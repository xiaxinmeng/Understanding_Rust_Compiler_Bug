{"sha": "0012af695eb81f2ab5dfb787383df5415e8cfba1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMTJhZjY5NWViODFmMmFiNWRmYjc4NzM4M2RmNTQxNWU4Y2ZiYTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-08T22:41:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-08T22:41:20Z"}, "message": "trait-ize binary_float_op", "tree": {"sha": "1684814233ec6655066f41fe1e34163b1a1a04e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1684814233ec6655066f41fe1e34163b1a1a04e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0012af695eb81f2ab5dfb787383df5415e8cfba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0012af695eb81f2ab5dfb787383df5415e8cfba1", "html_url": "https://github.com/rust-lang/rust/commit/0012af695eb81f2ab5dfb787383df5415e8cfba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0012af695eb81f2ab5dfb787383df5415e8cfba1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0803d75eb6083111504e9bae4fa6baf9104928fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0803d75eb6083111504e9bae4fa6baf9104928fe", "html_url": "https://github.com/rust-lang/rust/commit/0803d75eb6083111504e9bae4fa6baf9104928fe"}], "stats": {"total": 93, "additions": 49, "deletions": 44}, "files": [{"sha": "35663c4f014885ada2d22e81ba5dc84aa80daf17", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0012af695eb81f2ab5dfb787383df5415e8cfba1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0012af695eb81f2ab5dfb787383df5415e8cfba1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=0012af695eb81f2ab5dfb787383df5415e8cfba1", "patch": "@@ -132,6 +132,20 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n     }\n }\n \n+impl<Tag> From<Single> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(f: Single) -> Self {\n+        Scalar::from_f32(f)\n+    }\n+}\n+\n+impl<Tag> From<Double> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(f: Double) -> Self {\n+        Scalar::from_f64(f)\n+    }\n+}\n+\n impl<'tcx> Scalar<()> {\n     #[inline(always)]\n     fn check_data(data: u128, size: u8) {"}, {"sha": "dd04a8b3c3056b7017c812634f54205e239a0941", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0012af695eb81f2ab5dfb787383df5415e8cfba1/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0012af695eb81f2ab5dfb787383df5415e8cfba1/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=0012af695eb81f2ab5dfb787383df5415e8cfba1", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -55,15 +55,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return Ok((Scalar::from_bool(res), false));\n+        return (Scalar::from_bool(res), false);\n     }\n \n     fn binary_bool_op(\n         &self,\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -78,44 +78,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return Ok((Scalar::from_bool(res), false));\n+        return (Scalar::from_bool(res), false);\n     }\n \n-    fn binary_float_op(\n+    fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n         &self,\n         bin_op: mir::BinOp,\n-        fty: FloatTy,\n-        // passing in raw bits\n-        l: u128,\n-        r: u128,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+        l: F,\n+        r: F,\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n-        macro_rules! float_math {\n-            ($ty:path, $from_float:ident) => {{\n-                let l = <$ty>::from_bits(l);\n-                let r = <$ty>::from_bits(r);\n-                let val = match bin_op {\n-                    Eq => Scalar::from_bool(l == r),\n-                    Ne => Scalar::from_bool(l != r),\n-                    Lt => Scalar::from_bool(l < r),\n-                    Le => Scalar::from_bool(l <= r),\n-                    Gt => Scalar::from_bool(l > r),\n-                    Ge => Scalar::from_bool(l >= r),\n-                    Add => Scalar::$from_float((l + r).value),\n-                    Sub => Scalar::$from_float((l - r).value),\n-                    Mul => Scalar::$from_float((l * r).value),\n-                    Div => Scalar::$from_float((l / r).value),\n-                    Rem => Scalar::$from_float((l % r).value),\n-                    _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n-                };\n-                return Ok((val, false));\n-            }};\n-        }\n-        match fty {\n-            FloatTy::F32 => float_math!(Single, from_f32),\n-            FloatTy::F64 => float_math!(Double, from_f64),\n-        }\n+        let val = match bin_op {\n+            Eq => Scalar::from_bool(l == r),\n+            Ne => Scalar::from_bool(l != r),\n+            Lt => Scalar::from_bool(l < r),\n+            Le => Scalar::from_bool(l <= r),\n+            Gt => Scalar::from_bool(l > r),\n+            Ge => Scalar::from_bool(l >= r),\n+            Add => (l + r).value.into(),\n+            Sub => (l - r).value.into(),\n+            Mul => (l * r).value.into(),\n+            Div => (l / r).value.into(),\n+            Rem => (l % r).value.into(),\n+            _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+        };\n+        return (val, false);\n     }\n \n     fn binary_int_op(\n@@ -284,21 +272,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         match left.layout.ty.sty {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?.to_char()?;\n-                let right = right.to_scalar()?.to_char()?;\n-                self.binary_char_op(bin_op, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(self.binary_char_op(bin_op, left.to_char()?, right.to_char()?))\n             }\n             ty::Bool => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?.to_bool()?;\n-                let right = right.to_scalar()?.to_bool()?;\n-                self.binary_bool_op(bin_op, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(self.binary_bool_op(bin_op, left.to_bool()?, right.to_bool()?))\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_bits()?;\n-                let right = right.to_bits()?;\n-                self.binary_float_op(bin_op, fty, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(match fty {\n+                    FloatTy::F32 => self.binary_float_op(bin_op, left.to_f32()?, right.to_f32()?),\n+                    FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n+                })\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers."}]}