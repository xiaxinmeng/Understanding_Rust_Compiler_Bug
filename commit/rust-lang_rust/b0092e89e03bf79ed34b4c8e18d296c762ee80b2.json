{"sha": "b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDkyZTg5ZTAzYmY3OWVkMzRiNGM4ZTE4ZDI5NmM3NjJlZTgwYjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T10:32:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T20:21:57Z"}, "message": "move queries code into transform", "tree": {"sha": "42798cd9437570d1dcf0d768b7435dcf2742cd02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42798cd9437570d1dcf0d768b7435dcf2742cd02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "html_url": "https://github.com/rust-lang/rust/commit/b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0092e89e03bf79ed34b4c8e18d296c762ee80b2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "393fa4f1b715234bfb8a80699668dada8a3880c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/393fa4f1b715234bfb8a80699668dada8a3880c7", "html_url": "https://github.com/rust-lang/rust/commit/393fa4f1b715234bfb8a80699668dada8a3880c7"}], "stats": {"total": 228, "additions": 99, "deletions": 129}, "files": [{"sha": "5fa56bac1379be8b120ab0e044d77bd4bee40877", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0092e89e03bf79ed34b4c8e18d296c762ee80b2/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0092e89e03bf79ed34b4c8e18d296c762ee80b2/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "patch": "@@ -49,14 +49,12 @@ pub mod diagnostics;\n mod build;\n mod hair;\n mod shim;\n-mod queries;\n pub mod transform;\n pub mod util;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n-    queries::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n }"}, {"sha": "3e12221f85234546b2319c71aa23c2ac520e3f13", "filename": "src/librustc_mir/queries.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/393fa4f1b715234bfb8a80699668dada8a3880c7/src%2Flibrustc_mir%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/393fa4f1b715234bfb8a80699668dada8a3880c7/src%2Flibrustc_mir%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fqueries.rs?ref=393fa4f1b715234bfb8a80699668dada8a3880c7", "patch": "@@ -1,121 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An experimental pass that scources for `#[rustc_mir]` attributes,\n-//! builds the resulting MIR, and dumps it out into a file for inspection.\n-//!\n-//! The attribute formats that are currently accepted are:\n-//!\n-//! - `#[rustc_mir(graphviz=\"file.gv\")]`\n-//! - `#[rustc_mir(pretty=\"file.mir\")]`\n-\n-use build;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::Mir;\n-use rustc::mir::transform::{MirSource, MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED};\n-use rustc::ty::{self, TyCtxt};\n-use rustc::ty::maps::Providers;\n-use rustc::ty::steal::Steal;\n-use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::util::nodemap::DefIdSet;\n-use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n-use transform;\n-\n-use std::rc::Rc;\n-\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        mir_keys,\n-        mir_const,\n-        mir_validated,\n-        optimized_mir,\n-        is_mir_available,\n-        ..*providers\n-    };\n-}\n-\n-fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-    tcx.mir_keys(def_id.krate).contains(&def_id)\n-}\n-\n-/// Finds the full set of def-ids within the current crate that have\n-/// MIR associated with them.\n-fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n-                      -> Rc<DefIdSet> {\n-    assert_eq!(krate, LOCAL_CRATE);\n-\n-    let mut set = DefIdSet();\n-\n-    // All body-owners have MIR associated with them.\n-    set.extend(tcx.body_owners());\n-\n-    // Additionally, tuple struct/variant constructors have MIR, but\n-    // they don't have a BodyId, so we need to build them separately.\n-    struct GatherCtors<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        set: &'a mut DefIdSet,\n-    }\n-    impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n-        fn visit_variant_data(&mut self,\n-                              v: &'tcx hir::VariantData,\n-                              _: ast::Name,\n-                              _: &'tcx hir::Generics,\n-                              _: ast::NodeId,\n-                              _: Span) {\n-            if let hir::VariantData::Tuple(_, node_id) = *v {\n-                self.set.insert(self.tcx.hir.local_def_id(node_id));\n-            }\n-            intravisit::walk_struct_def(self, v)\n-        }\n-        fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n-            NestedVisitorMap::None\n-        }\n-    }\n-    tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n-        tcx: tcx,\n-        set: &mut set,\n-    }.as_deep_visitor());\n-\n-    Rc::new(set)\n-}\n-\n-fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let mut mir = build::mir_build(tcx, def_id);\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    transform::run_suite(tcx, source, MIR_CONST, &mut mir);\n-    tcx.alloc_steal_mir(mir)\n-}\n-\n-fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    if let MirSource::Const(_) = source {\n-        // Ensure that we compute the `mir_const_qualif` for constants at\n-        // this point, before we steal the mir-const result. We don't\n-        // directly need the result or `mir_const_qualif`, so we can just force it.\n-        ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n-    }\n-\n-    let mut mir = tcx.mir_const(def_id).steal();\n-    transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n-    tcx.alloc_steal_mir(mir)\n-}\n-\n-fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n-    // Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    ty::queries::borrowck::force(tcx, DUMMY_SP, def_id);\n-\n-    let mut mir = tcx.mir_validated(def_id).steal();\n-    let source = MirSource::from_local_def_id(tcx, def_id);\n-    transform::run_suite(tcx, source, MIR_OPTIMIZED, &mut mir);\n-    tcx.alloc_mir(mir)\n-}"}, {"sha": "fcea5d4c86047cc6e05a5dd9fd4b2d34f6fa6b2e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 99, "deletions": 6, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b0092e89e03bf79ed34b4c8e18d296c762ee80b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0092e89e03bf79ed34b4c8e18d296c762ee80b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b0092e89e03bf79ed34b4c8e18d296c762ee80b2", "patch": "@@ -8,10 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use build;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::Mir;\n-use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource};\n-use rustc::ty::TyCtxt;\n+use rustc::mir::transform::{MirPassIndex, MirSuite, MirSource,\n+                            MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n+use rustc::ty::steal::Steal;\n+use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::util::nodemap::DefIdSet;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax_pos::{DUMMY_SP, Span};\n+use transform;\n \n pub mod simplify_branches;\n pub mod simplify;\n@@ -30,14 +41,96 @@ pub mod inline;\n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n     *providers = Providers {\n+        mir_keys,\n+        mir_const,\n+        mir_validated,\n+        optimized_mir,\n+        is_mir_available,\n         ..*providers\n     };\n }\n \n-pub(crate) fn run_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  source: MirSource,\n-                                  suite: MirSuite,\n-                                  mir: &mut Mir<'tcx>)\n+fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    tcx.mir_keys(def_id.krate).contains(&def_id)\n+}\n+\n+/// Finds the full set of def-ids within the current crate that have\n+/// MIR associated with them.\n+fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n+                      -> Rc<DefIdSet> {\n+    assert_eq!(krate, LOCAL_CRATE);\n+\n+    let mut set = DefIdSet();\n+\n+    // All body-owners have MIR associated with them.\n+    set.extend(tcx.body_owners());\n+\n+    // Additionally, tuple struct/variant constructors have MIR, but\n+    // they don't have a BodyId, so we need to build them separately.\n+    struct GatherCtors<'a, 'tcx: 'a> {\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        set: &'a mut DefIdSet,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n+        fn visit_variant_data(&mut self,\n+                              v: &'tcx hir::VariantData,\n+                              _: ast::Name,\n+                              _: &'tcx hir::Generics,\n+                              _: ast::NodeId,\n+                              _: Span) {\n+            if let hir::VariantData::Tuple(_, node_id) = *v {\n+                self.set.insert(self.tcx.hir.local_def_id(node_id));\n+            }\n+            intravisit::walk_struct_def(self, v)\n+        }\n+        fn nested_visit_map<'b>(&'b mut self) -> NestedVisitorMap<'b, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+    tcx.hir.krate().visit_all_item_likes(&mut GatherCtors {\n+        tcx: tcx,\n+        set: &mut set,\n+    }.as_deep_visitor());\n+\n+    Rc::new(set)\n+}\n+\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let mut mir = build::mir_build(tcx, def_id);\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_CONST, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    if let MirSource::Const(_) = source {\n+        // Ensure that we compute the `mir_const_qualif` for constants at\n+        // this point, before we steal the mir-const result. We don't\n+        // directly need the result or `mir_const_qualif`, so we can just force it.\n+        ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n+    }\n+\n+    let mut mir = tcx.mir_const(def_id).steal();\n+    transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);\n+    tcx.alloc_steal_mir(mir)\n+}\n+\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n+    // Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    ty::queries::borrowck::force(tcx, DUMMY_SP, def_id);\n+\n+    let mut mir = tcx.mir_validated(def_id).steal();\n+    let source = MirSource::from_local_def_id(tcx, def_id);\n+    transform::run_suite(tcx, source, MIR_OPTIMIZED, &mut mir);\n+    tcx.alloc_mir(mir)\n+}\n+\n+fn run_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       source: MirSource,\n+                       suite: MirSuite,\n+                       mir: &mut Mir<'tcx>)\n {\n     let passes = tcx.mir_passes.passes(suite);\n "}]}