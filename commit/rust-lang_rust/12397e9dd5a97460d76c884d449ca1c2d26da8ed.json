{"sha": "12397e9dd5a97460d76c884d449ca1c2d26da8ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMzk3ZTlkZDVhOTc0NjBkNzZjODg0ZDQ0OWNhMWMyZDI2ZGE4ZWQ=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T14:38:16Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T14:47:03Z"}, "message": "Make enum usage explicit and fix tests", "tree": {"sha": "b7d194c34c3ba67579303f34e5d5a1879f5755d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d194c34c3ba67579303f34e5d5a1879f5755d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12397e9dd5a97460d76c884d449ca1c2d26da8ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12397e9dd5a97460d76c884d449ca1c2d26da8ed", "html_url": "https://github.com/rust-lang/rust/commit/12397e9dd5a97460d76c884d449ca1c2d26da8ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12397e9dd5a97460d76c884d449ca1c2d26da8ed/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c951882c7364c672fe127f61d25b458e810572ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c951882c7364c672fe127f61d25b458e810572ff", "html_url": "https://github.com/rust-lang/rust/commit/c951882c7364c672fe127f61d25b458e810572ff"}], "stats": {"total": 450, "additions": 289, "deletions": 161}, "files": [{"sha": "bb5b0d1da533772299e42d04ddf1edd2017770f6", "filename": "src/libtest/bench.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fbench.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,6 +1,11 @@\n //! Benchmarking module.\n use super::{\n-    BenchMode, MonitorMsg, Sender, Sink, TestDesc, TestResult\n+    event::CompletedTest,\n+    helpers::sink::Sink,\n+    options::BenchMode,\n+    types::TestDesc,\n+    test_result::TestResult,\n+    Sender,\n };\n \n use crate::stats;\n@@ -182,7 +187,7 @@ where\n     }\n }\n \n-pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n+pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<CompletedTest>, nocapture: bool, f: F)\n where\n     F: FnMut(&mut Bencher),\n {\n@@ -195,8 +200,8 @@ where\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let oldio = if !nocapture {\n         Some((\n-            io::set_print(Some(Box::new(Sink(data.clone())))),\n-            io::set_panic(Some(Box::new(Sink(data.clone())))),\n+            io::set_print(Some(Sink::new_boxed(&data))),\n+            io::set_panic(Some(Sink::new_boxed(&data))),\n         ))\n     } else {\n         None\n@@ -235,7 +240,8 @@ where\n     };\n \n     let stdout = data.lock().unwrap().to_vec();\n-    monitor_ch.send((desc, test_result, None, stdout)).unwrap();\n+    let message = CompletedTest::new(desc, test_result, None, stdout);\n+    monitor_ch.send(message).unwrap();\n }\n \n pub fn run_once<F>(f: F)"}, {"sha": "2c14e9a1591c76fbb05c5853220a7564994e697b", "filename": "src/libtest/console.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,7 +1,7 @@\n //! Module providing interface for running tests in the console.\n \n use std::fs::File;\n-use std::io::prelude::*;\n+use std::io::prelude::Write;\n use std::io;\n \n use term;\n@@ -192,7 +192,8 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n-    fn callback(\n+    // A callback handling events that occure during test execution.\n+    fn on_test_event(\n         event: &TestEvent,\n         st: &mut ConsoleTestState,\n         out: &mut dyn OutputFormatter,\n@@ -205,9 +206,14 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             TestEvent::TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n             TestEvent::TeWait(ref test) => out.write_test_start(test),\n             TestEvent::TeTimeout(ref test) => out.write_timeout(test),\n-            TestEvent::TeResult(test, result, exec_time, stdout) => {\n-                st.write_log_result(&test, &result, exec_time.as_ref())?;\n-                out.write_result(&test, &result, exec_time.as_ref(), &*stdout, &st)?;\n+            TestEvent::TeResult(completed_test) => {\n+                let test = completed_test.desc;\n+                let result = &completed_test.result;\n+                let exec_time = &completed_test.exec_time;\n+                let stdout = completed_test.stdout;\n+\n+                st.write_log_result(&test, result, exec_time.as_ref())?;\n+                out.write_result(&test, result, exec_time.as_ref(), &*stdout, st)?;\n                 match result {\n                     TestResult::TrOk => {\n                         st.passed += 1;\n@@ -280,7 +286,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         }\n     }\n \n-    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n+    run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n \n     assert!(st.current_test_count() == st.total);\n "}, {"sha": "e1b606149c50550d8214dcaf5e35552c607de598", "filename": "src/libtest/event.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fevent.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -5,11 +5,32 @@ use super::types::TestDesc;\n use super::test_result::TestResult;\n use super::time::TestExecTime;\n \n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n+pub struct CompletedTest {\n+    pub desc: TestDesc,\n+    pub result: TestResult,\n+    pub exec_time: Option<TestExecTime>,\n+    pub stdout: Vec<u8>,\n+}\n+\n+impl CompletedTest {\n+    pub fn new(desc: TestDesc, result: TestResult, exec_time: Option<TestExecTime>, stdout: Vec<u8>) -> Self {\n+        Self {\n+            desc,\n+            result,\n+            exec_time,\n+            stdout,\n+        }\n+    }\n+}\n+\n+unsafe impl Send for CompletedTest {}\n+\n+#[derive(Debug, Clone)]\n pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc),\n-    TeResult(TestDesc, TestResult, Option<TestExecTime>, Vec<u8>),\n+    TeResult(CompletedTest),\n     TeTimeout(TestDesc),\n     TeFilteredOut(usize),\n }"}, {"sha": "fc677036dabf21484020c74bde8e1bf603ba4b81", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,5 +1,16 @@\n-use super::*;\n-use super::console::{ConsoleTestState, OutputLocation};\n+use std::{\n+    io,\n+    io::prelude::Write,\n+    borrow::Cow,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState, OutputLocation},\n+};\n+use super::OutputFormatter;\n \n pub(crate) struct JsonFormatter<T> {\n     out: OutputLocation<T>,\n@@ -81,21 +92,21 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         stdout: &[u8],\n         state: &ConsoleTestState,\n     ) -> io::Result<()> {\n-        let stdout = if (state.options.display_output || *result != TrOk) && stdout.len() > 0 {\n+        let stdout = if (state.options.display_output || *result != TestResult::TrOk) && stdout.len() > 0 {\n             Some(String::from_utf8_lossy(stdout))\n         } else {\n             None\n         };\n         match *result {\n-            TrOk => {\n+            TestResult::TrOk => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"ok\", exec_time, stdout, None)\n             }\n \n-            TrFailed => {\n+            TestResult::TrFailed => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", exec_time, stdout, None)\n             }\n \n-            TrTimedFail => self.write_event(\n+            TestResult::TrTimedFail => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n@@ -104,7 +115,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 Some(r#\"\"reason\": \"time limit exceeded\"\"#),\n             ),\n \n-            TrFailedMsg(ref m) => self.write_event(\n+            TestResult::TrFailedMsg(ref m) => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"failed\",\n@@ -113,11 +124,11 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 Some(&*format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n             ),\n \n-            TrIgnored => {\n+            TestResult::TrIgnored => {\n                 self.write_event(\"test\", desc.name.as_slice(), \"ignored\", exec_time, stdout, None)\n             }\n \n-            TrAllowedFail => self.write_event(\n+            TestResult::TrAllowedFail => self.write_event(\n                 \"test\",\n                 desc.name.as_slice(),\n                 \"allowed_failure\",\n@@ -126,7 +137,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 None,\n             ),\n \n-            TrBench(ref bs) => {\n+            TestResult::TrBench(ref bs) => {\n                 let median = bs.ns_iter_summ.median as usize;\n                 let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n "}, {"sha": "b6649a3effc7c6ea048ac668969cfaa13c7b6d7c", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,5 +1,14 @@\n-use super::*;\n-use super::console::ConsoleTestState;\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::{TestDesc, TestName},\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState},\n+};\n \n mod pretty;\n mod json;"}, {"sha": "2fdbc63d51330eb7f464d0849ee20d83566bc717", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,5 +1,16 @@\n-use super::*;\n-use super::console::{ConsoleTestState, OutputLocation};\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    console::{ConsoleTestState, OutputLocation},\n+    bench::fmt_bench_samples,\n+};\n+use super::OutputFormatter;\n \n pub(crate) struct PrettyFormatter<T> {\n     out: OutputLocation<T>,\n@@ -204,15 +215,15 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         }\n \n         match *result {\n-            TrOk => self.write_ok()?,\n-            TrFailed | TrFailedMsg(_) => self.write_failed()?,\n-            TrIgnored => self.write_ignored()?,\n-            TrAllowedFail => self.write_allowed_fail()?,\n-            TrBench(ref bs) => {\n+            TestResult::TrOk => self.write_ok()?,\n+            TestResult::TrFailed | TestResult::TrFailedMsg(_) => self.write_failed()?,\n+            TestResult::TrIgnored => self.write_ignored()?,\n+            TestResult::TrAllowedFail => self.write_allowed_fail()?,\n+            TestResult::TrBench(ref bs) => {\n                 self.write_bench()?;\n                 self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n             }\n-            TrTimedFail => self.write_time_failed()?,\n+            TestResult::TrTimedFail => self.write_time_failed()?,\n         }\n \n         self.write_time(desc, exec_time)?;"}, {"sha": "90eb62251fb42c6f64d72d54415ad9f384c9f358", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,5 +1,20 @@\n-use super::*;\n-use super::console::{ConsoleTestState, OutputLocation};\n+use std::{\n+    io,\n+    io::prelude::Write,\n+};\n+\n+use crate::{\n+    types::TestDesc,\n+    time,\n+    test_result::TestResult,\n+    types::NamePadding,\n+    console::{ConsoleTestState, OutputLocation},\n+    bench::fmt_bench_samples,\n+};\n+use super::OutputFormatter;\n+\n+// insert a '\\n' after 100 tests in quiet mode\n+const QUIET_MODE_MAX_COLUMN: usize = 100;\n \n pub(crate) struct TerseFormatter<T> {\n     out: OutputLocation<T>,\n@@ -164,7 +179,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         // in order to indicate benchmarks.\n         // When running benchmarks, terse-mode should still print their name as if\n         // it is the Pretty formatter.\n-        if !self.is_multithreaded && desc.name.padding() == PadOnRight {\n+        if !self.is_multithreaded && desc.name.padding() == NamePadding::PadOnRight {\n             self.write_test_name(desc)?;\n         }\n \n@@ -180,11 +195,11 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         _: &ConsoleTestState,\n     ) -> io::Result<()> {\n         match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) | TrTimedFail => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n-            TrBench(ref bs) => {\n+            TestResult::TrOk => self.write_ok(),\n+            TestResult::TrFailed | TestResult::TrFailedMsg(_) | TestResult::TrTimedFail => self.write_failed(),\n+            TestResult::TrIgnored => self.write_ignored(),\n+            TestResult::TrAllowedFail => self.write_allowed_fail(),\n+            TestResult::TrBench(ref bs) => {\n                 if self.is_multithreaded {\n                     self.write_test_name(desc)?;\n                 }"}, {"sha": "831bef3b118ac1500f695885c0a9795faf77485d", "filename": "src/libtest/helpers/exit_code.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fexit_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fexit_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fexit_code.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -0,0 +1,20 @@\n+//! Helper module to detect subprocess exit code.\n+\n+use std::process::ExitStatus;\n+\n+#[cfg(not(unix))]\n+pub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    status.code().ok_or(\"received no exit code from child process\".into())\n+}\n+\n+#[cfg(unix)]\n+pub fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    use std::os::unix::process::ExitStatusExt;\n+    match status.code() {\n+        Some(code) => Ok(code),\n+        None => match status.signal() {\n+            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n+            None => Err(\"child process exited with unknown signal\".into()),\n+        }\n+    }\n+}"}, {"sha": "6a2ef6086cb92b55273655c8078ca93d79b6fc47", "filename": "src/libtest/helpers/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fmod.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -4,3 +4,5 @@\n pub mod concurrency;\n pub mod isatty;\n pub mod metrics;\n+pub mod sink;\n+pub mod exit_code;"}, {"sha": "aa7fe2487730e3aa28b451ef91bd35103fda7aea", "filename": "src/libtest/helpers/sink.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fsink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fhelpers%2Fsink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fhelpers%2Fsink.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -0,0 +1,24 @@\n+//! Module providing a helper structure to capture output in subprocesses.\n+\n+use std::{\n+    io,\n+    io::prelude::Write,\n+    sync::{Arc, Mutex},\n+};\n+\n+pub struct Sink(Arc<Mutex<Vec<u8>>>);\n+\n+impl Sink {\n+    pub fn new_boxed(data: &Arc<Mutex<Vec<u8>>>) -> Box<Self> {\n+        Box::new(Self(data.clone()))\n+    }\n+}\n+\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}"}, {"sha": "31da97b736a297423425394efe22ca305ff93d3e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 90, "deletions": 94, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -30,38 +30,21 @@\n #![feature(termination_trait_lib)]\n #![feature(test)]\n \n+// Public reexports\n pub use self::ColorConfig::*;\n-use self::event::TestEvent::*;\n+pub use self::types::*;\n pub use self::types::TestName::*;\n+pub use self::options::{Options, ShouldPanic};\n \n-use std::borrow::Cow;\n-use std::env;\n-use std::io;\n-use std::io::prelude::*;\n-use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n-use std::process;\n-use std::process::{ExitStatus, Command, Termination};\n-use std::sync::mpsc::{channel, Sender};\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-use std::time::{Duration, Instant};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n-\n-const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n-\n-// to be used by rustc to compile tests in libtest\n+// Module to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use crate::{\n         bench::Bencher,\n         cli::{parse_opts, TestOpts},\n         helpers::metrics::{Metric, MetricMap},\n         options::{ShouldPanic, Options, RunIgnored, RunStrategy},\n         test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n-        time::TestTimeOptions,\n+        time::{TestTimeOptions, TestExecTime},\n         types::{\n             DynTestFn, DynTestName, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn,\n             TestName, TestType,\n@@ -70,18 +53,21 @@ pub mod test {\n     };\n }\n \n-use bench::*;\n-use test_result::*;\n-use types::*;\n-use options::*;\n-use cli::*;\n-use event::*;\n-\n-use helpers::concurrency::get_concurrency;\n+use std::{\n+    env,\n+    io,\n+    io::prelude::Write,\n+    panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n+    process,\n+    process::{Command, Termination},\n+    sync::mpsc::{channel, Sender},\n+    sync::{Arc, Mutex},\n+    thread,\n+    time::{Duration, Instant},\n+};\n \n-mod formatters;\n pub mod stats;\n-\n+mod formatters;\n mod cli;\n mod console;\n mod event;\n@@ -92,14 +78,31 @@ mod options;\n mod bench;\n mod test_result;\n \n+#[cfg(test)]\n+mod tests;\n+\n+use test_result::*;\n+use time::TestExecTime;\n+use options::{RunStrategy, Concurrent, RunIgnored, ColorConfig};\n+use event::{CompletedTest, TestEvent};\n+use cli::TestOpts;\n+use helpers::sink::Sink;\n+use helpers::concurrency::get_concurrency;\n+use helpers::exit_code::get_exit_code;\n+\n+// Process exit code to be used to indicate test failures.\n+const ERROR_EXIT_CODE: i32 = 101;\n+\n+const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n+\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Options>) {\n-    let mut opts = match parse_opts(args) {\n+    let mut opts = match cli::parse_opts(args) {\n         Some(Ok(o)) => o,\n         Some(Err(msg)) => {\n             eprintln!(\"error: {}\", msg);\n-            process::exit(101);\n+            process::exit(ERROR_EXIT_CODE);\n         }\n         None => return,\n     };\n@@ -109,15 +112,15 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     if opts.list {\n         if let Err(e) = console::list_tests_console(&opts, tests) {\n             eprintln!(\"error: io error when listing tests: {:?}\", e);\n-            process::exit(101);\n+            process::exit(ERROR_EXIT_CODE);\n         }\n     } else {\n         match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n-            Ok(false) => process::exit(101),\n+            Ok(false) => process::exit(ERROR_EXIT_CODE),\n             Err(e) => {\n                 eprintln!(\"error: io error when listing tests: {:?}\", e);\n-                process::exit(101);\n+                process::exit(ERROR_EXIT_CODE);\n             }\n         }\n     }\n@@ -196,19 +199,7 @@ pub fn assert_test_result<T: Termination>(result: T) {\n     );\n }\n \n-pub type MonitorMsg = (TestDesc, TestResult, Option<time::TestExecTime>, Vec<u8>);\n-\n-struct Sink(Arc<Mutex<Vec<u8>>>);\n-impl Write for Sink {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        Write::write(&mut *self.0.lock().unwrap(), data)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n+pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut notify_about_test_event: F) -> io::Result<()>\n where\n     F: FnMut(TestEvent) -> io::Result<()>,\n {\n@@ -236,11 +227,13 @@ where\n     };\n \n     let filtered_out = tests_len - filtered_tests.len();\n-    callback(TeFilteredOut(filtered_out))?;\n+    let event = TestEvent::TeFilteredOut(filtered_out);\n+    notify_about_test_event(event)?;\n \n     let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n \n-    callback(TeFiltered(filtered_descs))?;\n+    let event = TestEvent::TeFiltered(filtered_descs);\n+    notify_about_test_event(event)?;\n \n     let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n         filtered_tests.into_iter().partition(|e| match e.testfn {\n@@ -254,7 +247,7 @@ where\n     remaining.reverse();\n     let mut pending = 0;\n \n-    let (tx, rx) = channel::<MonitorMsg>();\n+    let (tx, rx) = channel::<CompletedTest>();\n     let run_strategy = if opts.options.panic_abort {\n         RunStrategy::SpawnPrimary\n     } else {\n@@ -295,18 +288,23 @@ where\n     if concurrency == 1 {\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n-            callback(TeWait(test.desc.clone()))?;\n+            let event = TestEvent::TeWait(test.desc.clone());\n+            notify_about_test_event(event)?;\n             run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n-            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, exec_time, stdout))?;\n+            let completed_test = rx.recv().unwrap();\n+\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n         }\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n             while pending < concurrency && !remaining.is_empty() {\n                 let test = remaining.pop().unwrap();\n                 let timeout = time::get_default_test_timeout();\n                 running_tests.insert(test.desc.clone(), timeout);\n-                callback(TeWait(test.desc.clone()))?; //here no pad\n+\n+                let event = TestEvent::TeWait(test.desc.clone());\n+                notify_about_test_event(event)?; //here no pad\n                 run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n@@ -316,32 +314,44 @@ where\n                 if let Some(timeout) = calc_timeout(&running_tests) {\n                     res = rx.recv_timeout(timeout);\n                     for test in get_timed_out_tests(&mut running_tests) {\n-                        callback(TeTimeout(test))?;\n+                        let event = TestEvent::TeTimeout(test);\n+                        notify_about_test_event(event)?;\n                     }\n-                    if res != Err(RecvTimeoutError::Timeout) {\n-                        break;\n+\n+                    match res {\n+                        Err(RecvTimeoutError::Timeout) => {\n+                            // Result is not yet ready, continue waiting.\n+                        }\n+                        _ => {\n+                            // We've got a result, stop the loop.\n+                            break;\n+                        }            \n                     }\n                 } else {\n                     res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n                     break;\n                 }\n             }\n \n-            let (desc, result, exec_time, stdout) = res.unwrap();\n-            running_tests.remove(&desc);\n+            let completed_test = res.unwrap();\n+            running_tests.remove(&completed_test.desc);\n \n-            callback(TeResult(desc, result, exec_time, stdout))?;\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n             pending -= 1;\n         }\n     }\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n-            callback(TeWait(b.desc.clone()))?;\n+            let event = TestEvent::TeWait(b.desc.clone());\n+            notify_about_test_event(event)?;\n             run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n-            let (test, result, exec_time, stdout) = rx.recv().unwrap();\n-            callback(TeResult(test, result, exec_time, stdout))?;\n+            let completed_test = rx.recv().unwrap();\n+\n+            let event = TestEvent::TeResult(completed_test);\n+            notify_about_test_event(event)?;\n         }\n     }\n     Ok(())\n@@ -420,7 +430,7 @@ pub fn run_test(\n     force_ignore: bool,\n     test: TestDescAndFn,\n     strategy: RunStrategy,\n-    monitor_ch: Sender<MonitorMsg>,\n+    monitor_ch: Sender<CompletedTest>,\n     concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n@@ -430,7 +440,8 @@ pub fn run_test(\n         && (cfg!(target_arch = \"wasm32\") || cfg!(target_os = \"emscripten\"));\n \n     if force_ignore || desc.ignore || ignore_because_no_process_support {\n-        monitor_ch.send((desc, TrIgnored, None, Vec::new())).unwrap();\n+        let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n+        monitor_ch.send(message).unwrap();\n         return;\n     }\n \n@@ -443,7 +454,7 @@ pub fn run_test(\n \n     fn run_test_inner(\n         desc: TestDesc,\n-        monitor_ch: Sender<MonitorMsg>,\n+        monitor_ch: Sender<CompletedTest>,\n         testfn: Box<dyn FnOnce() + Send>,\n         opts: TestRunOpts,\n     ) {\n@@ -530,16 +541,16 @@ fn run_test_in_process(\n     nocapture: bool,\n     report_time: bool,\n     testfn: Box<dyn FnOnce() + Send>,\n-    monitor_ch: Sender<MonitorMsg>,\n+    monitor_ch: Sender<CompletedTest>,\n     time_opts: Option<time::TestTimeOptions>,\n ) {\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n     let oldio = if !nocapture {\n         Some((\n-            io::set_print(Some(Box::new(Sink(data.clone())))),\n-            io::set_panic(Some(Box::new(Sink(data.clone())))),\n+            io::set_print(Some(Sink::new_boxed(&data))),\n+            io::set_panic(Some(Sink::new_boxed(&data))),\n         ))\n     } else {\n         None\n@@ -553,7 +564,7 @@ fn run_test_in_process(\n     let result = catch_unwind(AssertUnwindSafe(testfn));\n     let exec_time = start.map(|start| {\n         let duration = start.elapsed();\n-        time::TestExecTime(duration)\n+        TestExecTime(duration)\n     });\n \n     if let Some((printio, panicio)) = oldio {\n@@ -566,13 +577,14 @@ fn run_test_in_process(\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap().to_vec();\n-    monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n+    let message = CompletedTest::new(desc.clone(), test_result, exec_time, stdout);\n+    monitor_ch.send(message).unwrap();\n }\n \n fn spawn_test_subprocess(\n     desc: TestDesc,\n     report_time: bool,\n-    monitor_ch: Sender<MonitorMsg>,\n+    monitor_ch: Sender<CompletedTest>,\n     time_opts: Option<time::TestTimeOptions>,\n ) {\n     let (result, test_output, exec_time) = (|| {\n@@ -595,7 +607,7 @@ fn spawn_test_subprocess(\n             };\n         let exec_time = start.map(|start| {\n             let duration = start.elapsed();\n-            time::TestExecTime(duration)\n+            TestExecTime(duration)\n         });\n \n         let std::process::Output { stdout, stderr, status } = output;\n@@ -617,7 +629,8 @@ fn spawn_test_subprocess(\n         (result, test_output, exec_time)\n     })();\n \n-    monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n+    let message = CompletedTest::new(desc.clone(), result, exec_time, test_output);\n+    monitor_ch.send(message).unwrap();\n }\n \n fn run_test_in_spawned_subprocess(\n@@ -653,20 +666,3 @@ fn run_test_in_spawned_subprocess(\n     record_result(None);\n     unreachable!(\"panic=abort callback should have exited the process\")\n }\n-\n-#[cfg(not(unix))]\n-fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n-    status.code().ok_or(\"received no exit code from child process\".into())\n-}\n-\n-#[cfg(unix)]\n-fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n-    use std::os::unix::process::ExitStatusExt;\n-    match status.code() {\n-        Some(code) => Ok(code),\n-        None => match status.signal() {\n-            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n-            None => Err(\"child process exited with unknown signal\".into()),\n-        }\n-    }\n-}"}, {"sha": "eaf41bc9e22559f1cf867c9614ff2903988487aa", "filename": "src/libtest/stats/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -4,7 +4,7 @@ extern crate test;\n use std::f64;\n use std::io::prelude::*;\n use std::io;\n-use self::test::Bencher;\n+use self::test::test::Bencher;\n \n // Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n "}, {"sha": "f6470b40a391d65f3d8b9013a9d65894afa0c5a1", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -1,11 +1,18 @@\n use super::*;\n \n-use crate::test::{\n-    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n-    // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n-    // TestType, TrFailedMsg, TrIgnored, TrOk,\n-    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts,\n-    TrIgnored, TrOk,\n+use crate::{\n+    bench::Bencher,\n+    console::OutputLocation,\n+    options::OutputFormat,\n+    time::{TimeThreshold, TestTimeOptions},\n+    formatters::PrettyFormatter,\n+    test::{\n+        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n+        // ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TestTimeOptions,\n+        // TestType, TrFailedMsg, TrIgnored, TrOk,\n+        ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts,\n+        TrIgnored, TrOk,\n+    },\n };\n use std::sync::mpsc::channel;\n use std::time::Duration;\n@@ -74,8 +81,8 @@ pub fn do_not_run_ignored_tests() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res != TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result != TrOk);\n }\n \n #[test]\n@@ -93,8 +100,8 @@ pub fn ignored_tests_result_in_ignored() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrIgnored);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrIgnored);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again\n@@ -116,8 +123,8 @@ fn test_should_panic() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrOk);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again\n@@ -139,8 +146,8 @@ fn test_should_panic_good_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrOk);\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrOk);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again\n@@ -165,8 +172,8 @@ fn test_should_panic_bad_message() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again\n@@ -186,8 +193,8 @@ fn test_should_panic_but_succeeds() {\n     };\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n+    let result = rx.recv().unwrap().result;\n+    assert!(result == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n@@ -214,7 +221,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n     };\n     let (tx, rx) = channel();\n     run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, _, exec_time, _) = rx.recv().unwrap();\n+    let exec_time = rx.recv().unwrap().exec_time;\n     exec_time\n }\n \n@@ -252,7 +259,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n     };\n     let (tx, rx) = channel();\n     run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let (_, result, _, _) = rx.recv().unwrap();\n+    let result = rx.recv().unwrap().result;\n \n     result\n }\n@@ -658,9 +665,9 @@ fn should_sort_failures_before_printing_them() {\n         test_type: TestType::Unknown,\n     };\n \n-    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false, None);\n+    let mut out = PrettyFormatter::new(OutputLocation::Raw(Vec::new()), false, 10, false, None);\n \n-    let st = ConsoleTestState {\n+    let st = console::ConsoleTestState {\n         log_out: None,\n         total: 0,\n         passed: 0,\n@@ -678,8 +685,8 @@ fn should_sort_failures_before_printing_them() {\n \n     out.write_failures(&st).unwrap();\n     let s = match out.output_location() {\n-        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        &Pretty(_) => unreachable!(),\n+        &OutputLocation::Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &OutputLocation::Pretty(_) => unreachable!(),\n     };\n \n     let apos = s.find(\"a\").unwrap();"}, {"sha": "83a545470efaaf658010d08346852d6429a5a9ef", "filename": "src/libtest/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12397e9dd5a97460d76c884d449ca1c2d26da8ed/src%2Flibtest%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftime.rs?ref=12397e9dd5a97460d76c884d449ca1c2d26da8ed", "patch": "@@ -61,7 +61,7 @@ pub fn get_default_test_timeout() -> Instant {\n }\n \n /// The meassured execution time of a unit test.\n-#[derive(Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq)]\n pub struct TestExecTime(pub Duration);\n \n impl fmt::Display for TestExecTime {"}]}