{"sha": "92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "node_id": "C_kwDOAAsO6NoAKDkyYzgzMTdkMmFlNDVhODZiNjMyYjI0OTk2Y2QyOWEzMGQwZGMzY2U", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-12-03T02:04:33Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-12-03T02:14:37Z"}, "message": "Add `[T]::as_simd(_mut)`\n\nSIMD-style optimizations are the most common use for `[T]::align_to(_mut)`, but that's `unsafe`.  So these are *safe* wrappers around it, now that we have the `Simd` type available, to make it easier to use.\n\n```rust\nimpl [T] {\n    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T]);\n    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T]);\n}\n```", "tree": {"sha": "bedcfc1d0be8f146cf69e48eccea475b42275acf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bedcfc1d0be8f146cf69e48eccea475b42275acf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "html_url": "https://github.com/rust-lang/rust/commit/92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92c8317d2ae45a86b632b24996cd29a30d0dc3ce/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff23ad3179014ba258f2b540fb39dd0f26852b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff23ad3179014ba258f2b540fb39dd0f26852b7a", "html_url": "https://github.com/rust-lang/rust/commit/ff23ad3179014ba258f2b540fb39dd0f26852b7a"}], "stats": {"total": 83, "additions": 83, "deletions": 0}, "files": [{"sha": "7797ae6d49ff20f02f468ec7b55bc96f567c11c8", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/92c8317d2ae45a86b632b24996cd29a30d0dc3ce/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c8317d2ae45a86b632b24996cd29a30d0dc3ce/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "patch": "@@ -16,6 +16,8 @@ use crate::option::Option::{None, Some};\n use crate::ptr;\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n+#[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+use crate::simd::{self, Simd};\n use crate::slice;\n \n #[unstable(\n@@ -3434,6 +3436,87 @@ impl<T> [T] {\n         }\n     }\n \n+    /// Split a slice into a prefix, a middle of aligned simd types, and a suffix.\n+    ///\n+    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n+    /// preconditions as that method.  Notably, you must not assume any particular\n+    /// split between the three parts: it's legal for the middle slice to be\n+    /// empty even if the input slice is longer than `3 * LANES`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    ///\n+    /// let short = &[1, 2, 3];\n+    /// let (prefix, middle, suffix) = short.as_simd::<4>();\n+    /// assert_eq!(middle, []); // Not enough elements for anything in the middle\n+    ///\n+    /// // They might be split in any possible way between prefix and suffix\n+    /// let it = prefix.iter().chain(suffix).copied();\n+    /// assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n+    ///\n+    /// fn basic_simd_sum(x: &[f32]) -> f32 {\n+    ///     use std::ops::Add;\n+    ///     use std::simd::f32x4;\n+    ///     let (prefix, middle, suffix) = x.as_simd();\n+    ///     let sums = f32x4::from_array([\n+    ///         prefix.iter().copied().sum(),\n+    ///         0.0,\n+    ///         0.0,\n+    ///         suffix.iter().copied().sum(),\n+    ///     ]);\n+    ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n+    ///     sums.horizontal_sum()\n+    /// }\n+    ///\n+    /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n+    /// assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n+    /// ```\n+    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+    #[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T])\n+    where\n+        Simd<T, LANES>: AsRef<[T; LANES]>,\n+        T: simd::SimdElement,\n+        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+    {\n+        // These are expected to always match, as vector types are laid out like\n+        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+        // might as well double-check since it'll optimize away anyhow.\n+        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+\n+        // SAFETY: The simd types have the same layout as arrays, just with\n+        // potentially-higher alignment, so the de-facto transmutes are sound.\n+        unsafe { self.align_to() }\n+    }\n+\n+    /// Split a slice into a prefix, a middle of aligned simd types, and a suffix.\n+    ///\n+    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n+    /// preconditions as that method.  Notably, you must not assume any particular\n+    /// split between the three parts: it's legal for the middle slice to be\n+    /// empty even if the input slice is longer than `3 * LANES`.\n+    ///\n+    /// This is the mutable version of [`slice::as_simd`]; see that for more.\n+    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+    #[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])\n+    where\n+        Simd<T, LANES>: AsMut<[T; LANES]>,\n+        T: simd::SimdElement,\n+        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+    {\n+        // These are expected to always match, as vector types are laid out like\n+        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+        // might as well double-check since it'll optimize away anyhow.\n+        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+\n+        // SAFETY: The simd types have the same layout as arrays, just with\n+        // potentially-higher alignment, so the de-facto transmutes are sound.\n+        unsafe { self.align_to_mut() }\n+    }\n+\n     /// Checks if the elements of this slice are sorted.\n     ///\n     /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the"}]}