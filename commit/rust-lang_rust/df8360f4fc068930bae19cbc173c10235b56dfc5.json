{"sha": "df8360f4fc068930bae19cbc173c10235b56dfc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmODM2MGY0ZmMwNjg5MzBiYWUxOWNiYzE3M2MxMDIzNWI1NmRmYzU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:35:09Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:35:09Z"}, "message": "Rollup merge of #24281 - steveklabnik:lol_editing, r=alexcrichton\n\n more more more", "tree": {"sha": "cedc5b030ae2dc928260ee661313e36f5342a828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cedc5b030ae2dc928260ee661313e36f5342a828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df8360f4fc068930bae19cbc173c10235b56dfc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df8360f4fc068930bae19cbc173c10235b56dfc5", "html_url": "https://github.com/rust-lang/rust/commit/df8360f4fc068930bae19cbc173c10235b56dfc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df8360f4fc068930bae19cbc173c10235b56dfc5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87660562a6a0a809a6016c38e55181b9860e06db", "url": "https://api.github.com/repos/rust-lang/rust/commits/87660562a6a0a809a6016c38e55181b9860e06db", "html_url": "https://github.com/rust-lang/rust/commit/87660562a6a0a809a6016c38e55181b9860e06db"}, {"sha": "74b5c75d7427830c5fb1728448f0611e7a77bcff", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b5c75d7427830c5fb1728448f0611e7a77bcff", "html_url": "https://github.com/rust-lang/rust/commit/74b5c75d7427830c5fb1728448f0611e7a77bcff"}], "stats": {"total": 472, "additions": 161, "deletions": 311}, "files": [{"sha": "f2d1666048d89773cb3a5745616edc4e0dc7d30f", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -7,38 +7,39 @@\n * [Learn Rust](learn-rust.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n-    * [`Debug` and `Display`](debug-and-display.md)\n+    * [Debug and Display](debug-and-display.md)\n     * [Testing](testing.md)\n     * [Documentation](documentation.md)\n     * [Iterators](iterators.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n-    * [`Deref` coercions](deref-coercions.md)\n+    * [Deref coercions](deref-coercions.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)\n     * [Primitive Types](primitive-types.md)\n     * [Comments](comments.md)\n-    * [Structs](structs.md)\n-    * [Mutability](mutability.md)\n-    * [Method Syntax](method-syntax.md)\n-    * [Enums](enums.md)\n-    * [`if`](if.md)\n-    * [Match](match.md)\n-    * [Patterns](patterns.md)\n-    * [`for` loops](for-loops.md)\n-    * [`while` loops](while-loops.md)\n+    * [if](if.md)\n+    * [for loops](for-loops.md)\n+    * [while loops](while-loops.md)\n     * [Ownership](ownership.md)\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n+    * [Mutability](mutability.md)\n     * [Move semantics](move-semantics.md)\n+    * [Enums](enums.md)\n+    * [Match](match.md)\n+    * [Patterns](patterns.md)\n+    * [Structs](structs.md)\n+    * [Method Syntax](method-syntax.md)\n     * [Drop](drop.md)\n     * [Vectors](vectors.md)\n     * [Strings](strings.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n     * [Generics](generics.md)\n+    * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)\n     * [Universal Function Call Syntax](ufcs.md)\n@@ -63,5 +64,6 @@\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n+    * [Slice Patterns](slice-patterns.md)\n * [Glossary](glossary.md)\n * [Academic Research](academic-research.md)"}, {"sha": "918f4c440ac32d5901d65a8d9710d08c4403f062", "filename": "src/doc/trpl/debug-and-display.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,3 +1,3 @@\n-% `Debug` and `Display`\n+% Debug and Display\n \n Coming soon!"}, {"sha": "1e3f2fa54bcc6c292bef7912c1ea1699b8603dc5", "filename": "src/doc/trpl/for-loops.md", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffor-loops.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,44 +1,43 @@\n-% `for` Loops\n+% for Loops\n \n-The `for` loop is used to loop a particular number of times. Rust's `for` loops\n-work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C-style\" `for` loop:\n+The `for` loop is used to loop a particular number of times. Rust\u2019s `for` loops\n+work a bit differently than in other systems languages, however. Rust\u2019s `for`\n+loop doesn\u2019t look like this \u201cC-style\u201d `for` loop:\n \n-```{c}\n+```c\n for (x = 0; x < 10; x++) {\n     printf( \"%d\\n\", x );\n }\n ```\n \n Instead, it looks like this:\n \n-```{rust}\n+```rust\n for x in 0..10 {\n     println!(\"{}\", x); // x: i32\n }\n ```\n \n In slightly more abstract terms,\n \n-```{ignore}\n+```ignore\n for var in expression {\n     code\n }\n ```\n \n-The expression is an iterator, which we will discuss in more depth later in the\n-guide. The iterator gives back a series of elements. Each element is one\n-iteration of the loop. That value is then bound to the name `var`, which is\n-valid for the loop body. Once the body is over, the next value is fetched from\n-the iterator, and we loop another time. When there are no more values, the\n-`for` loop is over.\n+The expression is an [iterator][iterator]. The iterator gives back a series of\n+elements. Each element is one iteration of the loop. That value is then bound\n+to the name `var`, which is valid for the loop body. Once the body is over, the\n+next value is fetched from the iterator, and we loop another time. When there\n+are no more values, the `for` loop is over.\n+\n+[iterator]: iterators.html\n \n In our example, `0..10` is an expression that takes a start and an end position,\n and gives an iterator over those values. The upper bound is exclusive, though,\n so our loop will print `0` through `9`, not `10`.\n \n-Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n+Rust does not have the \u201cC-style\u201d `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n-\n-We'll talk more about `for` when we cover *iterators*, later in the Guide."}, {"sha": "9e010b020c1810faa30811880c72672a681eb906", "filename": "src/doc/trpl/if-let.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -0,0 +1,3 @@\n+% if let\n+\n+COMING SOON"}, {"sha": "a532dabf8d12d894a7b9f13e7d6081d7b2f2040e", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 12, "deletions": 96, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,10 +1,10 @@\n-% `if`\n+% if\n \n-Rust's take on `if` is not particularly complex, but it's much more like the\n-`if` you'll find in a dynamically typed language than in a more traditional\n-systems language. So let's talk about it, to make sure you grasp the nuances.\n+Rust\u2019s take on `if` is not particularly complex, but it\u2019s much more like the\n+`if` you\u2019ll find in a dynamically typed language than in a more traditional\n+systems language. So let\u2019s talk about it, to make sure you grasp the nuances.\n \n-`if` is a specific form of a more general concept, the *branch*. The name comes\n+`if` is a specific form of a more general concept, the \u2018branch\u2019. The name comes\n from a branch in a tree: a decision point, where depending on a choice,\n multiple paths can be taken.\n \n@@ -20,11 +20,11 @@ if x == 5 {\n \n If we changed the value of `x` to something else, this line would not print.\n More specifically, if the expression after the `if` evaluates to `true`, then\n-the block is executed. If it's `false`, then it is not.\n+the block is executed. If it\u2019s `false`, then it is not.\n \n If you want something to happen in the `false` case, use an `else`:\n \n-```{rust}\n+```rust\n let x = 5;\n \n if x == 5 {\n@@ -50,8 +50,7 @@ if x == 5 {\n \n This is all pretty standard. However, you can also do this:\n \n-\n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 {\n@@ -63,95 +62,12 @@ let y = if x == 5 {\n \n Which we can (and probably should) write like this:\n \n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 { 10 } else { 15 }; // y: i32\n ```\n \n-This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different from semicolons in other 'curly brace\n-and semicolon'-based languages. These two things are related.\n-\n-## Expressions vs. Statements\n-\n-Rust is primarily an expression based language. There are only two kinds of\n-statements, and everything else is an expression.\n-\n-So what's the difference? Expressions return a value, and statements do not.\n-In many languages, `if` is a statement, and therefore, `let x = if ...` would\n-make no sense. But in Rust, `if` is an expression, which means that it returns\n-a value. We can then use this value to initialize the binding.\n-\n-Speaking of which, bindings are a kind of the first of Rust's two statements.\n-The proper name is a *declaration statement*. So far, `let` is the only kind\n-of declaration statement we've seen. Let's talk about that some more.\n-\n-In some languages, variable bindings can be written as expressions, not just\n-statements. Like Ruby:\n-\n-```{ruby}\n-x = y = 5\n-```\n-\n-In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n-following will produce a compile-time error:\n-\n-```{ignore}\n-let x = (let y = 5); // expected identifier, found keyword `let`\n-```\n-\n-The compiler is telling us here that it was expecting to see the beginning of\n-an expression, and a `let` can only begin a statement, not an expression.\n-\n-Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n-expression, although its value is not particularly useful. Unlike C, where an\n-assignment evaluates to the assigned value (e.g. `5` in the previous example),\n-in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n-\n-The second kind of statement in Rust is the *expression statement*. Its\n-purpose is to turn any expression into a statement. In practical terms, Rust's\n-grammar expects statements to follow other statements. This means that you use\n-semicolons to separate expressions from each other. This means that Rust\n-looks a lot like most other languages that require you to use semicolons\n-at the end of every line, and you will see semicolons at the end of almost\n-every line of Rust code you see.\n-\n-What is this exception that makes us say \"almost\"? You saw it already, in this\n-code:\n-\n-```{rust}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10 } else { 15 };\n-```\n-\n-Note that I've added the type annotation to `y`, to specify explicitly that I\n-want `y` to be an integer.\n-\n-This is not the same as this, which won't compile:\n-\n-```{ignore}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10; } else { 15; };\n-```\n-\n-Note the semicolons after the 10 and 15. Rust will give us the following error:\n-\n-```text\n-error: mismatched types: expected `i32`, found `()` (expected i32, found ())\n-```\n-\n-We expected an integer, but we got `()`. `()` is pronounced *unit*, and is a\n-special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n-variable of type `i32`. It's only a valid value for variables of the type `()`,\n-which aren't very useful. Remember how we said statements don't return a value?\n-Well, that's the purpose of unit in this case. The semicolon turns any\n-expression into a statement by throwing away its value and returning unit\n-instead.\n-\n-There's one more time in which you won't see a semicolon at the end of a line\n-of Rust code. For that, we'll need our next concept: functions.\n-\n-TODO: `if let`\n+This works because `if` is an expression. The value of the expression is the\n+value of the last expression in whichever branch was chosen. An `if` without an\n+`else` always results in `()` as the value."}, {"sha": "33d603f326af3a19f09ef9182605ef207c44d04f", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 23, "deletions": 117, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,13 +1,13 @@\n % Match\n \n-Often, a simple `if`/`else` isn't enough, because you have more than two\n+Often, a simple `if`/`else` isn\u2019t enough, because you have more than two\n possible options. Also, `else` conditions can get incredibly complicated, so\n-what's the solution?\n+what\u2019s the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n@@ -21,11 +21,14 @@ match x {\n ```\n \n `match` takes an expression and then branches based on its value. Each *arm* of\n-the branch is of the form `val => expression`. When the value matches, that arm's\n-expression will be evaluated. It's called `match` because of the term 'pattern\n-matching', which `match` is an implementation of.\n+the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n+expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n+matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n+patterns][patterns] coming up next, that covers all the options that fit here.\n \n-So what's the big advantage here? Well, there are a few. First of all, `match`\n+[patterns]: patterns.html\n+\n+So what\u2019s the big advantage here? Well, there are a few. First of all, `match`\n enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n@@ -36,121 +39,24 @@ error: non-exhaustive patterns: `_` not covered\n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n integer, Rust knows that it can have a number of different values \u2013 for example,\n `6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a *catch-all arm*. If none of the other arms match,\n+to compile. `_` acts like a \u2018catch-all arm\u2019. If none of the other arms match,\n the arm with `_` will, and since we have this catch-all arm, we now have an arm\n for every possible value of `x`, and so our program will compile successfully.\n \n-`match` statements also destructure enums, as well. Remember this code from the\n-section on enums?\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y);\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-We can re-write this as a `match`:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    match cmp(x, y) {\n-        Ordering::Less => println!(\"less\"),\n-        Ordering::Greater => println!(\"greater\"),\n-        Ordering::Equal => println!(\"equal\"),\n-    }\n-}\n-```\n-\n-This version has way less noise, and it also checks exhaustively to make sure\n-that we have covered all possible variants of `Ordering`. With our `if`/`else`\n-version, if we had forgotten the `Greater` case, for example, our program would\n-have happily compiled. If we forget in the `match`, it will not. Rust helps us\n-make sure to cover all of our bases.\n-\n-`match` expressions also allow us to get the values contained in an `enum`\n-(also known as destructuring) as follows:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-fn main() {\n-    let x = OptionalInt::Value(5);\n-    let y = OptionalInt::Missing;\n-\n-    match x {\n-        OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing => println!(\"x is missing!\"),\n-    }\n-\n-    match y {\n-        OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing => println!(\"y is missing!\"),\n-    }\n-}\n-```\n-\n-That is how you can get and use the values contained in `enum`s.\n-It can also allow us to handle errors or unexpected computations; for example, a\n-function that is not guaranteed to be able to compute a result (an `i32` here)\n-could return an `OptionalInt`, and we would handle that value with a `match`.\n-As you can see, `enum` and `match` used together are quite useful!\n-\n `match` is also an expression, which means we can use it on the right-hand\n-side of a `let` binding or directly where an expression is used. We could\n-also implement the previous example like this:\n-\n-```{rust}\n-use std::cmp::Ordering;\n+side of a `let` binding or directly where an expression is used:\n \n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n+```rust\n+let x = 5;\n \n-    println!(\"{}\", match cmp(x, y) {\n-        Ordering::Less => \"less\",\n-        Ordering::Greater => \"greater\",\n-        Ordering::Equal => \"equal\",\n-    });\n-}\n+let numer = match x {\n+    1 => \"one\",\n+    2 => \"two\",\n+    3 => \"three\",\n+    4 => \"four\",\n+    5 => \"five\",\n+    _ => \"something else\",\n+};\n ```\n \n-Sometimes, it's a nice pattern.\n+Sometimes, it\u2019s a nice way of converting things."}, {"sha": "c88e3a0f9edf5f71564270e369c7233455ec2849", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,13 +1,16 @@\n % Patterns\n \n-We've made use of patterns a few times in the guide: first with `let` bindings,\n-then with `match` statements. Let's go on a whirlwind tour of all of the things\n-patterns can do!\n+Patterns are quite common in Rust. We use them in [variable\n+bindings][bindings], [match statements][match], and other places, too. Let\u2019s go\n+on a whirlwind tour of all of the things patterns can do!\n+\n+[bindings]: variable-bindings.html\n+[match]: match.html\n \n A quick refresher: you can match against literals directly, and `_` acts as an\n-*any* case:\n+\u2018any\u2019 case:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -18,9 +21,11 @@ match x {\n }\n ```\n \n+# Multiple patterns\n+\n You can match multiple patterns with `|`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -30,9 +35,11 @@ match x {\n }\n ```\n \n+# Ranges\n+\n You can match a range of values with `...`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -43,10 +50,12 @@ match x {\n \n Ranges are mostly used with integers and single characters.\n \n-If you're matching multiple things, via a `|` or a `...`, you can bind\n+# Bindings\n+\n+If you\u2019re matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -55,10 +64,12 @@ match x {\n }\n ```\n \n-If you're matching on an enum which has variants, you can use `..` to\n+# Ignoring variants\n+\n+If you\u2019re matching on an enum which has variants, you can use `..` to\n ignore the value and type in the variant:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -72,9 +83,11 @@ match x {\n }\n ```\n \n-You can introduce *match guards* with `if`:\n+# Guards\n+\n+You can introduce \u2018match guards\u2019 with `if`:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -89,47 +102,38 @@ match x {\n }\n ```\n \n-If you're matching on a pointer, you can use the same syntax as you declared it\n-with. First, `&`:\n-\n-```{rust}\n-let x = &5;\n-\n-match x {\n-    &val => println!(\"Got a value: {}\", val),\n-}\n-```\n-\n-Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n-would be `5`.\n+# ref and ref mut\n \n-If you want to get a reference, use the `ref` keyword:\n+If you want to get a [reference][ref], use the `ref` keyword:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n+[ref]: references-and-borrowing.html\n+\n Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n-```{rust}\n+```rust\n let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n }\n ```\n \n-If you have a struct, you can destructure it inside of a pattern:\n+# Destructuring\n+\n+If you have a compound data type, like a `struct`, you can destructure it\n+inside of a pattern:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -142,10 +146,9 @@ match origin {\n }\n ```\n \n-If we only care about some of the values, we don't have to give them all names:\n+If we only care about some of the values, we don\u2019t have to give them all names:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -160,8 +163,7 @@ match origin {\n \n You can do this kind of match on any member, not just the first:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -174,22 +176,16 @@ match origin {\n }\n ```\n \n-If you want to match against a slice or array, you can use `&`:\n+This \u2018destructuring\u2019 behavior works on any compound data type, like\n+[tuples][tuples] or [enums][enums].\n \n-```{rust}\n-# #![feature(slice_patterns)]\n-fn main() {\n-    let v = vec![\"match_this\", \"1\"];\n+[tuples]: primitive-types.html#tuples\n+[enums]: enums.html\n \n-    match &v[..] {\n-        [\"match_this\", second] => println!(\"The second element is {}\", second),\n-        _ => {},\n-    }\n-}\n-```\n+# Mix and Match\n \n-Whew! That's a lot of different ways to match things, and they can all be\n-mixed and matched, depending on what you're doing:\n+Whew! That\u2019s a lot of different ways to match things, and they can all be\n+mixed and matched, depending on what you\u2019re doing:\n \n ```{rust,ignore}\n match x {"}, {"sha": "4599333a77a05e88d326126621762f6f27c4388e", "filename": "src/doc/trpl/slice-patterns.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslice-patterns.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -0,0 +1,18 @@\n+% Slice patterns\n+\n+If you want to match against a slice or array, you can use `&` with the\n+`slice_patterns` feature:\n+\n+```rust\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let v = vec![\"match_this\", \"1\"];\n+\n+    match &v[..] {\n+        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        _ => {},\n+    }\n+}\n+```\n+"}, {"sha": "f2e2f6b6f49a7403048a36ff755ac18cf8119fc1", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/df8360f4fc068930bae19cbc173c10235b56dfc5/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=df8360f4fc068930bae19cbc173c10235b56dfc5", "patch": "@@ -1,53 +1,59 @@\n-% `while` loops\n+% while loops\n \n-The other kind of looping construct in Rust is the `while` loop. It looks like\n-this:\n+Rust also has a `while` loop. It looks like this:\n \n ```{rust}\n let mut x = 5; // mut x: u32\n let mut done = false; // mut done: bool\n \n while !done {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n }\n ```\n \n-`while` loops are the correct choice when you're not sure how many times\n+`while` loops are the correct choice when you\u2019re not sure how many times\n you need to loop.\n \n If you need an infinite loop, you may be tempted to write this:\n \n-```{rust,ignore}\n+```rust,ignore\n while true {\n ```\n \n However, Rust has a dedicated keyword, `loop`, to handle this case:\n \n-```{rust,ignore}\n+```rust,ignore\n loop {\n ```\n \n-Rust's control-flow analysis treats this construct differently than a\n-`while true`, since we know that it will always loop. The details of what\n-that _means_ aren't super important to understand at this stage, but in\n-general, the more information we can give to the compiler, the better it\n-can do with safety and code generation, so you should always prefer\n-`loop` when you plan to loop infinitely.\n+Rust\u2019s control-flow analysis treats this construct differently than a `while\n+true`, since we know that it will always loop. In general, the more information\n+we can give to the compiler, the better it can do with safety and code\n+generation, so you should always prefer `loop` when you plan to loop\n+infinitely.\n \n ## Ending iteration early\n \n-Let's take a look at that `while` loop we had earlier:\n+Let\u2019s take a look at that `while` loop we had earlier:\n \n-```{rust}\n+```rust\n let mut x = 5;\n let mut done = false;\n \n while !done {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n+\n+    if x % 5 == 0 {\n+        done = true;\n+    }\n }\n ```\n \n@@ -57,12 +63,14 @@ modifying iteration: `break` and `continue`.\n \n In this case, we can write the loop in a better way with `break`:\n \n-```{rust}\n+```rust\n let mut x = 5;\n \n loop {\n     x += x - 3;\n+\n     println!(\"{}\", x);\n+\n     if x % 5 == 0 { break; }\n }\n ```\n@@ -72,12 +80,14 @@ We now loop forever with `loop` and use `break` to break out early.\n `continue` is similar, but instead of ending the loop, goes to the next\n iteration. This will only print the odd numbers:\n \n-```{rust}\n+```rust\n for x in 0..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);\n }\n ```\n \n-Both `continue` and `break` are valid in both kinds of loops.\n+Both `continue` and `break` are valid in both `while` loops and [`for` loops][for].\n+\n+[for]: for-loops.html"}]}