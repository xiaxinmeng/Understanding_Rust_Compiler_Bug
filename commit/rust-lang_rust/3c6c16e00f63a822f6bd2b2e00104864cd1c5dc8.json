{"sha": "3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNmMxNmUwMGY2M2E4MjJmNmJkMmIyZTAwMTA0ODY0Y2QxYzVkYzg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-25T02:54:25Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-25T02:54:25Z"}, "message": "Rollup merge of #24729 - mdinger:reference_grammar, r=steveklabnik\n\nFrom https://github.com/rust-lang/rust/issues/24723#issuecomment-95636827 :\r\n\r\n> Yes, I've been meaning to just remove it in favor of GRAMMAR.md\r\n> - steveklabnik", "tree": {"sha": "a113e3fba4a29d657e1686afdc05fe7400cb72fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a113e3fba4a29d657e1686afdc05fe7400cb72fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "html_url": "https://github.com/rust-lang/rust/commit/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02194bc772e104516d6aec8610a5c52964c118a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/02194bc772e104516d6aec8610a5c52964c118a5", "html_url": "https://github.com/rust-lang/rust/commit/02194bc772e104516d6aec8610a5c52964c118a5"}, {"sha": "7089c5e79c33c9b4831f39058701fdea33d398ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7089c5e79c33c9b4831f39058701fdea33d398ce", "html_url": "https://github.com/rust-lang/rust/commit/7089c5e79c33c9b4831f39058701fdea33d398ce"}], "stats": {"total": 380, "additions": 32, "deletions": 348}, "files": [{"sha": "542815e7afe3ce8522cf278692e2bacfd0f1c1a0", "filename": "src/doc/grammar.md", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "patch": "@@ -152,19 +152,19 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | become   | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | become   | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | macro    | match    | mod     |\n+| move     | mut      | offsetof | override | priv    |\n+| proc     | pub      | pure     | ref      | return  |\n+| Self     | self     | sizeof   | static   | struct  |\n+| super    | trait    | true     | type     | typeof  |\n+| unsafe   | unsized  | use      | virtual  | where   |\n+| while    | yield    |          |          |         |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -524,6 +524,15 @@ array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n idx_expr : expr '[' expr ']' ;\n ```\n \n+### Range expressions\n+\n+```antlr\n+range_expr : expr \"..\" expr |\n+             expr \"..\" |\n+             \"..\" expr |\n+             \"..\" ;\n+```\n+\n ### Unary operator expressions\n \n **FIXME:** grammar?\n@@ -610,7 +619,7 @@ lambda_expr : '|' ident_list '|' expr ;\n ### While loops\n \n ```antlr\n-while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n+while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### Infinite loops\n@@ -634,7 +643,7 @@ continue_expr : \"continue\" [ lifetime ];\n ### For expressions\n \n ```antlr\n-for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### If expressions"}, {"sha": "fdb791374b1a91c23349e2d710e90ab943efd125", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 333, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "patch": "@@ -29,41 +29,6 @@ You may also be interested in the [grammar].\n \n # Notation\n \n-Rust's grammar is defined over Unicode code points, each conventionally denoted\n-`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n-confined to the ASCII range of Unicode, and is described in this document by a\n-dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n-supported by common automated LL(k) parsing tools such as `llgen`, rather than\n-the dialect given in ISO 14977. The dialect can be defined self-referentially\n-as follows:\n-\n-```{.ebnf .notation}\n-grammar : rule + ;\n-rule    : nonterminal ':' productionrule ';' ;\n-productionrule : production [ '|' production ] * ;\n-production : term * ;\n-term : element repeats ;\n-element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n-repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-```\n-\n-Where:\n-\n-- Whitespace in the grammar is ignored.\n-- Square brackets are used to group rules.\n-- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n-  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode code point `U+00QQ`.\n-- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n-- The `repeat` forms apply to the adjacent `element`, and are as follows:\n-  - `?` means zero or one repetition\n-  - `*` means zero or more repetitions\n-  - `+` means one or more repetitions\n-  - NUMBER trailing a repeat symbol gives a maximum repetition count\n-  - NUMBER on its own gives an exact repetition count\n-\n-This EBNF dialect should hopefully be familiar to many readers.\n-\n ## Unicode productions\n \n A few productions in Rust's grammar permit Unicode code points outside the ASCII\n@@ -132,13 +97,6 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-```{.ebnf .gram}\n-comment : block_comment | line_comment ;\n-block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : [block_comment | character] * ;\n-line_comment : \"//\" non_eol * ;\n-```\n-\n Comments in Rust code follow the general C++ style of line and block-comment\n forms. Nested block comments are supported.\n \n@@ -159,11 +117,6 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-```{.ebnf .gram}\n-whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n-whitespace : [ whitespace_char | comment ] + ;\n-```\n-\n The `whitespace_char` production is any nonempty Unicode string consisting of\n any of the following Unicode characters: `U+0020` (space, `' '`), `U+0009`\n (tab, `'\\t'`), `U+000A` (LF, `'\\n'`), `U+000D` (CR, `'\\r'`).\n@@ -176,53 +129,18 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-```{.ebnf .gram}\n-simple_token : keyword | unop | binop ;\n-token : simple_token | ident | literal | symbol | whitespace token ;\n-```\n-\n Tokens are primitive productions in the grammar defined by regular\n (non-recursive) languages. \"Simple\" tokens are given in [string table\n production](#string-table-productions) form, and occur in the rest of the\n grammar as double-quoted strings. Other tokens have exact rules given.\n \n-### Keywords\n-\n-<p id=\"keyword-table-marker\"></p>\n-\n-|          |          |          |          |         |\n-|----------|----------|----------|----------|---------|\n-| abstract | alignof  | as       | become   | box     |\n-| break    | const    | continue | crate    | do      |\n-| else     | enum     | extern   | false    | final   |\n-| fn       | for      | if       | impl     | in      |\n-| let      | loop     | macro    | match    | mod     |\n-| move     | mut      | offsetof | override | priv    |\n-| proc     | pub      | pure     | ref      | return  |\n-| Self     | self     | sizeof   | static   | struct  |\n-| super    | trait    | true     | type     | typeof  |\n-| unsafe   | unsized  | use      | virtual  | where   |\n-| while    | yield    |          |          |         |\n-\n-\n-Each of these keywords has special meaning in its grammar, and all of them are\n-excluded from the `ident` rule.\n-\n-Note that some of these keywords are reserved, and do not currently do\n-anything.\n-\n ### Literals\n \n A literal is an expression consisting of a single token, rather than a sequence\n of tokens, that immediately and directly denotes the value it evaluates to,\n rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n-```{.ebnf .gram}\n-lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n-```\n-\n The optional suffix is only used for certain numeric literals, but is\n reserved for future extension, that is, the above gives the lexical\n grammar, but a Rust parser will reject everything but the 12 special\n@@ -275,32 +193,6 @@ cases mentioned in [Number literals](#number-literals) below.\n \n #### Character and string literals\n \n-```{.ebnf .gram}\n-char_lit : '\\x27' char_body '\\x27' ;\n-string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n-\n-char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n-\n-string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n-raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n-\n-common_escape : '\\x5c'\n-              | 'n' | 'r' | 't' | '0'\n-              | 'x' hex_digit 2\n-\n-unicode_escape : 'u' '{' hex_digit+ 6 '}';\n-\n-hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n-          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-          | dec_digit ;\n-oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n-dec_digit : '0' | nonzero_dec ;\n-nonzero_dec: '1' | '2' | '3' | '4'\n-           | '5' | '6' | '7' | '8' | '9' ;\n-```\n-\n ##### Character literals\n \n A _character literal_ is a single Unicode character enclosed within two\n@@ -349,11 +241,10 @@ following forms:\n \n Raw string literals do not process any escapes. They start with the character\n `U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n-`U+0022` (double-quote) character. The _raw string body_ is not defined in the\n-EBNF grammar above: it can contain any sequence of Unicode characters and is\n-terminated only by another `U+0022` (double-quote) character, followed by the\n-same number of `U+0023` (`#`) characters that preceded the opening `U+0022`\n-(double-quote) character.\n+`U+0022` (double-quote) character. The _raw string body_ can contain any sequence\n+of Unicode characters and is terminated only by another `U+0022` (double-quote)\n+character, followed by the same number of `U+0023` (`#`) characters that preceded\n+the opening `U+0022` (double-quote) character.\n \n All Unicode characters contained in the raw string body represent themselves,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -375,19 +266,6 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Byte and byte string literals\n \n-```{.ebnf .gram}\n-byte_lit : \"b\\x27\" byte_body '\\x27' ;\n-byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n-\n-byte_body : ascii_non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n-\n-byte_string_body : ascii_non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n-raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n-\n-```\n-\n ##### Byte literals\n \n A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n@@ -424,11 +302,10 @@ following forms:\n Raw byte string literals do not process any escapes. They start with the\n character `U+0062` (`b`), followed by `U+0072` (`r`), followed by zero or more\n of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n-_raw string body_ is not defined in the EBNF grammar above: it can contain any\n-sequence of ASCII characters and is terminated only by another `U+0022`\n-(double-quote) character, followed by the same number of `U+0023` (`#`)\n-characters that preceded the opening `U+0022` (double-quote) character. A raw\n-byte string literal can not contain any non-ASCII byte.\n+_raw string body_ can contain any sequence of ASCII characters and is terminated\n+only by another `U+0022` (double-quote) character, followed by the same number of\n+`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote)\n+character. A raw byte string literal can not contain any non-ASCII byte.\n \n All characters contained in the raw string body represent their ASCII encoding,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -450,19 +327,6 @@ b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n \n #### Number literals\n \n-```{.ebnf .gram}\n-num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] +\n-              | 'o'   [ oct_digit | '_' ] +\n-              | 'x'   [ hex_digit | '_' ] +  ] ;\n-\n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n-\n-exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n-dec_lit : [ dec_digit | '_' ] + ;\n-```\n-\n A _number literal_ is either an _integer literal_ or a _floating-point\n literal_. The grammar for recognizing the two kinds of literals is mixed.\n \n@@ -540,12 +404,6 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-```{.ebnf .gram}\n-symbol : \"::\" | \"->\"\n-       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n-       | ',' | ';' ;\n-```\n-\n Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable tokens that do not\n@@ -555,16 +413,6 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-```{.ebnf .gram}\n-expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n-expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | expr_path ;\n-\n-type_path : ident [ type_path_tail ] + ;\n-type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | \"::\" type_path ;\n-```\n-\n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n refer to either an [item](#items) or a [variable](#variables) in a local control\n@@ -660,19 +508,6 @@ Users of `rustc` can define new syntax extensions in two ways:\n \n ## Macros\n \n-```{.ebnf .gram}\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n-macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n-matcher : '(' matcher * ')' | '[' matcher * ']'\n-        | '{' matcher * '}' | '$' ident ':' ident\n-        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n-        | non_special_token ;\n-transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n-            | '{' transcriber * '}' | '$' ident\n-            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n-            | non_special_token ;\n-```\n-\n `macro_rules` allows users to define syntax extension in a declarative way.  We\n call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n from the \"procedural macros\" defined in [compiler plugins][plugin].\n@@ -811,12 +646,6 @@ Crates contain [items](#items), each of which may have some number of\n \n ## Items\n \n-```{.ebnf .gram}\n-item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n-     | struct_item | enum_item | static_item | trait_item | impl_item\n-     | extern_block ;\n-```\n-\n An _item_ is a component of a crate. Items are organized within a crate by a\n nested set of [modules](#modules). Every crate has a single \"outermost\"\n anonymous module; all further items within the crate have [paths](#paths)\n@@ -863,11 +692,6 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n-```{.ebnf .gram}\n-mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : item * ;\n-```\n-\n A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n@@ -928,11 +752,6 @@ mod thread {\n \n ##### Extern crate declarations\n \n-```{.ebnf .gram}\n-extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit \"as\" ident )\n-```\n-\n An _`extern crate` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident`\n provided in the `extern_crate_decl`.\n@@ -958,17 +777,6 @@ extern crate std as ruststd; // linking to 'std' under another name\n \n ##### Use declarations\n \n-```{.ebnf .gram}\n-use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n-                          | path_glob ] ;\n-\n-path_glob : ident [ \"::\" [ path_glob\n-                          | '*' ] ] ?\n-          | '{' path_item [ ',' path_item ] * '}' ;\n-\n-path_item : ident | \"self\" ;\n-```\n-\n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n@@ -1413,10 +1221,6 @@ it were `Bar(i32)`, this is disallowed.\n \n ### Constant items\n \n-```{.ebnf .gram}\n-const_item : \"const\" ident ':' type '=' expr ';' ;\n-```\n-\n A *constant item* is a named _constant value_ which is not associated with a\n specific memory location in the program. Constants are essentially inlined\n wherever they are used, meaning that they are copied directly into the relevant\n@@ -1453,10 +1257,6 @@ const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n \n ### Static items\n \n-```{.ebnf .gram}\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n-```\n-\n A *static item* is similar to a *constant*, except that it represents a precise\n memory location in the program. A static is never \"inlined\" at the usage site,\n and all references to it refer to the same memory location. Static items have\n@@ -1711,11 +1511,6 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-```{.ebnf .gram}\n-extern_block_item : \"extern\" '{' extern_block '}' ;\n-extern_block : [ foreign_fn ] * ;\n-```\n-\n External blocks form the basis for Rust's foreign function interface.\n Declarations in an external block describe symbols in external, non-Rust\n libraries.\n@@ -1915,13 +1710,6 @@ the namespace hierarchy as it normally would.\n \n ## Attributes\n \n-```{.ebnf .gram}\n-attribute : '#' '!' ? '[' meta_item ']' ;\n-meta_item : ident [ '=' literal\n-                  | '(' meta_seq ')' ] ? ;\n-meta_seq : meta_item [ ',' meta_seq ] ? ;\n-```\n-\n Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n (C#). An attribute is a general, free-form metadatum that is interpreted\n@@ -2554,11 +2342,6 @@ in meaning to declaring the item outside the statement block.\n \n #### Variable declarations\n \n-```{.ebnf .gram}\n-let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n-init : [ '=' ] expr ;\n-```\n-\n A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n@@ -2659,15 +2442,6 @@ the same name.\n \n ### Structure expressions\n \n-```{.ebnf .gram}\n-struct_expr : expr_path '{' ident ':' expr\n-                      [ ',' ident ':' expr ] *\n-                      [ \"..\" expr ] '}' |\n-              expr_path '(' expr\n-                      [ ',' expr ] * ')' |\n-              expr_path ;\n-```\n-\n There are several forms of structure expressions. A _structure expression_\n consists of the [path](#paths) of a [structure item](#structures), followed by\n a brace-enclosed list of one or more comma-separated name-value pairs,\n@@ -2718,11 +2492,6 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-```{.ebnf .gram}\n-block_expr : '{' [ stmt ';' | item ] *\n-                 [ expr ] '}' ;\n-```\n-\n A _block expression_ is similar to a module in terms of the declarations that\n are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n@@ -2745,10 +2514,6 @@ assert_eq!(5, x);\n \n ### Method-call expressions\n \n-```{.ebnf .gram}\n-method_call_expr : expr '.' ident paren_expr_list ;\n-```\n-\n A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n@@ -2757,10 +2522,6 @@ the left-hand-side expression is an indirect [trait object](#trait-objects).\n \n ### Field expressions\n \n-```{.ebnf .gram}\n-field_expr : expr '.' ident ;\n-```\n-\n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)). A field\n@@ -2781,12 +2542,6 @@ automatically dereferenced to make the field access possible.\n \n ### Array expressions\n \n-```{.ebnf .gram}\n-array_expr : '[' \"mut\" ? array_elems? ']' ;\n-\n-array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n-```\n-\n An [array](#array,-and-slice-types) _expression_ is written by enclosing zero\n or more comma-separated expressions of uniform type in square brackets.\n \n@@ -2803,10 +2558,6 @@ constant expression that can be evaluated at compile time, such as a\n \n ### Index expressions\n \n-```{.ebnf .gram}\n-idx_expr : expr '[' expr ']' ;\n-```\n-\n [Array](#array,-and-slice-types)-typed expressions can be indexed by\n writing a square-bracket-enclosed expression (the index) after them. When the\n array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n@@ -2823,13 +2574,6 @@ _panicked state_.\n \n ### Range expressions\n \n-```{.ebnf .gram}\n-range_expr : expr \"..\" expr |\n-             expr \"..\" |\n-             \"..\" expr |\n-             \"..\" ;\n-```\n-\n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n \n ```\n@@ -2872,10 +2616,6 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-```{.ebnf .gram}\n-binop_expr : expr binop expr ;\n-```\n-\n Binary operators expressions are given in terms of [operator\n precedence](#operator-precedence).\n \n@@ -3036,10 +2776,6 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression. Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-```{.ebnf .gram}\n-paren_expr : '(' expr ')' ;\n-```\n-\n An example of a parenthesized expression:\n \n ```\n@@ -3049,12 +2785,6 @@ let x: i32 = (2 + 3) * 4;\n \n ### Call expressions\n \n-```{.ebnf .gram}\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-```\n-\n A _call expression_ invokes a function, providing zero or more input variables\n and an optional location to move the function's output into. If the function\n eventually returns, then the expression completes.\n@@ -3070,11 +2800,6 @@ let pi: Result<f32, _> = \"3.14\".parse();\n \n ### Lambda expressions\n \n-```{.ebnf .gram}\n-ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '|' expr ;\n-```\n-\n A _lambda expression_ (sometimes called an \"anonymous function expression\")\n defines a function and denotes it as a value, in a single expression. A lambda\n expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n@@ -3118,10 +2843,6 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n A `loop` expression denotes an infinite loop.\n \n-```{.ebnf .gram}\n-loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n-```\n-\n A `loop` expression may optionally have a _label_. The label is written as\n a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n label is present, then labeled `break` and `continue` expressions nested\n@@ -3131,10 +2852,6 @@ expressions](#continue-expressions).\n \n ### Break expressions\n \n-```{.ebnf .gram}\n-break_expr : \"break\" [ lifetime ];\n-```\n-\n A `break` expression has an optional _label_. If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop. If the label is\n@@ -3143,10 +2860,6 @@ be the innermost label enclosing the `break` expression, but must enclose it.\n \n ### Continue expressions\n \n-```{.ebnf .gram}\n-continue_expr : \"continue\" [ lifetime ];\n-```\n-\n A `continue` expression has an optional _label_. If the label is absent, then\n executing a `continue` expression immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop *head*. In\n@@ -3160,10 +2873,6 @@ A `continue` expression is only permitted in the body of a loop.\n \n ### While loops\n \n-```{.ebnf .gram}\n-while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `while` loop begins by evaluating the boolean loop conditional expression.\n If the loop conditional expression evaluates to `true`, the loop body block\n executes and control returns to the loop conditional expression. If the loop\n@@ -3187,10 +2896,6 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### For expressions\n \n-```{.ebnf .gram}\n-for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `for` expression is a syntactic construct for looping over elements provided\n by an implementation of `std::iter::Iterator`.\n \n@@ -3226,14 +2931,6 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### If expressions\n \n-```{.ebnf .gram}\n-if_expr : \"if\" no_struct_literal_expr '{' block '}'\n-          else_tail ? ;\n-\n-else_tail : \"else\" [ if_expr | if_let_expr\n-                   | '{' block '}' ] ;\n-```\n-\n An `if` expression is a conditional branch in program control. The form of an\n `if` expression is a condition expression, followed by a consequent block, any\n number of `else if` conditions and blocks, and an optional trailing `else`\n@@ -3246,14 +2943,6 @@ if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n \n ### Match expressions\n \n-```{.ebnf .gram}\n-match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n-\n-match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n-\n-match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-```\n-\n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n literals, destructured arrays or enum constructors, structures and tuples,\n@@ -3370,23 +3059,13 @@ let message = match maybe_digit {\n \n ### If let expressions\n \n-```{.ebnf .gram}\n-if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n-               else_tail ? ;\n-else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n-```\n-\n An `if let` expression is semantically identical to an `if` expression but in place\n of a condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the corresponding\n block will execute, otherwise flow proceeds to the first `else` block that follows.\n \n ### While let loops\n \n-```{.ebnf .gram}\n-while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n-```\n-\n A `while let` loop is semantically identical to a `while` loop but in place of a\n condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the\n@@ -3395,10 +3074,6 @@ Otherwise, the while expression completes.\n \n ### Return expressions\n \n-```{.ebnf .gram}\n-return_expr : \"return\" expr ? ;\n-```\n-\n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n expression moves its argument into the designated output location for the\n current function call, destroys the current function activation frame, and"}]}