{"sha": "ed5a3c01a03da160b179166d2c1c839afac0b857", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNWEzYzAxYTAzZGExNjBiMTc5MTY2ZDJjMWM4MzlhZmFjMGI4NTc=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-10-06T15:35:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-06T15:35:42Z"}, "message": "Rollup merge of #36962 - arielb1:cast-assumptions, r=eddyb\n\nEmit more assumptions in trans\n\nPerf numbers pending.", "tree": {"sha": "1042de5f04e262e9b8e2c48ff430e3cc06893b09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1042de5f04e262e9b8e2c48ff430e3cc06893b09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed5a3c01a03da160b179166d2c1c839afac0b857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5a3c01a03da160b179166d2c1c839afac0b857", "html_url": "https://github.com/rust-lang/rust/commit/ed5a3c01a03da160b179166d2c1c839afac0b857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed5a3c01a03da160b179166d2c1c839afac0b857/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a7aa75332083700d71436d8af296a98491f221a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7aa75332083700d71436d8af296a98491f221a", "html_url": "https://github.com/rust-lang/rust/commit/1a7aa75332083700d71436d8af296a98491f221a"}, {"sha": "45fe3a1a2ab2671bb9f726941eda6c2899eb6dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fe3a1a2ab2671bb9f726941eda6c2899eb6dff", "html_url": "https://github.com/rust-lang/rust/commit/45fe3a1a2ab2671bb9f726941eda6c2899eb6dff"}], "stats": {"total": 369, "additions": 193, "deletions": 176}, "files": [{"sha": "e0e808f2dcca1848896a3c74c618be69e7215894", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 46, "deletions": 129, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -183,6 +183,14 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     StructGEP(bcx, fat_ptr, abi::FAT_PTR_ADDR)\n }\n \n+pub fn get_meta_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n+}\n+\n+pub fn get_dataptr_builder(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n+}\n+\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n@@ -247,124 +255,6 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    lhs_addr: ValueRef,\n-                                    lhs_extra: ValueRef,\n-                                    rhs_addr: ValueRef,\n-                                    rhs_extra: ValueRef,\n-                                    _t: Ty<'tcx>,\n-                                    op: hir::BinOp_,\n-                                    debug_loc: DebugLoc)\n-                                    -> ValueRef {\n-    match op {\n-        hir::BiEq => {\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-            And(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiNe => {\n-            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-            Or(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-            let (op, strict_op) = match op {\n-                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => bug!(),\n-            };\n-\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-        }\n-        _ => {\n-            bug!(\"unexpected fat ptr binop\");\n-        }\n-    }\n-}\n-\n-pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        lhs: ValueRef,\n-                                        rhs: ValueRef,\n-                                        t: Ty<'tcx>,\n-                                        op: hir::BinOp_,\n-                                        debug_loc: DebugLoc)\n-                                        -> ValueRef {\n-    match t.sty {\n-        ty::TyTuple(ref tys) if tys.is_empty() => {\n-            // We don't need to do actual comparisons for nil.\n-            // () == () holds but () < () does not.\n-            match op {\n-                hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n-                hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n-                // refinements would be nice\n-                _ => bug!(\"compare_scalar_types: must be a comparison operator\"),\n-            }\n-        }\n-        ty::TyBool => {\n-            // FIXME(#36856) -- using `from_immediate` forces these booleans into `i8`,\n-            // which works around some LLVM bugs\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 from_immediate(bcx, lhs),\n-                 from_immediate(bcx, rhs),\n-                 debug_loc)\n-        }\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyUint(_) | ty::TyChar => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, false),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyRawPtr(_) => {\n-            let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n-            let lhs_extra = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_EXTRA]));\n-\n-            let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n-            let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n-            compare_fat_ptrs(bcx,\n-                             lhs_addr,\n-                             lhs_extra,\n-                             rhs_addr,\n-                             rhs_extra,\n-                             t,\n-                             op,\n-                             debug_loc)\n-        }\n-        ty::TyInt(_) => {\n-            ICmp(bcx,\n-                 bin_op_to_icmp_predicate(op, true),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        ty::TyFloat(_) => {\n-            FCmp(bcx,\n-                 bin_op_to_fcmp_predicate(op),\n-                 lhs,\n-                 rhs,\n-                 debug_loc)\n-        }\n-        // Should never get here, because t is scalar.\n-        _ => bug!(\"non-scalar type passed to compare_scalar_types\"),\n-    }\n-}\n-\n pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -632,6 +522,11 @@ pub fn need_invoke(bcx: Block) -> bool {\n     }\n }\n \n+pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n+    let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n+    b.call(assume_intrinsic, &[val], None);\n+}\n+\n /// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n@@ -685,12 +580,9 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_ADDR),\n-              get_dataptr(cx, dst));\n-        Store(cx,\n-              ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n-              get_meta(cx, dst));\n+        let lladdr = ExtractValue(cx, v, abi::FAT_PTR_ADDR);\n+        let llextra = ExtractValue(cx, v, abi::FAT_PTR_EXTRA);\n+        store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n         Store(cx, from_immediate(cx, v), dst);\n     }\n@@ -708,11 +600,36 @@ pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 src: ValueRef,\n-                                _ty: Ty<'tcx>)\n-                                -> (ValueRef, ValueRef) {\n-    // FIXME: emit metadata\n-    (Load(cx, get_dataptr(cx, src)),\n-     Load(cx, get_meta(cx, src)))\n+                                ty: Ty<'tcx>)\n+                                -> (ValueRef, ValueRef)\n+{\n+    if cx.unreachable.get() {\n+        // FIXME: remove me\n+        return (Load(cx, get_dataptr(cx, src)),\n+                Load(cx, get_meta(cx, src)));\n+    }\n+\n+    load_fat_ptr_builder(&B(cx), src, ty)\n+}\n+\n+pub fn load_fat_ptr_builder<'a, 'tcx>(\n+    b: &Builder<'a, 'tcx>,\n+    src: ValueRef,\n+    t: Ty<'tcx>)\n+    -> (ValueRef, ValueRef)\n+{\n+\n+    let ptr = get_dataptr_builder(b, src);\n+    let ptr = if t.is_region_ptr() || t.is_unique() {\n+        b.load_nonnull(ptr)\n+    } else {\n+        b.load(ptr)\n+    };\n+\n+    // FIXME: emit metadata on `meta`.\n+    let meta = b.load(get_meta_builder(b, src));\n+\n+    (ptr, meta)\n }\n \n pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {"}, {"sha": "9edb489decc735f3c361c19b00940d046e528799", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::token;\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::{LvalueRef, load_fat_ptr};\n+use super::lvalue::{LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::*;\n \n@@ -703,7 +703,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n                     let ptr = adt::trans_field_ptr_builder(bcx, tuple.ty, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                        let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n+                        let (lldata, llextra) = base::load_fat_ptr_builder(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to"}, {"sha": "8e65eac2e80894943b86e3cfe836346c6e3008cd", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -13,10 +13,8 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n-use abi;\n use adt;\n use base;\n-use builder::Builder;\n use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n@@ -69,18 +67,6 @@ impl<'tcx> LvalueRef<'tcx> {\n     }\n }\n \n-pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n-pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n-    (b.load(get_dataptr(b, fat_ptr)), b.load(get_meta(b, fat_ptr)))\n-}\n-\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n                         bcx: &BlockAndBuilder<'bcx, 'tcx>,"}, {"sha": "d5828f7c56c25ec2b382145ae221e1c2be56bea0", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -34,7 +34,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::trans_static_initializer;\n \n-use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use self::lvalue::{LvalueRef};\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -384,8 +384,10 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                    arg.store_fn_arg(bcx, &mut llarg_idx,\n+                                     base::get_dataptr_builder(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx,\n+                                      base::get_meta_builder(bcx, dst));\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n@@ -466,8 +468,10 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 // so make an alloca to store them in.\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, lltemp));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, lltemp));\n+                arg.store_fn_arg(bcx, &mut llarg_idx,\n+                                 base::get_dataptr_builder(bcx, lltemp));\n+                meta.store_fn_arg(bcx, &mut llarg_idx,\n+                                  base::get_meta_builder(bcx, lltemp));\n             } else  {\n                 // otherwise, arg is passed by value, so make a\n                 // temporary and store it there"}, {"sha": "c9d83a3375258df830c0141cb3d38cadb886b40f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -143,20 +143,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = if common::type_is_imm_pair(bcx.ccx(), ty) {\n+        let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+            let (lldata, llextra) = base::load_fat_ptr_builder(bcx, llval, ty);\n+            OperandValue::Pair(lldata, llextra)\n+        } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n+            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx(), ty).unwrap();\n             let a_ptr = bcx.struct_gep(llval, 0);\n             let b_ptr = bcx.struct_gep(llval, 1);\n \n-            // This is None only for fat pointers, which don't\n-            // need any special load-time behavior anyway.\n-            let pair_fields = common::type_pair_fields(bcx.ccx(), ty);\n-            let (a, b) = if let Some([a_ty, b_ty]) = pair_fields {\n-                (base::load_ty_builder(bcx, a_ptr, a_ty),\n-                 base::load_ty_builder(bcx, b_ptr, b_ty))\n-            } else {\n-                (bcx.load(a_ptr), bcx.load(b_ptr))\n-            };\n-            OperandValue::Pair(a, b)\n+            OperandValue::Pair(\n+                base::load_ty_builder(bcx, a_ptr, a_ty),\n+                base::load_ty_builder(bcx, b_ptr, b_ty)\n+            )\n         } else if common::type_is_immediate(bcx.ccx(), ty) {\n             OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n         } else {"}, {"sha": "97aa475be68a7c3ef0860701080b3340f004b96d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 103, "deletions": 15, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -11,15 +11,18 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n+use rustc::ty::layout::Layout;\n use rustc::mir::repr as mir;\n \n use asm;\n use base;\n use callee::Callee;\n use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder, Result};\n+use common::{C_integral};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n+use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n@@ -28,7 +31,7 @@ use Disr;\n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::{LvalueRef, get_dataptr};\n+use super::lvalue::{LvalueRef};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -98,7 +101,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx(), size);\n-                let base = get_dataptr(&bcx, dest.llval);\n+                let base = base::get_dataptr_builder(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n                     tvec::slice_for_each(block, base, tr_elem.ty, size, |block, llslot| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n@@ -281,7 +284,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 }\n                                 OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n                             };\n-                            (discr, adt::is_discr_signed(&l))\n+                            let (signed, min, max) = match l {\n+                                &Layout::CEnum { signed, min, max, .. } => {\n+                                    (signed, min, max)\n+                                }\n+                                _ => bug!(\"CEnum {:?} is not an enum\", operand)\n+                            };\n+\n+                            if max > min {\n+                                // We want `table[e as usize]` to not\n+                                // have bound checks, and this is the most\n+                                // convenient place to put the `assume`.\n+\n+                                base::call_assume(&bcx, bcx.icmp(\n+                                    llvm::IntULE,\n+                                    discr,\n+                                    C_integral(common::val_ty(discr), max, false)\n+                                ))\n+                            }\n+\n+                            (discr, signed)\n                         } else {\n                             (operand.immediate(), operand.ty.is_signed())\n                         };\n@@ -382,13 +404,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                            bcx.with_block(|bcx| {\n-                                base::compare_fat_ptrs(bcx,\n-                                                       lhs_addr, lhs_extra,\n-                                                       rhs_addr, rhs_extra,\n-                                                       lhs.ty, op.to_hir_binop(),\n-                                                       debug_loc)\n-                            })\n+                            self.trans_fat_ptr_binop(&bcx, op,\n+                                                     lhs_addr, lhs_extra,\n+                                                     rhs_addr, rhs_extra,\n+                                                     lhs.ty)\n                         }\n                         _ => bug!()\n                     }\n@@ -485,6 +504,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                               input_ty: Ty<'tcx>) -> ValueRef {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n+        let is_nil = input_ty.is_nil();\n+        let is_bool = input_ty.is_bool();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bcx.fadd(lhs, rhs)\n@@ -535,12 +556,79 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    DebugLoc::None)\n                 })\n             }\n-            mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n-            mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n-                bcx.with_block(|bcx| {\n-                    base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n-                                               op.to_hir_binop(), DebugLoc::None)\n+            mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n+            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n+                C_bool(bcx.ccx(), match op {\n+                    mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n+                    mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n+                    _ => unreachable!()\n                 })\n+            } else if is_float {\n+                bcx.fcmp(\n+                    base::bin_op_to_fcmp_predicate(op.to_hir_binop()),\n+                    lhs, rhs\n+                )\n+            } else {\n+                let (lhs, rhs) = if is_bool {\n+                    // FIXME(#36856) -- extend the bools into `i8` because\n+                    // LLVM's i1 comparisons are broken.\n+                    (bcx.zext(lhs, Type::i8(bcx.ccx())),\n+                     bcx.zext(rhs, Type::i8(bcx.ccx())))\n+                } else {\n+                    (lhs, rhs)\n+                };\n+\n+                bcx.icmp(\n+                    base::bin_op_to_icmp_predicate(op.to_hir_binop(), is_signed),\n+                    lhs, rhs\n+                )\n+            }\n+        }\n+    }\n+\n+    pub fn trans_fat_ptr_binop(&mut self,\n+                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               op: mir::BinOp,\n+                               lhs_addr: ValueRef,\n+                               lhs_extra: ValueRef,\n+                               rhs_addr: ValueRef,\n+                               rhs_extra: ValueRef,\n+                               _input_ty: Ty<'tcx>)\n+                               -> ValueRef {\n+        match op {\n+            mir::BinOp::Eq => {\n+                bcx.and(\n+                    bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntEQ, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Ne => {\n+                bcx.or(\n+                    bcx.icmp(llvm::IntNE, lhs_addr, rhs_addr),\n+                    bcx.icmp(llvm::IntNE, lhs_extra, rhs_extra)\n+                )\n+            }\n+            mir::BinOp::Le | mir::BinOp::Lt |\n+            mir::BinOp::Ge | mir::BinOp::Gt => {\n+                // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+                let (op, strict_op) = match op {\n+                    mir::BinOp::Lt => (llvm::IntULT, llvm::IntULT),\n+                    mir::BinOp::Le => (llvm::IntULE, llvm::IntULT),\n+                    mir::BinOp::Gt => (llvm::IntUGT, llvm::IntUGT),\n+                    mir::BinOp::Ge => (llvm::IntUGE, llvm::IntUGT),\n+                    _ => bug!(),\n+                };\n+\n+                bcx.or(\n+                    bcx.icmp(strict_op, lhs_addr, rhs_addr),\n+                    bcx.and(\n+                        bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                        bcx.icmp(op, lhs_extra, rhs_extra)\n+                    )\n+                )\n+            }\n+            _ => {\n+                bug!(\"unexpected fat ptr binop\");\n             }\n         }\n     }"}, {"sha": "4cfb5a752dfdc0cadde5b8cf6ee2f2e5929b5300", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a3c01a03da160b179166d2c1c839afac0b857/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=ed5a3c01a03da160b179166d2c1c839afac0b857", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+pub enum Foo {\n+    A, B\n+}\n+\n+// CHECK-LABEL: @lookup\n+#[no_mangle]\n+pub fn lookup(buf: &[u8; 2], f: Foo) -> u8 {\n+    // CHECK-NOT: panic_bounds_check\n+    buf[f as usize]\n+}"}]}