{"sha": "d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNDQ3NTUwZGFiYzFiNWZlZTFiZGUyYTI2NjNlYmUxNWQ2YmJmMmE=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-22T20:38:51Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-03T10:41:51Z"}, "message": "Shift both late bound regions and bound types", "tree": {"sha": "d0bf02333e6f9dd50ae81b4906417eab6bd655a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0bf02333e6f9dd50ae81b4906417eab6bd655a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "html_url": "https://github.com/rust-lang/rust/commit/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1003b7f85e75e3a726adc34b9c315e98094176d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1003b7f85e75e3a726adc34b9c315e98094176d5", "html_url": "https://github.com/rust-lang/rust/commit/1003b7f85e75e3a726adc34b9c315e98094176d5"}], "stats": {"total": 282, "additions": 164, "deletions": 118}, "files": [{"sha": "523f03c2cfc4773afc81f9c008a0fa7294bb5f92", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -305,7 +305,7 @@ where\n             ty, region, origin\n         );\n \n-        assert!(!ty.has_escaping_regions());\n+        assert!(!ty.has_escaping_bound_vars());\n \n         let components = self.tcx.outlives_components(ty);\n         self.components_must_outlive(origin, components, region);"}, {"sha": "3b0f9a5e545fde48e157985c952b8b510f9cb83a", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -84,8 +84,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n-                assert!(!a.has_escaping_regions());\n-                assert!(!b.has_escaping_regions());\n+                assert!(!a.has_escaping_bound_vars());\n+                assert!(!b.has_escaping_bound_vars());\n \n                 // can't make progress on `A <: B` if both A and B are\n                 // type variables, so record an obligation. We also"}, {"sha": "afe23e47bbf549d22b056095f6105ab59e3bba03", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n \n-        debug_assert!(!projection_ty.has_escaping_regions());\n+        debug_assert!(!projection_ty.has_escaping_bound_vars());\n \n         // FIXME(#20304) -- cache\n "}, {"sha": "c0bc214fe7a59d4162ece2fdb7d1a72ad7379c30", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n@@ -393,7 +393,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 }\n             }\n \n-            ty::Projection(ref data) if !data.has_escaping_regions() => { // (*)\n+            ty::Projection(ref data) if !data.has_escaping_bound_vars() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because"}, {"sha": "59b086e35de310a0ae189d841b8e7270c007fec7", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => {\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 }\n             }\n \n-            ty::Projection(ref data) if !data.has_escaping_regions() => {\n+            ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n                 // (*)\n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because"}, {"sha": "6670b83bdf87a6fd0a0cbb0c4fd71f6262b28f1f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -587,7 +587,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({:?})\", obligation);\n-        debug_assert!(!obligation.predicate.has_escaping_regions());\n+        debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n \n@@ -690,7 +690,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n-                debug_assert!(!t.has_escaping_regions());\n+                debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t.clone());\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n@@ -722,9 +722,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             },\n \n             ty::Predicate::TypeOutlives(ref binder) => {\n-                assert!(!binder.has_escaping_regions());\n-                // Check if the type has higher-ranked regions.\n-                if binder.skip_binder().0.has_escaping_regions() {\n+                assert!(!binder.has_escaping_bound_vars());\n+                // Check if the type has higher-ranked vars.\n+                if binder.skip_binder().0.has_escaping_bound_vars() {\n                     // If so, this obligation is an error (for now). Eventually we should be\n                     // able to support additional cases here, like `for<'a> &'a str: 'a`.\n \n@@ -740,7 +740,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         Ok(EvaluatedToErr)\n                     }\n                 } else {\n-                    // If the type has no late bound regions, then if we assign all\n+                    // If the type has no late bound vars, then if we assign all\n                     // the inference variables in it to be 'static, then the type\n                     // will be 'static itself.\n                     //\n@@ -1199,7 +1199,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n             cache_fresh_trait_pred, stack\n         );\n-        debug_assert!(!stack.obligation.predicate.has_escaping_regions());\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n \n         if let Some(c) =\n             self.check_candidate_cache(stack.obligation.param_env, &cache_fresh_trait_pred)\n@@ -1801,7 +1801,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         placeholder_map: &infer::PlaceholderMap<'tcx>,\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n-        debug_assert!(!skol_trait_ref.has_escaping_regions());\n+        debug_assert!(!skol_trait_ref.has_escaping_bound_vars());\n         if self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(skol_trait_ref), trait_bound)"}, {"sha": "d0ea7f653d1e129c2278b0be5ac145c19244ee9c", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -115,7 +115,10 @@ impl FlagComputation {\n                 self.add_substs(&substs.substs);\n             }\n \n-            &ty::Bound(_) => self.add_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            &ty::Bound(bound_ty) => {\n+                self.add_flags(TypeFlags::HAS_CANONICAL_VARS);\n+                self.add_binder(bound_ty.level);\n+            }\n \n             &ty::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES); // it might, right?\n@@ -142,7 +145,7 @@ impl FlagComputation {\n             &ty::Projection(ref data) => {\n                 // currently we can't normalize projections that\n                 // include bound regions, so track those separately.\n-                if !data.has_escaping_regions() {\n+                if !data.has_escaping_bound_vars() {\n                     self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n                 }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);"}, {"sha": "cb94d7d1083e89f2f001a9e3fccbc054aade860b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 89, "deletions": 45, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -67,18 +67,18 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     /// bound by `binder` or bound by some binder outside of `binder`.\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n     /// there are any late-bound regions that appear free.\n-    fn has_regions_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.visit_with(&mut HasEscapingRegionsVisitor { outer_index: binder })\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder })\n     }\n \n     /// True if this `self` has any regions that escape `binder` (and\n     /// hence are not bound by it).\n-    fn has_regions_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.has_regions_bound_at_or_above(binder.shifted_in(1))\n+    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n     }\n \n-    fn has_escaping_regions(&self) -> bool {\n-        self.has_regions_bound_at_or_above(ty::INNERMOST)\n+    fn has_escaping_bound_vars(&self) -> bool {\n+        self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n@@ -574,7 +574,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_regions_bound_at_or_above(self.current_index) {\n+        if !t.has_vars_bound_at_or_above(self.current_index) {\n             return t;\n         }\n \n@@ -603,55 +603,99 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Region shifter\n+// Shifter\n //\n-// Shifts the De Bruijn indices on all escaping bound regions by a\n+// Shifts the De Bruijn indices on all escaping bound vars by a\n // fixed amount. Useful in substitution or when otherwise introducing\n // a binding level that is not intended to capture the existing bound\n-// regions. See comment on `shift_regions_through_binders` method in\n+// vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region(region: ty::RegionKind, amount: u32) -> ty::RegionKind {\n-    match region {\n-        ty::ReLateBound(debruijn, br) => {\n-            ty::ReLateBound(debruijn.shifted_in(amount), br)\n+struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+    current_index: ty::DebruijnIndex,\n+    amount: u32,\n+}\n+\n+impl Shifter<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32) -> Self {\n+        Shifter {\n+            tcx,\n+            current_index: ty::INNERMOST,\n+            amount,\n         }\n-        _ => {\n-            region\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(debruijn, br) => {\n+                if self.amount == 0 || debruijn < self.current_index {\n+                    r\n+                } else {\n+                    let shifted = ty::ReLateBound(debruijn.shifted_in(self.amount), br);\n+                    self.tcx.mk_region(shifted)\n+                }\n+            }\n+            _ => r\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: ty::Ty<'tcx>) -> ty::Ty<'tcx> {\n+        match ty.sty {\n+            ty::Bound(bound_ty) => {\n+                if self.amount == 0 || bound_ty.level < self.current_index {\n+                    ty\n+                } else {\n+                    let shifted = ty::BoundTy {\n+                        level: bound_ty.level.shifted_in(self.amount),\n+                        var: bound_ty.var,\n+                        kind: bound_ty.kind,\n+                    };\n+                    self.tcx.mk_ty(ty::Bound(shifted))\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n         }\n     }\n }\n \n-pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    region: ty::Region<'tcx>,\n-    amount: u32)\n-    -> ty::Region<'tcx>\n-{\n+pub fn shift_region(region: ty::RegionKind, amount: u32) -> ty::RegionKind {\n     match region {\n-        &ty::ReLateBound(debruijn, br) if amount > 0 => {\n-            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), br))\n+        ty::ReLateBound(debruijn, br) => {\n+            ty::ReLateBound(debruijn.shifted_in(amount), br)\n         }\n         _ => {\n             region\n         }\n     }\n }\n \n-pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        amount: u32,\n-                                        value: &T) -> T\n-    where T: TypeFoldable<'tcx>\n-{\n-    debug!(\"shift_regions(value={:?}, amount={})\",\n+pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    amount: u32,\n+    value: &T\n+) -> T where T: TypeFoldable<'tcx> {\n+    debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        shift_region_ref(tcx, region, amount)\n-    }))\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n-/// An \"escaping region\" is a bound region whose binder is not part of `t`.\n+/// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a\n+/// bound region or a bound type.\n ///\n /// So, for example, consider a type like the following, which has two binders:\n ///\n@@ -663,24 +707,24 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n /// fn type*, that type has an escaping region: `'a`.\n ///\n-/// Note that what I'm calling an \"escaping region\" is often just called a \"free region\". However,\n-/// we already use the term \"free region\". It refers to the regions that we use to represent bound\n-/// regions on a fn definition while we are typechecking its body.\n+/// Note that what I'm calling an \"escaping var\" is often just called a \"free var\". However,\n+/// we already use the term \"free var\". It refers to the regions or types that we use to represent\n+/// bound regions or type params on a fn definition while we are typechecking its body.\n ///\n /// To clarify, conceptually there is no particular difference between\n-/// an \"escaping\" region and a \"free\" region. However, there is a big\n+/// an \"escaping\" var and a \"free\" var. However, there is a big\n /// difference in practice. Basically, when \"entering\" a binding\n /// level, one is generally required to do some sort of processing to\n-/// a bound region, such as replacing it with a fresh/placeholder\n-/// region, or making an entry in the environment to represent the\n-/// scope to which it is attached, etc. An escaping region represents\n-/// a bound region for which this processing has not yet been done.\n-struct HasEscapingRegionsVisitor {\n+/// a bound var, such as replacing it with a fresh/placeholder\n+/// var, or making an entry in the environment to represent the\n+/// scope to which it is attached, etc. An escaping var represents\n+/// a bound var for which this processing has not yet been done.\n+struct HasEscapingVarsVisitor {\n     /// Anything bound by `outer_index` or \"above\" is escaping\n     outer_index: ty::DebruijnIndex,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n+impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n         self.outer_index.shift_in(1);\n         let result = t.super_visit_with(self);\n@@ -693,7 +737,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         // `outer_index`, that means that `t` contains some content\n         // bound at `outer_index` or above (because\n         // `outer_exclusive_binder` is always 1 higher than the\n-        // content in `t`). Therefore, `t` has some escaping regions.\n+        // content in `t`). Therefore, `t` has some escaping vars.\n         t.outer_exclusive_binder > self.outer_index\n     }\n "}, {"sha": "2fc8ef548fa0447fa6b1c5f8e61509bf1fa845e1", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -213,7 +213,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n-        assert!(!substs.has_escaping_regions(),\n+        assert!(!substs.has_escaping_bound_vars(),\n                 \"substs of instance {:?} not normalized for codegen: {:?}\",\n                 def_id, substs);\n         Instance { def: InstanceDef::Item(def_id), substs: substs }"}, {"sha": "449730c9d0601d6c991e7705131b3eb71ed122fe", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n             ty::Projection(ref data) => {\n-                if !data.has_escaping_regions() {\n+                if !data.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n                     // constraints for Pi). This defers the choice between"}, {"sha": "e812486d1f89e71cba166e31c2857da7e3f909bc", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -730,8 +730,8 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n-        // otherwise the escaping regions would be captured by the binder\n-        // debug_assert!(!self_ty.has_escaping_regions());\n+        // otherwise the escaping vars would be captured by the binder\n+        // debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::TraitRef {\n             def_id: self.def_id,\n@@ -776,7 +776,7 @@ impl<T> Binder<T> {\n     pub fn dummy<'tcx>(value: T) -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n-        debug_assert!(!value.has_escaping_regions());\n+        debug_assert!(!value.has_escaping_bound_vars());\n         Binder(value)\n     }\n \n@@ -835,7 +835,7 @@ impl<T> Binder<T> {\n     pub fn no_late_bound_regions<'tcx>(self) -> Option<T>\n         where T : TypeFoldable<'tcx>\n     {\n-        if self.skip_binder().has_escaping_regions() {\n+        if self.skip_binder().has_escaping_bound_vars() {\n             None\n         } else {\n             Some(self.skip_binder().clone())\n@@ -1246,7 +1246,6 @@ impl_stable_hash_for!(enum self::BoundTyKind { Anon, Param(a) });\n \n impl BoundTy {\n     pub fn new(level: DebruijnIndex, var: BoundTyIndex) -> Self {\n-        debug_assert_eq!(ty::INNERMOST, level);\n         BoundTy {\n             level,\n             var,\n@@ -1283,7 +1282,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n                         -> ty::ProjectionPredicate<'tcx>\n     {\n         // otherwise the escaping regions would be captured by the binders\n-        debug_assert!(!self_ty.has_escaping_regions());\n+        debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {"}, {"sha": "9e85cfe7a12e76a832b46bb546110c3c1efc92e4", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -355,7 +355,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n                                        span,\n                                        root_ty: None,\n                                        ty_stack_depth: 0,\n-                                       region_binders_passed: 0 };\n+                                       binders_passed: 0 };\n         (*self).fold_with(&mut folder)\n     }\n }\n@@ -377,16 +377,16 @@ struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ty_stack_depth: usize,\n \n     // Number of region binders we have passed through while doing the substitution\n-    region_binders_passed: u32,\n+    binders_passed: u32,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.region_binders_passed += 1;\n+        self.binders_passed += 1;\n         let t = t.super_fold_with(self);\n-        self.region_binders_passed -= 1;\n+        self.binders_passed -= 1;\n         t\n     }\n \n@@ -471,7 +471,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.shift_regions_through_binders(ty)\n+        self.shift_vars_through_binders(ty)\n     }\n \n     /// It is sometimes necessary to adjust the debruijn indices during substitution. This occurs\n@@ -516,25 +516,25 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     /// As indicated in the diagram, here the same type `&'a int` is substituted once, but in the\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n-    fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, has_escaping_regions={:?})\",\n-               ty, self.region_binders_passed, ty.has_escaping_regions());\n+    fn shift_vars_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"shift_vars(ty={:?}, binders_passed={:?}, has_escaping_bound_vars={:?})\",\n+               ty, self.binders_passed, ty.has_escaping_bound_vars());\n \n-        if self.region_binders_passed == 0 || !ty.has_escaping_regions() {\n+        if self.binders_passed == 0 || !ty.has_escaping_bound_vars() {\n             return ty;\n         }\n \n-        let result = ty::fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {:?}\", result);\n+        let result = ty::fold::shift_vars(self.tcx(), self.binders_passed, &ty);\n+        debug!(\"shift_vars: shifted result = {:?}\", result);\n \n         result\n     }\n \n     fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n+        if self.binders_passed == 0 || !region.has_escaping_bound_vars() {\n             return region;\n         }\n-        self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n+        self.tcx().mk_region(ty::fold::shift_region(*region, self.binders_passed))\n     }\n }\n "}, {"sha": "1b1bbfd4deb8b53ea1780846c863fbf2a4f433ca", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -363,7 +363,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                erased_self_ty,\n                predicates);\n \n-        assert!(!erased_self_ty.has_escaping_regions());\n+        assert!(!erased_self_ty.has_escaping_bound_vars());\n \n         traits::elaborate_predicates(self, predicates)\n             .filter_map(|predicate| {\n@@ -389,7 +389,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         // construct such an object, but this seems\n                         // correct even if that code changes).\n                         let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n-                        if t == &erased_self_ty && !r.has_escaping_regions() {\n+                        if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n                             Some(*r)\n                         } else {\n                             None"}, {"sha": "1336eac63f880514902cac8abb1e8b298beb40a7", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n         self.out.iter()\n-                .inspect(|pred| assert!(!pred.has_escaping_regions()))\n+                .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n                 .flat_map(|pred| {\n                     let mut selcx = traits::SelectionContext::new(infcx);\n                     let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         self.out.extend(\n             trait_ref.substs.types()\n-                            .filter(|ty| !ty.has_escaping_regions())\n+                            .filter(|ty| !ty.has_escaping_bound_vars())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n                                                               param_env,\n                                                               ty::Predicate::WellFormed(ty))));\n@@ -205,7 +205,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let trait_ref = data.trait_ref(self.infcx.tcx);\n         self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n-        if !data.has_escaping_regions() {\n+        if !data.has_escaping_bound_vars() {\n             let predicate = trait_ref.to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     }\n \n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n-        if !subty.has_escaping_regions() {\n+        if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n                 def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n@@ -300,7 +300,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                 ty::Ref(r, rty, _) => {\n                     // WfReference\n-                    if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n+                    if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n                         self.out.push(\n                             traits::Obligation::new(\n@@ -451,7 +451,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .map(|pred| traits::Obligation::new(cause.clone(),\n                                                       self.param_env,\n                                                       pred))\n-                  .filter(|pred| !pred.has_escaping_regions())\n+                  .filter(|pred| !pred.has_escaping_bound_vars())\n                   .collect()\n     }\n \n@@ -490,7 +490,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n \n-        if !data.has_escaping_regions() {\n+        if !data.has_escaping_bound_vars() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx, data);\n "}, {"sha": "c8c693257d52f410261bd223c7d2872dc50b475a", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -44,7 +44,7 @@ pub fn get_fn(\n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n-    assert!(!instance.substs.has_escaping_regions());\n+    assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n     let sig = instance.fn_sig(cx.tcx);"}, {"sha": "b01d7e3a776f7145b791bfe7670db6f55636f6f4", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         debug!(\"llvm_type({:#?})\", self);\n \n-        assert!(!self.ty.has_escaping_regions(), \"{:?} has escaping regions\", self.ty);\n+        assert!(!self.ty.has_escaping_bound_vars(), \"{:?} has escaping bound vars\", self.ty);\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes."}, {"sha": "28b7c610a91c0f8a9d2ccf728c9d1f854d9b6ee9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -616,22 +616,22 @@ fn escaping() {\n         // Theta = [A -> &'a foo]\n         env.create_simple_region_hierarchy();\n \n-        assert!(!env.t_nil().has_escaping_regions());\n+        assert!(!env.t_nil().has_escaping_bound_vars());\n \n         let t_rptr_free1 = env.t_rptr_free(1);\n-        assert!(!t_rptr_free1.has_escaping_regions());\n+        assert!(!t_rptr_free1.has_escaping_bound_vars());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, d1());\n-        assert!(t_rptr_bound1.has_escaping_regions());\n+        assert!(t_rptr_bound1.has_escaping_bound_vars());\n \n         let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-        assert!(t_rptr_bound2.has_escaping_regions());\n+        assert!(t_rptr_bound2.has_escaping_bound_vars());\n \n         // t_fn = fn(A)\n         let t_param = env.t_param(0);\n-        assert!(!t_param.has_escaping_regions());\n+        assert!(!t_param.has_escaping_bound_vars());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!t_fn.has_escaping_regions());\n+        assert!(!t_fn.has_escaping_bound_vars());\n     })\n }\n "}, {"sha": "91c2035838d08065a75021759eb0b997c7c4a256", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn sanitize_type(&mut self, parent: &dyn fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_regions() || ty.references_error() {\n+        if ty.has_escaping_bound_vars() || ty.references_error() {\n             span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n         } else {\n             ty"}, {"sha": "6b39060d6fc23f5d42db3142f1544d1f7589a94e", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -905,12 +905,12 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   trait_ty: Ty<'tcx>,\n                                                   impl_ty: Ty<'tcx>,\n                                                   output: &mut Vec<MonoItem<'tcx>>) {\n-    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n-            !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n+    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_bound_vars() &&\n+            !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n     if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n         let poly_trait_ref = trait_ty.principal().with_self_ty(tcx, impl_ty);\n-        assert!(!poly_trait_ref.has_escaping_regions());\n+        assert!(!poly_trait_ref.has_escaping_bound_vars());\n \n         // Walk all methods of the trait, including those of its supertraits\n         let methods = tcx.vtable_methods(poly_trait_ref);"}, {"sha": "b97450f96622162ea5d211129431757a3bc7a1e0", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -108,7 +108,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // From the full set of obligations, just filter down to the\n         // region relationships.\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-            assert!(!obligation.has_escaping_regions());\n+            assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate {\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |"}, {"sha": "010561d1001e5ad61cc4cf0af5da187681e0a8a6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.sig.has_regions_bound_above(ty::INNERMOST));\n+        assert!(!expected_sig.sig.has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = ty::Binder::bind(self.tcx.mk_fn_sig(\n             expected_sig.sig.inputs().iter().cloned(),\n             expected_sig.sig.output(),"}, {"sha": "11448750618e218252dd96cb040609c91127dac6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 value\n             }\n         };\n-        assert!(!bounds.has_escaping_regions());\n+        assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n         obligations.extend(traits::predicates_for_generics(cause.clone(),"}, {"sha": "305efd0d75af6ed89b0fc26cbb2cac3d10733c48", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -1374,7 +1374,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                fn_sig,\n                substs);\n \n-        assert!(!substs.has_escaping_regions());\n+        assert!(!substs.has_escaping_bound_vars());\n \n         // It is possible for type parameters or early-bound lifetimes\n         // to appear in the signature of `self`. The substitutions we"}, {"sha": "791b5a0bdd92abebb5025afe718f7791612c8e68", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -653,8 +653,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n     fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n         debug!(\"register_predicate({:?})\", obligation);\n-        if obligation.has_escaping_regions() {\n-            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n+        if obligation.has_escaping_bound_vars() {\n+            span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\",\n                       obligation);\n         }\n         self.fulfillment_cx\n@@ -1928,7 +1928,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_regions() {\n+        if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n             self.normalize_associated_types_in(span, &ty)\n@@ -2431,7 +2431,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           cause: traits::ObligationCause<'tcx>,\n                                           predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n-        assert!(!predicates.has_escaping_regions());\n+        assert!(!predicates.has_escaping_bound_vars());\n \n         debug!(\"add_obligations_for_parameters(predicates={:?})\",\n                predicates);\n@@ -5188,8 +5188,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             },\n         );\n-        assert!(!substs.has_escaping_regions());\n-        assert!(!ty.has_escaping_regions());\n+        assert!(!substs.has_escaping_bound_vars());\n+        assert!(!ty.has_escaping_bound_vars());\n \n         // Write the \"user substs\" down first thing for later.\n         let hir_id = self.tcx.hir.node_to_hir_id(node_id);"}, {"sha": "a5ad31e0b6b5f0de5e1abc1821522935186383ff", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=d0447550dabc1b5fee1bde2a2663ebe15d6bbf2a", "patch": "@@ -99,7 +99,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n \n     let span = tcx.hir.span(impl_node_id);\n     let param_env = tcx.param_env(impl_did);\n-    assert!(!self_type.has_escaping_regions());\n+    assert!(!self_type.has_escaping_bound_vars());\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n            self_type);\n@@ -176,7 +176,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n         let span = tcx.hir.span(impl_node_id);\n \n         let source = tcx.type_of(impl_did);\n-        assert!(!source.has_escaping_regions());\n+        assert!(!source.has_escaping_bound_vars());\n         let target = {\n             let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n             assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n@@ -356,7 +356,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n     let span = gcx.hir.span(impl_node_id);\n     let param_env = gcx.param_env(impl_did);\n-    assert!(!source.has_escaping_regions());\n+    assert!(!source.has_escaping_bound_vars());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n "}]}