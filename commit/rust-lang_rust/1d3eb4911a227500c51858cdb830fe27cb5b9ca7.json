{"sha": "1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkM2ViNDkxMWEyMjc1MDBjNTE4NThjZGI4MzBmZTI3Y2I1YjljYTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T01:50:49Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T01:54:06Z"}, "message": "Remove #ifmt. Issue #855", "tree": {"sha": "463a0eb75f3bab8ca3b59c3dca6ed2f59164991d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/463a0eb75f3bab8ca3b59c3dca6ed2f59164991d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "html_url": "https://github.com/rust-lang/rust/commit/1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3eb4911a227500c51858cdb830fe27cb5b9ca7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "418d09e547a021ad4853680f7efc3efc8774054c", "url": "https://api.github.com/repos/rust-lang/rust/commits/418d09e547a021ad4853680f7efc3efc8774054c", "html_url": "https://github.com/rust-lang/rust/commit/418d09e547a021ad4853680f7efc3efc8774054c"}], "stats": {"total": 432, "additions": 0, "deletions": 432}, "files": [{"sha": "274cb2dbd40e28c11e4be5d1e824a2fd3310b5ea", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d3eb4911a227500c51858cdb830fe27cb5b9ca7/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3eb4911a227500c51858cdb830fe27cb5b9ca7/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "patch": "@@ -23,8 +23,6 @@ tag syntax_extension {\n fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n     syntax_expanders.insert(~\"fmt\", normal(ext::fmt::expand_syntax_ext));\n-    // FIXME: Transitional. Remove\n-    syntax_expanders.insert(~\"ifmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"env\", normal(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));"}, {"sha": "78ecf62e174823cd60c8b6867fd497650969d6c8", "filename": "src/lib/extifmt.rs", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Fextifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Fextifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextifmt.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,429 +0,0 @@\n-// FIXME: Transitional. Remove me\n-\n-/* The 'fmt' extension is modeled on the posix printf system.\n- *\n- * A posix conversion ostensibly looks like this:\n- *\n- * %[parameter][flags][width][.precision][length]type\n- *\n- * Given the different numeric type bestiary we have, we omit the 'length'\n- * parameter and support slightly different conversions for 'type':\n- *\n- * %[parameter][flags][width][.precision]type\n- *\n- * we also only support translating-to-rust a tiny subset of the possible\n- * combinations at the moment.\n- */\n-import option::none;\n-import option::some;\n-\n-\n-/*\n- * We have a 'ct' (compile-time) module that parses format strings into a\n- * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the 'rt' (run-time) module.\n- * Each of those run-time conversion functions accepts another conversion\n- * description that specifies how to format its output.\n- *\n- * The building of the AST is currently done in a module inside the compiler,\n- * but should migrate over here as the plugin interface is defined.\n- */\n-\n-// Functions used by the fmt extension at compile time\n-mod ct {\n-    tag signedness { signed; unsigned; }\n-    tag caseness { case_upper; case_lower; }\n-    tag ty {\n-        ty_bool;\n-        ty_str;\n-        ty_char;\n-        ty_int(signedness);\n-        ty_bits;\n-        ty_hex(caseness);\n-        ty_octal;\n-        // FIXME: More types\n-    }\n-    tag flag {\n-        flag_left_justify;\n-        flag_left_zero_pad;\n-        flag_space_for_sign;\n-        flag_sign_always;\n-        flag_alternate;\n-    }\n-    tag count {\n-        count_is(int);\n-        count_is_param(int);\n-        count_is_next_param;\n-        count_implied;\n-    }\n-\n-    // A formatted conversion from an expression to a string\n-    type conv =\n-        {param: option::t<int>,\n-         flags: [flag],\n-         width: count,\n-         precision: count,\n-         ty: ty};\n-\n-\n-    // A fragment of the output sequence\n-    tag piece { piece_string(istr); piece_conv(conv); }\n-    type error_fn = fn(&istr) -> ! ;\n-\n-    fn parse_fmt_string(s: &istr, error: error_fn) -> [piece] {\n-        let pieces: [piece] = [];\n-        let lim = str::byte_len(s);\n-        let buf = ~\"\";\n-        fn flush_buf(buf: &istr, pieces: &mutable [piece]) -> istr {\n-            if str::byte_len(buf) > 0u {\n-                let piece = piece_string(buf);\n-                pieces += [piece];\n-            }\n-            ret ~\"\";\n-        }\n-        let i = 0u;\n-        while i < lim {\n-            let curr = str::substr(s, i, 1u);\n-            if str::eq(curr, ~\"%\") {\n-                i += 1u;\n-                if i >= lim {\n-                    error(~\"unterminated conversion at end of string\");\n-                }\n-                let curr2 = str::substr(s, i, 1u);\n-                if str::eq(curr2, ~\"%\") {\n-                    i += 1u;\n-                } else {\n-                    buf = flush_buf(buf, pieces);\n-                    let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece];\n-                    i = rs.next;\n-                }\n-            } else { buf += curr; i += 1u; }\n-        }\n-        buf = flush_buf(buf, pieces);\n-        ret pieces;\n-    }\n-    fn peek_num(s: &istr, i: uint, lim: uint) ->\n-       option::t<{num: uint, next: uint}> {\n-        if i >= lim { ret none; }\n-        let c = s[i];\n-        if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n-        let n = c - ('0' as u8) as uint;\n-        ret alt peek_num(s, i + 1u, lim) {\n-              none. { some({num: n, next: i + 1u}) }\n-              some(next) {\n-                let m = next.num;\n-                let j = next.next;\n-                some({num: n * 10u + m, next: j})\n-              }\n-            };\n-    }\n-    fn parse_conversion(s: &istr, i: uint, lim: uint, error: error_fn) ->\n-       {piece: piece, next: uint} {\n-        let parm = parse_parameter(s, i, lim);\n-        let flags = parse_flags(s, parm.next, lim);\n-        let width = parse_count(s, flags.next, lim);\n-        let prec = parse_precision(s, width.next, lim);\n-        let ty = parse_type(s, prec.next, lim, error);\n-        ret {piece:\n-                 piece_conv({param: parm.param,\n-                             flags: flags.flags,\n-                             width: width.count,\n-                             precision: prec.count,\n-                             ty: ty.ty}),\n-             next: ty.next};\n-    }\n-    fn parse_parameter(s: &istr, i: uint, lim: uint) ->\n-       {param: option::t<int>, next: uint} {\n-        if i >= lim { ret {param: none, next: i}; }\n-        let num = peek_num(s, i, lim);\n-        ret alt num {\n-              none. { {param: none, next: i} }\n-              some(t) {\n-                let n = t.num;\n-                let j = t.next;\n-                if j < lim && s[j] == '$' as u8 {\n-                    {param: some(n as int), next: j + 1u}\n-                } else { {param: none, next: i} }\n-              }\n-            };\n-    }\n-    fn parse_flags(s: &istr, i: uint, lim: uint) ->\n-       {flags: [flag], next: uint} {\n-        let noflags: [flag] = [];\n-        if i >= lim { ret {flags: noflags, next: i}; }\n-\n-        // FIXME: This recursion generates illegal instructions if the return\n-        // value isn't boxed. Only started happening after the ivec conversion\n-        fn more_(f: flag, s: &istr, i: uint, lim: uint) ->\n-           @{flags: [flag], next: uint} {\n-            let next = parse_flags(s, i + 1u, lim);\n-            let rest = next.flags;\n-            let j = next.next;\n-            let curr: [flag] = [f];\n-            ret @{flags: curr + rest, next: j};\n-        }\n-        let more = bind more_(_, s, i, lim);\n-        let f = s[i];\n-        ret if f == '-' as u8 {\n-                *more(flag_left_justify)\n-            } else if f == '0' as u8 {\n-                *more(flag_left_zero_pad)\n-            } else if f == ' ' as u8 {\n-                *more(flag_space_for_sign)\n-            } else if f == '+' as u8 {\n-                *more(flag_sign_always)\n-            } else if f == '#' as u8 {\n-                *more(flag_alternate)\n-            } else { {flags: noflags, next: i} };\n-    }\n-    fn parse_count(s: &istr, i: uint,\n-                   lim: uint) -> {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '*' as u8 {\n-                let param = parse_parameter(s, i + 1u, lim);\n-                let j = param.next;\n-                alt param.param {\n-                  none. { {count: count_is_next_param, next: j} }\n-                  some(n) { {count: count_is_param(n), next: j} }\n-                }\n-            } else {\n-                let num = peek_num(s, i, lim);\n-                alt num {\n-                  none. { {count: count_implied, next: i} }\n-                  some(num) {\n-                    {count: count_is(num.num as int), next: num.next}\n-                  }\n-                }\n-            };\n-    }\n-    fn parse_precision(s: &istr, i: uint, lim: uint) ->\n-       {count: count, next: uint} {\n-        ret if i >= lim {\n-                {count: count_implied, next: i}\n-            } else if s[i] == '.' as u8 {\n-                let count = parse_count(s, i + 1u, lim);\n-\n-\n-                // If there were no digits specified, i.e. the precision\n-                // was \".\", then the precision is 0\n-                alt count.count {\n-                  count_implied. { {count: count_is(0), next: count.next} }\n-                  _ { count }\n-                }\n-            } else { {count: count_implied, next: i} };\n-    }\n-    fn parse_type(s: &istr, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} {\n-        if i >= lim { error(~\"missing type in conversion\"); }\n-        let tstr = str::substr(s, i, 1u);\n-        // TODO: Do we really want two signed types here?\n-        // How important is it to be printf compatible?\n-        let t =\n-            if str::eq(tstr, ~\"b\") {\n-                ty_bool\n-            } else if str::eq(tstr, ~\"s\") {\n-                ty_str\n-            } else if str::eq(tstr, ~\"c\") {\n-                ty_char\n-            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n-                ty_int(signed)\n-            } else if str::eq(tstr, ~\"u\") {\n-                ty_int(unsigned)\n-            } else if str::eq(tstr, ~\"x\") {\n-                ty_hex(case_lower)\n-            } else if str::eq(tstr, ~\"X\") {\n-                ty_hex(case_upper)\n-            } else if str::eq(tstr, ~\"t\") {\n-                ty_bits\n-            } else if str::eq(tstr, ~\"o\") {\n-                ty_octal\n-            } else { error(~\"unknown type in conversion: \" + tstr) };\n-        ret {ty: t, next: i + 1u};\n-    }\n-}\n-\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it this way, I think.\n-mod rt {\n-    tag flag {\n-        flag_left_justify;\n-        flag_left_zero_pad;\n-        flag_space_for_sign;\n-        flag_sign_always;\n-        flag_alternate;\n-\n-\n-        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n-        // which have some difficulty typechecking currently. See\n-        // comments in front::extfmt::make_flags\n-        flag_none;\n-    }\n-    tag count { count_is(int); count_implied; }\n-    tag ty { ty_default; ty_bits; ty_hex_upper; ty_hex_lower; ty_octal; }\n-\n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag\n-    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n-\n-    fn conv_int(cv: &conv, i: int) -> istr {\n-        let radix = 10u;\n-        let prec = get_int_precision(cv);\n-        let s = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = ~\"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = ~\" \" + s;\n-            }\n-        }\n-        ret pad(cv, s, pad_signed);\n-    }\n-    fn conv_uint(cv: &conv, u: uint) -> istr {\n-        let prec = get_int_precision(cv);\n-        let rs =\n-            alt cv.ty {\n-              ty_default. { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n-            };\n-        ret pad(cv, rs, pad_unsigned);\n-    }\n-    fn conv_bool(cv: &conv, b: bool) -> istr {\n-        let s = if b { ~\"true\" } else { ~\"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-\n-        ret conv_str(cv, s);\n-    }\n-    fn conv_char(cv: &conv, c: char) -> istr {\n-        ret pad(cv, str::from_char(c), pad_nozero);\n-    }\n-    fn conv_str(cv: &conv, s: &istr) -> istr {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-\n-        // FIXME: substr works on bytes, not chars!\n-        let unpadded =\n-            alt cv.precision {\n-              count_implied. { s }\n-              count_is(max) {\n-                if max as uint < str::char_len(s) {\n-                    str::substr(s, 0u, max as uint)\n-                } else { s }\n-              }\n-            };\n-        ret pad(cv, unpadded, pad_nozero);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> istr {\n-        ret if num < 0 {\n-                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> istr {\n-        ret if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = uint::to_str(num, radix);\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str_init_elt('0', diff);\n-                    pad + s\n-                } else { s }\n-            };\n-    }\n-    fn get_int_precision(cv: &conv) -> uint {\n-        ret alt cv.precision {\n-              count_is(c) { c as uint }\n-              count_implied. { 1u }\n-            };\n-    }\n-\n-    // FIXME: This might be useful in str: but needs to be utf8 safe first\n-    fn str_init_elt(c: char, n_elts: uint) -> istr {\n-        let svec = vec::init_elt::<u8>(c as u8, n_elts);\n-\n-        ret str::unsafe_from_bytes(svec);\n-    }\n-    tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv, s: &istr, mode: pad_mode) -> istr {\n-        let uwidth;\n-        alt cv.width {\n-          count_implied. { ret s; }\n-          count_is(width) {\n-            // FIXME: Maybe width should be uint\n-\n-            uwidth = width as uint;\n-          }\n-        }\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { ret s; }\n-        let padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str_init_elt(padchar, diff);\n-            ret s + padstr;\n-        }\n-        let might_zero_pad = false;\n-        let signed = false;\n-        alt mode {\n-          pad_nozero. {\n-            // fallthrough\n-\n-          }\n-          pad_signed. { might_zero_pad = true; signed = true; }\n-          pad_unsigned. { might_zero_pad = true; }\n-        }\n-        fn have_precision(cv: &conv) -> bool {\n-            ret alt cv.precision { count_implied. { false } _ { true } };\n-        }\n-        let zero_padding = false;\n-        if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-               !have_precision(cv) {\n-            padchar = '0';\n-            zero_padding = true;\n-        }\n-        let padstr = str_init_elt(padchar, diff);\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && str::byte_len(s) > 0u {\n-            let head = s[0];\n-            if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes([head]);\n-                let bytelen = str::byte_len(s);\n-                let numpart = str::substr(s, 1u, bytelen - 1u);\n-                ret headstr + padstr + numpart;\n-            }\n-        }\n-        ret padstr + s;\n-    }\n-    fn have_flag(flags: &[flag], f: flag) -> bool {\n-        for candidate: flag in flags { if candidate == f { ret true; } }\n-        ret false;\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "c4188cfeb5524ec3367239939eb04266c81b6c3d", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d3eb4911a227500c51858cdb830fe27cb5b9ca7/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1d3eb4911a227500c51858cdb830fe27cb5b9ca7/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=1d3eb4911a227500c51858cdb830fe27cb5b9ca7", "patch": "@@ -86,7 +86,6 @@ mod sha1;\n mod ebml;\n mod ufind;\n mod extfmt;\n-mod extifmt;\n mod box;\n mod getopts;\n mod time;"}]}