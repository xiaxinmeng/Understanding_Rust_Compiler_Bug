{"sha": "3945ace520ff93e6edc03c75141cfaff3fbb832c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NDVhY2U1MjBmZjkzZTZlZGMwM2M3NTE0MWNmYWZmM2ZiYjgzMmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T18:56:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T18:56:02Z"}, "message": "rustc: Write out an index of definition info in crate metadata", "tree": {"sha": "4b99d56577ada2d6dce62ebcb8801a6e13cda80b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b99d56577ada2d6dce62ebcb8801a6e13cda80b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3945ace520ff93e6edc03c75141cfaff3fbb832c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3945ace520ff93e6edc03c75141cfaff3fbb832c", "html_url": "https://github.com/rust-lang/rust/commit/3945ace520ff93e6edc03c75141cfaff3fbb832c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3945ace520ff93e6edc03c75141cfaff3fbb832c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a60cb1e0cf4bdc37e78c0560e6fed0743a9c271", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a60cb1e0cf4bdc37e78c0560e6fed0743a9c271", "html_url": "https://github.com/rust-lang/rust/commit/6a60cb1e0cf4bdc37e78c0560e6fed0743a9c271"}], "stats": {"total": 151, "additions": 111, "deletions": 40}, "files": [{"sha": "c285edd0b790ee32aea8cc63483bd71235d27907", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=3945ace520ff93e6edc03c75141cfaff3fbb832c", "patch": "@@ -275,8 +275,7 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n                             ebml.move_to_parent(ebml_r);\n                             auto nm = _str.unsafe_from_bytes(name_data);\n                             name_opt = some[ast.ident](nm);\n-                        } else if (inner_tag.id ==\n-                                metadata.tag_items_def_id) {\n+                        } else if (inner_tag.id == metadata.tag_def_id) {\n                             ebml.move_to_first_child(ebml_r);\n                             auto did_data = ebml.read_data(ebml_r);\n                             ebml.move_to_parent(ebml_r);\n@@ -336,13 +335,12 @@ impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n \n             while (ebml.bytes_left(ebml_r) > 0u) {\n                 auto inner_ebml_tag = ebml.peek(ebml_r);\n-                if (inner_ebml_tag.id == metadata.tag_items_item) {\n+                if (inner_ebml_tag.id == metadata.tag_items_data_item) {\n                     ebml.move_to_first_child(ebml_r);\n \n                     while (ebml.bytes_left(ebml_r) > 0u) {\n                         auto innermost_ebml_tag = ebml.peek(ebml_r);\n-                        if (innermost_ebml_tag.id ==\n-                                metadata.tag_items_def_id) {\n+                        if (innermost_ebml_tag.id == metadata.tag_def_id) {\n                             ebml.move_to_first_child(ebml_r);\n                             auto did_data = ebml.read_data(ebml_r);\n                             ebml.move_to_parent(ebml_r);\n@@ -408,7 +406,7 @@ impure fn get_item_kind(&ebml.reader ebml_r) -> u8 {\n         ret data.(0);\n     }\n     auto f = converter;\n-    ret get_item_generic[u8](ebml_r, metadata.tag_items_kind, f);\n+    ret get_item_generic[u8](ebml_r, metadata.tag_items_data_item_kind, f);\n }\n \n impure fn get_item_symbol(&ebml.reader ebml_r) -> str {\n@@ -418,7 +416,7 @@ impure fn get_item_symbol(&ebml.reader ebml_r) -> str {\n         ret _str.unsafe_from_bytes(data);\n     }\n     auto f = converter;\n-    ret get_item_generic[str](ebml_r, metadata.tag_items_symbol, f);\n+    ret get_item_generic[str](ebml_r, metadata.tag_items_data_item_symbol, f);\n }\n \n // FIXME: This is a *terrible* botch.\n@@ -430,7 +428,8 @@ impure fn impure_parse_def_id(vec[u8] data) -> ast.def_id {\n \n impure fn get_variant_tag_id(&ebml.reader ebml_r) -> ast.def_id {\n     auto f = impure_parse_def_id;\n-    ret get_item_generic[ast.def_id](ebml_r, metadata.tag_items_tag_id, f);\n+    ret get_item_generic[ast.def_id](ebml_r,\n+                                     metadata.tag_items_data_item_tag_id, f);\n }\n \n impure fn get_item_type(&ebml.reader ebml_r, int this_cnum) -> @ty.t {\n@@ -448,15 +447,15 @@ impure fn get_item_type(&ebml.reader ebml_r, int this_cnum) -> @ty.t {\n         ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n     }\n     auto f = bind converter(this_cnum, _);\n-    ret get_item_generic[@ty.t](ebml_r, metadata.tag_items_type, f);\n+    ret get_item_generic[@ty.t](ebml_r, metadata.tag_items_data_item_type, f);\n }\n \n impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n         -> vec[ast.def_id] {\n     let vec[ast.def_id] tps = vec();\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == metadata.tag_items_ty_param) {\n+        if (ebml_tag.id == metadata.tag_items_data_item_ty_param) {\n             ebml.move_to_first_child(ebml_r);\n \n             auto data = ebml.read_data(ebml_r);"}, {"sha": "eae3aecb71b5182d7810aa628b92760d359195eb", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 100, "deletions": 30, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=3945ace520ff93e6edc03c75141cfaff3fbb832c", "patch": "@@ -1,4 +1,5 @@\n import std._str;\n+import std._uint;\n import std._vec;\n import std.ebml;\n import std.io;\n@@ -22,15 +23,23 @@ const uint tag_paths_name = 0x03u;\n const uint tag_paths_item = 0x04u;\n const uint tag_paths_mod = 0x05u;\n \n-const uint tag_items_item = 0x06u;\n-const uint tag_items_def_id = 0x07u;\n-const uint tag_items_kind = 0x08u;\n-const uint tag_items_ty_param = 0x09u;\n-const uint tag_items_type = 0x0au;\n-const uint tag_items_symbol = 0x0bu;\n-const uint tag_items_variant = 0x0cu;\n-const uint tag_items_tag_id = 0x0du;\n-const uint tag_items_obj_type_id = 0x0eu;\n+const uint tag_def_id = 0x06u;\n+\n+const uint tag_items_data = 0x07u;\n+const uint tag_items_data_item = 0x08u;\n+const uint tag_items_data_item_kind = 0x09u;\n+const uint tag_items_data_item_ty_param = 0x0au;\n+const uint tag_items_data_item_type = 0x0bu;\n+const uint tag_items_data_item_symbol = 0x0cu;\n+const uint tag_items_data_item_variant = 0x0du;\n+const uint tag_items_data_item_tag_id = 0x0eu;\n+const uint tag_items_data_item_obj_type_id = 0x0fu;\n+\n+const uint tag_items_index = 0x10u;\n+const uint tag_items_index_buckets = 0x11u;\n+const uint tag_items_index_buckets_bucket = 0x12u;\n+const uint tag_items_index_buckets_bucket_elt = 0x13u;\n+const uint tag_items_index_table = 0x14u;\n \n // Type encoding\n \n@@ -161,7 +170,7 @@ fn encode_name(&ebml.writer ebml_w, str name) {\n }\n \n fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_items_def_id);\n+    ebml.start_tag(ebml_w, tag_def_id);\n     ebml_w.writer.write(_str.bytes(def_to_str(id)));\n     ebml.end_tag(ebml_w);\n }\n@@ -259,7 +268,7 @@ fn encode_item_paths(&ebml.writer ebml_w, @ast.crate crate) {\n // Item info table encoding\n \n fn encode_kind(&ebml.writer ebml_w, u8 c) {\n-    ebml.start_tag(ebml_w, tag_items_kind);\n+    ebml.start_tag(ebml_w, tag_items_data_item_kind);\n     ebml_w.writer.write(vec(c));\n     ebml.end_tag(ebml_w);\n }\n@@ -271,40 +280,40 @@ fn def_to_str(ast.def_id did) -> str {\n // TODO: We need to encode the \"crate numbers\" somewhere for diamond imports.\n fn encode_type_params(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n     for (ast.ty_param tp in tps) {\n-        ebml.start_tag(ebml_w, tag_items_ty_param);\n+        ebml.start_tag(ebml_w, tag_items_data_item_ty_param);\n         ebml_w.writer.write(_str.bytes(def_to_str(tp.id)));\n         ebml.end_tag(ebml_w);\n     }\n }\n \n fn encode_type(&ebml.writer ebml_w, @ty.t typ) {\n-    ebml.start_tag(ebml_w, tag_items_type);\n+    ebml.start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n     ebml_w.writer.write(_str.bytes(ty_str(typ, f)));\n     ebml.end_tag(ebml_w);\n }\n \n fn encode_symbol(@trans.crate_ctxt cx, &ebml.writer ebml_w, ast.def_id did) {\n-    ebml.start_tag(ebml_w, tag_items_symbol);\n+    ebml.start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(_str.bytes(cx.item_symbols.get(did)));\n     ebml.end_tag(ebml_w);\n }\n \n fn encode_discriminant(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                        ast.def_id did) {\n-    ebml.start_tag(ebml_w, tag_items_symbol);\n+    ebml.start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(_str.bytes(cx.discrim_symbols.get(did)));\n     ebml.end_tag(ebml_w);\n }\n \n fn encode_tag_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_items_tag_id);\n+    ebml.start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(_str.bytes(def_to_str(id)));\n     ebml.end_tag(ebml_w);\n }\n \n fn encode_obj_type_id(&ebml.writer ebml_w, &ast.def_id id) {\n-    ebml.start_tag(ebml_w, tag_items_obj_type_id);\n+    ebml.start_tag(ebml_w, tag_items_data_item_obj_type_id);\n     ebml_w.writer.write(_str.bytes(def_to_str(id)));\n     ebml.end_tag(ebml_w);\n }\n@@ -313,7 +322,7 @@ fn encode_obj_type_id(&ebml.writer ebml_w, &ast.def_id id) {\n fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                            ast.def_id did, vec[ast.variant] variants) {\n     for (ast.variant variant in variants) {\n-        ebml.start_tag(ebml_w, tag_items_item);\n+        ebml.start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n@@ -330,15 +339,15 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                         @ast.item item) {\n     alt (item.node) {\n         case (ast.item_const(_, _, _, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'c' as u8);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_fn(_, _, ?tps, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_params(ebml_w, tps);\n@@ -347,27 +356,27 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_mod(_, _, ?did)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'm' as u8);\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_native_mod(_, _, ?did)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'n' as u8);\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_ty(?id, _, ?tps, ?did, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_params(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_tag(?id, ?variants, ?tps, ?did)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_params(ebml_w, tps);\n@@ -376,7 +385,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_tag_variant_info(cx, ebml_w, did, variants);\n         }\n         case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ctor);\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_params(ebml_w, tps);\n@@ -385,7 +394,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_symbol(cx, ebml_w, odid.ctor);\n             ebml.end_tag(ebml_w);\n \n-            ebml.start_tag(ebml_w, tag_items_item);\n+            ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_params(ebml_w, tps);\n@@ -397,7 +406,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n \n fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                                @ast.native_item nitem) {\n-    ebml.start_tag(ebml_w, tag_items_item);\n+    ebml.start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n@@ -413,26 +422,87 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n     ebml.end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w) {\n+fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n+        -> vec[tup(ast.def_id, uint)] {\n+    let vec[tup(ast.def_id, uint)] index = vec();\n+\n     ebml.start_tag(ebml_w, tag_items);\n     for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n+        index += vec(tup(kvp._0, ebml_w.writer.tell()));\n         encode_info_for_item(cx, ebml_w, kvp._1);\n     }\n     for each (@tup(ast.def_id, @ast.native_item) kvp in\n             cx.native_items.items()) {\n+        index += vec(tup(kvp._0, ebml_w.writer.tell()));\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n     ebml.end_tag(ebml_w);\n+\n+    ret index;\n+}\n+\n+\n+// Definition ID indexing\n+\n+fn create_index(vec[tup(ast.def_id, uint)] index)\n+        -> vec[vec[tup(ast.def_id, uint)]] {\n+    let vec[vec[tup(ast.def_id, uint)]] buckets = vec();\n+    for each (uint i in _uint.range(0u, 256u)) {\n+        let vec[tup(ast.def_id, uint)] bucket = vec();\n+        buckets += vec(bucket);\n+    }\n+\n+    for (tup(ast.def_id, uint) elt in index) {\n+        auto h = common.hash_def(elt._0);\n+        buckets.(h % 256u) += vec(elt);\n+    }\n+\n+    ret buckets;\n+}\n+\n+impure fn encode_index(&ebml.writer ebml_w,\n+                       vec[tup(ast.def_id, uint)] index) {\n+    auto writer = io.new_writer_(ebml_w.writer);\n+\n+    auto buckets = create_index(index);\n+\n+    ebml.start_tag(ebml_w, tag_items_index);\n+\n+    let vec[uint] bucket_locs = vec();\n+    ebml.start_tag(ebml_w, tag_items_index_buckets);\n+    for (vec[tup(ast.def_id, uint)] bucket in buckets) {\n+        bucket_locs += vec(ebml_w.writer.tell());\n+\n+        ebml.start_tag(ebml_w, tag_items_index_buckets_bucket);\n+        for (tup(ast.def_id, uint) elt in bucket) {\n+            ebml.start_tag(ebml_w, tag_items_index_buckets_bucket_elt);\n+            writer.write_be_uint(elt._1, 4u);\n+            writer.write_str(def_to_str(elt._0));\n+            ebml.end_tag(ebml_w);\n+        }\n+        ebml.end_tag(ebml_w);\n+    }\n+    ebml.end_tag(ebml_w);\n+\n+    ebml.start_tag(ebml_w, tag_items_index_table);\n+    for (uint pos in bucket_locs) {\n+        writer.write_be_uint(pos, 4u);\n+    }\n+    ebml.end_tag(ebml_w);\n+\n+    ebml.end_tag(ebml_w);\n }\n \n \n-fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate) -> ValueRef {\n+impure fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n+        -> ValueRef {\n     auto string_w = io.string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n     auto ebml_w = ebml.create_writer(buf_w);\n \n     encode_item_paths(ebml_w, crate);\n-    encode_info_for_items(cx, ebml_w);\n+    auto index = encode_info_for_items(cx, ebml_w);\n+    encode_index(ebml_w, index);\n \n     ret C_postr(string_w.get_str());\n }"}, {"sha": "e15d1842759c6342d4ce009c6263b5d4c8bcb494", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3945ace520ff93e6edc03c75141cfaff3fbb832c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=3945ace520ff93e6edc03c75141cfaff3fbb832c", "patch": "@@ -48,6 +48,8 @@ auth front.creader.get_type = impure;\n auth front.creader.get_symbol = impure;\n auth front.creader.impure_no_op = impure;\n auth middle.metadata = unsafe;\n+auth middle.metadata.encode_index = impure;\n+auth middle.metadata.encode_metadata = impure;\n auth middle.trans = unsafe;\n auth middle.trans.copy_any_self_to_alloca = impure;\n auth middle.trans.copy_args_to_allocas = impure;"}]}