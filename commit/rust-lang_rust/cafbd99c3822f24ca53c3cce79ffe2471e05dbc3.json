{"sha": "cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZmJkOTljMzgyMmYyNGNhNTNjM2NjZTc5ZmZlMjQ3MWUwNWRiYzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-30T08:51:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T08:40:50Z"}, "message": "extend NLL regions to include free region indices and add outlives", "tree": {"sha": "799402bab481bff6136b465702fbe9003f825ee8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/799402bab481bff6136b465702fbe9003f825ee8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "html_url": "https://github.com/rust-lang/rust/commit/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b30e8d6681b10d6b7ecf92aa52d3085c5218a85", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b30e8d6681b10d6b7ecf92aa52d3085c5218a85", "html_url": "https://github.com/rust-lang/rust/commit/7b30e8d6681b10d6b7ecf92aa52d3085c5218a85"}], "stats": {"total": 410, "additions": 297, "deletions": 113}, "files": [{"sha": "85f05a10cd9d5fdb0ba568d2932fdf93a1ce1810", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -38,7 +38,7 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<&'a RegionInferenceContext>,\n+    nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -69,7 +69,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<&'a RegionInferenceContext>)\n+               nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>)\n                -> Self {\n         let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n                                           location_map: FxHashMap(),\n@@ -140,7 +140,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         if let Some(regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = regioncx.region_value(borrow_data.region.to_region_index());\n-                if !borrow_region.may_contain(location) && location != borrow_data.location {\n+                if !borrow_region.may_contain_point(location) && location != borrow_data.location {\n                     debug!(\"kill_loans_out_of_scope_at_location: kill{:?} \\\n                            location={:?} borrow_data={:?}\", borrow_index, location, borrow_data);\n                     sets.kill(&borrow_index);"}, {"sha": "f077dd4d1240afe389eaad92d3b7653f4b77e6eb", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -29,7 +29,7 @@ use super::region_infer::RegionInferenceContext;\n \n pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    regioncx: &mut RegionInferenceContext,\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n     mir: &Mir<'tcx>,\n     mir_source: MirSource,\n     liveness: &LivenessResults,\n@@ -45,7 +45,7 @@ pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n \n struct ConstraintGeneration<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &'cx mut RegionInferenceContext,\n+    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n     mir: &'cx Mir<'tcx>,\n     liveness: &'cx LivenessResults,\n     mir_source: MirSource,"}, {"sha": "006a2f9047ad9a64211f14721562d2f1309353be", "filename": "src/librustc_mir/transform/nll/free_regions.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to extract the free regions declared on a function and the\n+//! relationships between them. For example:\n+//!\n+//! ```\n+//! fn foo<'a, 'b, 'c: 'b>() { }\n+//! ```\n+//!\n+//! here we would be returning a map assigning each of `{'a, 'b, 'c}`\n+//! to an index, as well as the `FreeRegionMap` which can compute\n+//! relationships between them.\n+//!\n+//! The code in this file doesn't *do anything* with those results; it\n+//! just returns them for other code to use.\n+\n+use rustc::infer::InferCtxt;\n+use rustc::middle::free_region::FreeRegionMap;\n+use rustc::mir::transform::MirSource;\n+use rustc::ty;\n+use rustc::ty::subst::Substs;\n+use rustc::util::nodemap::FxHashMap;\n+\n+#[derive(Debug)]\n+pub struct FreeRegions<'tcx> {\n+    /// Given a free region defined on this function (either early- or\n+    /// late-bound), this maps it to its internal region index. The\n+    /// corresponding variable will be \"capped\" so that it cannot\n+    /// grow.\n+    pub indices: FxHashMap<ty::Region<'tcx>, usize>,\n+\n+    /// The map from the typeck tables telling us how to relate free regions.\n+    pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n+}\n+\n+pub fn free_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    source: MirSource,\n+) -> FreeRegions<'tcx> {\n+    debug!(\"free_regions(source={:?})\", source);\n+\n+    let item_id = source.item_id();\n+    let item_def_id = infcx.tcx.hir.local_def_id(item_id);\n+\n+    let mut indices = FxHashMap();\n+\n+    // Extract the early regions.\n+    let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n+    for item_subst in item_substs {\n+        if let Some(region) = item_subst.as_region() {\n+            insert_free_region(&mut indices, region);\n+        }\n+    }\n+\n+    // Extract the late-bound regions. Use the liberated fn sigs,\n+    // where the late-bound regions will have been converted into free\n+    // regions, and add them to the map.\n+    let fn_hir_id = infcx.tcx.hir.node_to_hir_id(item_id);\n+    let tables = infcx.tcx.typeck_tables_of(item_def_id);\n+    let fn_sig = tables.liberated_fn_sigs()[fn_hir_id].clone();\n+    infcx\n+        .tcx\n+        .for_each_free_region(&fn_sig.inputs_and_output, |region| {\n+            if let ty::ReFree(_) = *region {\n+                insert_free_region(&mut indices, region);\n+            }\n+        });\n+\n+    debug!(\"free_regions: indices={:#?}\", indices);\n+\n+    FreeRegions { indices, free_region_map: &tables.free_region_map }\n+}\n+\n+fn insert_free_region<'tcx>(\n+    free_regions: &mut FxHashMap<ty::Region<'tcx>, usize>,\n+    region: ty::Region<'tcx>,\n+) {\n+    let len = free_regions.len();\n+    free_regions.entry(region).or_insert(len);\n+}"}, {"sha": "2dd9b85c29466be88921e58803020e04446eb36e", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -22,6 +22,7 @@ use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+mod free_regions;\n mod subtype;\n \n pub(crate) mod region_infer;\n@@ -36,9 +37,12 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source: MirSource,\n     mir: &mut Mir<'tcx>,\n-) -> RegionInferenceContext {\n+) -> RegionInferenceContext<'tcx> {\n+    // Compute named region information.\n+    let free_regions = &free_regions::free_regions(infcx, source);\n+\n     // Replace all regions with fresh inference variables.\n-    let num_region_variables = renumber::renumber_mir(infcx, mir);\n+    let num_region_variables = renumber::renumber_mir(infcx, free_regions, mir);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -61,11 +65,9 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n \n     // Create the region inference context, generate the constraints,\n     // and then solve them.\n-    let mut regioncx = RegionInferenceContext::new(num_region_variables);\n+    let mut regioncx = RegionInferenceContext::new(free_regions, num_region_variables, mir);\n     constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, source, liveness);\n-    let errors = regioncx.solve(infcx, &mir);\n-\n-    assert!(errors.is_empty(), \"FIXME: report region inference failures\");\n+    regioncx.solve(infcx, &mir);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests.\n@@ -152,11 +154,15 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n #[derive(Clone, Default, PartialEq, Eq)]\n pub struct Region {\n     points: BTreeSet<Location>,\n+    free_regions: BTreeSet<RegionIndex>,\n }\n \n impl fmt::Debug for Region {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(formatter, \"{:?}\", self.points)\n+        formatter.debug_set()\n+                 .entries(&self.points)\n+                 .entries(&self.free_regions)\n+                 .finish()\n     }\n }\n \n@@ -165,9 +171,17 @@ impl Region {\n         self.points.insert(point)\n     }\n \n-    pub fn may_contain(&self, point: Location) -> bool {\n+    pub fn add_free_region(&mut self, region: RegionIndex) -> bool {\n+        self.free_regions.insert(region)\n+    }\n+\n+    pub fn may_contain_point(&self, point: Location) -> bool {\n         self.points.contains(&point)\n     }\n+\n+    pub fn may_contain_free_region(&self, region: RegionIndex) -> bool {\n+        self.free_regions.contains(&region)\n+    }\n }\n \n newtype_index!(RegionIndex {"}, {"sha": "1027cf85090108d7a7420e43f8f981c3a1185e01", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 99, "deletions": 72, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -9,37 +9,49 @@\n // except according to those terms.\n \n use super::{Region, RegionIndex};\n-use std::mem;\n+use super::free_regions::FreeRegions;\n use rustc::infer::InferCtxt;\n use rustc::mir::{Location, Mir};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::ty;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n \n-pub struct RegionInferenceContext {\n+pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionIndex`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    definitions: IndexVec<RegionIndex, RegionDefinition>,\n+    definitions: IndexVec<RegionIndex, RegionDefinition<'tcx>>,\n+\n+    /// The indices of all \"free regions\" in scope. These are the\n+    /// lifetime parameters (anonymous and named) declared in the\n+    /// function signature:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &Foo<'a, 'b>)\n+    ///            ^^  ^^     ^\n+    ///\n+    /// These indices will be from 0..N, as it happens, but we collect\n+    /// them into a vector for convenience.\n+    free_regions: Vec<RegionIndex>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n-\n-    /// List of errors we have accumulated as we add constraints.\n-    /// After solving is done, this is replaced with an empty vector.\n-    errors: Vec<InferenceError>,\n-}\n-\n-pub struct InferenceError {\n-    pub constraint_point: Location,\n-    pub name: (), // FIXME(nashenas88) RegionName\n }\n \n #[derive(Default)]\n-struct RegionDefinition {\n-    name: (), // FIXME(nashenas88) RegionName\n+struct RegionDefinition<'tcx> {\n+    /// If this is a free-region, then this is `Some(X)` where `X` is\n+    /// the name of the region.\n+    name: Option<ty::Region<'tcx>>,\n+\n+    /// If true, this is a constant region which cannot grow larger.\n+    /// This is used for named regions as well as `'static`.\n+    constant: bool,\n+\n+    /// The current value of this inference variable. This starts out\n+    /// empty, but grows as we add constraints. The final value is\n+    /// determined when `solve()` is executed.\n     value: Region,\n-    capped: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -49,14 +61,73 @@ pub struct Constraint {\n     point: Location,\n }\n \n-impl RegionInferenceContext {\n-    pub fn new(num_region_variables: usize) -> Self {\n-        Self {\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Creates a new region inference context with a total of\n+    /// `num_region_variables` valid inference variables; the first N\n+    /// of those will be constant regions representing the free\n+    /// regions defined in `free_regions`.\n+    pub fn new(free_regions: &FreeRegions<'tcx>,\n+               num_region_variables: usize,\n+               mir: &Mir<'tcx>)\n+               -> Self {\n+        let mut result = Self {\n             definitions: (0..num_region_variables)\n                 .map(|_| RegionDefinition::default())\n                 .collect(),\n             constraints: Vec::new(),\n-            errors: Vec::new(),\n+            free_regions: Vec::new(),\n+        };\n+\n+        result.init_free_regions(free_regions, mir);\n+\n+        result\n+    }\n+\n+    fn init_free_regions(&mut self,\n+                         free_regions: &FreeRegions<'tcx>,\n+                         mir: &Mir<'tcx>)\n+    {\n+        let &FreeRegions { ref indices, ref free_region_map } = free_regions;\n+\n+        // For each free region variable X, it should contain:\n+        //\n+        // (a) the entire CFG\n+        // (b) `end(Y)` for all regions Y such that X: Y (or Y <= X)\n+        //\n+        // we add however the regions for clause (b) somewhat in\n+        // reverse, because of how the data structure in\n+        // `free_regions` is organized.\n+        for (free_region, index) in indices {\n+            let variable = RegionIndex::new(*index);\n+\n+            self.free_regions.push(variable);\n+\n+            self.definitions[variable].name = Some(free_region);\n+            self.definitions[variable].constant = true;\n+\n+            // Add all nodes in the CFG to `definition.value`.\n+            for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+                let definition = &mut self.definitions[variable];\n+                for statement_index in 0 .. block_data.statements.len() + 1 {\n+                    let location = Location { block, statement_index };\n+                    definition.value.add_point(location);\n+                }\n+            }\n+\n+            // Add `end(X)` into the set for X.\n+            self.definitions[variable].value.add_free_region(variable);\n+\n+            // Go through each region Y that outlives X (i.e., where\n+            // Y: X is true). Add `end(X)` into the set for `Y`.\n+            for superregion in free_region_map.regions_that_outlive(&free_region) {\n+                let superregion_index = RegionIndex::new(indices[superregion]);\n+                self.definitions[superregion_index].value.add_free_region(variable);\n+            }\n+\n+            debug!(\"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n+                   free_region,\n+                   variable,\n+                   self.definitions[variable].value);\n         }\n     }\n \n@@ -72,42 +143,25 @@ impl RegionInferenceContext {\n         &self.definitions[r].value\n     }\n \n-    /// Flags a region as being \"capped\" -- this means that if its\n-    /// value is required to grow as a result of some constraint\n-    /// (e.g., `add_live_point` or `add_outlives`), that indicates an\n-    /// error. This is used for the regions representing named\n-    /// lifetime parameters on a function: they get initialized to\n-    /// their complete value, and then \"capped\" so that they can no\n-    /// longer grow.\n-    #[allow(dead_code)]\n-    pub(super) fn cap_var(&mut self, v: RegionIndex) {\n-        self.definitions[v].capped = true;\n-    }\n-\n+    /// Indicates that the region variable `v` is live at the point `point`.\n     pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n-        if definition.value.add_point(point) {\n-            if definition.capped {\n-                self.errors.push(InferenceError {\n-                    constraint_point: point,\n-                    name: definition.name,\n-                });\n-            }\n-        }\n+        definition.value.add_point(point);\n     }\n \n+    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n     pub(super) fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n         self.constraints.push(Constraint { sup, sub, point });\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve<'a, 'gcx, 'tcx>(\n+    pub(super) fn solve<'a, 'gcx>(\n         &mut self,\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n-    ) -> Vec<InferenceError>\n+    )\n     where\n         'gcx: 'tcx + 'a,\n         'tcx: 'a,\n@@ -125,32 +179,13 @@ impl RegionInferenceContext {\n \n                 if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n                     changed = true;\n-                    if sup_def.capped {\n-                        // This is kind of a hack, but when we add a\n-                        // constraint, the \"point\" is always the point\n-                        // AFTER the action that induced the\n-                        // constraint. So report the error on the\n-                        // action BEFORE that.\n-                        assert!(constraint.point.statement_index > 0);\n-                        let p = Location {\n-                            block: constraint.point.block,\n-                            statement_index: constraint.point.statement_index - 1,\n-                        };\n-\n-                        self.errors.push(InferenceError {\n-                            constraint_point: p,\n-                            name: sup_def.name,\n-                        });\n-                    }\n                 }\n \n                 debug!(\"    sup (after) : {:?}\", sup_def.value);\n                 debug!(\"    changed     : {:?}\", changed);\n             }\n             debug!(\"\\n\");\n         }\n-\n-        mem::replace(&mut self.errors, Vec::new())\n     }\n }\n \n@@ -179,7 +214,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n         while let Some(p) = stack.pop() {\n             debug!(\"        dfs: p={:?}\", p);\n \n-            if !from_region.may_contain(p) {\n+            if !from_region.may_contain_point(p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n@@ -214,19 +249,11 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n             };\n \n             if successor_points.is_empty() {\n-                // FIXME handle free regions\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-                // for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n-                //     // FIXME(nashenas88) figure out skolemized_end points\n-                //     let block = self.env.graph.skolemized_end(region_decl.name);\n-                //     let skolemized_end_point = Location {\n-                //         block,\n-                //         statement_index: 0,\n-                //     };\n-                //     changed |= to_region.add_point(skolemized_end_point);\n-                // }\n+\n+                to_region.free_regions.extend(&from_region.free_regions);\n             } else {\n                 stack.extend(successor_points);\n             }"}, {"sha": "a3ff7a041ca0714bd2d963274d377cd4ab03f18b", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "modified", "additions": 78, "deletions": 28, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -8,22 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::TypeFoldable;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{Ty, ClosureSubsts, RegionVid, RegionKind};\n-use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n+use rustc::ty::{self, ClosureSubsts, RegionKind, RegionVid, Ty, TypeFoldable};\n+use rustc::mir::{BasicBlock, Local, Location, Mir, Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{self as rustc_infer, InferCtxt};\n use syntax_pos::DUMMY_SP;\n use std::collections::HashMap;\n \n+use super::free_regions::FreeRegions;\n+\n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                    mir: &mut Mir<'tcx>)\n-                                    -> usize\n-{\n-    let mut visitor = NLLVisitor::new(infcx);\n+pub fn renumber_mir<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    free_regions: &FreeRegions<'tcx>,\n+    mir: &mut Mir<'tcx>,\n+) -> usize {\n+    // Create inference variables for each of the free regions\n+    // declared on the function signature.\n+    let free_region_inference_vars = (0..free_regions.indices.len())\n+        .map(|_| {\n+            infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        })\n+        .collect();\n+\n+    let mut visitor = NLLVisitor {\n+        infcx,\n+        lookup_map: HashMap::new(),\n+        num_region_variables: free_regions.indices.len(),\n+        free_regions,\n+        free_region_inference_vars,\n+        arg_count: mir.arg_count,\n+    };\n     visitor.visit_mir(mir);\n     visitor.num_region_variables\n }\n@@ -32,22 +50,40 @@ struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     lookup_map: HashMap<RegionVid, TyContext>,\n     num_region_variables: usize,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    free_regions: &'a FreeRegions<'tcx>,\n+    free_region_inference_vars: Vec<ty::Region<'tcx>>,\n+    arg_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        NLLVisitor {\n-            infcx,\n-            lookup_map: HashMap::new(),\n-            num_region_variables: 0\n-        }\n+    /// Replaces all regions appearing in `value` with fresh inference\n+    /// variables. This is what we do for almost the entire MIR, with\n+    /// the exception of the declared types of our arguments.\n+    fn renumber_regions<T>(&mut self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .tcx\n+            .fold_regions(value, &mut false, |_region, _depth| {\n+                self.num_region_variables += 1;\n+                self.infcx\n+                    .next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+            })\n     }\n \n-    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n-        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n-            self.num_region_variables += 1;\n-            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n-        })\n+    /// Renumbers the regions appearing in `value`, but those regions\n+    /// are expected to be free regions from the function signature.\n+    fn renumber_free_regions<T>(&mut self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .tcx\n+            .fold_regions(value, &mut false, |region, _depth| {\n+                let index = self.free_regions.indices[&region];\n+                self.free_region_inference_vars[index]\n+            })\n     }\n \n     fn store_region(&mut self, region: &RegionKind, lookup: TyContext) {\n@@ -69,17 +105,31 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             self.store_region(region, ty_context);\n         }\n     }\n+\n+    fn is_argument_or_return_slot(&self, local: Local) -> bool {\n+        // The first argument is return slot, next N are arguments.\n+        local.index() <= self.arg_count\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n+        let is_arg = match ty_context {\n+            TyContext::LocalDecl { local, .. } => self.is_argument_or_return_slot(local),\n+            _ => false,\n+        };\n+\n         let old_ty = *ty;\n-        *ty = self.renumber_regions(&old_ty);\n+        *ty = if is_arg {\n+            self.renumber_free_regions(&old_ty)\n+        } else {\n+            self.renumber_regions(&old_ty)\n+        };\n         self.store_ty_regions(ty, ty_context);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{*substs});\n+        *substs = self.renumber_regions(&{ *substs });\n         let ty_context = TyContext::Location(location);\n         for kind in *substs {\n             self.store_kind_regions(kind, ty_context);\n@@ -110,20 +160,20 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n-                            location: Location) {\n+    fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n         *substs = self.renumber_regions(substs);\n         let ty_context = TyContext::Location(location);\n         for kind in substs.substs {\n             self.store_kind_regions(kind, ty_context);\n         }\n     }\n \n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &mut Statement<'tcx>,\n+        location: Location,\n+    ) {\n         if let StatementKind::EndRegion(_) = statement.kind {\n             statement.kind = StatementKind::Nop;\n         }"}, {"sha": "4a3e838beb34829d4958cfd5c38eb9599003188d", "filename": "src/test/compile-fail/nll/region-error.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-error.rs?ref=cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "patch": "@@ -0,0 +1,5 @@\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+    &*x\n+}\n+\n+fn main() { }"}]}