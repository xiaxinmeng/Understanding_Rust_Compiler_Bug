{"sha": "4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMzMyMjUyNWQ5YjY1Y2U0YzZmYzE4M2JjMWNkM2NmYzk0NzczMDA=", "commit": {"author": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-19T16:07:04Z"}, "committer": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-21T15:04:26Z"}, "message": "Separate tests for each lint", "tree": {"sha": "39bed2c86c8549333fa382802f96be346231607e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39bed2c86c8549333fa382802f96be346231607e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "html_url": "https://github.com/rust-lang/rust/commit/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/comments", "author": null, "committer": null, "parents": [{"sha": "86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "html_url": "https://github.com/rust-lang/rust/commit/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1"}], "stats": {"total": 610, "additions": 309, "deletions": 301}, "files": [{"sha": "45aa3e64292e2daf095b9ddce724175fda04461d", "filename": "tests/ui/await_holding_invalid.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/tests%2Fui%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/tests%2Fui%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_invalid.rs?ref=86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "patch": "@@ -1,145 +0,0 @@\n-// edition:2018\n-#![warn(clippy::await_holding_lock, clippy::await_holding_refcell_ref)]\n-\n-use std::cell::RefCell;\n-use std::sync::Mutex;\n-\n-async fn bad_lock(x: &Mutex<u32>) -> u32 {\n-    let guard = x.lock().unwrap();\n-    baz().await\n-}\n-\n-async fn good_lock(x: &Mutex<u32>) -> u32 {\n-    {\n-        let guard = x.lock().unwrap();\n-        let y = *guard + 1;\n-    }\n-    baz().await;\n-    let guard = x.lock().unwrap();\n-    47\n-}\n-\n-async fn baz() -> u32 {\n-    42\n-}\n-\n-async fn also_bad_lock(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let guard = x.lock().unwrap();\n-\n-    let second = baz().await;\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-async fn not_good_lock(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let second = {\n-        let guard = x.lock().unwrap();\n-        baz().await\n-    };\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-#[allow(clippy::manual_async_fn)]\n-fn block_bad_lock(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let guard = x.lock().unwrap();\n-        baz().await\n-    }\n-}\n-\n-async fn bad_refcell(x: &RefCell<u32>) -> u32 {\n-    let b = x.borrow();\n-    baz().await\n-}\n-\n-async fn bad_mut_refcell(x: &RefCell<u32>) -> u32 {\n-    let b = x.borrow_mut();\n-    baz().await\n-}\n-\n-async fn good_refcell(x: &RefCell<u32>) -> u32 {\n-    {\n-        let b = x.borrow_mut();\n-        let y = *b + 1;\n-    }\n-    baz().await;\n-    let b = x.borrow_mut();\n-    47\n-}\n-\n-async fn also_bad_refcell(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let b = x.borrow_mut();\n-\n-    let second = baz().await;\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-async fn less_bad_refcell(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let b = x.borrow_mut();\n-\n-    let second = baz().await;\n-\n-    drop(b);\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-async fn not_good_refcell(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let second = {\n-        let b = x.borrow_mut();\n-        baz().await\n-    };\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-#[allow(clippy::manual_async_fn)]\n-fn block_bad_refcell(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let b = x.borrow_mut();\n-        baz().await\n-    }\n-}\n-\n-fn main() {\n-    {\n-        let m = Mutex::new(100);\n-        good_lock(&m);\n-        bad_lock(&m);\n-        also_bad_lock(&m);\n-        not_good_lock(&m);\n-        block_bad_lock(&m);\n-    }\n-    {\n-        let rc = RefCell::new(100);\n-        good_refcell(&rc);\n-        bad_refcell(&rc);\n-        bad_mut_refcell(&rc);\n-        also_bad_refcell(&rc);\n-        less_bad_refcell(&rc);\n-        not_good_refcell(&rc);\n-        block_bad_refcell(&rc);\n-    }\n-}"}, {"sha": "c8d49820c0209cad978d7da87615cda52cd665b6", "filename": "tests/ui/await_holding_invalid.stderr", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/tests%2Fui%2Fawait_holding_invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/tests%2Fui%2Fawait_holding_invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_invalid.stderr?ref=86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "patch": "@@ -1,156 +0,0 @@\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:8:9\n-   |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n-   |\n-   = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:8:5\n-   |\n-LL | /     let guard = x.lock().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n-\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:29:9\n-   |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n-   |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:29:5\n-   |\n-LL | /     let guard = x.lock().unwrap();\n-LL | |\n-LL | |     let second = baz().await;\n-LL | |\n-...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n-\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:42:13\n-   |\n-LL |         let guard = x.lock().unwrap();\n-   |             ^^^^^\n-   |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:42:9\n-   |\n-LL | /         let guard = x.lock().unwrap();\n-LL | |         baz().await\n-LL | |     };\n-   | |_____^\n-\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:54:13\n-   |\n-LL |         let guard = x.lock().unwrap();\n-   |             ^^^^^\n-   |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:54:9\n-   |\n-LL | /         let guard = x.lock().unwrap();\n-LL | |         baz().await\n-LL | |     }\n-   | |_____^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:60:9\n-   |\n-LL |     let b = x.borrow();\n-   |         ^\n-   |\n-   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:60:5\n-   |\n-LL | /     let b = x.borrow();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:65:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:65:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:82:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:82:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |\n-LL | |     let second = baz().await;\n-LL | |\n-...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:94:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:94:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |\n-LL | |     let second = baz().await;\n-LL | |\n-...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:109:13\n-   |\n-LL |         let b = x.borrow_mut();\n-   |             ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:109:9\n-   |\n-LL | /         let b = x.borrow_mut();\n-LL | |         baz().await\n-LL | |     };\n-   | |_____^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:121:13\n-   |\n-LL |         let b = x.borrow_mut();\n-   |             ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_invalid.rs:121:9\n-   |\n-LL | /         let b = x.borrow_mut();\n-LL | |         baz().await\n-LL | |     }\n-   | |_____^\n-\n-error: aborting due to 10 previous errors\n-"}, {"sha": "0458950edee1c9660d41a4e15a974038f3949eac", "filename": "tests/ui/await_holding_lock.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "patch": "@@ -0,0 +1,65 @@\n+// edition:2018\n+#![warn(clippy::await_holding_lock)]\n+\n+use std::sync::Mutex;\n+\n+async fn bad(x: &Mutex<u32>) -> u32 {\n+    let guard = x.lock().unwrap();\n+    baz().await\n+}\n+\n+async fn good(x: &Mutex<u32>) -> u32 {\n+    {\n+        let guard = x.lock().unwrap();\n+        let y = *guard + 1;\n+    }\n+    baz().await;\n+    let guard = x.lock().unwrap();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let guard = x.lock().unwrap();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let m = Mutex::new(100);\n+    good(&m);\n+    bad(&m);\n+    also_bad(&m);\n+    not_good(&m);\n+    block_bad(&m);\n+}"}, {"sha": "21bf49d16f04877d862ff702ef527575cd537d2f", "filename": "tests/ui/await_holding_lock.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "patch": "@@ -0,0 +1,63 @@\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:7:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+   = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:7:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:28:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:28:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:41:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:41:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:53:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:53:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "88841597bb60bf5bc8a8bff346fdfc9391a40cfe", "filename": "tests/ui/await_holding_refcell_ref.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.rs?ref=4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "patch": "@@ -0,0 +1,86 @@\n+// edition:2018\n+#![warn(clippy::await_holding_refcell_ref)]\n+\n+use std::cell::RefCell;\n+\n+async fn bad(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn less_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    drop(b);\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let rc = RefCell::new(100);\n+    good(&rc);\n+    bad(&rc);\n+    bad_mut(&rc);\n+    also_bad(&rc);\n+    less_bad(&rc);\n+    not_good(&rc);\n+    block_bad(&rc);\n+}"}, {"sha": "b504f0454913634969cb11a6ced5b3fc5e9fb2f9", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "patch": "@@ -0,0 +1,95 @@\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:7:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:7:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:12:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:12:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:33:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:33:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:45:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:45:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:60:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:60:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:72:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:72:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 6 previous errors\n+"}]}