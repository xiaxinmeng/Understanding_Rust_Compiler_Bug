{"sha": "55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZmE4YWZlOTQwMTljYjFkYTI5ZDVmYWI3ZmQ3YWQ1Nzk1YjJjMzk=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-09T10:25:20Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-25T09:29:39Z"}, "message": "BTreeMap: various tweaks", "tree": {"sha": "79ab54405d40c3b5e98d74830d4f56a1c173b2cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ab54405d40c3b5e98d74830d4f56a1c173b2cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "html_url": "https://github.com/rust-lang/rust/commit/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "396552457033925010df3eccbee21bdff2aa1122", "url": "https://api.github.com/repos/rust-lang/rust/commits/396552457033925010df3eccbee21bdff2aa1122", "html_url": "https://github.com/rust-lang/rust/commit/396552457033925010df3eccbee21bdff2aa1122"}], "stats": {"total": 111, "additions": 50, "deletions": 61}, "files": [{"sha": "c3f27c105994fc81cdf046442201b345fbf5b36f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "patch": "@@ -47,8 +47,7 @@ const KV_IDX_CENTER: usize = B - 1;\n const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n \n-/// The underlying representation of leaf nodes.\n-#[repr(C)]\n+/// The underlying representation of leaf nodes and part of the representation of internal nodes.\n struct LeafNode<K, V> {\n     /// We want to be covariant in `K` and `V`.\n     parent: Option<NonNull<InternalNode<K, V>>>,\n@@ -59,9 +58,6 @@ struct LeafNode<K, V> {\n     parent_idx: MaybeUninit<u16>,\n \n     /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n@@ -92,7 +88,9 @@ impl<K, V> LeafNode<K, V> {\n /// node, allowing code to act on leaf and internal nodes generically without having to even check\n /// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n+// gdb_providers.py uses this type name for introspection.\n struct InternalNode<K, V> {\n+    // gdb_providers.py uses this field name for introspection.\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n@@ -183,9 +181,9 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n-    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of\n-    /// `pop_internal_level`.\n+    /// Adds a new internal node with a single edge pointing to the previous root node,\n+    /// make that new node the root node, and return it. This increases the height by 1\n+    /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n@@ -322,7 +320,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node.\n+    /// Exposes the leaf portion of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -472,7 +470,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// Exposes the leaf portion of any leaf or internal node for writing.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -498,18 +496,38 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n     }\n \n-    fn keys_mut(&mut self) -> &mut [K] {\n+    fn keys_mut(&mut self) -> &mut [K]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the key slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    fn vals_mut(&mut self) -> &mut [V] {\n+    fn vals_mut(&mut self) -> &mut [V]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the value slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n+                self.len(),\n+            )\n+        }\n     }\n }\n \n@@ -539,26 +557,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // SAFETY: The keys of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        // SAFETY: The values of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n     unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n@@ -610,8 +608,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n-    pub fn push_front(&mut self, key: K, val: V) {\n-        assert!(self.len() < CAPACITY);\n+    fn push_front(&mut self, key: K, val: V) {\n+        debug_assert!(self.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -683,10 +681,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node and returns the pair.\n     /// If this is an internal node, also removes the edge that was to the right\n-    /// of that pair and returns the orphaned node that this edge owned with its\n-    /// parent erased.\n-    pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -708,10 +705,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n-    /// also removes the edge that was to the left of that pair.\n-    pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// Removes a key/value pair from the beginning of this node and returns the pair.\n+    /// If this is an internal node, also removes the edge that was to the left\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -913,7 +911,6 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n     fn leafy_insert_fit(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n@@ -951,18 +948,18 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let val_ptr = match insertion {\n+            let mut insertion_edge = match insertion {\n                 InsertionPlace::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n                         insert_idx,\n                     )\n-                    .insert_fit(key, val)\n                 },\n             };\n+            let val_ptr = insertion_edge.insert_fit(key, val);\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), val_ptr)\n         }\n     }\n@@ -985,8 +982,6 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but in an internal module\n-        debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n@@ -1136,12 +1131,12 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n             ptr::copy_nonoverlapping(\n                 self.node.key_at(self.idx + 1),\n-                new_node.keys.as_mut_ptr() as *mut K,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.val_at(self.idx + 1),\n-                new_node.vals.as_mut_ptr() as *mut V,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.vals),\n                 new_len,\n             );\n \n@@ -1376,9 +1371,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     move_edges(left, new_left_len + 1, right, 0, count);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1433,9 +1426,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1568,9 +1559,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n                         move_edges(left, left_new_len + 1, right, 1, right_new_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                    _ => {\n-                        unreachable!();\n-                    }\n+                    _ => unreachable!(),\n                 }\n             }\n         }"}]}