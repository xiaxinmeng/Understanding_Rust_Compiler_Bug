{"sha": "085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "node_id": "C_kwDOAAsO6NoAKDA4NWE0OGU3OTgzZDJiM2IxZjZkNmZiZWIxMjdkZDkwYjJhMTM3N2M", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-23T22:33:59Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-30T19:11:01Z"}, "message": "Implement unsizing in the new trait solver", "tree": {"sha": "75aed2b5471a681700be64cbd109deaf8295fcb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75aed2b5471a681700be64cbd109deaf8295fcb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "html_url": "https://github.com/rust-lang/rust/commit/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006ca9b14da1e0145844598b3d6a554c042c702a", "url": "https://api.github.com/repos/rust-lang/rust/commits/006ca9b14da1e0145844598b3d6a554c042c702a", "html_url": "https://github.com/rust-lang/rust/commit/006ca9b14da1e0145844598b3d6a554c042c702a"}], "stats": {"total": 217, "additions": 217, "deletions": 0}, "files": [{"sha": "e6c36d37ffbff27964d6989d2efa0f92c108ee65", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "patch": "@@ -173,6 +173,14 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    // Implement unsizing. The most common forms of unsizing are array to slice,\n+    // and concrete (Sized) type into a `dyn Trait`. ADTs and Tuples can also\n+    // have their final field unsized if it's generic.\n+    fn consider_builtin_unsize_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -303,6 +311,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_future_candidate(self, goal)\n         } else if lang_items.gen_trait() == Some(trait_def_id) {\n             G::consider_builtin_generator_candidate(self, goal)\n+        } else if lang_items.unsize_trait() == Some(trait_def_id) {\n+            G::consider_builtin_unsize_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "00b4fa67d68c96018342a704305bf55edf8d74f8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "patch": "@@ -554,6 +554,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             .to_predicate(tcx),\n         )\n     }\n+\n+    fn consider_builtin_unsize_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "28144da1b1e99665e3daaf39467d553ff85bed2b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "patch": "@@ -8,6 +8,7 @@ use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitable};\n@@ -238,6 +239,180 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             .to_predicate(tcx),\n         )\n     }\n+\n+    fn consider_builtin_unsize_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+        let a_ty = goal.predicate.self_ty();\n+        let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n+        if b_ty.is_ty_var() {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        }\n+        ecx.infcx.probe(|_| {\n+            match (a_ty.kind(), b_ty.kind()) {\n+                // Trait upcasting, or `dyn Trait + Auto + 'a` -> `dyn Trait + 'b`\n+                (\n+                    &ty::Dynamic(a_data, a_region, ty::Dyn),\n+                    &ty::Dynamic(b_data, b_region, ty::Dyn),\n+                ) => {\n+                    // All of a's auto traits need to be in b's auto traits.\n+                    let auto_traits_compatible = b_data\n+                        .auto_traits()\n+                        .all(|b| a_data.auto_traits().any(|a| a == b));\n+                    if !auto_traits_compatible {\n+                        return Err(NoSolution);\n+                    }\n+\n+                    // If the principal def ids match (or are both none), then we're not doing\n+                    // trait upcasting. We're just removing auto traits (or shortening the lifetime).\n+                    if a_data.principal_def_id() == b_data.principal_def_id() {\n+                        // Require that all of the trait predicates from A match B, except for\n+                        // the auto traits. We do this by constructing a new A type with B's\n+                        // auto traits, and equating these types.\n+                        let new_a_data = a_data\n+                            .iter()\n+                            .filter(|a| {\n+                                matches!(\n+                                    a.skip_binder(),\n+                                    ty::ExistentialPredicate::Trait(_) | ty::ExistentialPredicate::Projection(_)\n+                                )\n+                            })\n+                            .chain(\n+                                b_data\n+                                    .auto_traits()\n+                                    .map(ty::ExistentialPredicate::AutoTrait)\n+                                    .map(ty::Binder::dummy),\n+                            );\n+                        let new_a_data = tcx.mk_poly_existential_predicates(new_a_data);\n+                        let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n+\n+                        // We also require that A's lifetime outlives B's lifetime.\n+                        let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                        nested_obligations.push(goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))));\n+\n+                        ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+                    } else if let Some(a_principal) = a_data.principal()\n+                        && let Some(b_principal) = b_data.principal()\n+                        && supertraits(tcx, a_principal.with_self_ty(tcx, a_ty))\n+                            .any(|trait_ref| trait_ref.def_id() == b_principal.def_id())\n+                    {\n+                        // FIXME: Intentionally ignoring `need_migrate_deref_output_trait_object` here for now.\n+                        // Confirm upcasting candidate\n+                        todo!()\n+                    } else {\n+                        Err(NoSolution)\n+                    }\n+                }\n+                // `T` -> `dyn Trait` unsizing\n+                (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n+                    // Can only unsize to an object-safe type\n+                    // FIXME: Can auto traits be *not* object safe?\n+                    if data\n+                        .auto_traits()\n+                        .chain(data.principal_def_id())\n+                        .any(|def_id| !tcx.is_object_safe(def_id))\n+                    {\n+                        return Err(NoSolution);\n+                    }\n+\n+                    let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n+                        return Err(NoSolution);\n+                    };\n+                    let nested_goals: Vec<_> = data\n+                        .iter()\n+                        // Check that the type implements all of the predicates of the def-id.\n+                        // (i.e. the principal, all of the associated types match, and any auto traits)\n+                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n+                        .chain([\n+                            // The type must be Sized to be unsized.\n+                            goal.with(\n+                                tcx,\n+                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n+                            ),\n+                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                            goal.with(\n+                                tcx,\n+                                ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region)),\n+                            ),\n+                        ])\n+                        .collect();\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // `[T; n]` -> `[T]` unsizing\n+                (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n+                    // We just require that the element type stays the same\n+                    let nested_goals = ecx.infcx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n+                (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n+                    if a_def.is_struct() && a_def.did() == b_def.did() =>\n+                {\n+                    let unsizing_params = tcx.unsizing_params_for_adt(a_def.did());\n+                    // We must be unsizing some type parameters. This also implies\n+                    // that the struct has a tail field.\n+                    if unsizing_params.is_empty() {\n+                        return Err(NoSolution);\n+                    }\n+\n+                    let tail_field = a_def\n+                        .non_enum_variant()\n+                        .fields\n+                        .last()\n+                        .expect(\"expected unsized ADT to have a tail field\");\n+                    let tail_field_ty = tcx.bound_type_of(tail_field.did);\n+\n+                    let a_tail_ty = tail_field_ty.subst(tcx, a_substs);\n+                    let b_tail_ty = tail_field_ty.subst(tcx, b_substs);\n+\n+                    // Substitute just the unsizing params from B into A. The type after\n+                    // this substitution must be equal to B. This is so we don't unsize\n+                    // unrelated type parameters.\n+                    let new_a_substs = tcx.mk_substs(a_substs.iter().enumerate().map(|(i, a)| {\n+                        if unsizing_params.contains(i as u32) { b_substs[i] } else { a }\n+                    }));\n+                    let unsized_a_ty = tcx.mk_adt(a_def, new_a_substs);\n+\n+                    // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n+                    // types.\n+                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    nested_goals.push(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(\n+                            tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n+                        ),\n+                    ));\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n+                (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n+                    if a_tys.len() == b_tys.len() && !a_tys.is_empty() =>\n+                {\n+                    let (a_last_ty, a_rest_tys) = a_tys.split_last().unwrap();\n+                    let b_last_ty = b_tys.last().unwrap();\n+\n+                    // Substitute just the tail field of B., and require that they're equal.\n+                    let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]));\n+                    let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+\n+                    // Similar to ADTs, require that the rest of the fields are equal.\n+                    nested_goals.push(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(\n+                            tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n+                        ),\n+                    ));\n+\n+                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                }\n+                _ => Err(NoSolution),\n+            }\n+        })\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "87ed9cfd10ae456e734d9ce8c4d575d9415086bd", "filename": "tests/ui/traits/new-solver/unsize-good.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Funsize-good.rs?ref=085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "patch": "@@ -0,0 +1,25 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+\n+fn main() {\n+    // Unsizing via struct\n+    let _: Box<dyn Foo> = Box::new(1i32);\n+\n+    // Slice unsizing\n+    let y = [1, 2, 3];\n+    let _: &[i32] = &y;\n+\n+    // Tuple unsizing\n+    let hi = (1i32,);\n+    let _: &(dyn Foo,) = &hi;\n+\n+    // Dropping auto traits\n+    let a: &(dyn Foo + Send) = &1;\n+    let _: &dyn Foo = a;\n+}"}]}