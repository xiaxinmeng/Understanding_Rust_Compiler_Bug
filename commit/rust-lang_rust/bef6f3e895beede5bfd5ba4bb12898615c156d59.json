{"sha": "bef6f3e895beede5bfd5ba4bb12898615c156d59", "node_id": "C_kwDOAAsO6NoAKGJlZjZmM2U4OTViZWVkZTViZmQ1YmE0YmIxMjg5ODYxNWMxNTZkNTk", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-15T15:30:30Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-03-30T09:23:58Z"}, "message": "rework implementation for inherent impls for builtin types", "tree": {"sha": "724e0593725707bbff014409e6b495142830315b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/724e0593725707bbff014409e6b495142830315b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bef6f3e895beede5bfd5ba4bb12898615c156d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bef6f3e895beede5bfd5ba4bb12898615c156d59", "html_url": "https://github.com/rust-lang/rust/commit/bef6f3e895beede5bfd5ba4bb12898615c156d59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bef6f3e895beede5bfd5ba4bb12898615c156d59/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4558a125b6108f3c080e88d7746e1d422b969bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/4558a125b6108f3c080e88d7746e1d422b969bef", "html_url": "https://github.com/rust-lang/rust/commit/4558a125b6108f3c080e88d7746e1d422b969bef"}], "stats": {"total": 779, "additions": 365, "deletions": 414}, "files": [{"sha": "7c53f839a92e46546f45da3a56b5c0a66a93fe67", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -636,6 +636,14 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word), ErrorFollowing,\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n+    rustc_attr!(\n+        rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing,\n+        \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n+    ),\n+    rustc_attr!(\n+        rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n+    ),\n     BuiltinAttribute {\n         name: sym::rustc_diagnostic_item,\n         type_: Normal,"}, {"sha": "de8c0800ac122b22f2b98482f475dff36a7aa012", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -95,6 +95,11 @@ crate struct CrateMetadata {\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n     trait_impls: FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<SimplifiedType>)]>>,\n+    /// Inherent impls which do not follow the normal coherence rules.\n+    ///\n+    /// These can be introduces using either `#![rustc_coherence_is_core]`\n+    /// or `#[rustc_allow_incoherent_impl]`.\n+    incoherent_impls: FxHashMap<SimplifiedType, Lazy<[DefIndex]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n@@ -1327,17 +1332,25 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     /// Decodes all trait impls in the crate (for rustdoc).\n     fn get_trait_impls(self) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + 'a {\n-        self.cdata.trait_impls.iter().flat_map(move |((trait_cnum_raw, trait_index), impls)| {\n+        self.cdata.trait_impls.iter().flat_map(move |(&(trait_cnum_raw, trait_index), impls)| {\n             let trait_def_id = DefId {\n-                krate: self.cnum_map[CrateNum::from_u32(*trait_cnum_raw)],\n-                index: *trait_index,\n+                krate: self.cnum_map[CrateNum::from_u32(trait_cnum_raw)],\n+                index: trait_index,\n             };\n             impls.decode(self).map(move |(impl_index, simplified_self_ty)| {\n                 (trait_def_id, self.local_def_id(impl_index), simplified_self_ty)\n             })\n         })\n     }\n \n+    fn get_incoherent_impls(self, tcx: TyCtxt<'tcx>, simp: SimplifiedType) -> &'tcx [DefId] {\n+        if let Some(impls) = self.cdata.incoherent_impls.get(&simp) {\n+            tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))\n+        } else {\n+            &[]\n+        }\n+    }\n+\n     fn get_implementations_of_trait(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -1754,6 +1767,11 @@ impl CrateMetadata {\n             .decode((&blob, sess))\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n+        let incoherent_impls = root\n+            .incoherent_impls\n+            .decode((&blob, sess))\n+            .map(|incoherent_impls| (incoherent_impls.self_ty, incoherent_impls.impls))\n+            .collect();\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n         let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n@@ -1766,6 +1784,7 @@ impl CrateMetadata {\n             blob,\n             root,\n             trait_impls,\n+            incoherent_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n             def_path_hash_map,"}, {"sha": "7fac668f0727f39b39e8a3f0f5768e0c376a664d", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -81,30 +81,42 @@ macro_rules! provide {\n // small trait to work around different signature queries all being defined via\n // the macro above.\n trait IntoArgs {\n-    fn into_args(self) -> (DefId, DefId);\n+    type Other;\n+    fn into_args(self) -> (DefId, Self::Other);\n }\n \n impl IntoArgs for DefId {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self, self)\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self, ())\n     }\n }\n \n impl IntoArgs for CrateNum {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self.as_def_id(), self.as_def_id())\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self.as_def_id(), ())\n     }\n }\n \n impl IntoArgs for (CrateNum, DefId) {\n+    type Other = DefId;\n     fn into_args(self) -> (DefId, DefId) {\n         (self.0.as_def_id(), self.1)\n     }\n }\n \n impl<'tcx> IntoArgs for ty::InstanceDef<'tcx> {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self.def_id(), self.def_id())\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self.def_id(), ())\n+    }\n+}\n+\n+impl IntoArgs for (CrateNum, SimplifiedType) {\n+    type Other = SimplifiedType;\n+    fn into_args(self) -> (DefId, SimplifiedType) {\n+        (self.0.as_def_id(), self.1)\n     }\n }\n \n@@ -199,6 +211,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n+    crate_incoherent_impls => { cdata.get_incoherent_impls(tcx, other) }\n \n     dep_kind => {\n         let r = *cdata.dep_kind.lock();\n@@ -371,7 +384,6 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n         crates: |tcx, ()| tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).crates_untracked()),\n-\n         ..*providers\n     };\n }"}, {"sha": "a219b9eb2be832374a8a227c30a85f5158e0922d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -2,8 +2,9 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -578,6 +579,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let tcx = self.tcx;\n         let mut i = self.position();\n \n         // Encode the crate deps\n@@ -623,8 +625,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let impls = self.encode_impls();\n         let impls_bytes = self.position() - i;\n \n-        let tcx = self.tcx;\n-\n+        i = self.position();\n+        let incoherent_impls = self.encode_incoherent_impls();\n+        let incoherent_impls_bytes = self.position() - i;\n         // Encode MIR.\n         i = self.position();\n         self.encode_mir();\n@@ -734,6 +737,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             source_map,\n             traits,\n             impls,\n+            incoherent_impls,\n             exported_symbols,\n             interpret_alloc_index,\n             tables,\n@@ -762,6 +766,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             eprintln!(\"      source_map bytes: {}\", source_map_bytes);\n             eprintln!(\"          traits bytes: {}\", traits_bytes);\n             eprintln!(\"           impls bytes: {}\", impls_bytes);\n+            eprintln!(\"incoherent_impls bytes: {}\", incoherent_impls_bytes);\n             eprintln!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             eprintln!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             eprintln!(\" def-path hashes bytes: {}\", def_path_hash_map_bytes);\n@@ -1813,6 +1818,33 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(&all_impls)\n     }\n \n+    fn encode_incoherent_impls(&mut self) -> Lazy<[IncoherentImpls]> {\n+        debug!(\"EncodeContext::encode_traits_and_impls()\");\n+        empty_proc_macro!(self);\n+        let tcx = self.tcx;\n+        let mut ctx = tcx.create_stable_hashing_context();\n+        let mut all_impls: Vec<_> = tcx.crate_inherent_impls(()).incoherent_impls.iter().collect();\n+        all_impls.sort_by_cached_key(|&(&simp, _)| {\n+            let mut hasher = StableHasher::new();\n+            simp.hash_stable(&mut ctx, &mut hasher);\n+            hasher.finish::<Fingerprint>();\n+        });\n+        let all_impls: Vec<_> = all_impls\n+            .into_iter()\n+            .map(|(&simp, impls)| {\n+                let mut impls: Vec<_> =\n+                    impls.into_iter().map(|def_id| def_id.local_def_index).collect();\n+                impls.sort_by_cached_key(|&local_def_index| {\n+                    tcx.hir().def_path_hash(LocalDefId { local_def_index })\n+                });\n+\n+                IncoherentImpls { self_ty: simp, impls: self.lazy(impls) }\n+            })\n+            .collect();\n+\n+        self.lazy(&all_impls)\n+    }\n+\n     // Encodes all symbols exported from this crate into the metadata.\n     //\n     // This pass is seeded off the reachability list calculated in the"}, {"sha": "204284ffaa3f999b615a42129aafd2dc0ad90c64", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -212,6 +212,7 @@ crate struct CrateRoot<'tcx> {\n     foreign_modules: Lazy<[ForeignModule]>,\n     traits: Lazy<[DefIndex]>,\n     impls: Lazy<[TraitImpls]>,\n+    incoherent_impls: Lazy<[IncoherentImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n     proc_macro_data: Option<ProcMacroData>,\n \n@@ -251,6 +252,12 @@ crate struct TraitImpls {\n     impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n }\n \n+#[derive(MetadataEncodable, MetadataDecodable)]\n+crate struct IncoherentImpls {\n+    self_ty: SimplifiedType,\n+    impls: Lazy<[DefIndex]>,\n+}\n+\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {"}, {"sha": "8afa6e70e41839024b8a941d7fd6ecb0cb4a4b2b", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -579,6 +579,10 @@ impl<'hir> Map<'hir> {\n         self.attrs(CRATE_HIR_ID)\n     }\n \n+    pub fn rustc_coherence_is_core(self) -> bool {\n+        self.krate_attrs().iter().any(|attr| attr.has_name(sym::rustc_coherence_is_core))\n+    }\n+\n     pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {"}, {"sha": "6d7e7ef0cb072a070aff48a4d2b24bda0ae511d0", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -684,6 +684,10 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query incoherent_impls(key: SimplifiedType) -> &'tcx [DefId] {\n+        desc { |tcx| \"collecting all inherent impls for `{:?}`\", key }\n+    }\n+\n     /// The result of unsafety-checking this `LocalDefId`.\n     query unsafety_check_result(key: LocalDefId) -> &'tcx mir::UnsafetyCheckResult {\n         desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n@@ -1469,6 +1473,15 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    /// Collects all incoherent impls for the given crate and type.\n+    ///\n+    /// Do not call this directly, but instead use the `incoherent_impls` query.\n+    /// This query is only used to get the data necessary for that query.\n+    query crate_incoherent_impls(key: (CrateNum, SimplifiedType)) -> &'tcx [DefId] {\n+        desc { |tcx| \"collecting all impls for a type in a crate\" }\n+        separate_provide_extern\n+    }\n+\n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n         desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "2009364b24e608cc32b9dccb87c5c53857bc5813", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -4,6 +4,7 @@\n use crate::middle::region;\n use crate::mir;\n use crate::ty;\n+use crate::ty::fast_reject::SimplifiedType;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::HashingControls;\n@@ -55,6 +56,18 @@ where\n     }\n }\n \n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for SimplifiedType {\n+    type KeyType = Fingerprint;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> Fingerprint {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx: StableHashingContext<'a> = hcx.clone();\n+        self.hash_stable(&mut hcx, &mut hasher);\n+        hasher.finish()\n+    }\n+}\n+\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.unpack().hash_stable(hcx, hasher);"}, {"sha": "dfc405b1195ee8ed346b6c7c77157d7eb7ff6cdb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -25,6 +25,7 @@ use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n+use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::Discr;\n use rustc_ast as ast;\n@@ -2335,6 +2336,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     super::middle::provide(providers);\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n+        incoherent_impls: trait_def::incoherent_impls_provider,\n         type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n         vtable_allocation: vtable::vtable_allocation_provider,\n@@ -2350,6 +2352,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n #[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: LocalDefIdMap<Vec<DefId>>,\n+    pub incoherent_impls: FxHashMap<SimplifiedType, Vec<LocalDefId>>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]"}, {"sha": "943f610cc0dd30d9370c394a62cee963e3ce23dd", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -2,9 +2,11 @@ use crate::traits::specialization_graph;\n use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ident, Ty, TyCtxt};\n+use hir::def_id::LOCAL_CRATE;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::DefPathHash;\n+use std::iter;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -257,3 +259,19 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n \n     impls\n }\n+\n+// Query provider for `incoherent_impls`.\n+#[instrument(level = \"debug\", skip(tcx))]\n+pub(super) fn incoherent_impls_provider(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n+    let mut impls = Vec::new();\n+\n+    for cnum in iter::once(LOCAL_CRATE).chain(tcx.crates(()).iter().copied()) {\n+        for &impl_def_id in tcx.crate_incoherent_impls((cnum, simp)) {\n+            impls.push(impl_def_id)\n+        }\n+    }\n+\n+    debug!(?impls);\n+\n+    tcx.arena.alloc_slice(&impls)\n+}"}, {"sha": "8aa659fa6ac7c54453e29eb84d216af4b7647059", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -120,6 +120,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::must_not_suspend => self.check_must_not_suspend(&attr, span, target),\n                 sym::must_use => self.check_must_use(hir_id, &attr, span, target),\n                 sym::rustc_pass_by_value => self.check_pass_by_value(&attr, span, target),\n+                sym::rustc_allow_incoherent_impl => {\n+                    self.check_allow_incoherent_impl(&attr, span, target)\n+                }\n                 sym::rustc_const_unstable\n                 | sym::rustc_const_stable\n                 | sym::unstable\n@@ -1080,6 +1083,24 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Warns against some misuses of `#[pass_by_value]`\n+    fn check_allow_incoherent_impl(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::Method(MethodKind::Inherent) => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        \"`rustc_allow_incoherent_impl` attribute should be applied to impl items.\",\n+                    )\n+                    .span_label(span, \"the only currently supported targets are inherent methods\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     /// Warns against some misuses of `#[must_use]`\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);"}, {"sha": "f1f83a7299c4d97740c2997e02055dcf466759bb", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -141,6 +141,16 @@ impl Key for ty::WithOptConstParam<LocalDefId> {\n     }\n }\n \n+impl Key for SimplifiedType {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for (DefId, DefId) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n@@ -215,6 +225,16 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl Key for (CrateNum, SimplifiedType) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0 == LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for (DefId, SimplifiedType) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "6dd9b8e44dd40f1d54be1632ad8da252f3f34aaf", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -1160,10 +1160,12 @@ symbols! {\n         rustc_allocator,\n         rustc_allocator_nounwind,\n         rustc_allow_const_fn_unstable,\n+        rustc_allow_incoherent_impl,\n         rustc_attrs,\n         rustc_builtin_macro,\n         rustc_capture_analysis,\n         rustc_clean,\n+        rustc_coherence_is_core,\n         rustc_const_stable,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,"}, {"sha": "5d91b3b46a176928427d9958b1bea7cf2dcccdce", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 20, "deletions": 76, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ParamEnvAnd, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -613,9 +614,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_probe(&mut self, self_ty: &Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n-        let lang_items = self.tcx.lang_items();\n-\n-        match *self_ty.value.value.kind() {\n+        let raw_self_ty = self_ty.value.value;\n+        match *raw_self_ty.kind() {\n             ty::Dynamic(data, ..) if let Some(p) = data.principal() => {\n                 // Subtle: we can't use `instantiate_query_response` here: using it will\n                 // commit to all of the type equalities assumed by inference going through\n@@ -650,83 +650,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::Param(p) => {\n                 self.assemble_inherent_candidates_from_param(p);\n             }\n-            ty::Bool => {\n-                let lang_def_id = lang_items.bool_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Char => {\n-                let lang_def_id = lang_items.char_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Str => {\n-                let lang_def_id = lang_items.str_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-\n-                let lang_def_id = lang_items.str_alloc_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Slice(_) => {\n-                for lang_def_id in [\n-                    lang_items.slice_impl(),\n-                    lang_items.slice_u8_impl(),\n-                    lang_items.slice_alloc_impl(),\n-                    lang_items.slice_u8_alloc_impl(),\n-                ] {\n-                    self.assemble_inherent_impl_for_primitive(lang_def_id);\n-                }\n-            }\n-            ty::Array(_, _) => {\n-                let lang_def_id = lang_items.array_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl }) => {\n-                let (lang_def_id1, lang_def_id2) = match mutbl {\n-                    hir::Mutability::Not => {\n-                        (lang_items.const_ptr_impl(), lang_items.const_slice_ptr_impl())\n-                    }\n-                    hir::Mutability::Mut => {\n-                        (lang_items.mut_ptr_impl(), lang_items.mut_slice_ptr_impl())\n-                    }\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id1);\n-                self.assemble_inherent_impl_for_primitive(lang_def_id2);\n-            }\n-            ty::Int(i) => {\n-                let lang_def_id = match i {\n-                    ty::IntTy::I8 => lang_items.i8_impl(),\n-                    ty::IntTy::I16 => lang_items.i16_impl(),\n-                    ty::IntTy::I32 => lang_items.i32_impl(),\n-                    ty::IntTy::I64 => lang_items.i64_impl(),\n-                    ty::IntTy::I128 => lang_items.i128_impl(),\n-                    ty::IntTy::Isize => lang_items.isize_impl(),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Uint(i) => {\n-                let lang_def_id = match i {\n-                    ty::UintTy::U8 => lang_items.u8_impl(),\n-                    ty::UintTy::U16 => lang_items.u16_impl(),\n-                    ty::UintTy::U32 => lang_items.u32_impl(),\n-                    ty::UintTy::U64 => lang_items.u64_impl(),\n-                    ty::UintTy::U128 => lang_items.u128_impl(),\n-                    ty::UintTy::Usize => lang_items.usize_impl(),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Float(f) => {\n-                let (lang_def_id1, lang_def_id2) = match f {\n-                    ty::FloatTy::F32 => (lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n-                    ty::FloatTy::F64 => (lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id1);\n-                self.assemble_inherent_impl_for_primitive(lang_def_id2);\n-            }\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty),\n             _ => {}\n         }\n     }\n \n-    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n-        if let Some(impl_def_id) = lang_def_id {\n+    fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsPlaceholders) else {\n+            bug!(\"unexpected incoherent type: {:?}\", self_ty)\n+        };\n+        for &impl_def_id in self.tcx.incoherent_impls(simp) {\n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }"}, {"sha": "573d072da4b12c0e08bea95f2b2caecb3ee627d6", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 55, "deletions": 323, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -9,10 +9,11 @@\n \n use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::ty::{self, CrateInherentImpls, TyCtxt};\n-\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n+use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n@@ -22,6 +23,13 @@ pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n     collect.impls_map\n }\n \n+pub fn crate_incoherent_impls(tcx: TyCtxt<'_>, (_, simp): (CrateNum, SimplifiedType)) -> &[DefId] {\n+    let crate_map = tcx.crate_inherent_impls(());\n+    tcx.arena.alloc_from_iter(\n+        crate_map.incoherent_impls.get(&simp).unwrap_or(&Vec::new()).iter().map(|d| d.to_def_id()),\n+    )\n+}\n+\n /// On-demand query: yields a vector of the inherent impls for a specific type.\n pub fn inherent_impls(tcx: TyCtxt<'_>, ty_def_id: DefId) -> &[DefId] {\n     let ty_def_id = ty_def_id.expect_local();\n@@ -40,12 +48,11 @@ struct InherentCollect<'tcx> {\n \n impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items: assoc_items, .. }) = item.kind else {\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n             return;\n         };\n \n         let self_ty = self.tcx.type_of(item.def_id);\n-        let lang_items = self.tcx.lang_items();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did());\n@@ -67,274 +74,18 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n                 .note(\"define and implement a new trait or type instead\")\n                 .emit();\n             }\n-            ty::Bool => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.bool_impl(),\n-                    None,\n-                    \"bool\",\n-                    \"bool\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Char => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.char_impl(),\n-                    None,\n-                    \"char\",\n-                    \"char\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Str => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.str_impl(),\n-                    lang_items.str_alloc_impl(),\n-                    \"str\",\n-                    \"str\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.slice_u8_impl(),\n-                    lang_items.slice_u8_alloc_impl(),\n-                    \"slice_u8\",\n-                    \"[u8]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Slice(_) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.slice_impl(),\n-                    lang_items.slice_alloc_impl(),\n-                    \"slice\",\n-                    \"[T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Array(_, _) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.array_impl(),\n-                    None,\n-                    \"array\",\n-                    \"[T; N]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Not })\n-                if matches!(inner.kind(), ty::Slice(_)) =>\n-            {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.const_slice_ptr_impl(),\n-                    None,\n-                    \"const_slice_ptr\",\n-                    \"*const [T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Mut })\n-                if matches!(inner.kind(), ty::Slice(_)) =>\n-            {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.mut_slice_ptr_impl(),\n-                    None,\n-                    \"mut_slice_ptr\",\n-                    \"*mut [T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.const_ptr_impl(),\n-                    None,\n-                    \"const_ptr\",\n-                    \"*const T\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.mut_ptr_impl(),\n-                    None,\n-                    \"mut_ptr\",\n-                    \"*mut T\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I8) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i8_impl(),\n-                    None,\n-                    \"i8\",\n-                    \"i8\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I16) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i16_impl(),\n-                    None,\n-                    \"i16\",\n-                    \"i16\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i32_impl(),\n-                    None,\n-                    \"i32\",\n-                    \"i32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i64_impl(),\n-                    None,\n-                    \"i64\",\n-                    \"i64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I128) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i128_impl(),\n-                    None,\n-                    \"i128\",\n-                    \"i128\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::Isize) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.isize_impl(),\n-                    None,\n-                    \"isize\",\n-                    \"isize\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U8) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u8_impl(),\n-                    None,\n-                    \"u8\",\n-                    \"u8\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U16) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u16_impl(),\n-                    None,\n-                    \"u16\",\n-                    \"u16\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u32_impl(),\n-                    None,\n-                    \"u32\",\n-                    \"u32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u64_impl(),\n-                    None,\n-                    \"u64\",\n-                    \"u64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U128) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u128_impl(),\n-                    None,\n-                    \"u128\",\n-                    \"u128\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::Usize) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.usize_impl(),\n-                    None,\n-                    \"usize\",\n-                    \"usize\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Float(ty::FloatTy::F32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.f32_impl(),\n-                    lang_items.f32_runtime_impl(),\n-                    \"f32\",\n-                    \"f32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Float(ty::FloatTy::F64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.f64_impl(),\n-                    lang_items.f64_runtime_impl(),\n-                    \"f64\",\n-                    \"f64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n             ty::Error(_) => {}\n             _ => {\n                 let mut err = struct_span_err!(\n@@ -390,60 +141,41 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_primitive_impl(\n-        &self,\n+        &mut self,\n         impl_def_id: LocalDefId,\n-        lang_def_id: Option<DefId>,\n-        lang_def_id2: Option<DefId>,\n-        lang: &str,\n-        ty: &str,\n+        ty: Ty<'tcx>,\n+        items: &[hir::ImplItemRef],\n         span: Span,\n-        assoc_items: &[hir::ImplItemRef],\n     ) {\n-        match (lang_def_id, lang_def_id2) {\n-            (Some(lang_def_id), _) if lang_def_id == impl_def_id.to_def_id() => {\n-                // OK\n-            }\n-            (_, Some(lang_def_id)) if lang_def_id == impl_def_id.to_def_id() => {\n-                // OK\n-            }\n-            _ => {\n-                let to_implement = if assoc_items.is_empty() {\n-                    String::new()\n-                } else {\n-                    let assoc_items_kind = {\n-                        let item_types = assoc_items.iter().map(|x| x.kind);\n-                        if item_types.clone().all(|x| x == hir::AssocItemKind::Const) {\n-                            \"constant\"\n-                        } else if item_types\n-                            .clone()\n-                            .all(|x| matches! {x, hir::AssocItemKind::Fn{ .. } })\n-                        {\n-                            \"method\"\n-                        } else {\n-                            \"associated item\"\n-                        }\n-                    };\n-\n-                    format!(\n-                        \" to implement {} {}{}\",\n-                        pluralize!(\"this\", assoc_items.len()),\n-                        assoc_items_kind,\n-                        pluralize!(assoc_items.len()),\n-                    )\n-                };\n-\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0390,\n-                    \"only a single inherent implementation marked with `#[lang = \\\n-                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n-                    lang,\n-                    ty\n-                )\n-                .help(&format!(\"consider using a trait{}\", to_implement))\n-                .emit();\n+        const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n+        const ADD_ATTR: &str =\n+            \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n+        if !self.tcx.hir().rustc_coherence_is_core() {\n+            for item in items {\n+                if !self.tcx.has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                {\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0390,\n+                        \"cannot define inherent `impl` for primitive types\",\n+                    );\n+\n+                    if self.tcx.features().rustc_attrs {\n+                        err.help(INTO_CORE).span_help(item.span, ADD_ATTR);\n+                    } else {\n+                        err.help(\"consider using a trait instead\");\n+                    }\n+                    err.emit();\n+                    return;\n+                }\n             }\n         }\n+\n+        let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsPlaceholders) else {\n+            bug!(\"unexpected primitive type: {:?}\", ty);\n+        };\n+        self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n+        return;\n     }\n }"}, {"sha": "3f1b4828d1af36089e11fa39965c09f6fc0a132f", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -144,13 +144,14 @@ fn enforce_empty_impls_for_marker_traits(\n \n pub fn provide(providers: &mut Providers) {\n     use self::builtin::coerce_unsized_info;\n-    use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n+    use self::inherent_impls::{crate_incoherent_impls, crate_inherent_impls, inherent_impls};\n     use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n     use self::orphan::orphan_check_crate;\n \n     *providers = Providers {\n         coherent_trait,\n         crate_inherent_impls,\n+        crate_incoherent_impls,\n         inherent_impls,\n         crate_inherent_impls_overlap_check,\n         coerce_unsized_info,"}, {"sha": "111c57e884b51317c0edd7807e6f29d458b15091", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -267,6 +267,7 @@ impl<T> [T] {\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n@@ -322,6 +323,7 @@ impl<T> [T] {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n@@ -363,6 +365,7 @@ impl<T> [T] {\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n@@ -409,6 +412,7 @@ impl<T> [T] {\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n@@ -467,6 +471,7 @@ impl<T> [T] {\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[rustc_conversion_suggestion]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -491,6 +496,7 @@ impl<T> [T] {\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn to_vec_in<A: Allocator>(&self, alloc: A) -> Vec<T, A>\n@@ -515,6 +521,7 @@ impl<T> [T] {\n     ///\n     /// assert_eq!(x, vec![10, 40, 30]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n@@ -542,6 +549,7 @@ impl<T> [T] {\n     /// // this will panic at runtime\n     /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>\n@@ -610,6 +618,7 @@ impl<T> [T] {\n     /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n     /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n     where\n@@ -628,6 +637,7 @@ impl<T> [T] {\n     /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n     /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n     where\n@@ -646,6 +656,7 @@ impl<T> [T] {\n     /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n     /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n@@ -669,6 +680,7 @@ impl [u8] {\n     ///\n     /// [`make_ascii_uppercase`]: slice::make_ascii_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the uppercase bytes as a new Vec, \\\n                   without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n@@ -689,6 +701,7 @@ impl [u8] {\n     ///\n     /// [`make_ascii_lowercase`]: slice::make_ascii_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the lowercase bytes as a new Vec, \\\n                   without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"}, {"sha": "bf70363258c9ee3b642a5e2dbca70dd01b4404b7", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -250,6 +250,7 @@ impl str {\n     /// let boxed_bytes = boxed_str.into_boxed_bytes();\n     /// assert_eq!(*boxed_bytes, *s.as_bytes());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n@@ -280,6 +281,7 @@ impl str {\n     /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -320,6 +322,7 @@ impl str {\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n@@ -376,6 +379,7 @@ impl str {\n     /// assert_eq!(new_year, new_year.to_lowercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the lowercase string as a new String, \\\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n@@ -458,6 +462,7 @@ impl str {\n     /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the uppercase string as a new String, \\\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n@@ -493,6 +498,7 @@ impl str {\n     /// assert_eq!(boxed_str.into_string(), string);\n     /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_string(self: Box<str>) -> String {\n@@ -521,6 +527,7 @@ impl str {\n     /// let huge = \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use]\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n@@ -549,6 +556,7 @@ impl str {\n     /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n@@ -581,6 +589,7 @@ impl str {\n     /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]"}, {"sha": "445a7ba6e2d669b4ac58bc7ab751923bbc63a342", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -84,6 +84,7 @@\n     target_has_atomic_load_store = \"ptr\",\n ))]\n #![no_core]\n+#![cfg_attr(not(bootstrap), rustc_coherence_is_core)]\n //\n // Lints:\n #![deny(rust_2021_incompatible_or_patterns)]"}, {"sha": "1faf57e13db8a9e8df6296559cfaaefc7149bcfd", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -43,6 +43,7 @@ impl f32 {\n     /// assert_eq!(g.floor(), 3.0);\n     /// assert_eq!(h.floor(), -4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -61,6 +62,7 @@ impl f32 {\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -80,6 +82,7 @@ impl f32 {\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -100,6 +103,7 @@ impl f32 {\n     /// assert_eq!(g.trunc(), 3.0);\n     /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -120,6 +124,7 @@ impl f32 {\n     /// assert!(abs_difference_x <= f32::EPSILON);\n     /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -144,6 +149,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.abs().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -167,6 +173,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.signum().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -193,6 +200,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.copysign(1.0).is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"copysign\", since = \"1.35.0\")]\n@@ -220,6 +228,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -244,6 +253,7 @@ impl f32 {\n     /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -278,6 +288,7 @@ impl f32 {\n     /// // limitation due to round-off error\n     /// assert!((-f32::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -298,6 +309,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -315,6 +327,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -339,6 +352,7 @@ impl f32 {\n     /// assert!(negative.sqrt().is_nan());\n     /// assert!(negative_zero.sqrt() == negative_zero);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -360,6 +374,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -379,6 +394,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -400,6 +416,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -423,6 +440,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -442,6 +460,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -464,6 +483,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -488,6 +508,7 @@ impl f32 {\n     /// assert!(abs_difference_x <= f32::EPSILON);\n     /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -517,6 +538,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -538,6 +560,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -556,6 +579,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -574,6 +598,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -591,6 +616,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -612,6 +638,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -633,6 +660,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -653,6 +681,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -686,6 +715,7 @@ impl f32 {\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// assert!(abs_difference_2 <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -708,6 +738,7 @@ impl f32 {\n     /// assert!(abs_difference_0 <= f32::EPSILON);\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin_cos(self) -> (f32, f32) {\n@@ -728,6 +759,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -749,6 +781,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -771,6 +804,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -793,6 +827,7 @@ impl f32 {\n     /// // Same result\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -815,6 +850,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -834,6 +870,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -853,6 +890,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -872,6 +910,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= 1e-5);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "22d58ab84cf7b0f64bc89dbd479f6b35c7a8d93e", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef6f3e895beede5bfd5ba4bb12898615c156d59/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=bef6f3e895beede5bfd5ba4bb12898615c156d59", "patch": "@@ -43,6 +43,7 @@ impl f64 {\n     /// assert_eq!(g.floor(), 3.0);\n     /// assert_eq!(h.floor(), -4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -61,6 +62,7 @@ impl f64 {\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -80,6 +82,7 @@ impl f64 {\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -100,6 +103,7 @@ impl f64 {\n     /// assert_eq!(g.trunc(), 3.0);\n     /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -120,6 +124,7 @@ impl f64 {\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -144,6 +149,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.abs().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -167,6 +173,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.signum().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -193,6 +200,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.copysign(1.0).is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"copysign\", since = \"1.35.0\")]\n     #[inline]\n@@ -220,6 +228,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -244,6 +253,7 @@ impl f64 {\n     /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -278,6 +288,7 @@ impl f64 {\n     /// // limitation due to round-off error\n     /// assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -298,6 +309,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -315,6 +327,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -339,6 +352,7 @@ impl f64 {\n     /// assert!(negative.sqrt().is_nan());\n     /// assert!(negative_zero.sqrt() == negative_zero);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -360,6 +374,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -379,6 +394,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -400,6 +416,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -423,6 +440,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -442,6 +460,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -466,6 +485,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -490,6 +510,7 @@ impl f64 {\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -519,6 +540,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -540,6 +562,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -558,6 +581,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -576,6 +600,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -593,6 +618,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-14);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -614,6 +640,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -635,6 +662,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -655,6 +683,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -688,6 +717,7 @@ impl f64 {\n     /// assert!(abs_difference_1 < 1e-10);\n     /// assert!(abs_difference_2 < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -710,6 +740,7 @@ impl f64 {\n     /// assert!(abs_difference_0 < 1e-10);\n     /// assert!(abs_difference_1 < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin_cos(self) -> (f64, f64) {\n@@ -730,6 +761,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-20);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -751,6 +783,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-20);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -773,6 +806,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -795,6 +829,7 @@ impl f64 {\n     /// // Same result\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -817,6 +852,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -836,6 +872,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -855,6 +892,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -874,6 +912,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -884,6 +923,7 @@ impl f64 {\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN).\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n         if !cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n             log_fn(self)"}]}