{"sha": "cc760a647ac0094814f592d08813ebae0b3bec47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzYwYTY0N2FjMDA5NDgxNGY1OTJkMDg4MTNlYmFlMGIzYmVjNDc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-19T11:51:37Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-19T15:06:16Z"}, "message": "syntax: modernise attribute handling in syntax::attr.\n\nThis does a number of things, but especially dramatically reduce the\nnumber of allocations performed for operations involving attributes/\nmeta items:\n\n- Converts ast::meta_item & ast::attribute and other associated enums\n  to CamelCase.\n- Converts several standalone functions in syntax::attr into methods,\n  defined on two traits AttrMetaMethods & AttributeMethods. The former\n  is common to both MetaItem and Attribute since the latter is a thin\n  wrapper around the former.\n- Deletes functions that are unnecessary due to iterators.\n- Converts other standalone functions to use iterators and the generic\n  AttrMetaMethods rather than allocating a lot of new vectors (e.g. the\n  old code would have to allocate a new vector to use functions that\n  operated on &[meta_item] on &[attribute].)\n- Moves the core algorithm of the #[cfg] matching to syntax::attr,\n  similar to find_inline_attr and find_linkage_metas.\n\nThis doesn't have much of an effect on the speed of #[cfg] stripping,\ndespite hugely reducing the number of allocations performed; presumably\nmost of the time is spent in the ast folder rather than doing attribute\nchecks.\n\nAlso fixes the Eq instance of MetaItem_ to correctly ignore spaces, so\nthat `rustc --cfg 'foo(bar)'` now works.", "tree": {"sha": "75ccb57c1c05b195ed8992a66cdd4a14441fca34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75ccb57c1c05b195ed8992a66cdd4a14441fca34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc760a647ac0094814f592d08813ebae0b3bec47", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc760a647ac0094814f592d08813ebae0b3bec47", "html_url": "https://github.com/rust-lang/rust/commit/cc760a647ac0094814f592d08813ebae0b3bec47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc760a647ac0094814f592d08813ebae0b3bec47/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32586faa6adb890bc25caa8b5cb692e8c37e4a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/32586faa6adb890bc25caa8b5cb692e8c37e4a89", "html_url": "https://github.com/rust-lang/rust/commit/32586faa6adb890bc25caa8b5cb692e8c37e4a89"}], "stats": {"total": 1539, "additions": 728, "deletions": 811}, "files": [{"sha": "6bccf7268bb48b251e1037fc46e28e949a819603", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -36,6 +36,7 @@ use std::vec;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::attr;\n+use syntax::attr::{AttrMetaMethods};\n use syntax::print::pprust;\n use syntax::parse::token;\n \n@@ -502,7 +503,7 @@ pub fn build_link_meta(sess: Session,\n     struct ProvidedMetas {\n         name: Option<@str>,\n         vers: Option<@str>,\n-        cmh_items: ~[@ast::meta_item]\n+        cmh_items: ~[@ast::MetaItem]\n     }\n \n     fn provided_link_metas(sess: Session, c: &ast::crate) ->\n@@ -513,18 +514,10 @@ pub fn build_link_meta(sess: Session,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.iter().advance |meta| {\n-            match attr::get_meta_item_value_str(*meta) {\n-                Some(value) => {\n-                    let item_name : &str = attr::get_meta_item_name(*meta);\n-                    match item_name {\n-                        // Changing attr would avoid the need for the copy\n-                        // here\n-                        \"name\" => name = Some(value),\n-                        \"vers\" => vers = Some(value),\n-                        _ => cmh_items.push(*meta)\n-                    }\n-                },\n-                None => cmh_items.push(*meta)\n+            match meta.name_str_pair() {\n+                Some((n, value)) if \"name\" == n => name = Some(value),\n+                Some((n, value)) if \"vers\" == n => vers = Some(value),\n+                _ => cmh_items.push(*meta)\n             }\n         }\n \n@@ -537,7 +530,7 @@ pub fn build_link_meta(sess: Session,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n-                              cmh_items: ~[@ast::meta_item],\n+                              cmh_items: ~[@ast::MetaItem],\n                               dep_hashes: ~[@str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n@@ -549,16 +542,16 @@ pub fn build_link_meta(sess: Session,\n \n         let cmh_items = attr::sort_meta_items(cmh_items);\n \n-        fn hash(symbol_hasher: &mut hash::State, m: &@ast::meta_item) {\n+        fn hash(symbol_hasher: &mut hash::State, m: &@ast::MetaItem) {\n             match m.node {\n-              ast::meta_name_value(key, value) => {\n+              ast::MetaNameValue(key, value) => {\n                 write_string(symbol_hasher, len_and_str(key));\n                 write_string(symbol_hasher, len_and_str_lit(value));\n               }\n-              ast::meta_word(name) => {\n+              ast::MetaWord(name) => {\n                 write_string(symbol_hasher, len_and_str(name));\n               }\n-              ast::meta_list(name, ref mis) => {\n+              ast::MetaList(name, ref mis) => {\n                 write_string(symbol_hasher, len_and_str(name));\n                 for mis.iter().advance |m_| {\n                     hash(symbol_hasher, m_);"}, {"sha": "796e6213921c2550a247fa17888d56c3cc9486f6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -34,6 +34,7 @@ use extra::getopts;\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n+use syntax::attr::{AttrMetaMethods};\n use syntax::codemap;\n use syntax::diagnostic;\n use syntax::parse;\n@@ -95,12 +96,9 @@ pub fn default_configuration(sess: Session, argv0: @str, input: &input) ->\n          mk(@\"build_input\", source_name(input))];\n }\n \n-pub fn append_configuration(cfg: ast::crate_cfg, name: @str)\n-                         -> ast::crate_cfg {\n-    if attr::contains_name(cfg, name) {\n-        cfg\n-    } else {\n-        vec::append_one(cfg, attr::mk_word_item(name))\n+pub fn append_configuration(cfg: &mut ast::crate_cfg, name: @str) {\n+    if !cfg.iter().any(|mi| mi.name() == name) {\n+        cfg.push(attr::mk_word_item(name))\n     }\n }\n \n@@ -109,18 +107,11 @@ pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n-    let user_cfg = sess.opts.cfg.clone();\n+    let mut user_cfg = sess.opts.cfg.clone();\n     // If the user wants a test runner, then add the test cfg\n-    let user_cfg = if sess.opts.test {\n-        append_configuration(user_cfg, @\"test\")\n-    } else {\n-        user_cfg\n-    };\n-\n+    if sess.opts.test { append_configuration(&mut user_cfg, @\"test\") }\n     // If the user requested GC, then add the GC cfg\n-    let user_cfg = append_configuration(\n-        user_cfg,\n-        if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n+    append_configuration(&mut user_cfg, if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n     return vec::append(user_cfg, default_cfg);\n }\n \n@@ -130,7 +121,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str],\n     do cfgspecs.consume_iter().transform |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n-    }.collect()\n+    }.collect::<ast::crate_cfg>()\n }\n \n pub enum input {\n@@ -215,6 +206,7 @@ pub fn compile_rest(sess: Session,\n         crate = time(time_passes, ~\"configuration 2\", ||\n                      front::config::strip_unconfigured_items(crate));\n \n+\n         crate = time(time_passes, ~\"maybe building test harness\", ||\n                      front::test::modify_for_testing(sess, crate));\n     }\n@@ -870,7 +862,7 @@ pub struct OutputFilenames {\n pub fn build_output_filenames(input: &input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n-                              attrs: &[ast::attribute],\n+                              attrs: &[ast::Attribute],\n                               sess: Session)\n                            -> @OutputFilenames {\n     let obj_path;\n@@ -912,12 +904,10 @@ pub fn build_output_filenames(input: &input,\n           let linkage_metas = attr::find_linkage_metas(attrs);\n           if !linkage_metas.is_empty() {\n               // But if a linkage meta is present, that overrides\n-              let maybe_matches = attr::find_meta_items_by_name(linkage_metas, \"name\");\n-              if !maybe_matches.is_empty() {\n-                  match attr::get_meta_item_value_str(maybe_matches[0]) {\n-                      Some(s) => stem = s,\n-                      _ => ()\n-                  }\n+              let maybe_name = linkage_metas.iter().find_(|m| \"name\" == m.name());\n+              match maybe_name.chain(|m| m.value_str()) {\n+                  Some(s) => stem = s,\n+                  _ => ()\n               }\n               // If the name is missing, we just default to the filename\n               // version\n@@ -1011,7 +1001,8 @@ mod test {\n             @\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, @\"whatever\", &str_input(@\"\"));\n-        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n-        assert_eq!(test_items.len(), 1u);\n+        let mut test_items = cfg.iter().filter(|m| \"test\" == m.name());\n+        assert!(test_items.next().is_some());\n+        assert!(test_items.next().is_none());\n     }\n }"}, {"sha": "6bdab3ad7150d856249ff41a28dad07bf26b72c0", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -369,7 +369,7 @@ pub fn building_library(req_crate_type: crate_type,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 \"crate_type\") {\n-              Some(s) if \"lib\" == s => true,\n+              Some(s) => \"lib\" == s,\n               _ => false\n             }\n         }\n@@ -395,18 +395,11 @@ mod test {\n     use driver::session::{unknown_crate};\n \n     use syntax::ast;\n+    use syntax::attr;\n     use syntax::codemap;\n \n-    fn make_crate_type_attr(t: @str) -> ast::attribute {\n-        codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n-            style: ast::attr_outer,\n-            value: @codemap::respan(codemap::dummy_sp(),\n-                ast::meta_name_value(\n-                    @\"crate_type\",\n-                    codemap::respan(codemap::dummy_sp(),\n-                                     ast::lit_str(t)))),\n-            is_sugared_doc: false\n-        })\n+    fn make_crate_type_attr(t: @str) -> ast::Attribute {\n+        attr::mk_attr(attr::mk_name_value_item_str(@\"crate_type\", t))\n     }\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {"}, {"sha": "c8049ef8cfd1eab75a32374e5b17e32d30d7e72b", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -12,7 +12,7 @@\n use std::option;\n use syntax::{ast, fold, attr};\n \n-type in_cfg_pred = @fn(attrs: &[ast::attribute]) -> bool;\n+type in_cfg_pred = @fn(attrs: &[ast::Attribute]) -> bool;\n \n struct Context {\n     in_cfg: in_cfg_pred\n@@ -175,31 +175,6 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &[@ast::meta_item], attrs: &[ast::attribute]) -> bool {\n-    metas_in_cfg(cfg, attr::attr_metas(attrs))\n-}\n-\n-pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n-                    metas: &[@ast::meta_item]) -> bool {\n-    // The \"cfg\" attributes on the item\n-    let cfg_metas = attr::find_meta_items_by_name(metas, \"cfg\");\n-\n-    // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n-    // so we can match against them. This is the list of configurations for\n-    // which the item is valid\n-    let cfg_metas = cfg_metas.consume_iter()\n-        .filter_map(|i| attr::get_meta_item_list(i))\n-        .collect::<~[~[@ast::meta_item]]>();\n-\n-    if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n-\n-    cfg_metas.iter().any(|cfg_meta| {\n-        cfg_meta.iter().all(|cfg_mi| {\n-            match cfg_mi.node {\n-                ast::meta_list(s, ref it) if \"not\" == s\n-                    => it.iter().all(|mi| !attr::contains(cfg, *mi)),\n-                _ => attr::contains(cfg, *cfg_mi)\n-            }\n-        })\n-    })\n+fn in_cfg(cfg: &[@ast::MetaItem], attrs: &[ast::Attribute]) -> bool {\n+    attr::test_cfg(cfg, attrs.iter().transform(|x| *x))\n }"}, {"sha": "7ddba6ec7b20f04675acd1906b3a0e6053f9ca4d", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -30,10 +30,10 @@ pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::crate)\n }\n \n fn use_std(crate: &ast::crate) -> bool {\n-    !attr::attrs_contains_name(crate.node.attrs, \"no_std\")\n+    !attr::contains_name(crate.node.attrs, \"no_std\")\n }\n-fn no_prelude(attrs: &[ast::attribute]) -> bool {\n-    attr::attrs_contains_name(attrs, \"no_implicit_prelude\")\n+fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n+    attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n@@ -48,14 +48,8 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n                 node: ast::view_item_extern_mod(\n                         sess.ident_of(\"std\"), ~[], n1),\n                 attrs: ~[\n-                    spanned(ast::attribute_ {\n-                        style: ast::attr_inner,\n-                        value: @spanned(ast::meta_name_value(\n-                            @\"vers\",\n-                            spanned(ast::lit_str(STD_VERSION.to_managed()))\n-                        )),\n-                        is_sugared_doc: false\n-                    })\n+                    attr::mk_attr(\n+                        attr::mk_name_value_item_str(@\"vers\", STD_VERSION.to_managed()))\n                 ],\n                 vis: ast::private,\n                 span: dummy_sp()"}, {"sha": "020ad731d5a71dbc7bc6474f0a6888ff962684e8", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -23,6 +23,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n+use syntax::attr::AttrMetaMethods;\n \n type node_id_gen = @fn() -> ast::node_id;\n \n@@ -50,8 +51,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains(crate.node.config,\n-                                     attr::mk_word_item(@\"test\"));\n+    let should_test = attr::contains_name(crate.node.config, \"test\");\n \n     if should_test {\n         generate_test_harness(sess, crate)\n@@ -95,8 +95,8 @@ fn strip_test_functions(crate: &ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {\n-        !attr::contains_name(attr::attr_metas(attrs), \"test\") &&\n-        !attr::contains_name(attr::attr_metas(attrs), \"bench\")\n+        !attr::contains_name(attrs, \"test\") &&\n+        !attr::contains_name(attrs, \"bench\")\n     }\n }\n \n@@ -111,7 +111,7 @@ fn fold_mod(cx: @mut TestCtxt,\n         if !*cx.sess.building_library {\n             @ast::item {\n                 attrs: do item.attrs.iter().filter_map |attr| {\n-                    if \"main\" != attr::get_attr_name(attr) {\n+                    if \"main\" != attr.name() {\n                         Some(*attr)\n                     } else {\n                         None\n@@ -180,8 +180,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n }\n \n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n-    let has_test_attr = !attr::find_attrs_by_name(i.attrs,\n-                                                  \"test\").is_empty();\n+    let has_test_attr = attr::contains_name(i.attrs, \"test\");\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match &i.node {\n@@ -205,11 +204,12 @@ fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n             \"functions used as tests must have signature fn() -> ().\"\n         );\n     }\n+\n     return has_test_attr && has_test_signature(i);\n }\n \n fn is_bench_fn(i: @ast::item) -> bool {\n-    let has_bench_attr = !attr::find_attrs_by_name(i.attrs, \"bench\").is_empty();\n+    let has_bench_attr = attr::contains_name(i.attrs, \"bench\");\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n@@ -233,21 +233,17 @@ fn is_bench_fn(i: @ast::item) -> bool {\n }\n \n fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n-    let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n-    let ignoreitems = attr::attr_metas(ignoreattrs);\n-    return if !ignoreitems.is_empty() {\n-        let cfg_metas = ignoreitems.consume_iter()\n-            .filter_map(|i| attr::get_meta_item_list(i))\n-            .collect::<~[~[@ast::meta_item]]>()\n-            .concat_vec();\n-        config::metas_in_cfg(cx.crate.node.config.clone(), cfg_metas)\n-    } else {\n-        false\n+    do i.attrs.iter().any |attr| {\n+        // check ignore(cfg(foo, bar))\n+        \"ignore\" == attr.name() && match attr.meta_item_list() {\n+            Some(ref cfgs) => attr::test_cfg(cx.crate.node.config, cfgs.iter().transform(|x| *x)),\n+            None => true\n+        }\n     }\n }\n \n fn should_fail(i: @ast::item) -> bool {\n-    !attr::find_attrs_by_name(i.attrs, \"should_fail\").is_empty()\n+    attr::contains_name(i.attrs, \"should_fail\")\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n@@ -278,19 +274,15 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> ast::view_item {\n-    let vers = ast::lit_str(@\"0.8-pre\");\n-    let vers = nospan(vers);\n-    let mi = ast::meta_name_value(@\"vers\", vers);\n-    let mi = nospan(mi);\n-    let id_std = cx.sess.ident_of(\"extra\");\n-    let vi = if is_std(cx) {\n+    let id_extra = cx.sess.ident_of(\"extra\");\n+    let vi = if is_extra(cx) {\n         ast::view_item_use(\n-            ~[@nospan(ast::view_path_simple(id_std,\n-                                            path_node(~[id_std]),\n+            ~[@nospan(ast::view_path_simple(id_extra,\n+                                            path_node(~[id_extra]),\n                                             cx.sess.next_node_id()))])\n     } else {\n-        ast::view_item_extern_mod(id_std, ~[@mi],\n-                           cx.sess.next_node_id())\n+        let mi = attr::mk_name_value_item_str(@\"vers\", @\"0.8-pre\");\n+        ast::view_item_extern_mod(id_extra, ~[mi], cx.sess.next_node_id())\n     };\n     ast::view_item {\n         node: vi,\n@@ -377,15 +369,12 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     )).get()\n }\n \n-fn is_std(cx: &TestCtxt) -> bool {\n-    let is_std = {\n-        let items = attr::find_linkage_metas(cx.crate.node.attrs);\n-        match attr::last_meta_item_value_str_by_name(items, \"name\") {\n-          Some(s) if \"extra\" == s => true,\n-          _ => false\n-        }\n-    };\n-    return is_std;\n+fn is_extra(cx: &TestCtxt) -> bool {\n+    let items = attr::find_linkage_metas(cx.crate.node.attrs);\n+    match attr::last_meta_item_value_str_by_name(items, \"name\") {\n+        Some(s) if \"extra\" == s => true,\n+        _ => false\n+    }\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {"}, {"sha": "16b5ecad5b7c80bc06b52cadbc5d65121ad2d212", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -18,6 +18,7 @@ use metadata::loader;\n \n use std::hashmap::HashMap;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token;\n@@ -59,7 +60,7 @@ struct cache_entry {\n     cnum: int,\n     span: span,\n     hash: @str,\n-    metas: @~[@ast::meta_item]\n+    metas: @~[@ast::MetaItem]\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n@@ -123,10 +124,9 @@ struct Env {\n \n fn visit_crate(e: &Env, c: &ast::crate) {\n     let cstore = e.cstore;\n-    let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n-    for link_args.iter().advance |a| {\n-        match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n+    for c.node.attrs.iter().filter(|m| \"link_args\" == m.name()).advance |a| {\n+        match a.value_str() {\n           Some(ref linkarg) => {\n             cstore::add_used_link_args(cstore, *linkarg);\n           }\n@@ -160,13 +160,17 @@ fn visit_item(e: &Env, i: @ast::item) {\n \n         let cstore = e.cstore;\n         let mut already_added = false;\n-        let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n+        let link_args = i.attrs.iter()\n+            .filter_map(|at| if \"link_args\" == at.name() {Some(at)} else {None})\n+            .collect::<~[&ast::Attribute]>();\n \n         match fm.sort {\n             ast::named => {\n-                let foreign_name =\n-                    match attr::first_attr_value_str_by_name(i.attrs,\n-                                                             \"link_name\") {\n+                let link_name = i.attrs.iter()\n+                    .find_(|at| \"link_name\" == at.name())\n+                    .chain(|at| at.value_str());\n+\n+                let foreign_name = match link_name {\n                         Some(nn) => {\n                             if nn.is_empty() {\n                                 e.diag.span_fatal(\n@@ -178,7 +182,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n                         }\n                         None => token::ident_to_str(&i.ident)\n                     };\n-                if attr::find_attrs_by_name(i.attrs, \"nolink\").is_empty() {\n+                if !attr::contains_name(i.attrs, \"nolink\") {\n                     already_added =\n                         !cstore::add_used_library(cstore, foreign_name);\n                 }\n@@ -190,8 +194,8 @@ fn visit_item(e: &Env, i: @ast::item) {\n             ast::anonymous => { /* do nothing */ }\n         }\n \n-        for link_args.iter().advance |a| {\n-            match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n+        for link_args.iter().advance |m| {\n+            match m.value_str() {\n                 Some(linkarg) => {\n                     cstore::add_used_link_args(cstore, linkarg);\n                 }\n@@ -203,21 +207,21 @@ fn visit_item(e: &Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @str, key: @str, mut metas: ~[@ast::meta_item])\n-    -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, key);\n-    if name_items.is_empty() {\n+fn metas_with(ident: @str, key: @str, mut metas: ~[@ast::MetaItem])\n+    -> ~[@ast::MetaItem] {\n+    // Check if key isn't there yet.\n+    if !attr::contains_name(metas, key) {\n         metas.push(attr::mk_name_value_item_str(key, ident));\n     }\n     metas\n }\n \n-fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n-    -> ~[@ast::meta_item] {\n+fn metas_with_ident(ident: @str, metas: ~[@ast::MetaItem])\n+    -> ~[@ast::MetaItem] {\n     metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: &Env, metas: &[@ast::meta_item], hash: &str)\n+fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n                -> Option<int> {\n     for e.crate_cache.iter().advance |c| {\n         if loader::metadata_matches(*c.metas, metas)\n@@ -230,7 +234,7 @@ fn existing_match(e: &Env, metas: &[@ast::meta_item], hash: &str)\n \n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n-                 metas: ~[@ast::meta_item],\n+                 metas: ~[@ast::MetaItem],\n                  hash: @str,\n                  span: span)\n               -> ast::crate_num {"}, {"sha": "2fc4ba8a1bd4d4da2840c92d189ace6aad3ff305", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -151,7 +151,7 @@ pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::def_id,\n-                      f: &fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::MetaItem])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }"}, {"sha": "f8c6c6288ac04354cbdbf7d8b1ff9274a76d4311", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -966,7 +966,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n pub fn get_item_attrs(cdata: cmd,\n                       node_id: ast::node_id,\n-                      f: &fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::MetaItem])) {\n \n     let item = lookup_item(node_id, cdata.data);\n     for reader::tagged_docs(item, tag_attributes) |attributes| {\n@@ -1073,8 +1073,8 @@ fn item_family_to_str(fam: Family) -> ~str {\n     }\n }\n \n-fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n-    let mut items: ~[@ast::meta_item] = ~[];\n+fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n+    let mut items: ~[@ast::MetaItem] = ~[];\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n@@ -1085,7 +1085,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = nd.as_str_slice().to_managed();\n         let v = vd.as_str_slice().to_managed();\n-        // FIXME (#623): Should be able to decode meta_name_value variants,\n+        // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n     };\n@@ -1098,8 +1098,8 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n-    let mut attrs: ~[ast::attribute] = ~[];\n+fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n+    let mut attrs: ~[ast::Attribute] = ~[];\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n         for reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n@@ -1110,8 +1110,8 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {\n-                    node: ast::attribute_ {\n-                        style: ast::attr_outer,\n+                    node: ast::Attribute_ {\n+                        style: ast::AttrOuter,\n                         value: meta_item,\n                         is_sugared_doc: false,\n                     },\n@@ -1145,7 +1145,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(\"\\n\\n\");\n }\n \n-pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n+pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n     return get_attributes(reader::Doc(data));\n }\n "}, {"sha": "86c470b09edc56b59df9b38e52819803214e775a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -36,6 +36,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::span_handler;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -821,10 +822,11 @@ fn purity_static_method_family(p: purity) -> char {\n }\n \n \n-fn should_inline(attrs: &[attribute]) -> bool {\n-    match attr::find_inline_attr(attrs) {\n-        attr::ia_none | attr::ia_never  => false,\n-        attr::ia_hint | attr::ia_always => true\n+fn should_inline(attrs: &[Attribute]) -> bool {\n+    use syntax::attr::*;\n+    match find_inline_attr(attrs) {\n+        InlineNone | InlineNever  => false,\n+        InlineHint | InlineAlways => true\n     }\n }\n \n@@ -1313,16 +1315,16 @@ fn write_int(writer: @io::Writer, &n: &int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n+fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n     match mi.node {\n-      meta_word(name) => {\n+      MetaWord(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      meta_name_value(name, value) => {\n+      MetaNameValue(name, value) => {\n         match value.node {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n@@ -1337,7 +1339,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      meta_list(name, ref items) => {\n+      MetaList(name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n@@ -1350,7 +1352,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n+fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.iter().advance |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1365,10 +1367,10 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n-                          crate: &crate) -> ~[attribute] {\n+                          crate: &crate) -> ~[Attribute] {\n \n-    fn synthesize_link_attr(ecx: &EncodeContext, items: ~[@meta_item]) ->\n-       attribute {\n+    fn synthesize_link_attr(ecx: &EncodeContext, items: ~[@MetaItem]) ->\n+       Attribute {\n \n         assert!(!ecx.link_meta.name.is_empty());\n         assert!(!ecx.link_meta.vers.is_empty());\n@@ -1380,29 +1382,29 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n             attr::mk_name_value_item_str(@\"vers\",\n                                          ecx.link_meta.vers);\n \n-        let other_items =\n-            {\n-                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n-                attr::remove_meta_items_by_name(tmp, \"vers\")\n-            };\n+        let mut meta_items = ~[name_item, vers_item];\n \n-        let meta_items = vec::append(~[name_item, vers_item], other_items);\n+        for items.iter()\n+            .filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name())\n+            .advance |&mi| {\n+            meta_items.push(mi);\n+        }\n         let link_item = attr::mk_list_item(@\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n \n-    let mut attrs: ~[attribute] = ~[];\n+    let mut attrs = ~[];\n     let mut found_link_attr = false;\n     for crate.node.attrs.iter().advance |attr| {\n         attrs.push(\n-            if \"link\" != attr::get_attr_name(attr)  {\n+            if \"link\" != attr.name()  {\n                 *attr\n             } else {\n-                match attr.node.value.node {\n-                  meta_list(_, ref l) => {\n+                match attr.meta_item_list() {\n+                  Some(l) => {\n                     found_link_attr = true;;\n-                    synthesize_link_attr(ecx, (*l).clone())\n+                    synthesize_link_attr(ecx, l.to_owned())\n                   }\n                   _ => *attr\n                 }"}, {"sha": "d6687b4313a254ef3d206560f274cbff313ceb23", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -22,6 +22,7 @@ use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n+use syntax::attr::AttrMetaMethods;\n \n use std::cast;\n use std::io;\n@@ -46,7 +47,7 @@ pub struct Context {\n     filesearch: @FileSearch,\n     span: span,\n     ident: ast::ident,\n-    metas: ~[@ast::meta_item],\n+    metas: ~[@ast::MetaItem],\n     hash: @str,\n     os: os,\n     is_static: bool,\n@@ -55,7 +56,7 @@ pub struct Context {\n \n pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n-      Some(ref t) => return (/*bad*/(*t).clone()),\n+      Some(t) => t,\n       None => {\n         cx.diag.span_fatal(cx.span,\n                            fmt!(\"can't find crate for `%s`\",\n@@ -140,31 +141,27 @@ fn find_library_crate_aux(\n         }\n }\n \n-pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n+pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n     for metas.iter().advance |m| {\n-        match m.node {\n-            ast::meta_name_value(s, ref l) if s == @\"name\" =>\n-                match l.node {\n-                    ast::lit_str(s) => return s,\n-                    _ => ()\n-                },\n-            _ => ()\n+        match m.name_str_pair() {\n+            Some((name, s)) if \"name\" == name => { return s; }\n+            _ => {}\n         }\n     }\n     fail!(\"expected to find the crate name\")\n }\n \n pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n-                          attrs: ~[ast::attribute]) {\n+                          attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n     for r.iter().advance |mi| {\n         diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n fn crate_matches(crate_data: @~[u8],\n-                 metas: &[@ast::meta_item],\n+                 metas: &[@ast::MetaItem],\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n@@ -175,18 +172,15 @@ fn crate_matches(crate_data: @~[u8],\n     metadata_matches(linkage_metas, metas)\n }\n \n-pub fn metadata_matches(extern_metas: &[@ast::meta_item],\n-                        local_metas: &[@ast::meta_item]) -> bool {\n+pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n+                        local_metas: &[@ast::MetaItem]) -> bool {\n \n     debug!(\"matching %u metadata requirements against %u items\",\n            local_metas.len(), extern_metas.len());\n \n-    for local_metas.iter().advance |needed| {\n-        if !attr::contains(extern_metas, *needed) {\n-            return false;\n-        }\n+    do local_metas.iter().all |needed| {\n+        attr::contains(extern_metas, *needed)\n     }\n-    return true;\n }\n \n fn get_metadata_section(os: os,"}, {"sha": "6f23f94b25e08a5275e034f633de2c53e97d9398", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -13,9 +13,9 @@ use driver::session;\n use driver::session::Session;\n use syntax::parse::token::special_idents;\n use syntax::ast::{crate, node_id, item, item_fn};\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::visit::{default_visitor, mk_vt, vt, Visitor, visit_crate, visit_item};\n-use syntax::attr::{attrs_contains_name};\n use syntax::ast_map;\n use std::util;\n \n@@ -90,7 +90,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n                 }\n             }\n \n-            if attrs_contains_name(item.attrs, \"main\") {\n+            if attr::contains_name(item.attrs, \"main\") {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n@@ -100,7 +100,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n                 }\n             }\n \n-            if attrs_contains_name(item.attrs, \"start\") {\n+            if attr::contains_name(item.attrs, \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {"}, {"sha": "b19b7652a91474e8729446e4e6118c6fd58e40fb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -17,7 +17,7 @@ use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n use syntax::ast::*;\n-use syntax::attr::attrs_contains_name;\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_util};\n@@ -113,7 +113,7 @@ fn check_block(block: &blk, (cx, visitor): (Context, visit::vt<Context>)) {\n \n fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n-    if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n+    if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n@@ -574,4 +574,3 @@ pub fn check_cast_for_escaping_regions(\n         cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n }\n-"}, {"sha": "da557c07906f04772080687caaf14e973352c4f3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -23,9 +23,9 @@\n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use metadata::cstore::iter_crate_data;\n-use syntax::ast::{crate, def_id, lit_str, meta_item};\n-use syntax::ast::{meta_list, meta_name_value, meta_word};\n+use syntax::ast::{crate, def_id, MetaItem};\n use syntax::ast_util::local_def;\n+use syntax::attr::AttrMetaMethods;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n@@ -360,17 +360,12 @@ impl<'self> LanguageItemCollector<'self> {\n \n     pub fn match_and_collect_meta_item(&mut self,\n                                        item_def_id: def_id,\n-                                       meta_item: &meta_item) {\n-        match meta_item.node {\n-            meta_name_value(key, literal) => {\n-                match literal.node {\n-                    lit_str(value) => {\n-                        self.match_and_collect_item(item_def_id, key, value);\n-                    }\n-                    _ => {} // Skip.\n-                }\n+                                       meta_item: &MetaItem) {\n+        match meta_item.name_str_pair() {\n+            Some((key, value)) => {\n+                self.match_and_collect_item(item_def_id, key, value);\n             }\n-            meta_word(*) | meta_list(*) => {} // Skip.\n+            None => {} // skip\n         }\n     }\n "}, {"sha": "2e6696e02fc50380a4717381897847fd65f40d51", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -26,6 +26,7 @@ use std::u64;\n use std::u8;\n use extra::smallintmap::SmallIntMap;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::{ast, visit, ast_util};\n@@ -417,7 +418,7 @@ impl Context {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(@mut self, attrs: &[ast::attribute], f: &fn()) {\n+    fn with_lint_attrs(@mut self, attrs: &[ast::Attribute], f: &fn()) {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -454,18 +455,14 @@ impl Context {\n         }\n \n         // detect doc(hidden)\n-        let mut doc_hidden = false;\n-        let r = attr::find_attrs_by_name(attrs, \"doc\");\n-        for r.iter().advance |attr| {\n-            match attr::get_meta_item_list(attr.node.value) {\n-                Some(s) => {\n-                    if attr::find_meta_items_by_name(s, \"hidden\").len() > 0 {\n-                        doc_hidden = true;\n-                    }\n+        let mut doc_hidden = do attrs.iter().any |attr| {\n+            \"doc\" == attr.name() &&\n+                match attr.meta_item_list() {\n+                    Some(l) => attr::contains_name(l, \"hidden\"),\n+                    None    => false // not of the form #[doc(...)]\n                 }\n-                None => {}\n-            }\n-        }\n+        };\n+\n         if doc_hidden && !self.doc_hidden {\n             self.doc_hidden = true;\n         } else {\n@@ -517,24 +514,23 @@ impl Context {\n }\n \n pub fn each_lint(sess: session::Session,\n-                 attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool {\n+                 attrs: &[ast::Attribute],\n+                 f: &fn(@ast::MetaItem, level, @str) -> bool) -> bool {\n     let xs = [allow, warn, deny, forbid];\n     for xs.iter().advance |&level| {\n         let level_name = level_to_str(level);\n-        let attrs = attr::find_attrs_by_name(attrs, level_name);\n-        for attrs.iter().advance |attr| {\n+        for attrs.iter().filter(|m| level_name == m.name()).advance |attr| {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n-                ast::meta_list(_, ref metas) => metas,\n+                ast::MetaList(_, ref metas) => metas,\n                 _ => {\n                     sess.span_err(meta.span, \"malformed lint attribute\");\n                     loop;\n                 }\n             };\n             for metas.iter().advance |meta| {\n                 match meta.node {\n-                    ast::meta_word(lintname) => {\n+                    ast::MetaWord(lintname) => {\n                         if !f(*meta, level, lintname) {\n                             return false;\n                         }\n@@ -1035,7 +1031,7 @@ fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n }\n \n fn lint_missing_doc() -> visit::vt<@mut Context> {\n-    fn check_attrs(cx: @mut Context, attrs: &[ast::attribute],\n+    fn check_attrs(cx: @mut Context, attrs: &[ast::Attribute],\n                    sp: span, msg: &str) {\n         // If we're building a test harness, then warning about documentation is\n         // probably not really relevant right now"}, {"sha": "69c5392f002f1eec21f9ca96b59bf3048dd00e48", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -376,8 +376,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_item: |item, (method_map, visitor)| {\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n-            if !attr::contains_name(attr::attr_metas(item.attrs),\n-                                    \"!resolve_unexported\") {\n+            if !attr::contains_name(item.attrs, \"!resolve_unexported\") {\n                 visit::visit_item(item, (method_map, visitor));\n             }\n         },"}, {"sha": "d11ac758f6e9a515aa3dd63e81eb93c5e05cc31e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -31,8 +31,8 @@ use syntax::visit;\n \n // Returns true if the given set of attributes contains the `#[inline]`\n // attribute.\n-fn attributes_specify_inlining(attrs: &[attribute]) -> bool {\n-    attr::attrs_contains_name(attrs, \"inline\")\n+fn attributes_specify_inlining(attrs: &[Attribute]) -> bool {\n+    attr::contains_name(attrs, \"inline\")\n }\n \n // Returns true if the given set of generics implies that the item it's\n@@ -431,4 +431,3 @@ pub fn find_reachable(tcx: ty::ctxt,\n     // Return the set of reachable symbols.\n     reachable_context.reachable_symbols\n }\n-"}, {"sha": "fa8390922122f97044be60a06c2208df268e39b7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -26,7 +26,7 @@ use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n-use syntax::attr::{attr_metas, contains_name};\n+use syntax::attr;\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n@@ -3494,8 +3494,7 @@ impl Resolver {\n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n         let orig_xray_flag = self.xray_context;\n-        if contains_name(attr_metas(item.attrs),\n-                         \"!resolve_unexported\") {\n+        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n             self.xray_context = Xray;\n         }\n "}, {"sha": "04a016524bd9d0230d755a8ba14823a3ecde4933", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -79,6 +79,7 @@ use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n use syntax::ast_util::{local_def};\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::span;\n use syntax::parse::token;\n use syntax::parse::token::{special_idents};\n@@ -464,13 +465,14 @@ pub fn set_inline_hint(f: ValueRef) {\n     }\n }\n \n-pub fn set_inline_hint_if_appr(attrs: &[ast::attribute],\n+pub fn set_inline_hint_if_appr(attrs: &[ast::Attribute],\n                                llfn: ValueRef) {\n-    match attr::find_inline_attr(attrs) {\n-      attr::ia_hint => set_inline_hint(llfn),\n-      attr::ia_always => set_always_inline(llfn),\n-      attr::ia_never => set_no_inline(llfn),\n-      attr::ia_none => { /* fallthrough */ }\n+    use syntax::attr::*;\n+    match find_inline_attr(attrs) {\n+        InlineHint   => set_inline_hint(llfn),\n+        InlineAlways => set_always_inline(llfn),\n+        InlineNever  => set_no_inline(llfn),\n+        InlineNone   => { /* fallthrough */ }\n     }\n }\n \n@@ -1845,7 +1847,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      self_arg: self_arg,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n-                     attributes: &[ast::attribute],\n+                     attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n@@ -1868,7 +1870,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n     // Set the fixed stack segment flag if necessary.\n-    if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n+    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n     }\n@@ -1926,7 +1928,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                 self_arg: self_arg,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n-                attrs: &[ast::attribute]) {\n+                attrs: &[ast::Attribute]) {\n \n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n@@ -2196,23 +2198,17 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           // Do static_assert checking. It can't really be done much earlier because we need to get\n           // the value of the bool out of LLVM\n           for item.attrs.iter().advance |attr| {\n-              match attr.node.value.node {\n-                  ast::meta_word(x) => {\n-                      if x.slice(0, x.len()) == \"static_assert\" {\n-                          if m == ast::m_mutbl {\n-                              ccx.sess.span_fatal(expr.span,\n-                                                  \"cannot have static_assert \\\n-                                                   on a mutable static\");\n-                          }\n-                          let v = ccx.const_values.get_copy(&item.id);\n-                          unsafe {\n-                              if !(llvm::LLVMConstIntGetZExtValue(v) as bool) {\n-                                  ccx.sess.span_fatal(expr.span, \"static assertion failed\");\n-                              }\n-                          }\n+              if \"static_assert\" == attr.name() {\n+                  if m == ast::m_mutbl {\n+                      ccx.sess.span_fatal(expr.span,\n+                                          \"cannot have static_assert on a mutable static\");\n+                  }\n+                  let v = ccx.const_values.get_copy(&item.id);\n+                  unsafe {\n+                      if !(llvm::LLVMConstIntGetZExtValue(v) as bool) {\n+                          ccx.sess.span_fatal(expr.span, \"static assertion failed\");\n                       }\n-                  },\n-                  _ => ()\n+                  }\n               }\n           }\n       },\n@@ -2258,7 +2254,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n                    sp: span,\n                    path: path,\n                    node_id: ast::node_id,\n-                   attrs: &[ast::attribute])\n+                   attrs: &[ast::Attribute])\n                 -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, node_id, attrs, t)\n@@ -2268,7 +2264,7 @@ pub fn register_fn_full(ccx: @mut CrateContext,\n                         sp: span,\n                         path: path,\n                         node_id: ast::node_id,\n-                        attrs: &[ast::attribute],\n+                        attrs: &[ast::Attribute],\n                         node_type: ty::t)\n                      -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n@@ -2280,7 +2276,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           sp: span,\n                           path: path,\n                           node_id: ast::node_id,\n-                          attrs: &[ast::attribute],\n+                          attrs: &[ast::Attribute],\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n@@ -2289,7 +2285,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n            node_id,\n            ast_map::path_to_str(path, token::get_ident_interner()));\n \n-    let ps = if attr::attrs_contains_name(attrs, \"no_mangle\") {\n+    let ps = if attr::contains_name(attrs, \"no_mangle\") {\n         path_elt_to_str(*path.last(), token::get_ident_interner())\n     } else {\n         mangle_exported_name(ccx, path, node_type)"}, {"sha": "355e2f57b2c3f9db7041c1824209029a777cdc26", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -351,10 +351,10 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                         cc: lib::llvm::CallConv) {\n         let llwrapfn = get_item_val(ccx, id);\n         let tys = shim_types(ccx, id);\n-        if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n+        if attr::contains_name(foreign_item.attrs, \"rust_stack\") {\n             build_direct_fn(ccx, llwrapfn, foreign_item,\n                             &tys, cc);\n-        } else if attr::attrs_contains_name(foreign_item.attrs, \"fast_ffi\") {\n+        } else if attr::contains_name(foreign_item.attrs, \"fast_ffi\") {\n             build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n         } else {\n             let llshimfn = build_shim_fn(ccx, foreign_item, &tys, cc);\n@@ -546,7 +546,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        item: &ast::foreign_item,\n                        path: ast_map::path,\n                        substs: @param_substs,\n-                       attributes: &[ast::attribute],\n+                       attributes: &[ast::Attribute],\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n@@ -624,7 +624,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n     set_always_inline(fcx.llfn);\n \n     // Set the fixed stack segment flag if necessary.\n-    if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n+    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n@@ -1146,7 +1146,7 @@ pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            sp: span,\n                            path: ast_map::path,\n                            node_id: ast::node_id,\n-                           attrs: &[ast::attribute])\n+                           attrs: &[ast::Attribute])\n                            -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n "}, {"sha": "a2edba7f3d749ca0e5dd3a06f5c649d3655c9933", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -3966,7 +3966,7 @@ pub fn has_attr(tcx: ctxt, did: def_id, attr: &str) -> bool {\n                 &ast_map::node_item(@ast::item {\n                     attrs: ref attrs,\n                     _\n-                }, _)) => attr::attrs_contains_name(*attrs, attr),\n+                }, _)) => attr::contains_name(*attrs, attr),\n             _ => tcx.sess.bug(fmt!(\"has_attr: %? is not an item\",\n                                    did))\n         }"}, {"sha": "f8eff69cc8f3e978b391a0961421afd6748586bd", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -18,24 +18,20 @@ an AST's attributes.\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::attr::{AttrMetaMethods, AttributeMethods};\n \n pub struct CrateAttrs {\n     name: Option<~str>\n }\n \n-fn doc_metas(\n-    attrs: ~[ast::attribute]\n-) -> ~[@ast::meta_item] {\n-\n-    let doc_attrs = attr::find_attrs_by_name(attrs, \"doc\");\n-    let doc_metas = do doc_attrs.map |attr| {\n-        attr::attr_meta(attr::desugar_doc_attr(attr))\n-    };\n-\n-    return doc_metas;\n+fn doc_metas(attrs: ~[ast::Attribute]) -> ~[@ast::MetaItem] {\n+    attrs.iter()\n+        .filter(|at| \"doc\" == at.name())\n+        .transform(|at| at.desugar_doc().meta())\n+        .collect()\n }\n \n-pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n+pub fn parse_crate(attrs: ~[ast::Attribute]) -> CrateAttrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n     let name = attr::last_meta_item_value_str_by_name(link_metas, \"name\");\n \n@@ -44,25 +40,22 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     }\n }\n \n-pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n+pub fn parse_desc(attrs: ~[ast::Attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).consume_iter().filter_map |meta| {\n-        attr::get_meta_item_value_str(meta).map(|s| s.to_owned())\n-    }.collect::<~[~str]>();\n+        meta.value_str()\n+    }.collect::<~[@str]>();\n     if doc_strs.is_empty() {\n         None\n     } else {\n         Some(doc_strs.connect(\"\\n\"))\n     }\n }\n \n-pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n+pub fn parse_hidden(attrs: ~[ast::Attribute]) -> bool {\n     let r = doc_metas(attrs);\n     do r.iter().any |meta| {\n-        match attr::get_meta_item_list(*meta) {\n-            Some(metas) => {\n-                let hiddens = attr::find_meta_items_by_name(metas, \"hidden\");\n-                !hiddens.is_empty()\n-            }\n+        match meta.meta_item_list() {\n+            Some(metas) => attr::contains_name(metas, \"hidden\"),\n             None => false\n         }\n     }\n@@ -74,7 +67,7 @@ mod test {\n     use syntax;\n     use super::{parse_hidden, parse_crate, parse_desc};\n \n-    fn parse_attributes(source: @str) -> ~[ast::attribute] {\n+    fn parse_attributes(source: @str) -> ~[ast::Attribute] {\n         use syntax::parse;\n         use syntax::parse::attr::parser_attr;\n "}, {"sha": "697a699915e246520e48e10d8c046f82436da037", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -68,7 +68,7 @@ fn fold_crate(\n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: attrs.name.clone().get_or_default(doc.topmod.name()),\n+                name: attrs.name.clone().get_or_default(doc.topmod.name_()),\n                 .. doc.topmod.item.clone()\n             },\n             .. doc.topmod.clone()\n@@ -102,7 +102,7 @@ fn fold_item(\n fn parse_item_attrs<T:Send>(\n     srv: astsrv::Srv,\n     id: doc::AstId,\n-    parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {\n+    parse_attrs: ~fn(a: ~[ast::Attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get_copy(&id) {\n             ast_map::node_item(item, _) => item.attrs.clone(),\n@@ -249,7 +249,7 @@ mod test {\n     #[test]\n     fn should_replace_top_module_name_with_crate_name() {\n         let doc = mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-        assert!(doc.cratemod().name() == ~\"bond\");\n+        assert!(doc.cratemod().name_() == ~\"bond\");\n     }\n \n     #[test]"}, {"sha": "cca898feba2b2d49d106a758bffb3dc20e83cc5b", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -355,7 +355,11 @@ impl Item for StructDoc {\n \n pub trait ItemUtils {\n     fn id(&self) -> AstId;\n-    fn name(&self) -> ~str;\n+    /// FIXME #5898: This conflicts with\n+    /// syntax::attr::AttrMetaMethods.name; This rustdoc seems to be on\n+    /// the way out so I'm making this one look bad rather than the\n+    /// new methods in attr.\n+    fn name_(&self) -> ~str;\n     fn path(&self) -> ~[~str];\n     fn brief(&self) -> Option<~str>;\n     fn desc(&self) -> Option<~str>;\n@@ -367,7 +371,7 @@ impl<A:Item> ItemUtils for A {\n         self.item().id\n     }\n \n-    fn name(&self) -> ~str {\n+    fn name_(&self) -> ~str {\n         self.item().name.clone()\n     }\n "}, {"sha": "c027ba7e2f232b509244934534ea7a19c89d9cf3", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -298,21 +298,21 @@ mod test {\n     #[test]\n     fn extract_mods() {\n         let doc = mk_doc(@\"mod a { mod b { } mod c { } }\");\n-        assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n-        assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n-        assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n+        assert!(doc.cratemod().mods()[0].name_() == ~\"a\");\n+        assert!(doc.cratemod().mods()[0].mods()[0].name_() == ~\"b\");\n+        assert!(doc.cratemod().mods()[0].mods()[1].name_() == ~\"c\");\n     }\n \n     #[test]\n     fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(@\"extern { fn a(); }\");\n-        assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n+        assert!(doc.cratemod().nmods()[0].fns[0].name_() == ~\"a\");\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n         let doc = mk_doc(@\"mod a { mod b { mod c { } } }\");\n-        assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n+        assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name_() ==\n             ~\"c\");\n     }\n \n@@ -328,8 +328,8 @@ mod test {\n             @\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n-        assert!(doc.cratemod().fns()[0].name() == ~\"a\");\n-        assert!(doc.cratemod().mods()[0].fns()[0].name() == ~\"c\");\n+        assert!(doc.cratemod().fns()[0].name_() == ~\"a\");\n+        assert!(doc.cratemod().mods()[0].fns()[0].name_() == ~\"c\");\n     }\n \n     #[test]\n@@ -343,30 +343,30 @@ mod test {\n         let source = @\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n-        assert!(doc.cratemod().name() == ~\"burp\");\n+        assert!(doc.cratemod().name_() == ~\"burp\");\n     }\n \n     #[test]\n     fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n-            assert!(doc.cratemod().name() == ~\"name\");\n+            assert!(doc.cratemod().name_() == ~\"name\");\n         }\n     }\n \n     #[test]\n     fn should_extract_const_name_and_id() {\n         let doc = mk_doc(@\"static a: int = 0;\");\n         assert!(doc.cratemod().consts()[0].id() != 0);\n-        assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n+        assert!(doc.cratemod().consts()[0].name_() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_enums() {\n         let doc = mk_doc(@\"enum e { v }\");\n         assert!(doc.cratemod().enums()[0].id() != 0);\n-        assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n+        assert!(doc.cratemod().enums()[0].name_() == ~\"e\");\n     }\n \n     #[test]\n@@ -378,7 +378,7 @@ mod test {\n     #[test]\n     fn should_extract_traits() {\n         let doc = mk_doc(@\"trait i { fn f(); }\");\n-        assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n+        assert!(doc.cratemod().traits()[0].name_() == ~\"i\");\n     }\n \n     #[test]\n@@ -396,13 +396,13 @@ mod test {\n     #[test]\n     fn should_extract_tys() {\n         let doc = mk_doc(@\"type a = int;\");\n-        assert!(doc.cratemod().types()[0].name() == ~\"a\");\n+        assert!(doc.cratemod().types()[0].name_() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_structs() {\n         let doc = mk_doc(@\"struct Foo { field: () }\");\n-        assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n+        assert!(doc.cratemod().structs()[0].name_() == ~\"Foo\");\n     }\n \n     #[test]"}, {"sha": "84b8febd33f549fbf0209d23f595c09ae20c8812", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -172,7 +172,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n }\n \n pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = (doc.path() + &[doc.name()]).connect(\"::\");\n+    let fullpath = (doc.path() + &[doc.name_()]).connect(\"::\");\n     match &doc {\n         &doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n             fullpath\n@@ -200,7 +200,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             fmt!(\"%s for %s%s\", trait_part, *self_ty, bounds)\n         }\n         _ => {\n-            doc.name()\n+            doc.name_()\n         }\n     }\n }"}, {"sha": "c13e85ea71659724ac3b46102a5b905125f458a2", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -159,12 +159,12 @@ pub fn make_filename(\n                 config.output_style == config::DocPerMod {\n                 ~\"index\"\n             } else {\n-                assert!(doc.topmod.name() != ~\"\");\n-                doc.topmod.name()\n+                assert!(doc.topmod.name_() != ~\"\");\n+                doc.topmod.name_()\n             }\n           }\n           doc::ItemPage(doc) => {\n-            (doc.path() + &[doc.name()]).connect(\"_\")\n+            (doc.path() + &[doc.name_()]).connect(\"_\")\n           }\n         }\n     };"}, {"sha": "7526b9557b2cb8a0e719efc5862f1a80cf154ef5", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -174,7 +174,7 @@ mod test {\n     fn should_make_a_page_for_every_mod() {\n         let doc = mk_doc(~\"mod a { }\");\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.pages.mods()[0].name(), ~\"a\");\n+        assert_eq!(doc.pages.mods()[0].name_(), ~\"a\");\n     }\n \n     #[test]"}, {"sha": "aadc1b31acc5296323c13e1027117d9c2ebc3a39", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -48,7 +48,7 @@ fn test_run_passes() {\n                 doc::CratePage(doc::CrateDoc{\n                     topmod: doc::ModDoc{\n                         item: doc::ItemDoc {\n-                            name: doc.cratemod().name() + \"two\",\n+                            name: doc.cratemod().name_() + \"two\",\n                             .. doc.cratemod().item.clone()\n                         },\n                         items: ~[],\n@@ -67,7 +67,7 @@ fn test_run_passes() {\n                 doc::CratePage(doc::CrateDoc{\n                     topmod: doc::ModDoc{\n                         item: doc::ItemDoc {\n-                            name: doc.cratemod().name() + \"three\",\n+                            name: doc.cratemod().name_() + \"three\",\n                             .. doc.cratemod().item.clone()\n                         },\n                         items: ~[],\n@@ -91,6 +91,6 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n-        assert_eq!(doc.cratemod().name(), ~\"onetwothree\");\n+        assert_eq!(doc.cratemod().name_(), ~\"onetwothree\");\n     }\n }"}, {"sha": "1b7b6d578b9a5ff5a00be6782714f9d6e13d55bd", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -68,7 +68,7 @@ fn fold_item(fold: &fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n fn fold_mod(fold: &fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n     let is_topmod = doc.id() == ast::crate_node_id;\n \n-    if !is_topmod { fold.ctxt.path.push(doc.name()); }\n+    if !is_topmod { fold.ctxt.path.push(doc.name_()); }\n     let doc = fold::default_any_fold_mod(fold, doc);\n     if !is_topmod { fold.ctxt.path.pop(); }\n \n@@ -79,7 +79,7 @@ fn fold_mod(fold: &fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n }\n \n fn fold_nmod(fold: &fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n-    fold.ctxt.path.push(doc.name());\n+    fold.ctxt.path.push(doc.name_());\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     fold.ctxt.path.pop();\n "}, {"sha": "8c7267e0b21c200f0f9d5ce30274a89f0ab01415", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -17,7 +17,7 @@ use sort_pass;\n \n pub fn mk_pass() -> Pass {\n     fn by_item_name(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        (*item1).name() <= (*item2).name()\n+        (*item1).name_() <= (*item2).name_()\n     }\n     sort_pass::mk_pass(~\"sort_item_name\", by_item_name)\n }\n@@ -32,7 +32,7 @@ fn test() {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[1].name(), ~\"y\");\n-        assert_eq!(doc.cratemod().items[2].name(), ~\"z\");\n+        assert_eq!(doc.cratemod().items[1].name_(), ~\"y\");\n+        assert_eq!(doc.cratemod().items[2].name_(), ~\"z\");\n     }\n }"}, {"sha": "366cc83df2728846f30a8b30c289ac7170e59e49", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -54,14 +54,14 @@ fn test() {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[0].name(), ~\"iconst\");\n-        assert_eq!(doc.cratemod().items[1].name(), ~\"itype\");\n-        assert_eq!(doc.cratemod().items[2].name(), ~\"ienum\");\n-        assert_eq!(doc.cratemod().items[3].name(), ~\"istruct\");\n-        assert_eq!(doc.cratemod().items[4].name(), ~\"itrait\");\n-        assert_eq!(doc.cratemod().items[5].name(), ~\"__extensions__\");\n-        assert_eq!(doc.cratemod().items[6].name(), ~\"ifn\");\n+        assert_eq!(doc.cratemod().items[0].name_(), ~\"iconst\");\n+        assert_eq!(doc.cratemod().items[1].name_(), ~\"itype\");\n+        assert_eq!(doc.cratemod().items[2].name_(), ~\"ienum\");\n+        assert_eq!(doc.cratemod().items[3].name_(), ~\"istruct\");\n+        assert_eq!(doc.cratemod().items[4].name_(), ~\"itrait\");\n+        assert_eq!(doc.cratemod().items[5].name_(), ~\"__extensions__\");\n+        assert_eq!(doc.cratemod().items[6].name_(), ~\"ifn\");\n         // hidden __std_macros module fits here.\n-        assert_eq!(doc.cratemod().items[8].name(), ~\"imod\");\n+        assert_eq!(doc.cratemod().items[8].name_(), ~\"imod\");\n     }\n }"}, {"sha": "a6aa9480f3827145bdb487c2fdd47c5cad8b07fa", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -68,18 +68,18 @@ fn fold_mod(\n #[test]\n fn test() {\n     fn name_lteq(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        (*item1).name() <= (*item2).name()\n+        (*item1).name_() <= (*item2).name_()\n     }\n \n     let source = ~\"mod z { mod y { } fn x() { } } mod w { }\";\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].name(), ~\"w\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name(), ~\"x\");\n-        assert_eq!(doc.cratemod().mods()[2].items[1].name(), ~\"y\");\n-        assert_eq!(doc.cratemod().mods()[2].name(), ~\"z\");\n+        assert_eq!(doc.cratemod().mods()[1].name_(), ~\"w\");\n+        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"x\");\n+        assert_eq!(doc.cratemod().mods()[2].items[1].name_(), ~\"y\");\n+        assert_eq!(doc.cratemod().mods()[2].name_(), ~\"z\");\n     }\n }\n \n@@ -94,10 +94,10 @@ fn should_be_stable() {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].items[0].name(), ~\"b\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name(), ~\"d\");\n+        assert_eq!(doc.cratemod().mods()[1].items[0].name_(), ~\"b\");\n+        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"d\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert_eq!(doc.cratemod().mods()[1].items[0].name(), ~\"b\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name(), ~\"d\");\n+        assert_eq!(doc.cratemod().mods()[1].items[0].name_(), ~\"b\");\n+        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"d\");\n     }\n }"}, {"sha": "13f3ce840714beffa975f4b00d806508273e9499", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -14,11 +14,9 @@ use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned};\n-use syntax::codemap::dummy_spanned;\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n-use syntax::ast::{meta_name_value, meta_list};\n-use syntax::attr::{mk_attr};\n+use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n use rustc::driver::driver::compile_upto;\n use rustc::driver::session::{lib_crate, bin_crate};\n@@ -81,7 +79,7 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.iter().filter_map |attr| {\n-                if \"main\" != attr::get_attr_name(attr) {\n+                if \"main\" != attr.name() {\n                     Some(*attr)\n                 } else {\n                     None\n@@ -104,25 +102,27 @@ fn fold_item(ctx: @mut ReadyCtx,\n              fold: @fold::ast_fold) -> Option<@ast::item> {\n     ctx.path.push(item.ident);\n \n-    let attrs = attr::find_attrs_by_name(item.attrs, \"pkg_do\");\n+    let mut cmds = ~[];\n+    let mut had_pkg_do = false;\n \n-    if attrs.len() > 0 {\n-        let mut cmds = ~[];\n-\n-        for attrs.iter().advance |attr| {\n+    for item.attrs.iter().advance |attr| {\n+        if \"pkg_do\" == attr.name() {\n+            had_pkg_do = true;\n             match attr.node.value.node {\n-                ast::meta_list(_, ref mis) => {\n+                ast::MetaList(_, ref mis) => {\n                     for mis.iter().advance |mi| {\n                         match mi.node {\n-                            ast::meta_word(cmd) => cmds.push(cmd.to_owned()),\n+                            ast::MetaWord(cmd) => cmds.push(cmd.to_owned()),\n                             _ => {}\n                         };\n                     }\n                 }\n                 _ => cmds.push(~\"build\")\n-            };\n+            }\n         }\n+    }\n \n+    if had_pkg_do {\n         ctx.fns.push(ListenerFn {\n             cmds: cmds,\n             span: item.span,\n@@ -245,14 +245,13 @@ pub fn compile_input(ctxt: &Ctx,\n             _     => pkg_id.short_name.clone()\n         };\n         debug!(\"Injecting link name: %s\", short_name_to_use);\n+        let link_options =\n+            ~[attr::mk_name_value_item_str(@\"name\", short_name_to_use.to_managed()),\n+              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())];\n+\n         crate = @codemap::respan(crate.span, ast::crate_ {\n-            attrs: ~[mk_attr(@dummy_spanned(\n-                meta_list(@\"link\",\n-                 ~[@dummy_spanned(meta_name_value(@\"name\",\n-                                      mk_string_lit(short_name_to_use.to_managed()))),\n-                   @dummy_spanned(meta_name_value(@\"vers\",\n-                         mk_string_lit(pkg_id.version.to_str().to_managed())))])))],\n-            ..crate.node.clone()});\n+            attrs: ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))],\n+            .. crate.node.clone()});\n     }\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,"}, {"sha": "f2974423a1a62fced17cab6c90ddcb3009e84d6c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -193,26 +193,51 @@ pub enum def {\n }\n \n \n-// The set of meta_items that define the compilation environment of the crate,\n+// The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n-pub type crate_cfg = ~[@meta_item];\n+pub type crate_cfg = ~[@MetaItem];\n \n pub type crate = spanned<crate_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct crate_ {\n     module: _mod,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     config: crate_cfg,\n }\n \n-pub type meta_item = spanned<meta_item_>;\n+pub type MetaItem = spanned<MetaItem_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum meta_item_ {\n-    meta_word(@str),\n-    meta_list(@str, ~[@meta_item]),\n-    meta_name_value(@str, lit),\n+#[deriving(Clone, Encodable, Decodable, IterBytes)]\n+pub enum MetaItem_ {\n+    MetaWord(@str),\n+    MetaList(@str, ~[@MetaItem]),\n+    MetaNameValue(@str, lit),\n+}\n+\n+// can't be derived because the MetaList requires an unordered comparison\n+impl Eq for MetaItem_ {\n+    fn eq(&self, other: &MetaItem_) -> bool {\n+        match *self {\n+            MetaWord(ref ns) => match *other {\n+                MetaWord(ref no) => (*ns) == (*no),\n+                _ => false\n+            },\n+            MetaNameValue(ref ns, ref vs) => match *other {\n+                MetaNameValue(ref no, ref vo) => {\n+                    (*ns) == (*no) && vs.node == vo.node\n+                }\n+                _ => false\n+            },\n+            MetaList(ref ns, ref miss) => match *other {\n+                MetaList(ref no, ref miso) => {\n+                    ns == no &&\n+                        miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n+                }\n+                _ => false\n+            }\n+        }\n+    }\n }\n \n //pub type blk = spanned<blk_>;\n@@ -622,7 +647,7 @@ pub type ty_field = spanned<ty_field_>;\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct ty_method {\n     ident: ident,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     purity: purity,\n     decl: fn_decl,\n     generics: Generics,\n@@ -833,7 +858,7 @@ pub type explicit_self = spanned<explicit_self_>;\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct method {\n     ident: ident,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     generics: Generics,\n     explicit_self: explicit_self,\n     purity: purity,\n@@ -886,7 +911,7 @@ pub struct enum_def {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_ {\n     name: ident,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     kind: variant_kind,\n     id: node_id,\n     disr_expr: Option<@expr>,\n@@ -925,34 +950,34 @@ pub enum view_path_ {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct view_item {\n     node: view_item_,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     vis: visibility,\n     span: span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum view_item_ {\n-    view_item_extern_mod(ident, ~[@meta_item], node_id),\n+    view_item_extern_mod(ident, ~[@MetaItem], node_id),\n     view_item_use(~[@view_path]),\n }\n \n // Meta-data associated with an item\n-pub type attribute = spanned<attribute_>;\n+pub type Attribute = spanned<Attribute_>;\n \n-// Distinguishes between attributes that decorate items and attributes that\n+// Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub enum attr_style {\n-    attr_outer,\n-    attr_inner,\n+pub enum AttrStyle {\n+    AttrOuter,\n+    AttrInner,\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub struct attribute_ {\n-    style: attr_style,\n-    value: @meta_item,\n+pub struct Attribute_ {\n+    style: AttrStyle,\n+    value: @MetaItem,\n     is_sugared_doc: bool,\n }\n \n@@ -990,7 +1015,7 @@ pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n     ty: Ty,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n }\n \n pub type struct_field = spanned<struct_field_>;\n@@ -1016,7 +1041,7 @@ pub struct struct_def {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct item {\n     ident: ident,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     id: node_id,\n     node: item_,\n     vis: visibility,\n@@ -1044,7 +1069,7 @@ pub enum item_ {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_item {\n     ident: ident,\n-    attrs: ~[attribute],\n+    attrs: ~[Attribute],\n     node: foreign_item_,\n     id: node_id,\n     span: span,"}, {"sha": "3c560d211fd2733150379ba6d4c96b059eb0dffb", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 218, "deletions": 228, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,326 +8,316 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Functions dealing with attributes and meta_items\n+// Functions dealing with attributes and meta items\n \n use extra;\n \n use ast;\n+use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n use codemap::{spanned, dummy_spanned};\n-use attr;\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n use std::hashmap::HashSet;\n-/* Constructors */\n-\n-pub fn mk_name_value_item_str(name: @str, value: @str)\n-                           -> @ast::meta_item {\n-    let value_lit = dummy_spanned(ast::lit_str(value));\n-    mk_name_value_item(name, value_lit)\n-}\n-\n-pub fn mk_name_value_item(name: @str, value: ast::lit)\n-        -> @ast::meta_item {\n-    @dummy_spanned(ast::meta_name_value(name, value))\n-}\n-\n-pub fn mk_list_item(name: @str, items: ~[@ast::meta_item]) ->\n-   @ast::meta_item {\n-    @dummy_spanned(ast::meta_list(name, items))\n-}\n \n-pub fn mk_word_item(name: @str) -> @ast::meta_item {\n-    @dummy_spanned(ast::meta_word(name))\n+pub trait AttrMetaMethods {\n+    // This could be changed to `fn check_name(&self, name: @str) ->\n+    // bool` which would facilitate a side table recording which\n+    // attributes/meta items are used/unused.\n+\n+    /// Retrieve the name of the meta item, e.g. foo in #[foo],\n+    /// #[foo=\"bar\"] and #[foo(bar)]\n+    fn name(&self) -> @str;\n+\n+    /**\n+     * Gets the string value if self is a MetaNameValue variant\n+     * containing a string, otherwise None.\n+     */\n+    fn value_str(&self) -> Option<@str>;\n+    /// Gets a list of inner meta items from a list MetaItem type.\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]>;\n+\n+    /**\n+     * If the meta item is a name-value type with a string value then returns\n+     * a tuple containing the name and string value, otherwise `None`\n+     */\n+    fn name_str_pair(&self) -> Option<(@str, @str)>;\n }\n \n-pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n-    dummy_spanned(ast::attribute_ { style: ast::attr_inner,\n-                                    value: item,\n-                                    is_sugared_doc: false })\n+impl AttrMetaMethods for Attribute {\n+    fn name(&self) -> @str { self.meta().name() }\n+    fn value_str(&self) -> Option<@str> { self.meta().value_str() }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+        self.node.value.meta_item_list()\n+    }\n+    fn name_str_pair(&self) -> Option<(@str, @str)> { self.meta().name_str_pair() }\n }\n \n-pub fn mk_sugared_doc_attr(text: @str,\n-                           lo: BytePos, hi: BytePos) -> ast::attribute {\n-    let style = doc_comment_style(text);\n-    let lit = spanned(lo, hi, ast::lit_str(text));\n-    let attr = ast::attribute_ {\n-        style: style,\n-        value: @spanned(lo, hi, ast::meta_name_value(@\"doc\", lit)),\n-        is_sugared_doc: true\n-    };\n-    spanned(lo, hi, attr)\n-}\n+impl AttrMetaMethods for MetaItem {\n+    fn name(&self) -> @str {\n+        match self.node {\n+            MetaWord(n) => n,\n+            MetaNameValue(n, _) => n,\n+            MetaList(n, _) => n\n+        }\n+    }\n \n-/* Conversion */\n+    fn value_str(&self) -> Option<@str> {\n+        match self.node {\n+            MetaNameValue(_, ref v) => {\n+                match v.node {\n+                    ast::lit_str(s) => Some(s),\n+                    _ => None,\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n \n-pub fn attr_meta(attr: ast::attribute) -> @ast::meta_item {\n-    attr.node.value\n-}\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+        match self.node {\n+            MetaList(_, ref l) => Some(l.as_slice()),\n+            _ => None\n+        }\n+    }\n \n-// Get the meta_items from inside a vector of attributes\n-pub fn attr_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n-    do attrs.map |a| { attr_meta(*a) }\n+    pub fn name_str_pair(&self) -> Option<(@str, @str)> {\n+        self.value_str().map_consume(|s| (self.name(), s))\n+    }\n }\n \n-pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n-    if attr.node.is_sugared_doc {\n-        let comment = get_meta_item_value_str(attr.node.value).get();\n-        let meta = mk_name_value_item_str(@\"doc\",\n-                                     strip_doc_comment_decoration(comment).to_managed());\n-        mk_attr(meta)\n-    } else {\n-        *attr\n+// Annoying, but required to get test_cfg to work\n+impl AttrMetaMethods for @MetaItem {\n+    fn name(&self) -> @str { (**self).name() }\n+    fn value_str(&self) -> Option<@str> { (**self).value_str() }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+        (**self).meta_item_list()\n     }\n+    fn name_str_pair(&self) -> Option<(@str, @str)> { (**self).name_str_pair() }\n }\n \n-/* Accessors */\n \n-pub fn get_attr_name(attr: &ast::attribute) -> @str {\n-    get_meta_item_name(attr.node.value)\n+pub trait AttributeMethods {\n+    fn meta(&self) -> @MetaItem;\n+    fn desugar_doc(&self) -> Attribute;\n }\n \n-pub fn get_meta_item_name(meta: @ast::meta_item) -> @str {\n-    match meta.node {\n-        ast::meta_word(n) => n,\n-        ast::meta_name_value(n, _) => n,\n-        ast::meta_list(n, _) => n,\n+impl AttributeMethods for Attribute {\n+    /// Extract the MetaItem from inside this Attribute.\n+    pub fn meta(&self) -> @MetaItem {\n+        self.node.value\n     }\n-}\n \n-/**\n- * Gets the string value if the meta_item is a meta_name_value variant\n- * containing a string, otherwise none\n- */\n-pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@str> {\n-    match meta.node {\n-        ast::meta_name_value(_, v) => {\n-            match v.node {\n-                ast::lit_str(s) => Some(s),\n-                _ => None,\n-            }\n-        },\n-        _ => None\n+    /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n+    /// comment like `///` or `/** */`. (Returns self unchanged for\n+    /// non-sugared doc attributes.)\n+    pub fn desugar_doc(&self) -> Attribute {\n+        if self.node.is_sugared_doc {\n+            let comment = self.value_str().get();\n+            let meta = mk_name_value_item_str(@\"doc\",\n+                                              strip_doc_comment_decoration(comment).to_managed());\n+            mk_attr(meta)\n+        } else {\n+            *self\n+        }\n     }\n }\n \n-/// Gets a list of inner meta items from a list meta_item type\n-pub fn get_meta_item_list(meta: @ast::meta_item)\n-                       -> Option<~[@ast::meta_item]> {\n-    match meta.node {\n-        ast::meta_list(_, ref l) => Some(/* FIXME (#2543) */ (*l).clone()),\n-        _ => None\n-    }\n-}\n+/* Constructors */\n \n-/**\n- * If the meta item is a nam-value type with a string value then returns\n- * a tuple containing the name and string value, otherwise `none`\n- */\n-pub fn get_name_value_str_pair(item: @ast::meta_item)\n-                            -> Option<(@str, @str)> {\n-    match attr::get_meta_item_value_str(item) {\n-      Some(value) => {\n-        let name = attr::get_meta_item_name(item);\n-        Some((name, value))\n-      }\n-      None => None\n-    }\n+pub fn mk_name_value_item_str(name: @str, value: @str) -> @MetaItem {\n+    let value_lit = dummy_spanned(ast::lit_str(value));\n+    mk_name_value_item(name, value_lit)\n }\n \n-\n-/* Searching */\n-\n-/// Search a list of attributes and return only those with a specific name\n-pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n-   ~[ast::attribute] {\n-    do attrs.iter().filter_map |a| {\n-        if name == get_attr_name(a) {\n-            Some(*a)\n-        } else {\n-            None\n-        }\n-    }.collect()\n+pub fn mk_name_value_item(name: @str, value: ast::lit) -> @MetaItem {\n+    @dummy_spanned(MetaNameValue(name, value))\n }\n \n-/// Search a list of meta items and return only those with a specific name\n-pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n-   ~[@ast::meta_item] {\n-    let mut rs = ~[];\n-    for metas.iter().advance |mi| {\n-        if name == get_meta_item_name(*mi) {\n-            rs.push(*mi)\n-        }\n-    }\n-    rs\n+pub fn mk_list_item(name: @str, items: ~[@MetaItem]) -> @MetaItem {\n+    @dummy_spanned(MetaList(name, items))\n }\n \n-/**\n- * Returns true if a list of meta items contains another meta item. The\n- * comparison is performed structurally.\n- */\n-pub fn contains(haystack: &[@ast::meta_item],\n-                needle: @ast::meta_item) -> bool {\n-    for haystack.iter().advance |item| {\n-        if eq(*item, needle) { return true; }\n-    }\n-    return false;\n+pub fn mk_word_item(name: @str) -> @MetaItem {\n+    @dummy_spanned(MetaWord(name))\n }\n \n-fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n-    match a.node {\n-        ast::meta_word(ref na) => match b.node {\n-            ast::meta_word(ref nb) => (*na) == (*nb),\n-            _ => false\n-        },\n-        ast::meta_name_value(ref na, va) => match b.node {\n-            ast::meta_name_value(ref nb, vb) => {\n-                (*na) == (*nb) && va.node == vb.node\n-            }\n-            _ => false\n-        },\n-        ast::meta_list(ref na, ref misa) => match b.node {\n-            ast::meta_list(ref nb, ref misb) => {\n-                if na != nb { return false; }\n-                for misa.iter().advance |mi| {\n-                    if !misb.iter().any(|x| x == mi) { return false; }\n-                }\n-                true\n-            }\n-            _ => false\n-        }\n-    }\n+pub fn mk_attr(item: @MetaItem) -> Attribute {\n+    dummy_spanned(Attribute_ {\n+        style: ast::AttrInner,\n+        value: item,\n+        is_sugared_doc: false,\n+    })\n }\n \n-pub fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n-    let matches = find_meta_items_by_name(metas, name);\n-    matches.len() > 0u\n+pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n+    let style = doc_comment_style(text);\n+    let lit = spanned(lo, hi, ast::lit_str(text));\n+    let attr = Attribute_ {\n+        style: style,\n+        value: @spanned(lo, hi, MetaNameValue(@\"doc\", lit)),\n+        is_sugared_doc: true\n+    };\n+    spanned(lo, hi, attr)\n }\n \n-pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n-    !find_attrs_by_name(attrs, name).is_empty()\n+/* Searching */\n+/// Check if `needle` occurs in `haystack` by a structural\n+/// comparison. This is slightly subtle, and relies on ignoring the\n+/// span included in the `==` comparison a plain MetaItem.\n+pub fn contains(haystack: &[@ast::MetaItem],\n+                needle: @ast::MetaItem) -> bool {\n+    debug!(\"attr::contains (name=%s)\", needle.name());\n+    do haystack.iter().any |item| {\n+        debug!(\"  testing: %s\", item.name());\n+        item.node == needle.node\n+    }\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[ast::attribute], name: &str)\n-                                 -> Option<@str> {\n-\n-    let mattrs = find_attrs_by_name(attrs, name);\n-    if mattrs.len() > 0 {\n-        get_meta_item_value_str(attr_meta(mattrs[0]))\n-    } else {\n-        None\n+pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n+    debug!(\"attr::contains_name (name=%s)\", name);\n+    do metas.iter().any |item| {\n+        debug!(\"  testing: %s\", item.name());\n+        name == item.name()\n     }\n }\n \n-fn last_meta_item_by_name(items: &[@ast::meta_item], name: &str)\n-    -> Option<@ast::meta_item> {\n-\n-    let items = attr::find_meta_items_by_name(items, name);\n-    items.last_opt().map(|item| **item)\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n+                                 -> Option<@str> {\n+    attrs.iter()\n+        .find_(|at| name == at.name())\n+        .chain(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[@ast::meta_item], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<@str> {\n-\n-    match last_meta_item_by_name(items, name) {\n-        Some(item) => {\n-            match attr::get_meta_item_value_str(item) {\n-                Some(value) => Some(value),\n-                None => None\n-            }\n-        },\n-        None => None\n-    }\n+    items.rev_iter().find_(|mi| name == mi.name()).chain(|i| i.value_str())\n }\n \n-pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n-    -> Option<~[@ast::meta_item]> {\n-\n-    match last_meta_item_by_name(items, name) {\n-      Some(item) => attr::get_meta_item_list(item),\n-      None => None\n-    }\n-}\n-\n-\n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v = items.to_owned();\n-    do extra::sort::quick_sort(v) |ma, mb| {\n-        get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n+pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n+    // This is sort of stupid here, but we need to sort by\n+    // human-readable strings.\n+    let mut v = items.iter()\n+        .transform(|&mi| (mi.name(), mi))\n+        .collect::<~[(@str, @MetaItem)]>();\n+\n+    do extra::sort::quick_sort(v) |&(a, _), &(b, _)| {\n+        a <= b\n     }\n \n     // There doesn't seem to be a more optimal way to do this\n-    do v.map |m| {\n+    do v.consume_iter().transform |(_, m)| {\n         match m.node {\n-            ast::meta_list(n, ref mis) => {\n+            MetaList(n, ref mis) => {\n                 @spanned {\n-                    node: ast::meta_list(n, sort_meta_items(*mis)),\n-                    .. /*bad*/ (**m).clone()\n+                    node: MetaList(n, sort_meta_items(*mis)),\n+                    .. /*bad*/ (*m).clone()\n                 }\n             }\n-            _ => *m\n+            _ => m\n         }\n-    }\n-}\n-\n-pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n-   ~[@ast::meta_item] {\n-    items.consume_iter().filter(|item| name != get_meta_item_name(*item)).collect()\n+    }.collect()\n }\n \n /**\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n-    do find_attrs_by_name(attrs, \"link\").flat_map |attr| {\n-        match attr.node.value.node {\n-            ast::meta_list(_, ref items) => {\n-                /* FIXME (#2543) */ (*items).clone()\n-            }\n-            _ => ~[]\n+pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n+    let mut result = ~[];\n+    for attrs.iter().filter(|at| \"link\" == at.name()).advance |attr| {\n+        match attr.meta().node {\n+            MetaList(_, ref items) => result.push_all(*items),\n+            _ => ()\n         }\n     }\n+    result\n }\n \n #[deriving(Eq)]\n-pub enum inline_attr {\n-    ia_none,\n-    ia_hint,\n-    ia_always,\n-    ia_never,\n+pub enum InlineAttr {\n+    InlineNone,\n+    InlineHint,\n+    InlineAlways,\n+    InlineNever,\n }\n \n /// True if something like #[inline] is found in the list of attrs.\n-pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n+pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n-    do attrs.iter().fold(ia_none) |ia,attr| {\n+    do attrs.iter().fold(InlineNone) |ia,attr| {\n         match attr.node.value.node {\n-          ast::meta_word(s) if \"inline\" == s => ia_hint,\n-          ast::meta_list(s, ref items) if \"inline\" == s => {\n-            if !find_meta_items_by_name(*items, \"always\").is_empty() {\n-                ia_always\n-            } else if !find_meta_items_by_name(*items, \"never\").is_empty() {\n-                ia_never\n+          MetaWord(n) if \"inline\" == n => InlineHint,\n+          MetaList(n, ref items) if \"inline\" == n => {\n+            if contains_name(*items, \"always\") {\n+                InlineAlways\n+            } else if contains_name(*items, \"never\") {\n+                InlineNever\n             } else {\n-                ia_hint\n+                InlineHint\n             }\n           }\n           _ => ia\n         }\n     }\n }\n \n+/// Tests if any `cfg(...)` meta items in `metas` match `cfg`. e.g.\n+///\n+/// test_cfg(`[foo=\"a\", bar]`, `[cfg(foo), cfg(bar)]`) == true\n+/// test_cfg(`[foo=\"a\", bar]`, `[cfg(not(bar))]`) == false\n+/// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"a\")]`) == true\n+/// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"b\")]`) == false\n+pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n+    (cfg: &[@MetaItem], mut metas: It) -> bool {\n+    // having no #[cfg(...)] attributes counts as matching.\n+    let mut no_cfgs = true;\n+\n+    // this would be much nicer as a chain of iterator adaptors, but\n+    // this doesn't work.\n+    let some_cfg_matches = do metas.any |mi| {\n+        debug!(\"testing name: %s\", mi.name());\n+        if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n+            debug!(\"is cfg\");\n+            no_cfgs = false;\n+             // only #[cfg(...)] ones are understood.\n+            match mi.meta_item_list() {\n+                Some(cfg_meta) => {\n+                    debug!(\"is cfg(...)\");\n+                    do cfg_meta.iter().all |cfg_mi| {\n+                        debug!(\"cfg(%s[...])\", cfg_mi.name());\n+                        match cfg_mi.node {\n+                            ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n+                                debug!(\"not!\");\n+                                // inside #[cfg(not(...))], so these need to all\n+                                // not match.\n+                                not_cfgs.iter().all(|mi| {\n+                                    debug!(\"cfg(not(%s[...]))\", mi.name());\n+                                    !contains(cfg, *mi)\n+                                })\n+                            }\n+                            _ => contains(cfg, *cfg_mi)\n+                        }\n+                    }\n+                }\n+                None => false\n+            }\n+        } else {\n+            false\n+        }\n+    };\n+    debug!(\"test_cfg (no_cfgs=%?, some_cfg_matches=%?)\", no_cfgs, some_cfg_matches);\n+    no_cfgs || some_cfg_matches\n+}\n \n pub fn require_unique_names(diagnostic: @span_handler,\n-                            metas: &[@ast::meta_item]) {\n+                            metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for metas.iter().advance |meta| {\n-        let name = get_meta_item_name(*meta);\n+        let name = meta.name();\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if !set.insert(name) {"}, {"sha": "4ada7f7479b757875d5c0e1cc8060d1f30eb6305", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -17,7 +17,7 @@ use ext::base::*;\n pub fn expand_auto_encode(\n     cx: @ExtCtxt,\n     span: span,\n-    _mitem: @ast::meta_item,\n+    _mitem: @ast::MetaItem,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     cx.span_err(span, \"`#[auto_encode]` is deprecated, use `#[deriving(Encodable)]` instead\");\n@@ -27,7 +27,7 @@ pub fn expand_auto_encode(\n pub fn expand_auto_decode(\n     cx: @ExtCtxt,\n     span: span,\n-    _mitem: @ast::meta_item,\n+    _mitem: @ast::MetaItem,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     cx.span_err(span, \"`#[auto_decode]` is deprecated, use `#[deriving(Decodable)]` instead\");"}, {"sha": "c71ea78bba5c56a683d7a6d9d7c5d2be94f2b0d2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -36,7 +36,7 @@ pub struct MacroDef {\n \n pub type ItemDecorator = @fn(@ExtCtxt,\n                              span,\n-                             @ast::meta_item,\n+                             @ast::MetaItem,\n                              ~[@ast::item])\n                           -> ~[@ast::item];\n "}, {"sha": "df5f3d8d89545b5a67886959122cf4fec1ba6170", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -163,7 +163,7 @@ pub trait AstBuilder {\n \n     // items\n     fn item(&self, span: span,\n-            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n+            name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n \n     fn arg(&self, span: span, name: ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n@@ -199,7 +199,7 @@ pub trait AstBuilder {\n     fn item_struct(&self, span: span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n \n     fn item_mod(&self, span: span,\n-                name: ident, attrs: ~[ast::attribute],\n+                name: ident, attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n@@ -209,11 +209,11 @@ pub trait AstBuilder {\n                     generics: Generics) -> @ast::item;\n     fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item;\n \n-    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n+    fn attribute(&self, sp: span, mi: @ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: span, w: @str) -> @ast::meta_item;\n-    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::meta_item]) -> @ast::meta_item;\n-    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item;\n+    fn meta_word(&self, sp: span, w: @str) -> @ast::MetaItem;\n+    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n+    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::MetaItem;\n \n     fn view_use(&self, sp: span,\n                 vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n@@ -657,7 +657,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item(&self, span: span,\n-            name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item {\n+            name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item {\n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         @ast::item { ident: name,\n@@ -754,7 +754,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item_mod(&self, span: span, name: ident,\n-                attrs: ~[ast::attribute],\n+                attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n         self.item(\n@@ -777,23 +777,22 @@ impl AstBuilder for @ExtCtxt {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute {\n-        respan(sp,\n-               ast::attribute_ {\n-                   style: ast::attr_outer,\n-                   value: mi,\n-                   is_sugared_doc: false\n-               })\n+    fn attribute(&self, sp: span, mi: @ast::MetaItem) -> ast::Attribute {\n+        respan(sp, ast::Attribute_ {\n+            style: ast::AttrOuter,\n+            value: mi,\n+            is_sugared_doc: false,\n+        })\n     }\n \n-    fn meta_word(&self, sp: span, w: @str) -> @ast::meta_item {\n-        @respan(sp, ast::meta_word(w))\n+    fn meta_word(&self, sp: span, w: @str) -> @ast::MetaItem {\n+        @respan(sp, ast::MetaWord(w))\n     }\n-    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::meta_item]) -> @ast::meta_item {\n-        @respan(sp, ast::meta_list(name, mis))\n+    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n+        @respan(sp, ast::MetaList(name, mis))\n     }\n-    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item {\n-        @respan(sp, ast::meta_name_value(name, respan(sp, value)))\n+    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::MetaItem {\n+        @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n \n     fn view_use(&self, sp: span,"}, {"sha": "02dcb2cdbc9eb5c58c3cec97466e1a115d0e4818", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_clone(cx: @ExtCtxt,\n                              span: span,\n-                             mitem: @meta_item,\n+                             mitem: @MetaItem,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n     let trait_def = TraitDef {\n@@ -40,9 +40,9 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n }\n \n pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n-                                 span: span,\n-                                 mitem: @meta_item,\n-                                 in_items: ~[@item])\n+                                  span: span,\n+                                  mitem: @MetaItem,\n+                                  in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n         path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),"}, {"sha": "a7d9db59130f349f88879051c4fa24fa26517291", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_eq(cx: @ExtCtxt,\n                           span: span,\n-                          mitem: @meta_item,\n+                          mitem: @MetaItem,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different"}, {"sha": "d532eedd2918e2e45c380098af0aa7abebe1eafa", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_ord(cx: @ExtCtxt,\n                            span: span,\n-                           mitem: @meta_item,\n+                           mitem: @MetaItem,\n                            in_items: ~[@item]) -> ~[@item] {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => {"}, {"sha": "8285de1d561981555c44a67f3b76552f474ffb65", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n-                          span: span,\n-                          mitem: @meta_item,\n-                          in_items: ~[@item]) -> ~[@item] {\n-\n+                               span: span,\n+                               mitem: @MetaItem,\n+                               in_items: ~[@item]) -> ~[@item] {\n     fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)"}, {"sha": "01dacdfe453ee7cec2a5b186698b48468ba9442a", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,7 +17,7 @@ use std::cmp::{Ordering, Equal, Less, Greater};\n \n pub fn expand_deriving_totalord(cx: @ExtCtxt,\n                                 span: span,\n-                                mitem: @meta_item,\n+                                mitem: @MetaItem,\n                                 in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n         path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),"}, {"sha": "bde0a345b1022688a232fbd15fa204cd1e7697ee", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -16,15 +16,15 @@ encodable.rs for more.\n use std::vec;\n use std::uint;\n \n-use ast::{meta_item, item, expr, m_mutbl};\n+use ast::{MetaItem, item, expr, m_mutbl};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_decodable(cx: @ExtCtxt,\n                                  span: span,\n-                                 mitem: @meta_item,\n+                                 mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n         path: Path::new_(~[\"extra\", \"serialize\", \"Decodable\"], None,"}, {"sha": "1f969b4e0781fede90ebdbb715fa48815af7378d", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -75,15 +75,15 @@ would yield functions like:\n     }\n */\n \n-use ast::{meta_item, item, expr, m_imm, m_mutbl};\n+use ast::{MetaItem, item, expr, m_imm, m_mutbl};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_encodable(cx: @ExtCtxt,\n                                  span: span,\n-                                 mitem: @meta_item,\n+                                 mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n         path: Path::new_(~[\"extra\", \"serialize\", \"Encodable\"], None,"}, {"sha": "04bbe5ae1d6a968e0e9003239d5ce59ec73cc61f", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -281,7 +281,7 @@ pub type EnumNonMatchFunc<'self> =\n impl<'self> TraitDef<'self> {\n     pub fn expand(&self, cx: @ExtCtxt,\n                   span: span,\n-                  _mitem: @ast::meta_item,\n+                  _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n         for in_items.iter().advance |item| {\n@@ -361,7 +361,8 @@ impl<'self> TraitDef<'self> {\n         let doc_attr = cx.attribute(\n             span,\n             cx.meta_name_value(span,\n-                               @\"doc\", ast::lit_str(@\"Automatically derived.\")));\n+                               @\"doc\",\n+                               ast::lit_str(@\"Automatically derived.\")));\n         cx.item(\n             span,\n             ::parse::token::special_idents::clownshoes_extensions,"}, {"sha": "57a4f0899b528ff63e2c2b7021579e78ceb8e5a4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr, and};\n+use ast::{MetaItem, item, expr, and};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,7 +17,7 @@ use ext::deriving::generic::*;\n \n pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   span: span,\n-                                  mitem: @meta_item,\n+                                  mitem: @MetaItem,\n                                   in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n         path: Path::new(~[\"std\", \"to_bytes\", \"IterBytes\"]),"}, {"sha": "cde7dcc5dbe2acc3cf35c61776d85b46c8361ae6", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -18,7 +18,8 @@ library.\n \n */\n \n-use ast::{enum_def, ident, item, Generics, meta_item, struct_def};\n+use ast::{enum_def, ident, item, Generics, struct_def};\n+use ast::{MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::span;\n@@ -58,26 +59,24 @@ pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ExtCtxt,\n \n pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             _span: span,\n-                            mitem: @meta_item,\n+                            mitem: @MetaItem,\n                             in_items: ~[@item])\n                          -> ~[@item] {\n-    use ast::{meta_list, meta_name_value, meta_word};\n-\n     match mitem.node {\n-        meta_name_value(_, ref l) => {\n+        MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");\n             in_items\n         }\n-        meta_word(_) | meta_list(_, []) => {\n+        MetaWord(_) | MetaList(_, []) => {\n             cx.span_warn(mitem.span, \"empty trait list in `deriving`\");\n             in_items\n         }\n-        meta_list(_, ref titems) => {\n+        MetaList(_, ref titems) => {\n             do titems.rev_iter().fold(in_items) |in_items, &titem| {\n                 match titem.node {\n-                    meta_name_value(tname, _) |\n-                    meta_list(tname, _) |\n-                    meta_word(tname) => {\n+                    MetaNameValue(tname, _) |\n+                    MetaList(tname, _) |\n+                    MetaWord(tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n                                                                    titem, in_items)));\n                         match tname.as_slice() {"}, {"sha": "2966a8c114dafa426c37342af6af99bd27dc2127", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{meta_item, item, expr, ident};\n+use ast::{MetaItem, item, expr, ident};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder, Duplicate};\n@@ -19,7 +19,7 @@ use std::vec;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: span,\n-                            mitem: @meta_item,\n+                            mitem: @MetaItem,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {"}, {"sha": "9b544eb0796a26895c8e2095a20ea52e8c88b578", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_to_str(cx: @ExtCtxt,\n                               span: span,\n-                              mitem: @meta_item,\n+                              mitem: @MetaItem,\n                               in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {"}, {"sha": "3c9e842473c1c8b7c2041ed16b0543704a26ec52", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -18,7 +18,7 @@ use std::vec;\n \n pub fn expand_deriving_zero(cx: @ExtCtxt,\n                             span: span,\n-                            mitem: @meta_item,\n+                            mitem: @MetaItem,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {"}, {"sha": "e78254f11f5b8302ef938338381f69f6689d61fa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -14,6 +14,7 @@ use ast::{illegal_ctxt};\n use ast;\n use ast_util::{new_rename, new_mark, resolve};\n use attr;\n+use attr::AttrMetaMethods;\n use codemap;\n use codemap::{span, ExpnInfo, NameAndSpan};\n use ext::base::*;\n@@ -126,7 +127,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n         do item.attrs.rev_iter().fold(~[*item]) |items, attr| {\n-            let mname = attr::get_attr_name(attr);\n+            let mname = attr.name();\n \n             match (*extsbox).find(&intern(mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n@@ -196,8 +197,8 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n }\n \n // does this attribute list contain \"macro_escape\" ?\n-pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n-    attrs.iter().any(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n+pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n+    attr::contains_name(attrs, \"macro_escape\")\n }\n \n // Support for item-position macro invocations, exactly the same\n@@ -793,7 +794,7 @@ pub fn new_ident_resolver() ->\n mod test {\n     use super::*;\n     use ast;\n-    use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n+    use ast::{Attribute_, AttrOuter, MetaWord, empty_ctxt};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n@@ -883,14 +884,14 @@ mod test {\n         assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n-    // make a \"meta_word\" outer attribute with the given name\n-    fn make_dummy_attr(s: @str) -> ast::attribute {\n+    // make a MetaWord outer attribute with the given name\n+    fn make_dummy_attr(s: @str) -> ast::Attribute {\n         spanned {\n             span:codemap::dummy_sp(),\n-            node: attribute_ {\n-                style: attr_outer,\n+            node: Attribute_ {\n+                style: AttrOuter,\n                 value: @spanned {\n-                    node: meta_word(s),\n+                    node: MetaWord(s),\n                     span: codemap::dummy_sp(),\n                 },\n                 is_sugared_doc: false,"}, {"sha": "63cb3cf38f698b24ea031a516be3b156de6e7254", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -74,35 +74,34 @@ pub type ast_fold_fns = @AstFoldFns;\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(mi: @meta_item, fld: @ast_fold) -> @meta_item {\n+fn fold_meta_item_(mi: @MetaItem, fld: @ast_fold) -> @MetaItem {\n     @spanned {\n         node:\n             match mi.node {\n-                meta_word(id) => meta_word(id),\n-                meta_list(id, ref mis) => {\n+                MetaWord(id) => MetaWord(id),\n+                MetaList(id, ref mis) => {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    meta_list(\n+                    MetaList(\n                         id,\n                         mis.map(|e| fold_meta_item(*e))\n                     )\n                 }\n-                meta_name_value(id, s) => {\n-                    meta_name_value(id, s)\n-                }\n+                MetaNameValue(id, s) => MetaNameValue(id, s)\n             },\n         span: fld.new_span(mi.span) }\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n+fn fold_attribute_(at: Attribute, fld: @ast_fold) -> Attribute {\n     spanned {\n-        node: ast::attribute_ {\n+        span: fld.new_span(at.span),\n+        node: ast::Attribute_ {\n             style: at.node.style,\n             value: fold_meta_item_(at.node.value, fld),\n-            is_sugared_doc: at.node.is_sugared_doc,\n-        },\n-        span: fld.new_span(at.span),\n+            is_sugared_doc: at.node.is_sugared_doc\n+        }\n     }\n }\n+\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n@@ -936,11 +935,11 @@ impl ast_fold for AstFoldFns {\n }\n \n pub trait AstFoldExtensions {\n-    fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute];\n+    fn fold_attributes(&self, attrs: ~[Attribute]) -> ~[Attribute];\n }\n \n impl AstFoldExtensions for @ast_fold {\n-    fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute] {\n+    fn fold_attributes(&self, attrs: ~[Attribute]) -> ~[Attribute] {\n         attrs.map(|x| fold_attribute_(*x, *self))\n     }\n }"}, {"sha": "8cce5f15e67a84f0ec008f0d247003d5b5d52798", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -17,40 +17,40 @@ use parse::parser::Parser;\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n-    fn parse_outer_attributes(&self) -> ~[ast::attribute];\n-    fn parse_attribute(&self, style: ast::attr_style) -> ast::attribute;\n+    fn parse_outer_attributes(&self) -> ~[ast::Attribute];\n+    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute;\n     fn parse_attribute_naked(\n         &self,\n-        style: ast::attr_style,\n+        style: ast::AttrStyle,\n         lo: BytePos\n-    ) -> ast::attribute;\n+    ) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::attribute], ~[ast::attribute]);\n-    fn parse_meta_item(&self) -> @ast::meta_item;\n-    fn parse_meta_seq(&self) -> ~[@ast::meta_item];\n-    fn parse_optional_meta(&self) -> ~[@ast::meta_item];\n+        (~[ast::Attribute], ~[ast::Attribute]);\n+    fn parse_meta_item(&self) -> @ast::MetaItem;\n+    fn parse_meta_seq(&self) -> ~[@ast::MetaItem];\n+    fn parse_optional_meta(&self) -> ~[@ast::MetaItem];\n }\n \n impl parser_attr for Parser {\n \n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes(&self) -> ~[ast::attribute] {\n-        let mut attrs: ~[ast::attribute] = ~[];\n+    fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n+        let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n             match *self.token {\n               token::POUND => {\n                 if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     break;\n                 }\n-                attrs.push(self.parse_attribute(ast::attr_outer));\n+                attrs.push(self.parse_attribute(ast::AttrOuter));\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                     self.id_to_str(s),\n                     self.span.lo,\n                     self.span.hi\n                 );\n-                if attr.node.style != ast::attr_outer {\n+                if attr.node.style != ast::AttrOuter {\n                   self.fatal(\"expected outer comment\");\n                 }\n                 attrs.push(attr);\n@@ -63,20 +63,20 @@ impl parser_attr for Parser {\n     }\n \n     // matches attribute = # attribute_naked\n-    fn parse_attribute(&self, style: ast::attr_style) -> ast::attribute {\n+    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute {\n         let lo = self.span.lo;\n         self.expect(&token::POUND);\n         return self.parse_attribute_naked(style, lo);\n     }\n \n     // matches attribute_naked = [ meta_item ]\n-    fn parse_attribute_naked(&self, style: ast::attr_style, lo: BytePos) ->\n-        ast::attribute {\n+    fn parse_attribute_naked(&self, style: ast::AttrStyle, lo: BytePos) ->\n+        ast::Attribute {\n         self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n         self.expect(&token::RBRACKET);\n         let hi = self.span.hi;\n-        return spanned(lo, hi, ast::attribute_ { style: style,\n+        return spanned(lo, hi, ast::Attribute_ { style: style,\n                                                  value: meta_item, is_sugared_doc: false }); }\n \n     // Parse attributes that appear after the opening of an item, each\n@@ -90,25 +90,25 @@ impl parser_attr for Parser {\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n     fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::attribute], ~[ast::attribute]) {\n-        let mut inner_attrs: ~[ast::attribute] = ~[];\n-        let mut next_outer_attrs: ~[ast::attribute] = ~[];\n+        (~[ast::Attribute], ~[ast::Attribute]) {\n+        let mut inner_attrs: ~[ast::Attribute] = ~[];\n+        let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n             match *self.token {\n               token::POUND => {\n                 if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     // This is an extension\n                     break;\n                 }\n-                let attr = self.parse_attribute(ast::attr_inner);\n+                let attr = self.parse_attribute(ast::AttrInner);\n                 if *self.token == token::SEMI {\n                     self.bump();\n                     inner_attrs.push(attr);\n                 } else {\n                     // It's not really an inner attribute\n                     let outer_attr =\n                         spanned(attr.span.lo, attr.span.hi,\n-                            ast::attribute_ { style: ast::attr_outer,\n+                            ast::Attribute_ { style: ast::AttrOuter,\n                                               value: attr.node.value,\n                                               is_sugared_doc: false });\n                     next_outer_attrs.push(outer_attr);\n@@ -122,7 +122,7 @@ impl parser_attr for Parser {\n                     self.span.hi\n                 );\n                 self.bump();\n-                if attr.node.style == ast::attr_inner {\n+                if attr.node.style == ast::AttrInner {\n                   inner_attrs.push(attr);\n                 } else {\n                   next_outer_attrs.push(attr);\n@@ -138,37 +138,37 @@ impl parser_attr for Parser {\n     // matches meta_item = IDENT\n     // | IDENT = lit\n     // | IDENT meta_seq\n-    fn parse_meta_item(&self) -> @ast::meta_item {\n+    fn parse_meta_item(&self) -> @ast::MetaItem {\n         let lo = self.span.lo;\n         let name = self.id_to_str(self.parse_ident());\n         match *self.token {\n             token::EQ => {\n                 self.bump();\n                 let lit = self.parse_lit();\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::meta_name_value(name, lit))\n+                @spanned(lo, hi, ast::MetaNameValue(name, lit))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::meta_list(name, inner_items))\n+                @spanned(lo, hi, ast::MetaList(name, inner_items))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                @spanned(lo, hi, ast::meta_word(name))\n+                @spanned(lo, hi, ast::MetaWord(name))\n             }\n         }\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&self) -> ~[@ast::meta_item] {\n+    fn parse_meta_seq(&self) -> ~[@ast::MetaItem] {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&self) -> ~[@ast::meta_item] {\n+    fn parse_optional_meta(&self) -> ~[@ast::MetaItem] {\n         match *self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => ~[]"}, {"sha": "6daeb1b3e1e9e94e44ff0c19dc1e7f2089976a8d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -44,12 +44,12 @@ pub fn is_doc_comment(s: &str) -> bool {\n     s.starts_with(\"/*!\")\n }\n \n-pub fn doc_comment_style(comment: &str) -> ast::attr_style {\n+pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n     assert!(is_doc_comment(comment));\n     if comment.starts_with(\"//!\") || comment.starts_with(\"/*!\") {\n-        ast::attr_inner\n+        ast::AttrInner\n     } else {\n-        ast::attr_outer\n+        ast::AttrOuter\n     }\n }\n "}, {"sha": "c7a65c80de18c06967f8cea9f421061c5c944793", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -115,7 +115,7 @@ pub fn parse_item_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::crate_cfg,\n-    attrs: ~[ast::attribute],\n+    attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n     let p = new_parser_from_source_str(\n@@ -132,7 +132,7 @@ pub fn parse_meta_from_source_str(\n     source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n-) -> @ast::meta_item {\n+) -> @ast::MetaItem {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -146,7 +146,7 @@ pub fn parse_stmt_from_source_str(\n     name: @str,\n     source: @str,\n     cfg: ast::crate_cfg,\n-    attrs: ~[ast::attribute],\n+    attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> @ast::stmt {\n     let p = new_parser_from_source_str("}, {"sha": "6d7fd3390fa9bbd000965925e30d8081ae5cafc8", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -17,7 +17,7 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{expr, expr_lit, lit_nil, attribute};\n+use ast::{expr, expr_lit, lit_nil, Attribute};\n use ast;\n use codemap::{span, respan};\n use parse::parser::Parser;\n@@ -88,7 +88,7 @@ pub trait ParserObsoleteMethods {\n     fn eat_obsolete_ident(&self, ident: &str) -> bool;\n     fn try_parse_obsolete_struct_ctor(&self) -> bool;\n     fn try_parse_obsolete_with(&self) -> bool;\n-    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool;\n+    fn try_parse_obsolete_priv_section(&self, attrs: &[Attribute]) -> bool;\n }\n \n impl ParserObsoleteMethods for Parser {\n@@ -322,7 +322,7 @@ impl ParserObsoleteMethods for Parser {\n         }\n     }\n \n-    pub fn try_parse_obsolete_priv_section(&self, attrs: &[attribute])\n+    pub fn try_parse_obsolete_priv_section(&self, attrs: &[Attribute])\n                                            -> bool {\n         if self.is_keyword(keywords::Priv) &&\n                 self.look_ahead(1, |t| *t == token::LBRACE) {"}, {"sha": "7e1d5bff4df2d593a7622eba186e9f6b1b14c9d5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -15,7 +15,7 @@ use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n-use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n+use ast::{_mod, add, arg, arm, Attribute, bind_by_ref, bind_infer};\n use ast::{bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n@@ -109,12 +109,12 @@ enum restriction {\n }\n \n type arg_or_capture_item = Either<arg, ()>;\n-type item_info = (ident, item_, Option<~[attribute]>);\n+type item_info = (ident, item_, Option<~[Attribute]>);\n \n pub enum item_or_view_item {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    iovi_none(~[attribute]),\n+    iovi_none(~[Attribute]),\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n     iovi_view_item(view_item)\n@@ -242,8 +242,8 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n-             -> ~[attribute] {\n+fn maybe_append(lhs: ~[Attribute], rhs: Option<~[Attribute]>)\n+             -> ~[Attribute] {\n     match rhs {\n         None => lhs,\n         Some(ref attrs) => vec::append(lhs, (*attrs))\n@@ -252,7 +252,7 @@ fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n \n struct ParsedItemsAndViewItems {\n-    attrs_remaining: ~[attribute],\n+    attrs_remaining: ~[Attribute],\n     view_items: ~[view_item],\n     items: ~[@item],\n     foreign_items: ~[@foreign_item]\n@@ -2959,7 +2959,7 @@ impl Parser {\n     // parse a structure field\n     fn parse_name_and_ty(&self,\n                          pr: visibility,\n-                         attrs: ~[attribute]) -> @struct_field {\n+                         attrs: ~[Attribute]) -> @struct_field {\n         let lo = self.span.lo;\n         if !is_plain_ident(&*self.token) {\n             self.fatal(\"expected ident\");\n@@ -2977,7 +2977,7 @@ impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n+    pub fn parse_stmt(&self, item_attrs: ~[Attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, found_attrs: bool) {\n@@ -3091,7 +3091,7 @@ impl Parser {\n \n     // parse a block. Inner attrs are allowed.\n     fn parse_inner_attrs_and_block(&self)\n-        -> (~[attribute], blk) {\n+        -> (~[Attribute], blk) {\n \n         maybe_whole!(pair_empty self, nt_block);\n \n@@ -3115,7 +3115,7 @@ impl Parser {\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n-                         first_item_attrs: ~[attribute]) -> blk {\n+                         first_item_attrs: ~[Attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n@@ -3594,7 +3594,7 @@ impl Parser {\n \n     fn mk_item(&self, lo: BytePos, hi: BytePos, ident: ident,\n                node: item_, vis: visibility,\n-               attrs: ~[attribute]) -> @item {\n+               attrs: ~[Attribute]) -> @item {\n         @ast::item { ident: ident,\n                      attrs: attrs,\n                      id: self.get_id(),\n@@ -3825,7 +3825,7 @@ impl Parser {\n     // parse a structure field declaration\n     pub fn parse_single_struct_field(&self,\n                                      vis: visibility,\n-                                     attrs: ~[attribute])\n+                                     attrs: ~[Attribute])\n                                      -> @struct_field {\n         if self.eat_obsolete_ident(\"let\") {\n             self.obsolete(*self.last_span, ObsoleteLet);\n@@ -3894,7 +3894,7 @@ impl Parser {\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&self,\n                        term: token::Token,\n-                       first_item_attrs: ~[attribute])\n+                       first_item_attrs: ~[Attribute])\n                        -> _mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n@@ -3953,7 +3953,7 @@ impl Parser {\n     }\n \n     // parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&self, outer_attrs: &[ast::attribute]) -> item_info {\n+    fn parse_item_mod(&self, outer_attrs: &[Attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n         if *self.token == token::SEMI {\n@@ -3972,11 +3972,10 @@ impl Parser {\n         }\n     }\n \n-    fn push_mod_path(&self, id: ident, attrs: &[ast::attribute]) {\n+    fn push_mod_path(&self, id: ident, attrs: &[Attribute]) {\n         let default_path = token::interner_get(id.name);\n-        let file_path = match ::attr::first_attr_value_str_by_name(\n-            attrs, \"path\") {\n-\n+        let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n+                                                                   \"path\") {\n             Some(d) => d,\n             None => default_path\n         };\n@@ -3990,14 +3989,13 @@ impl Parser {\n     // read a module from a source file.\n     fn eval_src_mod(&self,\n                     id: ast::ident,\n-                    outer_attrs: &[ast::attribute],\n+                    outer_attrs: &[ast::Attribute],\n                     id_sp: span)\n-                    -> (ast::item_, ~[ast::attribute]) {\n+                    -> (ast::item_, ~[ast::Attribute]) {\n         let prefix = Path(self.sess.cm.span_to_filename(*self.span));\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let default_path = token::interner_get(id.name).to_owned() + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n             Some(d) => {\n@@ -4008,7 +4006,7 @@ impl Parser {\n                     path\n                 }\n             }\n-            None => mod_path.push(default_path)\n+            None => mod_path.push(token::interner_get(id.name) + \".rs\") // default\n         };\n \n         self.eval_src_mod_from_path(prefix,\n@@ -4020,8 +4018,8 @@ impl Parser {\n     fn eval_src_mod_from_path(&self,\n                               prefix: Path,\n                               path: Path,\n-                              outer_attrs: ~[ast::attribute],\n-                              id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n+                              outer_attrs: ~[ast::Attribute],\n+                              id_sp: span) -> (ast::item_, ~[ast::Attribute]) {\n \n         let full_path = if path.is_absolute {\n             path\n@@ -4057,17 +4055,10 @@ impl Parser {\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         self.sess.included_mod_stack.pop();\n         return (ast::item_mod(m0), mod_attrs);\n-\n-        fn cdir_path_opt(default: @str, attrs: ~[ast::attribute]) -> @str {\n-            match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-                Some(d) => d,\n-                None => default\n-            }\n-        }\n     }\n \n     // parse a function declaration from a foreign module\n-    fn parse_item_foreign_fn(&self,  attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_item_foreign_fn(&self,  attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n@@ -4085,7 +4076,7 @@ impl Parser {\n \n     // parse a const definition from a foreign module\n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n-                                attrs: ~[attribute]) -> @foreign_item {\n+                                attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n         // XXX: Obsolete; remove after snap.\n@@ -4130,7 +4121,7 @@ impl Parser {\n     fn parse_foreign_mod_items(&self,\n                                sort: ast::foreign_mod_sort,\n                                abis: AbiSet,\n-                               first_item_attrs: ~[attribute])\n+                               first_item_attrs: ~[Attribute])\n                                -> foreign_mod {\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n@@ -4156,7 +4147,7 @@ impl Parser {\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n                               visibility: visibility,\n-                              attrs: ~[attribute],\n+                              attrs: ~[Attribute],\n                               items_allowed: bool)\n                               -> item_or_view_item {\n         let mut must_be_named_mod = false;\n@@ -4430,7 +4421,7 @@ impl Parser {\n     // NB: this function no longer parses the items inside an\n     // extern mod.\n     fn parse_item_or_view_item(&self,\n-                               attrs: ~[attribute],\n+                               attrs: ~[Attribute],\n                                macros_allowed: bool)\n                                -> item_or_view_item {\n         maybe_whole!(iovi self, nt_item);\n@@ -4562,7 +4553,7 @@ impl Parser {\n \n     // parse a foreign item; on failure, return iovi_none.\n     fn parse_foreign_item(&self,\n-                          attrs: ~[attribute],\n+                          attrs: ~[Attribute],\n                           macros_allowed: bool)\n                           -> item_or_view_item {\n         maybe_whole!(iovi self, nt_item);\n@@ -4587,7 +4578,7 @@ impl Parser {\n     // this is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &self,\n-        attrs: ~[attribute],\n+        attrs: ~[Attribute],\n         macros_allowed: bool,\n         lo : BytePos,\n         visibility : visibility\n@@ -4649,7 +4640,7 @@ impl Parser {\n         return iovi_none(attrs);\n     }\n \n-    pub fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n+    pub fn parse_item(&self, attrs: ~[Attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             iovi_none(_) =>\n                 None,\n@@ -4786,7 +4777,7 @@ impl Parser {\n     // parse a view item.\n     fn parse_view_item(\n         &self,\n-        attrs: ~[attribute],\n+        attrs: ~[Attribute],\n         vis: visibility\n     ) -> view_item {\n         let lo = self.span.lo;\n@@ -4812,7 +4803,7 @@ impl Parser {\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n     fn parse_items_and_view_items(&self,\n-                                  first_item_attrs: ~[attribute],\n+                                  first_item_attrs: ~[Attribute],\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n@@ -4894,7 +4885,7 @@ impl Parser {\n \n     // Parses a sequence of foreign items. Stops when it finds program\n     // text that can't be parsed as an item\n-    fn parse_foreign_items(&self, first_item_attrs: ~[attribute],\n+    fn parse_foreign_items(&self, first_item_attrs: ~[Attribute],\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,"}, {"sha": "42966edfc0b1338425b6aa46eafee49b7c1b0c80", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc760a647ac0094814f592d08813ebae0b3bec47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cc760a647ac0094814f592d08813ebae0b3bec47", "patch": "@@ -14,7 +14,7 @@ use ast;\n use ast_util;\n use opt_vec::OptVec;\n use opt_vec;\n-use attr;\n+use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n@@ -212,11 +212,11 @@ pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn meta_item_to_str(mi: &ast::meta_item, intr: @ident_interner) -> ~str {\n+pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n-pub fn attribute_to_str(attr: &ast::attribute, intr: @ident_interner) -> ~str {\n+pub fn attribute_to_str(attr: &ast::Attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n@@ -352,7 +352,7 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n     commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n-pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.iter().advance |vitem| {\n         print_view_item(s, vitem);\n@@ -361,7 +361,7 @@ pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n-                         attrs: &[ast::attribute]) {\n+                         attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.iter().advance |vitem| {\n         print_view_item(s, vitem);\n@@ -843,22 +843,22 @@ pub fn print_method(s: @ps, meth: &ast::method) {\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n+pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n-          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n+          ast::AttrOuter => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n     }\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n+pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n-          ast::attr_inner => {\n+          ast::AttrInner => {\n             print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, \";\");\n@@ -871,16 +871,15 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: &ast::attribute) {\n+pub fn print_attribute(s: @ps, attr: &ast::Attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let meta = attr::attr_meta(*attr);\n-        let comment = attr::get_meta_item_value_str(meta).get();\n+        let comment = attr.value_str().get();\n         word(s.s, comment);\n     } else {\n         word(s.s, \"#[\");\n-        print_meta_item(s, attr.node.value);\n+        print_meta_item(s, attr.meta());\n         word(s.s, \"]\");\n     }\n }\n@@ -927,7 +926,7 @@ pub fn print_block_unclosed_indent(s: @ps, blk: &ast::blk, indented: uint) {\n \n pub fn print_block_with_attrs(s: @ps,\n                               blk: &ast::blk,\n-                              attrs: &[ast::attribute]) {\n+                              attrs: &[ast::Attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n }\n@@ -946,7 +945,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n                                       blk: &ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n-                                      attrs: &[ast::attribute],\n+                                      attrs: &[ast::Attribute],\n                                       close_box: bool) {\n     match blk.rules {\n       ast::unsafe_blk => word_space(s, \"unsafe\"),\n@@ -1793,16 +1792,16 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: &ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(name) => word(s.s, name),\n-      ast::meta_name_value(name, value) => {\n+      ast::MetaWord(name) => word(s.s, name),\n+      ast::MetaNameValue(name, value) => {\n         word_space(s, name);\n         word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n-      ast::meta_list(name, ref items) => {\n+      ast::MetaList(name, ref items) => {\n         word(s.s, name);\n         popen(s);\n         commasep(s,"}]}