{"sha": "31284d2ef2c0a09cf719269cf21f0286ed074bb4", "node_id": "C_kwDOAAsO6NoAKDMxMjg0ZDJlZjJjMGEwOWNmNzE5MjY5Y2YyMWYwMjg2ZWQwNzRiYjQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-21T16:42:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-21T16:42:09Z"}, "message": "Rollup merge of #99552 - lcnr:orphan_check-rework, r=oli-obk\n\nRewrite `orphan_check_trait_ref` to use a `TypeVisitor`\n\nThe current impl is far more confusing than it has any right to be :sparkles:\n\nr? rust-lang/types", "tree": {"sha": "c2bed0c6a7daa1ed3f988f0ec781c84fef678505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2bed0c6a7daa1ed3f988f0ec781c84fef678505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31284d2ef2c0a09cf719269cf21f0286ed074bb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi2YHhCRBK7hj4Ov3rIwAA2rUIAHiQq1a5+SApvcGjtSosouti\nApejiE17IwAbBNg6YROnzXSFPNv7CwQZ7BNCCicdJSHnLx1qwgw31y37UBx1K1yB\nhgYsP/KBH84pDFltdMZt/CTFWeTUkDPzsTYzZF4AjFSF1ElIvBFRyT5j3ZAHGNrn\nxcosq8QLUqQpfjMBHE0/+3D9H3NwobQAv3BHCm/rXAYA8e0Dna9HWZ2nlSOMWWjC\nTeut4lwcKWkd+KyqGw0BJkor6Jr+pcmGqcJiL/tVb067bTyPbVHsX/hwXWLH9xwA\n7Sod3o7g7Gnh2NDDGYkwvFhvF7aljHZ6BC716XKkSi3ufTrc4DEXKWEYuu/RFpo=\n=4eHp\n-----END PGP SIGNATURE-----\n", "payload": "tree c2bed0c6a7daa1ed3f988f0ec781c84fef678505\nparent d425fe8fb34aa060391d5677d985d07ff53e32cf\nparent 84c3fcd2a0285c06a682c9b064640084e4c7271b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1658421729 +0200\ncommitter GitHub <noreply@github.com> 1658421729 +0200\n\nRollup merge of #99552 - lcnr:orphan_check-rework, r=oli-obk\n\nRewrite `orphan_check_trait_ref` to use a `TypeVisitor`\n\nThe current impl is far more confusing than it has any right to be :sparkles:\n\nr? rust-lang/types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31284d2ef2c0a09cf719269cf21f0286ed074bb4", "html_url": "https://github.com/rust-lang/rust/commit/31284d2ef2c0a09cf719269cf21f0286ed074bb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31284d2ef2c0a09cf719269cf21f0286ed074bb4/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d425fe8fb34aa060391d5677d985d07ff53e32cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d425fe8fb34aa060391d5677d985d07ff53e32cf", "html_url": "https://github.com/rust-lang/rust/commit/d425fe8fb34aa060391d5677d985d07ff53e32cf"}, {"sha": "84c3fcd2a0285c06a682c9b064640084e4c7271b", "url": "https://api.github.com/repos/rust-lang/rust/commits/84c3fcd2a0285c06a682c9b064640084e4c7271b", "html_url": "https://github.com/rust-lang/rust/commit/84c3fcd2a0285c06a682c9b064640084e4c7271b"}], "stats": {"total": 321, "additions": 124, "deletions": 197}, "files": [{"sha": "9983438233e1ef129275b506f53ab82d1f57a2e6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 123, "deletions": 196, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/31284d2ef2c0a09cf719269cf21f0286ed074bb4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31284d2ef2c0a09cf719269cf21f0286ed074bb4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=31284d2ef2c0a09cf719269cf21f0286ed074bb4", "patch": "@@ -22,11 +22,12 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -578,220 +579,146 @@ fn orphan_check_trait_ref<'tcx>(\n         );\n     }\n \n-    // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n-    // if at least one of the following is true:\n-    //\n-    // - Trait is a local trait\n-    // (already checked in orphan_check prior to calling this function)\n-    // - All of\n-    //     - At least one of the types T0..=Tn must be a local type.\n-    //      Let Ti be the first such type.\n-    //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n-    //\n-    fn uncover_fundamental_ty<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        in_crate: InCrate,\n-    ) -> Vec<Ty<'tcx>> {\n-        // FIXME: this is currently somewhat overly complicated,\n-        // but fixing this requires a more complicated refactor.\n-        if !contained_non_local_types(tcx, ty, in_crate).is_empty() {\n-            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-                return inner_tys\n-                    .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                    .collect();\n+    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    match trait_ref.visit_with(&mut checker) {\n+        ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n+        ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n+            // Does there exist some local type after the `ParamTy`.\n+            checker.search_first_local_ty = true;\n+            if let Some(OrphanCheckEarlyExit::LocalTy(local_ty)) =\n+                trait_ref.visit_with(&mut checker).break_value()\n+            {\n+                Err(OrphanCheckErr::UncoveredTy(ty, Some(local_ty)))\n+            } else {\n+                Err(OrphanCheckErr::UncoveredTy(ty, None))\n             }\n         }\n-\n-        vec![ty]\n-    }\n-\n-    let mut non_local_spans = vec![];\n-    for (i, input_ty) in trait_ref\n-        .substs\n-        .types()\n-        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-        .enumerate()\n-    {\n-        debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = contained_non_local_types(tcx, input_ty, in_crate);\n-        if non_local_tys.is_empty() {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-            return Ok(());\n-        } else if let ty::Param(_) = input_ty.kind() {\n-            debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n-            let local_type = trait_ref\n-                .substs\n-                .types()\n-                .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|&ty| ty_is_local_constructor(tcx, ty, in_crate));\n-\n-            debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n-\n-            return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type));\n-        }\n-\n-        non_local_spans.extend(non_local_tys.into_iter().map(|input_ty| (input_ty, i == 0)));\n+        ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(_)) => Ok(()),\n     }\n-    // If we exit above loop, never found a local type.\n-    debug!(\"orphan_check_trait_ref: no local type\");\n-    Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-/// Returns a list of relevant non-local types for `ty`.\n-///\n-/// This is just `ty` itself unless `ty` is `#[fundamental]`,\n-/// in which case we recursively look into this type.\n-///\n-/// If `ty` is local itself, this method returns an empty `Vec`.\n-///\n-/// # Examples\n-///\n-/// - `u32` is not local, so this returns `[u32]`.\n-/// - for `Foo<u32>`, where `Foo` is a local type, this returns `[]`.\n-/// - `&mut u32` returns `[u32]`, as `&mut` is a fundamental type, similar to `Box`.\n-/// - `Box<Foo<u32>>` returns `[]`, as `Box` is a fundamental type and `Foo` is local.\n-fn contained_non_local_types<'tcx>(\n+struct OrphanChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n     in_crate: InCrate,\n-) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(tcx, ty, in_crate) {\n-        Vec::new()\n-    } else {\n-        match fundamental_ty_inner_tys(tcx, ty) {\n-            Some(inner_tys) => {\n-                inner_tys.flat_map(|ty| contained_non_local_types(tcx, ty, in_crate)).collect()\n-            }\n-            None => vec![ty],\n+    in_self_ty: bool,\n+    /// Ignore orphan check failures and exclusively search for the first\n+    /// local type.\n+    search_first_local_ty: bool,\n+    non_local_tys: Vec<(Ty<'tcx>, bool)>,\n+}\n+\n+impl<'tcx> OrphanChecker<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+        OrphanChecker {\n+            tcx,\n+            in_crate,\n+            in_self_ty: true,\n+            search_first_local_ty: false,\n+            non_local_tys: Vec::new(),\n         }\n     }\n-}\n \n-/// For `#[fundamental]` ADTs and `&T` / `&mut T`, returns `Some` with the\n-/// type parameters of the ADT, or `T`, respectively. For non-fundamental\n-/// types, returns `None`.\n-fn fundamental_ty_inner_tys<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n-    let (first_ty, rest_tys) = match *ty.kind() {\n-        ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n-        ty::Adt(def, substs) if def.is_fundamental() => {\n-            let mut types = substs.types();\n-\n-            // FIXME(eddyb) actually validate `#[fundamental]` up-front.\n-            match types.next() {\n-                None => {\n-                    tcx.sess.span_err(\n-                        tcx.def_span(def.did()),\n-                        \"`#[fundamental]` requires at least one type parameter\",\n-                    );\n-\n-                    return None;\n-                }\n+    fn found_non_local_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        self.non_local_tys.push((t, self.in_self_ty));\n+        ControlFlow::CONTINUE\n+    }\n \n-                Some(first_ty) => (first_ty, types),\n-            }\n+    fn found_param_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        if self.search_first_local_ty {\n+            ControlFlow::CONTINUE\n+        } else {\n+            ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(t))\n         }\n-        _ => return None,\n-    };\n+    }\n \n-    Some(iter::once(first_ty).chain(rest_tys))\n+    fn def_id_is_local(&mut self, def_id: DefId) -> bool {\n+        match self.in_crate {\n+            InCrate::Local => def_id.is_local(),\n+            InCrate::Remote => false,\n+        }\n+    }\n }\n \n-fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n-    match in_crate {\n-        // The type is local to *this* crate - it will not be\n-        // local in any other crate.\n-        InCrate::Remote => false,\n-        InCrate::Local => def_id.is_local(),\n-    }\n+enum OrphanCheckEarlyExit<'tcx> {\n+    ParamTy(Ty<'tcx>),\n+    LocalTy(Ty<'tcx>),\n }\n \n-fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    debug!(\"ty_is_local_constructor({:?})\", ty);\n-\n-    match *ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::Str\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Array(..)\n-        | ty::Slice(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::Never\n-        | ty::Tuple(..)\n-        | ty::Param(..)\n-        | ty::Projection(..) => false,\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match in_crate {\n-            InCrate::Local => false,\n-            // The inference variable might be unified with a local\n-            // type in that remote crate.\n-            InCrate::Remote => true,\n-        },\n-\n-        ty::Adt(def, _) => def_id_is_local(def.did(), in_crate),\n-        ty::Foreign(did) => def_id_is_local(did, in_crate),\n-        ty::Opaque(..) => {\n-            // This merits some explanation.\n-            // Normally, opaque types are not involved when performing\n-            // coherence checking, since it is illegal to directly\n-            // implement a trait on an opaque type. However, we might\n-            // end up looking at an opaque type during coherence checking\n-            // if an opaque type gets used within another type (e.g. as\n-            // a type parameter). This requires us to decide whether or\n-            // not an opaque type should be considered 'local' or not.\n-            //\n-            // We choose to treat all opaque types as non-local, even\n-            // those that appear within the same crate. This seems\n-            // somewhat surprising at first, but makes sense when\n-            // you consider that opaque types are supposed to hide\n-            // the underlying type *within the same crate*. When an\n-            // opaque type is used from outside the module\n-            // where it is declared, it should be impossible to observe\n-            // anything about it other than the traits that it implements.\n-            //\n-            // The alternative would be to look at the underlying type\n-            // to determine whether or not the opaque type itself should\n-            // be considered local. However, this could make it a breaking change\n-            // to switch the underlying ('defining') type from a local type\n-            // to a remote type. This would violate the rule that opaque\n-            // types should be completely opaque apart from the traits\n-            // that they implement, so we don't use this behavior.\n-            false\n-        }\n+impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n+    type BreakTy = OrphanCheckEarlyExit<'tcx>;\n+    fn visit_region(&mut self, _r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n+    }\n \n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                def_id_is_local(principal.def_id(), in_crate)\n-            } else {\n-                false\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let result = match *ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Projection(..) => self.found_non_local_ty(ty),\n+\n+            ty::Param(..) => self.found_param_ty(ty),\n+\n+            ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match self.in_crate {\n+                InCrate::Local => self.found_non_local_ty(ty),\n+                // The inference variable might be unified with a local\n+                // type in that remote crate.\n+                InCrate::Remote => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            },\n+\n+            // For fundamental types, we just look inside of them.\n+            ty::Ref(_, ty, _) => ty.visit_with(self),\n+            ty::Adt(def, substs) => {\n+                if self.def_id_is_local(def.did()) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else if def.is_fundamental() {\n+                    substs.visit_with(self)\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n-        }\n+            ty::Foreign(def_id) => {\n+                if self.def_id_is_local(def_id) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Dynamic(tt, ..) => {\n+                let principal = tt.principal().map(|p| p.def_id());\n+                if principal.map_or(false, |p| self.def_id_is_local(p)) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            ty::Opaque(..) | ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n+                );\n+                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            }\n+        };\n+        // A bit of a hack, the `OrphanChecker` is only used to visit a `TraitRef`, so\n+        // the first type we visit is always the self type.\n+        self.in_self_ty = false;\n+        result\n+    }\n \n-        ty::Error(_) => true,\n-\n-        // These variants should never appear during coherence checking because they\n-        // cannot be named directly.\n-        //\n-        // They could be indirectly used through an opaque type. While using opaque types\n-        // in impls causes an error, this path can still be hit afterwards.\n-        //\n-        // See `test/ui/coherence/coherence-with-closure.rs` for an example where this\n-        // could happens.\n-        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-            tcx.sess.delay_span_bug(\n-                DUMMY_SP,\n-                format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-            );\n-            true\n-        }\n+    // FIXME: Constants should participate in orphan checking.\n+    fn visit_const(&mut self, _c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n     }\n }"}, {"sha": "2eea726a19c5aa6622a2365b1271ee2a11a00bb7", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31284d2ef2c0a09cf719269cf21f0286ed074bb4/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31284d2ef2c0a09cf719269cf21f0286ed074bb4/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=31284d2ef2c0a09cf719269cf21f0286ed074bb4", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+   = note: downstream crates may implement trait `std::fmt::Debug` for type `OpaqueType`\n \n error: cannot implement trait on type alias impl trait\n   --> $DIR/negative-reasoning.rs:19:25"}]}