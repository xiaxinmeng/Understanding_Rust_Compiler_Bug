{"sha": "de0abf7599023b71dd72b44f0165e86c040ee7ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMGFiZjc1OTkwMjNiNzFkZDcyYjQ0ZjAxNjVlODZjMDQwZWU3ZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T23:00:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T23:00:38Z"}, "message": "Auto merge of #66650 - matthewjasper:nonuniform-array-move, r=pnkfelix\n\nRemove uniform array move MIR passes\n\nThis PR fixes a number of bugs caused by limitations of this pass\n\n* Projections from constant indexes weren't being canonicalized\n* Constant indexes from the start weren't being canonicalized (they could have different min_lengths)\n* It didn't apply to non-moves\n\nThis PR makes the following changes to support removing this pass:\n\n* ConstantIndex of arrays are now generated in a canonical form (from the start, min_length is the actual length).\n* Subslices are now split when generating move paths and when checking subslices have been moved.\n\nAdditionally\n\n* The parent move path of a projection from an array element is now calculated correctly\n\ncloses #66502", "tree": {"sha": "be49c0cf5e2200c6d31133d7c336d99dee41d90c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be49c0cf5e2200c6d31133d7c336d99dee41d90c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0abf7599023b71dd72b44f0165e86c040ee7ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0abf7599023b71dd72b44f0165e86c040ee7ea", "html_url": "https://github.com/rust-lang/rust/commit/de0abf7599023b71dd72b44f0165e86c040ee7ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0abf7599023b71dd72b44f0165e86c040ee7ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d6f55f47e8875e71083a28ed84ea5a88e1b596", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d6f55f47e8875e71083a28ed84ea5a88e1b596", "html_url": "https://github.com/rust-lang/rust/commit/27d6f55f47e8875e71083a28ed84ea5a88e1b596"}, {"sha": "d96485d49e3745a9b9f4b2ed6ba9cebf265f142e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96485d49e3745a9b9f4b2ed6ba9cebf265f142e", "html_url": "https://github.com/rust-lang/rust/commit/d96485d49e3745a9b9f4b2ed6ba9cebf265f142e"}], "stats": {"total": 1762, "additions": 1131, "deletions": 631}, "files": [{"sha": "ba8feb4ee739d3f077419e9f4948c0f27c6e90f8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1714,18 +1714,25 @@ pub enum ProjectionElem<V, T> {\n     ConstantIndex {\n         /// index or -index (in Python terms), depending on from_end\n         offset: u32,\n-        /// thing being indexed must be at least this long\n+        /// The thing being indexed must be at least this long. For arrays this\n+        /// is always the exact length.\n         min_length: u32,\n-        /// counting backwards from end?\n+        /// Counting backwards from end? This is always false when indexing an\n+        /// array.\n         from_end: bool,\n     },\n \n     /// These indices are generated by slice patterns.\n     ///\n-    /// slice[from:-to] in Python terms.\n+    /// If `from_end` is true `slice[from..slice.len() - to]`.\n+    /// Otherwise `array[from..to]`.\n     Subslice {\n         from: u32,\n         to: u32,\n+        /// Whether `to` counts from the start or end of the array/slice.\n+        /// For `PlaceElem`s this is `true` if and only if the base is a slice.\n+        /// For `ProjectionKind`, this can also be `true` for arrays.\n+        from_end: bool,\n     },\n \n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n@@ -1914,15 +1921,18 @@ impl Debug for Place<'_> {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                     write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                 }\n-                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if *to == 0 => {\n                     write!(fmt, \"[{:?}:]\", from)?;\n                 }\n-                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                ProjectionElem::Subslice { from, to, from_end: true } if *from == 0 => {\n                     write!(fmt, \"[:-{:?}]\", to)?;\n                 }\n-                ProjectionElem::Subslice { from, to } => {\n+                ProjectionElem::Subslice { from, to, from_end: true } => {\n                     write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n+                ProjectionElem::Subslice { from, to, from_end: false } => {\n+                    write!(fmt, \"[{:?}..{:?}]\", from, to)?;\n+                }\n             }\n         }\n \n@@ -2456,7 +2466,7 @@ impl UserTypeProjection {\n     }\n \n     pub(crate) fn subslice(mut self, from: u32, to: u32) -> Self {\n-        self.projs.push(ProjectionElem::Subslice { from, to });\n+        self.projs.push(ProjectionElem::Subslice { from, to, from_end: true });\n         self\n     }\n "}, {"sha": "445fa6ea8cab31b7fb2d982994debcbb08e70175", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -88,14 +88,17 @@ impl<'tcx> PlaceTy<'tcx> {\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n                 PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n-            ProjectionElem::Subslice { from, to } => {\n+            ProjectionElem::Subslice { from, to, from_end } => {\n                 PlaceTy::from_ty(match self.ty.kind {\n-                    ty::Array(inner, size) => {\n+                    ty::Slice(..) => self.ty,\n+                    ty::Array(inner, _) if !from_end => {\n+                        tcx.mk_array(inner, (to - from) as u64)\n+                    }\n+                    ty::Array(inner, size) if from_end => {\n                         let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n                         tcx.mk_array(inner, len)\n                     }\n-                    ty::Slice(..) => self.ty,\n                     _ => {\n                         bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                     }"}, {"sha": "5d273fe85b6d2e49657d7fb3e67ce30ea39f4c79", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -954,7 +954,7 @@ macro_rules! visit_place_fns {\n                     );\n                 }\n                 ProjectionElem::Deref |\n-                ProjectionElem::Subslice { from: _, to: _ } |\n+                ProjectionElem::Subslice { from: _, to: _, from_end: _ } |\n                 ProjectionElem::ConstantIndex { offset: _,\n                                                 min_length: _,\n                                                 from_end: _ } |"}, {"sha": "5e13cabced000768a1ac3cabc22b885fbb7e1698", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -565,14 +565,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n-                    mir::ProjectionElem::Subslice { from, to } => {\n+                    mir::ProjectionElem::Subslice { from, to, from_end } => {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(*from as u64));\n                         let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n                             .projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n+                            assert!(from_end, \"slice subslices should be `from_end`\");\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n                                 bx.cx().const_usize((*from as u64) + (*to as u64))));\n                         }"}, {"sha": "1cd43d4fdd411cbe36aae02d174a8b3b3bb1bad5", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -78,10 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .collect();\n \n         if move_out_indices.is_empty() {\n-            let root_place = self\n-                .prefixes(used_place, PrefixSet::All)\n-                .last()\n-                .unwrap();\n+            let root_place = PlaceRef { projection: &[], ..used_place };\n \n             if !self.uninitialized_error_reported.insert(root_place) {\n                 debug!("}, {"sha": "b4f2e2377ac7dc95c4ff28a734921ea574a794ff", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -174,7 +174,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(&body, tcx) {\n+        match MoveData::gather_moves(&body, tcx, param_env) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -1600,7 +1600,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         (prefix, place_span.0, place_span.1),\n                         mpi,\n                     );\n-                    return; // don't bother finding other problems.\n                 }\n             }\n             Err(NoMovePathFound::ReachedStatic) => {\n@@ -1614,6 +1613,46 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Subslices correspond to multiple move paths, so we iterate through the\n+    /// elements of the base array. For each element we check\n+    ///\n+    /// * Does this element overlap with our slice.\n+    /// * Is any part of it uninitialized.\n+    fn check_if_subslice_element_is_moved(\n+        &mut self,\n+        location: Location,\n+        desired_action: InitializationRequiringAction,\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n+        maybe_uninits: &FlowAtLocation<'tcx, MaybeUninitializedPlaces<'cx, 'tcx>>,\n+        from: u32,\n+        to: u32,\n+    ) {\n+        if let Some(mpi) = self.move_path_for_place(place_span.0) {\n+            let mut child = self.move_data.move_paths[mpi].first_child;\n+            while let Some(child_mpi) = child {\n+                let child_move_place = &self.move_data.move_paths[child_mpi];\n+                let child_place = &child_move_place.place;\n+                let last_proj = child_place.projection.last().unwrap();\n+                if let ProjectionElem::ConstantIndex { offset, from_end, .. } = last_proj {\n+                    debug_assert!(!from_end, \"Array constant indexing shouldn't be `from_end`.\");\n+\n+                    if (from..to).contains(offset) {\n+                        if let Some(uninit_child) = maybe_uninits.has_any_child_of(child_mpi) {\n+                            self.report_use_of_moved_or_uninitialized(\n+                                location,\n+                                desired_action,\n+                                (place_span.0, place_span.0, place_span.1),\n+                                uninit_child,\n+                            );\n+                            return; // don't bother finding other problems.\n+                        }\n+                    }\n+                }\n+                child = child_move_place.next_sibling;\n+            }\n+        }\n+    }\n+\n     fn check_if_path_or_subpath_is_moved(\n         &mut self,\n         location: Location,\n@@ -1640,6 +1679,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);\n \n+        if let [\n+            base_proj @ ..,\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+        ] = place_span.0.projection {\n+            let place_ty = Place::ty_from(\n+                place_span.0.base,\n+                base_proj,\n+                self.body(),\n+                self.infcx.tcx,\n+            );\n+            if let ty::Array(..) = place_ty.ty.kind {\n+                let array_place = PlaceRef { base: place_span.0.base, projection: base_proj };\n+                self.check_if_subslice_element_is_moved(\n+                    location,\n+                    desired_action,\n+                    (array_place, place_span.1),\n+                    maybe_uninits,\n+                    *from,\n+                    *to,\n+                );\n+                return;\n+            }\n+        }\n+\n         // A move of any shallow suffix of `place` also interferes\n         // with an attempt to use `place`. This is scenario 3 above.\n         //\n@@ -1675,25 +1738,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// static variable, as we do not track those in the MoveData.\n     fn move_path_closest_to(\n         &mut self,\n-        place: PlaceRef<'cx, 'tcx>,\n+        place: PlaceRef<'_, 'tcx>,\n     ) -> Result<(PlaceRef<'cx, 'tcx>, MovePathIndex), NoMovePathFound> {\n-        let mut last_prefix = place.base;\n-\n-        for prefix in self.prefixes(place, PrefixSet::All) {\n-            if let Some(mpi) = self.move_path_for_place(prefix) {\n-                return Ok((prefix, mpi));\n-            }\n-\n-            last_prefix = prefix.base;\n-        }\n-\n-        match last_prefix {\n-            PlaceBase::Local(_) => panic!(\"should have move path for every Local\"),\n-            PlaceBase::Static(_) => Err(NoMovePathFound::ReachedStatic),\n+        match self.move_data.rev_lookup.find(place) {\n+            LookupResult::Parent(Some(mpi))\n+            | LookupResult::Exact(mpi) => Ok((self.move_data.move_paths[mpi].place.as_ref(), mpi)),\n+            LookupResult::Parent(None) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n-    fn move_path_for_place(&mut self, place: PlaceRef<'cx, 'tcx>) -> Option<MovePathIndex> {\n+    fn move_path_for_place(&mut self, place: PlaceRef<'_, 'tcx>) -> Option<MovePathIndex> {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `place` (which means there is nothing\n         // that borrowck tracks for its analysis)."}, {"sha": "1e3723edc564f226dc56765948bbdf5a16d7dcee", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -675,23 +675,16 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     }),\n                 )\n             }\n-            ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n+            ProjectionElem::Subslice { from, to, from_end } => PlaceTy::from_ty(\n                 match base_ty.kind {\n-                    ty::Array(inner, size) => {\n-                        let size = size.eval_usize(tcx, self.cx.param_env);\n-                        let min_size = (from as u64) + (to as u64);\n-                        if let Some(rest_size) = size.checked_sub(min_size) {\n-                            tcx.mk_array(inner, rest_size)\n-                        } else {\n-                            span_mirbug_and_err!(\n-                                self,\n-                                place,\n-                                \"taking too-small slice of {:?}\",\n-                                base_ty\n-                            )\n-                        }\n+                    ty::Array(inner, _) => {\n+                        assert!(!from_end, \"array subslices should not use from_end\");\n+                        tcx.mk_array(inner, (to - from) as u64)\n                     }\n-                    ty::Slice(..) => base_ty,\n+                    ty::Slice(..) => {\n+                        assert!(from_end, \"slice subslices should use from_end\");\n+                        base_ty\n+                    },\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             ),"}, {"sha": "9245064f8759422b086a0eda4fe3a8f7a41f286c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -503,34 +503,62 @@ fn place_projection_conflict<'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n+        (\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n+            ProjectionElem::Subslice { from, to, from_end: false }\n+        )\n+        | (\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }\n+        ) => {\n+            if (from..to).contains(&offset) {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                Overlap::Disjoint\n+            }\n+        }\n         (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n          ProjectionElem::Subslice {from, .. })\n         | (ProjectionElem::Subslice {from, .. },\n             ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n             if offset >= from {\n                 debug!(\n-                    \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                    \"place_element_conflict: DISJOINT-OR-EQ-SLICE-CONSTANT-INDEX-SUBSLICE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                debug!(\"place_element_conflict: DISJOINT-SLICE-CONSTANT-INDEX-SUBSLICE\");\n                 Overlap::Disjoint\n             }\n         }\n         (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n-         ProjectionElem::Subslice {from: _, to })\n-        | (ProjectionElem::Subslice {from: _, to },\n+         ProjectionElem::Subslice { to, from_end: true, .. })\n+        | (ProjectionElem::Subslice { to, from_end: true, .. },\n             ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n             if offset > to {\n                 debug!(\"place_element_conflict: \\\n-                       DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                       DISJOINT-OR-EQ-SLICE-CONSTANT-INDEX-SUBSLICE-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                debug!(\"place_element_conflict: DISJOINT-SLICE-CONSTANT-INDEX-SUBSLICE-FE\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (\n+            ProjectionElem::Subslice { from: f1, to: t1, from_end: false },\n+            ProjectionElem::Subslice { from: f2, to: t2, from_end: false }\n+        ) => {\n+            if f2 >= t1 || f1 >= t2 {\n+                debug!(\"place_element_conflict: DISJOINT-ARRAY-SUBSLICES\");\n                 Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+                Overlap::EqualOrDisjoint\n             }\n         }\n         (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+            debug!(\"place_element_conflict: DISJOINT-OR-EQ-SLICE-SUBSLICES\");\n              Overlap::EqualOrDisjoint\n         }\n         (ProjectionElem::Deref, _)"}, {"sha": "ec8b3c5e24bf276fb7324a72a6dc476223b7ad62", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -2,6 +2,7 @@ use crate::build::Builder;\n use crate::build::matches::MatchPair;\n use crate::hair::*;\n use rustc::mir::*;\n+use rustc::ty;\n use smallvec::SmallVec;\n use std::u32;\n use std::convert::TryInto;\n@@ -31,9 +32,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                      prefix: &'pat [Pat<'tcx>],\n                                      opt_slice: Option<&'pat Pat<'tcx>>,\n                                      suffix: &'pat [Pat<'tcx>]) {\n-        let min_length = prefix.len() + suffix.len();\n-        let min_length = min_length.try_into().unwrap();\n         let tcx = self.hir.tcx();\n+        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind {\n+            ty::Array(_, length) => (\n+                length.eval_usize(tcx, self.hir.param_env).try_into().unwrap(),\n+                true\n+            ),\n+            _ => (\n+                (prefix.len() + suffix.len()).try_into().unwrap(),\n+                false,\n+            ),\n+        };\n \n         match_pairs.extend(\n             prefix.iter()\n@@ -50,10 +59,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = tcx.mk_place_elem(place.clone(),ProjectionElem::Subslice {\n-                from: prefix.len() as u32,\n-                to: suffix.len() as u32\n-            });\n+            let suffix_len = suffix.len() as u32;\n+            let subslice = tcx.mk_place_elem(\n+                place.clone(),\n+                ProjectionElem::Subslice {\n+                    from: prefix.len() as u32,\n+                    to: if exact_size { min_length - suffix_len } else { suffix_len },\n+                    from_end: !exact_size,\n+                },\n+            );\n             match_pairs.push(MatchPair::new(subslice, subslice_pat));\n         }\n \n@@ -62,10 +76,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   .rev()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n+                      let end_offset = (idx + 1) as u32;\n                       let elem = ProjectionElem::ConstantIndex {\n-                          offset: (idx+1) as u32,\n+                          offset: if exact_size { min_length - end_offset } else { end_offset },\n                           min_length,\n-                          from_end: true,\n+                          from_end: !exact_size,\n                       };\n                       let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)"}, {"sha": "0665c0fb72c462069ec97d4bcd8322617e0541a4", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -49,8 +49,8 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n             ProjectionElem::Deref => ProjectionElem::Deref,\n             ProjectionElem::Field(ref f, ty) => ProjectionElem::Field(f.clone(), ty.lift()),\n             ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n-            ProjectionElem::Subslice { from, to } => {\n-                ProjectionElem::Subslice { from: from, to: to }\n+            ProjectionElem::Subslice { from, to, from_end } => {\n+                ProjectionElem::Subslice { from, to, from_end }\n             }\n             ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n                 ProjectionElem::ConstantIndex { offset, min_length, from_end }"}, {"sha": "fa0864e0de7607fa4fbd5989488c54f75165d5da", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 93, "deletions": 38, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc_index::vec::IndexVec;\n use smallvec::{smallvec, SmallVec};\n \n-use std::collections::hash_map::Entry;\n+use std::convert::TryInto;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -17,19 +17,21 @@ use super::{\n struct MoveDataBuilder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n \n         MoveDataBuilder {\n             body,\n             tcx,\n+            param_env,\n             errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n@@ -148,42 +150,47 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n                         ));\n                     }\n-                    _ => {\n-                        // FIXME: still badly broken\n-                    }\n+                    _ => {}\n                 },\n                 _ => {}\n             };\n \n-            let proj = &place.projection[..i+1];\n-            base = match self\n-                .builder\n-                .data\n-                .rev_lookup\n-                .projections\n-                .entry((base, elem.lift()))\n-                {\n-                    Entry::Occupied(ent) => *ent.get(),\n-                    Entry::Vacant(ent) => {\n-                        let path = MoveDataBuilder::new_move_path(\n-                            &mut self.builder.data.move_paths,\n-                            &mut self.builder.data.path_map,\n-                            &mut self.builder.data.init_path_map,\n-                            Some(base),\n-                            Place {\n-                                base: place.base.clone(),\n-                                projection: tcx.intern_place_elems(proj),\n-                            },\n-                        );\n-                        ent.insert(path);\n-                        path\n-                    }\n-                };\n+            base = self.add_move_path(base, elem, |tcx| {\n+                Place {\n+                    base: place.base.clone(),\n+                    projection: tcx.intern_place_elems(&place.projection[..i+1]),\n+                }\n+            });\n         }\n \n         Ok(base)\n     }\n \n+    fn add_move_path(\n+        &mut self,\n+        base: MovePathIndex,\n+        elem: &PlaceElem<'tcx>,\n+        mk_place: impl FnOnce(TyCtxt<'tcx>) -> Place<'tcx>,\n+    ) -> MovePathIndex {\n+        let MoveDataBuilder {\n+            data: MoveData { rev_lookup, move_paths, path_map, init_path_map, .. },\n+            tcx,\n+            ..\n+        } = self.builder;\n+        *rev_lookup.projections\n+            .entry((base, elem.lift()))\n+            .or_insert_with(move || {\n+                let path = MoveDataBuilder::new_move_path(\n+                    move_paths,\n+                    path_map,\n+                    init_path_map,\n+                    Some(base),\n+                    mk_place(*tcx),\n+                );\n+                path\n+            })\n+    }\n+\n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n@@ -214,8 +221,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n pub(super) fn gather_moves<'tcx>(\n     body: &Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-    let mut builder = MoveDataBuilder::new(body, tcx);\n+    let mut builder = MoveDataBuilder::new(body, tcx, param_env);\n \n     builder.gather_args();\n \n@@ -411,20 +419,67 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_move(&mut self, place: &Place<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, place);\n \n-        let path = match self.move_path_for(place) {\n-            Ok(path) | Err(MoveError::UnionMove { path }) => path,\n-            Err(error @ MoveError::IllegalMove { .. }) => {\n-                self.builder.errors.push((place.clone(), error));\n-                return;\n+        if let [\n+            ref base @ ..,\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+        ] = **place.projection {\n+            // Split `Subslice` patterns into the corresponding list of\n+            // `ConstIndex` patterns. This is done to ensure that all move paths\n+            // are disjoint, which is expected by drop elaboration.\n+            let base_place = Place {\n+                base: place.base.clone(),\n+                projection: self.builder.tcx.intern_place_elems(base),\n+            };\n+            let base_path = match self.move_path_for(&base_place) {\n+                Ok(path) => path,\n+                Err(MoveError::UnionMove { path }) => {\n+                    self.record_move(place, path);\n+                    return;\n+                }\n+                Err(error @ MoveError::IllegalMove { .. }) => {\n+                    self.builder.errors.push((base_place, error));\n+                    return;\n+                }\n+            };\n+            let base_ty = base_place.ty(self.builder.body, self.builder.tcx).ty;\n+            let len: u32 = match base_ty.kind {\n+                ty::Array(_, size) => {\n+                    let length = size.eval_usize(self.builder.tcx, self.builder.param_env);\n+                    length.try_into().expect(\n+                        \"slice pattern of array with more than u32::MAX elements\"\n+                    )\n+                }\n+                _ => bug!(\"from_end: false slice pattern of non-array type\"),\n+            };\n+            for offset in from..to {\n+                let elem = ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length: len,\n+                    from_end: false,\n+                };\n+                let path = self.add_move_path(\n+                    base_path,\n+                    &elem,\n+                    |tcx| tcx.mk_place_elem(base_place.clone(), elem),\n+                );\n+                self.record_move(place, path);\n             }\n-        };\n-        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n+        } else {\n+            match self.move_path_for(place) {\n+                Ok(path) | Err(MoveError::UnionMove { path }) => self.record_move(place, path),\n+                Err(error @ MoveError::IllegalMove { .. }) => {\n+                    self.builder.errors.push((place.clone(), error));\n+                }\n+            };\n+        }\n+    }\n \n+    fn record_move(&mut self, place: &Place<'tcx>, path: MovePathIndex) {\n+        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n         debug!(\n             \"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n             self.loc, place, move_out, path\n         );\n-\n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }"}, {"sha": "89ef9b245ce8f55f848cd0492c0e5871c2cb3ce0", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,6 +1,6 @@\n use core::slice::Iter;\n use rustc::mir::*;\n-use rustc::ty::{Ty, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt, ParamEnv};\n use rustc::util::nodemap::FxHashMap;\n use rustc_index::vec::{Enumerated, Idx, IndexVec};\n use smallvec::SmallVec;\n@@ -318,8 +318,9 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn gather_moves(\n         body: &Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n     ) -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-        builder::gather_moves(body, tcx)\n+        builder::gather_moves(body, tcx, param_env)\n     }\n \n     /// For the move path `mpi`, returns the root local variable (if any) that starts the path."}, {"sha": "42fbfeca3f05d5fe5166140d7bc0520979bdf9af", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -451,9 +451,15 @@ where\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n         to: u64,\n+        from_end: bool,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n-        assert!(from <= len - to);\n+        let actual_to = if from_end {\n+            assert!(from <= len - to);\n+            len - to\n+        } else {\n+            to\n+        };\n \n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n@@ -464,7 +470,7 @@ where\n         };\n \n         // Compute meta and new layout\n-        let inner_len = len - to - from;\n+        let inner_len = actual_to - from;\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n@@ -528,8 +534,8 @@ where\n                 self.mplace_field(base, index)?\n             }\n \n-            Subslice { from, to } =>\n-                self.mplace_subslice(base, u64::from(from), u64::from(to))?,\n+            Subslice { from, to, from_end } =>\n+                self.mplace_subslice(base, u64::from(from), u64::from(to), from_end)?,\n         })\n     }\n "}, {"sha": "1cacf1f3b0a578fe6961a6b8e559246a51263c07", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n \n         let def_id = src.def_id();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n-        let move_data = match MoveData::gather_moves(body, tcx) {\n+        let move_data = match MoveData::gather_moves(body, tcx, param_env) {\n             Ok(move_data) => move_data,\n             Err(_) => bug!(\"No `move_errors` should be allowed in MIR borrowck\"),\n         };\n@@ -234,12 +234,11 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n \n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path> {\n         dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n-            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false } => {\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                debug_assert!(size == *min_length, \"min_length should be exact for arrays\");\n+                assert!(!from_end, \"from_end should not be used for array element ConstantIndex\");\n                 *offset == index\n             }\n-            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true } => {\n-                size - offset == index\n-            }\n             _ => false,\n         })\n     }"}, {"sha": "2e1a08a022472c6fbc684e89a7a3ea60d50025fd", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -35,7 +35,6 @@ pub mod copy_prop;\n pub mod const_prop;\n pub mod generator;\n pub mod inline;\n-pub mod uniform_array_move_out;\n pub mod uninhabited_enum_branching;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n@@ -229,7 +228,6 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n-        &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n     body.ensure_predecessors();\n     tcx.alloc_steal_mir(body)\n@@ -294,7 +292,6 @@ fn run_optimization_passes<'tcx>(\n         // Optimizations begin.\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n         &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n-        &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n \n         // Lowering generator control-flow and variables"}, {"sha": "4345fc66bb95e8c73ee321cb858803d699493147", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(body, tcx).unwrap();\n+        let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n         let flow_inits ="}, {"sha": "71dd405386aa7b25b677b415edc2f2a589cabdeb", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "removed", "additions": 0, "deletions": 381, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27d6f55f47e8875e71083a28ed84ea5a88e1b596/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=27d6f55f47e8875e71083a28ed84ea5a88e1b596", "patch": "@@ -1,381 +0,0 @@\n-// This pass converts move out from array by Subslice and\n-// ConstIndex{.., from_end: true} to ConstIndex move out(s) from begin\n-// of array. It allows detect error by mir borrowck and elaborate\n-// drops for array without additional work.\n-//\n-// Example:\n-//\n-// let a = [ box 1,box 2, box 3];\n-// if b {\n-//  let [_a.., _] = a;\n-// } else {\n-//  let [.., _b] = a;\n-// }\n-//\n-//  mir statement _10 = move _2[:-1]; replaced by:\n-//  StorageLive(_12);\n-//  _12 = move _2[0 of 3];\n-//  StorageLive(_13);\n-//  _13 = move _2[1 of 3];\n-//  _10 = [move _12, move _13]\n-//  StorageDead(_12);\n-//  StorageDead(_13);\n-//\n-//  and mir statement _11 = move _2[-1 of 1]; replaced by:\n-//  _11 = move _2[2 of 3];\n-//\n-// FIXME: integrate this transformation to the mir build\n-\n-use rustc::ty;\n-use rustc::ty::TyCtxt;\n-use rustc::mir::*;\n-use rustc::mir::visit::{Visitor, PlaceContext, NonUseContext};\n-use rustc_index::vec::{IndexVec};\n-use crate::transform::{MirPass, MirSource};\n-use crate::util::patch::MirPatch;\n-\n-pub struct UniformArrayMoveOut;\n-\n-impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n-        let param_env = tcx.param_env(src.def_id());\n-        {\n-            let read_only_cache = read_only!(body);\n-            let mut visitor\n-                = UniformArrayMoveOutVisitor{ body, patch: &mut patch, tcx, param_env};\n-            visitor.visit_body(read_only_cache);\n-        }\n-        patch.apply(body);\n-    }\n-}\n-\n-struct UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    patch: &'a mut MirPatch<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self,\n-                    dst_place: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let &[ref proj_base @ .., elem] = src_place.projection.as_ref() {\n-                if let ProjectionElem::ConstantIndex{offset: _,\n-                                                     min_length: _,\n-                                                     from_end: false} = elem {\n-                    // no need to transformation\n-                } else {\n-                    let place_ty =\n-                        Place::ty_from(&src_place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Array(item_ty, const_size) = place_ty.kind {\n-                        if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n-                            assert!(size <= u32::max_value() as u64,\n-                                    \"uniform array move out doesn't supported\n-                                     for array bigger then u32\");\n-                            self.uniform(\n-                                location,\n-                                dst_place,\n-                                &src_place.base,\n-                                &src_place.projection,\n-                                item_ty,\n-                                size as u32,\n-                            );\n-                        }\n-                    }\n-\n-                }\n-            }\n-        }\n-        self.super_assign(dst_place, rvalue, location)\n-    }\n-}\n-\n-impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn uniform(&mut self,\n-               location: Location,\n-               dst_place: &Place<'tcx>,\n-               base: &PlaceBase<'tcx>,\n-               proj: &[PlaceElem<'tcx>],\n-               item_ty: &'tcx ty::TyS<'tcx>,\n-               size: u32) {\n-        if let [proj_base @ .., elem] = proj {\n-            match elem {\n-                // uniforms statements like_10 = move _2[:-1];\n-                ProjectionElem::Subslice{from, to} => {\n-                    self.patch.make_nop(location);\n-                    let temps : Vec<_> = (*from..(size-*to)).map(|i| {\n-                        let temp =\n-                            self.patch.new_temp(item_ty, self.body.source_info(location).span);\n-                        self.patch.add_statement(location, StatementKind::StorageLive(temp));\n-\n-                        let mut projection = proj_base.to_vec();\n-                        projection.push(ProjectionElem::ConstantIndex {\n-                            offset: i,\n-                            min_length: size,\n-                            from_end: false,\n-                        });\n-                        self.patch.add_assign(\n-                            location,\n-                            Place::from(temp),\n-                            Rvalue::Use(Operand::Move(Place {\n-                                base: base.clone(),\n-                                projection: self.tcx.intern_place_elems(&projection),\n-                            })),\n-                        );\n-                        temp\n-                    }).collect();\n-                    self.patch.add_assign(\n-                        location,\n-                        dst_place.clone(),\n-                        Rvalue::Aggregate(\n-                            box AggregateKind::Array(item_ty),\n-                            temps.iter().map(\n-                                |x| Operand::Move(Place::from(*x))\n-                            ).collect()\n-                        )\n-                    );\n-                    for temp in temps {\n-                        self.patch.add_statement(location, StatementKind::StorageDead(temp));\n-                    }\n-                }\n-                // uniforms statements like _11 = move _2[-1 of 1];\n-                ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n-                    self.patch.make_nop(location);\n-\n-                    let mut projection = proj_base.to_vec();\n-                    projection.push(ProjectionElem::ConstantIndex {\n-                        offset: size - offset,\n-                        min_length: size,\n-                        from_end: false,\n-                    });\n-                    self.patch.add_assign(\n-                        location,\n-                        dst_place.clone(),\n-                        Rvalue::Use(Operand::Move(Place {\n-                            base: base.clone(),\n-                            projection: self.tcx.intern_place_elems(&projection),\n-                        })),\n-                    );\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-// Restore Subslice move out after analysis\n-// Example:\n-//\n-//  next statements:\n-//   StorageLive(_12);\n-//   _12 = move _2[0 of 3];\n-//   StorageLive(_13);\n-//   _13 = move _2[1 of 3];\n-//   _10 = [move _12, move _13]\n-//   StorageDead(_12);\n-//   StorageDead(_13);\n-//\n-// replaced by _10 = move _2[:-1];\n-\n-pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n-    tcx: TyCtxt<'tcx>\n-}\n-\n-impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n-        let param_env = tcx.param_env(src.def_id());\n-        {\n-            let read_only_cache = read_only!(body);\n-            let mut visitor = RestoreDataCollector {\n-                locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n-                candidates: vec![],\n-            };\n-            visitor.visit_body(read_only_cache);\n-\n-            for candidate in &visitor.candidates {\n-                let statement = &body[candidate.block].statements[candidate.statement_index];\n-                if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n-                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n-                        let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(place) = item {\n-                                if let Some(local) = place.as_local() {\n-                                    let local_use = &visitor.locals_use[local];\n-                                    let opt_index_and_place =\n-                                        Self::try_get_item_source(local_use, body);\n-                                    // each local should be used twice:\n-                                    //  in assign and in aggregate statements\n-                                    if local_use.use_count == 2 && opt_index_and_place.is_some() {\n-                                        let (index, src_place) = opt_index_and_place.unwrap();\n-                                        return Some((local_use, index, src_place));\n-                                    }\n-                                }\n-                            }\n-                            None\n-                        }).collect();\n-\n-                        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n-                        let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = Place::ty_from(\n-                                src_place.base,\n-                                src_place.projection,\n-                                &**body,\n-                                tcx\n-                            ).ty;\n-                            if let ty::Array(_, ref size_o) = src_ty.kind {\n-                                size_o.try_eval_usize(tcx, param_env)\n-                            } else {\n-                                None\n-                            }\n-                        });\n-                        let restore_subslice = RestoreSubsliceArrayMoveOut { tcx };\n-                        restore_subslice\n-                            .check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n-                    }\n-                }\n-            }\n-        }\n-        patch.apply(body);\n-    }\n-}\n-\n-impl RestoreSubsliceArrayMoveOut<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        RestoreSubsliceArrayMoveOut { tcx }\n-    }\n-\n-    // Checks that source has size, all locals are inited from same source place and\n-    // indices is an integer interval. If all checks pass do the replacent.\n-    // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n-    fn check_and_patch(&self,\n-                       candidate: Location,\n-                       items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n-                       opt_size: Option<u64>,\n-                       patch: &mut MirPatch<'tcx>,\n-                       dst_place: &Place<'tcx>) {\n-        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n-\n-        if opt_size.is_some() && items.iter().all(\n-            |l| l.is_some() && l.unwrap().2 == opt_src_place.unwrap()) {\n-            let src_place = opt_src_place.unwrap();\n-\n-            let indices: Vec<_> = items.iter().map(|x| x.unwrap().1).collect();\n-            for i in 1..indices.len() {\n-                if indices[i - 1] + 1 != indices[i] {\n-                    return;\n-                }\n-            }\n-\n-            let min = *indices.first().unwrap();\n-            let max = *indices.last().unwrap();\n-\n-            for item in items {\n-                let locals_use = item.unwrap().0;\n-                patch.make_nop(locals_use.alive.unwrap());\n-                patch.make_nop(locals_use.dead.unwrap());\n-                patch.make_nop(locals_use.first_use.unwrap());\n-            }\n-            patch.make_nop(candidate);\n-            let size = opt_size.unwrap() as u32;\n-\n-            let mut projection = src_place.projection.to_vec();\n-            projection.push(ProjectionElem::Subslice { from: min, to: size - max - 1 });\n-            patch.add_assign(\n-                candidate,\n-                dst_place.clone(),\n-                Rvalue::Use(Operand::Move(Place {\n-                    base: src_place.base.clone(),\n-                    projection: self.tcx.intern_place_elems(&projection),\n-                })),\n-            );\n-        }\n-    }\n-\n-    fn try_get_item_source<'a>(local_use: &LocalUse,\n-                               body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n-        if let Some(location) = local_use.first_use {\n-            let block = &body[location.block];\n-            if block.statements.len() > location.statement_index {\n-                let statement = &block.statements[location.statement_index];\n-                if let StatementKind::Assign(\n-                    box(place, Rvalue::Use(Operand::Move(src_place)))\n-                ) = &statement.kind {\n-                    if let (Some(_), PlaceRef {\n-                        base: _,\n-                        projection: &[.., ProjectionElem::ConstantIndex {\n-                            offset, min_length: _, from_end: false\n-                        }],\n-                    }) = (place.as_local(), src_place.as_ref()) {\n-                        if let StatementKind::Assign(\n-                            box(_, Rvalue::Use(Operand::Move(place)))\n-                        ) = &statement.kind {\n-                            if let PlaceRef {\n-                                base,\n-                                projection: &[ref proj_base @ .., _],\n-                            } = place.as_ref() {\n-                                return Some((offset, PlaceRef {\n-                                    base,\n-                                    projection: proj_base,\n-                                }))\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-struct LocalUse {\n-    alive: Option<Location>,\n-    dead: Option<Location>,\n-    use_count: u32,\n-    first_use: Option<Location>,\n-}\n-\n-impl LocalUse {\n-    pub fn new() -> Self {\n-        LocalUse{alive: None, dead: None, use_count: 0, first_use: None}\n-    }\n-}\n-\n-struct RestoreDataCollector {\n-    locals_use: IndexVec<Local, LocalUse>,\n-    candidates: Vec<Location>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n-    fn visit_assign(&mut self,\n-                    place: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        if let Rvalue::Aggregate(box AggregateKind::Array(_), _) = *rvalue {\n-            self.candidates.push(location);\n-        }\n-        self.super_assign(place, rvalue, location)\n-    }\n-\n-    fn visit_local(&mut self,\n-                   local: &Local,\n-                   context: PlaceContext,\n-                   location: Location) {\n-        let local_use = &mut self.locals_use[*local];\n-        match context {\n-            PlaceContext::NonUse(NonUseContext::StorageLive) => local_use.alive = Some(location),\n-            PlaceContext::NonUse(NonUseContext::StorageDead) => local_use.dead = Some(location),\n-            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {}\n-            _ => {\n-                local_use.use_count += 1;\n-                if local_use.first_use.is_none() {\n-                    local_use.first_use = Some(location);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "ea7c1e7ccd0cb24e3ee95ce553394ac1ec789a6a", "filename": "src/test/mir-opt/const_prop/return_place.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -21,9 +21,6 @@ fn main() {\n //         _0 = move (_1.0: u32);\n //         return;\n //     }\n-//     bb2 (cleanup): {\n-//         resume;\n-//     }\n // }\n // END rustc.add.ConstProp.before.mir\n // START rustc.add.ConstProp.after.mir\n@@ -38,9 +35,6 @@ fn main() {\n //         _0 = const 4u32;\n //         return;\n //     }\n-//     bb2 (cleanup): {\n-//         resume;\n-//     }\n // }\n // END rustc.add.ConstProp.after.mir\n // START rustc.add.PreCodegen.before.mir"}, {"sha": "f2e1864096ea974f9290d9f44a149ad1195197dd", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -18,58 +18,12 @@ fn main() {\n \n // END RUST SOURCE\n \n-// START rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//      _6 = move _1[-1 of 1];\n-//      _0 = ();\n-// END rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n-\n-// START rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n-//     StorageLive(_6);\n+// START rustc.move_out_from_end.mir_map.0.mir\n //      _6 = move _1[1 of 2];\n-//      nop;\n //      _0 = ();\n-// END rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n-\n-// START rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//      _6 = move _1[0:];\n-// END rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n-\n-// START rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n-//     StorageLive(_6);\n-//     StorageLive(_7);\n-//     _7 = move _1[0 of 2];\n-//     StorageLive(_8);\n-//     _8 = move _1[1 of 2];\n-//     _6 = [move _7, move _8];\n-//     StorageDead(_7);\n-//     StorageDead(_8);\n-//     nop;\n-//     _0 = ();\n-// END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n-\n-// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//     StorageLive(_7);\n-//     _7 = move _1[0 of 2];\n-//     StorageLive(_8);\n-//     _8 = move _1[1 of 2];\n-//     _6 = [move _7, move _8];\n-//     StorageDead(_7);\n-//     StorageDead(_8);\n-//     _0 = ();\n-// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+// END rustc.move_out_from_end.mir_map.0.mir\n \n-// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n-//     StorageLive(_6);\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     _6 = move _1[0:];\n-//     nop;\n-//     nop;\n-//     nop;\n+// START rustc.move_out_by_subslice.mir_map.0.mir\n+//     _6 = move _1[0..2];\n //     _0 = ();\n-// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n+// END rustc.move_out_by_subslice.mir_map.0.mir"}, {"sha": "8f274cf73cb0ec3b05f889717d050f228c1328b8", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,69 @@\n+// check-pass\n+\n+#![feature(slice_patterns)]\n+\n+fn array() -> [(String, String); 3] {\n+    Default::default()\n+}\n+\n+// Const Index + Const Index\n+\n+fn move_out_from_begin_and_one_from_end() {\n+    let a = array();\n+    let [_, _, _x] = a;\n+    let [.., _y, _] = a;\n+}\n+\n+fn move_out_from_begin_field_and_end_field() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n+    let [.., (_, _y)] = a;\n+}\n+\n+// Const Index + Slice\n+\n+fn move_out_by_const_index_and_subslice() {\n+    let a = array();\n+    let [_x, _, _] = a;\n+    let [_, _y @ ..] = a;\n+}\n+\n+fn move_out_by_const_index_end_and_subslice() {\n+    let a = array();\n+    let [.., _x] = a;\n+    let [_y @ .., _] = a;\n+}\n+\n+fn move_out_by_const_index_field_and_subslice() {\n+    let a = array();\n+    let [(_x, _), _, _] = a;\n+    let [_, _y @ ..] = a;\n+}\n+\n+fn move_out_by_const_index_end_field_and_subslice() {\n+    let a = array();\n+    let [.., (_x, _)] = a;\n+    let [_y @ .., _] = a;\n+}\n+\n+fn move_out_by_const_subslice_and_index_field() {\n+    let a = array();\n+    let [_, _y @ ..] = a;\n+    let [(_x, _), _, _] = a;\n+}\n+\n+fn move_out_by_const_subslice_and_end_index_field() {\n+    let a = array();\n+    let [_y @ .., _] = a;\n+    let [.., (_x, _)] = a;\n+}\n+\n+// Slice + Slice\n+\n+fn move_out_by_subslice_and_subslice() {\n+    let a = array();\n+    let [x @ .., _, _] = a;\n+    let [_, _y @ ..] = a;\n+}\n+\n+fn main() {}"}, {"sha": "57ce2417570b0985f9787fbb4b1a601bce7441a3", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,69 @@\n+// check-pass\n+\n+#![feature(slice_patterns)]\n+\n+fn array() -> [(String, String); 3] {\n+    Default::default()\n+}\n+\n+// Const Index + Const Index\n+\n+fn move_out_from_begin_and_one_from_end() {\n+    let a = array();\n+    let [_, _, _x] = a;\n+    let [.., ref _y, _] = a;\n+}\n+\n+fn move_out_from_begin_field_and_end_field() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n+    let [.., (_, ref _y)] = a;\n+}\n+\n+// Const Index + Slice\n+\n+fn move_out_by_const_index_and_subslice() {\n+    let a = array();\n+    let [_x, _, _] = a;\n+    let [_, ref _y @ ..] = a;\n+}\n+\n+fn move_out_by_const_index_end_and_subslice() {\n+    let a = array();\n+    let [.., _x] = a;\n+    let [ref _y @ .., _] = a;\n+}\n+\n+fn move_out_by_const_index_field_and_subslice() {\n+    let a = array();\n+    let [(_x, _), _, _] = a;\n+    let [_, ref _y @ ..] = a;\n+}\n+\n+fn move_out_by_const_index_end_field_and_subslice() {\n+    let a = array();\n+    let [.., (_x, _)] = a;\n+    let [ref _y @ .., _] = a;\n+}\n+\n+fn move_out_by_const_subslice_and_index_field() {\n+    let a = array();\n+    let [_, _y @ ..] = a;\n+    let [(ref _x, _), _, _] = a;\n+}\n+\n+fn move_out_by_const_subslice_and_end_index_field() {\n+    let a = array();\n+    let [_y @ .., _] = a;\n+    let [.., (ref _x, _)] = a;\n+}\n+\n+// Slice + Slice\n+\n+fn move_out_by_subslice_and_subslice() {\n+    let a = array();\n+    let [x @ .., _, _] = a;\n+    let [_, ref _y @ ..] = a;\n+}\n+\n+fn main() {}"}, {"sha": "778beefbf2c85d59767e01cdc117e7d0ac2aa7ae", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,99 @@\n+#![feature(slice_patterns)]\n+\n+fn array() -> [(String, String); 3] {\n+    Default::default()\n+}\n+\n+// Const Index + Const Index\n+\n+fn move_out_from_begin_and_end() {\n+    let a = array();\n+    let [_, _, _x] = a;\n+    let [.., ref _y] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_from_begin_field_and_end() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n+    let [.., ref _y] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_from_begin_field_and_end_field() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n+    let [.., (ref _y, _)] = a; //~ ERROR [E0382]\n+}\n+\n+// Const Index + Slice\n+\n+fn move_out_by_const_index_and_subslice() {\n+    let a = array();\n+    let [_x, _, _] = a;\n+    let [ref _y @ .., _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_end_and_subslice() {\n+    let a = array();\n+    let [.., _x] = a;\n+    let [_, _, ref _y @ ..] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_field_and_subslice() {\n+    let a = array();\n+    let [(_x, _), _, _] = a;\n+    let [ref _y @ .., _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_end_field_and_subslice() {\n+    let a = array();\n+    let [.., (_x, _)] = a;\n+    let [_, _, ref _y @ ..] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_subslice_and_const_index_field() {\n+    let a = array();\n+    let [_y @ .., _, _] = a;\n+    let [(ref _x, _), _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_subslice_and_const_index_end_field() {\n+    let a = array();\n+    let [_, _, _y @ ..] = a;\n+    let [.., (ref _x, _)] = a; //~ ERROR [E0382]\n+}\n+\n+// Slice + Slice\n+\n+fn move_out_by_subslice_and_subslice() {\n+    let a = array();\n+    let [x @ .., _] = a;\n+    let [_, ref _y @ ..] = a; //~ ERROR [E0382]\n+}\n+\n+// Move + Assign\n+\n+fn move_out_and_assign_end() {\n+    let mut a = array();\n+    let [_, _, _x] = a;\n+    a[2] = Default::default(); //~ ERROR [E0382]\n+}\n+\n+fn move_out_and_assign_end_field() {\n+    let mut a = array();\n+    let [_, _, (_x, _)] = a;\n+    a[2].1 = Default::default(); //~ ERROR [E0382]\n+}\n+\n+fn move_out_slice_and_assign_end() {\n+    let mut a = array();\n+    let [_, _, _x @ ..] = a;\n+    a[0] = Default::default(); //~ ERROR [E0382]\n+}\n+\n+fn move_out_slice_and_assign_end_field() {\n+    let mut a = array();\n+    let [_, _, _x @ ..] = a;\n+    a[0].1 = Default::default(); //~ ERROR [E0382]\n+}\n+\n+fn main() {}"}, {"sha": "2a7b89132c1b7a71c31d74a5be8b3870a7198e42", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,143 @@\n+error[E0382]: borrow of moved value: `a[..]`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:12:14\n+   |\n+LL |     let [_, _, _x] = a;\n+   |                -- value moved here\n+LL |     let [.., ref _y] = a;\n+   |              ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a[..]`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:18:14\n+   |\n+LL |     let [_, _, (_x, _)] = a;\n+   |                 -- value moved here\n+LL |     let [.., ref _y] = a;\n+   |              ^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a[..].0`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:24:15\n+   |\n+LL |     let [_, _, (_x, _)] = a;\n+   |                 -- value moved here\n+LL |     let [.., (ref _y, _)] = a;\n+   |               ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:32:10\n+   |\n+LL |     let [_x, _, _] = a;\n+   |          -- value moved here\n+LL |     let [ref _y @ .., _, _] = a;\n+   |          ^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:38:16\n+   |\n+LL |     let [.., _x] = a;\n+   |              -- value moved here\n+LL |     let [_, _, ref _y @ ..] = a;\n+   |                ^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:44:10\n+   |\n+LL |     let [(_x, _), _, _] = a;\n+   |           -- value moved here\n+LL |     let [ref _y @ .., _, _] = a;\n+   |          ^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:50:16\n+   |\n+LL |     let [.., (_x, _)] = a;\n+   |               -- value moved here\n+LL |     let [_, _, ref _y @ ..] = a;\n+   |                ^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a[..]`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:56:11\n+   |\n+LL |     let [_y @ .., _, _] = a;\n+   |          ------- value moved here\n+LL |     let [(ref _x, _), _, _] = a;\n+   |           ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a[..]`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:62:15\n+   |\n+LL |     let [_, _, _y @ ..] = a;\n+   |                ------- value moved here\n+LL |     let [.., (ref _x, _)] = a;\n+   |               ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:70:13\n+   |\n+LL |     let [x @ .., _] = a;\n+   |          ------ value moved here\n+LL |     let [_, ref _y @ ..] = a;\n+   |             ^^^^^^^^^^^ value borrowed here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:78:5\n+   |\n+LL |     let [_, _, _x] = a;\n+   |                -- value moved here\n+LL |     a[2] = Default::default();\n+   |     ^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:84:5\n+   |\n+LL |     let [_, _, (_x, _)] = a;\n+   |                 -- value moved here\n+LL |     a[2].1 = Default::default();\n+   |     ^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:90:5\n+   |\n+LL |     let [_, _, _x @ ..] = a;\n+   |                ------- value moved here\n+LL |     a[0] = Default::default();\n+   |     ^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array-use.rs:96:5\n+   |\n+LL |     let [_, _, _x @ ..] = a;\n+   |                ------- value moved here\n+LL |     a[0].1 = Default::default();\n+   |     ^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "f9d3f6f2c0724e9adcf5d2aabc0ddc0c627f5569", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,16 +1,73 @@\n-#![feature(box_syntax)]\n #![feature(slice_patterns)]\n \n+fn array() -> [(String, String); 3] {\n+    Default::default()\n+}\n+\n+// Const Index + Const Index\n+\n fn move_out_from_begin_and_end() {\n-    let a = [box 1, box 2];\n-    let [_, _x] = a;\n+    let a = array();\n+    let [_, _, _x] = a;\n+    let [.., _y] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_from_begin_field_and_end() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n     let [.., _y] = a; //~ ERROR [E0382]\n }\n \n+fn move_out_from_begin_field_and_end_field() {\n+    let a = array();\n+    let [_, _, (_x, _)] = a;\n+    let [.., (_y, _)] = a; //~ ERROR [E0382]\n+}\n+\n+// Const Index + Slice\n+\n fn move_out_by_const_index_and_subslice() {\n-    let a = [box 1, box 2];\n-    let [_x, _] = a;\n-    let [_y @ ..] = a; //~ ERROR [E0382]\n+    let a = array();\n+    let [_x, _, _] = a;\n+    let [_y @ .., _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_end_and_subslice() {\n+    let a = array();\n+    let [.., _x] = a;\n+    let [_, _, _y @ ..] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_field_and_subslice() {\n+    let a = array();\n+    let [(_x, _), _, _] = a;\n+    let [_y @ .., _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_end_field_and_subslice() {\n+    let a = array();\n+    let [.., (_x, _)] = a;\n+    let [_, _, _y @ ..] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_subslice_and_const_index_field() {\n+    let a = array();\n+    let [_y @ .., _, _] = a;\n+    let [(_x, _), _, _] = a; //~ ERROR [E0382]\n+}\n+\n+fn move_out_by_subslice_and_const_index_end_field() {\n+    let a = array();\n+    let [_, _, _y @ ..] = a;\n+    let [.., (_x, _)] = a; //~ ERROR [E0382]\n+}\n+\n+// Slice + Slice\n+\n+fn move_out_by_subslice_and_subslice() {\n+    let a = array();\n+    let [x @ .., _] = a;\n+    let [_, _y @ ..] = a; //~ ERROR [E0382]\n }\n \n fn main() {}"}, {"sha": "08134a2a323e73410c934ca248499f71eff33ff3", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.stderr", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,23 +1,103 @@\n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array.rs:7:14\n+  --> $DIR/borrowck-move-out-from-array.rs:12:14\n    |\n-LL |     let [_, _x] = a;\n-   |             -- value moved here\n+LL |     let [_, _, _x] = a;\n+   |                -- value moved here\n LL |     let [.., _y] = a;\n    |              ^^ value used here after move\n    |\n-   = note: move occurs because `a[..]` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array.rs:13:10\n+  --> $DIR/borrowck-move-out-from-array.rs:18:14\n    |\n-LL |     let [_x, _] = a;\n+LL |     let [_, _, (_x, _)] = a;\n+   |                 -- value moved here\n+LL |     let [.., _y] = a;\n+   |              ^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a[..].0`\n+  --> $DIR/borrowck-move-out-from-array.rs:24:15\n+   |\n+LL |     let [_, _, (_x, _)] = a;\n+   |                 -- value moved here\n+LL |     let [.., (_y, _)] = a;\n+   |               ^^ value used here after move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array.rs:32:10\n+   |\n+LL |     let [_x, _, _] = a;\n    |          -- value moved here\n-LL |     let [_y @ ..] = a;\n-   |          ^^^^^^^ value used here after move\n+LL |     let [_y @ .., _, _] = a;\n+   |          ^^^^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array.rs:38:16\n+   |\n+LL |     let [.., _x] = a;\n+   |              -- value moved here\n+LL |     let [_, _, _y @ ..] = a;\n+   |                ^^^^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array.rs:44:10\n+   |\n+LL |     let [(_x, _), _, _] = a;\n+   |           -- value moved here\n+LL |     let [_y @ .., _, _] = a;\n+   |          ^^^^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array.rs:50:16\n+   |\n+LL |     let [.., (_x, _)] = a;\n+   |               -- value moved here\n+LL |     let [_, _, _y @ ..] = a;\n+   |                ^^^^^^^ value used here after partial move\n+   |\n+   = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a[..].0`\n+  --> $DIR/borrowck-move-out-from-array.rs:56:11\n+   |\n+LL |     let [_y @ .., _, _] = a;\n+   |          ------- value moved here\n+LL |     let [(_x, _), _, _] = a;\n+   |           ^^ value used here after move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a[..].0`\n+  --> $DIR/borrowck-move-out-from-array.rs:62:15\n+   |\n+LL |     let [_, _, _y @ ..] = a;\n+   |                ------- value moved here\n+LL |     let [.., (_x, _)] = a;\n+   |               ^^ value used here after move\n+   |\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/borrowck-move-out-from-array.rs:70:13\n+   |\n+LL |     let [x @ .., _] = a;\n+   |          ------ value moved here\n+LL |     let [_, _y @ ..] = a;\n+   |             ^^^^^^^ value used here after partial move\n    |\n-   = note: move occurs because `a[..]` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+   = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "7d91a212647233da54b45bb2da896856ef64250e", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array-no-overlap.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,66 @@\n+// check-pass\n+\n+#![feature(slice_patterns)]\n+\n+fn nop(_s: &[& i32]) {}\n+fn nop_subslice(_s: &[i32]) {}\n+\n+fn const_index_ok(s: &mut [i32; 4]) {\n+    let [ref first, ref second, _, ref fourth, ..] = *s;\n+    let [_, _, ref mut third, ..] = *s;\n+    nop(&[first, second, third, fourth]);\n+}\n+\n+fn const_index_from_end_ok(s: &mut [i32; 4]) {\n+    let [.., ref fourth, ref third, _, ref first] = *s;\n+    let [.., ref mut second, _] = *s;\n+    nop(&[first, second, third, fourth]);\n+}\n+\n+fn const_index_mixed(s: &mut [i32; 6]) {\n+    let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n+\n+    let [ref mut from_begin0, ..] = *s;\n+    nop(&[from_begin0, from_end1, from_end3, from_end4]);\n+    let [_, ref mut from_begin1, ..] = *s;\n+    nop(&[from_begin1, from_end1, from_end3, from_end4]);\n+\n+    let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s;\n+\n+    let [.., ref mut from_end1] = *s;\n+    nop(&[from_begin0, from_begin1, from_begin3, from_end1]);\n+    let [.., ref mut from_end2, _] = *s;\n+    nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n+    let [.., ref mut from_end4, _, _, _] = *s;\n+    nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n+}\n+\n+fn const_index_and_subslice_ok(s: &mut [i32; 4]) {\n+    let [ref first, ref second, ..] = *s;\n+    let [_, _, ref mut tail @ ..] = *s;\n+    nop(&[first, second]);\n+    nop_subslice(tail);\n+}\n+\n+fn const_index_and_subslice_from_end_ok(s: &mut [i32; 4]) {\n+    let [.., ref second, ref first] = *s;\n+    let [ref mut tail @ .., _, _] = *s;\n+    nop(&[first, second]);\n+    nop_subslice(tail);\n+}\n+\n+fn subslices(s: &mut [i32; 4]) {\n+    let [_, _, ref s1 @ ..] = *s;\n+    let [ref mut s2 @ .., _, _] = *s;\n+    nop_subslice(s1);\n+    nop_subslice(s2);\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    const_index_ok(&mut v);\n+    const_index_from_end_ok(&mut v);\n+    const_index_and_subslice_ok(&mut v);\n+    const_index_and_subslice_from_end_ok(&mut v);\n+    subslices(&mut v);\n+}"}, {"sha": "f03a2ab8fa8e456c53111e94bc6a52df144f495c", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,60 @@\n+#![feature(slice_patterns)]\n+\n+fn nop(_s: &[& i32]) {}\n+fn nop_subslice(_s: &[i32]) {}\n+\n+fn const_index_err(s: &mut [i32; 4]) {\n+    let [ref first, ref second, ..] = *s;\n+    let [_, ref mut  second2, ref mut third, ..] = *s; //~ERROR\n+    nop(&[first, second, second2, third]);\n+}\n+\n+fn const_index_from_end_err(s: &mut [i32; 4]) {\n+    let [.., ref fourth, ref third, _, ref first] = *s;\n+    let [.., ref mut third2, _, _] = *s; //~ERROR\n+    nop(&[first, third, third2, fourth]);\n+}\n+\n+fn const_index_mixed(s: &mut [i32; 6]) {\n+    let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n+\n+    let [_, _, ref mut from_begin2, ..] = *s; //~ERROR\n+    nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+    let [_, _, _, ref mut from_begin3, ..] = *s; //~ERROR\n+    nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+\n+    let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s;\n+\n+    let [.., ref mut from_end3, _,  _] = *s; //~ERROR\n+    nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+}\n+\n+fn const_index_and_subslice_err(s: &mut [i32; 4]) {\n+    let [ref first, ref second, ..] = *s;\n+    let [_, ref mut tail @ ..] = *s; //~ERROR\n+    nop(&[first, second]);\n+    nop_subslice(tail);\n+}\n+\n+fn const_index_and_subslice_from_end_err(s: &mut [i32; 4]) {\n+    let [.., ref second, ref first] = *s;\n+    let [ref mut tail @ .., _] = *s; //~ERROR\n+    nop(&[first, second]);\n+    nop_subslice(tail);\n+}\n+\n+fn subslices_overlap(s: &mut [i32; 4]) {\n+    let [_,  ref s1 @ ..] = *s;\n+    let [ref mut s2 @ .., _, _] = *s; //~ERROR\n+    nop_subslice(s1);\n+    nop_subslice(s2);\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    const_index_err(&mut v);\n+    const_index_from_end_err(&mut v);\n+    const_index_and_subslice_err(&mut v);\n+    const_index_and_subslice_from_end_err(&mut v);\n+    subslices_overlap(&mut v);\n+}"}, {"sha": "e50e7eb3e22301b5c98be9a1776b2c588830242d", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,86 @@\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:8:13\n+   |\n+LL |     let [ref first, ref second, ..] = *s;\n+   |                     ---------- immutable borrow occurs here\n+LL |     let [_, ref mut  second2, ref mut third, ..] = *s;\n+   |             ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[first, second, second2, third]);\n+   |                  ------ immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:14:14\n+   |\n+LL |     let [.., ref fourth, ref third, _, ref first] = *s;\n+   |                          --------- immutable borrow occurs here\n+LL |     let [.., ref mut third2, _, _] = *s;\n+   |              ^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[first, third, third2, fourth]);\n+   |                  ----- immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:21:16\n+   |\n+LL |     let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n+   |                 ------------- immutable borrow occurs here\n+LL | \n+LL |     let [_, _, ref mut from_begin2, ..] = *s;\n+   |                ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+   |                                              --------- immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:23:19\n+   |\n+LL |     let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n+   |                                ------------- immutable borrow occurs here\n+...\n+LL |     let [_, _, _, ref mut from_begin3, ..] = *s;\n+   |                   ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+   |                                   --------- immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:28:14\n+   |\n+LL |     let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s;\n+   |                                               --------------- immutable borrow occurs here\n+LL | \n+LL |     let [.., ref mut from_end3, _,  _] = *s;\n+   |              ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+   |                                     ----------- immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:34:13\n+   |\n+LL |     let [ref first, ref second, ..] = *s;\n+   |                     ---------- immutable borrow occurs here\n+LL |     let [_, ref mut tail @ ..] = *s;\n+   |             ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[first, second]);\n+   |                  ------ immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:41:10\n+   |\n+LL |     let [.., ref second, ref first] = *s;\n+   |              ---------- immutable borrow occurs here\n+LL |     let [ref mut tail @ .., _] = *s;\n+   |          ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop(&[first, second]);\n+   |                  ------ immutable borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:48:10\n+   |\n+LL |     let [_,  ref s1 @ ..] = *s;\n+   |              ----------- immutable borrow occurs here\n+LL |     let [ref mut s2 @ .., _, _] = *s;\n+   |          ^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |     nop_subslice(s1);\n+   |                  -- immutable borrow later used here\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "e69071f87720b9fb68046671a5b477c96458b9e7", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice-no-overlap.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -0,0 +1,61 @@\n+// check-pass\n+\n+#![feature(slice_patterns)]\n+\n+fn nop(_s: &[& i32]) {}\n+fn nop_subslice(_s: &[i32]) {}\n+\n+fn const_index_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, _, ref fourth, ..] = *s {\n+        if let [_, _, ref mut third, ..] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref fourth, ref third, _, ref first] = *s {\n+        if let [.., ref mut second, _] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_mixed(s: &mut [i32]) {\n+    if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+        if let [ref mut from_begin0, ..] = *s {\n+            nop(&[from_begin0, from_end1, from_end3, from_end4]);\n+        }\n+    }\n+    if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+        if let [.., ref mut from_end1] = *s {\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end1]);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, _, ref mut tail @ ..] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref second, ref first] = *s {\n+        if let [ref mut tail @ .., _, _] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    const_index_ok(&mut v);\n+    const_index_from_end_ok(&mut v);\n+    const_index_and_subslice_ok(&mut v);\n+    const_index_and_subslice_from_end_ok(&mut v);\n+}"}, {"sha": "2ef98741dc35aeacf6188e3a20caefbe505b38fa", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.rs", "status": "renamed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,18 +1,8 @@\n-//compile-flags: -Z borrowck=mir\n-\n #![feature(slice_patterns)]\n \n fn nop(_s: &[& i32]) {}\n fn nop_subslice(_s: &[i32]) {}\n \n-fn const_index_ok(s: &mut [i32]) {\n-    if let [ref first, ref second, _, ref fourth, ..] = *s {\n-        if let [_, _, ref mut third, ..] = *s {\n-            nop(&[first, second, third, fourth]);\n-        }\n-    }\n-}\n-\n fn const_index_err(s: &mut [i32]) {\n     if let [ref first, ref second, ..] = *s {\n         if let [_, ref mut  second2, ref mut third, ..] = *s { //~ERROR\n@@ -21,14 +11,6 @@ fn const_index_err(s: &mut [i32]) {\n     }\n }\n \n-fn const_index_from_end_ok(s: &mut [i32]) {\n-    if let [.., ref fourth, ref third, _, ref first] = *s {\n-        if let [.., ref mut second, _] = *s {\n-            nop(&[first, second, third, fourth]);\n-        }\n-    }\n-}\n-\n fn const_index_from_end_err(s: &mut [i32]) {\n     if let [.., ref fourth, ref third, _, ref first] = *s {\n         if let [.., ref mut third2, _, _] = *s { //~ERROR\n@@ -39,9 +21,6 @@ fn const_index_from_end_err(s: &mut [i32]) {\n \n fn const_index_mixed(s: &mut [i32]) {\n     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n-        if let [ref mut from_begin0, ..] = *s {\n-            nop(&[from_begin0, from_end1, from_end3, from_end4]);\n-        }\n         if let [_, ref mut from_begin1, ..] = *s { //~ERROR\n             nop(&[from_begin1, from_end1, from_end3, from_end4]);\n         }\n@@ -53,9 +32,6 @@ fn const_index_mixed(s: &mut [i32]) {\n         }\n     }\n     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n-        if let [.., ref mut from_end1] = *s {\n-            nop(&[from_begin0, from_begin1, from_begin3, from_end1]);\n-        }\n         if let [.., ref mut from_end2, _] = *s { //~ERROR\n             nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n         }\n@@ -68,15 +44,6 @@ fn const_index_mixed(s: &mut [i32]) {\n     }\n }\n \n-fn const_index_and_subslice_ok(s: &mut [i32]) {\n-    if let [ref first, ref second, ..] = *s {\n-        if let [_, _, ref mut tail @ ..] = *s {\n-            nop(&[first, second]);\n-            nop_subslice(tail);\n-        }\n-    }\n-}\n-\n fn const_index_and_subslice_err(s: &mut [i32]) {\n     if let [ref first, ref second, ..] = *s {\n         if let [_, ref mut tail @ ..] = *s { //~ERROR\n@@ -86,15 +53,6 @@ fn const_index_and_subslice_err(s: &mut [i32]) {\n     }\n }\n \n-fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n-    if let [.., ref second, ref first] = *s {\n-        if let [ref mut tail @ .., _, _] = *s {\n-            nop(&[first, second]);\n-            nop_subslice(tail);\n-        }\n-    }\n-}\n-\n fn const_index_and_subslice_from_end_err(s: &mut [i32]) {\n     if let [.., ref second, ref first] = *s {\n         if let [ref mut tail @ .., _] = *s { //~ERROR\n@@ -115,13 +73,9 @@ fn subslices(s: &mut [i32]) {\n \n fn main() {\n     let mut v = [1,2,3,4];\n-    const_index_ok(&mut v);\n     const_index_err(&mut v);\n-    const_index_from_end_ok(&mut v);\n     const_index_from_end_err(&mut v);\n-    const_index_and_subslice_ok(&mut v);\n     const_index_and_subslice_err(&mut v);\n-    const_index_and_subslice_from_end_ok(&mut v);\n     const_index_and_subslice_from_end_err(&mut v);\n     subslices(&mut v);\n }", "previous_filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.rs"}, {"sha": "b6f5ac64b20612fcff81373d3453289dd6a1f7f1", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.stderr", "status": "renamed", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:18:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:8:20\n    |\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n@@ -9,7 +9,7 @@ LL |             nop(&[first, second, second2, third]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:34:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:16:21\n    |\n LL |     if let [.., ref fourth, ref third, _, ref first] = *s {\n    |                             --------- immutable borrow occurs here\n@@ -19,18 +19,17 @@ LL |             nop(&[first, third, third2, fourth]);\n    |                          ----- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:45:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:24:20\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                    ------------- immutable borrow occurs here\n-...\n LL |         if let [_, ref mut from_begin1, ..] = *s {\n    |                    ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[from_begin1, from_end1, from_end3, from_end4]);\n    |                                                      --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:48:23\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:27:23\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                                   ------------- immutable borrow occurs here\n@@ -41,7 +40,7 @@ LL |             nop(&[from_begin2, from_end1, from_end3, from_end4]);\n    |                                           --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:51:26\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:30:26\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                                   ------------- immutable borrow occurs here\n@@ -52,18 +51,17 @@ LL |             nop(&[from_begin3, from_end1, from_end3, from_end4]);\n    |                                           --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:59:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:35:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                                                  --------------- immutable borrow occurs here\n-...\n LL |         if let [.., ref mut from_end2, _] = *s {\n    |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n    |                                             ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:62:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:38:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                                                  --------------- immutable borrow occurs here\n@@ -74,7 +72,7 @@ LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n    |                                             ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:65:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:41:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                              --------------- immutable borrow occurs here\n@@ -85,7 +83,7 @@ LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n    |                                ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:82:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:49:20\n    |\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n@@ -95,7 +93,7 @@ LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:100:17\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:58:17\n    |\n LL |     if let [.., ref second, ref first] = *s {\n    |                 ---------- immutable borrow occurs here\n@@ -105,7 +103,7 @@ LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan.rs:109:17\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:67:17\n    |\n LL |     if let [_, _, _, ref s1 @ ..] = *s {\n    |                      ----------- immutable borrow occurs here", "previous_filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.stderr"}, {"sha": "0f0ec0ba460c8e91c339e1455a2270054c7c8504", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0abf7599023b71dd72b44f0165e86c040ee7ea/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=de0abf7599023b71dd72b44f0165e86c040ee7ea", "patch": "@@ -269,6 +269,28 @@ fn subslice_pattern_reassign(a: &Allocator) {\n     let[_, _y @ ..] = ar;\n }\n \n+fn index_field_mixed_ends(a: &Allocator) {\n+    let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n+    let[(_x, _), ..] = ar;\n+    let[(_, _y), _] = ar;\n+    let[_, (_, _w)] = ar;\n+    let[.., (_z, _)] = ar;\n+}\n+\n+fn subslice_mixed_min_lengths(a: &Allocator, c: i32) {\n+    let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n+    match c {\n+        0 => { let[_x, ..] = ar; }\n+        1 => { let[_x, _, ..] = ar; }\n+        2 => { let[_x, _] = ar; }\n+        3 => { let[(_x, _), _, ..] = ar; }\n+        4 => { let[.., (_x, _)] = ar; }\n+        5 => { let[.., (_x, _), _] = ar; }\n+        6 => { let [_y @ ..] = ar; }\n+        _ => { let [_y @ .., _] = ar; }\n+    }\n+}\n+\n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n     // Panic in the drop of `p` or `q` can leak\n     let exceptions = vec![8, 9];\n@@ -422,6 +444,16 @@ fn main() {\n     run_test(|a| slice_pattern_reassign(a));\n     run_test(|a| subslice_pattern_reassign(a));\n \n+    run_test(|a| index_field_mixed_ends(a));\n+    run_test(|a| subslice_mixed_min_lengths(a, 0));\n+    run_test(|a| subslice_mixed_min_lengths(a, 1));\n+    run_test(|a| subslice_mixed_min_lengths(a, 2));\n+    run_test(|a| subslice_mixed_min_lengths(a, 3));\n+    run_test(|a| subslice_mixed_min_lengths(a, 4));\n+    run_test(|a| subslice_mixed_min_lengths(a, 5));\n+    run_test(|a| subslice_mixed_min_lengths(a, 6));\n+    run_test(|a| subslice_mixed_min_lengths(a, 7));\n+\n     run_test(|a| {\n         panic_after_return(a);\n     });"}]}