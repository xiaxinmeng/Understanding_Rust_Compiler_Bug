{"sha": "2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNjA2YWU1ZjMxMzRmOTQwODBlYWVjODNhYzU4NjRkZTJmNmM2YTA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-01T20:13:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:49Z"}, "message": "add libuv error msg helpers.. flushing out windows tcp issue.", "tree": {"sha": "3dcc3b7225bef9fa24c7dee8a53e97a9bc3b5c8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dcc3b7225bef9fa24c7dee8a53e97a9bc3b5c8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "html_url": "https://github.com/rust-lang/rust/commit/2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c26cf7f96252aad623dd2ca688a8d9782fc57c5", "html_url": "https://github.com/rust-lang/rust/commit/2c26cf7f96252aad623dd2ca688a8d9782fc57c5"}], "stats": {"total": 93, "additions": 74, "deletions": 19}, "files": [{"sha": "4c4415437bcecf049ac4e4748a5d7cdc8886dfe2", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "patch": "@@ -360,6 +360,10 @@ native mod rustrt {\n     fn rust_uv_buf_init(base: *u8, len: libc::size_t)\n         -> uv_buf_t;\n     fn rust_uv_last_error(loop_handle: *libc::c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    fn rust_uv_strerror(err: *uv_err_t) -> *libc::c_char;\n+    // FIXME ref #2064\n+    fn rust_uv_err_name(err: *uv_err_t) -> *libc::c_char;\n     fn rust_uv_ip4_test_verify_port_val(++addr: sockaddr_in,\n                                         expected: libc::c_uint)\n         -> bool;\n@@ -484,10 +488,17 @@ mod direct {\n         ret rustrt::rust_uv_read_stop(stream as *libc::c_void);\n     }\n \n-    unsafe fn uv_last_error(loop_handle: *libc::c_void) -> uv_err_t {\n+    unsafe fn last_error(loop_handle: *libc::c_void) -> uv_err_t {\n         ret rustrt::rust_uv_last_error(loop_handle);\n     }\n \n+    unsafe fn strerror(err: *uv_err_t) -> *libc::c_char {\n+        ret rustrt::rust_uv_strerror(err);\n+    }\n+    unsafe fn err_name(err: *uv_err_t) -> *libc::c_char {\n+        ret rustrt::rust_uv_err_name(err);\n+    }\n+\n     unsafe fn async_init(loop_handle: *libc::c_void,\n                          async_handle: *uv_async_t,\n                          cb: *u8) -> libc::c_int {\n@@ -570,6 +581,15 @@ mod direct {\n     unsafe fn free_base_of_buf(buf: uv_buf_t) {\n         rustrt::rust_uv_free_base_of_buf(buf);\n     }\n+\n+    unsafe fn print_last_err_info(uv_loop: *libc::c_void) {\n+        let err = direct::last_error(uv_loop);\n+        let err_ptr = ptr::addr_of(err);\n+        let err_name = str::unsafe::from_c_str(direct::err_name(err_ptr));\n+        let err_msg = str::unsafe::from_c_str(direct::strerror(err_ptr));\n+        io::println(#fmt(\"LIBUV ERROR: name: %s msg: %s\",\n+                        err_name, err_msg));\n+    }\n }\n \n // public functions\n@@ -1145,9 +1165,10 @@ crust fn on_alloc_cb(handle: *libc::c_void,\n \n crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n                     ++buf: uv_buf_t) unsafe {\n+    io::println(#fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n     if (nread > 0) {\n         // we have data\n-        io::println(#fmt(\"read: data! nread: %d\", nread));\n+        io::println(#fmt(\"CLIENT read: data! nread: %d\", nread));\n         direct::read_stop(stream);\n         let client_data = direct::\n             get_data_for_uv_handle(stream as *libc::c_void)\n@@ -1170,18 +1191,18 @@ crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n     }\n     // when we're done\n     direct::free_base_of_buf(buf);\n-    io::println(\"exiting on_read_cb\");\n+    io::println(\"CLIENT exiting on_read_cb\");\n }\n \n crust fn on_write_complete_cb(write_req: *uv_write_t,\n                               status: libc::c_int) unsafe {\n-    io::println(#fmt(\"beginning on_write_complete_cb status: %d\",\n+    io::println(#fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n                      status as int));\n     let stream = direct::get_stream_handle_from_write_req(write_req);\n-    io::println(#fmt(\"on_write_complete_cb: tcp:%d write_handle:%d\",\n+    io::println(#fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n         stream as int, write_req as int));\n     let result = direct::read_start(stream, on_alloc_cb, on_read_cb);\n-    io::println(#fmt(\"ending on_write_complete_cb .. status: %d\",\n+    io::println(#fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n                      result as int));\n }\n \n@@ -1207,7 +1228,9 @@ crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n                          write_result as int));\n     }\n     else {\n-        io::println(\"non-zero status for on_connect_cb..\");\n+        let test_loop = direct::get_loop_for_uv_handle(stream as *libc::c_void);\n+        direct::print_last_err_info(test_loop);\n+        assert false;\n     }\n     io::println(\"finishing on_connect_cb\");\n }\n@@ -1286,12 +1309,12 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n }\n \n crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-    io::println(\"server stream closed, should exit loop...\");\n+    io::println(\"SERVER server stream closed, should exit loop...\");\n }\n \n crust fn client_stream_after_close_cb(handle: *libc::c_void)\n     unsafe {\n-    io::println(\"closed client stream, now server..\");\n+    io::println(\"SERVER: closed client stream, now closing server stream\");\n     let client_data = direct::get_data_for_uv_handle(\n         handle) as\n         *tcp_server_data;\n@@ -1305,7 +1328,7 @@ crust fn after_server_resp_write(req: *uv_write_t) unsafe {\n     let client_data = direct::get_data_for_uv_handle(\n         client_stream_ptr as *libc::c_void) as\n         *tcp_server_data;\n-    direct::read_stop(client_stream_ptr);\n+    io::println(\"SERVER: resp sent... closing client stream\");\n     direct::close(client_stream_ptr as *libc::c_void,\n                   client_stream_after_close_cb)\n }\n@@ -1315,30 +1338,42 @@ crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n                            ++buf: uv_buf_t) unsafe {\n     if (nread > 0) {\n         // we have data\n-        io::println(#fmt(\"read: data! nread: %d\", nread));\n+        io::println(#fmt(\"SERVER read: data! nread: %d\", nread));\n \n         // pull out the contents of the write from the client\n         let buf_base = direct::get_base_from_buf(buf);\n         let buf_len = direct::get_len_from_buf(buf);\n         let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n         let request_str = str::from_bytes(bytes);\n-        io::println(\"client req to follow\");\n-        io::println(request_str);\n-        io::println(\"end of client read\");\n \n         let client_data = direct::get_data_for_uv_handle(\n             client_stream_ptr as *libc::c_void) as *tcp_server_data;\n \n         let server_kill_msg = (*client_data).server_kill_msg;\n         let write_req = (*client_data).server_write_req;\n         if (str::contains(request_str, server_kill_msg)) {\n+            io::println(\"SERVER: client request contains server_kill_msg!\");\n+            io::println(\"SERVER: sending response to client\");\n+            direct::read_stop(client_stream_ptr);\n             let server_chan = *((*client_data).server_chan);\n             comm::send(server_chan, request_str);\n             let write_result = direct::write(\n                 write_req as *libc::c_void,\n                 client_stream_ptr as *libc::c_void,\n                 (*client_data).server_resp_buf,\n                 after_server_resp_write);\n+            io::println(#fmt(\"SERVER: resp write result: %d\",\n+                        write_result as int));\n+            if (write_result != 0i32) {\n+                io::println(\"non-zero result for server resp direct::write()\");\n+                direct::print_last_err_info(\n+                    direct::get_loop_for_uv_handle(client_stream_ptr\n+                        as *libc::c_void));\n+                assert false;\n+            }\n+        }\n+        else {\n+            io::println(\"SERVER: client req DOESNT contain server_kill_msg!\");\n         }\n     }\n     else if (nread == -1) {\n@@ -1351,7 +1386,7 @@ crust fn on_server_read_cb(client_stream_ptr: *uv_stream_t,\n     }\n     // when we're done\n     direct::free_base_of_buf(buf);\n-    io::println(\"exiting on_read_cb\");\n+    io::println(\"SERVER exiting on_read_cb\");\n }\n \n crust fn server_connection_cb(server_stream_ptr: *uv_stream_t,\n@@ -1414,6 +1449,10 @@ type async_handle_data = {\n     continue_chan: *comm::chan<bool>\n };\n \n+crust fn async_close_cb(handle: *libc::c_void) {\n+    io::println(\"SERVER: closing async cb...\");\n+}\n+\n crust fn continue_async_cb(async_handle: *uv_async_t,\n                            status: libc::c_int) unsafe {\n     // once we're in the body of this callback,\n@@ -1424,7 +1463,7 @@ crust fn continue_async_cb(async_handle: *uv_async_t,\n         async_handle as *libc::c_void) as *async_handle_data;\n     let continue_chan = *((*data).continue_chan);\n     comm::send(continue_chan, true);\n-    direct::close(async_handle as *libc::c_void, 0 as *u8);\n+    direct::close(async_handle as *libc::c_void, async_close_cb);\n }\n \n fn impl_uv_tcp_server(server_ip: str,\n@@ -1500,6 +1539,7 @@ fn impl_uv_tcp_server(server_ip: str,\n                     direct::async_send(continue_async_handle_ptr);\n                     // uv_run()\n                     direct::run(test_loop);\n+                    io::println(\"server uv::run() has returned\");\n                 }\n                 else {\n                     io::println(#fmt(\"uv_async_init failure: %d\",\n@@ -1530,7 +1570,8 @@ fn impl_uv_tcp_server(server_ip: str,\n #[test]\n #[ignore(cfg(target_os = \"freebsd\"))]\n fn test_uv_tcp_server_and_request() unsafe {\n-    let ip = \"0.0.0.0\";\n+    let bind_ip = \"0.0.0.0\";\n+    let request_ip = \"127.0.0.1\";\n     let port = 8888;\n     let kill_server_msg = \"does a dog have buddha nature?\";\n     let server_resp_msg = \"mu!\";\n@@ -1544,7 +1585,7 @@ fn test_uv_tcp_server_and_request() unsafe {\n     let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n     task::spawn_sched(task::manual_threads(1u)) {||\n-        impl_uv_tcp_server(ip, port,\n+        impl_uv_tcp_server(bind_ip, port,\n                            kill_server_msg,\n                            server_resp_msg,\n                            ptr::addr_of(server_chan),\n@@ -1557,7 +1598,7 @@ fn test_uv_tcp_server_and_request() unsafe {\n     io::println(\"received on continue port, set up tcp client\");\n \n     task::spawn_sched(task::manual_threads(1u)) {||\n-        impl_uv_tcp_request(ip, port,\n+        impl_uv_tcp_request(request_ip, port,\n                            kill_server_msg,\n                            ptr::addr_of(client_chan));\n     };"}, {"sha": "9d2bb5e826030b76e473fd530d8aaa4597bdeeb4", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "patch": "@@ -346,6 +346,18 @@ rust_uv_last_error(uv_loop_t* loop) {\n \treturn uv_last_error(loop);\n }\n \n+extern \"C\" const char*\n+rust_uv_strerror(uv_err_t* err_ptr) {\n+\tuv_err_t err = *err_ptr;\n+\treturn uv_strerror(err);\n+}\n+\n+extern \"C\" const char*\n+rust_uv_err_name(uv_err_t* err_ptr) {\n+\tuv_err_t err = *err_ptr;\n+\treturn uv_err_name(err);\n+}\n+\n extern \"C\" int\n rust_uv_write(uv_write_t* req, uv_stream_t* handle,\n \t\t\t  uv_buf_t* bufs, int buf_cnt,"}, {"sha": "bf51d67cd41cf7d79e3830627833fea8802d8567", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/2b606ae5f3134f94080eaec83ac5864de2f6c6a0/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=2b606ae5f3134f94080eaec83ac5864de2f6c6a0", "patch": "@@ -100,6 +100,8 @@ rust_uv_free\n rust_uv_tcp_init\n rust_uv_buf_init\n rust_uv_last_error\n+rust_uv_strerror\n+rust_uv_err_name\n rust_uv_ip4_test_verify_port_val\n rust_uv_ip4_addr\n rust_uv_tcp_connect"}]}