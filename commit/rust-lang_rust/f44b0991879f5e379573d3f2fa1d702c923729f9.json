{"sha": "f44b0991879f5e379573d3f2fa1d702c923729f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NGIwOTkxODc5ZjVlMzc5NTczZDNmMmZhMWQ3MDJjOTIzNzI5Zjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T18:50:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:24Z"}, "message": "rustc_trans: avoid working with sizes/offsets and alignments as integers.", "tree": {"sha": "93a7b1fb8ab257afc7891b2bbf055bce98610700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93a7b1fb8ab257afc7891b2bbf055bce98610700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f44b0991879f5e379573d3f2fa1d702c923729f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f44b0991879f5e379573d3f2fa1d702c923729f9", "html_url": "https://github.com/rust-lang/rust/commit/f44b0991879f5e379573d3f2fa1d702c923729f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f44b0991879f5e379573d3f2fa1d702c923729f9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9deea47c9605f77d3d595744753704bfd74c0dc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9deea47c9605f77d3d595744753704bfd74c0dc9", "html_url": "https://github.com/rust-lang/rust/commit/9deea47c9605f77d3d595744753704bfd74c0dc9"}], "stats": {"total": 1849, "additions": 863, "deletions": 986}, "files": [{"sha": "d83f7e661baa3b51c5ec8f4ac5018606cf08894b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 83, "deletions": 59, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -24,7 +24,7 @@ use std::fmt;\n use std::i64;\n use std::iter;\n use std::mem;\n-use std::ops::Deref;\n+use std::ops::{Deref, Add, Sub, Mul, AddAssign};\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -203,6 +203,18 @@ impl TargetDataLayout {\n             bits => bug!(\"ptr_sized_integer: unknown pointer bit size {}\", bits)\n         }\n     }\n+\n+    pub fn vector_align(&self, vec_size: Size) -> Align {\n+        for &(size, align) in &self.vector_align {\n+            if size == vec_size {\n+                return align;\n+            }\n+        }\n+        // Default to natural alignment, which is what LLVM does.\n+        // That is, use the size, rounded up to a power of 2.\n+        let align = vec_size.bytes().next_power_of_two();\n+        Align::from_bytes(align, align).unwrap()\n+    }\n }\n \n pub trait HasDataLayout: Copy {\n@@ -236,7 +248,8 @@ pub struct Size {\n \n impl Size {\n     pub fn from_bits(bits: u64) -> Size {\n-        Size::from_bytes((bits + 7) / 8)\n+        // Avoid potential overflow from `bits + 7`.\n+        Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n     }\n \n     pub fn from_bytes(bytes: u64) -> Size {\n@@ -261,6 +274,11 @@ impl Size {\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n+    pub fn is_abi_aligned(self, align: Align) -> bool {\n+        let mask = align.abi() - 1;\n+        self.bytes() & mask == 0\n+    }\n+\n     pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n@@ -278,8 +296,6 @@ impl Size {\n     pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n-        // Each Size is less than dl.obj_size_bound(), so the sum is\n-        // also less than 1 << 62 (and therefore can't overflow).\n         match self.bytes().checked_mul(count) {\n             Some(bytes) if bytes < dl.obj_size_bound() => {\n                 Some(Size::from_bytes(bytes))\n@@ -289,6 +305,46 @@ impl Size {\n     }\n }\n \n+// Panicking addition, subtraction and multiplication for convenience.\n+// Avoid during layout computation, return `LayoutError` instead.\n+\n+impl Add for Size {\n+    type Output = Size;\n+    fn add(self, other: Size) -> Size {\n+        // Each Size is less than 1 << 61, so the sum is\n+        // less than 1 << 62 (and therefore can't overflow).\n+        Size::from_bytes(self.bytes() + other.bytes())\n+    }\n+}\n+\n+impl Sub for Size {\n+    type Output = Size;\n+    fn sub(self, other: Size) -> Size {\n+        // Each Size is less than 1 << 61, so an underflow\n+        // would result in a value larger than 1 << 61,\n+        // which Size::from_bytes will catch for us.\n+        Size::from_bytes(self.bytes() - other.bytes())\n+    }\n+}\n+\n+impl Mul<u64> for Size {\n+    type Output = Size;\n+    fn mul(self, count: u64) -> Size {\n+        match self.bytes().checked_mul(count) {\n+            Some(bytes) => Size::from_bytes(bytes),\n+            None => {\n+                bug!(\"Size::mul: {} * {} doesn't fit in u64\", self.bytes(), count)\n+            }\n+        }\n+    }\n+}\n+\n+impl AddAssign for Size {\n+    fn add_assign(&mut self, other: Size) {\n+        *self = *self + other;\n+    }\n+}\n+\n /// Alignment of a type in bytes, both ABI-mandated and preferred.\n /// Each field is a power of two, giving the alignment a maximum\n /// value of 2^(2^8 - 1), which is limited by LLVM to a i32, with\n@@ -301,7 +357,8 @@ pub struct Align {\n \n impl Align {\n     pub fn from_bits(abi: u64, pref: u64) -> Result<Align, String> {\n-        Align::from_bytes((abi + 7) / 8, (pref + 7) / 8)\n+        Align::from_bytes(Size::from_bits(abi).bytes(),\n+                          Size::from_bits(pref).bytes())\n     }\n \n     pub fn from_bytes(abi: u64, pref: u64) -> Result<Align, String> {\n@@ -340,6 +397,14 @@ impl Align {\n         1 << self.pref\n     }\n \n+    pub fn abi_bits(self) -> u64 {\n+        self.abi() * 8\n+    }\n+\n+    pub fn pref_bits(self) -> u64 {\n+        self.pref() * 8\n+    }\n+\n     pub fn min(self, other: Align) -> Align {\n         Align {\n             abi: cmp::min(self.abi, other.abi),\n@@ -366,7 +431,7 @@ pub enum Integer {\n     I128,\n }\n \n-impl Integer {\n+impl<'a, 'tcx> Integer {\n     pub fn size(&self) -> Size {\n         match *self {\n             I1 => Size::from_bits(1),\n@@ -391,8 +456,7 @@ impl Integer {\n         }\n     }\n \n-    pub fn to_ty<'a, 'tcx>(&self, tcx: &TyCtxt<'a, 'tcx, 'tcx>,\n-                           signed: bool) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I1, false) => tcx.types.u8,\n             (I8, false) => tcx.types.u8,\n@@ -467,12 +531,12 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            repr: &ReprOptions,\n-                            min: i64,\n-                            max: i64)\n-                            -> (Integer, bool) {\n+    fn repr_discr(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                  ty: Ty<'tcx>,\n+                  repr: &ReprOptions,\n+                  min: i64,\n+                  max: i64)\n+                  -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u64\n@@ -898,16 +962,6 @@ impl<'a, 'tcx> Struct {\n         }\n         Ok(None)\n     }\n-\n-    pub fn over_align(&self) -> Option<u32> {\n-        let align = self.align.abi();\n-        let primitive_align = self.primitive_align.abi();\n-        if align > primitive_align {\n-            Some(align as u32)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n /// An untagged union.\n@@ -981,16 +1035,6 @@ impl<'a, 'tcx> Union {\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n-\n-    pub fn over_align(&self) -> Option<u32> {\n-        let align = self.align.abi();\n-        let primitive_align = self.primitive_align.abi();\n-        if align > primitive_align {\n-            Some(align as u32)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n /// The first half of a fat pointer.\n@@ -1607,9 +1651,8 @@ impl<'a, 'tcx> Layout {\n \n             FatPointer { metadata, .. } => {\n                 // Effectively a (ptr, meta) tuple.\n-                Pointer.size(dl).abi_align(metadata.align(dl))\n-                       .checked_add(metadata.size(dl), dl).unwrap()\n-                       .abi_align(self.align(dl))\n+                (Pointer.size(dl).abi_align(metadata.align(dl)) +\n+                 metadata.size(dl)).abi_align(self.align(dl))\n             }\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n@@ -1638,15 +1681,7 @@ impl<'a, 'tcx> Layout {\n                     None => bug!(\"Layout::align({:?}): {} * {} overflowed\",\n                                  self, elem_size.bytes(), count)\n                 };\n-                for &(size, align) in &dl.vector_align {\n-                    if size == vec_size {\n-                        return align;\n-                    }\n-                }\n-                // Default to natural alignment, which is what LLVM does.\n-                // That is, use the size, rounded up to a power of 2.\n-                let align = vec_size.bytes().next_power_of_two();\n-                Align::from_bytes(align, align).unwrap()\n+                dl.vector_align(vec_size)\n             }\n \n             FatPointer { metadata, .. } => {\n@@ -1666,26 +1701,15 @@ impl<'a, 'tcx> Layout {\n     }\n \n     /// Returns alignment before repr alignment is applied\n-    pub fn primitive_align(&self, dl: &TargetDataLayout) -> Align {\n+    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n         match *self {\n             Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n                 variant.primitive_align\n             },\n \n-            _ => self.align(dl)\n-        }\n-    }\n-\n-    /// Returns repr alignment if it is greater than the primitive alignment.\n-    pub fn over_align(&self, dl: &TargetDataLayout) -> Option<u32> {\n-        let align = self.align(dl);\n-        let primitive_align = self.primitive_align(dl);\n-        if align.abi() > primitive_align.abi() {\n-            Some(align.abi() as u32)\n-        } else {\n-            None\n+            _ => self.align(cx.data_layout())\n         }\n     }\n "}, {"sha": "48f8094f98d8777f0633ac3575fefa7306f373ac", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -1205,15 +1205,13 @@ extern \"C\" {\n     pub fn LLVMRustBuildAtomicLoad(B: BuilderRef,\n                                    PointerVal: ValueRef,\n                                    Name: *const c_char,\n-                                   Order: AtomicOrdering,\n-                                   Alignment: c_uint)\n+                                   Order: AtomicOrdering)\n                                    -> ValueRef;\n \n     pub fn LLVMRustBuildAtomicStore(B: BuilderRef,\n                                     Val: ValueRef,\n                                     Ptr: ValueRef,\n-                                    Order: AtomicOrdering,\n-                                    Alignment: c_uint)\n+                                    Order: AtomicOrdering)\n                                     -> ValueRef;\n \n     pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n@@ -1247,23 +1245,6 @@ extern \"C\" {\n \n     /// Creates target data from a target layout string.\n     pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Number of bytes clobbered when doing a Store to *T.\n-    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Distance between successive elements in an array of T. Includes ABI padding.\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n-\n-    /// Returns the preferred alignment of a type.\n-    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n-    /// Returns the minimum alignment of a type.\n-    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n-\n-    /// Computes the byte offset of the indexed struct element for a\n-    /// target.\n-    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                               StructTy: TypeRef,\n-                               Element: c_uint)\n-                               -> c_ulonglong;\n \n     /// Disposes target data.\n     pub fn LLVMDisposeTargetData(TD: TargetDataRef);"}, {"sha": "ffbc4f82bca9e02e62b92ca10a440590f7190056", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 88, "deletions": 50, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -30,17 +30,16 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use machine::llalign_of_min;\n use type_::Type;\n use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Layout, LayoutTyper, TyLayout, Size};\n+use rustc::ty::layout::{self, Align, Layout, Size, TyLayout};\n+use rustc::ty::layout::{HasDataLayout, LayoutTyper};\n use rustc_back::PanicStrategy;\n \n use libc::c_uint;\n-use std::cmp;\n use std::iter;\n \n pub use syntax::abi::Abi;\n@@ -108,8 +107,8 @@ impl ArgAttributes {\n         self\n     }\n \n-    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n-        self.dereferenceable_bytes = bytes;\n+    pub fn set_dereferenceable(&mut self, size: Size) -> &mut Self {\n+        self.dereferenceable_bytes = size.bytes();\n         self\n     }\n \n@@ -174,7 +173,32 @@ impl Reg {\n }\n \n impl Reg {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        let dl = ccx.data_layout();\n+        match self.kind {\n+            RegKind::Integer => {\n+                match self.size.bits() {\n+                    1 => dl.i1_align,\n+                    2...8 => dl.i8_align,\n+                    9...16 => dl.i16_align,\n+                    17...32 => dl.i32_align,\n+                    33...64 => dl.i64_align,\n+                    65...128 => dl.i128_align,\n+                    _ => bug!(\"unsupported integer: {:?}\", self)\n+                }\n+            }\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => dl.f32_align,\n+                    64 => dl.f64_align,\n+                    _ => bug!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => dl.vector_align(self.size)\n+        }\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(ccx, self.size.bits()),\n             RegKind::Float => {\n@@ -193,7 +217,7 @@ impl Reg {\n \n /// An argument passed entirely registers with the\n /// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n-#[derive(Copy, Clone)]\n+#[derive(Clone, Copy, Debug)]\n pub struct Uniform {\n     pub unit: Reg,\n \n@@ -216,7 +240,11 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        self.unit.align(ccx)\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         let llunit = self.unit.llvm_type(ccx);\n \n         if self.total <= self.unit.size {\n@@ -328,11 +356,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                     }\n \n                     // Keep track of the offset (without padding).\n-                    let size = field.size(ccx);\n-                    match unaligned_offset.checked_add(size, ccx) {\n-                        Some(offset) => unaligned_offset = offset,\n-                        None => return None\n-                    }\n+                    unaligned_offset += field.size(ccx);\n                 }\n \n                 // There needs to be no padding.\n@@ -387,6 +411,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n pub enum CastTarget {\n     Uniform(Uniform),\n     Pair(Reg, Reg)\n@@ -405,7 +430,28 @@ impl From<Uniform> for CastTarget {\n }\n \n impl CastTarget {\n-    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn size(&self, ccx: &CrateContext) -> Size {\n+        match *self {\n+            CastTarget::Uniform(u) => u.total,\n+            CastTarget::Pair(a, b) => {\n+                (a.size.abi_align(a.align(ccx)) + b.size)\n+                    .abi_align(self.align(ccx))\n+            }\n+        }\n+    }\n+\n+    pub fn align(&self, ccx: &CrateContext) -> Align {\n+        match *self {\n+            CastTarget::Uniform(u) => u.align(ccx),\n+            CastTarget::Pair(a, b) => {\n+                ccx.data_layout().aggregate_align\n+                    .max(a.align(ccx))\n+                    .max(b.align(ccx))\n+            }\n+        }\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n         match *self {\n             CastTarget::Uniform(u) => u.llvm_type(ccx),\n             CastTarget::Pair(a, b) => {\n@@ -426,11 +472,11 @@ impl CastTarget {\n pub struct ArgType<'tcx> {\n     kind: ArgKind,\n     pub layout: TyLayout<'tcx>,\n-    /// Coerced LLVM Type\n-    pub cast: Option<Type>,\n-    /// Dummy argument, which is emitted before the real argument\n-    pub pad: Option<Type>,\n-    /// LLVM attributes of argument\n+    /// Cast target, either a single uniform or a pair of registers.\n+    pub cast: Option<CastTarget>,\n+    /// Dummy argument, which is emitted before the real argument.\n+    pub pad: Option<Reg>,\n+    /// Attributes of argument.\n     pub attrs: ArgAttributes\n }\n \n@@ -451,14 +497,12 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         // Wipe old attributes, likely not valid through indirection.\n         self.attrs = ArgAttributes::default();\n \n-        let llarg_sz = self.layout.size(ccx).bytes();\n-\n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n         self.attrs.set(ArgAttribute::NoAlias)\n                   .set(ArgAttribute::NoCapture)\n-                  .set_dereferenceable(llarg_sz);\n+                  .set_dereferenceable(self.layout.size(ccx));\n \n         self.kind = ArgKind::Indirect;\n     }\n@@ -500,12 +544,12 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n     }\n \n-    pub fn cast_to<T: Into<CastTarget>>(&mut self, ccx: &CrateContext, target: T) {\n-        self.cast = Some(target.into().llvm_type(ccx));\n+    pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n+        self.cast = Some(target.into());\n     }\n \n-    pub fn pad_with(&mut self, ccx: &CrateContext, reg: Reg) {\n-        self.pad = Some(reg.llvm_type(ccx));\n+    pub fn pad_with(&mut self, reg: Reg) {\n+        self.pad = Some(reg);\n     }\n \n     pub fn is_indirect(&self) -> bool {\n@@ -533,16 +577,14 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n             let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n-            let llalign = self.layout.align(ccx).abi();\n-            base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n+            base::call_memcpy(bcx, dst, val, llsz, self.layout.align(ccx));\n         } else if let Some(ty) = self.cast {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let llalign = self.layout.align(ccx).abi();\n-                bcx.store(val, cast_dst, Some(llalign as u32));\n+                let cast_dst = bcx.pointercast(dst, ty.llvm_type(ccx).ptr_to());\n+                bcx.store(val, cast_dst, Some(self.layout.align(ccx)));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -559,8 +601,9 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty, \"abi_cast\", None);\n-                base::Lifetime::Start.call(bcx, llscratch);\n+                let llscratch = bcx.alloca(ty.llvm_type(ccx), \"abi_cast\", None);\n+                let scratch_size = ty.size(ccx);\n+                bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n                 bcx.store(val, llscratch, None);\n@@ -570,10 +613,9 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n                                   C_usize(ccx, self.layout.size(ccx).bytes()),\n-                                  cmp::min(self.layout.align(ccx).abi() as u32,\n-                                           llalign_of_min(ccx, ty)));\n+                                  self.layout.align(ccx).min(ty.align(ccx)));\n \n-                base::Lifetime::End.call(bcx, llscratch);\n+                bcx.lifetime_end(llscratch, scratch_size);\n             }\n         } else {\n             if self.layout.ty == ccx.tcx().types.bool {\n@@ -840,7 +882,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     // Replace newtypes with their inner-most type.\n                     if unit.size == size {\n                         // Needs a cast as we've unpacked a newtype.\n-                        arg.cast_to(ccx, unit);\n+                        arg.cast_to(unit);\n                         return;\n                     }\n \n@@ -850,7 +892,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                             // FIXME(eddyb) This should be using Uniform instead of a pair,\n                             // but the resulting [2 x float/double] breaks emscripten.\n                             // See https://github.com/kripken/emscripten-fastcomp/issues/178.\n-                            arg.cast_to(ccx, CastTarget::Pair(unit, unit));\n+                            arg.cast_to(CastTarget::Pair(unit, unit));\n                             return;\n                         }\n                     }\n@@ -862,7 +904,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n-                    arg.cast_to(ccx, Reg {\n+                    arg.cast_to(Reg {\n                         kind: RegKind::Integer,\n                         size\n                     });\n@@ -931,10 +973,10 @@ impl<'a, 'tcx> FnType<'tcx> {\n         } else if self.ret.is_indirect() {\n             llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n             Type::void(ccx)\n+        } else if let Some(cast) = self.ret.cast {\n+            cast.llvm_type(ccx)\n         } else {\n-            self.ret.cast.unwrap_or_else(|| {\n-                type_of::immediate_type_of(ccx, self.ret.layout.ty)\n-            })\n+            type_of::immediate_type_of(ccx, self.ret.layout.ty)\n         };\n \n         for arg in &self.args {\n@@ -943,15 +985,15 @@ impl<'a, 'tcx> FnType<'tcx> {\n             }\n             // add padding\n             if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty);\n+                llargument_tys.push(ty.llvm_type(ccx));\n             }\n \n             let llarg_ty = if arg.is_indirect() {\n                 arg.memory_ty(ccx).ptr_to()\n+            } else if let Some(cast) = arg.cast {\n+                cast.llvm_type(ccx)\n             } else {\n-                arg.cast.unwrap_or_else(|| {\n-                    type_of::immediate_type_of(ccx, arg.layout.ty)\n-                })\n+                type_of::immediate_type_of(ccx, arg.layout.ty)\n             };\n \n             llargument_tys.push(llarg_ty);\n@@ -998,7 +1040,3 @@ impl<'a, 'tcx> FnType<'tcx> {\n         }\n     }\n }\n-\n-pub fn align_up_to(off: u64, a: u64) -> u64 {\n-    (off + a - 1) / a * a\n-}"}, {"sha": "b5b90753553f35ac92129e3f187965201e884021", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -42,10 +42,9 @@\n //!   taken to it, implementing them for Rust seems difficult.\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, Align, HasDataLayout, LayoutTyper, Size};\n \n use context::CrateContext;\n-use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n@@ -134,9 +133,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             // Use alignment-sized ints to fill all the union storage.\n-            let size = variants.stride().bytes();\n-            let align = variants.align.abi();\n-            let fill = union_fill(cx, size, align);\n+            let fill = union_fill(cx, variants.stride(), variants.align);\n             match name {\n                 None => {\n                     Type::struct_(cx, &[fill], variants.packed)\n@@ -159,22 +156,18 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // So we start with the discriminant, pad it up to the alignment with\n             // more of its own type, then use alignment-sized ints to get the rest\n             // of the size.\n-            let size = size.bytes();\n-            let align = align.abi();\n-            let primitive_align = primitive_align.abi();\n-            assert!(align <= ::std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n-            let padded_discr_size = roundup(discr_size, align as u32);\n-            let variant_part_size = size-padded_discr_size;\n-            let variant_fill = union_fill(cx, variant_part_size, primitive_align);\n+            let padded_discr_size = discr.size().abi_align(align);\n+            let variant_part_size = size - padded_discr_size;\n \n-            assert_eq!(machine::llalign_of_min(cx, variant_fill), primitive_align as u32);\n-            assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n-            let fields: Vec<Type> =\n-                [discr_ty,\n-                 Type::array(&discr_ty, (padded_discr_size - discr_size)/discr_size),\n-                 variant_fill].iter().cloned().collect();\n+            // Ensure discr_ty can fill pad evenly\n+            assert_eq!(padded_discr_size.bytes() % discr_size, 0);\n+            let fields = [\n+                discr_ty,\n+                Type::array(&discr_ty, padded_discr_size.bytes() / discr_size - 1),\n+                union_fill(cx, variant_part_size, primitive_align)\n+            ];\n             match name {\n                 None => {\n                     Type::struct_(cx, &fields, false)\n@@ -190,17 +183,19 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n-    assert_eq!(size%align, 0);\n-    assert_eq!(align.count_ones(), 1, \"Alignment must be a power fof 2. Got {}\", align);\n-    let align_units = size/align;\n-    let layout_align = layout::Align::from_bytes(align, align).unwrap();\n-    if let Some(ity) = layout::Integer::for_abi_align(cx, layout_align) {\n-        Type::array(&Type::from_integer(cx, ity), align_units)\n+fn union_fill(cx: &CrateContext, size: Size, align: Align) -> Type {\n+    let abi_align = align.abi();\n+    let elem_ty = if let Some(ity) = layout::Integer::for_abi_align(cx, align) {\n+        Type::from_integer(cx, ity)\n     } else {\n-        Type::array(&Type::vector(&Type::i32(cx), align/4),\n-                    align_units)\n-    }\n+        let vec_align = cx.data_layout().vector_align(Size::from_bytes(abi_align));\n+        assert_eq!(vec_align.abi(), abi_align);\n+        Type::vector(&Type::i32(cx), abi_align / 4)\n+    };\n+\n+    let size = size.bytes();\n+    assert_eq!(size % abi_align, 0);\n+    Type::array(&elem_ty, size / abi_align)\n }\n \n // Lookup `Struct::memory_index` and double it to account for padding\n@@ -231,7 +226,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut first_field = true;\n-    let mut min_offset = 0;\n+    let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(field_count * 2);\n     let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n         (i, match t.sty {\n@@ -249,48 +244,47 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.tcx().normalize_associated_type(&ty)\n             },\n             _ => bug!()\n-        }, variant.offsets[i as usize].bytes())\n+        }, variant.offsets[i as usize])\n     });\n     for (index, ty, target_offset) in field_iter {\n-        assert!(target_offset >= min_offset);\n-        let padding_bytes = target_offset - min_offset;\n+        debug!(\"struct_llfields: {} ty: {} offset: {:?} target_offset: {:?}\",\n+            index, ty, offset, target_offset);\n+        assert!(target_offset >= offset);\n+        let padding = target_offset - offset;\n         if first_field {\n-            debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n-                index, ty, min_offset, target_offset);\n-            assert_eq!(padding_bytes, 0);\n+            assert_eq!(padding.bytes(), 0);\n             first_field = false;\n         } else {\n-            result.push(Type::array(&Type::i8(cx), padding_bytes));\n-            debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n-                index, ty, padding_bytes, min_offset, target_offset);\n+            result.push(Type::array(&Type::i8(cx), padding.bytes()));\n+            debug!(\"    padding before: {:?}\", padding);\n         }\n         let llty = type_of::in_memory_type_of(cx, ty);\n         result.push(llty);\n         let layout = cx.layout_of(ty);\n         if variant.packed {\n-            assert_eq!(padding_bytes, 0);\n+            assert_eq!(padding.bytes(), 0);\n         } else {\n             let field_align = layout.align(cx);\n             assert!(field_align.abi() <= variant.align.abi(),\n                     \"non-packed type has field with larger align ({}): {:#?}\",\n                     field_align.abi(), variant);\n         }\n-        let target_size = layout.size(&cx.tcx().data_layout).bytes();\n-        min_offset = target_offset + target_size;\n+        let target_size = layout.size(&cx.tcx().data_layout);\n+        offset = target_offset + target_size;\n     }\n     if variant.sized && field_count > 0 {\n-        if variant.stride().bytes() < min_offset {\n-            bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n-            min_offset);\n+        if offset > variant.stride() {\n+            bug!(\"variant: {:?} stride: {:?} offset: {:?}\",\n+                variant, variant.stride(), offset);\n         }\n-        let padding_bytes = variant.stride().bytes() - min_offset;\n-        debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n-               padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n-        result.push(Type::array(&Type::i8(cx), padding_bytes));\n+        let padding = variant.stride() - offset;\n+        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} min_size: {:?} stride: {:?}\",\n+            padding, offset, variant.min_size, variant.stride());\n+        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n         assert!(result.len() == (field_count * 2));\n     } else {\n-        debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n-               min_offset, variant.min_size.bytes(), variant.stride().bytes());\n+        debug!(\"struct_llfields: offset: {:?} min_size: {:?} stride: {:?}\",\n+               offset, variant.min_size, variant.stride());\n     }\n \n     result\n@@ -310,7 +304,3 @@ pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n         assert!(min <= discr || discr <= max)\n     }\n }\n-\n-// FIXME this utility routine should be somewhere more general\n-#[inline]\n-fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }"}, {"sha": "98ad6a54bd1f563e0621b46f62444e25d35c8fa1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -40,6 +40,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::Align;\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n@@ -55,15 +56,14 @@ use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_u64, C_undef, C_array};\n+use common::{C_struct_in_context, C_undef, C_array};\n use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n use context::{self, LocalCrateContext, SharedCrateContext};\n use debuginfo;\n use declare;\n-use machine;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -489,50 +489,19 @@ pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n     }\n }\n \n-pub enum Lifetime { Start, End }\n-\n-impl Lifetime {\n-    // If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-    // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-    // and the intrinsic for `lt` and passes them to `emit`, which is in\n-    // charge of generating code to call the passed intrinsic on whatever\n-    // block of generated code is targeted for the intrinsic.\n-    //\n-    // If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-    // off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    pub fn call(self, b: &Builder, ptr: ValueRef) {\n-        if b.ccx.sess().opts.optimize == config::OptLevel::No {\n-            return;\n-        }\n-\n-        let size = machine::llsize_of_alloc(b.ccx, val_ty(ptr).element_type());\n-        if size == 0 {\n-            return;\n-        }\n-\n-        let lifetime_intrinsic = b.ccx.get_intrinsic(match self {\n-            Lifetime::Start => \"llvm.lifetime.start\",\n-            Lifetime::End => \"llvm.lifetime.end\"\n-        });\n-\n-        let ptr = b.pointercast(ptr, Type::i8p(b.ccx));\n-        b.call(lifetime_intrinsic, &[C_u64(b.ccx, size), ptr], None);\n-    }\n-}\n-\n-pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n-                               dst: ValueRef,\n-                               src: ValueRef,\n-                               n_bytes: ValueRef,\n-                               align: u32) {\n+pub fn call_memcpy(b: &Builder,\n+                   dst: ValueRef,\n+                   src: ValueRef,\n+                   n_bytes: ValueRef,\n+                   align: Align) {\n     let ccx = b.ccx;\n     let ptr_width = &ccx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n     let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n-    let align = C_i32(ccx, align as i32);\n+    let align = C_i32(ccx, align.abi() as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n@@ -542,11 +511,11 @@ pub fn memcpy_ty<'a, 'tcx>(\n     dst: ValueRef,\n     src: ValueRef,\n     t: Ty<'tcx>,\n-    align: Option<u32>,\n+    align: Option<Align>,\n ) {\n     let ccx = bcx.ccx;\n \n-    let size = ccx.size_of(t);\n+    let size = ccx.size_of(t).bytes();\n     if size == 0 {\n         return;\n     }"}, {"sha": "c8d8984122fddd19ff1abf1746b269c6ab17d49f", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -15,12 +15,12 @@ use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use common::*;\n-use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n-use rustc::session::Session;\n+use rustc::ty::layout::{Align, Size};\n+use rustc::session::{config, Session};\n \n use std::borrow::Cow;\n use std::ffi::CString;\n@@ -487,15 +487,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n+    pub fn alloca(&self, ty: Type, name: &str, align: Option<Align>) -> ValueRef {\n         let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         builder.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<u32>) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Option<Align>) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                       name.as_ptr())\n             };\n             if let Some(align) = align {\n-                llvm::LLVMSetAlignment(alloca, align as c_uint);\n+                llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n             }\n             alloca\n         }\n@@ -519,12 +519,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+    pub fn load(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             if let Some(align) = align {\n-                llvm::LLVMSetAlignment(load, align as c_uint);\n+                llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n             }\n             load\n         }\n@@ -539,20 +539,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering) -> ValueRef {\n+    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering, align: Align) -> ValueRef {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n-            let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order,\n-                                          align as c_uint)\n+            let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n+            llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n+            load\n         }\n     }\n \n \n     pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n                              hi: u64, signed: llvm::Bool,\n-                             align: Option<u32>) -> ValueRef {\n+                             align: Option<Align>) -> ValueRef {\n         let value = self.load(ptr, align);\n \n         unsafe {\n@@ -571,7 +570,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn load_nonnull(&self, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+    pub fn load_nonnull(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n         let value = self.load(ptr, align);\n         unsafe {\n             llvm::LLVMSetMetadata(value, llvm::MD_nonnull as c_uint,\n@@ -581,15 +580,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             if let Some(align) = align {\n-                llvm::LLVMSetAlignment(store, align as c_uint);\n+                llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n             }\n             store\n         }\n@@ -607,14 +606,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n+                        order: AtomicOrdering, align: Align) {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n-            let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n-            let align = llalign_of_pref(self.ccx, ty.element_type());\n-            llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order, align as c_uint);\n+            let store = llvm::LLVMRustBuildAtomicStore(self.llbuilder, val, ptr, order);\n+            llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n         }\n     }\n \n@@ -1233,4 +1232,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         return Cow::Owned(casted_args);\n     }\n+\n+    pub fn lifetime_start(&self, ptr: ValueRef, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n+    }\n+\n+    pub fn lifetime_end(&self, ptr: ValueRef, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n+    }\n+\n+    /// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+    /// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+    /// and the intrinsic for `lt` and passes them to `emit`, which is in\n+    /// charge of generating code to call the passed intrinsic on whatever\n+    /// block of generated code is targetted for the intrinsic.\n+    ///\n+    /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+    /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n+        if self.ccx.sess().opts.optimize == config::OptLevel::No {\n+            return;\n+        }\n+\n+        let size = size.bytes();\n+        if size == 0 {\n+            return;\n+        }\n+\n+        let lifetime_intrinsic = self.ccx.get_intrinsic(intrinsic);\n+\n+        let ptr = self.pointercast(ptr, Type::i8p(self.ccx));\n+        self.call(lifetime_intrinsic, &[C_u64(self.ccx, size), ptr], None);\n+    }\n }"}, {"sha": "b021a06072595f34f4cfbbb87eba305cac41da82", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -44,7 +44,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n     let size = ret.layout.size(ccx);\n@@ -60,7 +60,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n@@ -75,7 +75,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n     let size = arg.layout.size(ccx);\n@@ -91,7 +91,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit,\n             total: size\n         });"}, {"sha": "370a950617a1bf1ca5e2ae843301c2bdb97fe342", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -47,7 +47,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n \n     if vfp {\n         if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-            ret.cast_to(ccx, uniform);\n+            ret.cast_to(uniform);\n             return;\n         }\n     }\n@@ -62,7 +62,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         } else {\n             Reg::i32()\n         };\n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n@@ -79,14 +79,14 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n \n     if vfp {\n         if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-            arg.cast_to(ccx, uniform);\n+            arg.cast_to(uniform);\n             return;\n         }\n     }\n \n     let align = arg.layout.align(ccx).abi();\n     let total = arg.layout.size(ccx);\n-    arg.cast_to(ccx, Uniform {\n+    arg.cast_to(Uniform {\n         unit: if align <= 4 { Reg::i32() } else { Reg::i64() },\n         total\n     });"}, {"sha": "047caa431c545bb607f3e9c63b6c2b0bef644ee6", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -21,7 +21,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n             let size = ret.layout.size(ccx);\n             if unit.size == size {\n-                ret.cast_to(ccx, Uniform {\n+                ret.cast_to(Uniform {\n                     unit,\n                     total: size\n                 });"}, {"sha": "baab70367419a06a56e00aaeb4700a90fecdaebc", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n     let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "1cb63e72fb9be322daf0c875c69188a42c988c17", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect(ccx);\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n     let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i64(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i64());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i64());\n         }\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 8 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "df320fb00abe2a613223dd0f0460903bed2817d5", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -8,46 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{align_up_to, FnType, ArgType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-use std::cmp;\n+use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n     let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "9a9d6f8d0ac465e7e94a20eb5a6bf36bfc04f536", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -67,7 +67,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n \n@@ -84,7 +84,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n@@ -101,7 +101,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n \n@@ -124,7 +124,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         },\n     };\n \n-    arg.cast_to(ccx, Uniform {\n+    arg.cast_to(Uniform {\n         unit,\n         total\n     });"}, {"sha": "ffe2940a0284f4f035376dc39cfb2d1e8f03e5aa", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -49,16 +49,16 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n \n     if is_single_fp_element(ccx, arg.layout) {\n         match size.bytes() {\n-            4 => arg.cast_to(ccx, Reg::f32()),\n-            8 => arg.cast_to(ccx, Reg::f64()),\n+            4 => arg.cast_to(Reg::f32()),\n+            8 => arg.cast_to(Reg::f64()),\n             _ => arg.make_indirect(ccx)\n         }\n     } else {\n         match size.bytes() {\n-            1 => arg.cast_to(ccx, Reg::i8()),\n-            2 => arg.cast_to(ccx, Reg::i16()),\n-            4 => arg.cast_to(ccx, Reg::i32()),\n-            8 => arg.cast_to(ccx, Reg::i64()),\n+            1 => arg.cast_to(Reg::i8()),\n+            2 => arg.cast_to(Reg::i16()),\n+            4 => arg.cast_to(Reg::i32()),\n+            8 => arg.cast_to(Reg::i64()),\n             _ => arg.make_indirect(ccx)\n         }\n     }"}, {"sha": "baab70367419a06a56e00aaeb4700a90fecdaebc", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -8,45 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+use rustc::ty::layout::Size;\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             ret: &mut ArgType<'tcx>,\n+                             offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n+        *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &ccx.tcx().data_layout;\n     let size = arg.layout.size(ccx);\n-    let mut align = arg.layout.align(ccx).abi();\n-    align = cmp::min(cmp::max(align, 4), 8);\n+    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(ccx, Uniform {\n+        arg.cast_to(Uniform {\n             unit: Reg::i32(),\n             total: size\n         });\n-        if ((align - 1) & *offset) > 0 {\n-            arg.pad_with(ccx, Reg::i32());\n+        if !offset.is_abi_aligned(align) {\n+            arg.pad_with(Reg::i32());\n         }\n     } else {\n-        arg.extend_integer_width_to(32)\n+        arg.extend_integer_width_to(32);\n     }\n \n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size.bytes(), align);\n+    *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n     }\n \n-    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         classify_arg_ty(ccx, arg, &mut offset);"}, {"sha": "788fba9dc2628d59f38455dee42a92dc4bce8400", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -47,7 +47,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n-        ret.cast_to(ccx, uniform);\n+        ret.cast_to(uniform);\n         return;\n     }\n     let size = ret.layout.size(ccx);\n@@ -63,7 +63,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             Reg::i64()\n         };\n \n-        ret.cast_to(ccx, Uniform {\n+        ret.cast_to(Uniform {\n             unit,\n             total: size\n         });\n@@ -81,12 +81,12 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n \n     if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n-        arg.cast_to(ccx, uniform);\n+        arg.cast_to(uniform);\n         return;\n     }\n \n     let total = arg.layout.size(ccx);\n-    arg.cast_to(ccx, Uniform {\n+    arg.cast_to(Uniform {\n         unit: Reg::i64(),\n         total\n     });"}, {"sha": "b34337ae5f69f8fb9667a37a86c38b052a54e000", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -56,16 +56,16 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // float aggregates directly in a floating-point register.\n                 if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n                     match size.bytes() {\n-                        4 => fty.ret.cast_to(ccx, Reg::f32()),\n-                        8 => fty.ret.cast_to(ccx, Reg::f64()),\n+                        4 => fty.ret.cast_to(Reg::f32()),\n+                        8 => fty.ret.cast_to(Reg::f64()),\n                         _ => fty.ret.make_indirect(ccx)\n                     }\n                 } else {\n                     match size.bytes() {\n-                        1 => fty.ret.cast_to(ccx, Reg::i8()),\n-                        2 => fty.ret.cast_to(ccx, Reg::i16()),\n-                        4 => fty.ret.cast_to(ccx, Reg::i32()),\n-                        8 => fty.ret.cast_to(ccx, Reg::i64()),\n+                        1 => fty.ret.cast_to(Reg::i8()),\n+                        2 => fty.ret.cast_to(Reg::i16()),\n+                        4 => fty.ret.cast_to(Reg::i32()),\n+                        8 => fty.ret.cast_to(Reg::i64()),\n                         _ => fty.ret.make_indirect(ccx)\n                     }\n                 }"}, {"sha": "6670d084d6c57d6b20546f92b649a770a5e26035", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -34,9 +34,9 @@ const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n     fn unify(cls: &mut [Class],\n-             off: u64,\n+             off: Size,\n              c: Class) {\n-        let i = (off / 8) as usize;\n+        let i = (off.bytes() / 8) as usize;\n         let to_write = match (cls[i], c) {\n             (Class::None, _) => c,\n             (_, Class::None) => return,\n@@ -55,9 +55,9 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n-                          off: u64)\n+                          off: Size)\n                           -> Result<(), Memory> {\n-        if off % layout.align(ccx).abi() != 0 {\n+        if !off.is_abi_aligned(layout.align(ccx)) {\n             if layout.size(ccx).bytes() > 0 {\n                 return Err(Memory);\n             }\n@@ -85,25 +85,25 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let eltsz = element.size(ccx).bytes();\n+                let eltsz = element.size(ccx);\n                 for i in 1..count {\n-                    unify(cls, off + i * eltsz, Class::SseUp);\n+                    unify(cls, off + eltsz * i, Class::SseUp);\n                 }\n             }\n \n             Layout::Array { count, .. } => {\n                 if count > 0 {\n                     let elt = layout.field(ccx, 0);\n-                    let eltsz = elt.size(ccx).bytes();\n+                    let eltsz = elt.size(ccx);\n                     for i in 0..count {\n-                        classify(ccx, elt, cls, off + i * eltsz)?;\n+                        classify(ccx, elt, cls, off + eltsz * i)?;\n                     }\n                 }\n             }\n \n             Layout::Univariant { ref variant, .. } => {\n                 for i in 0..layout.field_count() {\n-                    let field_off = off + variant.offsets[i].bytes();\n+                    let field_off = off + variant.offsets[i];\n                     classify(ccx, layout.field(ccx, i), cls, field_off)?;\n                 }\n             }\n@@ -128,7 +128,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     }\n \n     let mut cls = [Class::None; MAX_EIGHTBYTES];\n-    classify(ccx, arg.layout, &mut cls, 0)?;\n+    classify(ccx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n         if cls[0] != Class::Sse {\n             return Err(Memory);\n@@ -153,7 +153,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     Ok(cls)\n }\n \n-fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n+fn reg_component(cls: &[Class], i: &mut usize, size: Size) -> Option<Reg> {\n     if *i >= cls.len() {\n         return None;\n     }\n@@ -162,7 +162,7 @@ fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n         Class::None => None,\n         Class::Int => {\n             *i += 1;\n-            Some(match size {\n+            Some(match size.bytes() {\n                 1 => Reg::i8(),\n                 2 => Reg::i16(),\n                 3 |\n@@ -174,32 +174,32 @@ fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n             let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n             *i += vec_len;\n             Some(if vec_len == 1 {\n-                match size {\n+                match size.bytes() {\n                     4 => Reg::f32(),\n                     _ => Reg::f64()\n                 }\n             } else {\n                 Reg {\n                     kind: RegKind::Vector,\n-                    size: Size::from_bytes(vec_len as u64 * 8)\n+                    size: Size::from_bytes(8) * (vec_len as u64)\n                 }\n             })\n         }\n         c => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n }\n \n-fn cast_target(cls: &[Class], size: u64) -> CastTarget {\n+fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n     let mut i = 0;\n     let lo = reg_component(cls, &mut i, size).unwrap();\n-    let offset = i as u64 * 8;\n+    let offset = Size::from_bytes(8) * (i as u64);\n     let target = if size <= offset {\n         CastTarget::from(lo)\n     } else {\n         let hi = reg_component(cls, &mut i, size - offset).unwrap();\n         CastTarget::Pair(lo, hi)\n     };\n-    assert_eq!(reg_component(cls, &mut i, 0), None);\n+    assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);\n     target\n }\n \n@@ -242,8 +242,8 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n             sse_regs -= needed_sse;\n \n             if arg.layout.is_aggregate() {\n-                let size = arg.layout.size(ccx).bytes();\n-                arg.cast_to(ccx, cast_target(cls.as_ref().unwrap(), size))\n+                let size = arg.layout.size(ccx);\n+                arg.cast_to(cast_target(cls.as_ref().unwrap(), size))\n             } else {\n                 arg.extend_integer_width_to(32);\n             }"}, {"sha": "1d391da5993fe2930b3eb86cce770b7c1d858287", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -20,10 +20,10 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n         let size = a.layout.size(ccx);\n         if a.layout.is_aggregate() {\n             match size.bits() {\n-                8 => a.cast_to(ccx, Reg::i8()),\n-                16 => a.cast_to(ccx, Reg::i16()),\n-                32 => a.cast_to(ccx, Reg::i32()),\n-                64 => a.cast_to(ccx, Reg::i64()),\n+                8 => a.cast_to(Reg::i8()),\n+                16 => a.cast_to(Reg::i16()),\n+                32 => a.cast_to(Reg::i32()),\n+                64 => a.cast_to(Reg::i64()),\n                 _ => a.make_indirect(ccx)\n             };\n         } else {"}, {"sha": "e3ee8f7c75a8ad32d77aa04b7d18022a69f1a2be", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -22,13 +22,12 @@ use base;\n use builder::Builder;\n use consts;\n use declare;\n-use machine;\n use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n+use rustc::ty::layout::{HasDataLayout, Layout, LayoutTyper};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n@@ -252,10 +251,6 @@ pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-    C_struct(ccx, &[], false)\n-}\n-\n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n     C_uint(Type::i1(ccx), val as u64)\n }\n@@ -273,8 +268,7 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n }\n \n pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n-\n+    let bit_size = ccx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n         assert!(i < (1<<bit_size));"}, {"sha": "83ecbbed76b9a4249f5dbecbb611814cc2853b26", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -14,7 +14,7 @@ use llvm::{ValueRef, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n-use {debuginfo, machine};\n+use debuginfo;\n use base;\n use trans_item::{TransItem, TransItemExt};\n use common::{self, CrateContext, val_ty};\n@@ -23,10 +23,10 @@ use monomorphize::Instance;\n use type_::Type;\n use type_of;\n use rustc::ty;\n+use rustc::ty::layout::Align;\n \n use rustc::hir;\n \n-use std::cmp;\n use std::ffi::{CStr, CString};\n use syntax::ast;\n use syntax::attr;\n@@ -45,26 +45,26 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n \n fn set_global_alignment(ccx: &CrateContext,\n                         gv: ValueRef,\n-                        mut align: machine::llalign) {\n+                        mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n     if let Some(min) = ccx.sess().target.target.options.min_global_align {\n         match ty::layout::Align::from_bits(min, min) {\n-            Ok(min) => align = cmp::max(align, min.abi() as machine::llalign),\n+            Ok(min) => align = align.max(min),\n             Err(err) => {\n                 ccx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n             }\n         }\n     }\n     unsafe {\n-        llvm::LLVMSetAlignment(gv, align);\n+        llvm::LLVMSetAlignment(gv, align.abi() as u32);\n     }\n }\n \n pub fn addr_of_mut(ccx: &CrateContext,\n                    cv: ValueRef,\n-                   align: machine::llalign,\n+                   align: Align,\n                    kind: &str)\n                     -> ValueRef {\n     unsafe {\n@@ -82,15 +82,16 @@ pub fn addr_of_mut(ccx: &CrateContext,\n \n pub fn addr_of(ccx: &CrateContext,\n                cv: ValueRef,\n-               align: machine::llalign,\n+               align: Align,\n                kind: &str)\n                -> ValueRef {\n     if let Some(&gv) = ccx.const_globals().borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n             // alignment requirements\n-            if align > llvm::LLVMGetAlignment(gv) {\n-                llvm::LLVMSetAlignment(gv, align);\n+            let llalign = align.abi() as u32;\n+            if llalign > llvm::LLVMGetAlignment(gv) {\n+                llvm::LLVMSetAlignment(gv, llalign);\n             }\n         }\n         return gv;"}, {"sha": "d2e2e1bbdee476231a1efda725c120eddf5a1bcc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 148, "deletions": 216, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use self::RecursiveTypeDescription::*;\n-use self::MemberOffset::*;\n use self::MemberDescriptionFactory::*;\n use self::EnumDiscriminantInfo::*;\n \n-use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n+use super::utils::{debug_context, DIB, span_start,\n                    get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n@@ -30,13 +29,11 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n-use rustc::hir;\n use rustc::ich::Fingerprint;\n-use {type_of, machine, monomorphize};\n+use monomorphize;\n use common::{self, CrateContext};\n-use type_::Type;\n use rustc::ty::{self, AdtKind, Ty};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, Align, LayoutTyper, Size};\n use rustc::session::{Session, config};\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n@@ -184,7 +181,6 @@ enum RecursiveTypeDescription<'tcx> {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n-        llvm_type: Type,\n         member_description_factory: MemberDescriptionFactory<'tcx>,\n     },\n     FinalMetadata(DICompositeType)\n@@ -195,7 +191,6 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n-    llvm_type: Type,\n     member_description_factory: MemberDescriptionFactory<'tcx>)\n  -> RecursiveTypeDescription<'tcx> {\n \n@@ -208,7 +203,6 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n         unfinished_type,\n         unique_type_id,\n         metadata_stub,\n-        llvm_type,\n         member_description_factory,\n     }\n }\n@@ -224,9 +218,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 unfinished_type,\n                 unique_type_id,\n                 metadata_stub,\n-                llvm_type,\n                 ref member_description_factory,\n-                ..\n             } => {\n                 // Make sure that we have a forward declaration of the type in\n                 // the TypeMap so that recursive references are possible. This\n@@ -251,7 +243,6 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n-                                              llvm_type,\n                                               &member_descriptions[..]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n@@ -274,20 +265,21 @@ macro_rules! return_if_metadata_created_in_meantime {\n \n fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n+                                array_or_slice_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n-                                len: Option<u64>,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n+    let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n-    let (array_size_in_bytes, upper_bound) = match len {\n-        Some(len) => (element_type_size * len, len as c_longlong),\n-        None => (0, -1)\n+    let upper_bound = match array_or_slice_type.sty {\n+        ty::TyArray(_, len) => {\n+            len.val.to_const_int().unwrap().to_u64().unwrap() as c_longlong\n+        }\n+        _ => -1\n     };\n \n     let subrange = unsafe {\n@@ -298,8 +290,8 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(array_size_in_bytes),\n-            bytes_to_bits(element_type_align),\n+            size.bits(),\n+            align.abi_bits() as u32,\n             element_type_metadata,\n             subscripts)\n     };\n@@ -308,66 +300,52 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                vec_type: Ty<'tcx>,\n+                                slice_ptr_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = cx.tcx().mk_ptr(ty::TypeAndMut {\n-        ty: element_type,\n-        mutbl: hir::MutImmutable\n-    });\n+    let data_ptr_type = cx.tcx().mk_imm_ptr(element_type);\n \n-    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n+    let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = compute_debuginfo_type_name(cx, vec_type, true);\n+    let slice_type_name = compute_debuginfo_type_name(cx, slice_ptr_type, true);\n+\n+    let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n+    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx().types.usize);\n \n-    let member_llvm_types = slice_llvm_type.field_types();\n-    assert!(slice_layout_is_correct(cx,\n-                                    &member_llvm_types[..],\n-                                    element_type));\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n-            llvm_type: member_llvm_types[0],\n-            type_metadata: element_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: data_ptr_metadata,\n+            offset: Size::from_bytes(0),\n+            size: pointer_size,\n+            align: pointer_align,\n             flags: DIFlags::FlagZero,\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n-            offset: ComputedMemberOffset,\n+            offset: pointer_size,\n+            size: usize_size,\n+            align: usize_align,\n             flags: DIFlags::FlagZero,\n         },\n     ];\n \n-    assert!(member_descriptions.len() == member_llvm_types.len());\n-\n     let file_metadata = unknown_file_metadata(cx);\n \n     let metadata = composite_type_metadata(cx,\n-                                           slice_llvm_type,\n+                                           slice_ptr_type,\n                                            &slice_type_name[..],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            NO_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n-    return MetadataCreationResult::new(metadata, false);\n-\n-    fn slice_layout_is_correct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         member_llvm_types: &[Type],\n-                                         element_type: Ty<'tcx>)\n-                                         -> bool {\n-        member_llvm_types.len() == 2 &&\n-        member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.isize_ty()\n-    }\n+    MetadataCreationResult::new(metadata, false)\n }\n \n fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -436,38 +414,38 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let trait_type_name =\n         compute_debuginfo_type_name(cx, trait_object_type, false);\n \n-    let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n     let file_metadata = unknown_file_metadata(cx);\n \n-\n-    let ptr_type = cx.tcx().mk_ptr(ty::TypeAndMut {\n-        ty: cx.tcx().types.u8,\n-        mutbl: hir::MutImmutable\n-    });\n-    let ptr_type_metadata = type_metadata(cx, ptr_type, syntax_pos::DUMMY_SP);\n-    let llvm_type = type_of::type_of(cx, ptr_type);\n+    let layout = cx.layout_of(cx.tcx().mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+\n+    let data_ptr_field = layout.field(cx, 0);\n+    let vtable_field = layout.field(cx, 1);\n     let member_descriptions = [\n         MemberDescription {\n             name: \"pointer\".to_string(),\n-            llvm_type: llvm_type,\n-            type_metadata: ptr_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: type_metadata(cx,\n+                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                syntax_pos::DUMMY_SP),\n+            offset: layout.field_offset(cx, 0),\n+            size: data_ptr_field.size(cx),\n+            align: data_ptr_field.align(cx),\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n             name: \"vtable\".to_string(),\n-            llvm_type: llvm_type,\n-            type_metadata: ptr_type_metadata,\n-            offset: ComputedMemberOffset,\n+            type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n+            offset: layout.field_offset(cx, 1),\n+            size: vtable_field.size(cx),\n+            align: vtable_field.align(cx),\n             flags: DIFlags::FlagArtificial,\n         },\n     ];\n \n     composite_type_metadata(cx,\n-                            trait_llvm_type,\n+                            trait_object_type,\n                             &trait_type_name[..],\n                             unique_type_id,\n                             &member_descriptions,\n@@ -556,15 +534,12 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elements, _) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyArray(typ, len) => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-            fixed_vec_metadata(cx, unique_type_id, typ, Some(len), usage_site_span)\n-        }\n+        ty::TyArray(typ, _) |\n         ty::TySlice(typ) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, None, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n         ty::TyStr => {\n-            fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx().types.i8, usage_site_span)\n         }\n         ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n@@ -770,15 +745,14 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n-    let llvm_type = type_of::type_of(cx, t);\n-    let (size, align) = size_and_align_of(cx, llvm_type);\n+    let (size, align) = cx.size_and_align_of(t);\n     let name = CString::new(name).unwrap();\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr(),\n-            bytes_to_bits(size),\n-            bytes_to_bits(align),\n+            size.bits(),\n+            align.abi_bits() as u32,\n             encoding)\n     };\n \n@@ -790,29 +764,25 @@ fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id: UniqueTypeId) -> DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n-    let llvm_type = type_of::type_of(cx, t);\n-\n     let name = compute_debuginfo_type_name(cx, t, false);\n-    create_struct_stub(cx, llvm_type, &name, unique_type_id, NO_SCOPE_METADATA)\n+    create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    pointer_type: Ty<'tcx>,\n                                    pointee_type_metadata: DIType)\n                                    -> DIType {\n-    let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n-    let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n+    let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let name = CString::new(name).unwrap();\n-    let ptr_metadata = unsafe {\n+    unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n             pointee_type_metadata,\n-            bytes_to_bits(pointer_size),\n-            bytes_to_bits(pointer_align),\n+            pointer_size.bits(),\n+            pointer_align.abi_bits() as u32,\n             name.as_ptr())\n-    };\n-    return ptr_metadata;\n+    }\n }\n \n pub fn compile_unit_metadata(scc: &SharedCrateContext,\n@@ -907,21 +877,15 @@ impl MetadataCreationResult {\n     }\n }\n \n-#[derive(Debug)]\n-enum MemberOffset {\n-    FixedMemberOffset { bytes: usize },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n-    ComputedMemberOffset\n-}\n-\n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n #[derive(Debug)]\n struct MemberDescription {\n     name: String,\n-    llvm_type: Type,\n     type_metadata: DIType,\n-    offset: MemberOffset,\n+    offset: Size,\n+    size: Size,\n+    align: Align,\n     flags: DIFlags,\n }\n \n@@ -998,13 +962,13 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             };\n             let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n \n-            let offset = FixedMemberOffset { bytes: offsets[i].bytes() as usize};\n-\n+            let (size, align) = cx.size_and_align_of(fty);\n             MemberDescription {\n                 name,\n-                llvm_type: type_of::in_memory_type_of(cx, fty),\n                 type_metadata: type_metadata(cx, fty, self.span),\n-                offset,\n+                offset: offsets[i],\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1018,7 +982,6 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n     let (struct_def_id, variant, substs) = match struct_type.sty {\n         ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n@@ -1028,7 +991,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let containing_scope = get_namespace_for_item(cx, struct_def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n-                                                  struct_llvm_type,\n+                                                  struct_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n@@ -1038,7 +1001,6 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n-        struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n             ty: struct_type,\n             variant,\n@@ -1069,15 +1031,14 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n             bug!(\"{} is not a tuple\", self.ty);\n         };\n \n-        self.component_types\n-            .iter()\n-            .enumerate()\n-            .map(|(i, &component_type)| {\n+        self.component_types.iter().enumerate().map(|(i, &component_type)| {\n+            let (size, align) = cx.size_and_align_of(component_type);\n             MemberDescription {\n                 name: format!(\"__{}\", i),\n-                llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: FixedMemberOffset { bytes: offsets[i].bytes() as usize },\n+                offset: offsets[i],\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1091,18 +1052,16 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     span: Span)\n                                     -> RecursiveTypeDescription<'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n-    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         tuple_type,\n         unique_type_id,\n         create_struct_stub(cx,\n-                           tuple_llvm_type,\n+                           tuple_type,\n                            &tuple_name[..],\n                            unique_type_id,\n                            NO_SCOPE_METADATA),\n-        tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n@@ -1126,11 +1085,13 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                                       -> Vec<MemberDescription> {\n         self.variant.fields.iter().map(|field| {\n             let fty = monomorphize::field_ty(cx.tcx(), self.substs, field);\n+            let (size, align) = cx.size_and_align_of(fty);\n             MemberDescription {\n                 name: field.name.to_string(),\n-                llvm_type: type_of::type_of(cx, fty),\n                 type_metadata: type_metadata(cx, fty, self.span),\n-                offset: FixedMemberOffset { bytes: 0 },\n+                offset: Size::from_bytes(0),\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1143,7 +1104,6 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     span: Span)\n                                     -> RecursiveTypeDescription<'tcx> {\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n-    let union_llvm_type = type_of::in_memory_type_of(cx, union_type);\n \n     let (union_def_id, variant, substs) = match union_type.sty {\n         ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n@@ -1153,7 +1113,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let containing_scope = get_namespace_for_item(cx, union_def_id);\n \n     let union_metadata_stub = create_union_stub(cx,\n-                                                union_llvm_type,\n+                                                union_type,\n                                                 &union_name,\n                                                 unique_type_id,\n                                                 containing_scope);\n@@ -1163,7 +1123,6 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         union_type,\n         unique_type_id,\n         union_metadata_stub,\n-        union_llvm_type,\n         UnionMDF(UnionMemberDescriptionFactory {\n             variant,\n             substs,\n@@ -1206,9 +1165,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     .iter()\n                     .enumerate()\n                     .map(|(i, struct_def)| {\n-                        let (variant_type_metadata,\n-                             variant_llvm_type,\n-                             member_desc_factory) =\n+                        let (variant_type_metadata, member_desc_factory) =\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n@@ -1222,13 +1179,13 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n-                                                      variant_llvm_type,\n                                                       &member_descriptions);\n                         MemberDescription {\n                             name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n                             type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n+                            offset: Size::from_bytes(0),\n+                            size: struct_def.stride(),\n+                            align: struct_def.align,\n                             flags: DIFlags::FlagZero\n                         }\n                     }).collect()\n@@ -1239,9 +1196,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 if adt.variants.is_empty() {\n                     vec![]\n                 } else {\n-                    let (variant_type_metadata,\n-                         variant_llvm_type,\n-                         member_description_factory) =\n+                    let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               variant,\n@@ -1255,14 +1210,14 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n-                                                  variant_llvm_type,\n                                                   &member_descriptions[..]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n                             type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n+                            offset: Size::from_bytes(0),\n+                            size: variant.stride(),\n+                            align: variant.align,\n                             flags: DIFlags::FlagZero\n                         }\n                     ]\n@@ -1278,15 +1233,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n-                let nnty = monomorphize::field_ty(cx.tcx(), &substs, &non_null_variant.fields[0] );\n-                let non_null_llvm_type = type_of::type_of(cx, nnty);\n+                let nnty = monomorphize::field_ty(cx.tcx(), &substs, &non_null_variant.fields[0]);\n+                let (size, align) = cx.size_and_align_of(nnty);\n                 let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n \n-                // The type of the artificial struct wrapping the pointer\n-                let artificial_struct_llvm_type = Type::struct_(cx,\n-                                                                &[non_null_llvm_type],\n-                                                                false);\n-\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n@@ -1297,9 +1247,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                         CtorKind::Const => bug!()\n                     },\n-                    llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n-                    offset: FixedMemberOffset { bytes: 0 },\n+                    offset: Size::from_bytes(0),\n+                    size,\n+                    align,\n                     flags: DIFlags::FlagZero\n                 };\n \n@@ -1313,7 +1264,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Now we can create the metadata of the artificial struct\n                 let artificial_struct_metadata =\n                     composite_type_metadata(cx,\n-                                            artificial_struct_llvm_type,\n+                                            nnty,\n                                             &non_null_variant_name,\n                                             unique_type_id,\n                                             &[sole_struct_member_description],\n@@ -1334,9 +1285,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 vec![\n                     MemberDescription {\n                         name: union_member_name,\n-                        llvm_type: artificial_struct_llvm_type,\n                         type_metadata: artificial_struct_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n+                        offset: Size::from_bytes(0),\n+                        size,\n+                        align,\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n@@ -1345,7 +1297,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                                 nndiscr,\n                                                 ref discrfield_source, ..} => {\n                 // Create a description of the non-null variant\n-                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n@@ -1359,7 +1311,6 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n-                                              variant_llvm_type,\n                                               &variant_member_descriptions[..]);\n \n                 // Encode the information about the null variant in the union\n@@ -1378,9 +1329,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 vec![\n                     MemberDescription {\n                         name: union_member_name,\n-                        llvm_type: variant_llvm_type,\n                         type_metadata: variant_type_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n+                        offset: Size::from_bytes(0),\n+                        size: struct_def.stride(),\n+                        align: struct_def.align,\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n@@ -1404,14 +1356,16 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n+            let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n                 name: name.to_string(),\n-                llvm_type: type_of::type_of(cx, ty),\n                 type_metadata: match self.discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n                     _ => type_metadata(cx, ty, self.span)\n                 },\n-                offset: FixedMemberOffset { bytes: self.offsets[i].bytes() as usize },\n+                offset: self.offsets[i],\n+                size,\n+                align,\n                 flags: DIFlags::FlagZero\n             }\n         }).collect()\n@@ -1436,7 +1390,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n-                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n+                                   -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n     let substs = match enum_type.sty {\n         ty::TyAdt(def, s) if def.adt_kind() == AdtKind::Enum => s,\n         ref t @ _ => bug!(\"{:#?} is not an enum\", t)\n@@ -1456,17 +1410,9 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }).collect::<Vec<_>>();\n \n     if let Some((discr, signed)) = maybe_discr_and_signed {\n-        field_tys.insert(0, discr.to_ty(&cx.tcx(), signed));\n+        field_tys.insert(0, discr.to_ty(cx.tcx(), signed));\n     }\n \n-\n-    let variant_llvm_type =\n-        Type::struct_(cx, &field_tys\n-                                    .iter()\n-                                    .map(|t| type_of::type_of(cx, t))\n-                                    .collect::<Vec<_>>()\n-                                    ,\n-                      struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n     let variant_name = variant.name.as_str();\n@@ -1478,7 +1424,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                               &variant_name);\n \n     let metadata_stub = create_struct_stub(cx,\n-                                           variant_llvm_type,\n+                                           enum_type,\n                                            &variant_name,\n                                            unique_type_id,\n                                            containing_scope);\n@@ -1526,7 +1472,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             span,\n         });\n \n-    (metadata_stub, variant_llvm_type, member_description_factory)\n+    (metadata_stub, member_description_factory)\n }\n \n fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1570,12 +1516,11 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n-                let discriminant_llvm_type = Type::from_integer(cx, inttype);\n                 let (discriminant_size, discriminant_align) =\n-                    size_and_align_of(cx, discriminant_llvm_type);\n+                    (inttype.size(), inttype.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx,\n-                                  inttype.to_ty(&cx.tcx(), signed),\n+                                  inttype.to_ty(cx.tcx(), signed),\n                                   syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n@@ -1587,8 +1532,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         name.as_ptr(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(discriminant_size),\n-                        bytes_to_bits(discriminant_align),\n+                        discriminant_size.bits(),\n+                        discriminant_align.abi_bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n                         discriminant_base_type_metadata)\n                 };\n@@ -1615,8 +1560,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n \n-    let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+    let (enum_type_size, enum_type_align) = cx.size_and_align_of(enum_type);\n \n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new(\n@@ -1629,8 +1573,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_name.as_ptr(),\n         file_metadata,\n         UNKNOWN_LINE_NUMBER,\n-        bytes_to_bits(enum_type_size),\n-        bytes_to_bits(enum_type_align),\n+        enum_type_size.bits(),\n+        enum_type_align.abi_bits() as u32,\n         DIFlags::FlagZero,\n         ptr::null_mut(),\n         0, // RuntimeLang\n@@ -1642,7 +1586,6 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_type,\n         unique_type_id,\n         enum_metadata,\n-        enum_llvm_type,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             type_rep: type_rep.layout,\n@@ -1664,36 +1607,34 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(cx: &CrateContext,\n-                           composite_llvm_type: Type,\n-                           composite_type_name: &str,\n-                           composite_type_unique_id: UniqueTypeId,\n-                           member_descriptions: &[MemberDescription],\n-                           containing_scope: DIScope,\n-\n-                           // Ignore source location information as long as it\n-                           // can't be reconstructed for non-local crates.\n-                           _file_metadata: DIFile,\n-                           _definition_span: Span)\n-                           -> DICompositeType {\n+fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     composite_type: Ty<'tcx>,\n+                                     composite_type_name: &str,\n+                                     composite_type_unique_id: UniqueTypeId,\n+                                     member_descriptions: &[MemberDescription],\n+                                     containing_scope: DIScope,\n+\n+                                     // Ignore source location information as long as it\n+                                     // can't be reconstructed for non-local crates.\n+                                     _file_metadata: DIFile,\n+                                     _definition_span: Span)\n+                                     -> DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(cx,\n-                                                     composite_llvm_type,\n+                                                     composite_type,\n                                                      composite_type_name,\n                                                      composite_type_unique_id,\n                                                      containing_scope);\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx,\n                                   composite_type_metadata,\n-                                  composite_llvm_type,\n                                   member_descriptions);\n \n     return composite_type_metadata;\n }\n \n fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_type_metadata: DICompositeType,\n-                                 composite_llvm_type: Type,\n                                  member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n@@ -1714,14 +1655,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     let member_metadata: Vec<DIDescriptor> = member_descriptions\n         .iter()\n-        .enumerate()\n-        .map(|(i, member_description)| {\n-            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = match member_description.offset {\n-                FixedMemberOffset { bytes } => bytes as u64,\n-                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n-            };\n-\n+        .map(|member_description| {\n             let member_name = member_description.name.as_bytes();\n             let member_name = CString::new(member_name).unwrap();\n             unsafe {\n@@ -1731,9 +1665,9 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                     member_name.as_ptr(),\n                     unknown_file_metadata(cx),\n                     UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(member_size),\n-                    bytes_to_bits(member_align),\n-                    bytes_to_bits(member_offset),\n+                    member_description.size.bits(),\n+                    member_description.align.abi_bits() as u32,\n+                    member_description.offset.bits(),\n                     member_description.flags,\n                     member_description.type_metadata)\n             }\n@@ -1750,13 +1684,13 @@ fn set_members_of_composite_type(cx: &CrateContext,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub(cx: &CrateContext,\n-                      struct_llvm_type: Type,\n-                      struct_type_name: &str,\n-                      unique_type_id: UniqueTypeId,\n-                      containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                struct_type: Ty<'tcx>,\n+                                struct_type_name: &str,\n+                                unique_type_id: UniqueTypeId,\n+                                containing_scope: DIScope)\n+                                -> DICompositeType {\n+    let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n     let name = CString::new(struct_type_name).unwrap();\n     let unique_type_id = CString::new(\n@@ -1774,8 +1708,8 @@ fn create_struct_stub(cx: &CrateContext,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n+            struct_size.bits(),\n+            struct_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             ptr::null_mut(),\n             empty_array,\n@@ -1787,13 +1721,13 @@ fn create_struct_stub(cx: &CrateContext,\n     return metadata_stub;\n }\n \n-fn create_union_stub(cx: &CrateContext,\n-                     union_llvm_type: Type,\n-                     union_type_name: &str,\n-                     unique_type_id: UniqueTypeId,\n-                     containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n+fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                               union_type: Ty<'tcx>,\n+                               union_type_name: &str,\n+                               unique_type_id: UniqueTypeId,\n+                               containing_scope: DIScope)\n+                               -> DICompositeType {\n+    let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n     let name = CString::new(union_type_name).unwrap();\n     let unique_type_id = CString::new(\n@@ -1811,8 +1745,8 @@ fn create_union_stub(cx: &CrateContext,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(union_size),\n-            bytes_to_bits(union_align),\n+            union_size.bits(),\n+            union_align.abi_bits() as u32,\n             DIFlags::FlagZero,\n             empty_array,\n             0, // RuntimeLang\n@@ -1867,7 +1801,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     is_local_to_unit,\n                                                     global,\n                                                     ptr::null_mut(),\n-                                                    global_align,\n+                                                    global_align.abi() as u32,\n         );\n     }\n }\n@@ -1899,8 +1833,6 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let type_metadata = type_metadata(cx, ty, syntax_pos::DUMMY_SP);\n-    let llvm_vtable_type = Type::vtable_ptr(cx).element_type();\n-    let (struct_size, struct_align) = size_and_align_of(cx, llvm_vtable_type);\n \n     unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n@@ -1919,8 +1851,8 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n+            Size::from_bytes(0).bits(),\n+            cx.tcx().data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),\n             empty_array,"}, {"sha": "1ca12771dd44871ae601f72599405b7015fd5ab6", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -499,7 +499,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     cx.sess().opts.optimize != config::OptLevel::No,\n                     DIFlags::FlagZero,\n                     argument_index,\n-                    align,\n+                    align.abi() as u32,\n                 )\n             };\n             source_loc::set_debug_location(bcx,"}, {"sha": "95427d9b3cd4e76a8f1606b75e98be0092b50858", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -18,15 +18,11 @@ use rustc::ty::DefIdTree;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n-use machine;\n use common::{CrateContext};\n-use type_::Type;\n \n use syntax_pos::{self, Span};\n use syntax::ast;\n \n-use std::ops;\n-\n pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n@@ -53,15 +49,6 @@ pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo())\n }\n \n-pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u32) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n-}\n-\n-pub fn bytes_to_bits<T>(bytes: T) -> T\n-    where T: ops::Mul<Output=T> + From<u8> {\n-    bytes * 8u8.into()\n-}\n-\n #[inline]\n pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {"}, {"sha": "597d8c587e9218aac95d5ebd55e93a7a79be0e58", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -29,12 +29,11 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n     if bcx.ccx.shared().type_is_sized(t) {\n-        let size = bcx.ccx.size_of(t);\n-        let align = bcx.ccx.align_of(t);\n-        debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n+        let (size, align) = bcx.ccx.size_and_align_of(t);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, Value(info), size, align);\n-        let size = C_usize(bcx.ccx, size);\n-        let align = C_usize(bcx.ccx, align as u64);\n+        let size = C_usize(bcx.ccx, size.bytes());\n+        let align = C_usize(bcx.ccx, align.abi());\n         return (size, align);\n     }\n     assert!(!info.is_null());\n@@ -122,8 +121,9 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            (bcx.mul(info, C_usize(bcx.ccx, bcx.ccx.size_of(unit))),\n-             C_usize(bcx.ccx, bcx.ccx.align_of(unit) as u64))\n+            let (size, align) = bcx.ccx.size_and_align_of(unit);\n+            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n+             C_usize(bcx.ccx, align.abi()))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "c66a8ae2fcc4e5e0ad3e394c2617d2f104ab0a64", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 93, "deletions": 96, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -21,9 +21,9 @@ use common::*;\n use declare;\n use glue;\n use type_of;\n-use machine;\n use type_::Type;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::HasDataLayout;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -125,50 +125,47 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"try\" => {\n             try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n-            C_nil(ccx)\n+            return;\n         }\n         \"breakpoint\" => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n             bcx.call(llfn, &[], None)\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            C_usize(ccx, ccx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                let lltp_ty = type_of::type_of(ccx, tp_ty);\n-                C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n             } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llsize\n             } else {\n-                C_usize(ccx, 0u64)\n+                C_usize(ccx, 0)\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty) as u64)\n+            C_usize(ccx, ccx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if bcx.ccx.shared().type_is_sized(tp_ty) {\n-                C_usize(ccx, ccx.align_of(tp_ty) as u64)\n+                C_usize(ccx, ccx.align_of(tp_ty).abi())\n             } else if bcx.ccx.shared().type_has_metadata(tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_usize(ccx, 1u64)\n+                C_usize(ccx, 1)\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_usize(ccx, machine::llalign_of_pref(ccx, lltp_ty) as u64)\n+            C_usize(ccx, ccx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n@@ -187,11 +184,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n                 memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n             }\n-            C_nil(ccx)\n+            return;\n         }\n         // Effectively no-ops\n         \"uninit\" => {\n-            C_nil(ccx)\n+            return;\n         }\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n@@ -232,11 +229,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n-                ptr = bcx.pointercast(ptr, ty.ptr_to());\n+                ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n             }\n             let load = bcx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty));\n+                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty).abi() as u32);\n             }\n             to_immediate(bcx, load, tp_ty)\n         },\n@@ -249,19 +246,18 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let val = if fn_ty.args[1].is_indirect() {\n                     bcx.load(llargs[1], None)\n                 } else {\n-                    if !type_is_zero_size(ccx, tp_ty) {\n-                        from_immediate(bcx, llargs[1])\n-                    } else {\n-                        C_nil(ccx)\n+                    if type_is_zero_size(ccx, tp_ty) {\n+                        return;\n                     }\n+                    from_immediate(bcx, llargs[1])\n                 };\n                 let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty));\n+                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n                 }\n             }\n-            C_nil(ccx)\n+            return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n@@ -279,8 +275,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n-            let sty = &arg_tys[0].sty;\n-            match int_type_width_signed(sty, ccx) {\n+            let ty = arg_tys[0];\n+            match int_type_width_signed(ty, ccx) {\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n@@ -317,7 +313,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             bcx.store(result, bcx.struct_gep(llresult, 0), None);\n                             bcx.store(overflow, bcx.struct_gep(llresult, 1), None);\n \n-                            C_nil(bcx.ccx)\n+                            return;\n                         },\n                         \"overflowing_add\" => bcx.add(llargs[0], llargs[1]),\n                         \"overflowing_sub\" => bcx.sub(llargs[0], llargs[1]),\n@@ -347,8 +343,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     span_invalid_monomorphization_error(\n                         tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\", name, sty));\n-                        C_nil(ccx)\n+                                  expected basic integer type, found `{}`\", name, ty));\n+                    return;\n                 }\n             }\n \n@@ -370,7 +366,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n                                   expected basic float type, found `{}`\", name, sty));\n-                        C_nil(ccx)\n+                    return;\n                 }\n             }\n \n@@ -399,11 +395,14 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             bcx.select(is_zero, zero, bcx.sub(offset, llargs[1]))\n         }\n         name if name.starts_with(\"simd_\") => {\n-            generic_simd_intrinsic(bcx, name,\n-                                   callee_ty,\n-                                   &llargs,\n-                                   ret_ty, llret_ty,\n-                                   span)\n+            match generic_simd_intrinsic(bcx, name,\n+                                         callee_ty,\n+                                         &llargs,\n+                                         ret_ty, llret_ty,\n+                                         span) {\n+                Ok(llval) => llval,\n+                Err(()) => return\n+            }\n         }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n@@ -437,57 +436,58 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n-            let invalid_monomorphization = |sty| {\n+            let invalid_monomorphization = |ty| {\n                 span_invalid_monomorphization_error(tcx.sess, span,\n                     &format!(\"invalid monomorphization of `{}` intrinsic: \\\n-                              expected basic integer type, found `{}`\", name, sty));\n+                              expected basic integer type, found `{}`\", name, ty));\n             };\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let val = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n                             failorder, weak);\n                         let result = bcx.extract_value(val, 0);\n                         let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n                         bcx.store(result, bcx.struct_gep(llresult, 0), None);\n                         bcx.store(success, bcx.struct_gep(llresult, 1), None);\n+                        return;\n                     } else {\n-                        invalid_monomorphization(sty);\n+                        return invalid_monomorphization(ty);\n                     }\n-                    C_nil(ccx)\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n-                        bcx.atomic_load(llargs[0], order)\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n+                        let align = ccx.align_of(ty);\n+                        bcx.atomic_load(llargs[0], order, align)\n                     } else {\n-                        invalid_monomorphization(sty);\n-                        C_nil(ccx)\n+                        return invalid_monomorphization(ty);\n                     }\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n-                        bcx.atomic_store(llargs[1], llargs[0], order);\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n+                        let align = ccx.align_of(ty);\n+                        bcx.atomic_store(llargs[1], llargs[0], order, align);\n+                        return;\n                     } else {\n-                        invalid_monomorphization(sty);\n+                        return invalid_monomorphization(ty);\n                     }\n-                    C_nil(ccx)\n                 }\n \n                 \"fence\" => {\n                     bcx.atomic_fence(order, llvm::SynchronizationScope::CrossThread);\n-                    C_nil(ccx)\n+                    return;\n                 }\n \n                 \"singlethreadfence\" => {\n                     bcx.atomic_fence(order, llvm::SynchronizationScope::SingleThread);\n-                    C_nil(ccx)\n+                    return;\n                 }\n \n                 // These are all AtomicRMW ops\n@@ -507,12 +507,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.type_at(0).sty;\n-                    if int_type_width_signed(sty, ccx).is_some() {\n+                    let ty = substs.type_at(0);\n+                    if int_type_width_signed(ty, ccx).is_some() {\n                         bcx.atomic_rmw(atom_op, llargs[0], llargs[1], order)\n                     } else {\n-                        invalid_monomorphization(sty);\n-                        C_nil(ccx)\n+                        return invalid_monomorphization(ty);\n                     }\n                 }\n             }\n@@ -662,16 +661,16 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         let (dest, align) = lval.trans_field_ptr(bcx, i);\n                         bcx.store(val, dest, align.to_align());\n                     }\n-                    C_nil(ccx)\n+                    return;\n                 }\n                 _ => val,\n             }\n         }\n     };\n \n-    if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n+    if !fn_ty.ret.is_ignore() {\n         if let Some(ty) = fn_ty.ret.cast {\n-            let ptr = bcx.pointercast(llresult, ty.ptr_to());\n+            let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n             bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n             store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n@@ -682,24 +681,24 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n-                            tp_ty: Ty<'tcx>,\n+                            ty: Ty<'tcx>,\n                             dst: ValueRef,\n                             src: ValueRef,\n                             count: ValueRef)\n                             -> ValueRef {\n     let ccx = bcx.ccx;\n-    let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n-    let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n+    let (size, align) = ccx.size_and_align_of(ty);\n+    let size = C_usize(ccx, size.bytes());\n+    let align = C_i32(ccx, align.abi() as i32);\n \n     let operation = if allow_overlap {\n         \"memmove\"\n     } else {\n         \"memcpy\"\n     };\n \n-    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation, int_size);\n+    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n+                       ccx.data_layout().pointer_size.bits());\n \n     let dst_ptr = bcx.pointercast(dst, Type::i8p(ccx));\n     let src_ptr = bcx.pointercast(src, Type::i8p(ccx));\n@@ -723,9 +722,9 @@ fn memset_intrinsic<'a, 'tcx>(\n     count: ValueRef\n ) -> ValueRef {\n     let ccx = bcx.ccx;\n-    let align = C_i32(ccx, ccx.align_of(ty) as i32);\n-    let lltp_ty = type_of::type_of(ccx, ty);\n-    let size = machine::llsize_of(ccx, lltp_ty);\n+    let (size, align) = ccx.size_and_align_of(ty);\n+    let size = C_usize(ccx, size.bytes());\n+    let align = C_i32(ccx, align.abi() as i32);\n     let dst = bcx.pointercast(dst, Type::i8p(ccx));\n     call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n@@ -975,7 +974,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     ret_ty: Ty<'tcx>,\n     llret_ty: Type,\n     span: Span\n-) -> ValueRef {\n+) -> Result<ValueRef, ()> {\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -993,7 +992,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         ($cond: expr, $($fmt: tt)*) => {\n             if !$cond {\n                 emit_error!($($fmt)*);\n-                return C_nil(bcx.ccx)\n+                return Err(());\n             }\n         }\n     }\n@@ -1039,12 +1038,12 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n \n-        return compare_simd_types(bcx,\n-                                  llargs[0],\n-                                  llargs[1],\n-                                  in_elem,\n-                                  llret_ty,\n-                                  cmp_op)\n+        return Ok(compare_simd_types(bcx,\n+                                     llargs[0],\n+                                     llargs[1],\n+                                     in_elem,\n+                                     llret_ty,\n+                                     cmp_op))\n     }\n \n     if name.starts_with(\"simd_shuffle\") {\n@@ -1090,23 +1089,23 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return C_null(llret_ty)\n+            None => return Ok(C_null(llret_ty))\n         };\n \n-        return bcx.shuffle_vector(llargs[0], llargs[1], C_vector(&indices))\n+        return Ok(bcx.shuffle_vector(llargs[0], llargs[1], C_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n         require!(in_elem == arg_tys[2],\n                  \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, arg_tys[2]);\n-        return bcx.insert_element(llargs[0], llargs[2], llargs[1])\n+        return Ok(bcx.insert_element(llargs[0], llargs[2], llargs[1]))\n     }\n     if name == \"simd_extract\" {\n         require!(ret_ty == in_elem,\n                  \"expected return type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, ret_ty);\n-        return bcx.extract_element(llargs[0], llargs[1])\n+        return Ok(bcx.extract_element(llargs[0], llargs[1]))\n     }\n \n     if name == \"simd_cast\" {\n@@ -1120,7 +1119,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // casting cares about nominal type, not just structural type\n         let out_elem = ret_ty.simd_type(tcx);\n \n-        if in_elem == out_elem { return llargs[0]; }\n+        if in_elem == out_elem { return Ok(llargs[0]); }\n \n         enum Style { Float, Int(/* is signed? */ bool), Unsupported }\n \n@@ -1141,36 +1140,36 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n         match (in_style, out_style) {\n             (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return match in_width.cmp(&out_width) {\n+                return Ok(match in_width.cmp(&out_width) {\n                     Ordering::Greater => bcx.trunc(llargs[0], llret_ty),\n                     Ordering::Equal => llargs[0],\n                     Ordering::Less => if in_is_signed {\n                         bcx.sext(llargs[0], llret_ty)\n                     } else {\n                         bcx.zext(llargs[0], llret_ty)\n                     }\n-                }\n+                })\n             }\n             (Style::Int(in_is_signed), Style::Float) => {\n-                return if in_is_signed {\n+                return Ok(if in_is_signed {\n                     bcx.sitofp(llargs[0], llret_ty)\n                 } else {\n                     bcx.uitofp(llargs[0], llret_ty)\n-                }\n+                })\n             }\n             (Style::Float, Style::Int(out_is_signed)) => {\n-                return if out_is_signed {\n+                return Ok(if out_is_signed {\n                     bcx.fptosi(llargs[0], llret_ty)\n                 } else {\n                     bcx.fptoui(llargs[0], llret_ty)\n-                }\n+                })\n             }\n             (Style::Float, Style::Float) => {\n-                return match in_width.cmp(&out_width) {\n+                return Ok(match in_width.cmp(&out_width) {\n                     Ordering::Greater => bcx.fptrunc(llargs[0], llret_ty),\n                     Ordering::Equal => llargs[0],\n                     Ordering::Less => bcx.fpext(llargs[0], llret_ty)\n-                }\n+                })\n             }\n             _ => {/* Unsupported. Fallthrough. */}\n         }\n@@ -1186,7 +1185,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                     match in_elem.sty {\n                         $(\n                             $(ty::$p(_))|* => {\n-                                return bcx.$call(llargs[0], llargs[1])\n+                                return Ok(bcx.$call(llargs[0], llargs[1]))\n                             }\n                             )*\n                         _ => {},\n@@ -1213,15 +1212,13 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     span_bug!(span, \"unknown SIMD intrinsic\");\n }\n \n-// Returns the width of an int TypeVariant, and if it's signed or not\n+// Returns the width of an int Ty, and if it's signed or not\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n-        -> Option<(u64, bool)> {\n-    use rustc::ty::{TyInt, TyUint};\n-    match *sty {\n-        TyInt(t) => Some((match t {\n+fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n+    match ty.sty {\n+        ty::TyInt(t) => Some((match t {\n             ast::IntTy::Is => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n@@ -1236,7 +1233,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::IntTy::I64 => 64,\n             ast::IntTy::I128 => 128,\n         }, true)),\n-        TyUint(t) => Some((match t {\n+        ty::TyUint(t) => Some((match t {\n             ast::UintTy::Us => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,"}, {"sha": "73e03dc0691459a78dfc566c42cf2dee2a8d65c4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -136,7 +136,6 @@ mod declare;\n mod glue;\n mod intrinsic;\n mod llvm_util;\n-mod machine;\n mod metadata;\n mod meth;\n mod mir;"}, {"sha": "bc383abc7e0ecc96aeb18ead69c13991aaa3d55f", "filename": "src/librustc_trans/machine.rs", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9deea47c9605f77d3d595744753704bfd74c0dc9/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deea47c9605f77d3d595744753704bfd74c0dc9/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=9deea47c9605f77d3d595744753704bfd74c0dc9", "patch": "@@ -1,79 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Information concerning the machine representation of various types.\n-\n-#![allow(non_camel_case_types)]\n-\n-use llvm::{self, ValueRef};\n-use common::*;\n-\n-use type_::Type;\n-\n-pub type llbits = u64;\n-pub type llsize = u64;\n-pub type llalign = u32;\n-\n-// ______________________________________________________________________\n-// compute sizeof / alignof\n-\n-// Returns the number of bytes between successive elements of type T in an\n-// array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n-    unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-/// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> llbits {\n-    unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td(), ty.to_ref())\n-    }\n-}\n-\n-/// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n-    // Once upon a time, this called LLVMSizeOf, which does a\n-    // getelementptr(1) on a null pointer and casts to an int, in\n-    // order to obtain the type size as a value without requiring the\n-    // target data layout.  But we have the target data layout, so\n-    // there's no need for that contrivance.  The instruction\n-    // selection DAG generator would flatten that GEP(1) node into a\n-    // constant of the type's alloc size, so let's save it some work.\n-    return C_usize(cx, llsize_of_alloc(cx, ty));\n-}\n-\n-// Returns the preferred alignment of the given type for the current target.\n-// The preferred alignment may be larger than the alignment used when\n-// packing the type into structs. This will be used for things like\n-// allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> llalign {\n-    unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-// Returns the minimum alignment of a type required by the platform.\n-// This is the alignment that will be used for struct fields, arrays,\n-// and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n-    unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n-pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n-    unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td(),\n-                                         struct_ty.to_ref(),\n-                                         element as u32);\n-    }\n-}"}, {"sha": "a2e7eb2258fc186b9c10db8af99d4316b1777b83", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -13,11 +13,11 @@ use callee;\n use common::*;\n use builder::Builder;\n use consts;\n-use machine;\n use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n \n #[derive(Copy, Clone, Debug)]\n@@ -79,10 +79,11 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n \n+    let (size, align) = ccx.size_and_align_of(ty);\n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n-        C_usize(ccx, ccx.size_of(ty)),\n-        C_usize(ccx, ccx.align_of(ty) as u64)\n+        C_usize(ccx, size.bytes()),\n+        C_usize(ccx, align.abi())\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {\n@@ -97,7 +98,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     let vtable_const = C_struct(ccx, &components, false);\n-    let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n+    let align = ccx.data_layout().pointer_align;\n     let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n \n     debuginfo::create_vtable_metadata(ccx, ty, vtable);"}, {"sha": "abd86a5cb01eb12240ae214d68744cb73de83021", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -17,12 +17,11 @@ use rustc::traits;\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n-use base::{self, Lifetime};\n+use base;\n use callee;\n use builder::Builder;\n use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n-use machine::llalign_of_min;\n use meth;\n use monomorphize;\n use type_of;\n@@ -31,8 +30,6 @@ use type_::Type;\n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n-use std::cmp;\n-\n use super::{MirContext, LocalRef};\n use super::constant::Const;\n use super::lvalue::{Alignment, LvalueRef};\n@@ -120,7 +117,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             fn_ty: FnType<'tcx>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n-            destination: Option<(ReturnDest, Ty<'tcx>, mir::BasicBlock)>,\n+            destination: Option<(ReturnDest<'tcx>, Ty<'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -175,14 +172,23 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n-                    let ps = self.get_personality_slot(&bcx);\n-                    let lp = bcx.load(ps, None);\n-                    Lifetime::End.call(&bcx, ps);\n+                    let slot = self.get_personality_slot(&bcx);\n+\n+                    let (lp0ptr, align) = slot.trans_field_ptr(&bcx, 0);\n+                    let lp0 = bcx.load(lp0ptr, align.to_align());\n+\n+                    let (lp1ptr, align) = slot.trans_field_ptr(&bcx, 1);\n+                    let lp1 = bcx.load(lp1ptr, align.to_align());\n+\n+                    slot.storage_dead(&bcx);\n+\n                     if !bcx.sess().target.target.options.custom_unwind_resume {\n+                        let mut lp = C_undef(self.landing_pad_type());\n+                        lp = bcx.insert_value(lp, lp0, 0);\n+                        lp = bcx.insert_value(lp, lp1, 1);\n                         bcx.resume(lp);\n                     } else {\n-                        let exc_ptr = bcx.extract_value(lp, 0);\n-                        bcx.call(bcx.ccx.eh_unwind_resume(), &[exc_ptr], cleanup_bundle);\n+                        bcx.call(bcx.ccx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n                         bcx.unreachable();\n                     }\n                 }\n@@ -245,8 +251,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         }\n                     };\n                     let load = bcx.load(\n-                        bcx.pointercast(llslot, cast_ty.ptr_to()),\n-                        Some(ret.layout.align(bcx.ccx).abi() as u32));\n+                        bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n+                        Some(ret.layout.align(bcx.ccx)));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n@@ -336,6 +342,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n                 let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n+                let align = tcx.data_layout.aggregate_align\n+                    .max(tcx.data_layout.i32_align)\n+                    .max(tcx.data_layout.pointer_align);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -351,7 +360,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 }));\n \n                         let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line_col));\n                         let file_line_col = consts::addr_of(bcx.ccx,\n                                                             file_line_col,\n                                                             align,\n@@ -366,7 +374,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let msg_file_line_col = C_struct(bcx.ccx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n                         let msg_file_line_col = consts::addr_of(bcx.ccx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -387,7 +394,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let msg_file_line_col = C_struct(bcx.ccx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n                         let msg_file_line_col = consts::addr_of(bcx.ccx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -552,7 +558,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         ReturnDest::Nothing => {\n                             (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n                         }\n-                        ReturnDest::IndirectOperand(dst, _) |\n+                        ReturnDest::IndirectOperand(dst, _) => (dst.llval, &llargs[..]),\n                         ReturnDest::Store(dst) => (dst, &llargs[..]),\n                         ReturnDest::DirectOperand(_) =>\n                             bug!(\"Cannot use direct operand with an intrinsic call\")\n@@ -566,7 +572,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                         // Make a fake operand for store_return\n                         let op = OperandRef {\n-                            val: Ref(dst, Alignment::AbiAligned),\n+                            val: Ref(dst.llval, Alignment::AbiAligned),\n                             ty: sig.output(),\n                         };\n                         self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n@@ -633,7 +639,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty));\n+            llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n         }\n \n         if arg.is_ignore() {\n@@ -651,13 +657,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n                 }\n             }\n-            Ref(llval, Alignment::Packed) if arg.is_indirect() => {\n+            Ref(llval, align @ Alignment::Packed) if arg.is_indirect() => {\n                 // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n                 let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n-                base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n+                base::memcpy_ty(bcx, llscratch, llval, op.ty, align.to_align());\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n             Ref(llval, align) => (llval, align, true)\n@@ -670,8 +676,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n                 llval = bcx.trunc(llval, Type::i1(bcx.ccx));\n             } else if let Some(ty) = arg.cast {\n-                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()),\n-                                 align.min_with(arg.layout.align(bcx.ccx).abi() as u32));\n+                llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n+                                 align.min_with(Some(arg.layout.align(bcx.ccx))));\n             } else {\n                 llval = bcx.load(llval, align.to_align());\n             }\n@@ -759,14 +765,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     }\n \n-    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n-        if let Some(slot) = self.llpersonalityslot {\n+        if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.alloca(llretty, \"personalityslot\", None);\n-            self.llpersonalityslot = Some(slot);\n+            let ty = ccx.tcx().intern_tup(&[\n+                ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n+                ccx.tcx().types.i32\n+            ], false);\n+            let slot = LvalueRef::alloca(bcx, ty, \"personalityslot\");\n+            self.personality_slot = Some(slot);\n             slot\n         }\n     }\n@@ -794,16 +803,26 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n-        let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n-        bcx.set_cleanup(llretval);\n+        let llretty = self.landing_pad_type();\n+        let lp = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n+        bcx.set_cleanup(lp);\n+\n         let slot = self.get_personality_slot(&bcx);\n-        Lifetime::Start.call(&bcx, slot);\n-        bcx.store(llretval, slot, None);\n+        slot.storage_live(&bcx);\n+        self.store_operand(&bcx, slot.llval, None, OperandRef {\n+            val: Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)),\n+            ty: slot.ty.to_ty(ccx.tcx())\n+        });\n+\n         bcx.br(target_bb);\n         bcx.llbb()\n     }\n \n+    fn landing_pad_type(&self) -> Type {\n+        let ccx = self.ccx;\n+        Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false)\n+    }\n+\n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n             let bl = self.new_block(\"unreachable\");\n@@ -825,7 +844,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n-                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n+                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n+                        -> ReturnDest<'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret_ty.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -841,14 +861,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n                         let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        tmp.storage_live(bcx);\n                         llargs.push(tmp.llval);\n-                        ReturnDest::IndirectOperand(tmp.llval, index)\n+                        ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n                         let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n-                        ReturnDest::IndirectOperand(tmp.llval, index)\n+                        tmp.storage_live(bcx);\n+                        ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n                     };\n@@ -891,8 +913,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(dst);\n                     assert!(!lvalue_ty.has_erasable_regions());\n                     let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"transmute_temp\");\n+                    lvalue.storage_live(bcx);\n                     self.trans_transmute_into(bcx, src, &lvalue);\n                     let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n+                    lvalue.storage_dead(bcx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n                 LocalRef::Operand(Some(_)) => {\n@@ -915,15 +939,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());\n-        let llalign = cmp::min(bcx.ccx.align_of(in_type), bcx.ccx.align_of(out_type));\n-        self.store_operand(bcx, cast_ptr, Some(llalign), val);\n+        let align = bcx.ccx.align_of(in_type).min(bcx.ccx.align_of(out_type));\n+        self.store_operand(bcx, cast_ptr, Some(align), val);\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bcx: &Builder<'a, 'tcx>,\n-                    dest: ReturnDest,\n+                    dest: ReturnDest<'tcx>,\n                     ret_ty: &ArgType<'tcx>,\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n@@ -932,15 +956,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Nothing => (),\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, index) => {\n-                let op = self.trans_load(bcx, tmp, Alignment::AbiAligned, op.ty);\n+                let op = self.trans_load(bcx, tmp.llval, Alignment::AbiAligned, op.ty);\n+                tmp.storage_dead(bcx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n                     let tmp = LvalueRef::alloca(bcx, op.ty, \"tmp_ret\");\n+                    tmp.storage_live(bcx);\n                     ret_ty.store(bcx, op.immediate(), tmp.llval);\n-                    self.trans_load(bcx, tmp.llval, tmp.alignment, op.ty)\n+                    let op = self.trans_load(bcx, tmp.llval, tmp.alignment, op.ty);\n+                    tmp.storage_dead(bcx);\n+                    op\n                 } else {\n                     op.unpack_if_pair(bcx)\n                 };\n@@ -950,13 +978,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n }\n \n-enum ReturnDest {\n+enum ReturnDest<'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n     Store(ValueRef),\n     // Stores an indirect return value to an operand local lvalue\n-    IndirectOperand(ValueRef, mir::Local),\n+    IndirectOperand(LvalueRef<'tcx>, mir::Local),\n     // Stores a direct return value to an operand local lvalue\n     DirectOperand(mir::Local)\n }"}, {"sha": "57c131a106b3bfb3bb01727cb71dbf9418f1fef9", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 65, "deletions": 72, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -18,12 +18,12 @@ use rustc::traits;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, LayoutTyper, Size};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {adt, base, machine};\n+use {adt, base};\n use abi::{self, Abi};\n use callee;\n use builder::Builder;\n@@ -100,9 +100,11 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n+            ConstVal::ByteStr(v) => {\n+                consts::addr_of(ccx, C_bytes(ccx, v.data), ccx.align_of(ty), \"byte_str\")\n+            }\n             ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n-            ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n+            ConstVal::Function(..) => C_null(llty),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) |\n             ConstVal::Unevaluated(..) => {\n@@ -368,12 +370,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n                                     let llval = C_usize(self.ccx,\n-                                        self.ccx.size_of(substs.type_at(0)));\n+                                        self.ccx.size_of(substs.type_at(0)).bytes());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n                                     let llval = C_usize(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)) as u64);\n+                                        self.ccx.align_of(substs.type_at(0)).abi());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -590,7 +592,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 self.const_array(dest_ty, &fields)\n             }\n \n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+            mir::Rvalue::Aggregate(box mir::AggregateKind::Array(_), ref operands) => {\n                 // Make sure to evaluate all operands to\n                 // report as many errors as we possibly can.\n                 let mut fields = Vec::with_capacity(operands.len());\n@@ -603,17 +605,23 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                match **kind {\n-                    mir::AggregateKind::Array(_) => {\n-                        self.const_array(dest_ty, &fields)\n-                    }\n-                    mir::AggregateKind::Adt(..) |\n-                    mir::AggregateKind::Closure(..) |\n-                    mir::AggregateKind::Generator(..) |\n-                    mir::AggregateKind::Tuple => {\n-                        Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n+                self.const_array(dest_ty, &fields)\n+            }\n+\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                // Make sure to evaluate all operands to\n+                // report as many errors as we possibly can.\n+                let mut fields = Vec::with_capacity(operands.len());\n+                let mut failure = Ok(());\n+                for operand in operands {\n+                    match self.const_operand(operand, span) {\n+                        Ok(val) => fields.push(val),\n+                        Err(err) => if failure.is_ok() { failure = Err(err); }\n                     }\n                 }\n+                failure?;\n+\n+                trans_const_adt(self.ccx, dest_ty, kind, &fields)\n             }\n \n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -780,7 +788,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let align = if self.ccx.shared().type_is_sized(ty) {\n                             self.ccx.align_of(ty)\n                         } else {\n-                            self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n+                            self.ccx.tcx().data_layout.pointer_align\n                         };\n                         if bk == mir::BorrowKind::Mut {\n                             consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n@@ -860,7 +868,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_usize(self.ccx, self.ccx.size_of(ty));\n+                let llval = C_usize(self.ccx, self.ccx.size_of(ty).bytes());\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -1099,12 +1107,12 @@ pub fn trans_static_initializer<'a, 'tcx>(\n /// Currently the returned value has the same size as the type, but\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n-fn trans_const<'a, 'tcx>(\n+fn trans_const_adt<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     t: Ty<'tcx>,\n     kind: &mir::AggregateKind,\n-    vals: &[ValueRef]\n-) -> ValueRef {\n+    vals: &[Const<'tcx>]\n+) -> Const<'tcx> {\n     let l = ccx.layout_of(t);\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n@@ -1121,112 +1129,97 @@ fn trans_const<'a, 'tcx>(\n             };\n             assert_eq!(vals.len(), 0);\n             adt::assert_discr_in_range(min, max, discr);\n-            C_int(Type::from_integer(ccx, d), discr as i64)\n+            Const::new(C_int(Type::from_integer(ccx, d), discr as i64), t)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];\n             let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n-            let mut vals_with_discr = vec![lldiscr];\n+            let mut vals_with_discr = vec![\n+                Const::new(lldiscr, d.to_ty(ccx.tcx(), false))\n+            ];\n             vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(ccx).bytes() - variant.stride().bytes();\n-            if needed_padding > 0 {\n-                contents.push(padding(ccx, needed_padding));\n-            }\n-            C_struct(ccx, &contents[..], false)\n+            build_const_struct(ccx, l, &variant, &vals_with_discr)\n         }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             assert_eq!(variant_index, 0);\n-            let contents = build_const_union(ccx, variants, vals[0]);\n-            C_struct(ccx, &contents, variants.packed)\n+            let mut contents = vec![vals[0].llval];\n+\n+            let offset = ccx.size_of(vals[0].ty);\n+            let size = variants.stride();\n+            if offset != size {\n+                contents.push(padding(ccx, size - offset));\n+            }\n+\n+            Const::new(C_struct(ccx, &contents, variants.packed), t)\n         }\n         layout::Univariant { ref variant, .. } => {\n             assert_eq!(variant_index, 0);\n-            let contents = build_const_struct(ccx, &variant, vals);\n-            C_struct(ccx, &contents[..], variant.packed)\n+            build_const_struct(ccx, l, &variant, vals)\n         }\n         layout::Vector { .. } => {\n-            C_vector(vals)\n+            Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n                 assert_eq!(vals.len(), 1);\n-                vals[0]\n+                Const::new(vals[0].llval, t)\n             } else {\n-                C_null(type_of::type_of(ccx, t))\n+                Const::new(C_null(type_of::type_of(ccx, t)), t)\n             }\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n+                build_const_struct(ccx, l, &nonnull, vals)\n             } else {\n                 // Always use null even if it's not the `discrfield`th\n                 // field; see #8506.\n-                C_null(type_of::type_of(ccx, t))\n+                Const::new(C_null(type_of::type_of(ccx, t)), t)\n             }\n         }\n-        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n+        _ => bug!(\"trans_const_adt: cannot handle type {} repreented as {:#?}\", t, l)\n     }\n }\n \n /// Building structs is a little complicated, because we might need to\n /// insert padding if a field's value is less aligned than its type.\n ///\n-/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// Continuing the example from `trans_const_adt`, a value of type `(u32,\n /// E)` should have the `E` at offset 8, but if that field's\n /// initializer is 4-byte aligned then simply translating the tuple as\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                layout: layout::TyLayout<'tcx>,\n                                 st: &layout::Struct,\n-                                vals: &[ValueRef])\n-                                -> Vec<ValueRef> {\n+                                vals: &[Const<'tcx>])\n+                                -> Const<'tcx> {\n     assert_eq!(vals.len(), st.offsets.len());\n \n-    if vals.len() == 0 {\n-        return Vec::new();\n-    }\n-\n     // offset of current value\n-    let mut offset = 0;\n+    let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n     cfields.reserve(st.offsets.len()*2);\n \n     let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (&vals[i], st.offsets[i].bytes())\n+        (vals[i], st.offsets[i])\n     });\n-    for (&val, target_offset) in parts {\n+    for (val, target_offset) in parts {\n         if offset < target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n-            offset = target_offset;\n         }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n-    }\n-\n-    if offset < st.stride().bytes() {\n-        cfields.push(padding(ccx, st.stride().bytes() - offset));\n+        assert!(!is_undef(val.llval));\n+        cfields.push(val.llval);\n+        offset = target_offset + ccx.size_of(val.ty);\n     }\n \n-    cfields\n-}\n-\n-fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &layout::Union,\n-                               field_val: ValueRef)\n-                               -> Vec<ValueRef> {\n-    let mut cfields = vec![field_val];\n-\n-    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = un.stride().bytes();\n-    if offset != size {\n+    let size = layout.size(ccx);\n+    if offset < size {\n         cfields.push(padding(ccx, size - offset));\n     }\n \n-    cfields\n+    Const::new(C_struct(ccx, &cfields, st.packed), layout.ty)\n }\n \n-fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size))\n+fn padding(ccx: &CrateContext, size: Size) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size.bytes()))\n }"}, {"sha": "376d42c71adfee3523f47fb7ecb9f874bf40a6fc", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::{self, Align, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -19,7 +19,6 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, C_usize, C_u8, C_i32, C_int, C_null, val_ty};\n use consts;\n-use machine;\n use type_of;\n use type_::Type;\n use value::Value;\n@@ -56,18 +55,15 @@ impl Alignment {\n         }\n     }\n \n-    pub fn to_align(self) -> Option<u32> {\n+    pub fn to_align(self) -> Option<Align> {\n         match self {\n-            Alignment::Packed => Some(1),\n+            Alignment::Packed => Some(Align::from_bytes(1, 1).unwrap()),\n             Alignment::AbiAligned => None,\n         }\n     }\n \n-    pub fn min_with(self, align: u32) -> Option<u32> {\n-        match self {\n-            Alignment::Packed => Some(1),\n-            Alignment::AbiAligned => Some(align),\n-        }\n+    pub fn min_with(self, align: Option<Align>) -> Option<Align> {\n+        self.to_align().or(align)\n     }\n }\n \n@@ -153,7 +149,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.d., Result of Either with (), as one side.)\n                 let ty = type_of::type_of(ccx, fty);\n-                assert_eq!(machine::llsize_of_alloc(ccx, ty), 0);\n+                assert_eq!(ccx.size_of(fty).bytes(), 0);\n                 return (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed);\n             }\n             layout::RawNullablePointer { .. } => {\n@@ -174,7 +170,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let ptr_val = if let layout::General { discr, .. } = *l {\n             let variant_ty = Type::struct_(ccx,\n                 &adt::struct_llfields(ccx, l.ty, l.variant_index.unwrap(), st,\n-                                      Some(discr.to_ty(&bcx.tcx(), false))), st.packed);\n+                                      Some(discr.to_ty(bcx.tcx(), false))), st.packed);\n             bcx.pointercast(self.llval, variant_ty.ptr_to())\n         } else {\n             self.llval\n@@ -374,6 +370,14 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             bcx.inbounds_gep(self.llval, &[zero, llindex])\n         }\n     }\n+\n+    pub fn storage_live(&self, bcx: &Builder<'a, 'tcx>) {\n+        bcx.lifetime_start(self.llval, bcx.ccx.size_of(self.ty.to_ty(bcx.tcx())));\n+    }\n+\n+    pub fn storage_dead(&self, bcx: &Builder<'a, 'tcx>) {\n+        bcx.lifetime_end(self.llval, bcx.ccx.size_of(self.ty.to_ty(bcx.tcx())));\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -432,7 +436,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n                         let index = self.trans_operand(bcx, index);\n-                        let llindex = self.prepare_index(bcx, index.immediate());\n+                        let llindex = index.immediate();\n                         ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n@@ -487,22 +491,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         result\n     }\n \n-    /// Adjust the bitwidth of an index since LLVM is less forgiving\n-    /// than we are.\n-    ///\n-    /// nmatsakis: is this still necessary? Not sure.\n-    fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n-        let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.isize_ty());\n-        if index_size < int_size {\n-            bcx.zext(llindex, bcx.ccx.isize_ty())\n-        } else if index_size > int_size {\n-            bcx.trunc(llindex, bcx.ccx.isize_ty())\n-        } else {\n-            llindex\n-        }\n-    }\n-\n     pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         let tcx = self.ccx.tcx();\n         let lvalue_ty = lvalue.ty(self.mir, tcx);"}, {"sha": "1cb13c973f9b86b405679316fce463dc146a4889", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -61,7 +61,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    llpersonalityslot: Option<ValueRef>,\n+    personality_slot: Option<LvalueRef<'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n@@ -177,9 +177,8 @@ enum LocalRef<'tcx> {\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n-impl<'tcx> LocalRef<'tcx> {\n-    fn new_operand<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                       ty: Ty<'tcx>) -> LocalRef<'tcx> {\n+impl<'a, 'tcx> LocalRef<'tcx> {\n+    fn new_operand(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> LocalRef<'tcx> {\n         if common::type_is_zero_size(ccx, ty) {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -232,7 +231,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         llfn,\n         fn_ty,\n         ccx,\n-        llpersonalityslot: None,\n+        personality_slot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds,\n@@ -470,7 +469,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                assert_eq!((meta.cast, meta.pad), (None, None));\n+                assert!(meta.cast.is_none() && meta.pad.is_none());\n                 let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n "}, {"sha": "47350d0712544faa8b3d8cb8106915a655a64d75", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n+use rustc::ty::layout::{Align, Layout, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn store_operand(&mut self,\n                          bcx: &Builder<'a, 'tcx>,\n                          lldest: ValueRef,\n-                         align: Option<u32>,\n+                         align: Option<Align>,\n                          operand: OperandRef<'tcx>) {\n         debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n@@ -319,10 +319,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return;\n         }\n         match operand.val {\n-            OperandValue::Ref(r, Alignment::Packed) =>\n-                base::memcpy_ty(bcx, lldest, r, operand.ty, Some(1)),\n-            OperandValue::Ref(r, Alignment::AbiAligned) =>\n-                base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n+            OperandValue::Ref(r, source_align) =>\n+                base::memcpy_ty(bcx, lldest, r, operand.ty,\n+                                source_align.min_with(align)),\n             OperandValue::Immediate(s) => {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }\n@@ -331,7 +330,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     Layout::Univariant { ref variant, .. } => {\n                         (adt::struct_llfields_index(variant, 0),\n                         adt::struct_llfields_index(variant, 1),\n-                        if variant.packed { Some(1) } else { None })\n+                        if variant.packed { Some(variant.align) } else { None })\n                     }\n                     _ => (0, 1, align)\n                 };"}, {"sha": "7e4b7235750318831d53c2b92d572abde10abc4c", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -22,10 +22,10 @@ use std::{u128, i128};\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n+use common::{self, val_ty};\n+use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n use consts;\n use adt;\n-use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n@@ -104,33 +104,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.as_u64();\n-                let size = C_usize(bcx.ccx, size);\n+                let count = count.as_u64();\n+                let count = C_usize(bcx.ccx, count);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 let align = dest.alignment.to_align();\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n+                    let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                    let align = C_i32(bcx.ccx, align.abi() as i32);\n+                    let size = C_usize(bcx.ccx, bcx.ccx.size_of(dest_ty).bytes());\n+\n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n-                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n-                        let align = C_i32(bcx.ccx, align as i32);\n-                        let ty = type_of::type_of(bcx.ccx, dest_ty);\n-                        let size = machine::llsize_of(bcx.ccx, ty);\n-                        let fill = C_uint(Type::i8(bcx.ccx), 0);\n+                        let fill = C_u8(bcx.ccx, 0);\n                         base::call_memset(&bcx, base, fill, size, align, false);\n                         return bcx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     if common::val_ty(v) == Type::i8(bcx.ccx) {\n-                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n-                        let align = C_i32(bcx.ccx, align as i32);\n                         base::call_memset(&bcx, base, v, size, align, false);\n                         return bcx;\n                     }\n                 }\n \n-                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n+                tvec::slice_for_each(&bcx, base, tr_elem.ty, count, |bcx, llslot, loop_bb| {\n                     self.store_operand(bcx, llslot, align, tr_elem);\n                     bcx.br(loop_bb);\n                 })\n@@ -459,7 +457,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty));\n+                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty).bytes());\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -469,12 +467,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let llty = type_of::type_of(bcx.ccx, content_ty);\n-                let llsize = machine::llsize_of(bcx.ccx, llty);\n-                let align = bcx.ccx.align_of(content_ty);\n-                let llalign = C_usize(bcx.ccx, align as u64);\n-                let llty_ptr = llty.ptr_to();\n+                let (size, align) = bcx.ccx.size_and_align_of(content_ty);\n+                let llsize = C_usize(bcx.ccx, size.bytes());\n+                let llalign = C_usize(bcx.ccx, align.abi());\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n+                let llty_ptr = type_of::type_of(bcx.ccx, box_ty);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {"}, {"sha": "2559b21c46b0643e3933ccd65392becf05ce39b9", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::mir;\n \n-use base;\n use asm;\n use common;\n use builder::Builder;\n@@ -63,10 +62,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n             mir::StatementKind::StorageLive(local) => {\n-                self.trans_storage_liveness(bcx, local, base::Lifetime::Start)\n+                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                    tr_lval.storage_live(&bcx);\n+                }\n+                bcx\n             }\n             mir::StatementKind::StorageDead(local) => {\n-                self.trans_storage_liveness(bcx, local, base::Lifetime::End)\n+                if let LocalRef::Lvalue(tr_lval) = self.locals[local] {\n+                    tr_lval.storage_dead(&bcx);\n+                }\n+                bcx\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n@@ -86,15 +91,4 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::StatementKind::Nop => bcx,\n         }\n     }\n-\n-    fn trans_storage_liveness(&self,\n-                              bcx: Builder<'a, 'tcx>,\n-                              index: mir::Local,\n-                              intrinsic: base::Lifetime)\n-                              -> Builder<'a, 'tcx> {\n-        if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n-            intrinsic.call(&bcx, tr_lval.llval);\n-        }\n-        bcx\n-    }\n }"}, {"sha": "f74aec07087c72e64d31f4e67067cb389ab25527", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -11,9 +11,8 @@\n use abi::FnType;\n use adt;\n use common::*;\n-use machine;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::LayoutTyper;\n+use rustc::ty::layout::{Align, LayoutTyper, Size};\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -212,19 +211,26 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n-    pub fn align_of(&self, ty: Ty<'tcx>) -> machine::llalign {\n-        self.layout_of(ty).align(self).abi() as machine::llalign\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align(self)\n     }\n \n-    pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n-        self.layout_of(ty).size(self).bytes() as machine::llsize\n+    pub fn size_of(&self, ty: Ty<'tcx>) -> Size {\n+        self.layout_of(ty).size(self)\n     }\n \n-    pub fn over_align_of(&self, t: Ty<'tcx>)\n-                              -> Option<machine::llalign> {\n+    pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, Align) {\n+        let layout = self.layout_of(ty);\n+        (layout.size(self), layout.align(self))\n+    }\n+\n+    /// Returns alignment if it is different than the primitive alignment.\n+    pub fn over_align_of(&self, t: Ty<'tcx>) -> Option<Align> {\n         let layout = self.layout_of(t);\n-        if let Some(align) = layout.over_align(&self.tcx().data_layout) {\n-            Some(align as machine::llalign)\n+        let align = layout.align(self);\n+        let primitive_align = layout.primitive_align(self);\n+        if align != primitive_align {\n+            Some(align)\n         } else {\n             None\n         }"}, {"sha": "c8d974febf23ec38c5ad8855a6b722768c716772", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f44b0991879f5e379573d3f2fa1d702c923729f9/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f44b0991879f5e379573d3f2fa1d702c923729f9", "patch": "@@ -257,21 +257,18 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n \n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n-                        LLVMAtomicOrdering Order, unsigned Alignment) {\n+                        LLVMAtomicOrdering Order) {\n   LoadInst *LI = new LoadInst(unwrap(Source), 0);\n   LI->setAtomic(fromRust(Order));\n-  LI->setAlignment(Alignment);\n   return wrap(unwrap(B)->Insert(LI, Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n                                                  LLVMValueRef V,\n                                                  LLVMValueRef Target,\n-                                                 LLVMAtomicOrdering Order,\n-                                                 unsigned Alignment) {\n+                                                 LLVMAtomicOrdering Order) {\n   StoreInst *SI = new StoreInst(unwrap(V), unwrap(Target));\n   SI->setAtomic(fromRust(Order));\n-  SI->setAlignment(Alignment);\n   return wrap(unwrap(B)->Insert(SI));\n }\n "}]}