{"sha": "1473a663188e9a8642abb700a23fa40369ba8e15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzNhNjYzMTg4ZTlhODY0MmFiYjcwMGEyM2ZhNDAzNjliYThlMTU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-07T23:03:43Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-04T16:53:15Z"}, "message": "Suggest restricting type param when it doesn't satisfy projection\n\nWhen encountering a projection that isn't satisfied by a type parameter,\nsuggest constraining the type parameter.", "tree": {"sha": "4c092be881ca9f7602a61b2279dcbb1539fa8f60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c092be881ca9f7602a61b2279dcbb1539fa8f60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1473a663188e9a8642abb700a23fa40369ba8e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1473a663188e9a8642abb700a23fa40369ba8e15", "html_url": "https://github.com/rust-lang/rust/commit/1473a663188e9a8642abb700a23fa40369ba8e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1473a663188e9a8642abb700a23fa40369ba8e15/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75f066dc687e9a40e193ff059491b208a98291aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f066dc687e9a40e193ff059491b208a98291aa", "html_url": "https://github.com/rust-lang/rust/commit/75f066dc687e9a40e193ff059491b208a98291aa"}], "stats": {"total": 552, "additions": 358, "deletions": 194}, "files": [{"sha": "613d66d59c55bc81e8c8dfa6a6e5321be675333b", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 183, "deletions": 1, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -2,7 +2,12 @@\n \n use crate::ty::sty::InferTy;\n use crate::ty::TyKind::*;\n-use crate::ty::TyS;\n+use crate::ty::{TyCtxt, TyS};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_span::{BytePos, Span};\n \n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n@@ -67,3 +72,180 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    def_id: Option<DefId>,\n+) -> bool {\n+    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+\n+    let param = if let Some(param) = param {\n+        param\n+    } else {\n+        return false;\n+    };\n+\n+    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n+    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n+    let msg_restrict_type_further =\n+        format!(\"consider further restricting type parameter `{}`\", param_name);\n+\n+    if def_id == tcx.lang_items().sized_trait() {\n+        // Type parameters are already `Sized` by default.\n+        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n+        return true;\n+    }\n+    let mut suggest_restrict = |span| {\n+        err.span_suggestion_verbose(\n+            span,\n+            MSG_RESTRICT_BOUND_FURTHER,\n+            format!(\" + {}\", constraint),\n+            Applicability::MachineApplicable,\n+        );\n+    };\n+\n+    if param_name.starts_with(\"impl \") {\n+        // If there's an `impl Trait` used in argument position, suggest\n+        // restricting it:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             replace with: `impl Foo + Bar`\n+\n+        suggest_restrict(param.span.shrink_to_hi());\n+        return true;\n+    }\n+\n+    if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+    {\n+        if let Some(bounds_span) = param.bounds_span() {\n+            // If user has provided some bounds, suggest restricting them:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //             ---\n+            //             |\n+            //             help: consider further restricting this bound with `+ Bar`\n+            //\n+            // Suggestion for tools in this case is:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //          --\n+            //          |\n+            //          replace with: `T: Bar +`\n+            suggest_restrict(bounds_span.shrink_to_hi());\n+        } else {\n+            // If user hasn't provided any bounds, suggest adding a new one:\n+            //\n+            //   fn foo<T>(t: T) { ... }\n+            //          - help: consider restricting this type parameter with `T: Foo`\n+            err.span_suggestion_verbose(\n+                param.span.shrink_to_hi(),\n+                &msg_restrict_type,\n+                format!(\": {}\", constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        true\n+    } else {\n+        // This part is a bit tricky, because using the `where` clause user can\n+        // provide zero, one or many bounds for the same type parameter, so we\n+        // have following cases to consider:\n+        //\n+        // 1) When the type parameter has been provided zero bounds\n+        //\n+        //    Message:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //             - help: consider restricting this type parameter with `where X: Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //                                           - insert: `, X: Bar`\n+        //\n+        //\n+        // 2) When the type parameter has been provided one bound\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^\n+        //                            |\n+        //                            replace with: `T: Bar +`\n+        //\n+        //\n+        // 3) When the type parameter has been provided many bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //                                          - insert: `, T: Zar`\n+\n+        let mut param_spans = Vec::new();\n+\n+        for predicate in generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                span, bounded_ty, ..\n+            }) = predicate\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                    if let Some(segment) = path.segments.first() {\n+                        if segment.ident.to_string() == param_name {\n+                            param_spans.push(span);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n+        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n+        let mut trailing_comma = false;\n+        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n+            trailing_comma = snippet.ends_with(',');\n+        }\n+        let where_clause_span = if trailing_comma {\n+            let hi = where_clause_span.hi();\n+            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n+        } else {\n+            where_clause_span.shrink_to_hi()\n+        };\n+\n+        match &param_spans[..] {\n+            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+            _ => {\n+                err.span_suggestion_verbose(\n+                    where_clause_span,\n+                    &msg_restrict_type_further,\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        true\n+    }\n+}"}, {"sha": "329fd928c8717f398c2083f9ab9d0cb9a7aeac5d", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -1,4 +1,5 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n@@ -401,8 +402,43 @@ impl<'tcx> TyCtxt<'tcx> {\n                     (ty::Projection(_), ty::Projection(_)) => {\n                         db.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(_), ty::Projection(_)) | (ty::Projection(_), ty::Param(_)) => {\n-                        db.note(\"you might be missing a type parameter or trait bound\");\n+                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n+                        if !sp.contains(p_span) {\n+                            db.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = self.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = hir\n+                            .as_local_hir_id(generics.type_param(p, self).def_id)\n+                            .and_then(|id| self.hir().find(self.hir().get_parent_node(id)))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let trait_ref = proj.trait_ref(self);\n+                            let path =\n+                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = self.item_name(proj.item_def_id);\n+                            let path = if path.ends_with('>') {\n+                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                            } else {\n+                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                self,\n+                                generics,\n+                                db,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            db.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n                     }\n                     (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n                     | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {"}, {"sha": "14a094b9d5273f6fefa7796001c68729144d3df1", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::mir::{\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};"}, {"sha": "19ed6b50f92a624ba00d7082927edbce4b6d17ac", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 182, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -15,17 +15,16 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::{Node, QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::SubtypePredicate;\n use rustc_middle::ty::{\n-    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n+    TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::{BytePos, ExpnKind, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1700,180 +1699,3 @@ impl ArgKind {\n         }\n     }\n }\n-\n-/// Suggest restricting a type param with a new bound.\n-pub fn suggest_constraining_type_param(\n-    tcx: TyCtxt<'_>,\n-    generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n-    param_name: &str,\n-    constraint: &str,\n-    def_id: Option<DefId>,\n-) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n-\n-    let param = if let Some(param) = param {\n-        param\n-    } else {\n-        return false;\n-    };\n-\n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n-\n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n-\n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n-\n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(bounds_span) = param.bounds_span() {\n-            // If user has provided some bounds, suggest restricting them:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(bounds_span.shrink_to_hi());\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-\n-        let mut param_spans = Vec::new();\n-\n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n-        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n-        let mut trailing_comma = false;\n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n-            trailing_comma = snippet.ends_with(',');\n-        }\n-        let where_clause_span = if trailing_comma {\n-            let hi = where_clause_span.hi();\n-            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n-        } else {\n-            where_clause_span.shrink_to_hi()\n-        };\n-\n-        match &param_spans[..] {\n-            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-            _ => {\n-                err.span_suggestion_verbose(\n-                    where_clause_span,\n-                    &msg_restrict_type_further,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "74dd47a91c2790e9b86bb840fd55aa1ef0defe59", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -3,7 +3,6 @@ use super::{\n };\n \n use crate::infer::InferCtxt;\n-use crate::traits::error_reporting::suggest_constraining_type_param;\n \n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n@@ -13,7 +12,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n+    TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};"}, {"sha": "89a6b98cd8f529c2ec27a59bb64e7fbea4effa87", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`"}, {"sha": "b9468b3330b44e5b4a794fe2a7b2824b837dbe34", "filename": "src/test/ui/generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -2,11 +2,16 @@ error[E0271]: type mismatch resolving `for<'a> <<T as Baz>::Baa<'a> as std::ops:\n   --> $DIR/construct_with_other_type.rs:19:9\n    |\n LL | impl<T> Baz for T where T: Foo {\n-   |         ^^^ expected type parameter `T`, found associated type\n+   |      -  ^^^ expected type parameter `T`, found associated type\n+   |      |\n+   |      this type parameter\n    |\n    = note: expected associated type `<T as Foo>::Bar<'_, 'static>`\n               found associated type `<<T as Baz>::Quux<'_> as Foo>::Bar<'_, 'static>`\n-   = note: you might be missing a type parameter or trait bound\n+help: consider further restricting this bound\n+   |\n+LL | impl<T> Baz for T where T: Foo + Baz<Quux = T> {\n+   |                                ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c2e619d1a7e276b61b342d8a22cee9e34449aa2a", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1852ef62fe6ec5f3be9fbd9070d28f3df0a04d80", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "630ceac093ef29764728918fdc1b96b2b78362ee", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -0,0 +1,49 @@\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:11:11\n+   |\n+LL | impl<B> Add for A<B> where B: Add {\n+   |      - this type parameter\n+...\n+LL |         A(self.0 + rhs.0)\n+   |           ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:21:14\n+   |\n+LL | impl<B: Add> Add for C<B> {\n+   |      - this type parameter\n+...\n+LL |         Self(self.0 + rhs.0)\n+   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0369]: cannot add `B` to `B`\n+  --> $DIR/missing-bounds.rs:31:21\n+   |\n+LL |         Self(self.0 + rhs.0)\n+   |              ------ ^ ----- B\n+   |              |\n+   |              B\n+   |\n+help: consider restricting type parameter `B`\n+   |\n+LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "d5cbcf786bf1abfe5426869412c4f3fd01871c89", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1473a663188e9a8642abb700a23fa40369ba8e15/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=1473a663188e9a8642abb700a23fa40369ba8e15", "patch": "@@ -7,7 +7,9 @@ LL |     type A: MultiDispatch<Self::B, O = Self>;\n    |                                    -------- required by this bound in `Trait`\n ...\n LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   |            ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         -  ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         |\n+   |         this type parameter\n    |\n    = note: expected type parameter `T`\n              found associated type `<<T as Trait>::A as MultiDispatch<i32>>::O`"}]}