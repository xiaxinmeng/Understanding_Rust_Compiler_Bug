{"sha": "ddbb27a2414db79bef0a5858b440b04b545c80fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYmIyN2EyNDE0ZGI3OWJlZjBhNTg1OGI0NDBiMDRiNTQ1YzgwZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-11T16:43:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-11T16:43:40Z"}, "message": "Auto merge of #46558 - arielb1:union-borrow-refactor, r=nikomatsakis\n\nClean up the MIR borrowck code\n\nI want to avoid the new code to start with so much technical debt.\n\nr? @nikomatsakis", "tree": {"sha": "210829b4271f7bfa755c22db8fbc08e136c0dc0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/210829b4271f7bfa755c22db8fbc08e136c0dc0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddbb27a2414db79bef0a5858b440b04b545c80fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbb27a2414db79bef0a5858b440b04b545c80fa", "html_url": "https://github.com/rust-lang/rust/commit/ddbb27a2414db79bef0a5858b440b04b545c80fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddbb27a2414db79bef0a5858b440b04b545c80fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33245fe682874fd138bb6d49b9e5d72e5b915800", "url": "https://api.github.com/repos/rust-lang/rust/commits/33245fe682874fd138bb6d49b9e5d72e5b915800", "html_url": "https://github.com/rust-lang/rust/commit/33245fe682874fd138bb6d49b9e5d72e5b915800"}, {"sha": "e798cb0e52e505ed759f8af01e90a758858b115d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e798cb0e52e505ed759f8af01e90a758858b115d", "html_url": "https://github.com/rust-lang/rust/commit/e798cb0e52e505ed759f8af01e90a758858b115d"}], "stats": {"total": 2694, "additions": 1358, "deletions": 1336}, "files": [{"sha": "e4d2d7228c25620318d3ab8695c539de1a80cefe", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -0,0 +1,574 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::Span;\n+use rustc::mir::{BorrowKind, Field, Local, Location, Operand};\n+use rustc::mir::{Place, ProjectionElem, Rvalue, StatementKind};\n+use rustc::ty;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use super::{MirBorrowckCtxt, Context};\n+use super::{InitializationRequiringAction, PrefixSet};\n+use dataflow::{BorrowData, Borrows, FlowAtLocation, MovingOutStatements};\n+use dataflow::move_paths::MovePathIndex;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    pub(super) fn report_use_of_moved_or_uninitialized(\n+        &mut self,\n+        _context: Context,\n+        desired_action: InitializationRequiringAction,\n+        (place, span): (&Place<'tcx>, Span),\n+        mpi: MovePathIndex,\n+        curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n+    ) {\n+        let mois = self.move_data.path_map[mpi]\n+            .iter()\n+            .filter(|moi| curr_move_out.contains(moi))\n+            .collect::<Vec<_>>();\n+\n+        if mois.is_empty() {\n+            let item_msg = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            self.tcx\n+                .cannot_act_on_uninitialized_variable(\n+                    span,\n+                    desired_action.as_noun(),\n+                    &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                    Origin::Mir,\n+                )\n+                .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n+                .emit();\n+        } else {\n+            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n+\n+            let mut err = self.tcx.cannot_act_on_moved_value(\n+                span,\n+                desired_action.as_noun(),\n+                msg,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            );\n+\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"value {} here after move\",\n+                    desired_action.as_verb_in_past_tense()\n+                ),\n+            );\n+            for moi in mois {\n+                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n+                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n+                if span == move_span {\n+                    err.span_label(\n+                        span,\n+                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n+                    );\n+                } else {\n+                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                };\n+            }\n+            //FIXME: add note for closure\n+            err.emit();\n+        }\n+    }\n+\n+    pub(super) fn report_move_out_while_borrowed(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        let value_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+        let borrow_msg = match self.describe_place(&borrow.place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+        self.tcx\n+            .cannot_move_when_borrowed(\n+                span,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            )\n+            .span_label(\n+                self.retrieve_borrow_span(borrow),\n+                format!(\"borrow of {} occurs here\", borrow_msg),\n+            )\n+            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n+            .emit();\n+    }\n+\n+    pub(super) fn report_use_while_mutably_borrowed(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            self.retrieve_borrow_span(borrow),\n+            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        err.emit();\n+    }\n+\n+    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n+    /// the local assigned at `location`.\n+    /// This is done by searching in statements succeeding `location`\n+    /// and originating from `maybe_closure_span`.\n+    fn find_closure_span(\n+        &self,\n+        maybe_closure_span: Span,\n+        location: Location,\n+    ) -> Option<(Span, Span)> {\n+        use rustc::hir::ExprClosure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = if let StatementKind::Assign(Place::Local(local), _) =\n+            self.mir[location.block].statements[location.statement_index].kind\n+        {\n+            local\n+        } else {\n+            return None;\n+        };\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if maybe_closure_span != stmt.source_info.span {\n+                break;\n+            }\n+\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_span: found closure {:?}\", places);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return None;\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, place) in freevars.iter().zip(places) {\n+                                    match *place {\n+                                        Operand::Copy(Place::Local(l)) |\n+                                        Operand::Move(Place::Local(l)) if local == l =>\n+                                        {\n+                                            debug!(\n+                                                \"find_closure_span: found captured local {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                None\n+                            })\n+                            .map(|var_span| (args_span, var_span))\n+                    } else {\n+                        None\n+                    };\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub(super) fn report_conflicting_borrow(\n+        &mut self,\n+        context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        gen_borrow_kind: BorrowKind,\n+        issued_borrow: &BorrowData,\n+        end_issued_loan_span: Option<Span>,\n+    ) {\n+        let issued_span = self.retrieve_borrow_span(issued_borrow);\n+\n+        let new_closure_span = self.find_closure_span(span, context.loc);\n+        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n+        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n+        let issued_span = old_closure_span\n+            .map(|(args, _)| args)\n+            .unwrap_or(issued_span);\n+\n+        let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (\n+            gen_borrow_kind,\n+            \"immutable\",\n+            \"mutable\",\n+            issued_borrow.kind,\n+            \"immutable\",\n+            \"mutable\",\n+        ) {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+                .cannot_reborrow_already_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"it\",\n+                    rgt,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) => self.tcx\n+                .cannot_mutably_borrow_multiply(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_uniquely_borrow_by_two_closures(\n+                    span,\n+                    &desc_place,\n+                    issued_span,\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n+                span,\n+                &desc_place,\n+                \"\",\n+                issued_span,\n+                \"it\",\n+                \"\",\n+                end_issued_loan_span,\n+                Origin::Mir,\n+            ),\n+\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n+        };\n+\n+        if let Some((_, var_span)) = old_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\n+                    \"previous borrow occurs due to use of `{}` in closure\",\n+                    desc_place\n+                ),\n+            );\n+        }\n+\n+        if let Some((_, var_span)) = new_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+            );\n+        }\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_borrowed_value_does_not_live_long_enough(\n+        &mut self,\n+        _: Context,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrows: &Borrows<'cx, 'gcx, 'tcx>\n+    ) {\n+        let end_span = borrows.opt_region_end_span(&borrow.region);\n+        let root_place = self.prefixes(&borrow.place, PrefixSet::All).last().unwrap();\n+\n+        match root_place {\n+            &Place::Local(local) => {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported_l.replace(local) {\n+                    debug!(\"report_does_not_live_long_enough({:?}): <suppressed>\",\n+                           (borrow, drop_span));\n+                    return\n+                }\n+            }\n+            &Place::Static(ref statik) => {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported_s\n+                    .replace(statik.def_id)\n+                {\n+                    debug!(\"report_does_not_live_long_enough({:?}): <suppressed>\",\n+                           (borrow, drop_span));\n+                    return\n+                }\n+            },\n+            &Place::Projection(_) =>\n+                unreachable!(\"root_place is an unreachable???\")\n+        };\n+\n+        let proper_span = match *root_place {\n+            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n+            _ => drop_span,\n+        };\n+\n+        let mut err = self.tcx\n+            .path_does_not_live_long_enough(drop_span, \"borrowed value\", Origin::Mir);\n+        err.span_label(proper_span, \"temporary value created here\");\n+        err.span_label(drop_span, \"temporary value dropped here while still borrowed\");\n+        err.note(\"consider using a `let` binding to increase its lifetime\");\n+\n+        if let Some(end) = end_span {\n+            err.span_label(end, \"temporary value needs to live until here\");\n+        }\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_illegal_mutation_of_borrowed(\n+        &mut self,\n+        _: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        loan: &BorrowData,\n+    ) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span,\n+            self.retrieve_borrow_span(loan),\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_illegal_reassignment(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        assigned_span: Span,\n+    ) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+        err.span_label(span, \"cannot assign twice to immutable variable\");\n+        if span != assigned_span {\n+            let value_msg = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n+        }\n+        err.emit();\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    // End-user visible description of `place` if one can be found. If the\n+    // place is a temporary for instance, None will be returned.\n+    pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n+        let mut buf = String::new();\n+        match self.append_place_to_string(place, &mut buf, false) {\n+            Ok(()) => Some(buf),\n+            Err(()) => None,\n+        }\n+    }\n+\n+    // Appends end-user visible description of `place` to `buf`.\n+    fn append_place_to_string(\n+        &self,\n+        place: &Place<'tcx>,\n+        buf: &mut String,\n+        mut autoderef: bool,\n+    ) -> Result<(), ()> {\n+        match *place {\n+            Place::Local(local) => {\n+                self.append_local_to_string(local, buf)?;\n+            }\n+            Place::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Place::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            if self.mir.upvar_decls[var_index].by_ref {\n+                                buf.push_str(&name);\n+                            } else {\n+                                buf.push_str(&format!(\"*{}\", &name));\n+                            }\n+                        } else {\n+                            if autoderef {\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            } else {\n+                                buf.push_str(&\"*\");\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            }\n+                        }\n+                    }\n+                    ProjectionElem::Downcast(..) => {\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                    }\n+                    ProjectionElem::Field(field, _ty) => {\n+                        autoderef = true;\n+\n+                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            buf.push_str(&name);\n+                        } else {\n+                            let field_name = self.describe_field(&proj.base, field);\n+                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            buf.push_str(&format!(\".{}\", field_name));\n+                        }\n+                    }\n+                    ProjectionElem::Index(index) => {\n+                        autoderef = true;\n+\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        buf.push_str(\"[\");\n+                        if let Err(_) = self.append_local_to_string(index, buf) {\n+                            buf.push_str(\"..\");\n+                        }\n+                        buf.push_str(\"]\");\n+                    }\n+                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                        autoderef = true;\n+                        // Since it isn't possible to borrow an element on a particular index and\n+                        // then use another while the borrow is held, don't output indices details\n+                        // to avoid confusing the end-user\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        buf.push_str(&\"[..]\");\n+                    }\n+                };\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n+    // a name, then `Err` is returned\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n+        let local = &self.mir.local_decls[local_index];\n+        match local.name {\n+            Some(name) => {\n+                buf.push_str(&format!(\"{}\", name));\n+                Ok(())\n+            }\n+            None => Err(()),\n+        }\n+    }\n+\n+    // End-user visible description of the `field`nth field of `base`\n+    fn describe_field(&self, base: &Place, field: Field) -> String {\n+        match *base {\n+            Place::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                self.describe_field_from_ty(&local.ty, field)\n+            }\n+            Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Deref => self.describe_field(&proj.base, field),\n+                ProjectionElem::Downcast(def, variant_index) => {\n+                    format!(\"{}\", def.variants[variant_index].fields[field.index()].name)\n+                }\n+                ProjectionElem::Field(_, field_type) => {\n+                    self.describe_field_from_ty(&field_type, field)\n+                }\n+                ProjectionElem::Index(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Subslice { .. } => {\n+                    format!(\"{}\", self.describe_field(&proj.base, field))\n+                }\n+            },\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `ty`\n+    fn describe_field_from_ty(&self, ty: &ty::Ty, field: Field) -> String {\n+        if ty.is_box() {\n+            // If the type is a box, the field is described from the boxed type\n+            self.describe_field_from_ty(&ty.boxed_ty(), field)\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, _) => if def.is_enum() {\n+                    format!(\"{}\", field.index())\n+                } else {\n+                    format!(\"{}\", def.struct_variant().fields[field.index()].name)\n+                },\n+                ty::TyTuple(_, _) => format!(\"{}\", field.index()),\n+                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n+                    self.describe_field_from_ty(&tnm.ty, field)\n+                }\n+                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::TyClosure(closure_def_id, _) => {\n+                    // Convert the def-id into a node-id. node-ids are only valid for\n+                    // the local code in the current crate, so this returns an `Option` in case\n+                    // the closure comes from another crate. But in that case we wouldn't\n+                    // be borrowck'ing it, so we can just unwrap:\n+                    let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n+                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+\n+                    self.tcx.hir.name(freevar.var_id()).to_string()\n+                }\n+                _ => {\n+                    // Might need a revision when the fields in trait RFC is implemented\n+                    // (https://github.com/rust-lang/rfcs/pull/1546)\n+                    bug!(\n+                        \"End-user description not implemented for field access on `{:?}`\",\n+                        ty.sty\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    // Retrieve span of given borrow from the current MIR representation\n+    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+        self.mir.source_info(borrow.location).span\n+    }\n+}"}, {"sha": "449062989e07ed2f1831c25c06a890afc384eed1", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Manages the dataflow bits required for borrowck.\n+//!\n+//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n+//! but is not as ugly as it is right now.\n+\n+use rustc::mir::{BasicBlock, Location};\n+\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{Borrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::move_paths::HasMoveData;\n+use std::fmt;\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+    pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+}\n+\n+impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n+    pub fn new(\n+        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+        inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+        uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    ) -> Self {\n+        Flows {\n+            borrows,\n+            inits,\n+            uninits,\n+            move_outs,\n+            ever_inits,\n+        }\n+    }\n+}\n+\n+macro_rules! each_flow {\n+    ($this:ident, $meth:ident($arg:ident)) => {\n+        FlowAtLocation::$meth(&mut $this.borrows, $arg);\n+        FlowAtLocation::$meth(&mut $this.inits, $arg);\n+        FlowAtLocation::$meth(&mut $this.uninits, $arg);\n+        FlowAtLocation::$meth(&mut $this.move_outs, $arg);\n+        FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n+    }\n+}\n+\n+impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        each_flow!(self, reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, location: Location) {\n+        each_flow!(self, reconstruct_statement_effect(location));\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, location: Location) {\n+        each_flow!(self, reconstruct_terminator_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self, location: Location) {\n+        each_flow!(self, apply_local_effect(location));\n+    }\n+}\n+\n+impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path = &self.inits.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"move_out: [\");\n+        let mut saw_one = false;\n+        self.move_outs.each_state_bit(|mpi_move_out| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_out = &self.move_outs.operator().move_data().moves[mpi_move_out];\n+            s.push_str(&format!(\"{:?}\", move_out));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"ever_init: [\");\n+        let mut saw_one = false;\n+        self.ever_inits.each_state_bit(|mpi_ever_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let ever_init =\n+                &self.ever_inits.operator().move_data().inits[mpi_ever_init];\n+            s.push_str(&format!(\"{:?}\", ever_init));\n+        });\n+        s.push_str(\"]\");\n+\n+        fmt::Display::fmt(&s, fmt)\n+    }\n+}"}, {"sha": "358f96abe72e886f9904fe261990d75efea6e0ba", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 195, "deletions": 1269, "changes": 1464, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -22,27 +22,32 @@ use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_set::{IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n \n use syntax::ast;\n use syntax_pos::Span;\n \n use dataflow::do_dataflow;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::DataflowResultsConsumer;\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n use dataflow::{BorrowData, BorrowIndex, Borrows};\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n-use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveOutIndex, MovePathIndex};\n+use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n-use std::fmt;\n use std::iter;\n \n+use self::flows::Flows;\n+use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+mod error_reporting;\n+mod flows;\n+mod prefixes;\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -145,7 +150,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n \n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-    let mut flow_inits = FlowInProgress::new(do_dataflow(\n+    let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -154,7 +159,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeInitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n     ));\n-    let flow_uninits = FlowInProgress::new(do_dataflow(\n+    let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -163,7 +168,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n     ));\n-    let flow_move_outs = FlowInProgress::new(do_dataflow(\n+    let flow_move_outs = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -172,7 +177,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MovingOutStatements::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().moves[i],\n     ));\n-    let flow_ever_inits = FlowInProgress::new(do_dataflow(\n+    let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -200,21 +205,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n-    let mut mbcx = MirBorrowckCtxt {\n-        tcx: tcx,\n-        mir: mir,\n-        node_id: id,\n-        move_data: &mdpe.move_data,\n-        param_env: param_env,\n-        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n-            hir::BodyOwnerKind::Const |\n-            hir::BodyOwnerKind::Static(_) => false,\n-            hir::BodyOwnerKind::Fn => true,\n-        },\n-        storage_dead_or_drop_error_reported: FxHashSet(),\n-    };\n-\n-    let flow_borrows = FlowInProgress::new(do_dataflow(\n+    let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -224,13 +215,27 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| bd.location(i),\n     ));\n \n-    let mut state = InProgress::new(\n+    let mut state = Flows::new(\n         flow_borrows,\n         flow_inits,\n         flow_uninits,\n         flow_move_outs,\n         flow_ever_inits,\n     );\n+    let mut mbcx = MirBorrowckCtxt {\n+        tcx: tcx,\n+        mir: mir,\n+        node_id: id,\n+        move_data: &mdpe.move_data,\n+        param_env: param_env,\n+        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n+            hir::BodyOwnerKind::Const |\n+            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Fn => true,\n+        },\n+        storage_dead_or_drop_error_reported_l: FxHashSet(),\n+        storage_dead_or_drop_error_reported_s: FxHashSet(),\n+    };\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n@@ -254,26 +259,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// This field keeps track of when storage dead or drop errors are reported\n     /// in order to stop duplicate error reporting and identify the conditions required\n     /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n-    storage_dead_or_drop_error_reported: FxHashSet<Local>,\n-}\n-\n-// (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-    inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-    move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-    ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-}\n-\n-struct FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: IdxSetBuf<BD::Idx>,\n-    stmt_kill: IdxSetBuf<BD::Idx>,\n+    storage_dead_or_drop_error_reported_l: FxHashSet<Local>,\n+    /// Same as the above, but for statics (thread-locals)\n+    storage_dead_or_drop_error_reported_s: FxHashSet<DefId>,\n }\n \n // Check that:\n@@ -282,60 +270,12 @@ where\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    type FlowState = InProgress<'cx, 'gcx, 'tcx>;\n+    type FlowState = Flows<'cx, 'gcx, 'tcx>;\n \n     fn mir(&self) -> &'cx Mir<'tcx> {\n         self.mir\n     }\n \n-    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(\n-            |b| b.reset_to_entry_of(bb),\n-            |i| i.reset_to_entry_of(bb),\n-            |u| u.reset_to_entry_of(bb),\n-            |m| m.reset_to_entry_of(bb),\n-            |e| e.reset_to_entry_of(bb),\n-        );\n-    }\n-\n-    fn reconstruct_statement_effect(\n-        &mut self,\n-        location: Location,\n-        flow_state: &mut Self::FlowState,\n-    ) {\n-        flow_state.each_flow(\n-            |b| b.reconstruct_statement_effect(location),\n-            |i| i.reconstruct_statement_effect(location),\n-            |u| u.reconstruct_statement_effect(location),\n-            |m| m.reconstruct_statement_effect(location),\n-            |e| e.reconstruct_statement_effect(location),\n-        );\n-    }\n-\n-    fn apply_local_effect(&mut self, _location: Location, flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(\n-            |b| b.apply_local_effect(),\n-            |i| i.apply_local_effect(),\n-            |u| u.apply_local_effect(),\n-            |m| m.apply_local_effect(),\n-            |e| e.apply_local_effect(),\n-        );\n-    }\n-\n-    fn reconstruct_terminator_effect(\n-        &mut self,\n-        location: Location,\n-        flow_state: &mut Self::FlowState,\n-    ) {\n-        flow_state.each_flow(\n-            |b| b.reconstruct_terminator_effect(location),\n-            |i| i.reconstruct_terminator_effect(location),\n-            |u| u.reconstruct_terminator_effect(location),\n-            |m| m.reconstruct_terminator_effect(location),\n-            |e| e.reconstruct_terminator_effect(location),\n-        );\n-    }\n-\n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n         debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n     }\n@@ -560,24 +500,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // Often, the storage will already have been killed by an explicit\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n-                let domain = flow_state.borrows.base_results.operator();\n+                let domain = flow_state.borrows.operator();\n                 let data = domain.borrows();\n                 flow_state.borrows.with_elems_outgoing(|borrows| {\n                     for i in borrows {\n                         let borrow = &data[i];\n+                        let context = ContextKind::StorageDead.new(loc);\n \n-                        if self.place_is_invalidated_at_exit(&borrow.place) {\n-                            debug!(\"borrow conflicts at exit {:?}\", borrow);\n-                            // FIXME: should be talking about the region lifetime instead\n-                            // of just a span here.\n-                            let end_span = domain.opt_region_end_span(&borrow.region);\n-\n-                            self.report_borrowed_value_does_not_live_long_enough(\n-                                ContextKind::StorageDead.new(loc),\n-                            (&borrow.place, end_span.unwrap_or(span)),\n-                                end_span,\n-                            )\n-                        }\n+                        self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n                     }\n                 });\n             }\n@@ -668,11 +598,19 @@ enum WriteKind {\n /// - Take flow state into consideration in `is_assignable()` for local variables\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n-    Move,\n     Yes,\n+    /// We want use of immutable upvars to cause a \"write to immutable upvar\"\n+    /// error, not an \"reassignment\" error.\n+    ExceptUpvars,\n     No\n }\n \n+struct AccessErrorsReported {\n+    mutability_error: bool,\n+    #[allow(dead_code)]\n+    conflict_error: bool\n+}\n+\n #[derive(Copy, Clone)]\n enum InitializationRequiringAction {\n     Update,\n@@ -714,26 +652,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: (ShallowOrDeep, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n-    ) {\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) -> AccessErrorsReported {\n         let (sd, rw) = kind;\n \n-        let storage_dead_or_drop_local = match (place_span.0, rw) {\n-            (&Place::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n-            _ => None,\n-        };\n-\n-        // Check if error has already been reported to stop duplicate reporting.\n-        if let Some(local) = storage_dead_or_drop_local {\n-            if self.storage_dead_or_drop_error_reported.contains(&local) {\n-                return;\n-            }\n-        }\n-\n-        // Check permissions\n-        let mut error_reported =\n+        let mutability_error =\n             self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n+        let conflict_error =\n+            self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n+        AccessErrorsReported { mutability_error, conflict_error }\n+    }\n+\n+    fn check_access_for_conflict(\n+        &mut self,\n+        context: Context,\n+        place_span: (&Place<'tcx>, Span),\n+        sd: ShallowOrDeep,\n+        rw: ReadOrWrite,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) -> bool {\n+        let mut error_reported = false;\n         self.each_borrow_involving_path(\n             context,\n             (sd, place_span.0),\n@@ -749,7 +688,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         ReadKind::Borrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n-                                .base_results\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n@@ -769,7 +707,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::MutableBorrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n-                                .base_results\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n@@ -782,17 +719,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             )\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n-                            let end_span = flow_state\n-                                .borrows\n-                                .base_results\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context,\n-                                place_span,\n-                                end_span,\n-                            )\n+                                context, borrow, place_span.1, flow_state.borrows.operator());\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -808,11 +737,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             },\n         );\n \n-        if error_reported {\n-            if let Some(local) = storage_dead_or_drop_local {\n-                self.storage_dead_or_drop_error_reported.insert(local);\n-            }\n-        }\n+        error_reported\n     }\n \n     fn mutate_place(\n@@ -821,7 +746,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: ShallowOrDeep,\n         mode: MutateMode,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n@@ -838,24 +763,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.access_place(\n+        let errors_reported = self.access_place(\n             context,\n             place_span,\n             (kind, Write(WriteKind::Mutate)),\n-            LocalMutationIsAllowed::Yes,\n+            // We want immutable upvars to cause an \"assignment to immutable var\"\n+            // error, not an \"reassignment of immutable var\" error, because the\n+            // latter can't find a good previous assignment span.\n+            //\n+            // There's probably a better way to do this.\n+            LocalMutationIsAllowed::ExceptUpvars,\n             flow_state,\n         );\n \n-        // check for reassignments to immutable local variables\n-        self.check_if_reassignment_to_immutable_state(context, place_span, flow_state);\n+        if !errors_reported.mutability_error {\n+            // check for reassignments to immutable local variables\n+            self.check_if_reassignment_to_immutable_state(context, place_span, flow_state);\n+        }\n     }\n \n     fn consume_rvalue(\n         &mut self,\n         context: Context,\n         (rvalue, span): (&Rvalue<'tcx>, Span),\n         _location: Location,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n@@ -932,7 +864,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (operand, span): (&Operand<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n@@ -960,7 +892,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     context,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n-                    LocalMutationIsAllowed::Move,\n+                    LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n \n@@ -978,16 +910,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn place_is_invalidated_at_exit(&mut self, place: &Place<'tcx>) -> bool {\n-        debug!(\"place_is_invalidated_at_exit({:?})\", place);\n+    fn check_for_invalidation_at_exit(&mut self,\n+                                      context: Context,\n+                                      borrow: &BorrowData<'tcx>,\n+                                      span: Span,\n+                                      flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+    {\n+        debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n+        let place = &borrow.place;\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n-        let (might_be_alive, will_be_dropped, local) = match root_place {\n+        let (might_be_alive, will_be_dropped) = match root_place {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n@@ -996,12 +934,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n \n-                (true, is_thread_local, None)\n+                (true, is_thread_local)\n             }\n-            Place::Local(local) => {\n+            Place::Local(_) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n-                (false, self.locals_are_invalidated_at_exit, Some(*local))\n+                (false, self.locals_are_invalidated_at_exit)\n             }\n             Place::Projection(..) => {\n                 bug!(\"root of {:?} is a projection ({:?})?\", place, root_place)\n@@ -1013,30 +951,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 \"place_is_invalidated_at_exit({:?}) - won't be dropped\",\n                 place\n             );\n-            return false;\n+            return;\n         }\n \n         // FIXME: replace this with a proper borrow_conflicts_with_place when\n         // that is merged.\n-        let prefix_set = if might_be_alive {\n-            PrefixSet::Supporting\n+        let sd = if might_be_alive {\n+            Deep\n         } else {\n-            PrefixSet::Shallow\n+            Shallow(None)\n         };\n \n-        let result =\n-            self.prefixes(place, prefix_set).any(|prefix| prefix == root_place);\n-\n-        if result {\n-            if let Some(local) = local {\n-                if let Some(_) = self.storage_dead_or_drop_error_reported.replace(local) {\n-                    debug!(\"place_is_invalidated_at_exit({:?}) - suppressed\", place);\n-                    return false;\n-                }\n-            }\n+        if self.places_conflict(place, root_place, sd) {\n+            debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n+            // FIXME: should be talking about the region lifetime instead\n+            // of just a span here.\n+            self.report_borrowed_value_does_not_live_long_enough(\n+                context,\n+                borrow,\n+                span.end_point(),\n+                flow_state.borrows.operator()\n+            )\n         }\n-\n-        result\n     }\n }\n \n@@ -1045,40 +981,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        let move_data = self.move_data;\n-\n+        debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n         if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n+        debug!(\"check_if_reassignment_to_immutable_state({:?}) - is an imm local\", place);\n \n-        if let Err(_) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n-            return;\n-        }\n-\n-        match self.move_path_closest_to(place) {\n-            Ok(mpi) => for ii in &move_data.init_path_map[mpi] {\n-                if flow_state.ever_inits.curr_state.contains(ii) {\n-                    let first_assign_span = self.move_data.inits[*ii].span;\n-                    self.report_illegal_reassignment(context, (place, span), first_assign_span);\n-                    break;\n-                }\n-            },\n-            Err(NoMovePathFound::ReachedStatic) => {\n-                let item_msg = match self.describe_place(place) {\n-                    Some(name) => format!(\"immutable static item `{}`\", name),\n-                    None => \"immutable static item\".to_owned(),\n-                };\n-                self.tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\n-                        \"cannot assign to {}, should have been caught by \\\n-                         `check_access_permissions()`\",\n-                        item_msg\n-                    ),\n-                );\n+        for i in flow_state.ever_inits.elems_incoming() {\n+            let init = self.move_data.inits[i];\n+            let init_place = &self.move_data.move_paths[init.path].place;\n+            if self.places_conflict(&init_place, place, Deep) {\n+                self.report_illegal_reassignment(context, (place, span), init.span);\n+                break;\n             }\n         }\n     }\n@@ -1088,14 +1005,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path ... but is that what we want here?\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs.curr_state;\n+        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1136,7 +1053,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_if_path_is_moved part1 place: {:?}\", place);\n         match self.move_path_closest_to(place) {\n             Ok(mpi) => {\n-                if maybe_uninits.curr_state.contains(&mpi) {\n+                if maybe_uninits.contains(&mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n                         context,\n                         desired_action,\n@@ -1222,7 +1139,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // recur down place; dispatch to check_if_path_is_moved when necessary\n         let mut place = place;\n@@ -1301,7 +1218,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut error_reported = false;\n         match kind {\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n-                if let Err(_place_err) = self.is_unique(place) {\n+                if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n@@ -1383,7 +1300,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes |\n-                        LocalMutationIsAllowed::Move => Ok(()),\n+                        LocalMutationIsAllowed::ExceptUpvars => Ok(()),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1408,25 +1325,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        match self.is_upvar_field_projection(&proj.base) {\n+                                        let mode = match\n+                                            self.is_upvar_field_projection(&proj.base)\n+                                        {\n                                             Some(field) if {\n                                                 self.mir.upvar_decls[field.index()].by_ref\n-                                            } => {\n-                                                self.is_mutable(&proj.base,\n-                                                                is_local_mutation_allowed)\n-                                            }\n-                                            _ => self.is_unique(&proj.base)\n-                                        }\n+                                            } => is_local_mutation_allowed,\n+                                            _ => LocalMutationIsAllowed::Yes\n+                                        };\n+\n+                                        self.is_mutable(&proj.base, mode)\n                                     }\n                                 }\n                             }\n                             ty::TyRawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::MutImmutable => return Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of context\n                                     // The users have to check by themselve.\n-                                    hir::MutMutable => Ok(()),\n+                                    hir::MutMutable => return Ok(()),\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n@@ -1444,81 +1362,50 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::ConstantIndex { .. } |\n                     ProjectionElem::Subslice { .. } |\n                     ProjectionElem::Downcast(..) => {\n-                        let field_projection = self.is_upvar_field_projection(place);\n-\n-                        if let Some(field) = field_projection {\n+                        if let Some(field) = self.is_upvar_field_projection(place) {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n                                    decl, is_local_mutation_allowed, place);\n-                            return match (decl.mutability, is_local_mutation_allowed) {\n+                            match (decl.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No) |\n-                                (Mutability::Not, LocalMutationIsAllowed::Yes) => Err(place),\n-                                (Mutability::Not, LocalMutationIsAllowed::Move) |\n-                                (Mutability::Mut, _) => self.is_unique(&proj.base),\n-                            };\n+                                (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars)\n+                                    => Err(place),\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes) |\n+                                (Mutability::Mut, _) =>\n+                                    self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                            }\n+                        } else {\n+                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n                         }\n-\n-                        self.is_mutable(&proj.base, is_local_mutation_allowed)\n                     }\n                 }\n             }\n         }\n     }\n \n-    /// Does this place have a unique path\n-    fn is_unique<'d>(&self, place: &'d Place<'tcx>) -> Result<(), &'d Place<'tcx>> {\n-        match *place {\n-            Place::Local(..) => {\n-                // Local variables are unique\n-                Ok(())\n-            }\n-            Place::Static(ref static_) => {\n-                if !self.tcx.is_static_mut(static_.def_id) {\n-                    Err(place)\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n-                        // `Box<T>` referent is unique if box is a unique spot\n-                        if base_ty.is_box() {\n-                            return self.is_unique(&proj.base);\n-                        }\n+    /// If this is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        match *place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let is_projection_from_ty_closure = proj.base\n+                        .ty(self.mir, self.tcx)\n+                        .to_ty(self.tcx)\n+                        .is_closure();\n \n-                        // Otherwise we check the kind of deref to decide\n-                        match base_ty.sty {\n-                            ty::TyRef(_, tnm) => {\n-                                match tnm.mutbl {\n-                                    // place represent an aliased location\n-                                    hir::MutImmutable => Err(place),\n-                                    // `&mut T` is as unique as the context in which it is found\n-                                    hir::MutMutable => self.is_unique(&proj.base),\n-                                }\n-                            }\n-                            ty::TyRawPtr(tnm) => {\n-                                match tnm.mutbl {\n-                                    // `*mut` can be aliased, but we leave it to user\n-                                    hir::MutMutable => Ok(()),\n-                                    // `*const` is treated the same as `*mut`\n-                                    hir::MutImmutable => Ok(()),\n-                                }\n-                            }\n-                            // Deref should only be for reference, pointers or boxes\n-                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n-                        }\n+                    if is_projection_from_ty_closure {\n+                        Some(field)\n+                    } else {\n+                        None\n                     }\n-                    // Other projections are unique if the base is unique\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Downcast(..) => self.is_unique(&proj.base),\n                 }\n-            }\n+                _ => None,\n+            },\n+            _ => None,\n         }\n     }\n }\n@@ -1567,10 +1454,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Overlap::Disjoint\n                 }\n             }\n-            (Place::Static(..), Place::Static(..)) => {\n-                // Borrows of statics do not have to be tracked here.\n-                debug!(\"place_element_conflict: IGNORED-STATIC\");\n-                Overlap::Disjoint\n+            (Place::Static(static1), Place::Static(static2)) => {\n+                if static1.def_id != static2.def_id {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                    Overlap::Disjoint\n+                } else if self.tcx.is_static_mut(static1.def_id) {\n+                    // We ignore mutable statics - they can only be unsafe code.\n+                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                    Overlap::Disjoint\n+                } else {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                    Overlap::EqualOrDisjoint\n+                }\n             }\n             (Place::Local(_), Place::Static(_)) |\n             (Place::Static(_), Place::Local(_)) => {\n@@ -1682,13 +1577,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-    fn borrow_conflicts_with_place(&mut self,\n-                                    borrow: &BorrowData<'tcx>,\n-                                    place: &Place<'tcx>,\n-                                    access: ShallowOrDeep)\n-                                    -> bool\n+\n+    /// Returns whether an access of kind `access` to `access_place` conflicts with\n+    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n+    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n+    fn places_conflict(&mut self,\n+                       borrow_place: &Place<'tcx>,\n+                       access_place: &Place<'tcx>,\n+                       access: ShallowOrDeep)\n+                       -> bool\n     {\n-        debug!(\"borrow_conflicts_with_place({:?},{:?},{:?})\", borrow, place, access);\n+        debug!(\"places_conflict({:?},{:?},{:?})\", borrow_place, access_place, access);\n \n         // Return all the prefixes of `place` in reverse order, including\n         // downcasts.\n@@ -1710,9 +1609,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        let borrow_components = place_elements(&borrow.place);\n-        let access_components = place_elements(place);\n-        debug!(\"borrow_conflicts_with_place: components {:?} / {:?}\",\n+        let borrow_components = place_elements(borrow_place);\n+        let access_components = place_elements(access_place);\n+        debug!(\"places_conflict: components {:?} / {:?}\",\n                borrow_components, access_components);\n \n         let borrow_components = borrow_components.into_iter()\n@@ -1762,7 +1661,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //  - If we did run out of accesss, the borrow can access a part of it.\n         for (borrow_c, access_c) in borrow_components.zip(access_components) {\n             // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-            debug!(\"borrow_conflicts_with_place: {:?} vs. {:?}\", borrow_c, access_c);\n+            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n             match (borrow_c, access_c) {\n                 (None, _) => {\n                     // If we didn't run out of access, the borrow can access all of our\n@@ -1775,7 +1674,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     //\n                     // FIXME: Differs from AST-borrowck; includes drive-by fix\n                     // to #38899. Will probably need back-compat mode flag.\n-                    debug!(\"borrow_conflict_with_place: full borrow, CONFLICT\");\n+                    debug!(\"places_conflict: full borrow, CONFLICT\");\n                     return true;\n                 }\n                 (Some(borrow_c), None) => {\n@@ -1800,15 +1699,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             //\n                             // e.g. a (mutable) borrow of `a[5]` while we read the\n                             // array length of `a`.\n-                            debug!(\"borrow_conflicts_with_place: implicit field\");\n+                            debug!(\"places_conflict: implicit field\");\n                             return false;\n                         }\n \n                         (ProjectionElem::Deref, _, Shallow(None)) => {\n                             // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n                             // prefix thereof - the shallow access can't touch anything behind\n                             // the pointer.\n-                            debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                            debug!(\"places_conflict: shallow access behind ptr\");\n                             return false;\n                         }\n                         (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n@@ -1819,7 +1718,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // I'm not sure why we are tracking these borrows - shared\n                             // references can *always* be aliased, which means the\n                             // permission check already account for this borrow.\n-                            debug!(\"borrow_conflicts_with_place: behind a shared ref\");\n+                            debug!(\"places_conflict: behind a shared ref\");\n                             return false;\n                         }\n \n@@ -1852,7 +1751,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // idea, at least for now, so just give up and\n                             // report a conflict. This is unsafe code anyway so\n                             // the user could always use raw pointers.\n-                            debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                            debug!(\"places_conflict: arbitrary -> conflict\");\n                             return true;\n                         }\n                         Overlap::EqualOrDisjoint => {\n@@ -1861,7 +1760,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Overlap::Disjoint => {\n                             // We have proven the borrow disjoint - further\n                             // projections will remain disjoint.\n-                            debug!(\"borrow_conflicts_with_place: disjoint\");\n+                            debug!(\"places_conflict: disjoint\");\n                             return false;\n                         }\n                     }\n@@ -1876,7 +1775,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n         F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n@@ -1886,754 +1785,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n-        let domain = flow_state.borrows.base_results.operator();\n-        let data = domain.borrows();\n+        let data = flow_state.borrows.operator().borrows();\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        'next_borrow: for i in flow_state.borrows.elems_incoming() {\n+        for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            if self.borrow_conflicts_with_place(borrowed, place, access) {\n+            if self.places_conflict(&borrowed.place, place, access) {\n                 let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break { return; }\n             }\n         }\n     }\n }\n \n-use self::prefixes::PrefixSet;\n-\n-/// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n-/// place are formed by stripping away fields and derefs, except that\n-/// we stop when we reach the deref of a shared reference. [...] \"\n-///\n-/// \"Shallow prefixes are found by stripping away fields, but stop at\n-/// any dereference. So: writing a path like `a` is illegal if `a.b`\n-/// is borrowed. But: writing `a` is legal if `*a` is borrowed,\n-/// whether or not `a` is a shared or mutable reference. [...] \"\n-mod prefixes {\n-    use super::MirBorrowckCtxt;\n-\n-    use rustc::hir;\n-    use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Mir, Place, ProjectionElem};\n-\n-    pub trait IsPrefixOf<'tcx> {\n-        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n-    }\n-\n-    impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n-        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n-            let mut cursor = other;\n-            loop {\n-                if self == cursor {\n-                    return true;\n-                }\n-\n-                match *cursor {\n-                    Place::Local(_) | Place::Static(_) => return false,\n-                    Place::Projection(ref proj) => {\n-                        cursor = &proj.base;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-        mir: &'cx Mir<'tcx>,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        kind: PrefixSet,\n-        next: Option<&'cx Place<'tcx>>,\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-    #[allow(dead_code)]\n-    pub(super) enum PrefixSet {\n-        /// Doesn't stop until it returns the base case (a Local or\n-        /// Static prefix).\n-        All,\n-        /// Stops at any dereference.\n-        Shallow,\n-        /// Stops at the deref of a shared reference.\n-        Supporting,\n-    }\n-\n-    impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-        /// Returns an iterator over the prefixes of `place`\n-        /// (inclusive) from longest to smallest, potentially\n-        /// terminating the iteration early based on `kind`.\n-        pub(super) fn prefixes(\n-            &self,\n-            place: &'cx Place<'tcx>,\n-            kind: PrefixSet,\n-        ) -> Prefixes<'cx, 'gcx, 'tcx> {\n-            Prefixes {\n-                next: Some(place),\n-                kind,\n-                mir: self.mir,\n-                tcx: self.tcx,\n-            }\n-        }\n-    }\n-\n-    impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n-        type Item = &'cx Place<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            let mut cursor = self.next?;\n-\n-            // Post-processing `place`: Enqueue any remaining\n-            // work. Also, `place` may not be a prefix itself, but\n-            // may hold one further down (e.g. we never return\n-            // downcasts here, but may return a base of a downcast).\n-\n-            'cursor: loop {\n-                let proj = match *cursor {\n-                    Place::Local(_) | // search yielded this leaf\n-                    Place::Static(_) => {\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-\n-                    Place::Projection(ref proj) => proj,\n-                };\n-\n-                match proj.elem {\n-                    ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                        // FIXME: add union handling\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-                    ProjectionElem::Downcast(..) |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Index(_) => {\n-                        cursor = &proj.base;\n-                        continue 'cursor;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        // (handled below)\n-                    }\n-                }\n-\n-                assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                match self.kind {\n-                    PrefixSet::Shallow => {\n-                        // shallow prefixes are found by stripping away\n-                        // fields, but stop at *any* dereference.\n-                        // So we can just stop the traversal now.\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-                    PrefixSet::All => {\n-                        // all prefixes: just blindly enqueue the base\n-                        // of the projection\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-                    PrefixSet::Supporting => {\n-                        // fall through!\n-                    }\n-                }\n-\n-                assert_eq!(self.kind, PrefixSet::Supporting);\n-                // supporting prefixes: strip away fields and\n-                // derefs, except we stop at the deref of a shared\n-                // reference.\n-\n-                let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                match ty.sty {\n-                    ty::TyRawPtr(_) |\n-                    ty::TyRef(\n-                        _, /*rgn*/\n-                        ty::TypeAndMut {\n-                            ty: _,\n-                            mutbl: hir::MutImmutable,\n-                        },\n-                    ) => {\n-                        // don't continue traversing over derefs of raw pointers or shared borrows.\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-\n-                    ty::TyRef(\n-                        _, /*rgn*/\n-                        ty::TypeAndMut {\n-                            ty: _,\n-                            mutbl: hir::MutMutable,\n-                        },\n-                    ) => {\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-\n-                    ty::TyAdt(..) if ty.is_box() => {\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-\n-                    _ => panic!(\"unknown type fed to Projection Deref.\"),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    fn report_use_of_moved_or_uninitialized(\n-        &mut self,\n-        _context: Context,\n-        desired_action: InitializationRequiringAction,\n-        (place, span): (&Place<'tcx>, Span),\n-        mpi: MovePathIndex,\n-        curr_move_out: &IdxSetBuf<MoveOutIndex>,\n-    ) {\n-        let mois = self.move_data.path_map[mpi]\n-            .iter()\n-            .filter(|moi| curr_move_out.contains(moi))\n-            .collect::<Vec<_>>();\n-\n-        if mois.is_empty() {\n-            let item_msg = match self.describe_place(place) {\n-                Some(name) => format!(\"`{}`\", name),\n-                None => \"value\".to_owned(),\n-            };\n-            self.tcx\n-                .cannot_act_on_uninitialized_variable(\n-                    span,\n-                    desired_action.as_noun(),\n-                    &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                    Origin::Mir,\n-                )\n-                .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n-                .emit();\n-        } else {\n-            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n-\n-            let mut err = self.tcx.cannot_act_on_moved_value(\n-                span,\n-                desired_action.as_noun(),\n-                msg,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            );\n-\n-            err.span_label(\n-                span,\n-                format!(\n-                    \"value {} here after move\",\n-                    desired_action.as_verb_in_past_tense()\n-                ),\n-            );\n-            for moi in mois {\n-                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n-                if span == move_span {\n-                    err.span_label(\n-                        span,\n-                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n-                    );\n-                } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                };\n-            }\n-            //FIXME: add note for closure\n-            err.emit();\n-        }\n-    }\n-\n-    fn report_move_out_while_borrowed(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        let value_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        let borrow_msg = match self.describe_place(&borrow.place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        self.tcx\n-            .cannot_move_when_borrowed(\n-                span,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            )\n-            .span_label(\n-                self.retrieve_borrow_span(borrow),\n-                format!(\"borrow of {} occurs here\", borrow_msg),\n-            )\n-            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n-            .emit();\n-    }\n-\n-    fn report_use_while_mutably_borrowed(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span,\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        err.emit();\n-    }\n-\n-    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n-    /// the local assigned at `location`.\n-    /// This is done by searching in statements succeeding `location`\n-    /// and originating from `maybe_closure_span`.\n-    fn find_closure_span(\n-        &self,\n-        maybe_closure_span: Span,\n-        location: Location,\n-    ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprClosure;\n-        use rustc::mir::AggregateKind;\n-\n-        let local = if let StatementKind::Assign(Place::Local(local), _) =\n-            self.mir[location.block].statements[location.statement_index].kind\n-        {\n-            local\n-        } else {\n-            return None;\n-        };\n-\n-        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if maybe_closure_span != stmt.source_info.span {\n-                break;\n-            }\n-\n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_span: found closure {:?}\", places);\n-\n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let ExprClosure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return None;\n-                        };\n-\n-                        self.tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l)) |\n-                                        Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_span: found captured local {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| (args_span, var_span))\n-                    } else {\n-                        None\n-                    };\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn report_conflicting_borrow(\n-        &mut self,\n-        context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        gen_borrow_kind: BorrowKind,\n-        issued_borrow: &BorrowData,\n-        end_issued_loan_span: Option<Span>,\n-    ) {\n-        let issued_span = self.retrieve_borrow_span(issued_borrow);\n-\n-        let new_closure_span = self.find_closure_span(span, context.loc);\n-        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n-        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n-        let issued_span = old_closure_span\n-            .map(|(args, _)| args)\n-            .unwrap_or(issued_span);\n-\n-        let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-\n-        // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (\n-            gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n-            issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n-        ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n-                .cannot_reborrow_already_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"it\",\n-                    rgt,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) => self.tcx\n-                .cannot_mutably_borrow_multiply(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_uniquely_borrow_by_two_closures(\n-                    span,\n-                    &desc_place,\n-                    issued_span,\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                span,\n-                &desc_place,\n-                \"\",\n-                issued_span,\n-                \"it\",\n-                \"\",\n-                end_issued_loan_span,\n-                Origin::Mir,\n-            ),\n-\n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n-        };\n-\n-        if let Some((_, var_span)) = old_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\n-                    \"previous borrow occurs due to use of `{}` in closure\",\n-                    desc_place\n-                ),\n-            );\n-        }\n-\n-        if let Some((_, var_span)) = new_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n-            );\n-        }\n-\n-        err.emit();\n-    }\n-\n-    fn report_borrowed_value_does_not_live_long_enough(\n-        &mut self,\n-        _: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        end_span: Option<Span>,\n-    ) {\n-        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n-        let proper_span = match *root_place {\n-            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n-            _ => span,\n-        };\n-        let mut err = self.tcx\n-            .path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n-        err.span_label(proper_span, \"temporary value created here\");\n-        err.span_label(span, \"temporary value dropped here while still borrowed\");\n-        err.note(\"consider using a `let` binding to increase its lifetime\");\n-\n-        if let Some(end) = end_span {\n-            err.span_label(end, \"temporary value needs to live until here\");\n-        }\n-\n-        err.emit();\n-    }\n-\n-    fn report_illegal_mutation_of_borrowed(\n-        &mut self,\n-        _: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        loan: &BorrowData,\n-    ) {\n-        let mut err = self.tcx.cannot_assign_to_borrowed(\n-            span,\n-            self.retrieve_borrow_span(loan),\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        err.emit();\n-    }\n-\n-    fn report_illegal_reassignment(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        assigned_span: Span,\n-    ) {\n-        let mut err = self.tcx.cannot_reassign_immutable(\n-            span,\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-        err.span_label(span, \"cannot assign twice to immutable variable\");\n-        if span != assigned_span {\n-            let value_msg = match self.describe_place(place) {\n-                Some(name) => format!(\"`{}`\", name),\n-                None => \"value\".to_owned(),\n-            };\n-            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n-        }\n-        err.emit();\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `place` if one can be found. If the\n-    // place is a temporary for instance, None will be returned.\n-    fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n-        let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false) {\n-            Ok(()) => Some(buf),\n-            Err(()) => None,\n-        }\n-    }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        match *place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let is_projection_from_ty_closure = proj.base\n-                        .ty(self.mir, self.tcx)\n-                        .to_ty(self.tcx)\n-                        .is_closure();\n-\n-                    if is_projection_from_ty_closure {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    // Appends end-user visible description of `place` to `buf`.\n-    fn append_place_to_string(\n-        &self,\n-        place: &Place<'tcx>,\n-        buf: &mut String,\n-        mut autoderef: bool,\n-    ) -> Result<(), ()> {\n-        match *place {\n-            Place::Local(local) => {\n-                self.append_local_to_string(local, buf)?;\n-            }\n-            Place::Static(ref static_) => {\n-                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n-            }\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Deref => {\n-                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n-                            let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            if self.mir.upvar_decls[var_index].by_ref {\n-                                buf.push_str(&name);\n-                            } else {\n-                                buf.push_str(&format!(\"*{}\", &name));\n-                            }\n-                        } else {\n-                            if autoderef {\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            } else {\n-                                buf.push_str(&\"*\");\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            }\n-                        }\n-                    }\n-                    ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                    }\n-                    ProjectionElem::Field(field, _ty) => {\n-                        autoderef = true;\n-\n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n-                            let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            buf.push_str(&name);\n-                        } else {\n-                            let field_name = self.describe_field(&proj.base, field);\n-                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            buf.push_str(&format!(\".{}\", field_name));\n-                        }\n-                    }\n-                    ProjectionElem::Index(index) => {\n-                        autoderef = true;\n-\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                        buf.push_str(\"[\");\n-                        if let Err(_) = self.append_local_to_string(index, buf) {\n-                            buf.push_str(\"..\");\n-                        }\n-                        buf.push_str(\"]\");\n-                    }\n-                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n-                        autoderef = true;\n-                        // Since it isn't possible to borrow an element on a particular index and\n-                        // then use another while the borrow is held, don't output indices details\n-                        // to avoid confusing the end-user\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                        buf.push_str(&\"[..]\");\n-                    }\n-                };\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n-    // a name, then `Err` is returned\n-    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n-        let local = &self.mir.local_decls[local_index];\n-        match local.name {\n-            Some(name) => {\n-                buf.push_str(&format!(\"{}\", name));\n-                Ok(())\n-            }\n-            None => Err(()),\n-        }\n-    }\n-\n-    // End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place, field: Field) -> String {\n-        match *base {\n-            Place::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field)\n-            }\n-            Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) => {\n-                    format!(\"{}\", def.variants[variant_index].fields[field.index()].name)\n-                }\n-                ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field)\n-                }\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n-                    format!(\"{}\", self.describe_field(&proj.base, field))\n-                }\n-            },\n-        }\n-    }\n-\n-    // End-user visible description of the `field_index`nth field of `ty`\n-    fn describe_field_from_ty(&self, ty: &ty::Ty, field: Field) -> String {\n-        if ty.is_box() {\n-            // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field)\n-        } else {\n-            match ty.sty {\n-                ty::TyAdt(def, _) => if def.is_enum() {\n-                    format!(\"{}\", field.index())\n-                } else {\n-                    format!(\"{}\", def.struct_variant().fields[field.index()].name)\n-                },\n-                ty::TyTuple(_, _) => format!(\"{}\", field.index()),\n-                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n-                    self.describe_field_from_ty(&tnm.ty, field)\n-                }\n-                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n-                ty::TyClosure(closure_def_id, _) => {\n-                    // Convert the def-id into a node-id. node-ids are only valid for\n-                    // the local code in the current crate, so this returns an `Option` in case\n-                    // the closure comes from another crate. But in that case we wouldn't\n-                    // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n-                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n-\n-                    self.tcx.hir.name(freevar.var_id()).to_string()\n-                }\n-                _ => {\n-                    // Might need a revision when the fields in trait RFC is implemented\n-                    // (https://github.com/rust-lang/rfcs/pull/1546)\n-                    bug!(\n-                        \"End-user description not implemented for field access on `{:?}`\",\n-                        ty.sty\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    // Retrieve span of given borrow from the current MIR representation\n-    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.source_info(borrow.location).span\n-    }\n-}\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // FIXME (#16118): function intended to allow the borrow checker\n@@ -2694,243 +1860,3 @@ impl ContextKind {\n         }\n     }\n }\n-\n-impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n-    fn new(\n-        borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-        inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-        move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-    ) -> Self {\n-        InProgress {\n-            borrows,\n-            inits,\n-            uninits,\n-            move_outs,\n-            ever_inits,\n-        }\n-    }\n-\n-    fn each_flow<XB, XI, XU, XM, XE>(\n-        &mut self,\n-        mut xform_borrows: XB,\n-        mut xform_inits: XI,\n-        mut xform_uninits: XU,\n-        mut xform_move_outs: XM,\n-        mut xform_ever_inits: XE,\n-    ) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n-        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n-        XE: FnMut(&mut FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>),\n-    {\n-        xform_borrows(&mut self.borrows);\n-        xform_inits(&mut self.inits);\n-        xform_uninits(&mut self.uninits);\n-        xform_move_outs(&mut self.move_outs);\n-        xform_ever_inits(&mut self.ever_inits);\n-    }\n-}\n-\n-impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"inits: [\");\n-        let mut saw_one = false;\n-        self.inits.each_state_bit(|mpi_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path = &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path =\n-                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"move_out: [\");\n-        let mut saw_one = false;\n-        self.move_outs.each_state_bit(|mpi_move_out| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_out = &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n-            s.push_str(&format!(\"{:?}\", move_out));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"ever_init: [\");\n-        let mut saw_one = false;\n-        self.ever_inits.each_state_bit(|mpi_ever_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let ever_init =\n-                &self.ever_inits.base_results.operator().move_data().inits[mpi_ever_init];\n-            s.push_str(&format!(\"{:?}\", ever_init));\n-        });\n-        s.push_str(\"]\");\n-\n-        fmt::Display::fmt(&s, fmt)\n-    }\n-}\n-\n-impl<'tcx, T> FlowInProgress<T>\n-where\n-    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n-{\n-    fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n-        let move_data = self.base_results.operator().move_data();\n-\n-        let mut todo = vec![mpi];\n-        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n-        while let Some(mpi) = todo.pop() {\n-            if self.curr_state.contains(&mpi) {\n-                return Some(mpi);\n-            }\n-            let move_path = &move_data.move_paths[mpi];\n-            if let Some(child) = move_path.first_child {\n-                todo.push(child);\n-            }\n-            if push_siblings {\n-                if let Some(sibling) = move_path.next_sibling {\n-                    todo.push(sibling);\n-                }\n-            } else {\n-                // after we've processed the original `mpi`, we should\n-                // always traverse the siblings of any of its\n-                // children.\n-                push_siblings = true;\n-            }\n-        }\n-        return None;\n-    }\n-}\n-\n-impl<BD> FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_gen\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn new(results: DataflowResults<BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n-        FlowInProgress {\n-            base_results: results,\n-            curr_state: curr_state,\n-            stmt_gen: stmt_gen,\n-            stmt_kill: stmt_kill,\n-        }\n-    }\n-\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .statement_effect(&mut sets, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .terminator_effect(&mut sets, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n-    }\n-\n-    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ)\n-    }\n-\n-    fn with_elems_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(indexed_set::Elems<BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        curr_state.union(&self.stmt_gen);\n-        curr_state.subtract(&self.stmt_kill);\n-        let univ = self.base_results.sets().bits_per_block();\n-        f(curr_state.elems(univ));\n-    }\n-}"}, {"sha": "59e862a56af02c5a36b50c8a82fb852221e8f99c", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n-use borrow_check::FlowInProgress;\n+use borrow_check::{FlowAtLocation, FlowsAtLocation};\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::{HasMoveData, MoveData};\n \n@@ -36,7 +36,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n@@ -61,7 +61,7 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir: &'cg Mir<'tcx>,\n     liveness: &'cg LivenessResults,\n     param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &'cg mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &'cg mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &'cg MoveData<'tcx>,\n }\n \n@@ -172,7 +172,6 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                         \"add_liveness_constraints: location={:?} initialized={:?}\",\n                         location,\n                         &self.flow_inits\n-                            .base_results\n                             .operator()\n                             .move_data()\n                             .move_paths[mpi_init]\n@@ -205,7 +204,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                 );\n                 self.flow_inits.reconstruct_statement_effect(location);\n             }\n-            self.flow_inits.apply_local_effect();\n+            self.flow_inits.apply_local_effect(location);\n         }\n     }\n "}, {"sha": "218142f7e2d428a60b81746d454b647dffec1b92", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -18,7 +18,7 @@ use std::io;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n-use borrow_check::FlowInProgress;\n+use borrow_check::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n \n@@ -69,7 +69,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,"}, {"sha": "645c935de09b1a04cc985d39a5c4e54cc68e52e8", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n+//! place are formed by stripping away fields and derefs, except that\n+//! we stop when we reach the deref of a shared reference. [...] \"\n+//!\n+//! \"Shallow prefixes are found by stripping away fields, but stop at\n+//! any dereference. So: writing a path like `a` is illegal if `a.b`\n+//! is borrowed. But: writing `a` is legal if `*a` is borrowed,\n+//! whether or not `a` is a shared or mutable reference. [...] \"\n+\n+use super::MirBorrowckCtxt;\n+\n+use rustc::hir;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{Mir, Place, ProjectionElem};\n+\n+pub trait IsPrefixOf<'tcx> {\n+    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n+}\n+\n+impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n+    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n+        let mut cursor = other;\n+        loop {\n+            if self == cursor {\n+                return true;\n+            }\n+\n+            match *cursor {\n+                Place::Local(_) | Place::Static(_) => return false,\n+                Place::Projection(ref proj) => {\n+                    cursor = &proj.base;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    kind: PrefixSet,\n+    next: Option<&'cx Place<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[allow(dead_code)]\n+pub(super) enum PrefixSet {\n+    /// Doesn't stop until it returns the base case (a Local or\n+    /// Static prefix).\n+    All,\n+    /// Stops at any dereference.\n+    Shallow,\n+    /// Stops at the deref of a shared reference.\n+    Supporting,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Returns an iterator over the prefixes of `place`\n+    /// (inclusive) from longest to smallest, potentially\n+    /// terminating the iteration early based on `kind`.\n+    pub(super) fn prefixes(\n+        &self,\n+        place: &'cx Place<'tcx>,\n+        kind: PrefixSet,\n+    ) -> Prefixes<'cx, 'gcx, 'tcx> {\n+        Prefixes {\n+            next: Some(place),\n+            kind,\n+            mir: self.mir,\n+            tcx: self.tcx,\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n+    type Item = &'cx Place<'tcx>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let mut cursor = match self.next {\n+            None => return None,\n+            Some(place) => place,\n+        };\n+\n+        // Post-processing `place`: Enqueue any remaining\n+        // work. Also, `place` may not be a prefix itself, but\n+        // may hold one further down (e.g. we never return\n+        // downcasts here, but may return a base of a downcast).\n+\n+        'cursor: loop {\n+            let proj = match *cursor {\n+                Place::Local(_) | // search yielded this leaf\n+                Place::Static(_) => {\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+\n+                Place::Projection(ref proj) => proj,\n+            };\n+\n+            match proj.elem {\n+                ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n+                        // FIXME: add union handling\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+                ProjectionElem::Downcast(..) |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Index(_) => {\n+                    cursor = &proj.base;\n+                    continue 'cursor;\n+                }\n+                ProjectionElem::Deref => {\n+                    // (handled below)\n+                }\n+            }\n+\n+            assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+            match self.kind {\n+                PrefixSet::Shallow => {\n+                    // shallow prefixes are found by stripping away\n+                    // fields, but stop at *any* dereference.\n+                    // So we can just stop the traversal now.\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+                PrefixSet::All => {\n+                    // all prefixes: just blindly enqueue the base\n+                    // of the projection\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+                PrefixSet::Supporting => {\n+                    // fall through!\n+                }\n+            }\n+\n+            assert_eq!(self.kind, PrefixSet::Supporting);\n+            // supporting prefixes: strip away fields and\n+            // derefs, except we stop at the deref of a shared\n+            // reference.\n+\n+            let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            match ty.sty {\n+                ty::TyRawPtr(_) |\n+                ty::TyRef(\n+                    _, /*rgn*/\n+                    ty::TypeAndMut {\n+                        ty: _,\n+                            mutbl: hir::MutImmutable,\n+                        },\n+                    ) => {\n+                    // don't continue traversing over derefs of raw pointers or shared borrows.\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+\n+                ty::TyRef(\n+                    _, /*rgn*/\n+                    ty::TypeAndMut {\n+                        ty: _,\n+                        mutbl: hir::MutMutable,\n+                    },\n+                    ) => {\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+\n+                ty::TyAdt(..) if ty.is_box() => {\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+\n+                _ => panic!(\"unknown type fed to Projection Deref.\"),\n+            }\n+        }\n+    }\n+}"}, {"sha": "90ebb45123ed8947d1bbf62d6c438ed9481cedf0", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A nice wrapper to consume dataflow results at several CFG\n+//! locations.\n+\n+use rustc::mir::{BasicBlock, Location};\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use dataflow::{BitDenotation, BlockSets, DataflowResults};\n+use dataflow::move_paths::{HasMoveData, MovePathIndex};\n+\n+/// A trait for \"cartesian products\" of multiple FlowAtLocation.\n+///\n+/// There's probably a way to auto-impl this, but I think\n+/// it is cleaner to have manual visitor impls.\n+pub trait FlowsAtLocation {\n+    // reset the state bitvector to represent the entry to block `bb`.\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock);\n+\n+    // build gen + kill sets for statement at `loc`.\n+    fn reconstruct_statement_effect(&mut self, loc: Location);\n+\n+    // build gen + kill sets for terminator for `loc`.\n+    fn reconstruct_terminator_effect(&mut self, loc: Location);\n+\n+    // apply current gen + kill sets to `flow_state`.\n+    //\n+    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n+    // client. For the terminator, the `stmt_idx` will be the number\n+    // of statements in the block.)\n+    fn apply_local_effect(&mut self, loc: Location);\n+}\n+\n+/// Represents the state of dataflow at a particular\n+/// CFG location, both before and after it is\n+/// executed.\n+pub struct FlowAtLocation<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+impl<BD> FlowAtLocation<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    pub fn each_state_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.curr_state\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    pub fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.stmt_gen\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    pub fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowAtLocation {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    pub fn operator(&self) -> &BD {\n+        self.base_results.operator()\n+    }\n+\n+    pub fn contains(&self, x: &BD::Idx) -> bool {\n+        self.curr_state.contains(x)\n+    }\n+\n+    pub fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+\n+    pub fn with_elems_outgoing<F>(&self, f: F)\n+    where\n+        F: FnOnce(indexed_set::Elems<BD::Idx>),\n+    {\n+        let mut curr_state = self.curr_state.clone();\n+        curr_state.union(&self.stmt_gen);\n+        curr_state.subtract(&self.stmt_kill);\n+        let univ = self.base_results.sets().bits_per_block();\n+        f(curr_state.elems(univ));\n+    }\n+}\n+\n+impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n+    where BD: BitDenotation\n+{\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self, _loc: Location) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+}\n+\n+\n+impl<'tcx, T> FlowAtLocation<T>\n+where\n+    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n+{\n+    pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n+        let move_data = self.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}"}, {"sha": "b3299b943ba55f07a88a52c4a6593f202b25223e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     fn bits_per_block(&self) -> usize {\n         self.borrows.len()\n     }\n-    fn start_block_effect(&self, _sets: &mut BlockSets<BorrowIndex>)  {\n+    fn start_block_effect(&self, _sets: &mut IdxSet<BorrowIndex>)  {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect on\n         // `_sets`."}, {"sha": "033d2a3212f8c1610990c86a40407218c7829294", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -331,13 +331,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n         self.move_data().move_paths.len()\n     }\n \n-    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>)\n-    {\n+    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.add(&path);\n+                entry_set.add(&path);\n             });\n     }\n \n@@ -384,15 +383,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n+    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        for e in sets.on_entry.words_mut() { *e = !0; }\n+        for e in entry_set.words_mut() { *e = !0; }\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.remove(&path);\n+                entry_set.remove(&path);\n             });\n     }\n \n@@ -439,14 +438,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, sets: &mut BlockSets<MovePathIndex>) {\n-        for e in sets.on_entry.words_mut() { *e = 0; }\n+    fn start_block_effect(&self, entry_set: &mut IdxSet<MovePathIndex>) {\n+        for e in entry_set.words_mut() { *e = 0; }\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.add(&path);\n+                entry_set.add(&path);\n             });\n     }\n \n@@ -492,10 +491,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n         self.move_data().moves.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n+    fn start_block_effect(&self, _sets: &mut IdxSet<MoveOutIndex>) {\n         // no move-statements have been executed prior to function\n         // execution, so this method has no effect on `_sets`.\n     }\n+\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<MoveOutIndex>,\n                         location: Location) {\n@@ -568,9 +568,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         self.move_data().inits.len()\n     }\n \n-    fn start_block_effect(&self, sets: &mut BlockSets<InitIndex>) {\n-        sets.gen_all((0..self.mir.arg_count).map(InitIndex::new));\n+    fn start_block_effect(&self, entry_set: &mut IdxSet<InitIndex>) {\n+        for arg_init in 0..self.mir.arg_count {\n+            entry_set.add(&InitIndex::new(arg_init));\n+        }\n     }\n+\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<InitIndex>,\n                         location: Location) {"}, {"sha": "9e5a71683781b740678801ef3d9065de75c1d97d", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n         self.mir.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut BlockSets<Local>) {\n+    fn start_block_effect(&self, _sets: &mut IdxSet<Local>) {\n         // Nothing is live on function entry\n     }\n "}, {"sha": "2136b41e46222a169604230ebc7732890336aefb", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -30,10 +30,12 @@ pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::EverInitializedLvals;\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n+pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n use self::move_paths::MoveData;\n \n+mod at_location;\n mod drop_flag_effects;\n mod graphviz;\n mod impls;\n@@ -169,7 +171,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n \n         {\n             let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n-            self.flow_state.operator.start_block_effect(sets);\n+            self.flow_state.operator.start_block_effect(&mut sets.on_entry);\n         }\n \n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n@@ -275,7 +277,7 @@ impl<E:Idx> Bits<E> {\n /// where we are combining the results of *multiple* flow analyses\n /// (e.g. borrows + inits + uninits).\n pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n-    type FlowState;\n+    type FlowState: FlowsAtLocation;\n \n     // Observation Hooks: override (at least one of) these to get analysis feedback.\n     fn visit_block_entry(&mut self,\n@@ -297,7 +299,7 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n         let flow = flow_uninit;\n         for bb in self.mir().basic_blocks().indices() {\n-            self.reset_to_entry_of(bb, flow);\n+            flow.reset_to_entry_of(bb);\n             self.process_basic_block(bb, flow);\n         }\n     }\n@@ -307,14 +309,14 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n             self.mir()[bb];\n         let mut location = Location { block: bb, statement_index: 0 };\n         for stmt in statements.iter() {\n-            self.reconstruct_statement_effect(location, flow_state);\n+            flow_state.reconstruct_statement_effect(location);\n             self.visit_statement_entry(location, stmt, flow_state);\n-            self.apply_local_effect(location, flow_state);\n+            flow_state.apply_local_effect(location);\n             location.statement_index += 1;\n         }\n \n         if let Some(ref term) = *terminator {\n-            self.reconstruct_terminator_effect(location, flow_state);\n+            flow_state.reconstruct_terminator_effect(location);\n             self.visit_terminator_entry(location, term, flow_state);\n \n             // We don't need to apply the effect of the terminator,\n@@ -328,30 +330,6 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     // Delegated Hooks: Provide access to the MIR and process the flow state.\n \n     fn mir(&self) -> &'a Mir<'tcx>;\n-\n-    // reset the state bitvector to represent the entry to block `bb`.\n-    fn reset_to_entry_of(&mut self,\n-                         bb: BasicBlock,\n-                         flow_state: &mut Self::FlowState);\n-\n-    // build gen + kill sets for statement at `loc`.\n-    fn reconstruct_statement_effect(&mut self,\n-                                    loc: Location,\n-                                    flow_state: &mut Self::FlowState);\n-\n-    // build gen + kill sets for terminator for `loc`.\n-    fn reconstruct_terminator_effect(&mut self,\n-                                     loc: Location,\n-                                     flow_state: &mut Self::FlowState);\n-\n-    // apply current gen + kill sets to `flow_state`.\n-    //\n-    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n-    // client. For the terminator, the `stmt_idx` will be the number\n-    // of statements in the block.)\n-    fn apply_local_effect(&mut self,\n-                          loc: Location,\n-                          flow_state: &mut Self::FlowState);\n }\n \n pub fn state_for_location<T: BitDenotation>(loc: Location,\n@@ -578,16 +556,13 @@ pub trait BitDenotation: DataflowOperator {\n     /// Size of each bitvector allocated for each block in the analysis.\n     fn bits_per_block(&self) -> usize;\n \n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects that have been\n-    /// established *prior* to entering the start block.\n+    /// Mutates the entry set according to the effects that\n+    /// have been established *prior* to entering the start\n+    /// block. This can't access the gen/kill sets, because\n+    /// these won't be accounted for correctly.\n     ///\n     /// (For example, establishing the call arguments.)\n-    ///\n-    /// (Typically this should only modify `sets.on_entry`, since the\n-    /// gen and kill sets should reflect the effects of *executing*\n-    /// the start block itself.)\n-    fn start_block_effect(&self, sets: &mut BlockSets<Self::Idx>);\n+    fn start_block_effect(&self, entry_set: &mut IdxSet<Self::Idx>);\n \n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating statement."}, {"sha": "b32056fcb915a0eacb8d77de39f640e43791bc77", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n \n fn f(y: Box<isize>) {\n-    *y = 5; //~ ERROR cannot assign\n+    *y = 5; //[ast]~ ERROR cannot assign\n+            //[mir]~^ ERROR cannot assign twice\n }\n \n fn g() {\n-    let _frob = |q: Box<isize>| { *q = 2; }; //~ ERROR cannot assign\n-\n+    let _frob = |q: Box<isize>| { *q = 2; }; //[ast]~ ERROR cannot assign\n+    //[mir]~^ ERROR cannot assign twice\n }\n \n fn main() {}"}, {"sha": "3e14525250de53945d919e95d115ebcbcf31a9d7", "filename": "src/test/compile-fail/issue-17954.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -8,18 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(thread_local)]\n \n #[thread_local]\n static FOO: u8 = 3;\n \n fn main() {\n     let a = &FOO;\n-    //~^ ERROR borrowed value does not live long enough\n-    //~| does not live long enough\n-    //~| NOTE borrowed value must be valid for the static lifetime\n+    //[ast]~^ ERROR borrowed value does not live long enough\n+    //[ast]~| does not live long enough\n+    //[ast]~| NOTE borrowed value must be valid for the static lifetime\n \n     std::thread::spawn(move || {\n         println!(\"{}\", a);\n     });\n-} //~ temporary value only lives until here\n+} //[ast]~ temporary value only lives until here\n+  //[mir]~^ ERROR borrowed value does not live long enough"}, {"sha": "f138ae93f71a2abec4eadfbb8f27be1b849184d6", "filename": "src/test/compile-fail/mutable-class-fields.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbb27a2414db79bef0a5858b440b04b545c80fa/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-class-fields.rs?ref=ddbb27a2414db79bef0a5858b440b04b545c80fa", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n struct cat {\n   meows : usize,\n   how_hungry : isize,\n@@ -22,5 +25,6 @@ fn cat(in_x : usize, in_y : isize) -> cat {\n \n fn main() {\n   let nyan : cat = cat(52, 99);\n-  nyan.how_hungry = 0; //~ ERROR cannot assign\n+  nyan.how_hungry = 0; //[ast]~ ERROR cannot assign\n+  //[mir]~^ ERROR cannot assign\n }"}]}