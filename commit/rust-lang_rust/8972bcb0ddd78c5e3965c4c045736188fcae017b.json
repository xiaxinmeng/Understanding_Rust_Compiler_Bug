{"sha": "8972bcb0ddd78c5e3965c4c045736188fcae017b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NzJiY2IwZGRkNzhjNWUzOTY1YzRjMDQ1NzM2MTg4ZmNhZTAxN2I=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-09T12:48:45Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-12T15:18:30Z"}, "message": "BTreeMap: test chaotic ordering & other bits & bobs", "tree": {"sha": "e0685a52fa33f17a0d47a572825d36a9db200fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0685a52fa33f17a0d47a572825d36a9db200fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8972bcb0ddd78c5e3965c4c045736188fcae017b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8972bcb0ddd78c5e3965c4c045736188fcae017b", "html_url": "https://github.com/rust-lang/rust/commit/8972bcb0ddd78c5e3965c4c045736188fcae017b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8972bcb0ddd78c5e3965c4c045736188fcae017b/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55794e43960ad3647e78ea5b0cb5ad0c5c0596a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/55794e43960ad3647e78ea5b0cb5ad0c5c0596a8", "html_url": "https://github.com/rust-lang/rust/commit/55794e43960ad3647e78ea5b0cb5ad0c5c0596a8"}], "stats": {"total": 227, "additions": 201, "deletions": 26}, "files": [{"sha": "7bc6a045ad6c80049093ec2f59a43f59f865d5b5", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 121, "deletions": 25, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=8972bcb0ddd78c5e3965c4c045736188fcae017b", "patch": "@@ -14,6 +14,9 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n+mod ord_chaos;\n+use ord_chaos::{Cyclic3, Governed, Governor};\n+\n // Capacity of a tree with a single level,\n // i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n@@ -28,7 +31,7 @@ const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n-// Gather all references from a mutable iterator and make sure Miri notices if\n+// Gathers all references from a mutable iterator and makes sure Miri notices if\n // using them is dangerous.\n fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>) {\n     // Gather all those references.\n@@ -43,28 +46,43 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n }\n \n impl<K, V> BTreeMap<K, V> {\n-    /// Panics if the map (or the code navigating it) is corrupted.\n-    fn check(&self)\n-    where\n-        K: Copy + Debug + Ord,\n-    {\n+    // Panics if the map (or the code navigating it) is corrupted.\n+    fn check_invariants(&self) {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n \n+            // Check the back pointers top-down, before we attempt to rely on\n+            // more serious navigation code.\n             assert!(root_node.ascend().is_err());\n             root_node.assert_back_pointers();\n \n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, root_node.calc_length());\n+            assert_eq!(self.length, self.keys().count());\n \n+            // Lastly, check the invariant causing the least harm.\n             root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n+            // Check consistenty of `length` and some of the navigation.\n             assert_eq!(self.length, 0);\n+            assert_eq!(self.length, self.keys().count());\n         }\n+    }\n \n-        self.assert_ascending();\n+    // Panics if the map is corrupted or if the keys are not in strictly\n+    // ascending order, in the current opinion of the `Ord` implementation.\n+    // If the `Ord` implementation does not honor transitivity, this method\n+    // does not guarantee that all the keys are unique, just that adjacent\n+    // keys are unique.\n+    fn check(&self)\n+    where\n+        K: Debug + Ord,\n+    {\n+        self.check_invariants();\n+        self.assert_strictly_ascending();\n     }\n \n-    /// Returns the height of the root, if any.\n+    // Returns the height of the root, if any.\n     fn height(&self) -> Option<usize> {\n         self.root.as_ref().map(node::Root::height)\n     }\n@@ -80,22 +98,18 @@ impl<K, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Asserts that the keys are in strictly ascending order.\n-    fn assert_ascending(&self)\n+    // Panics if the keys are not in strictly ascending order.\n+    fn assert_strictly_ascending(&self)\n     where\n-        K: Copy + Debug + Ord,\n+        K: Debug + Ord,\n     {\n-        let mut num_seen = 0;\n         let mut keys = self.keys();\n         if let Some(mut previous) = keys.next() {\n-            num_seen = 1;\n             for next in keys {\n                 assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n                 previous = next;\n-                num_seen += 1;\n             }\n         }\n-        assert_eq!(num_seen, self.len());\n     }\n }\n \n@@ -111,7 +125,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-// Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n+// Tests our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n // implementation of insertion, but it's best to be aware of when it does.\n #[test]\n fn test_levels() {\n@@ -149,6 +163,25 @@ fn test_levels() {\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2, \"{}\", map.dump_keys());\n }\n \n+// Ensures the testing infrastructure usually notices order violations.\n+#[test]\n+#[should_panic]\n+fn test_check_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check();\n+}\n+\n+// Ensures the testing infrastructure doesn't always mind order violations.\n+#[test]\n+fn test_check_invariants_ord_chaos() {\n+    let gov = Governor::new();\n+    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    gov.flip();\n+    map.check_invariants();\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -334,7 +367,7 @@ fn test_iter_rev() {\n     test(size, map.into_iter().rev());\n }\n \n-/// Specifically tests iter_mut's ability to mutate the value of pairs in-line\n+// Specifically tests iter_mut's ability to mutate the value of pairs in-line.\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n@@ -439,6 +472,8 @@ fn test_iter_entering_root_twice() {\n     *back.1 = 42;\n     assert_eq!(front, (&0, &mut 24));\n     assert_eq!(back, (&1, &mut 42));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n     map.check();\n }\n \n@@ -591,11 +626,12 @@ fn test_range_small() {\n \n #[test]\n fn test_range_height_1() {\n-    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n-    // to rely upon, the single key at the root will be 6 or 7.\n+    // Tests tree with a root and 2 leaves. The single key in the root node is\n+    // close to the middle among the keys.\n \n-    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n-    for &root in &[6, 7] {\n+    let map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n+    let middle = MIN_INSERTS_HEIGHT_1 as i32 / 2;\n+    for root in middle - 2..=middle + 2 {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n         assert_eq!(range_keys(&map, (Included(root), Excluded(root + 1))), vec![root]);\n@@ -727,6 +763,19 @@ fn test_range_backwards_4() {\n     map.range((Excluded(3), Excluded(2)));\n }\n \n+#[test]\n+#[should_panic]\n+fn test_range_backwards_5() {\n+    let mut map = BTreeMap::new();\n+    map.insert(Cyclic3::B, ());\n+    // Lacking static_assert, call `range` conditionally, to emphasise that\n+    // we cause a different panic than `test_range_backwards_1` does.\n+    // A more refined `should_panic` would be welcome.\n+    if Cyclic3::C < Cyclic3::A {\n+        map.range(Cyclic3::C..=Cyclic3::A);\n+    }\n+}\n+\n #[test]\n fn test_range_1000() {\n     // Miri is too slow\n@@ -820,18 +869,28 @@ mod test_drain_filter {\n     }\n \n     #[test]\n-    fn consuming_nothing() {\n+    fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n     #[test]\n-    fn consuming_all() {\n+    fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.clone().collect();\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n+        assert!(map.is_empty());\n+        map.check();\n+    }\n+\n+    #[test]\n+    fn dropped_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n         map.check();\n     }\n \n@@ -1712,6 +1771,27 @@ fn test_append_drop_leak() {\n     assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n+#[test]\n+fn test_append_ord_chaos() {\n+    let mut map1 = BTreeMap::new();\n+    map1.insert(Cyclic3::A, ());\n+    map1.insert(Cyclic3::B, ());\n+    let mut map2 = BTreeMap::new();\n+    map2.insert(Cyclic3::A, ());\n+    map2.insert(Cyclic3::B, ());\n+    map2.insert(Cyclic3::C, ()); // lands first, before A\n+    map2.insert(Cyclic3::B, ()); // lands first, before C\n+    map1.check();\n+    map2.check(); // keys are not unique but still strictly ascending\n+    assert_eq!(map1.len(), 2);\n+    assert_eq!(map2.len(), 4);\n+    map1.append(&mut map2);\n+    assert_eq!(map1.len(), 5);\n+    assert_eq!(map2.len(), 0);\n+    map1.check();\n+    map2.check();\n+}\n+\n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();\n@@ -1874,11 +1954,27 @@ fn test_insert_remove_intertwined() {\n     let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n     let mut map = BTreeMap::new();\n     let mut i = 1;\n+    let offset = 165; // somewhat arbitrarily chosen to cover some code paths\n     for _ in 0..loops {\n-        i = (i + 421) & 0xFF;\n+        i = (i + offset) & 0xFF;\n         map.insert(i, i);\n         map.remove(&(0xFF - i));\n     }\n-\n     map.check();\n }\n+\n+#[test]\n+fn test_insert_remove_intertwined_ord_chaos() {\n+    let loops = if cfg!(miri) { 100 } else { 1_000_000 };\n+    let gov = Governor::new();\n+    let mut map = BTreeMap::new();\n+    let mut i = 1;\n+    let offset = 165; // more arbitrarily copied from above\n+    for _ in 0..loops {\n+        i = (i + offset) & 0xFF;\n+        map.insert(Governed(i, &gov), ());\n+        map.remove(&Governed(0xFF - i, &gov));\n+        gov.flip();\n+    }\n+    map.check_invariants();\n+}"}, {"sha": "91d1d6ea9ef38f48fe9ef73171c4ebc6014a3514", "filename": "library/alloc/src/collections/btree/map/tests/ord_chaos.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests%2Ford_chaos.rs?ref=8972bcb0ddd78c5e3965c4c045736188fcae017b", "patch": "@@ -0,0 +1,76 @@\n+use std::cell::Cell;\n+use std::cmp::Ordering::{self, *};\n+use std::ptr;\n+\n+#[derive(Debug)]\n+pub enum Cyclic3 {\n+    A,\n+    B,\n+    C,\n+}\n+use Cyclic3::*;\n+\n+impl PartialOrd for Cyclic3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Cyclic3 {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        match (self, other) {\n+            (A, A) | (B, B) | (C, C) => Equal,\n+            (A, B) | (B, C) | (C, A) => Less,\n+            (A, C) | (B, A) | (C, B) => Greater,\n+        }\n+    }\n+}\n+\n+impl PartialEq for Cyclic3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(&other) == Equal\n+    }\n+}\n+\n+impl Eq for Cyclic3 {}\n+\n+#[derive(Debug)]\n+pub struct Governor {\n+    flipped: Cell<bool>,\n+}\n+\n+impl Governor {\n+    pub fn new() -> Self {\n+        Governor { flipped: Cell::new(false) }\n+    }\n+\n+    pub fn flip(&self) {\n+        self.flipped.set(!self.flipped.get());\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Governed<'a, T>(pub T, pub &'a Governor);\n+\n+impl<T: Ord> PartialOrd for Governed<'_, T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl<T: Ord> Ord for Governed<'_, T> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        assert!(ptr::eq(self.1, other.1));\n+        let ord = self.0.cmp(&other.0);\n+        if self.1.flipped.get() { ord.reverse() } else { ord }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for Governed<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        assert!(ptr::eq(self.1, other.1));\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl<T: Eq> Eq for Governed<'_, T> {}"}, {"sha": "636b4d039818b6ce406cdef7a8c36c4afe0645d7", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8972bcb0ddd78c5e3965c4c045736188fcae017b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=8972bcb0ddd78c5e3965c4c045736188fcae017b", "patch": "@@ -5,7 +5,7 @@ use crate::string::String;\n use core::cmp::Ordering::*;\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Asserts that the back pointer in each reachable node points to its parent.\n+    // Asserts that the back pointer in each reachable node points to its parent.\n     pub fn assert_back_pointers(self) {\n         if let ForceResult::Internal(node) = self.force() {\n             for idx in 0..=node.len() {\n@@ -17,6 +17,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         }\n     }\n \n+    // Renders a multi-line display of the keys in order and in tree hierarchy,\n+    // picturing the tree growing sideways from its root on the left to its\n+    // leaves on the right.\n     pub fn dump_keys(self) -> String\n     where\n         K: Debug,"}]}