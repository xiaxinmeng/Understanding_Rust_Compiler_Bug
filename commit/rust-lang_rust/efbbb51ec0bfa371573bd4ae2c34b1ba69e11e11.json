{"sha": "efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYmJiNTFlYzBiZmEzNzE1NzNiZDRhZTJjMzRiMWJhNjllMTFlMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-16T10:26:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-16T10:26:16Z"}, "message": "auto merge of #15691 : jbclements/rust/method-field-cleanup, r=alexcrichton\n\nThis patch applies the excellent suggestion of @pnkfelix to group the helper methods for method field access into a Trait, making the code much more readable, and much more similar to the way it was before.", "tree": {"sha": "8b32e0078c5a956618270ab18fcf91ae6efd6ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b32e0078c5a956618270ab18fcf91ae6efd6ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "html_url": "https://github.com/rust-lang/rust/commit/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c35d513cea468b30759b4f78becf28f11a123c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c35d513cea468b30759b4f78becf28f11a123c0", "html_url": "https://github.com/rust-lang/rust/commit/6c35d513cea468b30759b4f78becf28f11a123c0"}, {"sha": "ca05828cb7b6e985c43b6ed716155478f529b308", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca05828cb7b6e985c43b6ed716155478f529b308", "html_url": "https://github.com/rust-lang/rust/commit/ca05828cb7b6e985c43b6ed716155478f529b308"}], "stats": {"total": 314, "additions": 180, "deletions": 134}, "files": [{"sha": "0a050850fe907f9cb091541d51a3d234b5e159bb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -43,6 +43,7 @@ use syntax::ast_map::{PathElem, PathElems};\n use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::ast_util;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n@@ -798,7 +799,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n-        encode_method_argument_names(ebml_w, method_fn_decl(&*ast_method));\n+        encode_method_argument_names(ebml_w, &*ast_method.pe_fn_decl());\n     }\n \n     ebml_w.end_tag();\n@@ -1240,7 +1241,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,\n                                         IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(ebml_w, method_fn_decl(m));\n+                    encode_method_argument_names(ebml_w, m.pe_fn_decl());\n                 }\n             }\n "}, {"sha": "9240547874fd83291e82a6c50ce90b4ae9318300", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -31,6 +31,7 @@ use middle::{ty, typeck};\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::parse::token;\n@@ -136,7 +137,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         let ident = match ii {\n             ast::IIItem(i) => i.ident,\n             ast::IIForeign(i) => i.ident,\n-            ast::IIMethod(_, _, m) => ast_util::method_ident(&*m),\n+            ast::IIMethod(_, _, m) => m.pe_ident(),\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\","}, {"sha": "8f01ee0564d19635e218d920b1d63486a1fe0910", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -22,8 +22,7 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax::ast_util::{local_def, is_local};\n+use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap;\n@@ -213,7 +212,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n                 visit::walk_trait_method(self, &*trait_method, ctxt);\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, ast_util::method_body(&*method), ctxt);\n+                visit::walk_block(self, method.pe_body(), ctxt);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item, ctxt);\n@@ -521,8 +520,7 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::Provided(ref method) => visit::walk_block(self,\n-                                                           ast_util::method_body(&**method), ()),\n+            ast::Provided(ref method) => visit::walk_block(self, method.pe_body(), ()),\n             ast::Required(_) => ()\n         }\n     }"}, {"sha": "fed2f91ce098601ccb5f6b5e3d7dfd141f3a7acc", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -17,7 +17,7 @@ use middle::typeck::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n-use syntax::ast_util;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -95,7 +95,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::UnsafeFn),\n             visit::FkMethod(_, _, method) =>\n-                (true, ast_util::method_fn_style(method) == ast::UnsafeFn),\n+                (true, method.pe_fn_style() == ast::UnsafeFn),\n             _ => (false, false),\n         };\n "}, {"sha": "74ca13a082135b3e6a2f6a3138fccd804d866964", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -26,8 +26,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax::ast_util::{is_local, local_def};\n+use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -264,10 +263,10 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n                 if public_ty || public_trait {\n                     for method in methods.iter() {\n-                        let meth_public = match ast_util::method_explicit_self(&**method).node {\n+                        let meth_public = match method.pe_explicit_self().node {\n                             ast::SelfStatic => public_ty,\n                             _ => true,\n-                        } && ast_util::method_vis(&**method) == ast::Public;\n+                        } && method.pe_vis() == ast::Public;\n                         if meth_public || tr.is_some() {\n                             self.exported_items.insert(method.id);\n                         }\n@@ -457,8 +456,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     let imp = self.tcx.map.get_parent_did(closest_private_id);\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n-                        _ if ast_util::method_vis(&**m) == ast::Public => return Allowable,\n-                        _ => ast_util::method_vis(&**m)\n+                        _ if m.pe_vis() == ast::Public => return Allowable,\n+                        _ => m.pe_vis()\n                     }\n                 }\n                 Some(ast_map::NodeTraitMethod(_)) => {\n@@ -1079,7 +1078,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for m in methods.iter() {\n-                    check_inherited(m.span, ast_util::method_vis(&**m), \"\");\n+                    check_inherited(m.span, m.pe_vis(), \"\");\n                 }\n             }\n \n@@ -1111,7 +1110,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Provided(ref m) => {\n-                            check_inherited(m.span, ast_util::method_vis(&**m),\n+                            check_inherited(m.span, m.pe_vis(),\n                                             \"unnecessary visibility\");\n                         }\n                         ast::Required(ref m) => {\n@@ -1149,7 +1148,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n         match item.node {\n             ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n-                    check_inherited(tcx, m.span, ast_util::method_vis(&**m));\n+                    check_inherited(tcx, m.span, m.pe_vis());\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n@@ -1175,7 +1174,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                     match *m {\n                         ast::Required(..) => {}\n                         ast::Provided(ref m) => check_inherited(tcx, m.span,\n-                                                                ast_util::method_vis(&**m)),\n+                                                                m.pe_vis()),\n                     }\n                 }\n             }\n@@ -1345,7 +1344,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for method in methods.iter() {\n-                        if ast_util::method_explicit_self(&**method).node == ast::SelfStatic &&\n+                        if method.pe_explicit_self().node == ast::SelfStatic &&\n                             self.exported_items.contains(&method.id) {\n                             found_pub_static = true;\n                             visit::walk_method_helper(self, &**method, ());"}, {"sha": "b228a82bdf7b1bf7fd39ded7367dc2bf9ce0989d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -26,7 +26,7 @@ use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::is_local;\n+use syntax::ast_util::{is_local, PostExpansionMethod};\n use syntax::ast_util;\n use syntax::attr::{InlineAlways, InlineHint, InlineNever, InlineNone};\n use syntax::attr;\n@@ -68,7 +68,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs.as_slice()) ||\n-        generics_require_inlining(ast_util::method_generics(&*method)) {\n+        generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -200,7 +200,7 @@ impl<'a> ReachableContext<'a> {\n                 }\n             }\n             Some(ast_map::NodeMethod(method)) => {\n-                if generics_require_inlining(ast_util::method_generics(&*method)) ||\n+                if generics_require_inlining(method.pe_generics()) ||\n                         attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n@@ -316,14 +316,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(self, ast_util::method_body(&**method), ())\n+                        visit::walk_block(self, method.pe_body(), ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, &*method, did) {\n-                    visit::walk_block(self, ast_util::method_body(&*method), ())\n+                    visit::walk_block(self, method.pe_body(), ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "40237e7984f6c6bf4a741cfd1a241f3149e17db0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -22,8 +22,7 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util;\n-use syntax::ast_util::{local_def};\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_names;\n@@ -1299,20 +1298,20 @@ impl<'a> Resolver<'a> {\n                         // For each method...\n                         for method in methods.iter() {\n                             // Add the method to the module.\n-                            let ident = ast_util::method_ident(&**method);\n+                            let ident = method.pe_ident();\n                             let method_name_bindings =\n                                 self.add_child(ident,\n                                                new_parent.clone(),\n                                                ForbidDuplicateValues,\n                                                method.span);\n-                            let def = match ast_util::method_explicit_self(&**method).node {\n+                            let def = match method.pe_explicit_self().node {\n                                 SelfStatic => {\n                                     // Static methods become\n                                     // `def_static_method`s.\n                                     DefStaticMethod(local_def(method.id),\n                                                       FromImpl(local_def(\n                                                         item.id)),\n-                                                    ast_util::method_fn_style(&**method))\n+                                                      method.pe_fn_style())\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1321,7 +1320,7 @@ impl<'a> Resolver<'a> {\n                                 }\n                             };\n \n-                            let is_public = ast_util::method_vis(&**method) == ast::Public;\n+                            let is_public = method.pe_vis() == ast::Public;\n                             method_name_bindings.define_value(def,\n                                                               method.span,\n                                                               is_public);\n@@ -4004,15 +4003,14 @@ impl<'a> Resolver<'a> {\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n                       method: &Method) {\n-        let method_generics = ast_util::method_generics(method);\n+        let method_generics = method.pe_generics();\n         let type_parameters = HasTypeParameters(method_generics,\n                                                 FnSpace,\n                                                 method.id,\n                                                 rib_kind);\n \n-        self.resolve_function(rib_kind, Some(ast_util::method_fn_decl(method)),\n-                              type_parameters,\n-                              ast_util::method_body(method));\n+        self.resolve_function(rib_kind, Some(method.pe_fn_decl()), type_parameters,\n+                              method.pe_body());\n     }\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n@@ -4083,7 +4081,7 @@ impl<'a> Resolver<'a> {\n     fn check_trait_method(&self, method: &Method) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            let method_name = ast_util::method_ident(method).name;\n+            let method_name = method.pe_ident().name;\n \n             if self.method_map.borrow().find(&(method_name, did)).is_none() {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);"}, {"sha": "9ae2a4c62cd546b022ec93109f49e83bda55fceb", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -43,6 +43,7 @@ use std::os;\n \n use syntax::ast;\n use syntax::ast_util;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::ast::{NodeId,DefId};\n use syntax::ast_map::NodeItem;\n use syntax::attr;\n@@ -333,7 +334,7 @@ impl <'l> DxrVisitor<'l> {\n             },\n         };\n \n-        qualname.push_str(get_ident(ast_util::method_ident(&*method)).get());\n+        qualname.push_str(get_ident(method.pe_ident()).get());\n         let qualname = qualname.as_slice();\n \n         // record the decl for this def (if it has one)\n@@ -349,18 +350,17 @@ impl <'l> DxrVisitor<'l> {\n                             decl_id,\n                             scope_id);\n \n-        let m_decl = ast_util::method_fn_decl(&*method);\n-        self.process_formals(&m_decl.inputs, qualname, e);\n+        self.process_formals(&method.pe_fn_decl().inputs, qualname, e);\n \n         // walk arg and return types\n-        for arg in m_decl.inputs.iter() {\n+        for arg in method.pe_fn_decl().inputs.iter() {\n             self.visit_ty(&*arg.ty, e);\n         }\n-        self.visit_ty(m_decl.output, e);\n+        self.visit_ty(method.pe_fn_decl().output, e);\n         // walk the fn body\n-        self.visit_block(ast_util::method_body(&*method), DxrVisitorEnv::new_nested(method.id));\n+        self.visit_block(method.pe_body(), DxrVisitorEnv::new_nested(method.id));\n \n-        self.process_generic_params(ast_util::method_generics(&*method),\n+        self.process_generic_params(method.pe_generics(),\n                                     method.span,\n                                     qualname,\n                                     method.id,"}, {"sha": "49b6f02356091ce2acafcb286008b60d4a0198e4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -207,6 +207,7 @@ use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n@@ -1138,10 +1139,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n         }\n         ast_map::NodeMethod(ref method) => {\n-            (ast_util::method_ident(&**method),\n-             ast_util::method_fn_decl(&**method),\n-             ast_util::method_generics(&**method),\n-             ast_util::method_body(&**method),\n+            (method.pe_ident(),\n+             method.pe_fn_decl(),\n+             method.pe_generics(),\n+             method.pe_body(),\n              method.span,\n              true)\n         }\n@@ -1167,10 +1168,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeTraitMethod(ref trait_method) => {\n             match **trait_method {\n                 ast::Provided(ref method) => {\n-                    (ast_util::method_ident(&**method),\n-                     ast_util::method_fn_decl(&**method),\n-                     ast_util::method_generics(&**method),\n-                     ast_util::method_body(&**method),\n+                    (method.pe_ident(),\n+                     method.pe_fn_decl(),\n+                     method.pe_generics(),\n+                     method.pe_body(),\n                      method.span,\n                      true)\n                 }"}, {"sha": "bf39f3a6aa385842d1d2a838aafe61dcbffa9648", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -16,7 +16,7 @@ use middle::trans::common::*;\n use middle::ty;\n \n use syntax::ast;\n-use syntax::ast_util::local_def;\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::ast_util;\n \n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n@@ -128,12 +128,11 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n             let unparameterized =\n                 impl_tpt.generics.types.is_empty() &&\n-                ast_util::method_generics(&*mth).ty_params.is_empty();\n+                mth.pe_generics().ty_params.is_empty();\n \n           if unparameterized {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n-                       ast_util::method_body(&*mth), llfn,\n+                trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), llfn,\n                        &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)"}, {"sha": "f9c5f82fb29ac2ff42d86c520cd13625f0f10c38", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -37,7 +37,8 @@ use std::c_str::ToCStr;\n use std::gc::Gc;\n use syntax::abi::Rust;\n use syntax::parse::token;\n-use syntax::{ast, ast_map, visit, ast_util};\n+use syntax::{ast, ast_map, visit};\n+use syntax::ast_util::PostExpansionMethod;\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -65,10 +66,9 @@ pub fn trans_impl(ccx: &CrateContext,\n         return;\n     }\n     for method in methods.iter() {\n-        if ast_util::method_generics(&**method).ty_params.len() == 0u {\n+        if method.pe_generics().ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx, ast_util::method_fn_decl(&**method),\n-                     ast_util::method_body(&**method),\n+            trans_fn(ccx, method.pe_fn_decl(), method.pe_body(),\n                      llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n@@ -160,7 +160,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n             ast_map::NodeTraitMethod(method) => {\n                 let ident = match *method {\n                     ast::Required(ref m) => m.ident,\n-                    ast::Provided(ref m) => ast_util::method_ident(&**m)\n+                    ast::Provided(ref m) => m.pe_ident()\n                 };\n                 ident.name\n             }"}, {"sha": "6ff6c4741c77c87763a26dd7037be321db638825", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -25,8 +25,7 @@ use util::ppaux::Repr;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax::ast_util::local_def;\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use std::hash::{sip, Hash};\n \n pub fn monomorphic_fn(ccx: &CrateContext,\n@@ -182,17 +181,16 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n-                     ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n+            trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n-                             ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n+                    trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n+                             &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {"}, {"sha": "bc4d1c73ffbf39cfd08ade998311fe50391b98de", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -125,7 +125,7 @@ use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::local_def;\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -757,16 +757,14 @@ fn check_method_body(ccx: &CrateCtxt,\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n     let method_generics = &method_ty.generics;\n-    let m_body = ast_util::method_body(&*method);\n \n     let param_env = ty::construct_parameter_environment(ccx.tcx,\n                                                         method_generics,\n-                                                        m_body.id);\n+                                                        method.pe_body().id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n-    check_bare_fn(ccx, ast_util::method_fn_decl(&*method),\n-                  m_body, method.id, fty, param_env);\n+    check_bare_fn(ccx, method.pe_fn_decl(), method.pe_body(), method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n@@ -794,7 +792,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                 compare_impl_method(ccx.tcx,\n                                     &*impl_method_ty,\n                                     impl_method.span,\n-                                    ast_util::method_body(&**impl_method).id,\n+                                    impl_method.pe_body().id,\n                                     &**trait_method_ty,\n                                     &impl_trait_ref.substs);\n             }\n@@ -817,7 +815,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n     for trait_method in trait_methods.iter() {\n         let is_implemented =\n             impl_methods.iter().any(\n-                |m| ast_util::method_ident(&**m).name == trait_method.ident.name);\n+                |m| m.pe_ident().name == trait_method.ident.name);\n         let is_provided =\n             provided_methods.iter().any(\n                 |m| m.ident.name == trait_method.ident.name);"}, {"sha": "e21a7949ec79975154cec27c8c7bdeb51d7b3b87", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -57,8 +57,7 @@ use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax::ast_util::{local_def, method_ident, split_trait_methods};\n+use syntax::ast_util::{local_def, split_trait_methods, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n@@ -214,11 +213,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_def.generics,\n-                                    &m.id, &ast_util::method_ident(&**m),\n-                                    ast_util::method_explicit_self(&**m),\n-                                    ast_util::method_generics(&**m),\n-                                    &ast_util::method_fn_style(&**m),\n-                                    ast_util::method_fn_decl(&**m))\n+                                    &m.id, &m.pe_ident(), m.pe_explicit_self(),\n+                                    m.pe_generics(), &m.pe_fn_style(), m.pe_fn_decl())\n                             }\n                         });\n \n@@ -334,7 +330,7 @@ fn convert_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n-        if !seen_methods.insert(ast_util::method_ident(&**m).repr(tcx)) {\n+        if !seen_methods.insert(m.pe_ident().repr(ccx.tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n@@ -346,9 +342,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n-                method_ident(&**m).repr(tcx),\n+                m.pe_ident().repr(ccx.tcx),\n                 m.id,\n-                fty.repr(tcx));\n+                fty.repr(ccx.tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n             Polytype {\n@@ -369,24 +365,23 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_visibility: ast::Visibility)\n                     -> ty::Method\n     {\n-        let fty = astconv::ty_of_method(ccx, m.id, ast_util::method_fn_style(&*m),\n+        let fty = astconv::ty_of_method(ccx, m.id, m.pe_fn_style(),\n                                         untransformed_rcvr_ty,\n-                                        *ast_util::method_explicit_self(&*m),\n-                                        ast_util::method_fn_decl(&*m));\n+                                        *m.pe_explicit_self(), m.pe_fn_decl());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n         // { fn foo(); }` is public, but private in `priv impl { fn\n         // foo(); }`).\n-        let method_vis = ast_util::method_vis(&*m).inherit_from(rcvr_visibility);\n+        let method_vis = m.pe_vis().inherit_from(rcvr_visibility);\n \n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx, ast_util::method_generics(&*m),\n+            ty_generics_for_fn_or_method(ccx, m.pe_generics(),\n                                          (*rcvr_ty_generics).clone());\n-        ty::Method::new(ast_util::method_ident(&*m),\n+        ty::Method::new(m.pe_ident(),\n                         m_ty_generics,\n                         fty,\n-                        ast_util::method_explicit_self(&*m).node,\n+                        m.pe_explicit_self().node,\n                         method_vis,\n                         local_def(m.id),\n                         container,"}, {"sha": "8be1700b635b4fccb251b5302b2cd29b0a197f81", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -84,7 +84,7 @@ use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n-use syntax::ast_util::name_to_dummy_lifetime;\n+use syntax::ast_util::{name_to_dummy_lifetime, PostExpansionMethod};\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -700,11 +700,8 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     }\n                 }\n                 ast_map::NodeMethod(ref m) => {\n-                    Some((ast_util::method_fn_decl(&**m),\n-                          ast_util::method_generics(&**m),\n-                          ast_util::method_fn_style(&**m),\n-                          ast_util::method_ident(&**m),\n-                          Some(ast_util::method_explicit_self(&**m).node), m.span))\n+                    Some((m.pe_fn_decl(), m.pe_generics(), m.pe_fn_style(),\n+                          m.pe_ident(), Some(m.pe_explicit_self().node), m.span))\n                 },\n                 _ => None\n             },\n@@ -1455,7 +1452,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 _ => None\n             },\n             ast_map::NodeMethod(m) => {\n-                taken.push_all(ast_util::method_generics(&*m).lifetimes.as_slice());\n+                taken.push_all(m.pe_generics().lifetimes.as_slice());\n                 Some(m.id)\n             },\n             _ => None"}, {"sha": "fdf98f392a7430515eeabc6460cedb3ddf02b547", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -14,6 +14,7 @@\n use syntax;\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Pos;\n@@ -695,30 +696,30 @@ pub struct Method {\n \n impl Clean<Item> for ast::Method {\n     fn clean(&self) -> Item {\n-        let fn_decl = ast_util::method_fn_decl(self);\n-        let inputs = match ast_util::method_explicit_self(self).node {\n-            ast::SelfStatic => fn_decl.inputs.as_slice(),\n-            _ => fn_decl.inputs.slice_from(1)\n+        let all_inputs = &self.pe_fn_decl().inputs;\n+        let inputs = match self.pe_explicit_self().node {\n+            ast::SelfStatic => all_inputs.as_slice(),\n+            _ => all_inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean()).collect(),\n             },\n-            output: (fn_decl.output.clean()),\n-            cf: fn_decl.cf.clean(),\n+            output: (self.pe_fn_decl().output.clean()),\n+            cf: self.pe_fn_decl().cf.clean(),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(ast_util::method_ident(self).clean()),\n+            name: Some(self.pe_ident().clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n-            visibility: ast_util::method_vis(self).clean(),\n+            visibility: self.pe_vis().clean(),\n             stability: get_stability(ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n-                generics: ast_util::method_generics(self).clean(),\n-                self_: ast_util::method_explicit_self(self).node.clean(),\n-                fn_style: ast_util::method_fn_style(self).clone(),\n+                generics: self.pe_generics().clean(),\n+                self_: self.pe_explicit_self().node.clean(),\n+                fn_style: self.pe_fn_style().clone(),\n                 decl: decl,\n             }),\n         }"}, {"sha": "a522f80554327f89a297c2c6107c821923cad6bb", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -26,7 +26,7 @@ use ast::{P, Block, FnDecl, NodeId};\n use ast;\n use ast_map::{Node};\n use ast_map;\n-use ast_util;\n+use ast_util::PostExpansionMethod;\n use codemap::Span;\n use visit;\n \n@@ -152,13 +152,13 @@ impl FnLikeNode {\n \n     pub fn body<'a>(&'a self) -> P<Block> {\n         self.handle(|i: ItemFnParts|     i.body,\n-                    |m: &'a ast::Method| ast_util::method_body(m),\n+                    |m: &'a ast::Method| m.pe_body(),\n                     |c: ClosureParts|    c.body)\n     }\n \n     pub fn decl<'a>(&'a self) -> P<FnDecl> {\n         self.handle(|i: ItemFnParts|     i.decl,\n-                    |m: &'a ast::Method| ast_util::method_fn_decl(m),\n+                    |m: &'a ast::Method| m.pe_fn_decl(),\n                     |c: ClosureParts|    c.decl)\n     }\n \n@@ -182,7 +182,7 @@ impl FnLikeNode {\n             visit::FkFnBlock\n         };\n         let method = |m: &'a ast::Method| {\n-            visit::FkMethod(ast_util::method_ident(m), ast_util::method_generics(m), m)\n+            visit::FkMethod(m.pe_ident(), m.pe_generics(), m)\n         };\n         self.handle(item, method, closure)\n     }"}, {"sha": "5431a3db16ecb24a437f29161f47ff15fab16232", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=efbbb51ec0bfa371573bd4ae2c34b1ba69e11e11", "patch": "@@ -742,37 +742,98 @@ pub fn static_has_significant_address(mutbl: ast::Mutability,\n     inline == InlineNever || inline == InlineNone\n }\n \n-\n /// Macro invocations are guaranteed not to occur after expansion is complete.\n-/// extracting fields of a method requires a dynamic check to make sure that it's\n-/// not a macro invocation, though this check is guaranteed to succeed, assuming\n+/// Extracting fields of a method requires a dynamic check to make sure that it's\n+/// not a macro invocation. This check is guaranteed to succeed, assuming\n /// that the invocations are indeed gone.\n-macro_rules! method_field_extractor {\n-    ($fn_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n-        /// Returns the ident of a Method. To be used after expansion is complete\n-        pub fn $fn_name<'a>(method: &'a ast::Method) -> $field_ty {\n-            match method.node {\n+pub trait PostExpansionMethod {\n+    fn pe_ident(&self) -> ast::Ident;\n+    fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n+    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n+    fn pe_fn_style(&self) -> ast::FnStyle;\n+    fn pe_fn_decl(&self) -> P<ast::FnDecl>;\n+    fn pe_body(&self) -> P<ast::Block>;\n+    fn pe_vis(&self) -> ast::Visibility;\n+}\n+\n+\n+/// can't use the standard cfg(stage0) tricks here, because the error occurs in\n+/// parsing, before cfg gets a chance to save the day. (yes, interleaved parsing\n+/// / expansion / configuring would solve this problem...)\n+\n+// NOTE: remove after next snapshot\n+/// to be more specific: after a snapshot, swap out the \"PRE\" stuff, and\n+// swap in the \"POST\" stuff.\n+\n+/// PRE\n+macro_rules! mf_method_body{\n+    ($slf:ident, $field_pat:pat, $result:ident) => {\n+        match $slf.node {\n+            $field_pat => $result,\n+                MethMac(_) => {\n+                    fail!(\"expected an AST without macro invocations\");\n+                }\n+        }\n+    }\n+}\n+\n+/// POST\n+/*\n+#[cfg(not(stage0))]\n+macro_rules! mf_method{\n+    ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+        fn $meth_name<'a>(&'a self) -> $field_ty {\n+            match self.node {\n                 $field_pat => $result,\n                 MethMac(_) => {\n                     fail!(\"expected an AST without macro invocations\");\n                 }\n             }\n         }\n     }\n+}*/\n+\n+\n+// PRE\n+impl PostExpansionMethod for Method {\n+    fn pe_ident(&self) -> ast::Ident {\n+        mf_method_body!(self,MethDecl(ident,_,_,_,_,_,_),ident)\n+    }\n+    fn pe_generics<'a>(&'a self) -> &'a ast::Generics {\n+        mf_method_body!(self,MethDecl(_,ref generics,_,_,_,_,_),generics)\n+    }\n+    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf {\n+        mf_method_body!(self,MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+    }\n+    fn pe_fn_style(&self) -> ast::FnStyle{\n+        mf_method_body!(self,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+    }\n+    fn pe_fn_decl(&self) -> P<ast::FnDecl> {\n+        mf_method_body!(self,MethDecl(_,_,_,_,decl,_,_),decl)\n+    }\n+    fn pe_body(&self) -> P<ast::Block> {\n+        mf_method_body!(self,MethDecl(_,_,_,_,_,body,_),body)\n+    }\n+    fn pe_vis(&self) -> ast::Visibility {\n+        mf_method_body!(self,MethDecl(_,_,_,_,_,_,vis),vis)\n+    }\n }\n \n-// Note: this is unhygienic in the lifetime 'a. In order to fix this, we'd have to\n-// add :lifetime as a macro argument type, so that the 'a could be supplied by the macro\n-// invocation.\n-pub method_field_extractor!(method_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n-pub method_field_extractor!(method_generics,&'a ast::Generics,\n-                            MethDecl(_,ref generics,_,_,_,_,_),generics)\n-pub method_field_extractor!(method_explicit_self,&'a ast::ExplicitSelf,\n-                            MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n-pub method_field_extractor!(method_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n-pub method_field_extractor!(method_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n-pub method_field_extractor!(method_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n-pub method_field_extractor!(method_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+// POST\n+/*\n+#[cfg(not(stage0))]\n+impl PostExpansionMethod for Method {\n+    mf_method!(pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n+    mf_method!(pe_generics,&'a ast::Generics,\n+               MethDecl(_,ref generics,_,_,_,_,_),generics)\n+    mf_method!(pe_explicit_self,&'a ast::ExplicitSelf,\n+               MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+    mf_method!(pe_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+    mf_method!(pe_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n+    mf_method!(pe_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n+    mf_method!(pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+}\n+*/\n \n #[cfg(test)]\n mod test {\n@@ -799,4 +860,3 @@ mod test {\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }\n-"}]}