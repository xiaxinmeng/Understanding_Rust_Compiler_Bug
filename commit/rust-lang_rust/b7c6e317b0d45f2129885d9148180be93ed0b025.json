{"sha": "b7c6e317b0d45f2129885d9148180be93ed0b025", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YzZlMzE3YjBkNDVmMjEyOTg4NWQ5MTQ4MTgwYmU5M2VkMGIwMjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-27T09:22:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:22Z"}, "message": "Make projected types select out of the trait bounds.", "tree": {"sha": "286eaeebdc2cc4a820ae10ed34f7c6b71183271c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/286eaeebdc2cc4a820ae10ed34f7c6b71183271c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7c6e317b0d45f2129885d9148180be93ed0b025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7c6e317b0d45f2129885d9148180be93ed0b025", "html_url": "https://github.com/rust-lang/rust/commit/b7c6e317b0d45f2129885d9148180be93ed0b025", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7c6e317b0d45f2129885d9148180be93ed0b025/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de806bc057caa599fce959ce56259e6e919f1041", "url": "https://api.github.com/repos/rust-lang/rust/commits/de806bc057caa599fce959ce56259e6e919f1041", "html_url": "https://github.com/rust-lang/rust/commit/de806bc057caa599fce959ce56259e6e919f1041"}], "stats": {"total": 485, "additions": 321, "deletions": 164}, "files": [{"sha": "fb20df020acf8b73fe35a71b84e0801089fcdb77", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -31,7 +31,6 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n-use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -120,19 +119,14 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        match traits::poly_trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n-            Ok(trait_ref) => {\n-                let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-                fulfill_cx.register_trait_ref(self.tcx, trait_ref, cause);\n-                let env = ty::empty_parameter_environment();\n-                match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n-                    Ok(()) => { },\n-                    Err(ref errors) => {\n-                      traits::report_fulfillment_errors(&infcx, errors);\n-                    }\n-                }\n+        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+        let env = ty::empty_parameter_environment();\n+        match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+            Ok(()) => { },\n+            Err(ref errors) => {\n+                traits::report_fulfillment_errors(&infcx, errors);\n             }\n-            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "a87db776ce053b549ab04ae1b699e7766591a666", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -412,6 +412,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n+    pub fn to_vec(self) -> Vec<T> {\n+        self.content\n+    }\n+\n     pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n         P: FnMut(&[T]) -> bool,\n     {"}, {"sha": "0d2023ead4fcc5aadbaad6b62a8c70b2ed983575", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -119,43 +119,43 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                 ty: ty_var\n             });\n         let obligation = Obligation::new(cause, projection.as_predicate());\n-        self.register_predicate(infcx.tcx, obligation);\n+        self.register_predicate(infcx, obligation);\n         ty_var\n     }\n \n-    pub fn register_builtin_bound(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  builtin_bound: ty::BuiltinBound,\n-                                  cause: ObligationCause<'tcx>)\n+    pub fn register_builtin_bound<'a>(&mut self,\n+                                      infcx: &InferCtxt<'a,'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      builtin_bound: ty::BuiltinBound,\n+                                      cause: ObligationCause<'tcx>)\n     {\n-        match predicate_for_builtin_bound(tcx, cause, builtin_bound, 0, ty) {\n+        match predicate_for_builtin_bound(infcx.tcx, cause, builtin_bound, 0, ty) {\n             Ok(predicate) => {\n-                self.register_predicate(tcx, predicate);\n+                self.register_predicate(infcx, predicate);\n             }\n             Err(ErrorReported) => { }\n         }\n     }\n \n-    pub fn register_region_obligation(&mut self,\n-                                      tcx: &ty::ctxt<'tcx>,\n-                                      t_a: Ty<'tcx>,\n-                                      r_b: ty::Region,\n-                                      cause: ObligationCause<'tcx>)\n+    pub fn register_region_obligation<'a>(&mut self,\n+                                          infcx: &InferCtxt<'a,'tcx>,\n+                                          t_a: Ty<'tcx>,\n+                                          r_b: ty::Region,\n+                                          cause: ObligationCause<'tcx>)\n     {\n-        register_region_obligation(tcx, t_a, r_b, cause, &mut self.region_obligations);\n+        register_region_obligation(infcx.tcx, t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n     pub fn register_predicate<'a>(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n+                                  infcx: &InferCtxt<'a,'tcx>,\n                                   obligation: PredicateObligation<'tcx>)\n     {\n         if !self.duplicate_set.insert(obligation.predicate.clone()) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(tcx));\n+            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", obligation.repr(tcx));\n+        debug!(\"register_predicate({})\", obligation.repr(infcx.tcx));\n         self.predicates.push(obligation);\n     }\n \n@@ -230,7 +230,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                self.predicates.len(),\n                only_new_obligations);\n \n-        let tcx = selcx.tcx();\n         let mut errors = Vec::new();\n \n         loop {\n@@ -279,7 +278,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n             for new_obligation in new_obligations.into_iter() {\n-                self.register_predicate(tcx, new_obligation);\n+                self.register_predicate(selcx.infcx(), new_obligation);\n             }\n         }\n \n@@ -469,17 +468,22 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                             CodeProjectionError(e)));\n                     true\n                 }\n-                Err(project::ProjectionError::TraitSelectionError(e)) => {\n-                    // Extract just the `T : Trait` from `<T as\n-                    // Trait>::Name == U`, so that when we report an\n-                    // error to the user, it says something like \"`T :\n-                    // Trait` not satisfied\".5D\n+                Err(project::ProjectionError::TraitSelectionError(_)) => {\n+                    // There was an error matching `T : Trait` (which\n+                    // is a pre-requisite for `<T as Trait>::Name`\n+                    // being valid).  We could just report the error\n+                    // now, but that tends to lead to double error\n+                    // reports for the user (one for the obligation `T\n+                    // : Trait`, typically incurred somewhere else,\n+                    // and one from here). Instead, we'll create the\n+                    // `T : Trait` obligation and add THAT as a\n+                    // requirement. This will (eventually) trigger the\n+                    // same error, but it will also wind up flagged as\n+                    // a duplicate if another requirement that `T :\n+                    // Trait` arises from somewhere else.\n                     let trait_predicate = data.to_poly_trait_ref();\n                     let trait_obligation = obligation.with(trait_predicate.as_predicate());\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            trait_obligation,\n-                            CodeSelectionError(e)));\n+                    new_obligations.push(trait_obligation);\n                     true\n                 }\n             }"}, {"sha": "d7febea8909b174a26edb6f8db001dea2fa46e91", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -37,7 +37,6 @@ pub use self::util::elaborate_predicates;\n pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n-pub use self::util::search_trait_and_supertraits_from_bound;\n pub use self::util::transitive_bounds;\n \n mod coherence;\n@@ -189,10 +188,10 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///\n ///    // Case B: Vtable must be provided by caller. This applies when\n ///    // type is a type parameter.\n-///    param.clone();    // VtableParam(Oblig_1)\n+///    param.clone();    // VtableParam\n ///\n ///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n /// }\n /// ```\n ///\n@@ -206,7 +205,7 @@ pub enum Vtable<'tcx, N> {\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParamData<'tcx>),\n+    VtableParam,\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -243,15 +242,6 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n-/// A vtable provided as a parameter by the caller. For example, in a\n-/// function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n-/// on an instance of `T`, the vtable would be of type `VtableParam`.\n-#[deriving(PartialEq,Eq,Clone)]\n-pub struct VtableParamData<'tcx> {\n-    // In the above example, this would `Eq`\n-    pub bound: ty::PolyTraitRef<'tcx>,\n-}\n-\n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n /// of a trait, not an inherent impl.\n pub fn is_orphan_impl(tcx: &ty::ctxt,\n@@ -302,7 +292,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     // (there shouldn't really be any anyhow).\n     let cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n \n-    fulfill_cx.register_builtin_bound(infcx.tcx, ty, bound, cause);\n+    fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n \n     // Note: we only assume something is `Copy` if we can\n     // *definitively* show that it implements `Copy`. Otherwise,\n@@ -361,7 +351,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n-            VtableParam(_) => (&[]).iter(),\n+            VtableParam => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n     }\n@@ -371,7 +361,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n-            VtableParam(ref p) => VtableParam((*p).clone()),\n+            VtableParam => VtableParam,\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n     }\n@@ -383,7 +373,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n-            VtableParam(p) => VtableParam(p),\n+            VtableParam => VtableParam,\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }\n     }"}, {"sha": "43f97de2d4383ff18a0c3b6080c2eab582de9bfe", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -128,10 +128,12 @@ pub fn project_type<'cx,'tcx>(\n                                                   &mut candidates);\n \n     if candidates.vec.is_empty() {\n-        // TODO This `if` is not necessarily wrong, but it needs an\n-        // explanation, and it should probably be accompanied by a\n-        // similar rule in `select.rs`. Currently it's *needed*\n-        // because the impl-trait-for-trait branch has not landed.\n+        // FIXME(#20297) -- In `select.rs` there is similar logic that\n+        // gives precedence to where-clauses, but it's a bit more\n+        // fine-grained. I was lazy here and just always give\n+        // precedence to where-clauses or other such sources over\n+        // actually dredging through impls. This logic probably should\n+        // be tightened up.\n \n         let () = try!(assemble_candidates_from_impls(selcx,\n                                                      obligation,"}, {"sha": "2e4bdadb8c231644662649895204e7a69b03999b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 180, "deletions": 21, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -24,7 +24,7 @@ use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n-use super::{VtableImplData, VtableParamData, VtableBuiltinData};\n+use super::{VtableImplData, VtableBuiltinData};\n use super::{util};\n \n use middle::fast_reject;\n@@ -131,9 +131,13 @@ pub enum MethodMatchedData {\n #[deriving(PartialEq,Eq,Show,Clone)]\n enum SelectionCandidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n-    ParamCandidate(VtableParamData<'tcx>),\n+    ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n \n+    /// This is a trait matching with a projected type as `Self`, and\n+    /// we found an applicable bound in the trait definition.\n+    ProjectionCandidate,\n+\n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n     UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n@@ -507,8 +511,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = candidate_set.vec;\n \n-        debug!(\"assembled {} candidates for {}\",\n-               candidates.len(), stack.repr(self.tcx()));\n+        debug!(\"assembled {} candidates for {}: {}\",\n+               candidates.len(),\n+               stack.repr(self.tcx()),\n+               candidates.repr(self.tcx()));\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -706,11 +712,137 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n+        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n         try!(self.assemble_candidates_from_caller_bounds(obligation, &mut candidates));\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n     }\n \n+    fn assemble_candidates_from_projected_tys(&mut self,\n+                                              obligation: &TraitObligation<'tcx>,\n+                                              candidates: &mut SelectionCandidateSet<'tcx>)\n+    {\n+        let poly_trait_predicate =\n+            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        debug!(\"assemble_candidates_for_projected_tys({},{})\",\n+               obligation.repr(self.tcx()),\n+               poly_trait_predicate.repr(self.tcx()));\n+\n+        // FIXME(#20297) -- just examining the self-type is very simplistic\n+\n+        // before we go into the whole skolemization thing, just\n+        // quickly check if the self-type is a projection at all.\n+        let trait_def_id = match poly_trait_predicate.0.trait_ref.self_ty().sty {\n+            ty::ty_projection(ref data) => data.trait_ref.def_id,\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                // TODO ignore potential ambiguity so that we can do\n+                // better inference, need to get our story\n+                // straight(er) here, I think.\n+                // candidates.ambiguous = true;\n+                return;\n+            }\n+            _ => { return; }\n+        };\n+\n+        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={}\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        let result = self.infcx.probe(|snapshot| {\n+            self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                       snapshot)\n+        });\n+\n+        if result {\n+            candidates.vec.push(ProjectionCandidate);\n+        }\n+    }\n+\n+    fn match_projection_obligation_against_bounds_from_trait(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        snapshot: &infer::CombinedSnapshot)\n+        -> bool\n+    {\n+        let poly_trait_predicate =\n+            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+        let (skol_trait_predicate, skol_map) =\n+            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                skol_trait_predicate={} skol_map={}\",\n+               skol_trait_predicate.repr(self.tcx()),\n+               skol_map.repr(self.tcx()));\n+\n+        let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n+            ty::ty_projection(ref data) => &data.trait_ref,\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n+                             but self-ty not a projection: {}\",\n+                            skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())).as_slice());\n+            }\n+        };\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                projection_trait_ref={}\",\n+               projection_trait_ref.repr(self.tcx()));\n+\n+        let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n+        let bounds = trait_def.generics.to_bounds(self.tcx(), &projection_trait_ref.substs);\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                bounds={}\",\n+               bounds.repr(self.tcx()));\n+\n+        let matching_bound =\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.to_vec())\n+            .filter_to_traits()\n+            .find(\n+                |bound| self.infcx.probe(\n+                    |_| self.match_projection(obligation,\n+                                              bound.clone(),\n+                                              skol_trait_predicate.trait_ref.clone(),\n+                                              &skol_map,\n+                                              snapshot)));\n+\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                matching_bound={}\",\n+               matching_bound.repr(self.tcx()));\n+        match matching_bound {\n+            None => false,\n+            Some(bound) => {\n+                // Repeat the successful match, if any, this time outside of a probe.\n+                let result = self.match_projection(obligation,\n+                                                   bound,\n+                                                   skol_trait_predicate.trait_ref.clone(),\n+                                                   &skol_map,\n+                                                   snapshot);\n+                assert!(result);\n+                true\n+            }\n+        }\n+    }\n+\n+    fn match_projection(&mut self,\n+                        obligation: &TraitObligation<'tcx>,\n+                        trait_bound: ty::PolyTraitRef<'tcx>,\n+                        skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                        skol_map: &infer::SkolemizationMap,\n+                        snapshot: &infer::CombinedSnapshot)\n+                        -> bool\n+    {\n+        assert!(!skol_trait_ref.has_escaping_regions());\n+        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             trait_bound.clone(),\n+                                             ty::Binder(skol_trait_ref.clone())) {\n+            Ok(()) => { }\n+            Err(_) => { return false; }\n+        }\n+\n+        self.infcx.leak_check(skol_map, snapshot).is_ok()\n+    }\n+\n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n     /// supplied to find out whether it is listed among them.\n     ///\n@@ -738,8 +870,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n-            matching_bounds.map(\n-                |bound| ParamCandidate(VtableParamData { bound: bound }));\n+            matching_bounds.map(|bound| ParamCandidate(bound));\n \n         candidates.vec.extend(param_candidates);\n \n@@ -933,7 +1064,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                    -> bool\n     {\n         match (candidate_i, candidate_j) {\n-            (&ImplCandidate(impl_def_id), &ParamCandidate(ref vt)) => {\n+            (&ImplCandidate(impl_def_id), &ParamCandidate(ref bound)) => {\n                 debug!(\"Considering whether to drop param {} in favor of impl {}\",\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));\n@@ -954,10 +1085,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n-                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, vt.bound.clone())\n+                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, bound.clone())\n                         .is_ok()\n                 })\n             }\n+            (&ProjectionCandidate, &ParamCandidate(_)) => {\n+                // FIXME(#20297) -- this gives where clauses precedent\n+                // over projections. Really these are just two means\n+                // of deducing information (one based on the where\n+                // clauses on the trait definition; one based on those\n+                // on the enclosing scope), and it'd be better to\n+                // integrate them more intelligently. But for now this\n+                // seems ok. If we DON'T give where clauses\n+                // precedence, we run into trouble in default methods,\n+                // where both the projection bounds for `Self::A` and\n+                // the where clauses are in scope.\n+                true\n+            }\n             _ => {\n                 *candidate_i == *candidate_j\n             }\n@@ -1390,8 +1534,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ParamCandidate(param) => {\n-                Ok(VtableParam(\n-                    try!(self.confirm_param_candidate(obligation, param))))\n+                self.confirm_param_candidate(obligation, param);\n+                Ok(VtableParam)\n             }\n \n             ImplCandidate(impl_def_id) => {\n@@ -1410,14 +1554,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_fn_pointer_candidate(obligation));\n                 Ok(VtableFnPointer(fn_type))\n             }\n+\n+            ProjectionCandidate => {\n+                self.confirm_projection_candidate(obligation);\n+                Ok(VtableParam)\n+            }\n         }\n     }\n \n+    fn confirm_projection_candidate(&mut self,\n+                                    obligation: &TraitObligation<'tcx>)\n+    {\n+        let _: Result<(),()> =\n+            self.infcx.try(|snapshot| {\n+                let result =\n+                    self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                               snapshot);\n+                assert!(result);\n+                Ok(())\n+            });\n+    }\n+\n     fn confirm_param_candidate(&mut self,\n                                obligation: &TraitObligation<'tcx>,\n-                               param: VtableParamData<'tcx>)\n-                               -> Result<VtableParamData<'tcx>,\n-                                         SelectionError<'tcx>>\n+                               param: ty::PolyTraitRef<'tcx>)\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1429,12 +1589,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // transactional boundary; it should not fail.\n         match self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                            obligation.predicate.to_poly_trait_ref(),\n-                                           param.bound.clone()) {\n-            Ok(()) => Ok(param),\n+                                           param.clone()) {\n+            Ok(()) => { }\n             Err(_) => {\n                 self.tcx().sess.bug(\n                     format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                            param.bound.repr(self.tcx()),\n+                            param.repr(self.tcx()),\n                             obligation.repr(self.tcx())).as_slice());\n             }\n         }\n@@ -1981,14 +2141,13 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n+            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n+            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n+            ProjectionCandidate => format!(\"ProjectionCandidate\"),\n+            FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             UnboxedClosureCandidate(c, ref s) => {\n                 format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n             }\n-            FnPointerCandidate => {\n-                format!(\"FnPointerCandidate\")\n-            }\n-            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n-            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "95567d8240a2d3efa7088a09188ce2da62959e30", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -20,7 +20,7 @@ use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n-            VtableImpl, VtableParam, VtableParamData, VtableImplData};\n+            VtableImpl, VtableParam, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n // `Elaboration` iterator\n@@ -78,6 +78,10 @@ pub fn elaborate_predicates<'cx, 'tcx>(\n }\n \n impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n+    pub fn filter_to_traits(self) -> Supertraits<'cx, 'tcx> {\n+        Supertraits { elaborator: self }\n+    }\n+\n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n@@ -183,16 +187,14 @@ pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Supertraits<'cx, 'tcx>\n {\n-    let elaborator = elaborate_trait_ref(tcx, trait_ref);\n-    Supertraits { elaborator: elaborator }\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                                     bounds: &[ty::PolyTraitRef<'tcx>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n-    let elaborator = elaborate_trait_refs(tcx, bounds);\n-    Supertraits { elaborator: elaborator }\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n impl<'cx, 'tcx> Iterator<ty::PolyTraitRef<'tcx>> for Supertraits<'cx, 'tcx> {\n@@ -247,12 +249,6 @@ impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     }\n }\n \n-impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableParam(...)\")\n-    }\n-}\n-\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n@@ -306,26 +302,6 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     })\n }\n \n-/// Starting from a caller obligation `caller_bound` (which has coordinates `space`/`i` in the list\n-/// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n-/// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n-/// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n-                                                       caller_bound: ty::PolyTraitRef<'tcx>,\n-                                                       mut test: F)\n-                                                       -> Option<VtableParamData<'tcx>>\n-    where F: FnMut(ast::DefId) -> bool,\n-{\n-    for bound in transitive_bounds(tcx, &[caller_bound]) {\n-        if test(bound.def_id()) {\n-            let vtable_param = VtableParamData { bound: bound };\n-            return Some(vtable_param);\n-        }\n-    }\n-\n-    return None;\n-}\n-\n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(predicate={},depth={})\",\n@@ -349,8 +325,8 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableFnPointer({})\",\n                         d.repr(tcx)),\n \n-            super::VtableParam(ref v) =>\n-                format!(\"VtableParam({})\", v.repr(tcx)),\n+            super::VtableParam =>\n+                format!(\"VtableParam\"),\n \n             super::VtableBuiltin(ref d) =>\n                 d.repr(tcx)\n@@ -374,13 +350,6 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::VtableParamData<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableParam(bound={})\",\n-                self.bound.repr(tcx))\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {"}, {"sha": "1e7605c0f171c44b8b42fd779b635b92cb7f67f9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -501,20 +501,12 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))\n             }\n-            traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n+            traits::VtableParam => traits::VtableParam,\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n         }\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData<'tcx> {\n-        traits::VtableParamData {\n-            bound: self.bound.fold_with(folder),\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n         ty::EquatePredicate(self.0.fold_with(folder),"}, {"sha": "06819aac5bc04b5e37688dd64ccdfb691571e80c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -960,7 +960,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // iterating early.\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let vtable = selection.map_move_nested(|predicate| {\n-        fulfill_cx.register_predicate(infcx.tcx, predicate);\n+        fulfill_cx.register_predicate(&infcx, predicate);\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }"}, {"sha": "2ede6e2e47fd26928d990c9fc6f5521d7a17871f", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -565,7 +565,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n                 llfn.into_iter()\n             }\n-            traits::VtableParam(..) => {\n+            traits::VtableParam => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),"}, {"sha": "4bc1246d39359bdc40dde0b785a5d5e434aaa10a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -1871,7 +1871,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n         self.inh.fulfillment_cx.borrow_mut()\n-            .register_builtin_bound(self.tcx(), ty, builtin_bound, cause);\n+            .register_builtin_bound(self.infcx(), ty, builtin_bound, cause);\n     }\n \n     pub fn register_predicate(&self,\n@@ -1882,7 +1882,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.inh.fulfillment_cx\n             .borrow_mut()\n-            .register_predicate(self.tcx(), obligation);\n+            .register_predicate(self.infcx(), obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n@@ -2026,7 +2026,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        fulfillment_cx.register_region_obligation(self.tcx(), ty, region, cause);\n+        fulfillment_cx.register_region_obligation(self.infcx(), ty, region, cause);\n     }\n \n     pub fn add_default_region_param_bounds(&self,"}, {"sha": "b311f10c0a320fd94225f75ffb5b2be7c4eb9a10", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -842,16 +842,15 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             generics,\n                                             items);\n \n+    assert_eq!(mk_item_substs(ccx, &ty_generics), substs);\n+\n     let self_param_ty = ty::ParamTy::for_self(def_id);\n \n     let bounds = compute_bounds(ccx,\n-                                token::SELF_KEYWORD_NAME,\n-                                self_param_ty,\n+                                self_param_ty.to_ty(ccx.tcx),\n                                 bounds.as_slice(),\n                                 it.span);\n \n-    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n-\n     let associated_type_names: Vec<_> =\n         items.iter()\n              .filter_map(|item| {\n@@ -862,14 +861,16 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n              })\n             .collect();\n \n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: def_id,\n+        substs: substs\n+    });\n+\n     let trait_def = Rc::new(ty::TraitDef {\n         unsafety: unsafety,\n         generics: ty_generics,\n         bounds: bounds,\n-        trait_ref: Rc::new(ty::TraitRef {\n-            def_id: def_id,\n-            substs: substs\n-        }),\n+        trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n     });\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n@@ -1027,9 +1028,12 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n-                                   _items: &[ast::TraitItem])\n+                                   trait_items: &[ast::TraitItem])\n                                    -> ty::Generics<'tcx>\n {\n+    debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n+           local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n+\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n@@ -1045,8 +1049,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        ty::Binder(Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n-                                          substs: substs }));\n+        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n+                               substs: substs });\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -1056,7 +1060,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         bounds: ty::ParamBounds {\n             region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: vec!(self_trait_ref.clone()),\n+            trait_bounds: vec!(ty::Binder(self_trait_ref.clone())),\n             projection_bounds: vec!(),\n         },\n         default: None\n@@ -1068,7 +1072,47 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     generics.predicates.push(subst::SelfSpace, self_trait_ref.as_predicate());\n \n-    generics\n+    let assoc_predicates = predicates_for_associated_types(ccx,\n+                                                           &self_trait_ref,\n+                                                           trait_items);\n+\n+    debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n+\n+    for assoc_predicate in assoc_predicates.into_iter() {\n+        generics.predicates.push(subst::SelfSpace, assoc_predicate);\n+    }\n+\n+    return generics;\n+\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 trait_items: &[ast::TraitItem])\n+                                                 -> Vec<ty::Predicate<'tcx>>\n+    {\n+        trait_items\n+            .iter()\n+            .flat_map(|trait_item| {\n+                let assoc_type_def = match *trait_item {\n+                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n+                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                        return vec!().into_iter();\n+                    }\n+                };\n+\n+                let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                                 self_trait_ref.clone(),\n+                                                 assoc_type_def.ident.name);\n+\n+                let bounds = compute_bounds(ccx,\n+                                            assoc_ty,\n+                                            assoc_type_def.bounds.as_slice(),\n+                                            &assoc_type_def.unbound,\n+                                            assoc_type_def.span);\n+\n+                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+            })\n+            .collect()\n+    }\n }\n \n fn ty_generics_for_fn_or_method<'tcx,AC>(\n@@ -1269,8 +1313,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n \n     let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n     let bounds = compute_bounds(this,\n-                                param.ident.name,\n-                                param_ty,\n+                                param_ty.to_ty(this.tcx()),\n                                 param.bounds[],\n                                 param.span);\n     let default = match param.default {\n@@ -1312,8 +1355,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n fn compute_bounds<'tcx,AC>(this: &AC,\n-                           name_of_bounded_thing: ast::Name,\n-                           param_ty: ty::ParamTy,\n+                           param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n@@ -1329,7 +1371,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                       span);\n \n     check_bounds_compatible(this.tcx(),\n-                            name_of_bounded_thing,\n+                            param_ty,\n                             &param_bounds,\n                             span);\n \n@@ -1339,7 +1381,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n }\n \n fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 name_of_bounded_thing: ast::Name,\n+                                 param_ty: Ty<'tcx>,\n                                  param_bounds: &ty::ParamBounds<'tcx>,\n                                  span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n@@ -1352,9 +1394,9 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n-                              \"incompatible bounds on type parameter `{}`, \\\n+                              \"incompatible bounds on `{}`, \\\n                                bound `{}` does not allow unsized type\",\n-                              name_of_bounded_thing.user_string(tcx),\n+                              param_ty.user_string(tcx),\n                               trait_ref.user_string(tcx));\n                 }\n                 true\n@@ -1364,7 +1406,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn conv_param_bounds<'tcx,AC>(this: &AC,\n                               span: Span,\n-                              param_ty: ty::ParamTy,\n+                              param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n                               where AC: AstConv<'tcx>\n@@ -1382,7 +1424,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n             astconv::instantiate_poly_trait_ref(this,\n                                                 &ExplicitRscope,\n                                                 bound,\n-                                                Some(param_ty.to_ty(this.tcx())),\n+                                                Some(param_ty),\n                                                 &mut projection_bounds)\n         })\n         .collect();"}, {"sha": "486d3d38c60af7ef845b81776476f2217d5c9780", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7c6e317b0d45f2129885d9148180be93ed0b025/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=b7c6e317b0d45f2129885d9148180be93ed0b025", "patch": "@@ -26,9 +26,10 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n }\n \n pub fn main() {\n-    f1(2i, 4i); //~ERROR the trait `Foo` is not implemented\n-    f1(2u, 4u); //~ERROR the trait `Foo` is not implemented\n-    f1(2u, 4i); //~ERROR the trait `Foo` is not implemented\n+    f1(2i, 4i); //~ ERROR expected uint, found int\n+    f1(2i, 4u);\n+    f1(2u, 4u); //~ ERROR the trait `Foo` is not implemented\n+    f1(2u, 4i); //~ ERROR the trait `Foo` is not implemented\n \n-    let _: int = f2(2i); //~ERROR mismatched types: expected `int`, found `uint`\n+    let _: int = f2(2i); //~ERROR expected `int`, found `uint`\n }"}]}