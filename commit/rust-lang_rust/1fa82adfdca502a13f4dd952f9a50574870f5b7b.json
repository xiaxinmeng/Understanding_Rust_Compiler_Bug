{"sha": "1fa82adfdca502a13f4dd952f9a50574870f5b7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYTgyYWRmZGNhNTAyYTEzZjRkZDk1MmY5YTUwNTc0ODcwZjViN2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-26T23:16:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-26T23:16:38Z"}, "message": "Merge #9413\n\n9413: internal: Deduplicate ast expression walking logic r=Veykril a=Veykril\n\nDeduplicates the duplication introduced in #9375 and #9396 while also fixing a few bugs in both the assist and related highlighting.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "ea086cd7e23ffee54dab682c99950e298f9ba3a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea086cd7e23ffee54dab682c99950e298f9ba3a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fa82adfdca502a13f4dd952f9a50574870f5b7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg17VWCRBK7hj4Ov3rIwAAYuMIACRh7U7fMUOo2oc9e4TmRTJn\nTJoq1p6DJOZj5n8sgu8YH9xzW6CUqqa3/cfJ4tkBJD9hXKTouYdIKyWXS/zTt5cN\nJZ3HYHcT5nMBgDIo4pm1EZsECK7KYNnkyDmuNIrVzTMDU5Hvx9lh75WPmPuYxl1h\n4689y7CiQWmCBPcGt5vBao2XhM8HgYDhN0W+xW5VNRmA5LLo3Ubhegr5YG2Y8P7T\n7nbJoaqvbHpeARPKoSLb1CmjHS09hndmrpqZcxvBCU9KOj9n76MNyXX17l9Myndo\n6HEWlBl3Fa6FZPgwPXT03JpA6PV0UDPFLAVmYhFYhqvrhIoLlzFe7Nti2dKpdE8=\n=Sted\n-----END PGP SIGNATURE-----\n", "payload": "tree ea086cd7e23ffee54dab682c99950e298f9ba3a9\nparent ddce8b603328e27327e9a8ee08b617986685abe8\nparent 3ce5c66ca1dbe99f107b4a84f1f8bf37db831740\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624749398 +0000\ncommitter GitHub <noreply@github.com> 1624749398 +0000\n\nMerge #9413\n\n9413: internal: Deduplicate ast expression walking logic r=Veykril a=Veykril\n\nDeduplicates the duplication introduced in #9375 and #9396 while also fixing a few bugs in both the assist and related highlighting.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa82adfdca502a13f4dd952f9a50574870f5b7b", "html_url": "https://github.com/rust-lang/rust/commit/1fa82adfdca502a13f4dd952f9a50574870f5b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fa82adfdca502a13f4dd952f9a50574870f5b7b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddce8b603328e27327e9a8ee08b617986685abe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddce8b603328e27327e9a8ee08b617986685abe8", "html_url": "https://github.com/rust-lang/rust/commit/ddce8b603328e27327e9a8ee08b617986685abe8"}, {"sha": "3ce5c66ca1dbe99f107b4a84f1f8bf37db831740", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce5c66ca1dbe99f107b4a84f1f8bf37db831740", "html_url": "https://github.com/rust-lang/rust/commit/3ce5c66ca1dbe99f107b4a84f1f8bf37db831740"}], "stats": {"total": 659, "additions": 218, "deletions": 441}, "files": [{"sha": "2d27fb45e341bb7dc6ad93112309638508a23246", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 6, "deletions": 156, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=1fa82adfdca502a13f4dd952f9a50574870f5b7b", "patch": "@@ -2,13 +2,13 @@ use hir::Semantics;\n use ide_db::{\n     base_db::FilePosition,\n     defs::Definition,\n-    helpers::pick_best_token,\n+    helpers::{for_each_break_expr, for_each_tail_expr, pick_best_token},\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n use syntax::{\n     ast::{self, LoopBodyOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n+    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n use crate::{display::TryToNav, references, NavigationTarget};\n@@ -95,7 +95,7 @@ fn highlight_exit_points(\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n-        walk(&body, &mut |expr| match expr {\n+        body.walk(&mut |expr| match expr {\n             ast::Expr::ReturnExpr(expr) => {\n                 if let Some(token) = expr.return_token() {\n                     highlights.push(HighlightedRange { access: None, range: token.text_range() });\n@@ -120,7 +120,7 @@ fn highlight_exit_points(\n         };\n \n         if let Some(tail) = tail {\n-            for_each_inner_tail(&tail, &mut |tail| {\n+            for_each_tail_expr(&tail, &mut |tail| {\n                 let range = match tail {\n                     ast::Expr::BreakExpr(b) => b\n                         .break_token()\n@@ -161,7 +161,7 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n             label.as_ref().map(|it| it.syntax().text_range()),\n         );\n         highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n-        for_each_break(label, body, &mut |break_| {\n+        for_each_break_expr(label, body, &mut |break_| {\n             let range = cover_range(\n                 break_.break_token().map(|it| it.text_range()),\n                 break_.lifetime().map(|it| it.syntax().text_range()),\n@@ -216,7 +216,7 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         highlights.push(HighlightedRange { access: None, range: async_token?.text_range() });\n         if let Some(body) = body {\n-            walk(&body, &mut |expr| {\n+            body.walk(&mut |expr| {\n                 if let ast::Expr::AwaitExpr(expr) = expr {\n                     if let Some(token) = expr.await_token() {\n                         highlights\n@@ -240,156 +240,6 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     None\n }\n \n-/// Preorder walk all the expression's child expressions\n-fn walk(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {\n-    let mut preorder = expr.syntax().preorder();\n-    while let Some(event) = preorder.next() {\n-        let node = match event {\n-            WalkEvent::Enter(node) => node,\n-            WalkEvent::Leave(_) => continue,\n-        };\n-        match ast::Stmt::cast(node.clone()) {\n-            // recursively walk the initializer, skipping potential const pat expressions\n-            // lets statements aren't usually nested too deeply so this is fine to recurse on\n-            Some(ast::Stmt::LetStmt(l)) => {\n-                if let Some(expr) = l.initializer() {\n-                    walk(&expr, cb);\n-                }\n-                preorder.skip_subtree();\n-            }\n-            // Don't skip subtree since we want to process the expression child next\n-            Some(ast::Stmt::ExprStmt(_)) => (),\n-            // skip inner items which might have their own expressions\n-            Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n-            None => {\n-                if let Some(expr) = ast::Expr::cast(node) {\n-                    let is_different_context = match &expr {\n-                        ast::Expr::EffectExpr(effect) => {\n-                            matches!(\n-                                effect.effect(),\n-                                ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n-                            )\n-                        }\n-                        ast::Expr::ClosureExpr(__) => true,\n-                        _ => false,\n-                    };\n-                    cb(expr);\n-                    if is_different_context {\n-                        preorder.skip_subtree();\n-                    }\n-                } else {\n-                    preorder.skip_subtree();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// FIXME: doesn't account for labeled breaks in labeled blocks\n-fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n-    match expr {\n-        ast::Expr::BlockExpr(b) => {\n-            if let Some(e) = b.tail_expr() {\n-                for_each_inner_tail(&e, cb);\n-            }\n-        }\n-        ast::Expr::EffectExpr(e) => match e.effect() {\n-            ast::Effect::Label(label) => {\n-                for_each_break(Some(label), e.block_expr(), &mut |b| cb(&ast::Expr::BreakExpr(b)));\n-                if let Some(b) = e.block_expr() {\n-                    for_each_inner_tail(&ast::Expr::BlockExpr(b), cb);\n-                }\n-            }\n-            ast::Effect::Unsafe(_) => {\n-                if let Some(e) = e.block_expr().and_then(|b| b.tail_expr()) {\n-                    for_each_inner_tail(&e, cb);\n-                }\n-            }\n-            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_) => cb(expr),\n-        },\n-        ast::Expr::IfExpr(if_) => {\n-            if_.blocks().for_each(|block| for_each_inner_tail(&ast::Expr::BlockExpr(block), cb))\n-        }\n-        ast::Expr::LoopExpr(l) => {\n-            for_each_break(l.label(), l.loop_body(), &mut |b| cb(&ast::Expr::BreakExpr(b)))\n-        }\n-        ast::Expr::MatchExpr(m) => {\n-            if let Some(arms) = m.match_arm_list() {\n-                arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_inner_tail(&e, cb));\n-            }\n-        }\n-        ast::Expr::ArrayExpr(_)\n-        | ast::Expr::AwaitExpr(_)\n-        | ast::Expr::BinExpr(_)\n-        | ast::Expr::BoxExpr(_)\n-        | ast::Expr::BreakExpr(_)\n-        | ast::Expr::CallExpr(_)\n-        | ast::Expr::CastExpr(_)\n-        | ast::Expr::ClosureExpr(_)\n-        | ast::Expr::ContinueExpr(_)\n-        | ast::Expr::FieldExpr(_)\n-        | ast::Expr::ForExpr(_)\n-        | ast::Expr::IndexExpr(_)\n-        | ast::Expr::Literal(_)\n-        | ast::Expr::MacroCall(_)\n-        | ast::Expr::MacroStmts(_)\n-        | ast::Expr::MethodCallExpr(_)\n-        | ast::Expr::ParenExpr(_)\n-        | ast::Expr::PathExpr(_)\n-        | ast::Expr::PrefixExpr(_)\n-        | ast::Expr::RangeExpr(_)\n-        | ast::Expr::RecordExpr(_)\n-        | ast::Expr::RefExpr(_)\n-        | ast::Expr::ReturnExpr(_)\n-        | ast::Expr::TryExpr(_)\n-        | ast::Expr::TupleExpr(_)\n-        | ast::Expr::WhileExpr(_)\n-        | ast::Expr::YieldExpr(_) => cb(expr),\n-    }\n-}\n-\n-fn for_each_break(\n-    label: Option<ast::Label>,\n-    body: Option<ast::BlockExpr>,\n-    cb: &mut dyn FnMut(ast::BreakExpr),\n-) {\n-    let label = label.and_then(|lbl| lbl.lifetime());\n-    let mut depth = 0;\n-    if let Some(b) = body {\n-        let preorder = &mut b.syntax().preorder();\n-        let ev_as_expr = |ev| match ev {\n-            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n-            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n-        };\n-        let eq_label = |lt: Option<ast::Lifetime>| {\n-            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n-        };\n-        while let Some(node) = preorder.find_map(ev_as_expr) {\n-            match node {\n-                WalkEvent::Enter(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth += 1\n-                    }\n-                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n-                    ast::Expr::BreakExpr(b)\n-                        if (depth == 0 && b.lifetime().is_none()) || eq_label(b.lifetime()) =>\n-                    {\n-                        cb(b);\n-                    }\n-                    _ => (),\n-                },\n-                WalkEvent::Leave(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth -= 1\n-                    }\n-                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth -= 1,\n-                    _ => (),\n-                },\n-            }\n-        }\n-    }\n-}\n-\n fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange> {\n     match (r0, r1) {\n         (Some(r0), Some(r1)) => Some(r0.cover(r1)),"}, {"sha": "65d0640a3838d404ef9feb36d45add8cac65aab1", "filename": "crates/ide_assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 51, "deletions": 282, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=1fa82adfdca502a13f4dd952f9a50574870f5b7b", "patch": "@@ -1,8 +1,9 @@\n use std::iter;\n \n+use ide_db::helpers::for_each_tail_expr;\n use syntax::{\n-    ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n-    match_ast, AstNode, SyntaxNode,\n+    ast::{self, make, Expr},\n+    match_ast, AstNode,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -21,7 +22,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let ret_type = ctx.find_node_at_offset::<ast::RetType>()?;\n     let parent = ret_type.syntax().parent()?;\n-    let block_expr = match_ast! {\n+    let body = match_ast! {\n         match parent {\n             ast::Fn(func) => func.body()?,\n             ast::ClosureExpr(closure) => match closure.body()? {\n@@ -32,6 +33,7 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n             _ => return None,\n         }\n     };\n+    let body = ast::Expr::BlockExpr(body);\n \n     let type_ref = &ret_type.ty()?;\n     let ret_type_str = type_ref.syntax().text().to_string();\n@@ -48,11 +50,18 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n         \"Wrap return type in Result\",\n         type_ref.syntax().text_range(),\n         |builder| {\n-            let mut tail_return_expr_collector = TailReturnCollector::new();\n-            tail_return_expr_collector.collect_jump_exprs(&block_expr, false);\n-            tail_return_expr_collector.collect_tail_exprs(&block_expr);\n+            let mut exprs_to_wrap = Vec::new();\n+            let tail_cb = &mut |e: &_| tail_cb_impl(&mut exprs_to_wrap, e);\n+            body.walk(&mut |expr| {\n+                if let Expr::ReturnExpr(ret_expr) = expr {\n+                    if let Some(ret_expr_arg) = &ret_expr.expr() {\n+                        for_each_tail_expr(ret_expr_arg, tail_cb);\n+                    }\n+                }\n+            });\n+            for_each_tail_expr(&body, tail_cb);\n \n-            for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n+            for ret_expr_arg in exprs_to_wrap {\n                 let ok_wrapped = make::expr_call(\n                     make::expr_path(make::ext::ident_path(\"Ok\")),\n                     make::arg_list(iter::once(ret_expr_arg.clone())),\n@@ -72,199 +81,14 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext)\n     )\n }\n \n-struct TailReturnCollector {\n-    exprs_to_wrap: Vec<ast::Expr>,\n-}\n-\n-impl TailReturnCollector {\n-    fn new() -> Self {\n-        Self { exprs_to_wrap: vec![] }\n-    }\n-    /// Collect all`return` expression\n-    fn collect_jump_exprs(&mut self, block_expr: &BlockExpr, collect_break: bool) {\n-        let statements = block_expr.statements();\n-        for stmt in statements {\n-            let expr = match &stmt {\n-                ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n-                ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n-                ast::Stmt::Item(_) => continue,\n-            };\n-            if let Some(expr) = &expr {\n-                self.handle_exprs(expr, collect_break);\n-            }\n-        }\n-\n-        // Browse tail expressions for each block\n-        if let Some(expr) = block_expr.tail_expr() {\n-            if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n-                for last_expr in last_exprs {\n-                    let last_expr = match last_expr {\n-                        NodeType::Node(expr) => expr,\n-                        NodeType::Leaf(expr) => expr.syntax().clone(),\n-                    };\n-\n-                    if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n-                        self.handle_exprs(&last_expr, collect_break);\n-                    } else if let Some(expr_stmt) = ast::Stmt::cast(last_expr) {\n-                        let expr_stmt = match &expr_stmt {\n-                            ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n-                            ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n-                            ast::Stmt::Item(_) => None,\n-                        };\n-                        if let Some(expr) = &expr_stmt {\n-                            self.handle_exprs(expr, collect_break);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn handle_exprs(&mut self, expr: &Expr, collect_break: bool) {\n-        match expr {\n-            Expr::BlockExpr(block_expr) => {\n-                self.collect_jump_exprs(block_expr, collect_break);\n-            }\n-            Expr::ReturnExpr(ret_expr) => {\n-                if let Some(ret_expr_arg) = &ret_expr.expr() {\n-                    self.exprs_to_wrap.push(ret_expr_arg.clone());\n-                }\n-            }\n-            Expr::BreakExpr(break_expr) if collect_break => {\n-                if let Some(break_expr_arg) = &break_expr.expr() {\n-                    self.exprs_to_wrap.push(break_expr_arg.clone());\n-                }\n-            }\n-            Expr::IfExpr(if_expr) => {\n-                for block in if_expr.blocks() {\n-                    self.collect_jump_exprs(&block, collect_break);\n-                }\n-            }\n-            Expr::LoopExpr(loop_expr) => {\n-                if let Some(block_expr) = loop_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::ForExpr(for_expr) => {\n-                if let Some(block_expr) = for_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::WhileExpr(while_expr) => {\n-                if let Some(block_expr) = while_expr.loop_body() {\n-                    self.collect_jump_exprs(&block_expr, collect_break);\n-                }\n-            }\n-            Expr::MatchExpr(match_expr) => {\n-                if let Some(arm_list) = match_expr.match_arm_list() {\n-                    arm_list.arms().filter_map(|match_arm| match_arm.expr()).for_each(|expr| {\n-                        self.handle_exprs(&expr, collect_break);\n-                    });\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn collect_tail_exprs(&mut self, block: &BlockExpr) {\n-        if let Some(expr) = block.tail_expr() {\n-            self.handle_exprs(&expr, true);\n-            self.fetch_tail_exprs(&expr);\n-        }\n-    }\n-\n-    fn fetch_tail_exprs(&mut self, expr: &Expr) {\n-        if let Some(exprs) = get_tail_expr_from_block(expr) {\n-            for node_type in &exprs {\n-                match node_type {\n-                    NodeType::Leaf(expr) => {\n-                        self.exprs_to_wrap.push(expr.clone());\n-                    }\n-                    NodeType::Node(expr) => {\n-                        if let Some(last_expr) = Expr::cast(expr.clone()) {\n-                            self.fetch_tail_exprs(&last_expr);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum NodeType {\n-    Leaf(ast::Expr),\n-    Node(SyntaxNode),\n-}\n-\n-/// Get a tail expression inside a block\n-fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n-    match expr {\n-        Expr::IfExpr(if_expr) => {\n-            let mut nodes = vec![];\n-            for block in if_expr.blocks() {\n-                if let Some(block_expr) = block.tail_expr() {\n-                    if let Some(tail_exprs) = get_tail_expr_from_block(&block_expr) {\n-                        nodes.extend(tail_exprs);\n-                    }\n-                } else if let Some(last_expr) = block.syntax().last_child() {\n-                    nodes.push(NodeType::Node(last_expr));\n-                } else {\n-                    nodes.push(NodeType::Node(block.syntax().clone()));\n-                }\n+fn tail_cb_impl(acc: &mut Vec<ast::Expr>, e: &ast::Expr) {\n+    match e {\n+        Expr::BreakExpr(break_expr) => {\n+            if let Some(break_expr_arg) = break_expr.expr() {\n+                for_each_tail_expr(&break_expr_arg, &mut |e| tail_cb_impl(acc, e))\n             }\n-            Some(nodes)\n-        }\n-        Expr::LoopExpr(loop_expr) => {\n-            loop_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::ForExpr(for_expr) => {\n-            for_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::WhileExpr(while_expr) => {\n-            while_expr.syntax().last_child().map(|lc| vec![NodeType::Node(lc)])\n-        }\n-        Expr::BlockExpr(block_expr) => {\n-            block_expr.tail_expr().map(|lc| vec![NodeType::Node(lc.syntax().clone())])\n-        }\n-        Expr::MatchExpr(match_expr) => {\n-            let arm_list = match_expr.match_arm_list()?;\n-            let arms: Vec<NodeType> = arm_list\n-                .arms()\n-                .filter_map(|match_arm| match_arm.expr())\n-                .map(|expr| match expr {\n-                    Expr::ReturnExpr(ret_expr) => NodeType::Node(ret_expr.syntax().clone()),\n-                    Expr::BreakExpr(break_expr) => NodeType::Node(break_expr.syntax().clone()),\n-                    _ => match expr.syntax().last_child() {\n-                        Some(last_expr) => NodeType::Node(last_expr),\n-                        None => NodeType::Node(expr.syntax().clone()),\n-                    },\n-                })\n-                .collect();\n-\n-            Some(arms)\n         }\n-        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e)]),\n-        Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n-\n-        Expr::CallExpr(_)\n-        | Expr::Literal(_)\n-        | Expr::TupleExpr(_)\n-        | Expr::ArrayExpr(_)\n-        | Expr::ParenExpr(_)\n-        | Expr::PathExpr(_)\n-        | Expr::RecordExpr(_)\n-        | Expr::IndexExpr(_)\n-        | Expr::MethodCallExpr(_)\n-        | Expr::AwaitExpr(_)\n-        | Expr::CastExpr(_)\n-        | Expr::RefExpr(_)\n-        | Expr::PrefixExpr(_)\n-        | Expr::RangeExpr(_)\n-        | Expr::BinExpr(_)\n-        | Expr::MacroCall(_)\n-        | Expr::BoxExpr(_) => Some(vec![NodeType::Leaf(expr.clone())]),\n-        _ => None,\n+        e => acc.push(e.clone()),\n     }\n }\n \n@@ -293,6 +117,35 @@ fn foo() -> Result<i32, ${0:_}> {\n         );\n     }\n \n+    #[test]\n+    fn wrap_return_type_break_split_tail() {\n+        check_assist(\n+            wrap_return_type_in_result,\n+            r#\"\n+fn foo() -> i3$02 {\n+    loop {\n+        break if true {\n+            1\n+        } else {\n+            0\n+        };\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<i32, ${0:_}> {\n+    loop {\n+        break if true {\n+            Ok(1)\n+        } else {\n+            Ok(0)\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn wrap_return_type_in_result_simple_closure() {\n         check_assist(\n@@ -940,90 +793,6 @@ fn foo() -> Result<i32, ${0:_}> {\n \"#,\n         );\n \n-        check_assist(\n-            wrap_return_type_in_result,\n-            r#\"\n-fn foo() -> i32$0 {\n-    let test = \"test\";\n-    if test == \"test\" {\n-        return 24i32;\n-    }\n-    let mut i = 0;\n-    loop {\n-        loop {\n-            if i == 1 {\n-                break 55;\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\"#,\n-            r#\"\n-fn foo() -> Result<i32, ${0:_}> {\n-    let test = \"test\";\n-    if test == \"test\" {\n-        return Ok(24i32);\n-    }\n-    let mut i = 0;\n-    loop {\n-        loop {\n-            if i == 1 {\n-                break Ok(55);\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\"#,\n-        );\n-\n-        check_assist(\n-            wrap_return_type_in_result,\n-            r#\"\n-fn foo() -> i3$02 {\n-    let test = \"test\";\n-    let other = 5;\n-    if test == \"test\" {\n-        let res = match other {\n-            5 => 43,\n-            _ => return 56,\n-        };\n-    }\n-    let mut i = 0;\n-    loop {\n-        loop {\n-            if i == 1 {\n-                break 55;\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\"#,\n-            r#\"\n-fn foo() -> Result<i32, ${0:_}> {\n-    let test = \"test\";\n-    let other = 5;\n-    if test == \"test\" {\n-        let res = match other {\n-            5 => 43,\n-            _ => return Ok(56),\n-        };\n-    }\n-    let mut i = 0;\n-    loop {\n-        loop {\n-            if i == 1 {\n-                break Ok(55);\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\"#,\n-        );\n-\n         check_assist(\n             wrap_return_type_in_result,\n             r#\""}, {"sha": "632fd3659011eedf4a4c5d39a8d61418557b7489", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=1fa82adfdca502a13f4dd952f9a50574870f5b7b", "patch": "@@ -11,8 +11,8 @@ use base_db::FileId;\n use either::Either;\n use hir::{Crate, Enum, ItemInNs, MacroDef, Module, ModuleDef, Name, ScopeDef, Semantics, Trait};\n use syntax::{\n-    ast::{self, make},\n-    SyntaxKind, SyntaxToken, TokenAtOffset,\n+    ast::{self, make, LoopBodyOwner},\n+    AstNode, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n };\n \n use crate::RootDatabase;\n@@ -204,3 +204,111 @@ impl SnippetCap {\n         }\n     }\n }\n+\n+/// Calls `cb` on each expression inside `expr` that is at \"tail position\".\n+pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n+    match expr {\n+        ast::Expr::BlockExpr(b) => {\n+            if let Some(e) = b.tail_expr() {\n+                for_each_tail_expr(&e, cb);\n+            }\n+        }\n+        ast::Expr::EffectExpr(e) => match e.effect() {\n+            ast::Effect::Label(label) => {\n+                for_each_break_expr(Some(label), e.block_expr(), &mut |b| {\n+                    cb(&ast::Expr::BreakExpr(b))\n+                });\n+                if let Some(b) = e.block_expr() {\n+                    for_each_tail_expr(&ast::Expr::BlockExpr(b), cb);\n+                }\n+            }\n+            ast::Effect::Unsafe(_) => {\n+                if let Some(e) = e.block_expr().and_then(|b| b.tail_expr()) {\n+                    for_each_tail_expr(&e, cb);\n+                }\n+            }\n+            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_) => cb(expr),\n+        },\n+        ast::Expr::IfExpr(if_) => {\n+            if_.blocks().for_each(|block| for_each_tail_expr(&ast::Expr::BlockExpr(block), cb))\n+        }\n+        ast::Expr::LoopExpr(l) => {\n+            for_each_break_expr(l.label(), l.loop_body(), &mut |b| cb(&ast::Expr::BreakExpr(b)))\n+        }\n+        ast::Expr::MatchExpr(m) => {\n+            if let Some(arms) = m.match_arm_list() {\n+                arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_tail_expr(&e, cb));\n+            }\n+        }\n+        ast::Expr::ArrayExpr(_)\n+        | ast::Expr::AwaitExpr(_)\n+        | ast::Expr::BinExpr(_)\n+        | ast::Expr::BoxExpr(_)\n+        | ast::Expr::BreakExpr(_)\n+        | ast::Expr::CallExpr(_)\n+        | ast::Expr::CastExpr(_)\n+        | ast::Expr::ClosureExpr(_)\n+        | ast::Expr::ContinueExpr(_)\n+        | ast::Expr::FieldExpr(_)\n+        | ast::Expr::ForExpr(_)\n+        | ast::Expr::IndexExpr(_)\n+        | ast::Expr::Literal(_)\n+        | ast::Expr::MacroCall(_)\n+        | ast::Expr::MacroStmts(_)\n+        | ast::Expr::MethodCallExpr(_)\n+        | ast::Expr::ParenExpr(_)\n+        | ast::Expr::PathExpr(_)\n+        | ast::Expr::PrefixExpr(_)\n+        | ast::Expr::RangeExpr(_)\n+        | ast::Expr::RecordExpr(_)\n+        | ast::Expr::RefExpr(_)\n+        | ast::Expr::ReturnExpr(_)\n+        | ast::Expr::TryExpr(_)\n+        | ast::Expr::TupleExpr(_)\n+        | ast::Expr::WhileExpr(_)\n+        | ast::Expr::YieldExpr(_) => cb(expr),\n+    }\n+}\n+\n+/// Calls `cb` on each break expr inside of `body` that is applicable for the given label.\n+pub fn for_each_break_expr(\n+    label: Option<ast::Label>,\n+    body: Option<ast::BlockExpr>,\n+    cb: &mut dyn FnMut(ast::BreakExpr),\n+) {\n+    let label = label.and_then(|lbl| lbl.lifetime());\n+    let mut depth = 0;\n+    if let Some(b) = body {\n+        let preorder = &mut b.syntax().preorder();\n+        let ev_as_expr = |ev| match ev {\n+            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n+            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n+        };\n+        let eq_label = |lt: Option<ast::Lifetime>| {\n+            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n+        };\n+        while let Some(node) = preorder.find_map(ev_as_expr) {\n+            match node {\n+                WalkEvent::Enter(expr) => match expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth += 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n+                    ast::Expr::BreakExpr(b)\n+                        if (depth == 0 && b.lifetime().is_none()) || eq_label(b.lifetime()) =>\n+                    {\n+                        cb(b);\n+                    }\n+                    _ => (),\n+                },\n+                WalkEvent::Leave(expr) => match expr {\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n+                        depth -= 1\n+                    }\n+                    ast::Expr::EffectExpr(e) if e.label().is_some() => depth -= 1,\n+                    _ => (),\n+                },\n+            }\n+        }\n+    }\n+}"}, {"sha": "826efdfe87b1de3498082f7df72bd29375e383a5", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa82adfdca502a13f4dd952f9a50574870f5b7b/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=1fa82adfdca502a13f4dd952f9a50574870f5b7b", "patch": "@@ -5,7 +5,7 @@ use std::{borrow::Cow, fmt, iter::successors};\n \n use itertools::Itertools;\n use parser::SyntaxKind;\n-use rowan::{GreenNodeData, GreenTokenData};\n+use rowan::{GreenNodeData, GreenTokenData, WalkEvent};\n \n use crate::{\n     ast::{self, support, AstChildren, AstNode, AstToken, AttrsOwner, NameOwner, SyntaxNode},\n@@ -51,6 +51,56 @@ impl ast::BlockExpr {\n     }\n }\n \n+impl ast::Expr {\n+    /// Preorder walk all the expression's child expressions.\n+    pub fn walk(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                // recursively walk the initializer, skipping potential const pat expressions\n+                // let statements aren't usually nested too deeply so this is fine to recurse on\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(expr) = l.initializer() {\n+                        expr.walk(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own expressions\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those expressions are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(__) => true,\n+                            _ => false,\n+                        };\n+                        cb(expr);\n+                        if is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum Macro {\n     MacroRules(ast::MacroRules),"}]}