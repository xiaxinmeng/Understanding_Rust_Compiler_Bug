{"sha": "6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYTRjOTkyYmM4ZWUwMDNiZTAxYmZjNTlkMmQ3YjU0ZDAxYmMxMzE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-17T17:24:50Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-19T02:18:26Z"}, "message": "Suggest appropriate path when calling associated item on bare types\n\nWhen looking at the documentation for `std::f32` or `std::str`, for\nexample, it is easy to get confused and assume `std::f32` and `f32`\nare the same thing. Because of this, it is not uncommon to attempt\nwriting `f32::consts::PI` instead of the correct\n`std::f32::consts::PI`. When encountering the former, which results\nin an access error due to it being an inexistent path, try to access\nthe same path under `std`. If this succeeds, this information is\nstored for later tweaking of the final E0599 to provide an\nappropriate suggestion.\n\nThis suggestion applies to both E0233 and E0599 and is only checked\nwhen the first ident of a path corresponds to a primitive type.", "tree": {"sha": "4313d42306b5b29b60ab686db1880e4b8f1ba69b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4313d42306b5b29b60ab686db1880e4b8f1ba69b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "html_url": "https://github.com/rust-lang/rust/commit/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e928e9441157f63a776ba1f8773818838e0912ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e928e9441157f63a776ba1f8773818838e0912ea", "html_url": "https://github.com/rust-lang/rust/commit/e928e9441157f63a776ba1f8773818838e0912ea"}], "stats": {"total": 174, "additions": 134, "deletions": 40}, "files": [{"sha": "d9da995037325f5d80328a23ff83d56dfea8b50f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -165,6 +165,10 @@ pub struct Session {\n \n     /// `Span`s of trait methods that weren't found to avoid emitting object safety errors\n     pub trait_methods_not_found: Lock<FxHashSet<Span>>,\n+\n+    /// Mapping from ident span to path span for paths that don't exist as written, but that\n+    /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n+    pub confused_type_with_std_module: Lock<FxHashMap<Span, Span>>,\n }\n \n pub struct PerfStats {\n@@ -1248,6 +1252,7 @@ fn build_session_(\n         has_panic_handler: Once::new(),\n         driver_lint_caps,\n         trait_methods_not_found: Lock::new(Default::default()),\n+        confused_type_with_std_module: Lock::new(Default::default()),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "8df83120738c154ee39a86e806b86750ed0f8cad", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -3273,6 +3273,25 @@ impl<'a> Resolver<'a> {\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n+\n+                let mut std_path = vec![Segment::from_ident(Ident::from_str(\"std\"))];\n+                std_path.extend(path);\n+                if self.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                    let cl = CrateLint::No;\n+                    let ns = Some(ns);\n+                    if let PathResult::Module(_) | PathResult::NonModule(_) =\n+                        self.resolve_path_without_parent_scope(&std_path, ns, false, span, cl)\n+                    {\n+                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n+                        let item_span = path.iter().last().map(|segment| segment.ident.span)\n+                            .unwrap_or(span);\n+                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n+                        let mut hm = self.session.confused_type_with_std_module.borrow_mut();\n+                        hm.insert(item_span, span);\n+                        // In some places (E0223) we only have access to the full path\n+                        hm.insert(span, span);\n+                    }\n+                }\n                 resolution\n             }\n             _ => report_errors(self, None)\n@@ -3387,16 +3406,17 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n-    fn resolve_qpath_anywhere(&mut self,\n-                              id: NodeId,\n-                              qself: Option<&QSelf>,\n-                              path: &[Segment],\n-                              primary_ns: Namespace,\n-                              span: Span,\n-                              defer_to_typeck: bool,\n-                              global_by_default: bool,\n-                              crate_lint: CrateLint)\n-                              -> Option<PathResolution> {\n+    fn resolve_qpath_anywhere(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        primary_ns: Namespace,\n+        span: Span,\n+        defer_to_typeck: bool,\n+        global_by_default: bool,\n+        crate_lint: CrateLint,\n+    ) -> Option<PathResolution> {\n         let mut fin_res = None;\n         // FIXME: can't resolve paths in macro namespace yet, macros are\n         // processed by the little special hack below.\n@@ -3426,15 +3446,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Handles paths that may refer to associated items.\n-    fn resolve_qpath(&mut self,\n-                     id: NodeId,\n-                     qself: Option<&QSelf>,\n-                     path: &[Segment],\n-                     ns: Namespace,\n-                     span: Span,\n-                     global_by_default: bool,\n-                     crate_lint: CrateLint)\n-                     -> Option<PathResolution> {\n+    fn resolve_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        ns: Namespace,\n+        span: Span,\n+        global_by_default: bool,\n+        crate_lint: CrateLint,\n+    ) -> Option<PathResolution> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n              ns={:?}, span={:?}, global_by_default={:?})\","}, {"sha": "be8e5dae1d9f9ff5a1db0099d6da4084f0ef801a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -1187,18 +1187,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         ty\n     }\n \n-    fn report_ambiguous_associated_type(&self,\n-                                        span: Span,\n-                                        type_str: &str,\n-                                        trait_str: &str,\n-                                        name: &str) {\n-        struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\")\n-            .span_suggestion(\n+    fn report_ambiguous_associated_type(\n+        &self,\n+        span: Span,\n+        type_str: &str,\n+        trait_str: &str,\n+        name: &str,\n+    ) {\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\");\n+        if let (Some(_), Ok(snippet)) = (\n+            self.tcx().sess.confused_type_with_std_module.borrow().get(&span),\n+            self.tcx().sess.source_map().span_to_snippet(span),\n+         ) {\n+            err.span_suggestion(\n                 span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n-                Applicability::HasPlaceholders\n-            ).emit();\n+                \"you are looking for the module in `std`, not the primitive type\",\n+                format!(\"std::{}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_suggestion(\n+                    span,\n+                    \"use fully-qualified syntax\",\n+                    format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n+                    Applicability::HasPlaceholders\n+            );\n+        }\n+        err.emit();\n     }\n \n     // Search for a bound on a type parameter which includes the associated item\n@@ -1391,10 +1406,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     err.emit();\n                 } else if !qself_ty.references_error() {\n                     // Don't print `TyErr` to the user.\n-                    self.report_ambiguous_associated_type(span,\n-                                                          &qself_ty.to_string(),\n-                                                          \"Trait\",\n-                                                          &assoc_ident.as_str());\n+                    self.report_ambiguous_associated_type(\n+                        span,\n+                        &qself_ty.to_string(),\n+                        \"Trait\",\n+                        &assoc_ident.as_str(),\n+                    );\n                 }\n                 return (tcx.types.err, Def::Err);\n             }\n@@ -1461,10 +1478,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             ty\n         } else {\n             let path_str = tcx.def_path_str(trait_def_id);\n-            self.report_ambiguous_associated_type(span,\n-                                                  \"Type\",\n-                                                  &path_str,\n-                                                  &item_segment.ident.as_str());\n+            self.report_ambiguous_associated_type(\n+                span,\n+                \"Type\",\n+                &path_str,\n+                &item_segment.ident.as_str(),\n+            );\n             return tcx.types.err;\n         };\n "}, {"sha": "7121b06e27a0f07af568e98642af2ede29c8ce5f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -292,15 +292,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     } else {\n                         span = item_name.span;\n-                        struct_span_err!(\n+                        let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n                             E0599,\n                             \"no {} named `{}` found for type `{}` in the current scope\",\n                             item_kind,\n                             item_name,\n                             ty_str\n-                        )\n+                        );\n+                        if let Some(span) = tcx.sess.confused_type_with_std_module.borrow()\n+                            .get(&span)\n+                        {\n+                            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n+                                err.span_suggestion(\n+                                    *span,\n+                                    \"you are looking for the module in `std`, \\\n+                                     not the primitive type\",\n+                                    format!(\"std::{}\", snippet),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        }\n+                        err\n                     }\n                 } else {\n                     tcx.sess.diagnostic().struct_dummy()"}, {"sha": "e0e8b5e18a42d4625d2b6e7f50dc296d27dfae48", "filename": "src/test/ui/issues/issue-22933-3.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22933-3.stderr?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -3,6 +3,10 @@ error[E0599]: no associated item named `MIN` found for type `u8` in the current\n    |\n LL | const FOO: [u32; u8::MIN as usize] = [];\n    |                      ^^^ associated item not found in `u8`\n+help: you are looking for the module in `std`, not the primitive type\n+   |\n+LL | const FOO: [u32; std::u8::MIN as usize] = [];\n+   |                  ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9ca68a635da96ad85247aaa0f36f10f260b6aab7", "filename": "src/test/ui/suggestions/suggest-std-when-using-type.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.rs?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let pi = f32::consts::PI; //~ ERROR ambiguous associated type\n+    let bytes = \"hello world\".as_bytes();\n+    let string = unsafe {\n+        str::from_utf8(bytes) //~ ERROR no function or associated item named `from_utf8` found\n+    };\n+}"}, {"sha": "eecb4e60f9d5990fceae61f4eb9e23b4cfdcdbfd", "filename": "src/test/ui/suggestions/suggest-std-when-using-type.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6aa4c992bc8ee003be01bfc59d2d7b54d01bc131/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-std-when-using-type.stderr?ref=6aa4c992bc8ee003be01bfc59d2d7b54d01bc131", "patch": "@@ -0,0 +1,24 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/suggest-std-when-using-type.rs:2:14\n+   |\n+LL |     let pi = f32::consts::PI;\n+   |              ^^^^^^^^^^^^^^^\n+help: you are looking for the module in `std`, not the primitive type\n+   |\n+LL |     let pi = std::f32::consts::PI;\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no function or associated item named `from_utf8` found for type `str` in the current scope\n+  --> $DIR/suggest-std-when-using-type.rs:5:14\n+   |\n+LL |         str::from_utf8(bytes)\n+   |              ^^^^^^^^^ function or associated item not found in `str`\n+help: you are looking for the module in `std`, not the primitive type\n+   |\n+LL |         std::str::from_utf8(bytes)\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0223, E0599.\n+For more information about an error, try `rustc --explain E0223`."}]}