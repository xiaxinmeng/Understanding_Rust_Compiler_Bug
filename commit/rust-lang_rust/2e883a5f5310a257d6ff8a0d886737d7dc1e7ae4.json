{"sha": "2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlODgzYTVmNTMxMGEyNTdkNmZmOGEwZDg4NjczN2Q3ZGMxZTdhZTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:41:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:41:20Z"}, "message": "rollup merge of #20560: aturon/stab-2-iter-ops-slice\n\nConflicts:\n\tsrc/libcollections/slice.rs\n\tsrc/libcore/iter.rs\n\tsrc/libstd/sync/mpsc/mod.rs\n\tsrc/libstd/sync/rwlock.rs", "tree": {"sha": "d4d000e33b01feac0d57cd018e8ceddc6a403154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d000e33b01feac0d57cd018e8ceddc6a403154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "html_url": "https://github.com/rust-lang/rust/commit/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb5e16b4b869f0c585c21db110e51165865e8833", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5e16b4b869f0c585c21db110e51165865e8833", "html_url": "https://github.com/rust-lang/rust/commit/bb5e16b4b869f0c585c21db110e51165865e8833"}, {"sha": "c6f4a03d12d97162e2775c14ab006d355b04126d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f4a03d12d97162e2775c14ab006d355b04126d", "html_url": "https://github.com/rust-lang/rust/commit/c6f4a03d12d97162e2775c14ab006d355b04126d"}], "stats": {"total": 936, "additions": 574, "deletions": 362}, "files": [{"sha": "1d679f18feb3e6ebedf470e774b87e8838e50958", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -246,7 +246,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[experimental = \"Deref is experimental.\"]\n+#[stable]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -290,7 +290,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"waiting on stability of Drop\"]\n+#[stable]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -418,7 +418,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[stable]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///"}, {"sha": "33d1cc7f4c74596cbc23ba54485eec44c3dbffc8", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -155,12 +155,14 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n+#[stable]\n impl<Sized? T> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n+#[stable]\n impl<Sized? T> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }"}, {"sha": "1621e1934faecb816aec616d284ef434e5decaad", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -354,7 +354,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[experimental = \"Deref is experimental.\"]\n+#[stable]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -365,7 +365,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Drop is experimental.\"]\n+#[stable]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -656,7 +656,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[stable]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///"}, {"sha": "d95c666b5860cfa4cdb74a99f26c80aa920304fb", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -148,6 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n+#![stable]\n \n use core::prelude::*;\n \n@@ -561,11 +562,13 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n+#[stable]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+#[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n@@ -593,6 +596,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n+#[stable]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n@@ -618,6 +622,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n+#[unstable = \"recent addition\"]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "b3c1486eaf363e2183f7f43acc02a8b9fe652797", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -19,6 +19,8 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use alloc::boxed::Box;"}, {"sha": "c9b090bfb232373551710a94052cb03c1a1ba66e", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -65,19 +65,23 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n+#[stable]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n+#[stable]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n \n+#[stable]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n+#[stable]\n pub mod btree_set {\n     pub use btree::set::*;\n }\n@@ -109,8 +113,7 @@ mod prelude {\n     pub use core::iter::range;\n     pub use core::iter::{FromIterator, Extend, IteratorExt};\n     pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n-    pub use core::iter::{IteratorCloneExt, CloneIteratorExt};\n-    pub use core::iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n+    pub use core::iter::{ExactSizeIterator};\n     pub use core::kinds::{Copy, Send, Sized, Sync};\n     pub use core::mem::drop;\n     pub use core::ops::{Drop, Fn, FnMut, FnOnce};"}, {"sha": "0ffede776eadec93609b4ce6df26275dbe35c46b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -12,6 +12,8 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use core::cmp::Ordering;"}, {"sha": "1afdd8c023b074e67b7240a740b237985315c159", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -86,6 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n+#![stable]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -121,8 +122,10 @@ pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt<T> for Sized? {\n+pub trait SliceExt for Sized? {\n+    #[stable]\n+    type Item;\n+\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -561,8 +564,10 @@ pub trait SliceExt<T> for Sized? {\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl<T> SliceExt<T> for [T] {\n+#[stable]\n+impl<T> SliceExt for [T] {\n+    type Item = T;\n+\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -1113,7 +1118,10 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-impl Iterator<(uint, uint)> for ElementSwaps {\n+#[stable]\n+impl Iterator for ElementSwaps {\n+    type Item = (uint, uint);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         fn new_pos(i: uint, s: Direction) -> uint {"}, {"sha": "9f3ab6dd5c0cb4fa249d84228154ea2447ce218d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -165,13 +165,15 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n     buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n+#[stable]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -253,6 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -261,6 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n+#[stable]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -348,10 +352,12 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[unstable]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n+#[stable]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n "}, {"sha": "6d7ebeff094882a3c5bbec65f8d8c2406d4be423", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -687,7 +687,7 @@ impl fmt::Show for FromUtf16Error {\n     }\n }\n \n-#[experimental = \"waiting on FromIterator stabilization\"]\n+#[stable]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -696,7 +696,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[experimental = \"waiting on FromIterator stabilization\"]\n+#[stable]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -808,7 +808,7 @@ impl<H: hash::Writer> hash::Hash<H> for String {\n     }\n }\n \n-#[experimental = \"waiting on Add stabilization\"]\n+#[unstable = \"recent addition, needs more experience\"]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -840,7 +840,7 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n-#[experimental = \"waiting on Deref stabilization\"]\n+#[stable]\n impl ops::Deref for String {\n     type Target = str;\n "}, {"sha": "86f5f61b2105ef76b504d7f43ddce844e1f0c4ca", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -1251,19 +1251,19 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Deref stability\"]\n+#[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[experimental = \"waiting on DerefMut stability\"]\n+#[stable]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[experimental = \"waiting on FromIterator stability\"]\n+#[stable]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1393,6 +1393,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n+#[unstable = \"recent addition, needs more experience\"]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n \n@@ -1404,6 +1405,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1449,6 +1451,7 @@ impl<'a> fmt::Writer for Vec<u8> {\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n+#[unstable]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1494,6 +1497,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1530,6 +1534,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1553,9 +1558,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1577,6 +1584,7 @@ pub struct Drain<'a, T> {\n     marker: ContravariantLifetime<'a>,\n }\n \n+#[stable]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1613,6 +1621,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1636,9 +1645,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1671,7 +1682,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[experimental]\n+#[stable]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;"}, {"sha": "63b3be00f55f5fe79608a0c294e8c702e384f19d", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -191,6 +191,7 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n+#[stable]\n impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n "}, {"sha": "fd18d6ac3f3b409e389b599e5292343feccb720f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -419,7 +419,7 @@ pub struct Ref<'b, T:'b> {\n     _borrow: BorrowRef<'b>,\n }\n \n-#[unstable = \"waiting for `Deref` to become stable\"]\n+#[stable]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -477,7 +477,7 @@ pub struct RefMut<'b, T:'b> {\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[unstable = \"waiting for `Deref` to become stable\"]\n+#[stable]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -487,7 +487,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[unstable = \"waiting for `DerefMut` to become stable\"]\n+#[stable]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {"}, {"sha": "caac894c0daa327c5ccf98edb285de9014b7fa08", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -314,6 +314,7 @@ pub struct EscapeUnicode {\n }\n \n #[derive(Clone)]\n+#[unstable]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -375,6 +376,7 @@ pub struct EscapeDefault {\n }\n \n #[derive(Clone)]\n+#[unstable]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),"}, {"sha": "b262054992c9fdf0744a03d5cde69de580f04e76", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 341, "deletions": 302, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -54,6 +54,8 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n+#![stable]\n+\n use self::MinMaxResult::*;\n \n use clone::Clone;\n@@ -79,38 +81,94 @@ use uint;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[unstable = \"just split up for object safety\"]\n+#[stable]\n pub trait Iterator {\n+    #[stable]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n+    #[stable]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `uint`.\n     #[inline]\n+    #[stable]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Conversion from an `Iterator`\n-#[unstable = \"may be replaced by a more general conversion trait\"]\n+#[stable]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n-#[unstable = \"just renamed as part of collections reform\"]\n+#[stable]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n-#[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n+#[stable]\n pub trait IteratorExt: Iterator + Sized {\n+    /// Counts the number of elements in this iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.count() == 5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn count(self) -> uint {\n+        self.fold(0, |cnt, _x| cnt + 1)\n+    }\n+\n+    /// Loops through the entire iterator, returning the last element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().last().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n+        let mut last = None;\n+        for x in self { last = Some(x); }\n+        last\n+    }\n+\n+    /// Loops through `n` iterations, returning the `n`th element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.nth(2).unwrap() == &3);\n+    /// assert!(it.nth(2) == None);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n+        for x in *self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -169,7 +227,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> B,\n     {\n@@ -189,7 +247,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -209,7 +267,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n     {\n@@ -258,9 +316,9 @@ pub trait IteratorExt: Iterator + Sized {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator that invokes the predicate on elements until it\n-    /// returns false. Once the predicate returns false, all further elements are\n-    /// yielded.\n+    /// Creates an iterator that invokes the predicate on elements\n+    /// until it returns false. Once the predicate returns false, that\n+    /// element and all further elements are yielded.\n     ///\n     /// # Example\n     ///\n@@ -273,7 +331,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -294,7 +352,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n+    #[stable]\n     fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -359,7 +417,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -389,7 +447,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(<Self as Iterator>::Item) -> U,\n@@ -449,7 +507,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n         F: FnMut(&<Self as Iterator>::Item),\n     {\n@@ -487,7 +545,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n+    #[stable]\n     fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -570,7 +628,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, <Self as Iterator>::Item) -> B,\n     {\n@@ -606,7 +664,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -624,7 +682,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -634,7 +692,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -646,7 +704,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(<Self as Iterator>::Item) -> bool,\n     {\n@@ -660,6 +718,145 @@ pub trait IteratorExt: Iterator + Sized {\n         None\n     }\n \n+    /// Return the index of the last element satisfying the specified predicate\n+    ///\n+    /// If no element matches, None is returned.\n+    #[inline]\n+    #[stable]\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+        Self: ExactSizeIterator + DoubleEndedIterator\n+    {\n+        let len = self.len();\n+        for i in range(0, len).rev() {\n+            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n+                return Some(i);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Consumes the entire iterator to return the maximum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().max().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn max(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |max, x| {\n+            match max {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::max(x, y))\n+            }\n+        })\n+    }\n+\n+    /// Consumes the entire iterator to return the minimum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().min().unwrap() == &1);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn min(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |min, x| {\n+            match min {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::min(x, y))\n+            }\n+        })\n+    }\n+\n+    /// `min_max` finds the minimum and maximum elements in the iterator.\n+    ///\n+    /// The return type `MinMaxResult` is an enum of three variants:\n+    ///\n+    /// - `NoElements` if the iterator is empty.\n+    /// - `OneElement(x)` if the iterator has exactly one element.\n+    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n+    ///    values are equal if and only if there is more than one\n+    ///    element in the iterator and all elements are equal.\n+    ///\n+    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n+    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n+    ///\n+    /// let v: [int; 0] = [];\n+    /// assert_eq!(v.iter().min_max(), NoElements);\n+    ///\n+    /// let v = [1i];\n+    /// assert!(v.iter().min_max() == OneElement(&1));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5, 6];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n+    ///\n+    /// let v = [1i, 1, 1, 1];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n+    /// ```\n+    #[unstable = \"return type may change\"]\n+    fn min_max(mut self) -> MinMaxResult< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        let (mut min, mut max) = match self.next() {\n+            None => return NoElements,\n+            Some(x) => {\n+                match self.next() {\n+                    None => return OneElement(x),\n+                    Some(y) => if x < y {(x, y)} else {(y,x)}\n+                }\n+            }\n+        };\n+\n+        loop {\n+            // `first` and `second` are the two next elements we want to look at.\n+            // We first compare `first` and `second` (#1). The smaller one is then compared to\n+            // current minimum (#2). The larger one is compared to current maximum (#3). This\n+            // way we do 3 comparisons for 2 elements.\n+            let first = match self.next() {\n+                None => break,\n+                Some(x) => x\n+            };\n+            let second = match self.next() {\n+                None => {\n+                    if first < min {\n+                        min = first;\n+                    } else if first > max {\n+                        max = first;\n+                    }\n+                    break;\n+                }\n+                Some(x) => x\n+            };\n+            if first < second {\n+                if first < min {min = first;}\n+                if max < second {max = second;}\n+            } else {\n+                if second < min {min = second;}\n+                if max < first {max = first;}\n+            }\n+        }\n+\n+        MinMax(min, max)\n+    }\n+\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n@@ -672,7 +869,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -701,7 +898,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -740,6 +937,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n+    #[unstable = \"recent addition\"]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -769,36 +967,41 @@ pub trait IteratorExt: Iterator + Sized {\n \n         (ts, us)\n     }\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<I> IteratorExt for I where I: Iterator {}\n-\n-/// A range iterator able to yield elements from both ends\n-///\n-/// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n-/// elements from the *same* range, and do not work independently of each other.\n-#[unstable = \"recently split into two traits\"]\n-pub trait DoubleEndedIterator: Iterator {\n-    /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n-}\n+    /// Creates an iterator that clones the elements it yields. Useful for converting an\n+    /// Iterator<&T> to an Iterator<T>.\n+    #[unstable = \"recent addition\"]\n+    fn cloned<T, D>(self) -> Cloned<Self> where\n+        Self: Iterator<Item=D>,\n+        D: Deref<Target=T>,\n+        T: Clone,\n+    {\n+        Cloned { it: self }\n+    }\n \n-/// A double-ended iterator yielding mutable references\n-#[experimental = \"not widely used\"]\n-pub trait MutableDoubleEndedIterator {\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self);\n-}\n+    /// Repeats an iterator endlessly\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::count;\n+    ///\n+    /// let a = count(1i,1i).take(1);\n+    /// let mut cy = a.cycle();\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// ```\n+    #[stable]\n+    #[inline]\n+    fn cycle(self) -> Cycle<Self> where Self: Clone {\n+        Cycle{orig: self.clone(), iter: self}\n+    }\n \n-#[experimental = \"trait is experimental\"]\n-impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n-    I: DoubleEndedIterator + Iterator<Item=&'a mut T>,\n-{\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self) {\n+    /// Use an iterator to reverse a container in place.\n+    #[experimental = \"uncertain about placement or widespread use\"]\n+    fn reverse_in_place<'a, T: 'a>(&mut self) where\n+        Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n+    {\n         loop {\n             match (self.next(), self.next_back()) {\n                 (Some(x), Some(y)) => mem::swap(x, y),\n@@ -808,6 +1011,18 @@ impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n     }\n }\n \n+#[stable]\n+impl<I> IteratorExt for I where I: Iterator {}\n+\n+/// A range iterator able to yield elements from both ends\n+///\n+/// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n+/// elements from the *same* range, and do not work independently of each other.\n+#[stable]\n+pub trait DoubleEndedIterator: Iterator {\n+    /// Yield an element from the end of the range, returning `None` if the range is empty.\n+    fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n+}\n \n /// An object implementing random access indexing by `uint`\n ///\n@@ -832,24 +1047,8 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-#[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n-pub trait ExactSizeIterator: DoubleEndedIterator {\n-    /// Return the index of the last element satisfying the specified predicate\n-    ///\n-    /// If no element matches, None is returned.\n-    #[inline]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n-        P: FnMut(<Self as Iterator>::Item) -> bool,\n-    {\n-        let len = self.len();\n-        for i in range(0, len).rev() {\n-            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n-                return Some(i);\n-            }\n-        }\n-        None\n-    }\n-\n+#[stable]\n+pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n     fn len(&self) -> uint {\n@@ -865,21 +1064,21 @@ pub trait ExactSizeIterator: DoubleEndedIterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[unstable = \"trait is unstable\"]\n-impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n+impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n+#[stable]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n@@ -890,7 +1089,7 @@ pub struct Rev<T> {\n     iter: T\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -900,7 +1099,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n@@ -924,7 +1123,7 @@ pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -934,7 +1133,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n@@ -1025,134 +1224,9 @@ impl_multiplicative! { uint, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n-/// A trait for iterators over elements which can be compared to one another.\n-#[unstable = \"recently renamed for new extension trait conventions\"]\n-pub trait IteratorOrdExt<A> {\n-    /// Consumes the entire iterator to return the maximum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().max().unwrap() == &5);\n-    /// ```\n-    fn max(self) -> Option<A>;\n-\n-    /// Consumes the entire iterator to return the minimum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().min().unwrap() == &1);\n-    /// ```\n-    fn min(self) -> Option<A>;\n-\n-    /// `min_max` finds the minimum and maximum elements in the iterator.\n-    ///\n-    /// The return type `MinMaxResult` is an enum of three variants:\n-    ///\n-    /// - `NoElements` if the iterator is empty.\n-    /// - `OneElement(x)` if the iterator has exactly one element.\n-    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n-    ///    values are equal if and only if there is more than one\n-    ///    element in the iterator and all elements are equal.\n-    ///\n-    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n-    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n-    ///\n-    /// let v: [int; 0] = [];\n-    /// assert_eq!(v.iter().min_max(), NoElements);\n-    ///\n-    /// let v = [1];\n-    /// assert!(v.iter().min_max() == OneElement(&1));\n-    ///\n-    /// let v = [1, 2, 3, 4, 5];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n-    ///\n-    /// let v = [1, 2, 3, 4, 5, 6];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n-    ///\n-    /// let v = [1, 1, 1, 1];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n-    /// ```\n-    fn min_max(self) -> MinMaxResult<A>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, I> IteratorOrdExt<T> for I where I: Iterator<Item=T>, T: Ord {\n-    #[inline]\n-    fn max(self) -> Option<T> {\n-        self.fold(None, |max, x| {\n-            match max {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::max(x, y))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn min(self) -> Option<T> {\n-        self.fold(None, |min, x| {\n-            match min {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::min(x, y))\n-            }\n-        })\n-    }\n-\n-    fn min_max(mut self) -> MinMaxResult<T> {\n-        let (mut min, mut max) = match self.next() {\n-            None => return NoElements,\n-            Some(x) => {\n-                match self.next() {\n-                    None => return OneElement(x),\n-                    Some(y) => if x < y {(x, y)} else {(y,x)}\n-                }\n-            }\n-        };\n-\n-        loop {\n-            // `first` and `second` are the two next elements we want to look at.\n-            // We first compare `first` and `second` (#1). The smaller one is then compared to\n-            // current minimum (#2). The larger one is compared to current maximum (#3). This\n-            // way we do 3 comparisons for 2 elements.\n-            let first = match self.next() {\n-                None => break,\n-                Some(x) => x\n-            };\n-            let second = match self.next() {\n-                None => {\n-                    if first < min {\n-                        min = first;\n-                    } else if first > max {\n-                        max = first;\n-                    }\n-                    break;\n-                }\n-                Some(x) => x\n-            };\n-            if first < second {\n-                if first < min {min = first;}\n-                if max < second {max = second;}\n-            } else {\n-                if second < min {min = second;}\n-                if max < first {max = first;}\n-            }\n-        }\n-\n-        MinMax(min, max)\n-    }\n-}\n-\n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"waiting on namespaced enum conventions\"]\n+#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1164,7 +1238,6 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n-#[stable]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n     /// `None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n@@ -1185,6 +1258,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n+    #[unstable = \"type is unstable\"]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1194,30 +1268,15 @@ impl<T: Clone> MinMaxResult<T> {\n     }\n }\n \n-/// A trait for iterators that contain cloneable elements\n-#[unstable = \"recently renamed for extension trait conventions\"]\n-pub trait IteratorCloneExt<A> {\n-    /// Creates an iterator that clones the elements it yields. Useful for converting an\n-    /// Iterator<&T> to an Iterator<T>.\n-    fn cloned(self) -> Cloned<Self>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, D, I> IteratorCloneExt<T> for I where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: Iterator<Item=D>,\n-{\n-    fn cloned(self) -> Cloned<I> {\n-        Cloned { it: self }\n-    }\n-}\n-\n /// An iterator that clones the elements of an underlying iterator\n+#[unstable = \"recent addition\"]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n+#[stable]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1234,6 +1293,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n+#[stable]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1244,39 +1304,13 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n     I: ExactSizeIterator + Iterator<Item=D>,\n {}\n \n-#[unstable = \"recently renamed for extension trait conventions\"]\n-/// An extension trait for cloneable iterators.\n-pub trait CloneIteratorExt {\n-    /// Repeats an iterator endlessly\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::{CloneIteratorExt, count};\n-    ///\n-    /// let a = count(1, 1).take(1);\n-    /// let mut cy = a.cycle();\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// ```\n-    #[stable]\n-    fn cycle(self) -> Cycle<Self>;\n-}\n-\n-impl<I> CloneIteratorExt for I where I: Iterator + Clone {\n-    #[inline]\n-    fn cycle(self) -> Cycle<I> {\n-        Cycle{orig: self.clone(), iter: self}\n-    }\n-}\n-\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1286,6 +1320,7 @@ pub struct Cycle<I> {\n     iter: I,\n }\n \n+#[stable]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1345,7 +1380,7 @@ pub struct Chain<A, B> {\n     flag: bool,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1379,7 +1414,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator + Iterator<Item=T>,\n     B: DoubleEndedIterator + Iterator<Item=T>,\n@@ -1424,7 +1459,7 @@ pub struct Zip<A, B> {\n     b: B\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1460,10 +1495,10 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: ExactSizeIterator + Iterator<Item=T>,\n-    B: ExactSizeIterator + Iterator<Item=U>,\n+    A: ExactSizeIterator + Iterator<Item=T> + DoubleEndedIterator,\n+    B: ExactSizeIterator + Iterator<Item=U> + DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(T, U)> {\n@@ -1539,7 +1574,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1555,7 +1590,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1606,7 +1641,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1629,7 +1664,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1667,7 +1702,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1692,7 +1727,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1718,7 +1753,7 @@ pub struct Enumerate<I> {\n     count: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (uint, <I as Iterator>::Item);\n \n@@ -1740,8 +1775,10 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl<I> DoubleEndedIterator for Enumerate<I> where I: ExactSizeIterator {\n+#[stable]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n@@ -1779,6 +1816,7 @@ pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     peeked: Option<T>,\n }\n \n+#[stable]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1850,7 +1888,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1896,7 +1934,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1935,7 +1973,7 @@ pub struct Skip<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2005,7 +2043,7 @@ pub struct Take<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2054,7 +2092,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2079,7 +2117,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2102,7 +2140,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2131,7 +2169,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2166,7 +2204,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     U: DoubleEndedIterator + Iterator<Item=B>,\n@@ -2199,7 +2237,7 @@ pub struct Fuse<I> {\n     done: bool\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2228,7 +2266,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n@@ -2260,11 +2298,11 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n }\n \n-#[experimental = \"seems marginal\"]\n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n+    #[experimental = \"seems marginal\"]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2273,7 +2311,7 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n@@ -2305,7 +2343,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2321,7 +2359,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n@@ -2416,7 +2454,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[experimental]\n+#[stable]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2435,7 +2473,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2445,12 +2483,12 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2469,7 +2507,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"will be replaced by range notation\"]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2490,6 +2528,7 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n+#[unstable = \"will be replaced by range notation\"]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2499,7 +2538,7 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2549,7 +2588,7 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2564,23 +2603,23 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2615,7 +2654,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2634,7 +2673,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2644,13 +2683,13 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2671,7 +2710,7 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2682,7 +2721,7 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2694,7 +2733,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2719,7 +2758,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n /// directions. The `steps_between` function provides a way to\n /// compare two Step objects (it could be provided using `step()` and `Ord`,\n /// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"Trait is unstable.\"]\n+#[unstable = \"design of range notation/iteration is in flux\"]\n pub trait Step: Ord {\n     /// Change self to the next object.\n     fn step(&mut self);\n@@ -2779,7 +2818,7 @@ pub struct Repeat<A> {\n     element: A\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2789,7 +2828,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n@@ -2855,7 +2894,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[experimental = \"likely to be removed after cmp reform\"]\n+#[unstable = \"needs review and revision\"]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "3d4be651f8338a38bcc8e08b00223f97e6573b45", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -59,6 +59,8 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n+#![stable]\n+\n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use kinds::Sized;\n@@ -86,8 +88,10 @@ use option::Option::{self, Some, None};\n /// }\n /// ```\n #[lang=\"drop\"]\n+#[stable]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n+    #[stable]\n     fn drop(&mut self);\n }\n \n@@ -120,15 +124,19 @@ pub trait Drop {\n /// }\n /// ```\n #[lang=\"add\"]\n+#[stable]\n pub trait Add<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `+` operator\n+    #[stable]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -169,15 +177,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n+#[stable]\n pub trait Sub<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `-` operator\n+    #[stable]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -218,15 +230,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n+#[stable]\n pub trait Mul<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `*` operator\n+    #[stable]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -267,15 +283,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n+#[stable]\n pub trait Div<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `/` operator\n+    #[stable]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -316,15 +336,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n+#[stable]\n pub trait Rem<RHS=Self> {\n+    #[stable]\n     type Output = Self;\n \n     /// The method for the `%` operator\n+    #[stable]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -336,6 +360,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -382,26 +407,33 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n+#[stable]\n pub trait Neg {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `-` operator\n+    #[stable]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Neg for $t {\n+            #[stable]\n             type Output = $t;\n \n             #[inline]\n+            #[stable]\n             fn neg(self) -> $t { -self }\n         }\n     )*)\n }\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n+        #[stable]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -450,15 +482,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n+#[stable]\n pub trait Not {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `!` operator\n+    #[stable]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -499,15 +535,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n+#[stable]\n pub trait BitAnd<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `&` operator\n+    #[stable]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -548,15 +588,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n+#[stable]\n pub trait BitOr<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `|` operator\n+    #[stable]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -597,15 +641,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n+#[stable]\n pub trait BitXor<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `^` operator\n+    #[stable]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -646,15 +694,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n+#[stable]\n pub trait Shl<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `<<` operator\n+    #[stable]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Shl<uint> for $t {\n             type Output = $t;\n \n@@ -697,10 +749,13 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shr\"]\n+#[stable]\n pub trait Shr<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `>>` operator\n+    #[stable]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -893,11 +948,13 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n /// An unbounded range.\n #[derive(Copy)]\n #[lang=\"full_range\"]\n+#[unstable = \"API still in development\"]\n pub struct FullRange;\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy)]\n #[lang=\"range\"]\n+#[unstable = \"API still in development\"]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n@@ -907,6 +964,7 @@ pub struct Range<Idx> {\n \n // FIXME(#19391) needs a snapshot\n //impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;\n \n@@ -931,6 +989,7 @@ impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     }\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n@@ -943,16 +1002,19 @@ impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     }\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n /// A range which is only bounded below.\n #[derive(Copy)]\n #[lang=\"range_from\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n+#[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     type Item = Idx;\n \n@@ -968,6 +1030,7 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy)]\n #[lang=\"range_to\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n@@ -1005,19 +1068,24 @@ pub struct RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n+#[stable]\n pub trait Deref for Sized? {\n+    #[stable]\n     type Sized? Target;\n \n     /// The method called to dereference a value\n+    #[stable]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n+#[stable]\n impl<'a, Sized? T> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n+#[stable]\n impl<'a, Sized? T> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1062,31 +1130,37 @@ impl<'a, Sized? T> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n+#[stable]\n pub trait DerefMut for Sized? : Deref {\n     /// The method called to mutably dereference a value\n+    #[stable]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n+#[stable]\n impl<'a, Sized? T> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait Fn<Args,Result> for Sized? {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait FnMut<Args,Result> for Sized? {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;"}, {"sha": "3c96011867cef378a9a3c8caff670e45f2509885", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -807,6 +807,7 @@ impl<A> ExactSizeIterator for Item<A> {}\n #[stable]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n+#[stable]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -816,11 +817,13 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n #[stable]\n@@ -834,6 +837,7 @@ impl<'a, A> Clone for Iter<'a, A> {\n #[stable]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n+#[stable]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -843,17 +847,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n #[stable]\n pub struct IntoIter<A> { inner: Item<A> }\n \n+#[stable]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -863,11 +870,13 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+#[stable]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n+#[stable]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "e88cb73c8a9b7f6f8d7b6f1a0a6c1207febc3f0d", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -43,8 +43,7 @@ pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use iter::{Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator};\n-pub use iter::{IteratorCloneExt, CloneIteratorExt};\n-pub use iter::{IteratorOrdExt, ExactSizeIterator};\n+pub use iter::{ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result::{self, Ok, Err};"}, {"sha": "7293ed6455b084aa74cd5932a0b494b75cc99ec8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -807,6 +807,7 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n #[stable]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n+#[stable]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -819,11 +820,13 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n@@ -834,6 +837,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[stable]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n+#[stable]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -846,17 +850,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n+#[stable]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n+#[stable]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n #[stable]\n pub struct IntoIter<T> { inner: Option<T> }\n \n+#[stable]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -869,11 +876,13 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n+#[stable]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n+#[stable]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "ae88a27974cf0a5a820b7fb51d37635f4c8d53ef", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -650,7 +650,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[experimental = \"needs review\"]\n+        #[stable]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -688,7 +688,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[experimental = \"needs review\"]\n+        #[stable]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -771,15 +771,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[experimental = \"needs review\"]\n+#[experimental = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -865,7 +865,7 @@ impl<'a, T> IterMut<'a, T> {\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -897,7 +897,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -925,7 +925,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -970,7 +970,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1005,7 +1005,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1038,7 +1038,6 @@ struct GenericSplitN<I> {\n     invert: bool\n }\n \n-#[experimental = \"needs review\"]\n impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n     type Item = T;\n \n@@ -1061,32 +1060,37 @@ impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n+#[stable]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n+#[stable]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n+#[stable]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n+#[stable]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n+        #[stable]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1112,12 +1116,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[stable]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1149,13 +1154,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1184,7 +1189,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1200,7 +1205,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[experimental = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1224,13 +1229,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[experimental = \"needs review\"]\n+#[stable]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1260,7 +1265,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1338,7 +1343,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable = \"jshould be renamed to from_raw_parts_mut\"]\n+#[unstable = \"should be renamed to from_raw_parts_mut\"]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p as *const T, len: len })\n }"}, {"sha": "a30fe68d9c3612ef0aa2283961f631bcb81f03fb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -37,18 +37,16 @@ use uint;\n macro_rules! delegate_iter {\n     (exact $te:ty in $ti:ty) => {\n         delegate_iter!{$te in $ti}\n+        #[stable]\n         impl<'a> ExactSizeIterator for $ti {\n-            #[inline]\n-            fn rposition<P>(&mut self, predicate: P) -> Option<uint> where P: FnMut($te) -> bool{\n-                self.0.rposition(predicate)\n-            }\n             #[inline]\n             fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n     };\n     ($te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -61,6 +59,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n+        #[stable]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -69,6 +68,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -81,6 +81,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n+        #[stable]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -89,6 +90,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty in $ti:ty) => {\n+        #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -275,6 +277,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n+#[stable]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -320,6 +323,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -356,11 +360,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n+#[stable]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n+#[stable]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -384,6 +390,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -465,6 +472,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -499,6 +507,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -540,6 +549,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n+#[stable]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -865,6 +875,7 @@ pub struct SplitStr<'a> {\n     finished: bool\n }\n \n+#[stable]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -881,6 +892,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -1586,26 +1598,30 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n+#[stable]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n-}\n+\n+#[stable]}\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}\n+\n+#[stable]}\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n-}\n+\n+#[stable]}\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "0d4b2dce4c6626f2c24dd95a599d7e5ee63bbc41", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -18,7 +18,7 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, IteratorCloneExt, FromIterator, Map, Chain, Extend};\n+use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n use result::Result::{Ok, Err};"}, {"sha": "ef9d28bbbb2e863bd993080831155ff454335613", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -309,7 +309,7 @@\n //! }\n //! ```\n \n-#![experimental]\n+#![stable]\n \n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n pub use core_collections::{DList, RingBuf, VecMap};\n@@ -322,11 +322,13 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n+#[stable]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n+#[stable]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;"}, {"sha": "c4e37264e2aeeb2d3ff1a83d58be901a2cc8e24a", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -14,7 +14,7 @@\n \n use cmp;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n-use iter::ExactSizeIterator;\n+use iter::{IteratorExt, ExactSizeIterator};\n use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};"}, {"sha": "9e9a483e1a5e3f510922eb6ae9b652eda2848162", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -25,11 +25,9 @@\n #[stable] #[doc(no_inline)] pub use char::CharExt;\n #[stable] #[doc(no_inline)] pub use clone::Clone;\n #[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[stable] #[doc(no_inline)] pub use iter::CloneIteratorExt;\n #[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n #[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n #[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n-#[stable] #[doc(no_inline)] pub use iter::{IteratorCloneExt, IteratorOrdExt};\n #[stable] #[doc(no_inline)] pub use option::Option::{self, Some, None};\n #[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable] #[doc(no_inline)] pub use result::Result::{self, Ok, Err};"}, {"sha": "e97be51fdbc25af6ccc56aec377ee00aee43173a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -188,6 +188,7 @@ impl Condvar {\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n+#[stable]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }"}, {"sha": "1ed68823a2c3b165bb47fce84f25321847d3477f", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -675,6 +675,7 @@ impl<T: Send> Clone for Sender<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -768,6 +769,7 @@ impl<T: Send> Clone for SyncSender<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n@@ -1006,12 +1008,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n-#[unstable]\n-impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n-    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n+#[stable]\n+impl<'a, T: Send> Iterator for Iter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {"}, {"sha": "9ad24a5a11ec5dfb61080a507b4d4a61920a8198", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -138,6 +138,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "6b3dd89f33b07fcc71cc4a4a02cdfd7c4072ec2a", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -228,6 +228,7 @@ impl<T: Send> Mutex<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -291,20 +292,23 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n+#[stable]\n impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n+#[stable]\n impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "e21aa3ef7e91bfb225fa8b36c6265958e403cdaf", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -228,6 +228,7 @@ impl<T: Send + Sync> RwLock<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n@@ -327,30 +328,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n+#[stable]\n impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+#[stable]\n impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+#[stable]\n impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);"}, {"sha": "505819fbf8a246cf4ee618b64e89cb921dd8d8a7", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -99,6 +99,7 @@ impl Semaphore {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {\n         self.sem.release();"}, {"sha": "cc82d38ae2af1f01140701dd4e6894296fc594d6", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=2e883a5f5310a257d6ff8a0d886737d7dc1e7ae4", "patch": "@@ -423,6 +423,7 @@ impl<T: Send> JoinGuard<T> {\n }\n \n #[unsafe_destructor]\n+#[stable]\n impl<T: Send> Drop for JoinGuard<T> {\n     fn drop(&mut self) {\n         if !self.joined {"}]}