{"sha": "5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZjFlN2UwZWZlNzEyOWVkYmYwNmE2OTlhYmFhNjU2M2U4Y2ZjOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-01T08:53:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-01T08:53:18Z"}, "message": "Auto merge of #34830 - michaelwoerister:internal-closures, r=nikomatsakis\n\ntrans: Avoid weak linkage for closures when linking with MinGW.\n\nThis PR proposes one possible solution to #34793, the problem that prevents https://github.com/servo/servo/pull/12393 from landing. It applies the same strategy, that we already use for monomorphizations, to closures, that is, instead of emitting symbols with `weak_odr` linkage in order to avoid symbol conflicts, we emit them with `internal` linkage, with the side effect that we have to copy code instead of just linking to it, if more than one codegen unit is involved.\nWith this PR, the compiler will only apply this strategy for targets where we would actually run into a problem when using `weak_odr` linkage, in other words nothing will change for platforms except for MinGW.\n\nThe solution implemented here has one restriction that could be lifted with some more effort, but it does not seem to be worth the trouble since it will go away once we use only MIR-trans: If someone compiles code\n\n1. on MinGW,\n2. with more than one codegen unit,\n3. *not* using MIR-trans,\n4. and runs into a closure inlined from another crate\n\nthen the compiler will abort and suggest to compile either with just one codegen unit or `-Zorbit`.\n\nWhat's nice about this is that I lays a foundation for also doing the same for generics: using weak linkage where possible and thus enabling some more space optimizations that the linker can do.\n\n~~This PR also contains a test case for compiling a program that contains more than 2^15 closures. It's a huge, generated file with almost 100K LOCs. I did not commit the script for generating the file but could do so. Alternatively, maybe someone wants to come up with a way of doing this with macros.~~\nThe test file is implemented via macros now (thanks @alexcrichton!)\n\nOpinions?\n\nFixes #34793.\n\ncc @rust-lang/compiler", "tree": {"sha": "6442c3ada91d688c993c6599840e4dec6ce60707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6442c3ada91d688c993c6599840e4dec6ce60707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "html_url": "https://github.com/rust-lang/rust/commit/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d648a16cd5e265e0e3676c91d4f627ad349af42b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d648a16cd5e265e0e3676c91d4f627ad349af42b", "html_url": "https://github.com/rust-lang/rust/commit/d648a16cd5e265e0e3676c91d4f627ad349af42b"}, {"sha": "eaea4ac8acbb46395f08b78452bfc758280e1421", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaea4ac8acbb46395f08b78452bfc758280e1421", "html_url": "https://github.com/rust-lang/rust/commit/eaea4ac8acbb46395f08b78452bfc758280e1421"}], "stats": {"total": 186, "additions": 145, "deletions": 41}, "files": [{"sha": "cdde6d6f63ddd1c3dcdb911251c799a673164b68", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -330,6 +330,11 @@ impl Options {\n             self.debugging_opts.dump_dep_graph ||\n             self.debugging_opts.query_dep_graph\n     }\n+\n+    pub fn single_codegen_unit(&self) -> bool {\n+        self.incremental.is_none() ||\n+        self.cg.codegen_units == 1\n+    }\n }\n \n // The type of entry function, so\n@@ -655,7 +660,6 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"panic strategy to compile crate with\"),\n }\n \n-\n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          build_debugging_options, \"Z\", \"debugging\",\n          DB_OPTIONS, db_type_desc, dbsetters,"}, {"sha": "3d24fd8ab67e4a2d4b1bd1d1a25ff95f3336933b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -292,6 +292,13 @@ pub struct TargetOptions {\n     pub is_like_android: bool,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n+    /// The MinGW toolchain has a known issue that prevents it from correctly\n+    /// handling COFF object files with more than 2^15 sections. Since each weak\n+    /// symbol needs its own COMDAT section, weak linkage implies a large\n+    /// number sections that easily exceeds the given limit for larger\n+    /// codebases. Consequently we want a way to disallow weak linkage on some\n+    /// platforms.\n+    pub allows_weak_linkage: bool,\n     /// Whether the linker support rpaths or not. Defaults to false.\n     pub has_rpath: bool,\n     /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM\n@@ -367,6 +374,7 @@ impl Default for TargetOptions {\n             is_like_android: false,\n             is_like_msvc: false,\n             linker_is_gnu: false,\n+            allows_weak_linkage: true,\n             has_rpath: false,\n             no_compiler_rt: false,\n             no_default_libraries: true,\n@@ -509,6 +517,7 @@ impl Target {\n         key!(is_like_msvc, bool);\n         key!(is_like_android, bool);\n         key!(linker_is_gnu, bool);\n+        key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n         key!(no_compiler_rt, bool);\n         key!(no_default_libraries, bool);\n@@ -651,6 +660,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_msvc);\n         target_option_val!(is_like_android);\n         target_option_val!(linker_is_gnu);\n+        target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);\n         target_option_val!(no_compiler_rt);\n         target_option_val!(no_default_libraries);"}, {"sha": "c398ee40f2f9790bfe5b4f310a8773baf79a982c", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -25,6 +25,7 @@ pub fn opts() -> TargetOptions {\n         staticlib_suffix: \".lib\".to_string(),\n         no_default_libraries: true,\n         is_like_windows: true,\n+        allows_weak_linkage: false,\n         pre_link_args: vec!(\n             // And here, we see obscure linker flags #45. On windows, it has been\n             // found to be necessary to have this flag to compile liblibc."}, {"sha": "6b9de4a48786d4eddbff71ee5f3120b71d3ecac8", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -181,6 +181,41 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n+fn translating_closure_body_via_mir_will_fail(ccx: &CrateContext,\n+                                              closure_def_id: DefId)\n+                                              -> bool {\n+    let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n+    let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n+    let use_mir = default_to_mir ^ ccx.tcx().has_attr(closure_def_id, invert);\n+\n+    !use_mir\n+}\n+\n+pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                            closure_def_id: DefId,\n+                                            closure_substs: ty::ClosureSubsts<'tcx>) {\n+    use syntax::ast::DUMMY_NODE_ID;\n+    use syntax_pos::DUMMY_SP;\n+    use syntax::ptr::P;\n+\n+    trans_closure_expr(Dest::Ignore(ccx),\n+                       &hir::FnDecl {\n+                           inputs: P::new(),\n+                           output: hir::NoReturn(DUMMY_SP),\n+                           variadic: false\n+                       },\n+                       &hir::Block {\n+                           stmts: P::new(),\n+                           expr: None,\n+                           id: DUMMY_NODE_ID,\n+                           rules: hir::DefaultBlock,\n+                           span: DUMMY_SP\n+                       },\n+                       DUMMY_NODE_ID,\n+                       closure_def_id,\n+                       closure_substs);\n+}\n+\n pub enum Dest<'a, 'tcx: 'a> {\n     SaveIn(Block<'a, 'tcx>, ValueRef),\n     Ignore(&'a CrateContext<'a, 'tcx>)\n@@ -213,8 +248,13 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // If we have not done so yet, translate this closure's body\n     if  !ccx.instances().borrow().contains_key(&instance) {\n         let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-        llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n-        llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+\n+        if ccx.sess().target.target.options.allows_weak_linkage {\n+            llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n+            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+        } else {\n+            llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+        }\n \n         // set an inline hint for all closures\n         attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -296,6 +336,39 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     // If this is a closure, redirect to it.\n     let llfn = get_or_create_closure_declaration(ccx, closure_def_id, substs);\n \n+    // If weak linkage is not allowed, we have to make sure that a local,\n+    // private copy of the closure is available in this codegen unit\n+    if !ccx.sess().target.target.options.allows_weak_linkage &&\n+       !ccx.sess().opts.single_codegen_unit() {\n+\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(closure_def_id) {\n+            // If the closure is defined in the local crate, we can always just\n+            // translate it.\n+            let (decl, body) = match ccx.tcx().map.expect_expr(node_id).node {\n+                hir::ExprClosure(_, ref decl, ref body, _) => (decl, body),\n+                _ => { unreachable!() }\n+            };\n+\n+            trans_closure_expr(Dest::Ignore(ccx),\n+                               decl,\n+                               body,\n+                               node_id,\n+                               closure_def_id,\n+                               substs);\n+        } else {\n+            // If the closure is defined in an upstream crate, we can only\n+            // translate it if MIR-trans is active.\n+\n+            if translating_closure_body_via_mir_will_fail(ccx, closure_def_id) {\n+                ccx.sess().fatal(\"You have run into a known limitation of the \\\n+                                  MingW toolchain. Either compile with -Zorbit or \\\n+                                  with -Ccodegen-units=1 to work around it.\");\n+            }\n+\n+            trans_closure_body_via_mir(ccx, closure_def_id, substs);\n+        }\n+    }\n+\n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n     let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);"}, {"sha": "8dc5e5f993fbe5122deba33712eb99aed3bf52a6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -530,26 +530,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 // FIXME Shouldn't need to manually trigger closure instantiations.\n                 if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                    use rustc::hir;\n-                    use syntax::ast::DUMMY_NODE_ID;\n-                    use syntax::ptr::P;\n                     use closure;\n-\n-                    closure::trans_closure_expr(closure::Dest::Ignore(self.ccx),\n-                                                &hir::FnDecl {\n-                                                    inputs: P::new(),\n-                                                    output: hir::NoReturn(DUMMY_SP),\n-                                                    variadic: false\n-                                                },\n-                                                &hir::Block {\n-                                                    stmts: P::new(),\n-                                                    expr: None,\n-                                                    id: DUMMY_NODE_ID,\n-                                                    rules: hir::DefaultBlock,\n-                                                    span: DUMMY_SP\n-                                                },\n-                                                DUMMY_NODE_ID, def_id,\n-                                                self.monomorphize(&substs));\n+                    closure::trans_closure_body_via_mir(self.ccx,\n+                                                        def_id,\n+                                                        self.monomorphize(&substs));\n                 }\n \n                 let val = if let mir::AggregateKind::Adt(adt_def, index, _) = *kind {"}, {"sha": "6ebc23884918976c19f4cfc1c220ed3ab3977a8f", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -131,27 +131,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     _ => {\n                         // FIXME Shouldn't need to manually trigger closure instantiations.\n                         if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n-                            use rustc::hir;\n-                            use syntax::ast::DUMMY_NODE_ID;\n-                            use syntax::ptr::P;\n-                            use syntax_pos::DUMMY_SP;\n                             use closure;\n \n-                            closure::trans_closure_expr(closure::Dest::Ignore(bcx.ccx()),\n-                                                        &hir::FnDecl {\n-                                                            inputs: P::new(),\n-                                                            output: hir::NoReturn(DUMMY_SP),\n-                                                            variadic: false\n-                                                        },\n-                                                        &hir::Block {\n-                                                            stmts: P::new(),\n-                                                            expr: None,\n-                                                            id: DUMMY_NODE_ID,\n-                                                            rules: hir::DefaultBlock,\n-                                                            span: DUMMY_SP\n-                                                        },\n-                                                        DUMMY_NODE_ID, def_id,\n-                                                        bcx.monomorphize(&substs));\n+                            closure::trans_closure_body_via_mir(bcx.ccx(),\n+                                                                def_id,\n+                                                                bcx.monomorphize(&substs));\n                         }\n \n                         for (i, operand) in operands.iter().enumerate() {"}, {"sha": "d2c9a5d562b026b818e23233b5b3971d183d6fa2", "filename": "src/test/run-pass/myriad-closures.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-pass%2Fmyriad-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-pass%2Fmyriad-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmyriad-closures.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case tests whether we can handle code bases that contain a high\n+// number of closures, something that needs special handling in the MingGW\n+// toolchain.\n+// See https://github.com/rust-lang/rust/issues/34793 for more information.\n+\n+// Expand something exponentially\n+macro_rules! go_bacterial {\n+    ($mac:ident) => ($mac!());\n+    ($mac:ident 1 $($t:tt)*) => (\n+        go_bacterial!($mac $($t)*);\n+        go_bacterial!($mac $($t)*);\n+    )\n+}\n+\n+macro_rules! mk_closure {\n+    () => ({\n+        let c = |a: u32| a + 4;\n+        let _ = c(2);\n+    })\n+}\n+\n+macro_rules! mk_fn {\n+    () => {\n+        {\n+            fn function() {\n+                // Make 16 closures\n+                go_bacterial!(mk_closure 1 1 1 1);\n+            }\n+            let _ = function();\n+        }\n+    }\n+}\n+\n+fn main() {\n+    // Make 2^12 functions, each containing 16 closures,\n+    // resulting in 2^16 closures overall.\n+    go_bacterial!(mk_fn 1 1 1 1  1 1 1 1  1 1 1 1);\n+}"}]}