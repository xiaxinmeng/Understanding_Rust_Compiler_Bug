{"sha": "c8ec909cdd35a82ee79ab18a15a696805e331b17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZWM5MDljZGQzNWE4MmVlNzlhYjE4YTE1YTY5NjgwNWUzMzFiMTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T08:45:11Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-16T11:07:40Z"}, "message": "Rollup merge of #27039 - bluss:siphash-tests, r=alexcrichton\n\n core: Revive SipHash's tests\n\nThese tests were bitrotting, include them in the crate and bring them up\nto date and compiling.. and they pass.", "tree": {"sha": "3ecb197e60eba68a9ef46813a76d1b6c3e1672f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ecb197e60eba68a9ef46813a76d1b6c3e1672f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ec909cdd35a82ee79ab18a15a696805e331b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ec909cdd35a82ee79ab18a15a696805e331b17", "html_url": "https://github.com/rust-lang/rust/commit/c8ec909cdd35a82ee79ab18a15a696805e331b17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ec909cdd35a82ee79ab18a15a696805e331b17/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77d5fca3effd71b2270d7bd00a758fd8522c0d4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/77d5fca3effd71b2270d7bd00a758fd8522c0d4b", "html_url": "https://github.com/rust-lang/rust/commit/77d5fca3effd71b2270d7bd00a758fd8522c0d4b"}, {"sha": "86d954ba2b97d971e866a70b588d73b53f3c29a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/86d954ba2b97d971e866a70b588d73b53f3c29a0", "html_url": "https://github.com/rust-lang/rust/commit/86d954ba2b97d971e866a70b588d73b53f3c29a0"}], "stats": {"total": 130, "additions": 61, "deletions": 69}, "files": [{"sha": "d26e9ab7072055d9a7a24f38e2e31ca58fa10409", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=c8ec909cdd35a82ee79ab18a15a696805e331b17", "patch": "@@ -10,8 +10,6 @@\n \n //! An implementation of SipHash 2-4.\n \n-#![allow(deprecated)] // until the next snapshot for inherent wrapping ops\n-\n use prelude::*;\n use super::Hasher;\n "}, {"sha": "697c3ee254b983ee3323381c14e6f8bb649bf654", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=c8ec909cdd35a82ee79ab18a15a696805e331b17", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod sip;\n+\n use std::mem;\n use std::hash::{Hash, Hasher};\n use std::default::Default;"}, {"sha": "7832985d3f1c1ee158291af85f1ea502e871a3d1", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ec909cdd35a82ee79ab18a15a696805e331b17/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=c8ec909cdd35a82ee79ab18a15a696805e331b17", "patch": "@@ -8,28 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use test::Bencher;\n-use std::prelude::*;\n-use std::fmt;\n \n-use str::Str;\n-use string::String;\n-use slice::{AsSlice, SlicePrelude};\n-use vec::Vec;\n-\n-use core::hash::{Hash, Writer};\n-use core::hash::sip::{SipState, hash, hash_with_keys};\n+use core::hash::{Hash, Hasher};\n+use core::hash::SipHasher;\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n \n-impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n+impl<'a> Hash for Bytes<'a> {\n     #[allow(unused_must_use)]\n-    fn hash(&self, state: &mut S) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n     }\n }\n \n+macro_rules! u8to64_le {\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     ($buf[1+$i] as u64) << 8 |\n+     ($buf[2+$i] as u64) << 16 |\n+     ($buf[3+$i] as u64) << 24 |\n+     ($buf[4+$i] as u64) << 32 |\n+     ($buf[5+$i] as u64) << 40 |\n+     ($buf[6+$i] as u64) << 48 |\n+     ($buf[7+$i] as u64) << 56);\n+    ($buf:expr, $i:expr, $len:expr) =>\n+    ({\n+        let mut t = 0;\n+        let mut out = 0;\n+        while t < $len {\n+            out |= ($buf[t+$i] as u64) << t*8;\n+            t += 1;\n+        }\n+        out\n+    });\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    let mut st = SipHasher::new();\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n+fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 {\n+    let mut st = SipHasher::new_with_keys(k1, k2);\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash() {\n@@ -104,79 +131,43 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipState::new_with_keys(k0, k1);\n-    let mut state_full = SipState::new_with_keys(k0, k1);\n-\n-    fn to_hex_str(r: &[u8; 8]) -> String {\n-        let mut s = String::new();\n-        for b in r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n-\n-    fn result_bytes(h: u64) -> Vec<u8> {\n-        vec![(h >> 0) as u8,\n-          (h >> 8) as u8,\n-          (h >> 16) as u8,\n-          (h >> 24) as u8,\n-          (h >> 32) as u8,\n-          (h >> 40) as u8,\n-          (h >> 48) as u8,\n-          (h >> 56) as u8,\n-        ]\n-    }\n-\n-    fn result_str(h: u64) -> String {\n-        let r = result_bytes(h);\n-        let mut s = String::new();\n-        for b in &r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n+    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n \n     while t < 64 {\n-        debug!(\"siphash test {}: {}\", t, buf);\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with_keys(k0, k1, &Bytes(buf));\n-        debug!(\"got {}, expected {}\", out, vec);\n+        let out = hash_with_keys(k0, k1, &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        state_full.reset();\n-        state_full.write(buf);\n-        let f = result_str(state_full.result());\n-        let i = result_str(state_inc.result());\n-        let v = to_hex_str(&vecs[t]);\n-        debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+        let full = hash_with_keys(k0, k1, &Bytes(&buf));\n+        let i = state_inc.finish();\n \n-        assert_eq!(f, i);\n-        assert_eq!(f, v);\n+        assert_eq!(full, i);\n+        assert_eq!(full, vec);\n \n         buf.push(t as u8);\n-        state_inc.write(&[t as u8]);\n+        Hasher::write(&mut state_inc, &[t as u8]);\n \n         t += 1;\n     }\n }\n \n #[test] #[cfg(target_arch = \"arm\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-    assert!(hash(&(val as u32)) != hash(&(val as uint)));\n+    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+    assert!(hash(&(val as u32)) != hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n \n #[test]\n@@ -200,7 +191,7 @@ fn test_hash_no_bytes_dropped_64() {\n     assert!(hash(&val) != hash(&zero_byte(val, 6)));\n     assert!(hash(&val) != hash(&zero_byte(val, 7)));\n \n-    fn zero_byte(val: u64, byte: uint) -> u64 {\n+    fn zero_byte(val: u64, byte: usize) -> u64 {\n         assert!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n@@ -215,7 +206,7 @@ fn test_hash_no_bytes_dropped_32() {\n     assert!(hash(&val) != hash(&zero_byte(val, 2)));\n     assert!(hash(&val) != hash(&zero_byte(val, 3)));\n \n-    fn zero_byte(val: u32, byte: uint) -> u32 {\n+    fn zero_byte(val: u32, byte: usize) -> u32 {\n         assert!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n@@ -230,8 +221,9 @@ fn test_hash_no_concat_alias() {\n     assert!(s != t && t != u);\n     assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n \n-    let v: (&[u8], &[u8], &[u8]) = (&[1], &[0, 0], &[0]);\n-    let w: (&[u8], &[u8], &[u8]) = (&[1, 0, 0, 0], &[], &[]);\n+    let u = [1, 0, 0, 0];\n+    let v = (&u[..1], &u[1..3], &u[3..]);\n+    let w = (&u[..], &u[4..4], &u[4..4]);\n \n     assert!(v != w);\n     assert!(hash(&v) != hash(&w));"}]}