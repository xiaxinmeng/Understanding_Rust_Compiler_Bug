{"sha": "b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZmJkMzQ2MDNjNWUyMDlhYjdhNjFhMDljYTk0M2JkNWIxNWYxYTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-25T03:20:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T21:24:10Z"}, "message": "core::rt: Begin implementing TcpStream\n\nThis ended up touching a lot of code related to error handling.", "tree": {"sha": "6dca7e91760ec1d47acea7742426464aae3055cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dca7e91760ec1d47acea7742426464aae3055cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "html_url": "https://github.com/rust-lang/rust/commit/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b4d4edf8bc6a90c0bcbf06599ddf92fea1ed58f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4d4edf8bc6a90c0bcbf06599ddf92fea1ed58f", "html_url": "https://github.com/rust-lang/rust/commit/0b4d4edf8bc6a90c0bcbf06599ddf92fea1ed58f"}], "stats": {"total": 339, "additions": 282, "deletions": 57}, "files": [{"sha": "b2e94f327c86e188f971289564876559efcdd90e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -30,6 +30,14 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+macro_rules! rtassert (\n+    ( $arg:expr ) => ( {\n+        if !$arg {\n+            abort!(\"assertion failed: %s\", stringify!($arg));\n+        }\n+    } )\n+)\n+\n macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);"}, {"sha": "93daa36dd60a7ae68174689ff1396cbeca058f3c", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -252,7 +252,9 @@ pub use self::stdio::println;\n \n pub use self::file::FileStream;\n pub use self::net::ip::IpAddr;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpListener;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n@@ -266,6 +268,7 @@ pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n pub mod net {\n+    #[cfg(not(stage0))]\n     pub mod tcp;\n     pub mod udp;\n     pub mod ip;\n@@ -326,12 +329,14 @@ pub struct IoError {\n \n #[deriving(Eq)]\n pub enum IoErrorKind {\n+    PreviousIoError,\n+    OtherIoError,\n+    EndOfFile,\n     FileNotFound,\n-    FilePermission,\n+    PermissionDenied,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError,\n-    PreviousIoError\n+    ConnectionRefused,\n }\n \n // XXX: Can't put doc comments on macros"}, {"sha": "2ac2ffb60a8cfcd3bc757e49d4f5251cb2056269", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 140, "deletions": 24, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -8,63 +8,179 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::super::*;\n-use super::ip::IpAddr;\n+use option::{Option, Some, None};\n+use result::{Result, Ok, Err};\n+use ops::Drop;\n+use rt::sched::local_sched::unsafe_borrow_io;\n+use rt::io::net::ip::IpAddr;\n+use rt::io::{Reader, Writer, Listener};\n+use rt::io::io_error;\n+use rt::rtio;\n+use rt::rtio::{IoFactory, TcpListener, Stream};\n \n-pub struct TcpStream;\n+pub struct TcpStream {\n+    rtstream: ~rtio::StreamObject\n+}\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n-        fail!()\n+    fn new(s: ~rtio::StreamObject) -> TcpStream {\n+        TcpStream {\n+            rtstream: s\n+        }\n+    }\n+\n+    pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n+        let stream = unsafe {\n+            rtdebug!(\"borrowing io to connect\");\n+            let io = unsafe_borrow_io();\n+            rtdebug!(\"about to connect\");\n+            io.connect(addr)\n+        };\n+\n+        match stream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to connect: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let bytes_read = self.rtstream.read(buf);\n+        match bytes_read {\n+            Ok(read) => Some(read),\n+            Err(_) => {\n+                abort!(\"TODO\");\n+            }\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        let res = self.rtstream.write(buf);\n+        match res {\n+            Ok(_) => (),\n+            Err(_) => {\n+                abort!(\"TODO\");\n+            }\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n \n-pub struct TcpListener;\n+impl Drop for TcpStream {\n+    fn finalize(&self) {\n+        self.rtstream.close();\n+    }\n+}\n+\n+pub struct TcpListener {\n+    rtlistener: ~rtio::TcpListenerObject\n+}\n \n impl TcpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n-        fail!()\n+    pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n+        let listener = unsafe { unsafe_borrow_io().bind(addr) };\n+        match listener {\n+            Ok(l) => {\n+                Some(TcpListener {\n+                    rtlistener: l\n+                })\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n-    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+    fn accept(&mut self) -> Option<TcpStream> {\n+        let rtstream = self.rtlistener.listen();\n+        match rtstream {\n+            Some(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            None => {\n+                abort!(\"TODO\");\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for TcpListener {\n+    fn finalize(&self) {\n+        self.rtlistener.close();\n+    }\n }\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n+    use rt::test::*;\n+    use rt::io::net::ip::Ipv4;\n+    use rt::io::*;\n+\n+    #[test]\n+    fn bind_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let listener = TcpListener::bind(addr);\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == ConnectionRefused);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let stream = TcpStream::connect(addr);\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n \n-    #[test] #[ignore]\n+    #[test]\n     fn smoke_test() {\n-        /*do run_in_newsched_task {\n+        do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawn_immediately {\n-                let listener = TcpListener::bind(addr);\n-                do listener.accept() {\n-                    let mut buf = [0];\n-                    listener.read(buf);\n-                    assert!(buf[0] == 99);\n-                }\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n             }\n \n-            do spawn_immediately {\n-                let stream = TcpStream::connect(addr);\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n-        }*/\n+        }\n     }\n }"}, {"sha": "47e8669b5469252651befc7085615287e15532f7", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -177,7 +177,8 @@ pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n             transmute_mut_region(&mut task.local_services)\n         }\n         None => {\n-            fail!(~\"no local services for schedulers yet\")\n+            // Don't fail. Infinite recursion\n+            abort!(\"no local services for schedulers yet\")\n         }\n     }\n }"}, {"sha": "72715ea9b2823827b3db7e5c3dafa2a3f7a3964b", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -8,15 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! The Rust runtime, including the scheduler and I/O interface */\n+/*! The Rust runtime, including the scheduler and I/O interface\n+\n+# XXX\n+\n+* Unsafe uses of borrowed pointers should just use unsafe pointers\n+* Unwinding is not wired up correctly\n+\n+*/\n+\n \n #[doc(hidden)];\n \n use libc::c_char;\n \n #[path = \"sched/mod.rs\"]\n mod sched;\n-mod rtio;\n+pub mod rtio;\n pub mod uvll;\n mod uvio;\n #[path = \"uv/mod.rs\"]"}, {"sha": "961a032607eb3500d7109ad73f8f720b69ba22af", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -11,6 +11,7 @@\n use option::*;\n use result::*;\n \n+use rt::io::IoError;\n use super::io::net::ip::IpAddr;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n@@ -28,8 +29,8 @@ pub trait EventLoop {\n }\n \n pub trait IoFactory {\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject>;\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject>;\n+    fn connect(&mut self, addr: IpAddr) -> Result<~StreamObject, IoError>;\n+    fn bind(&mut self, addr: IpAddr) -> Result<~TcpListenerObject, IoError>;\n }\n \n pub trait TcpListener {"}, {"sha": "c4153381d91aa5410e02845bf9524f3e052b8c36", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -13,18 +13,21 @@\n use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n-use cast::transmute;\n+use cast;\n+use cell::Cell;\n \n use super::Scheduler;\n use super::super::rtio::IoFactoryObject;\n use tls = super::super::thread_local_storage;\n+use unstable::finally::Finally;\n+\n #[cfg(test)] use super::super::uvio::UvEventLoop;\n \n /// Give the Scheduler to thread-local storage\n pub fn put(sched: ~Scheduler) {\n     unsafe {\n         let key = tls_key();\n-        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        let void_sched: *mut c_void = cast::transmute(sched);\n         tls::set(key, void_sched);\n     }\n }\n@@ -34,8 +37,8 @@ pub fn take() -> ~Scheduler {\n     unsafe {\n         let key = tls_key();\n         let void_sched: *mut c_void = tls::get(key);\n-        assert!(void_sched.is_not_null());\n-        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        rtassert!(void_sched.is_not_null());\n+        let sched: ~Scheduler = cast::transmute(void_sched);\n         tls::set(key, mut_null());\n         return sched;\n     }\n@@ -55,8 +58,18 @@ pub fn exists() -> bool {\n /// While the scheduler is borrowed it is not available in TLS.\n pub fn borrow(f: &fn(&mut Scheduler)) {\n     let mut sched = take();\n-    f(sched);\n-    put(sched);\n+\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    unsafe {\n+        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n+        let sched = Cell(sched);\n+        \n+        do (|| {\n+            f(unsafe_sched);\n+        }).finally {\n+            put(sched.take());\n+        }\n+    }\n }\n \n /// Borrow a mutable reference to the thread-local Scheduler\n@@ -68,11 +81,11 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n-    assert!(void_sched.is_not_null());\n+    rtassert!(void_sched.is_not_null());\n     {\n         let void_sched_ptr = &mut void_sched;\n         let sched: &mut ~Scheduler = {\n-            transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n+            cast::transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n         };\n         let sched: &mut Scheduler = &mut **sched;\n         return sched;\n@@ -91,7 +104,7 @@ fn tls_key() -> tls::Key {\n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_sched_tls_key();\n-        let key: &mut tls::Key = transmute(key);\n+        let key: &mut tls::Key = cast::transmute(key);\n         let key = *key;\n         // Check that the key has been initialized.\n "}, {"sha": "87aa7524ed610517e16f9bf80fe1c6ace60e0abb", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -34,17 +34,22 @@ via `close` and `delete` methods.\n \n */\n \n+use libc;\n+use vec;\n+use ptr;\n+use cast;\n+use str;\n use option::*;\n use str::raw::from_c_str;\n use to_str::ToStr;\n-use vec;\n-use ptr;\n use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n-use super::uvll;\n use unstable::finally::Finally;\n \n+use rt::uvll;\n+use rt::io::{IoError, FileNotFound};\n+\n #[cfg(test)] use unstable::run_in_bare_thread;\n \n pub use self::file::{FsRequest, FsCallback};\n@@ -211,6 +216,55 @@ fn error_smoke_test() {\n     assert!(err.to_str() == ~\"EOF: end of file\");\n }\n \n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n+    unsafe {\n+        let loop_ = loop_from_watcher(watcher);\n+        UvError(uvll::last_error(loop_.native_handle()))\n+    }\n+}\n+\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n+\n+    // XXX: Could go in str::raw\n+    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s, len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len);\n+        }\n+\n+        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n+    }\n+\n+\n+    unsafe {\n+        // Importing error constants\n+        use rt::uvll::*;\n+        use rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(&*uverr);\n+        let desc = c_str_to_static_slice(c_desc);\n+\n+        let kind = match uverr.code {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            e => {\n+                abort!(\"unknown uv error code: %u\", e as uint);\n+            }\n+        };\n+\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n+    }\n+}\n \n /// Given a uv handle, convert a callback status to a UvError\n // XXX: Follow the pattern below by parameterizing over T: Watcher, not T"}, {"sha": "6d8979e04d68e8e0f775db81c53b4ac8587b9aeb", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -18,13 +18,14 @@ use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCa\n             install_watcher_data, get_watcher_data, drop_watcher_data,\n             vec_to_uv_buf, vec_from_uv_buf};\n use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::uv::last_uv_error;\n \n #[cfg(test)] use cell::Cell;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use super::super::thread::Thread;\n #[cfg(test)] use super::super::test::*;\n \n-fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n+fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n             unsafe {\n@@ -34,7 +35,7 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n                                                 c as uint,\n                                                 d as uint), p as int);\n                 do (|| {\n-                    f(addr);\n+                    f(addr)\n                 }).finally {\n                     free_ip4_addr(addr);\n                 }\n@@ -193,15 +194,18 @@ pub impl TcpWatcher {\n         }\n     }\n \n-    fn bind(&mut self, address: IpAddr) {\n+    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n                     let result = unsafe {\n                         uvll::tcp_bind(self.native_handle(), addr)\n                     };\n-                    // XXX: bind is likely to fail. need real error handling\n-                    assert!(result == 0);\n+                    if result == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(last_uv_error(self))\n+                    }\n                 }\n             }\n             _ => fail!()"}, {"sha": "2c4ff37e4be455c4a1512dffc24b0d8908668b33", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -11,6 +11,7 @@\n use option::*;\n use result::*;\n \n+use rt::io::IoError;\n use super::io::net::ip::IpAddr;\n use super::uv::*;\n use super::rtio::*;\n@@ -98,11 +99,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n+    fn connect(&mut self, addr: IpAddr) -> Result<~StreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~StreamObject, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -122,11 +123,12 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 let maybe_stream = if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n+                    Ok(~UvStream(stream_watcher))\n                 } else {\n                     rtdebug!(\"status is some\");\n+                    // XXX: Wait for close\n                     stream_watcher.close(||());\n-                    None\n+                    Err(uv_error_to_io_error(status.get()))\n                 };\n \n                 // Store the stream in the task's stack\n@@ -142,10 +144,16 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n+    fn bind(&mut self, addr: IpAddr) -> Result<~TcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvTcpListener(watcher)),\n+            Err(uverr) => {\n+                // XXX: Should we wait until close completes?\n+                watcher.as_stream().close(||());\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n     }\n }\n \n@@ -321,7 +329,7 @@ fn test_simple_io_no_connect() {\n         let io = unsafe { local_sched::unsafe_borrow_io() };\n         let addr = next_test_ip4();\n         let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n+        assert!(maybe_chan.is_err());\n     }\n }\n "}, {"sha": "2a2812c67184750884b184b1c2fa7d387867f57a", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=b2fbd34603c5e209ab7a61a09ca943bd5b15f1a3", "patch": "@@ -33,6 +33,13 @@ use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use prelude::*;\n \n+pub static UNKNOWN: c_int = -1;\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+\n pub struct uv_err_t {\n     code: c_int,\n     sys_errno_: c_int"}]}