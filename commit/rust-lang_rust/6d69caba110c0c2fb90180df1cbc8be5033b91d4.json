{"sha": "6d69caba110c0c2fb90180df1cbc8be5033b91d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNjljYWJhMTEwYzBjMmZiOTAxODBkZjFjYmM4YmU1MDMzYjkxZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-27T18:38:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-27T18:38:19Z"}, "message": "Auto merge of #68434 - varkor:astconv-mismatch-error, r=nikomatsakis\n\nMove generic arg/param validation to `create_substs_for_generic_args` to resolve various const generics issues\n\nThis changes some diagnostics, but I think they're around as helpful as the previous ones, and occur infrequently regardless.\n\nFixes https://github.com/rust-lang/rust/issues/68257.\nFixes https://github.com/rust-lang/rust/issues/68398.\n\nr? @eddyb", "tree": {"sha": "ea43727ec0e56f4eda523aa60ccc346bd085083c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea43727ec0e56f4eda523aa60ccc346bd085083c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d69caba110c0c2fb90180df1cbc8be5033b91d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d69caba110c0c2fb90180df1cbc8be5033b91d4", "html_url": "https://github.com/rust-lang/rust/commit/6d69caba110c0c2fb90180df1cbc8be5033b91d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d69caba110c0c2fb90180df1cbc8be5033b91d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0", "html_url": "https://github.com/rust-lang/rust/commit/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0"}, {"sha": "bead79ebc6d0f605f42a0f8315ce9f5fe5764b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/bead79ebc6d0f605f42a0f8315ce9f5fe5764b99", "html_url": "https://github.com/rust-lang/rust/commit/bead79ebc6d0f605f42a0f8315ce9f5fe5764b99"}], "stats": {"total": 582, "additions": 349, "deletions": 233}, "files": [{"sha": "dae9f945ce09811f828bb4aa546c8b89be976a15", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -931,7 +931,17 @@ pub enum GenericParamDefKind {\n     Const,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+impl GenericParamDefKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GenericParamDefKind::Lifetime => \"lifetime\",\n+            GenericParamDefKind::Type { .. } => \"type\",\n+            GenericParamDefKind::Const => \"constant\",\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: Symbol,\n     pub def_id: DefId,"}, {"sha": "03ff1b8a3171f6b5af9a9ddc154f1bda741bbcc7", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -17,17 +17,6 @@ use std::fmt;\n use std::rc::Rc;\n use std::sync::Arc;\n \n-impl fmt::Debug for ty::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type { .. } => \"Type\",\n-            ty::GenericParamDefKind::Const => \"Const\",\n-        };\n-        write!(f, \"{}({}, {:?}, {})\", type_name, self.name, self.def_id, self.index)\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {"}, {"sha": "0463ad7fb7b6f1226df06b0376b8e0d004856e82", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 17, "deletions": 65, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, struct_span_err, Applicability, FatalError};\n+use rustc_errors::{error_code, struct_span_err, Applicability};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY;\n use rustc_session::lint::LintBuffer;\n@@ -596,23 +596,15 @@ impl<'a> AstValidator<'a> {\n     }\n }\n \n-enum GenericPosition {\n-    Param,\n-    Arg,\n-}\n-\n-fn validate_generics_order<'a>(\n+fn validate_generic_param_order<'a>(\n     sess: &Session,\n     handler: &rustc_errors::Handler,\n     generics: impl Iterator<Item = (ParamKindOrd, Option<&'a [GenericBound]>, Span, Option<String>)>,\n-    pos: GenericPosition,\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n     let mut out_of_order = FxHashMap::default();\n     let mut param_idents = vec![];\n-    let mut found_type = false;\n-    let mut found_const = false;\n \n     for (kind, bounds, span, ident) in generics {\n         if let Some(ident) = ident {\n@@ -626,11 +618,6 @@ fn validate_generics_order<'a>(\n             }\n             Some(_) | None => *max_param = Some(kind),\n         };\n-        match kind {\n-            ParamKindOrd::Type => found_type = true,\n-            ParamKindOrd::Const => found_const = true,\n-            _ => {}\n-        }\n     }\n \n     let mut ordered_params = \"<\".to_string();\n@@ -653,42 +640,26 @@ fn validate_generics_order<'a>(\n     }\n     ordered_params += \">\";\n \n-    let pos_str = match pos {\n-        GenericPosition::Param => \"parameter\",\n-        GenericPosition::Arg => \"argument\",\n-    };\n-\n     for (param_ord, (max_param, spans)) in &out_of_order {\n-        let mut err = handler.struct_span_err(\n-            spans.clone(),\n-            &format!(\n-                \"{} {pos}s must be declared prior to {} {pos}s\",\n-                param_ord,\n-                max_param,\n-                pos = pos_str,\n-            ),\n-        );\n-        if let GenericPosition::Param = pos {\n-            err.span_suggestion(\n-                span,\n+        let mut err =\n+            handler.struct_span_err(\n+                spans.clone(),\n                 &format!(\n-                    \"reorder the {}s: lifetimes, then types{}\",\n-                    pos_str,\n-                    if sess.features_untracked().const_generics { \", then consts\" } else { \"\" },\n+                    \"{} parameters must be declared prior to {} parameters\",\n+                    param_ord, max_param,\n                 ),\n-                ordered_params.clone(),\n-                Applicability::MachineApplicable,\n             );\n-        }\n+        err.span_suggestion(\n+            span,\n+            &format!(\n+                \"reorder the parameters: lifetimes, then types{}\",\n+                if sess.features_untracked().const_generics { \", then consts\" } else { \"\" },\n+            ),\n+            ordered_params.clone(),\n+            Applicability::MachineApplicable,\n+        );\n         err.emit();\n     }\n-\n-    // FIXME(const_generics): we shouldn't have to abort here at all, but we currently get ICEs\n-    // if we don't. Const parameters and type parameters can currently conflict if they\n-    // are out-of-order.\n-    if !out_of_order.is_empty() && found_type && found_const {\n-        FatalError.raise();\n-    }\n }\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n@@ -1016,24 +987,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n                 walk_list!(self, visit_generic_arg, &data.args);\n-                validate_generics_order(\n-                    self.session,\n-                    self.err_handler(),\n-                    data.args.iter().map(|arg| {\n-                        (\n-                            match arg {\n-                                GenericArg::Lifetime(..) => ParamKindOrd::Lifetime,\n-                                GenericArg::Type(..) => ParamKindOrd::Type,\n-                                GenericArg::Const(..) => ParamKindOrd::Const,\n-                            },\n-                            None,\n-                            arg.span(),\n-                            None,\n-                        )\n-                    }),\n-                    GenericPosition::Arg,\n-                    generic_args.span(),\n-                );\n \n                 // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n                 // are allowed to contain nested `impl Trait`.\n@@ -1070,7 +1023,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n         }\n \n-        validate_generics_order(\n+        validate_generic_param_order(\n             self.session,\n             self.err_handler(),\n             generics.params.iter().map(|param| {\n@@ -1085,7 +1038,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 };\n                 (kind, Some(&*param.bounds), param.ident.span, ident)\n             }),\n-            GenericPosition::Param,\n             generics.span,\n         );\n "}, {"sha": "91a7b6c8958382bab398372bec9c093e590339b4", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -417,6 +417,7 @@ E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n E0745: include_str!(\"./error_codes/E0745.md\"),\n E0746: include_str!(\"./error_codes/E0746.md\"),\n+E0747: include_str!(\"./error_codes/E0747.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "df1afbfef46df1c4435158a75287c978dd4ffaa8", "filename": "src/librustc_error_codes/error_codes/E0747.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -0,0 +1,20 @@\n+Generic arguments must be provided in the same order as the corresponding\n+generic parameters are declared.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0747\n+struct S<'a, T>(&'a T);\n+\n+type X = S<(), 'static>; // error: the type argument is provided before the\n+                         // lifetime argument\n+```\n+\n+The argument order should be changed to match the parameter declaration\n+order, as in the following.\n+\n+```\n+struct S<'a, T>(&'a T);\n+\n+type X = S<'static, ()>; // ok\n+```"}, {"sha": "2e99998c627bf6afb33bca978f79d83c4dcb8b99", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -298,6 +298,14 @@ impl GenericArg<'_> {\n             _ => false,\n         }\n     }\n+\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GenericArg::Lifetime(_) => \"lifetime\",\n+            GenericArg::Type(_) => \"type\",\n+            GenericArg::Const(_) => \"constant\",\n+        }\n+    }\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]"}, {"sha": "49f38d86d916133cd21caa44da9963d3506dd880", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 180, "deletions": 99, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -12,7 +12,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::ErrorReported;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n-use rustc::session::parse::feature_err;\n+use rustc::session::{parse::feature_err, Session};\n use rustc::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n@@ -132,6 +132,15 @@ enum GenericArgPosition {\n     MethodCall,\n }\n \n+/// A marker denoting that the generic arguments that were\n+/// provided did not match the respective generic parameters.\n+pub struct GenericArgCountMismatch {\n+    /// Indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n+    pub reported: Option<ErrorReported>,\n+    /// A list of spans of arguments provided that were not valid.\n+    pub invalid_args: Vec<Span>,\n+}\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -262,7 +271,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: &ty::Generics,\n         seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n-    ) -> bool {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         let empty_args = hir::GenericArgs::none();\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n@@ -274,7 +283,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             def.parent.is_none() && def.has_self, // `has_self`\n             seg.infer_args || suppress_mismatch,  // `infer_args`\n         )\n-        .0\n     }\n \n     /// Checks that the correct number of generic arguments have been provided.\n@@ -287,7 +295,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> (bool, Option<Vec<Span>>) {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -313,7 +321,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n-        let mut reported_late_bound_region_err = None;\n+        let mut explicit_lifetimes = Ok(());\n         if !infer_lifetimes {\n             if let Some(span_late) = def.has_late_bound_regions {\n                 let msg = \"cannot specify lifetime arguments explicitly \\\n@@ -323,11 +331,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if position == GenericArgPosition::Value\n                     && arg_counts.lifetimes != param_counts.lifetimes\n                 {\n+                    explicit_lifetimes = Err(true);\n                     let mut err = tcx.sess.struct_span_err(span, msg);\n                     err.span_note(span_late, note);\n                     err.emit();\n-                    reported_late_bound_region_err = Some(true);\n                 } else {\n+                    explicit_lifetimes = Err(false);\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n                     tcx.struct_span_lint_hir(\n@@ -336,112 +345,136 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         multispan,\n                         |lint| lint.build(msg).emit(),\n                     );\n-                    reported_late_bound_region_err = Some(false);\n                 }\n             }\n         }\n \n-        let check_kind_count = |kind, required, permitted, provided, offset| {\n-            debug!(\n-                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                kind, required, permitted, provided, offset\n-            );\n-            // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-            if required <= provided && provided <= permitted {\n-                return (reported_late_bound_region_err.unwrap_or(false), None);\n-            }\n-\n-            // Unfortunately lifetime and type parameter mismatches are typically styled\n-            // differently in diagnostics, which means we have a few cases to consider here.\n-            let (bound, quantifier) = if required != permitted {\n-                if provided < required {\n-                    (required, \"at least \")\n-                } else {\n-                    // provided > permitted\n-                    (permitted, \"at most \")\n+        let check_kind_count =\n+            |kind, required, permitted, provided, offset, unexpected_spans: &mut Vec<Span>| {\n+                debug!(\n+                    \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                    kind, required, permitted, provided, offset\n+                );\n+                // We enforce the following: `required` <= `provided` <= `permitted`.\n+                // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+                // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+                if required <= provided && provided <= permitted {\n+                    return Ok(());\n                 }\n-            } else {\n-                (required, \"\")\n-            };\n \n-            let mut potential_assoc_types: Option<Vec<Span>> = None;\n-            let (spans, label) = if required == permitted && provided > permitted {\n-                // In the case when the user has provided too many arguments,\n-                // we want to point to the unexpected arguments.\n-                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                    .iter()\n-                    .map(|arg| arg.span())\n-                    .collect();\n-                potential_assoc_types = Some(spans.clone());\n-                (spans, format!(\"unexpected {} argument\", kind))\n-            } else {\n-                (\n-                    vec![span],\n-                    format!(\n-                        \"expected {}{} {} argument{}\",\n-                        quantifier,\n-                        bound,\n-                        kind,\n-                        pluralize!(bound),\n+                // Unfortunately lifetime and type parameter mismatches are typically styled\n+                // differently in diagnostics, which means we have a few cases to consider here.\n+                let (bound, quantifier) = if required != permitted {\n+                    if provided < required {\n+                        (required, \"at least \")\n+                    } else {\n+                        // provided > permitted\n+                        (permitted, \"at most \")\n+                    }\n+                } else {\n+                    (required, \"\")\n+                };\n+\n+                let (spans, label) = if required == permitted && provided > permitted {\n+                    // In the case when the user has provided too many arguments,\n+                    // we want to point to the unexpected arguments.\n+                    let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                        .iter()\n+                        .map(|arg| arg.span())\n+                        .collect();\n+                    unexpected_spans.extend(spans.clone());\n+                    (spans, format!(\"unexpected {} argument\", kind))\n+                } else {\n+                    (\n+                        vec![span],\n+                        format!(\n+                            \"expected {}{} {} argument{}\",\n+                            quantifier,\n+                            bound,\n+                            kind,\n+                            pluralize!(bound),\n+                        ),\n+                    )\n+                };\n+\n+                let mut err = tcx.sess.struct_span_err_with_code(\n+                    spans.clone(),\n+                    &format!(\n+                        \"wrong number of {} arguments: expected {}{}, found {}\",\n+                        kind, quantifier, bound, provided,\n                     ),\n-                )\n-            };\n+                    DiagnosticId::Error(\"E0107\".into()),\n+                );\n+                for span in spans {\n+                    err.span_label(span, label.as_str());\n+                }\n+                err.emit();\n \n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                spans.clone(),\n-                &format!(\n-                    \"wrong number of {} arguments: expected {}{}, found {}\",\n-                    kind, quantifier, bound, provided,\n-                ),\n-                DiagnosticId::Error(\"E0107\".into()),\n-            );\n-            for span in spans {\n-                err.span_label(span, label.as_str());\n-            }\n-            err.emit();\n+                Err(true)\n+            };\n \n-            (\n-                provided > required, // `suppress_error`\n-                potential_assoc_types,\n-            )\n-        };\n+        let mut arg_count_correct = explicit_lifetimes;\n+        let mut unexpected_spans = vec![];\n \n-        if reported_late_bound_region_err.is_none()\n+        if arg_count_correct.is_ok()\n             && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes)\n         {\n-            check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n                 arg_counts.lifetimes,\n                 0,\n-            );\n+                &mut unexpected_spans,\n+            )\n+            .and(arg_count_correct);\n         }\n         // FIXME(const_generics:defaults)\n         if !infer_args || arg_counts.consts > param_counts.consts {\n-            check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"const\",\n                 param_counts.consts,\n                 param_counts.consts,\n                 arg_counts.consts,\n                 arg_counts.lifetimes + arg_counts.types,\n-            );\n+                &mut unexpected_spans,\n+            )\n+            .and(arg_count_correct);\n         }\n         // Note that type errors are currently be emitted *after* const errors.\n         if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n         {\n-            check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"type\",\n                 param_counts.types - defaults.types - has_self as usize,\n                 param_counts.types - has_self as usize,\n                 arg_counts.types,\n                 arg_counts.lifetimes,\n+                &mut unexpected_spans,\n             )\n-        } else {\n-            (reported_late_bound_region_err.unwrap_or(false), None)\n+            .and(arg_count_correct);\n         }\n+\n+        arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+            reported: if reported_err { Some(ErrorReported) } else { None },\n+            invalid_args: unexpected_spans,\n+        })\n+    }\n+\n+    /// Report an error that a generic argument did not match the generic parameter that was\n+    /// expected.\n+    fn generic_arg_mismatch_err(sess: &Session, arg: &GenericArg<'_>, kind: &'static str) {\n+        let mut err = struct_span_err!(\n+            sess,\n+            arg.span(),\n+            E0747,\n+            \"{} provided when a {} was expected\",\n+            arg.descr(),\n+            kind,\n+        );\n+        // This note will be true as long as generic parameters are strictly ordered by their kind.\n+        err.note(&format!(\"{} arguments must be provided before {} arguments\", kind, arg.descr()));\n+        err.emit();\n     }\n \n     /// Creates the relevant generic argument substitutions\n@@ -479,6 +512,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n+        arg_count_correct: bool,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n         provided_kind: impl Fn(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n@@ -502,7 +536,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // methods in `subst.rs`, so that we can iterate over the arguments and\n         // parameters in lock-step linearly, instead of trying to match each pair.\n         let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-\n         // Iterate over each segment of the path.\n         while let Some((def_id, defs)) = stack.pop() {\n             let mut params = defs.params.iter().peekable();\n@@ -539,6 +572,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let mut args =\n                 generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n \n+            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+            // If we later encounter a lifetime, we know that the arguments were provided in the\n+            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+            // inferred, so we can use it for diagnostics later.\n+            let mut force_infer_lt = None;\n+\n             loop {\n                 // We're going to iterate through the generic arguments that the user\n                 // provided, matching them with the generic parameters we expect.\n@@ -559,30 +598,58 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n                                 substs.push(inferred_kind(None, param, infer_args));\n+                                force_infer_lt = Some(arg);\n                                 params.next();\n                             }\n-                            (_, _) => {\n+                            (_, kind) => {\n                                 // We expected one kind of parameter, but the user provided\n-                                // another. This is an error, but we need to handle it\n-                                // gracefully so we can report sensible errors.\n-                                // In this case, we're simply going to infer this argument.\n-                                args.next();\n+                                // another. This is an error. However, if we already know that\n+                                // the arguments don't match up with the parameters, we won't issue\n+                                // an additional error, as the user already knows what's wrong.\n+                                if arg_count_correct {\n+                                    Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n+                                }\n+\n+                                // We've reported the error, but we want to make sure that this\n+                                // problem doesn't bubble down and create additional, irrelevant\n+                                // errors. In this case, we're simply going to ignore the argument\n+                                // and any following arguments. The rest of the parameters will be\n+                                // inferred.\n+                                while args.next().is_some() {}\n                             }\n                         }\n                     }\n-                    (Some(_), None) => {\n+\n+                    (Some(&arg), None) => {\n                         // We should never be able to reach this point with well-formed input.\n-                        // Getting to this point means the user supplied more arguments than\n-                        // there are parameters.\n-                        args.next();\n+                        // There are two situations in which we can encounter this issue.\n+                        //\n+                        //  1.  The number of arguments is incorrect. In this case, an error\n+                        //      will already have been emitted, and we can ignore it. This case\n+                        //      also occurs when late-bound lifetime parameters are present, yet\n+                        //      the lifetime arguments have also been explicitly specified by the\n+                        //      user.\n+                        //  2.  We've inferred some lifetimes, which have been provided later (i.e.\n+                        //      after a type or const). We want to throw an error in this case.\n+\n+                        if arg_count_correct {\n+                            let kind = arg.descr();\n+                            assert_eq!(kind, \"lifetime\");\n+                            let provided =\n+                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind);\n+                        }\n+\n+                        break;\n                     }\n+\n                     (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n                         substs.push(inferred_kind(Some(&substs), param, infer_args));\n-                        args.next();\n                         params.next();\n                     }\n+\n                     (None, None) => break,\n                 }\n             }\n@@ -630,7 +697,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n+    {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n@@ -656,7 +724,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none() && parent_substs.is_empty());\n         }\n \n-        let (_, potential_assoc_types) = Self::check_generic_arg_count(\n+        let arg_count_correct = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n@@ -689,8 +757,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n+            arg_count_correct.is_ok(),\n             // Provide the generic args, and whether types should be inferred.\n-            |_| (Some(generic_args), infer_args),\n+            |did| {\n+                if did == def_id {\n+                    (Some(generic_args), infer_args)\n+                } else {\n+                    // The last component of this tuple is unimportant.\n+                    (None, false)\n+                }\n+            },\n             // Provide substitutions for parameters for which (valid) arguments have been provided.\n             |param, arg| match (&param.kind, arg) {\n                 (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n@@ -794,7 +870,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_params, self_ty, substs\n         );\n \n-        (substs, assoc_bindings, potential_assoc_types)\n+        (substs, assoc_bindings, arg_count_correct)\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -925,7 +1001,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> Option<Vec<Span>> {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -942,7 +1018,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         } else {\n             trait_ref.path.span\n         };\n-        let (substs, assoc_bindings, potential_assoc_types) = self.create_substs_for_ast_trait_ref(\n+        let (substs, assoc_bindings, arg_count_correct) = self.create_substs_for_ast_trait_ref(\n             path_span,\n             trait_def_id,\n             self_ty,\n@@ -971,7 +1047,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             \"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n             trait_ref, bounds, poly_trait_ref\n         );\n-        potential_assoc_types\n+\n+        arg_count_correct\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -999,7 +1076,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n-    ) -> Option<Vec<Span>> {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n@@ -1088,7 +1165,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n+    {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n@@ -1433,13 +1511,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         for trait_bound in trait_bounds.iter().rev() {\n-            let cur_potential_assoc_types = self.instantiate_poly_trait_ref(\n+            if let Err(GenericArgCountMismatch {\n+                invalid_args: cur_potential_assoc_types, ..\n+            }) = self.instantiate_poly_trait_ref(\n                 trait_bound,\n                 Constness::NotConst,\n                 dummy_self,\n                 &mut bounds,\n-            );\n-            potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n+            ) {\n+                potential_assoc_types.extend(cur_potential_assoc_types.into_iter());\n+            }\n         }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait"}, {"sha": "108affe5a86c0161fcff0f0f95a383e270e97afc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n-        AstConv::check_generic_arg_count_for_call(\n+        let arg_count_correct = AstConv::check_generic_arg_count_for_call(\n             self.tcx, self.span, &generics, &seg, true, // `is_method_call`\n         );\n \n@@ -313,10 +313,16 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n+            arg_count_correct.is_ok(),\n             // Provide the generic args, and whether types should be inferred.\n-            |_| {\n-                // The last argument of the returned tuple here is unimportant.\n-                if let Some(ref data) = seg.args { (Some(data), false) } else { (None, false) }\n+            |def_id| {\n+                // The last component of the returned tuple here is unimportant.\n+                if def_id == pick.item.def_id {\n+                    if let Some(ref data) = seg.args {\n+                        return (Some(data), false);\n+                    }\n+                }\n+                (None, false)\n             },\n             // Provide substitutions for parameters for which (valid) arguments have been provided.\n             |param, arg| match (&param.kind, arg) {"}, {"sha": "3c71e8bf6b8fa720798d70ba9c1ccdaf66dcaf91", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -87,7 +87,7 @@ mod upvar;\n mod wfcheck;\n pub mod writeback;\n \n-use crate::astconv::{AstConv, PathSeg};\n+use crate::astconv::{AstConv, GenericArgCountMismatch, PathSeg};\n use crate::middle::lang_items;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n@@ -5431,10 +5431,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            let suppress_errors = AstConv::check_generic_arg_count_for_call(\n-                tcx, span, &generics, &seg, false, // `is_method_call`\n-            );\n-            if suppress_errors {\n+            if let Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }) =\n+                AstConv::check_generic_arg_count_for_call(\n+                    tcx, span, &generics, &seg, false, // `is_method_call`\n+                )\n+            {\n                 infer_args_for_err.insert(index);\n                 self.set_tainted_by_errors(); // See issue #53251.\n             }\n@@ -5499,6 +5500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &[][..],\n                 has_self,\n                 self_ty,\n+                infer_args_for_err.is_empty(),\n                 // Provide the generic args, and whether types should be inferred.\n                 |def_id| {\n                     if let Some(&PathSeg(_, index)) ="}, {"sha": "1fade1b5ca65e31a1683ca29d113ee0621098ee1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1270,7 +1270,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n-    // Now create the real type parameters.\n+    // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n     params.extend(ast_generics.params.iter().filter_map(|param| {"}, {"sha": "f024eb6a957e374c93b0e9e5fa8802001a2cc77e", "filename": "src/test/ui/const-generics/const-arg-type-arg-misordered.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -0,0 +1,10 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+type Array<T, const N: usize> = [T; N];\n+\n+fn foo<const N: usize>() -> Array<N, ()> { //~ ERROR constant provided when a type was expected\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "150a6011c2c13bc8171a8daadceef8cbe38bf47f", "filename": "src/test/ui/const-generics/const-arg-type-arg-misordered.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-type-arg-misordered.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/const-arg-type-arg-misordered.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0747]: constant provided when a type was expected\n+  --> $DIR/const-arg-type-arg-misordered.rs:6:35\n+   |\n+LL | fn foo<const N: usize>() -> Array<N, ()> {\n+   |                                   ^\n+   |\n+   = note: type arguments must be provided before constant arguments\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "19c4120eb2f148eb24dda3e0f8227b26cf8f3474", "filename": "src/test/ui/const-generics/const-param-after-const-literal-arg.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-after-const-literal-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-after-const-literal-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-after-const-literal-arg.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(const_generics)]\n+\n+struct Foo<const A: usize, const B: usize>;\n+\n+impl<const A: usize> Foo<1, A> {} // ok\n+\n+fn main() {}"}, {"sha": "756e961ce914f9009c2c2c5883ed4ad3d7951372", "filename": "src/test/ui/const-generics/const-param-before-other-params.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1,3 +1,4 @@\n+#![allow(incomplete_features)]\n #![feature(const_generics)]\n \n fn bar<const X: (), 'a>(_: &'a ()) {"}, {"sha": "9b18b8c79edda7b50a79597c7a2ca3f3c0f950ca", "filename": "src/test/ui/const-generics/const-param-before-other-params.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1,11 +1,11 @@\n error: lifetime parameters must be declared prior to const parameters\n-  --> $DIR/const-param-before-other-params.rs:3:21\n+  --> $DIR/const-param-before-other-params.rs:4:21\n    |\n LL | fn bar<const X: (), 'a>(_: &'a ()) {\n    |       --------------^^- help: reorder the parameters: lifetimes, then types, then consts: `<'a, const X: ()>`\n \n error: type parameters must be declared prior to const parameters\n-  --> $DIR/const-param-before-other-params.rs:7:21\n+  --> $DIR/const-param-before-other-params.rs:8:21\n    |\n LL | fn foo<const X: (), T>(_: &T) {\n    |       --------------^- help: reorder the parameters: lifetimes, then types, then consts: `<T, const X: ()>`"}, {"sha": "3e5e2e601f5c46a72df440926644177dd906ffbd", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -4,7 +4,6 @@ struct Bar<'a>(&'a ());\n \n fn main() {\n     Foo::<'static, 'static, ()>(&0); //~ ERROR wrong number of lifetime arguments\n-    //~^ ERROR mismatched types\n \n     Bar::<'static, 'static, ()>(&()); //~ ERROR wrong number of lifetime arguments\n     //~^ ERROR wrong number of type arguments"}, {"sha": "99adb3526852710af8efae52b2af5e006124f406", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -4,28 +4,18 @@ error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n LL |     Foo::<'static, 'static, ()>(&0);\n    |                    ^^^^^^^ unexpected lifetime argument\n \n-error[E0308]: mismatched types\n-  --> $DIR/generic-arg-mismatch-recover.rs:6:33\n-   |\n-LL |     Foo::<'static, 'static, ()>(&0);\n-   |                                 ^^ expected `()`, found integer\n-   |\n-   = note: expected reference `&'static ()`\n-              found reference `&{integer}`\n-\n error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n-  --> $DIR/generic-arg-mismatch-recover.rs:9:20\n+  --> $DIR/generic-arg-mismatch-recover.rs:8:20\n    |\n LL |     Bar::<'static, 'static, ()>(&());\n    |                    ^^^^^^^ unexpected lifetime argument\n \n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/generic-arg-mismatch-recover.rs:9:29\n+  --> $DIR/generic-arg-mismatch-recover.rs:8:29\n    |\n LL |     Bar::<'static, 'static, ()>(&());\n    |                             ^^ unexpected type argument\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0107, E0308.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "46ece84d69e457ae97084e56f27a9c9785f50694", "filename": "src/test/ui/parser/issue-14303-fncall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -11,7 +11,7 @@ fn foo<'a, 'b>(start: &'a usize, end: &'a usize) {\n     let _x = (*start..*end)\n         .map(|x| S { a: start, b: end })\n         .collect::<Vec<S<_, 'a>>>();\n-        //~^ ERROR lifetime arguments must be declared prior to type arguments\n+        //~^ ERROR type provided when a lifetime was expected\n }\n \n fn main() {}"}, {"sha": "109542237130a19c36ed4d75a0dcb3d176cb6467", "filename": "src/test/ui/parser/issue-14303-fncall.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-fncall.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1,8 +1,11 @@\n-error: lifetime arguments must be declared prior to type arguments\n-  --> $DIR/issue-14303-fncall.rs:13:29\n+error[E0747]: type provided when a lifetime was expected\n+  --> $DIR/issue-14303-fncall.rs:13:26\n    |\n LL |         .collect::<Vec<S<_, 'a>>>();\n-   |                             ^^\n+   |                          ^\n+   |\n+   = note: lifetime arguments must be provided before type arguments\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "89ef914aba238a7871241e1ccf7b860c87f7460e", "filename": "src/test/ui/parser/issue-14303-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -8,6 +8,6 @@ mod foo {\n }\n \n fn bar<'a, 'b, 'c, T>(x: foo::X<'a, T, 'b, 'c>) {}\n-//~^ ERROR lifetime arguments must be declared prior to type arguments\n+//~^ ERROR type provided when a lifetime was expected\n \n fn main() {}"}, {"sha": "c1ad2332b5bfa8b21b3e0d614079906c225c650b", "filename": "src/test/ui/parser/issue-14303-path.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-14303-path.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1,8 +1,11 @@\n-error: lifetime arguments must be declared prior to type arguments\n-  --> $DIR/issue-14303-path.rs:10:40\n+error[E0747]: type provided when a lifetime was expected\n+  --> $DIR/issue-14303-path.rs:10:37\n    |\n LL | fn bar<'a, 'b, 'c, T>(x: foo::X<'a, T, 'b, 'c>) {}\n-   |                                        ^^  ^^\n+   |                                     ^\n+   |\n+   = note: lifetime arguments must be provided before type arguments\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "6505a97de6e4bfcbb8c556fd01d9476b133e0be5", "filename": "src/test/ui/suggestions/suggest-move-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -33,7 +33,7 @@ struct A<T, M: One<A=(), T>> { //~ ERROR associated type bindings must be declar\n \n struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n //~^ ERROR associated type bindings must be declared after generic parameters\n-//~^^ ERROR lifetime arguments must be declared prior to type arguments\n+//~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n }\n@@ -47,7 +47,7 @@ struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> { //~ ERROR associated ty\n \n struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n //~^ ERROR associated type bindings must be declared after generic parameters\n-//~^^ ERROR lifetime arguments must be declared prior to type arguments\n+//~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n@@ -63,7 +63,7 @@ struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> { //~ ERROR associated ty\n \n struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n //~^ ERROR associated type bindings must be declared after generic parameters\n-//~^^ ERROR lifetime arguments must be declared prior to type arguments\n+//~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n@@ -79,7 +79,7 @@ struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> { //~ ERROR associated ty\n \n struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n //~^ ERROR associated type bindings must be declared after generic parameters\n-//~^^ ERROR lifetime arguments must be declared prior to type arguments\n+//~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,"}, {"sha": "ac91813f928396bcd5f9b7da113d02464b009520", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -74,29 +74,38 @@ LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, '\n    |                                                            |     this associated type binding should be moved after the generic parameters\n    |                                                            this associated type binding should be moved after the generic parameters\n \n-error: lifetime arguments must be declared prior to type arguments\n-  --> $DIR/suggest-move-types.rs:34:46\n+error[E0747]: type provided when a lifetime was expected\n+  --> $DIR/suggest-move-types.rs:34:43\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n-   |                                              ^^\n+   |                                           ^\n+   |\n+   = note: lifetime arguments must be provided before type arguments\n \n-error: lifetime arguments must be declared prior to type arguments\n-  --> $DIR/suggest-move-types.rs:48:80\n+error[E0747]: type provided when a lifetime was expected\n+  --> $DIR/suggest-move-types.rs:48:71\n    |\n LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n-   |                                                                                ^^  ^^  ^^\n+   |                                                                       ^\n+   |\n+   = note: lifetime arguments must be provided before type arguments\n \n-error: lifetime arguments must be declared prior to type arguments\n+error[E0747]: lifetime provided when a type was expected\n   --> $DIR/suggest-move-types.rs:64:56\n    |\n LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n-   |                                                        ^^                       ^^     ^^\n+   |                                                        ^^\n+   |\n+   = note: type arguments must be provided before lifetime arguments\n \n-error: lifetime arguments must be declared prior to type arguments\n+error[E0747]: lifetime provided when a type was expected\n   --> $DIR/suggest-move-types.rs:80:56\n    |\n LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n-   |                                                        ^^                 ^^           ^^\n+   |                                                        ^^\n+   |\n+   = note: type arguments must be provided before lifetime arguments\n \n error: aborting due to 12 previous errors\n \n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "e885cd2f68ac5bbed55e1ced305c729cd34ef060", "filename": "src/test/ui/traits/trait-object-vs-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.rs?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -12,6 +12,6 @@ fn main() {\n     //~^ ERROR wrong number of lifetime arguments: expected 1, found 2\n     //~| ERROR wrong number of type arguments: expected 1, found 0\n     let _: S<dyn 'static +, 'static>;\n-    //~^ ERROR lifetime arguments must be declared prior to type arguments\n+    //~^ ERROR type provided when a lifetime was expected\n     //~| ERROR at least one trait is required for an object type\n }"}, {"sha": "04529fb8cfab3caa1e61ddf2519acd2d91a55be3", "filename": "src/test/ui/traits/trait-object-vs-lifetime.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d69caba110c0c2fb90180df1cbc8be5033b91d4/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-vs-lifetime.stderr?ref=6d69caba110c0c2fb90180df1cbc8be5033b91d4", "patch": "@@ -1,9 +1,3 @@\n-error: lifetime arguments must be declared prior to type arguments\n-  --> $DIR/trait-object-vs-lifetime.rs:14:29\n-   |\n-LL |     let _: S<dyn 'static +, 'static>;\n-   |                             ^^^^^^^\n-\n error[E0224]: at least one trait is required for an object type\n   --> $DIR/trait-object-vs-lifetime.rs:9:23\n    |\n@@ -28,6 +22,15 @@ error[E0224]: at least one trait is required for an object type\n LL |     let _: S<dyn 'static +, 'static>;\n    |              ^^^^^^^^^^^^^\n \n+error[E0747]: type provided when a lifetime was expected\n+  --> $DIR/trait-object-vs-lifetime.rs:14:14\n+   |\n+LL |     let _: S<dyn 'static +, 'static>;\n+   |              ^^^^^^^^^^^^^\n+   |\n+   = note: lifetime arguments must be provided before type arguments\n+\n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0107`.\n+Some errors have detailed explanations: E0107, E0747.\n+For more information about an error, try `rustc --explain E0107`."}]}