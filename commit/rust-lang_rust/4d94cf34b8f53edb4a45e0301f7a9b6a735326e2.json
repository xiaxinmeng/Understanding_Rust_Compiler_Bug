{"sha": "4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "node_id": "C_kwDOAAsO6NoAKDRkOTRjZjM0YjhmNTNlZGI0YTQ1ZTAzMDFmN2E5YjZhNzM1MzI2ZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-10T14:55:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-10T14:55:59Z"}, "message": "Auto merge of #12208 - jonas-schievink:assoc-ty-signature-info, r=jonas-schievink\n\nfeat: include associated types in trait signature help\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12141\n\n![screenshot-2022-05-10-16:55:19](https://user-images.githubusercontent.com/1786438/167658642-8df42fba-523a-46fe-a0f6-e0e041b3659d.png)", "tree": {"sha": "918da9cc1139362160a02a7cb2cbe9f1704792dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918da9cc1139362160a02a7cb2cbe9f1704792dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "html_url": "https://github.com/rust-lang/rust/commit/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "254bfdd2c3794e2319330e39aacbf8609d539496", "url": "https://api.github.com/repos/rust-lang/rust/commits/254bfdd2c3794e2319330e39aacbf8609d539496", "html_url": "https://github.com/rust-lang/rust/commit/254bfdd2c3794e2319330e39aacbf8609d539496"}, {"sha": "ac3c18bc17eddb62aab0abf9c7c6dea9d17dd0b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac3c18bc17eddb62aab0abf9c7c6dea9d17dd0b1", "html_url": "https://github.com/rust-lang/rust/commit/ac3c18bc17eddb62aab0abf9c7c6dea9d17dd0b1"}], "stats": {"total": 182, "additions": 177, "deletions": 5}, "files": [{"sha": "32e7c59b2a5a1d8ea74af237e048f1024cc7b04e", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 176, "deletions": 4, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "patch": "@@ -1,8 +1,10 @@\n //! This module provides primitives for showing type and function parameter information when editing\n //! a call or use-site.\n \n+use std::collections::BTreeSet;\n+\n use either::Either;\n-use hir::{GenericParam, HasAttrs, HirDisplay, Semantics};\n+use hir::{AssocItem, GenericParam, HasAttrs, HirDisplay, Semantics, Trait};\n use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n use stdx::format_to;\n use syntax::{\n@@ -316,11 +318,52 @@ fn signature_help_for_generics(\n         format_to!(buf, \"{}\", param.display(db));\n         res.push_generic_param(&buf);\n     }\n+    if let hir::GenericDef::Trait(tr) = generics_def {\n+        add_assoc_type_bindings(db, &mut res, tr, arg_list);\n+    }\n     res.signature.push('>');\n \n     Some(res)\n }\n \n+fn add_assoc_type_bindings(\n+    db: &RootDatabase,\n+    res: &mut SignatureHelp,\n+    tr: Trait,\n+    args: ast::GenericArgList,\n+) {\n+    if args.syntax().ancestors().find_map(ast::TypeBound::cast).is_none() {\n+        // Assoc type bindings are only valid in type bound position.\n+        return;\n+    }\n+\n+    let present_bindings = args\n+        .generic_args()\n+        .filter_map(|arg| match arg {\n+            ast::GenericArg::AssocTypeArg(arg) => arg.name_ref().map(|n| n.to_string()),\n+            _ => None,\n+        })\n+        .collect::<BTreeSet<_>>();\n+\n+    let mut buf = String::new();\n+    for binding in &present_bindings {\n+        buf.clear();\n+        format_to!(buf, \"{} = \u2026\", binding);\n+        res.push_generic_param(&buf);\n+    }\n+\n+    for item in tr.items_with_supertraits(db) {\n+        if let AssocItem::TypeAlias(ty) = item {\n+            let name = ty.name(db).to_smol_str();\n+            if !present_bindings.contains(&*name) {\n+                buf.clear();\n+                format_to!(buf, \"{} = \u2026\", name);\n+                res.push_generic_param(&buf);\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -368,10 +411,11 @@ mod tests {\n                         panic!(\"parameter ranges out of order: {:?}\", sig_help.parameter_ranges())\n                     });\n                     rendered.extend(iter::repeat(' ').take(gap as usize));\n-                    let width = u32::from(range.end() - range.start());\n+                    let param_text = &sig_help.signature[*range];\n+                    let width = param_text.chars().count(); // \u2026\n                     let marker = if is_active { '^' } else { '-' };\n-                    rendered.extend(iter::repeat(marker).take(width as usize));\n-                    offset += gap + width;\n+                    rendered.extend(iter::repeat(marker).take(width));\n+                    offset += gap + u32::from(range.len());\n                 }\n                 if !sig_help.parameter_ranges().is_empty() {\n                     format_to!(rendered, \"\\n\");\n@@ -1124,6 +1168,134 @@ fn f() {\n         );\n     }\n \n+    #[test]\n+    fn test_trait_assoc_types() {\n+        check(\n+            r#\"\n+trait Trait<'a, T> {\n+    type Assoc;\n+}\n+fn f() -> impl Trait<(), $0\n+            \"#,\n+            expect![[r#\"\n+                trait Trait<'a, T, Assoc = \u2026>\n+                            --  -  ^^^^^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Iterator {\n+    type Item;\n+}\n+fn f() -> impl Iterator<$0\n+            \"#,\n+            expect![[r#\"\n+                trait Iterator<Item = \u2026>\n+                               ^^^^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Iterator {\n+    type Item;\n+}\n+fn f() -> impl Iterator<Item = $0\n+            \"#,\n+            expect![[r#\"\n+                trait Iterator<Item = \u2026>\n+                               ^^^^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    type A;\n+    type B;\n+}\n+fn f() -> impl Tr<$0\n+            \"#,\n+            expect![[r#\"\n+                trait Tr<A = \u2026, B = \u2026>\n+                         ^^^^^  -----\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    type A;\n+    type B;\n+}\n+fn f() -> impl Tr<B$0\n+            \"#,\n+            expect![[r#\"\n+                trait Tr<A = \u2026, B = \u2026>\n+                         ^^^^^  -----\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    type A;\n+    type B;\n+}\n+fn f() -> impl Tr<B = $0\n+            \"#,\n+            expect![[r#\"\n+                trait Tr<B = \u2026, A = \u2026>\n+                         ^^^^^  -----\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    type A;\n+    type B;\n+}\n+fn f() -> impl Tr<B = (), $0\n+            \"#,\n+            expect![[r#\"\n+                trait Tr<B = \u2026, A = \u2026>\n+                         -----  ^^^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_supertrait_assoc() {\n+        check(\n+            r#\"\n+trait Super {\n+    type SuperTy;\n+}\n+trait Sub: Super + Super {\n+    type SubTy;\n+}\n+fn f() -> impl Sub<$0\n+            \"#,\n+            expect![[r#\"\n+                trait Sub<SubTy = \u2026, SuperTy = \u2026>\n+                          ^^^^^^^^^  -----------\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn no_assoc_types_outside_type_bounds() {\n+        check(\n+            r#\"\n+trait Tr<T> {\n+    type Assoc;\n+}\n+\n+impl Tr<$0\n+        \"#,\n+            expect![[r#\"\n+            trait Tr<T>\n+                     ^\n+        \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn impl_trait() {\n         // FIXME: Substitute type vars in impl trait (`U` -> `i8`)"}, {"sha": "ea4ca5d82e59af8f7d4afb5016882e75f2f56ab3", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d94cf34b8f53edb4a45e0301f7a9b6a735326e2/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=4d94cf34b8f53edb4a45e0301f7a9b6a735326e2", "patch": "@@ -341,7 +341,7 @@ pub(crate) fn signature_help(\n     config: CallInfoConfig,\n     label_offsets: bool,\n ) -> lsp_types::SignatureHelp {\n-    let (label, parameters) = match (!config.params_only, label_offsets) {\n+    let (label, parameters) = match (config.params_only, label_offsets) {\n         (concise, false) => {\n             let params = call_info\n                 .parameter_labels()"}]}