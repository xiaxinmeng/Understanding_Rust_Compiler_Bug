{"sha": "7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOWIwMWEwZmM2ODA5NDNhNWMzN2VlODIwYWUzZmJkNmFiYzQwZjY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-22T07:46:29Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-07-04T21:36:07Z"}, "message": "Add miri infinite loop detection\n\nUse the approach suggested by @oli-obk, a table holding `EvalState`\nhashes and a table holding full `EvalState` objects. When a hash\ncollision is observed, the state is cloned and put into the full\ntable. If the collision was not spurious, it will be detected during the\nnext iteration of the infinite loop.", "tree": {"sha": "72b412453e3fe498bdcc77802bfc064507cfffd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b412453e3fe498bdcc77802bfc064507cfffd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "html_url": "https://github.com/rust-lang/rust/commit/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c0f502fe6bb54b285d66850ca8171e0c98091b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0f502fe6bb54b285d66850ca8171e0c98091b0", "html_url": "https://github.com/rust-lang/rust/commit/6c0f502fe6bb54b285d66850ca8171e0c98091b0"}], "stats": {"total": 85, "additions": 71, "deletions": 14}, "files": [{"sha": "4699444bd424907d9a4c2575cbee663f2b219ba7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "patch": "@@ -10,6 +10,7 @@ use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf,\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::query::TyCtxtAt;\n+use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::mir::interpret::{\n     FrameInfo, GlobalId, Value, Scalar,\n@@ -34,15 +35,16 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// Virtual memory and call stack.\n-    state: EvalState<'a, 'mir, 'tcx, M>,\n+    pub(crate) state: EvalState<'a, 'mir, 'tcx, M>,\n \n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n \n-    /// The maximum number of terminators that may be evaluated.\n-    /// This prevents infinite loops and huge computations from freezing up const eval.\n-    /// Remove once halting problem is solved.\n-    pub(crate) terminators_remaining: usize,\n+    /// The number of terminators to be evaluated before enabling the infinite\n+    /// loop detector.\n+    pub(crate) steps_until_detector_enabled: usize,\n+\n+    pub(crate) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n pub(crate) struct EvalState<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n@@ -178,6 +180,56 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    /// The set of all `EvalState` *hashes* observed by this detector.\n+    ///\n+    /// Not a proper bloom filter.\n+    bloom: FxHashSet<u64>,\n+\n+    /// The set of all `EvalState`s observed by this detector.\n+    ///\n+    /// An `EvalState` will only be fully cloned once it has caused a collision\n+    /// in `bloom`. As a result, the detector must observe *two* full cycles of\n+    /// an infinite loop before it triggers.\n+    snapshots: FxHashSet<EvalState<'a, 'mir, 'tcx, M>>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn default() -> Self {\n+        InfiniteLoopDetector {\n+            bloom: FxHashSet::default(),\n+            snapshots: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    pub fn observe(&mut self, snapshot: &EvalState<'a, 'mir, 'tcx, M>) -> Result<(), (/*TODO*/)> {\n+        let mut fx = FxHasher::default();\n+        snapshot.hash(&mut fx);\n+        let hash = fx.finish();\n+\n+        if self.bloom.insert(hash) {\n+            // No collision\n+            return Ok(())\n+        }\n+\n+        if self.snapshots.insert(snapshot.clone()) {\n+            // Spurious collision or first cycle\n+            return Ok(())\n+        }\n+\n+        // Second cycle,\n+        Err(())\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure it\n@@ -280,16 +332,17 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 stack: Vec::new(),\n             },\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n-            terminators_remaining: MAX_TERMINATORS,\n+            loop_detector: Default::default(),\n+            steps_until_detector_enabled: MAX_TERMINATORS,\n         }\n     }\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n         let stack = mem::replace(self.stack_mut(), Vec::new());\n-        let terminators_remaining = mem::replace(&mut self.terminators_remaining, MAX_TERMINATORS);\n+        let steps = mem::replace(&mut self.steps_until_detector_enabled, MAX_TERMINATORS);\n         let r = f(self);\n         *self.stack_mut() = stack;\n-        self.terminators_remaining = terminators_remaining;\n+        self.steps_until_detector_enabled = steps;\n         r\n     }\n \n@@ -634,7 +687,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                self.inc_step_counter_and_check_limit(operands.len());\n+                self.inc_step_counter_and_detect_loops(operands.len());\n \n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {"}, {"sha": "e8eabe2b1bf6ff36990ee13ad7f0830a4a271592", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "patch": "@@ -8,12 +8,16 @@ use rustc::mir::interpret::EvalResult;\n use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn inc_step_counter_and_check_limit(&mut self, n: usize) {\n-        self.terminators_remaining = self.terminators_remaining.saturating_sub(n);\n-        if self.terminators_remaining == 0 {\n+    pub fn inc_step_counter_and_detect_loops(&mut self, n: usize) {\n+        self.steps_until_detector_enabled\n+            = self.steps_until_detector_enabled.saturating_sub(n);\n+\n+        if self.steps_until_detector_enabled == 0 {\n+            let _ = self.loop_detector.observe(&self.state); // TODO: Handle error\n+\n             // FIXME(#49980): make this warning a lint\n             self.tcx.sess.span_warn(self.frame().span, \"Constant evaluating a complex constant, this might take some time\");\n-            self.terminators_remaining = 1_000_000;\n+            self.steps_until_detector_enabled = 1_000_000;\n         }\n     }\n \n@@ -36,7 +40,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return Ok(true);\n         }\n \n-        self.inc_step_counter_and_check_limit(1);\n+        self.inc_step_counter_and_detect_loops(1);\n \n         let terminator = basic_block.terminator();\n         assert_eq!(old_frames, self.cur_frame());"}]}