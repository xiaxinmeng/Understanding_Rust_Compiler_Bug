{"sha": "15ec8f7c521461bfa64729d859e64f5415ddb4fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZWM4ZjdjNTIxNDYxYmZhNjQ3MjlkODU5ZTY0ZjU0MTVkZGI0ZmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-02T16:46:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-08T08:20:30Z"}, "message": "rename Memory::get methods to get_raw to indicate their unchecked nature", "tree": {"sha": "5fc75a01fbd502cb61fa3afcfa72ffd76a778dfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fc75a01fbd502cb61fa3afcfa72ffd76a778dfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ec8f7c521461bfa64729d859e64f5415ddb4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ec8f7c521461bfa64729d859e64f5415ddb4fd", "html_url": "https://github.com/rust-lang/rust/commit/15ec8f7c521461bfa64729d859e64f5415ddb4fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ec8f7c521461bfa64729d859e64f5415ddb4fd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c34472b77084c9f76f872871aeab121daf81fb99", "url": "https://api.github.com/repos/rust-lang/rust/commits/c34472b77084c9f76f872871aeab121daf81fb99", "html_url": "https://github.com/rust-lang/rust/commit/c34472b77084c9f76f872871aeab121daf81fb99"}], "stats": {"total": 89, "additions": 46, "deletions": 43}, "files": [{"sha": "88bfcd63129fa9759fa27e9bab358e109438cc23", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -37,7 +37,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let col_out = self.force_ptr(self.mplace_field(location, 2)?.ptr)?;\n \n         let layout = &self.tcx.data_layout;\n-        let alloc = self.memory.get_mut(file_ptr_out.alloc_id)?;\n+        // We just allocated this, so we can skip the bounds checks.\n+        let alloc = self.memory.get_raw_mut(file_ptr_out.alloc_id)?;\n \n         alloc.write_scalar(layout, file_ptr_out, file.into(), ptr_size)?;\n         alloc.write_scalar(layout, file_len_out, file_len.into(), ptr_size)?;"}, {"sha": "6d4ef93aafafa37b12084bd393f70dc5cfc63131", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -210,7 +210,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind);\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => self.get(ptr.alloc_id)?.size,\n+            None => self.get_raw(ptr.alloc_id)?.size,\n         };\n         self.copy(\n             ptr,\n@@ -480,7 +480,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ).0)\n     }\n \n-    pub fn get(\n+    /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    pub fn get_raw(\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n@@ -513,7 +515,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_mut(\n+    /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n+    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCtx` instead!\n+    pub fn get_raw_mut(\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n@@ -555,7 +559,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n         // # Regular allocations\n-        // Don't use `self.get` here as that will\n+        // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n@@ -627,7 +631,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_mut(id)?.mutability = Mutability::Immutable;\n+        self.get_raw_mut(id)?.mutability = Mutability::Immutable;\n         Ok(())\n     }\n \n@@ -776,15 +780,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(ptr) => ptr,\n             None => return Ok(&[]), // zero-sized access\n         };\n-        self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n+        self.get_raw(ptr.alloc_id)?.get_bytes(self, ptr, size)\n     }\n \n     /// Reads a 0-terminated sequence of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n     pub fn read_c_str(&self, ptr: Scalar<M::PointerTag>) -> InterpResult<'tcx, &[u8]> {\n         let ptr = self.force_ptr(ptr)?; // We need to read at least 1 byte, so we *need* a ptr.\n-        self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n+        self.get_raw(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n     /// Writes the given stream of bytes into memory.\n@@ -804,7 +808,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             None => return Ok(()), // zero-sized access\n         };\n         let tcx = self.tcx.tcx;\n-        self.get_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+        self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n     /// Expects the caller to have checked bounds and alignment.\n@@ -832,16 +836,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = self.get(src.alloc_id)?\n+        let relocations = self.get_raw(src.alloc_id)?\n             .prepare_relocation_copy(self, src, size, dest, length);\n \n         let tcx = self.tcx.tcx;\n \n         // This checks relocation edges on the src.\n-        let src_bytes = self.get(src.alloc_id)?\n+        let src_bytes = self.get_raw(src.alloc_id)?\n             .get_bytes_with_undef_and_ptr(&tcx, src, size)?\n             .as_ptr();\n-        let dest_bytes = self.get_mut(dest.alloc_id)?\n+        let dest_bytes = self.get_raw_mut(dest.alloc_id)?\n             .get_bytes_mut(&tcx, dest, size * length)?\n             .as_mut_ptr();\n \n@@ -880,7 +884,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n         // copy the relocations to the destination\n-        self.get_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n+        self.get_raw_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n \n         Ok(())\n     }\n@@ -899,11 +903,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let src_alloc = self.get(src.alloc_id)?;\n+        let src_alloc = self.get_raw(src.alloc_id)?;\n         let compressed = src_alloc.compress_undef_range(src, size);\n \n         // now fill in all the data\n-        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+        let dest_allocation = self.get_raw_mut(dest.alloc_id)?;\n         dest_allocation.mark_compressed_undef_range(&compressed, dest, size, repeat);\n \n         Ok(())"}, {"sha": "79762b87b0a8502e9f6291e7fac4f7181ad125ce", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -248,7 +248,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(ImmTy {\n                     imm: scalar.into(),\n@@ -266,10 +266,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n                 let b_ptr = ptr.offset(b_offset, self)?;\n                 let a_val = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, a_ptr, a_size)?;\n                 let b_val = self.memory\n-                    .get(ptr.alloc_id)?\n+                    .get_raw(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n                 Ok(Some(ImmTy {\n                     imm: Immediate::ScalarPair(a_val, b_val),"}, {"sha": "04effc2ea2de60fd544f5e60fb97d575dedde1be", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -808,7 +808,7 @@ where\n                     _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                             dest.layout)\n                 }\n-                self.memory.get_mut(ptr.alloc_id)?.write_scalar(\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n                     tcx, ptr, scalar, dest.layout.size\n                 )\n             }\n@@ -830,10 +830,10 @@ where\n                 // fields do not match the `ScalarPair` components.\n \n                 self.memory\n-                    .get_mut(ptr.alloc_id)?\n+                    .get_raw_mut(ptr.alloc_id)?\n                     .write_scalar(tcx, ptr, a_val, a_size)?;\n                 self.memory\n-                    .get_mut(b_ptr.alloc_id)?\n+                    .get_raw_mut(b_ptr.alloc_id)?\n                     .write_scalar(tcx, b_ptr, b_val, b_size)\n             }\n         }"}, {"sha": "1df98f079cc104957575686d85cba453074f803d", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -392,7 +392,7 @@ impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n     for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n-        self.get(*id).ok()\n+        self.get_raw(*id).ok()\n     }\n }\n "}, {"sha": "e10bb85d52df8b97b29806e63d60d979562417ce", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -445,7 +445,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ptr_size,\n                     self.tcx.data_layout.pointer_align.abi,\n                 )?.expect(\"cannot be a ZST\");\n-                let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n+                let fn_ptr = self.memory.get_raw(vtable_slot.alloc_id)?\n                     .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n                 let drop_fn = self.memory.get_fn(fn_ptr)?;\n "}, {"sha": "c15425321ec0123a249ae2be1ce3c4a0ce2d8762", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -63,35 +63,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop = Instance::resolve_drop_in_place(*tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n-        // no need to do any alignment checks on the memory accesses below, because we know the\n+        // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n-        self.memory\n-            .get_mut(vtable.alloc_id)?\n-            .write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n-\n-        let size_ptr = vtable.offset(ptr_size, self)?;\n-        self.memory\n-            .get_mut(size_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, self)?;\n-        self.memory\n-            .get_mut(align_ptr.alloc_id)?\n-            .write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n+        vtable_alloc.write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n+\n+        let size_ptr = vtable.offset(ptr_size, tcx)?;\n+        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n+        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance = ty::Instance::resolve_for_vtable(\n-                    *self.tcx,\n+                    *tcx,\n                     self.param_env,\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n-                self.memory\n-                    .get_mut(method_ptr.alloc_id)?\n+                // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                self.memory.get_raw_mut(vtable.alloc_id)?\n                     .write_ptr_sized(tcx, method_ptr, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n@@ -114,7 +109,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.tcx.data_layout.pointer_align.abi,\n         )?.expect(\"cannot be a ZST\");\n         let drop_fn = self.memory\n-            .get(vtable.alloc_id)?\n+            .get_raw(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n             .not_undef()?;\n         // We *need* an instance here, no other kind of function value, to be able\n@@ -140,7 +135,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             3*pointer_size,\n             self.tcx.data_layout.pointer_align.abi,\n         )?.expect(\"cannot be a ZST\");\n-        let alloc = self.memory.get(vtable.alloc_id)?;\n+        let alloc = self.memory.get_raw(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size, self)?"}, {"sha": "dedccbaa3d7f4724620d77c4d8ffb2a5e2a7bbd7", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ec8f7c521461bfa64729d859e64f5415ddb4fd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=15ec8f7c521461bfa64729d859e64f5415ddb4fd", "patch": "@@ -586,6 +586,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     _ => false,\n                 }\n             } => {\n+                // Optimized handling for arrays of integer/float type.\n+\n                 // bailing out for zsts is ok, since the array element type can only be int/float\n                 if op.layout.is_zst() {\n                     return Ok(());\n@@ -605,6 +607,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // Size is not 0, get a pointer.\n                 let ptr = self.ecx.force_ptr(mplace.ptr)?;\n \n+                // This is the optimization: we just check the entire range at once.\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n@@ -614,7 +617,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept undef, for consistency with the slow path.\n-                match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n+                match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,\n                     size,"}]}