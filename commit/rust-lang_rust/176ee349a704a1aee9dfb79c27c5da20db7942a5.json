{"sha": "176ee349a704a1aee9dfb79c27c5da20db7942a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NmVlMzQ5YTcwNGExYWVlOWRmYjc5YzI3YzVkYTIwZGI3OTQyYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-30T12:27:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-30T12:27:10Z"}, "message": "Auto merge of #30542 - nrc:errs-base, r=nagisa\n\nAs discussed [here](https://internals.rust-lang.org/t/more-structured-errors/3005)\n\nr? @nikomatsakis or anyone else on the @rust-lang/compiler team", "tree": {"sha": "99e1ead256ccd196b4135455ef037b14ab3094fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99e1ead256ccd196b4135455ef037b14ab3094fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/176ee349a704a1aee9dfb79c27c5da20db7942a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/176ee349a704a1aee9dfb79c27c5da20db7942a5", "html_url": "https://github.com/rust-lang/rust/commit/176ee349a704a1aee9dfb79c27c5da20db7942a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/176ee349a704a1aee9dfb79c27c5da20db7942a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a06bb977d86dcfe786d4265f4807a11c39b51141", "url": "https://api.github.com/repos/rust-lang/rust/commits/a06bb977d86dcfe786d4265f4807a11c39b51141", "html_url": "https://github.com/rust-lang/rust/commit/a06bb977d86dcfe786d4265f4807a11c39b51141"}, {"sha": "04d972906d05e6c27452e1ae35970c30e7cf6e6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/04d972906d05e6c27452e1ae35970c30e7cf6e6b", "html_url": "https://github.com/rust-lang/rust/commit/04d972906d05e6c27452e1ae35970c30e7cf6e6b"}], "stats": {"total": 3770, "additions": 2253, "deletions": 1517}, "files": [{"sha": "464f29a33937f053c0ba9ae191b5b7ddd5667219", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 66, "deletions": 20, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -40,14 +40,14 @@ use std::mem;\n use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n+use syntax::errors::{self, DiagnosticBuilder};\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax::attr::ThinAttributesExt;\n use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n-use syntax::errors;\n \n /// Information about the registered lints.\n ///\n@@ -363,10 +363,24 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n /// in trans that run after the main lint pass is finished. Most\n /// lints elsewhere in the compiler should call\n /// `Session::add_lint()` instead.\n-pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n-                     lvlsrc: LevelSource, span: Option<Span>, msg: &str) {\n+pub fn raw_emit_lint(sess: &Session,\n+                     lint: &'static Lint,\n+                     lvlsrc: LevelSource,\n+                     span: Option<Span>,\n+                     msg: &str) {\n+    raw_struct_lint(sess, lint, lvlsrc, span, msg).emit();\n+}\n+\n+pub fn raw_struct_lint<'a>(sess: &'a Session,\n+                           lint: &'static Lint,\n+                           lvlsrc: LevelSource,\n+                           span: Option<Span>,\n+                           msg: &str)\n+                           -> DiagnosticBuilder<'a> {\n     let (mut level, source) = lvlsrc;\n-    if level == Allow { return }\n+    if level == Allow {\n+        return sess.diagnostic().struct_dummy();\n+    }\n \n     let name = lint.name_lower();\n     let mut def = None;\n@@ -391,17 +405,19 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     // For purposes of printing, we can treat forbid as deny.\n     if level == Forbid { level = Deny; }\n \n-    match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, &msg[..]),\n-        (Warn, None)     => sess.warn(&msg[..]),\n-        (Deny, Some(sp)) => sess.span_err(sp, &msg[..]),\n-        (Deny, None)     => sess.err(&msg[..]),\n+    let mut err = match (level, span) {\n+        (Warn, Some(sp)) => sess.struct_span_warn(sp, &msg[..]),\n+        (Warn, None)     => sess.struct_warn(&msg[..]),\n+        (Deny, Some(sp)) => sess.struct_span_err(sp, &msg[..]),\n+        (Deny, None)     => sess.struct_err(&msg[..]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n-    }\n+    };\n \n     if let Some(span) = def {\n-        sess.span_note(span, \"lint level defined here\");\n+        err.span_note(span, \"lint level defined here\");\n     }\n+\n+    err\n }\n \n pub trait LintContext: Sized {\n@@ -418,44 +434,74 @@ pub trait LintContext: Sized {\n         self.lints().levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n     }\n \n-    fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n-        let (level, src) = match self.lints().levels.get(&LintId::of(lint)) {\n-            None => return,\n-            Some(&(Warn, src)) => {\n+    fn level_src(&self, lint: &'static Lint) -> Option<LevelSource> {\n+        self.lints().levels.get(&LintId::of(lint)).map(|ls| match ls {\n+            &(Warn, src) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n                 (self.lints().get_level_source(lint_id).0, src)\n             }\n-            Some(&pair) => pair,\n+            _ => *ls\n+        })\n+    }\n+\n+    fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n+        let (level, src) = match self.level_src(lint) {\n+            None => return,\n+            Some(pair) => pair,\n         };\n \n         raw_emit_lint(&self.sess(), lint, (level, src), span, msg);\n     }\n \n+    fn lookup(&self,\n+              lint: &'static Lint,\n+              span: Option<Span>,\n+              msg: &str)\n+              -> DiagnosticBuilder {\n+        let (level, src) = match self.level_src(lint) {\n+            None => return self.sess().diagnostic().struct_dummy(),\n+            Some(pair) => pair,\n+        };\n+\n+        raw_struct_lint(&self.sess(), lint, (level, src), span, msg)\n+    }\n+\n     /// Emit a lint at the appropriate level, for a particular span.\n     fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n+    fn struct_span_lint(&self,\n+                        lint: &'static Lint,\n+                        span: Span,\n+                        msg: &str)\n+                        -> DiagnosticBuilder {\n+        self.lookup(lint, Some(span), msg)\n+    }\n+\n     /// Emit a lint and note at the appropriate level, for a particular span.\n     fn span_lint_note(&self, lint: &'static Lint, span: Span, msg: &str,\n                       note_span: Span, note: &str) {\n-        self.span_lint(lint, span, msg);\n+        let mut err = self.lookup(lint, Some(span), msg);\n         if self.current_level(lint) != Level::Allow {\n             if note_span == span {\n-                self.sess().fileline_note(note_span, note)\n+                err.fileline_note(note_span, note);\n             } else {\n-                self.sess().span_note(note_span, note)\n+                err.span_note(note_span, note);\n             }\n         }\n+        err.emit();\n     }\n \n     /// Emit a lint and help at the appropriate level, for a particular span.\n     fn span_lint_help(&self, lint: &'static Lint, span: Span,\n                       msg: &str, help: &str) {\n+        let mut err = self.lookup(lint, Some(span), msg);\n         self.span_lint(lint, span, msg);\n         if self.current_level(lint) != Level::Allow {\n-            self.sess().span_help(span, help)\n+            err.span_help(span, help);\n         }\n+        err.emit();\n     }\n \n     /// Emit a lint at the appropriate level, with no associated span."}, {"sha": "9c689daab86a797173f102cb47fe8f6ee3e8cebf", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -41,7 +41,7 @@ use rustc_front::hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        GatherNodeLevels};\n+                        raw_struct_lint, GatherNodeLevels};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "c2acd0e4795c9ae0f51cf34c281a318b34153804", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -224,14 +224,15 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                 // this doesn't come from a macro that has #[allow_internal_unstable]\n                 !self.tcx.sess.codemap().span_allows_unstable(expr.span)\n             {\n-                self.tcx.sess.span_err(\n+                let mut err = self.tcx.sess.struct_span_err(\n                     expr.span,\n                     \"const fns are an unstable feature\");\n                 fileline_help!(\n-                    self.tcx.sess,\n+                    &mut err,\n                     expr.span,\n                     \"in Nightly builds, add `#![feature(const_fn)]` to the crate \\\n                      attributes to enable\");\n+                err.emit();\n             }\n \n             let qualif = self.fn_like(fn_like.kind(),\n@@ -714,27 +715,27 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n-                    fn span_limited_call_error(tcx: &ty::ctxt, span: Span, s: &str) {\n-                        span_err!(tcx.sess, span, E0015, \"{}\", s);\n-                    }\n-\n                     // FIXME(#24111) Remove this check when const fn stabilizes\n-                    if let UnstableFeatures::Disallow = v.tcx.sess.opts.unstable_features {\n-                        span_limited_call_error(&v.tcx, e.span,\n-                                                &format!(\"function calls in {}s are limited to \\\n-                                                          struct and enum constructors\",\n-                                                         v.msg()));\n-                        v.tcx.sess.span_note(e.span,\n-                                             \"a limited form of compile-time function \\\n-                                              evaluation is available on a nightly \\\n-                                              compiler via `const fn`\");\n+                    let (msg, note) =\n+                        if let UnstableFeatures::Disallow = v.tcx.sess.opts.unstable_features {\n+                        (format!(\"function calls in {}s are limited to \\\n+                                  struct and enum constructors\",\n+                                 v.msg()),\n+                         Some(\"a limited form of compile-time function \\\n+                               evaluation is available on a nightly \\\n+                               compiler via `const fn`\"))\n                     } else {\n-                        span_limited_call_error(&v.tcx, e.span,\n-                                                &format!(\"function calls in {}s are limited \\\n-                                                          to constant functions, \\\n-                                                          struct and enum constructors\",\n-                                                         v.msg()));\n+                        (format!(\"function calls in {}s are limited \\\n+                                  to constant functions, \\\n+                                  struct and enum constructors\",\n+                                 v.msg()),\n+                         None)\n+                    };\n+                    let mut err = struct_span_err!(v.tcx.sess, e.span, E0015, \"{}\", msg);\n+                    if let Some(note) = note {\n+                        err.span_note(e.span, note);\n                     }\n+                    err.emit();\n                 }\n             }\n         }"}, {"sha": "8439b439d76498c65a2f0f62d6e5ad5d36fabca4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -215,12 +215,13 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n             if inlined_arms.is_empty() {\n                 if !pat_ty.is_empty(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n-                    span_err!(cx.tcx.sess, ex.span, E0002,\n-                              \"non-exhaustive patterns: type {} is non-empty\",\n-                              pat_ty);\n-                    span_help!(cx.tcx.sess, ex.span,\n+                    let mut err = struct_span_err!(cx.tcx.sess, ex.span, E0002,\n+                                                   \"non-exhaustive patterns: type {} is non-empty\",\n+                                                   pat_ty);\n+                    span_help!(&mut err, ex.span,\n                         \"Please ensure that all possible cases are being handled; \\\n                          possibly adding wildcards or more match arms.\");\n+                    err.emit();\n                 }\n                 // If the type *is* empty, it's vacuously exhaustive\n                 return;\n@@ -251,14 +252,15 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                                 && variant.kind() == VariantKind::Unit\n                         ) {\n                             let ty_path = cx.tcx.item_path_str(edef.did);\n-                            span_warn!(cx.tcx.sess, p.span, E0170,\n+                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n                                 ident.node, ty_path);\n-                            fileline_help!(cx.tcx.sess, p.span,\n+                            fileline_help!(err, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n                                 ty_path, ident.node);\n+                            err.emit();\n                         }\n                     }\n                 }\n@@ -282,13 +284,13 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n                 Ok(_) => {}\n \n                 Err(err) => {\n-                    span_err!(cx.tcx.sess, err.span, E0471,\n-                              \"constant evaluation error: {}\",\n-                              err.description());\n+                    let mut diag = struct_span_err!(cx.tcx.sess, err.span, E0471,\n+                                                    \"constant evaluation error: {}\",\n+                                                    err.description());\n                     if !p.span.contains(err.span) {\n-                        cx.tcx.sess.span_note(p.span,\n-                                              \"in pattern here\")\n+                        diag.span_note(p.span, \"in pattern here\");\n                     }\n+                    diag.emit();\n                 }\n             }\n         }\n@@ -1076,9 +1078,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n         } else if by_ref_span.is_some() {\n-            span_err!(cx.tcx.sess, p.span, E0009,\n-                \"cannot bind by-move and by-ref in the same pattern\");\n-            span_note!(cx.tcx.sess, by_ref_span.unwrap(), \"by-ref binding occurs here\");\n+            let mut err = struct_span_err!(cx.tcx.sess, p.span, E0009,\n+                                           \"cannot bind by-move and by-ref in the same pattern\");\n+            span_note!(&mut err, by_ref_span.unwrap(), \"by-ref binding occurs here\");\n+            err.emit();\n         }\n     };\n "}, {"sha": "aac6f1edc051da6fe085ebf06848cc85fd2581c0", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -243,10 +243,11 @@ fn add_library(sess: &session::Session,\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                   shows up once\", sess.cstore.crate_name(cnum)));\n-                sess.help(\"having upstream crates all available in one format \\\n-                           will likely make this go away\");\n+                sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                          shows up once\", sess.cstore.crate_name(cnum)))\n+                    .help(\"having upstream crates all available in one format \\\n+                           will likely make this go away\")\n+                    .emit();\n             }\n         }\n         None => { m.insert(cnum, link); }"}, {"sha": "2d096f66e09f6798e5e9358410bc36322c4fbdbc", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -146,17 +146,20 @@ fn configure_main(this: &mut EntryContext) {\n         this.session.entry_type.set(Some(config::EntryMain));\n     } else {\n         // No main function\n-        this.session.err(\"main function not found\");\n+        let mut err = this.session.struct_err(\"main function not found\");\n         if !this.non_main_fns.is_empty() {\n             // There were some functions named 'main' though. Try to give the user a hint.\n-            this.session.note(\"the main function must be defined at the crate level \\\n-                               but you have one or more functions named 'main' that are not \\\n-                               defined at the crate level. Either move the definition or \\\n-                               attach the `#[main]` attribute to override this behavior.\");\n+            err.note(\"the main function must be defined at the crate level \\\n+                      but you have one or more functions named 'main' that are not \\\n+                      defined at the crate level. Either move the definition or \\\n+                      attach the `#[main]` attribute to override this behavior.\");\n             for &(_, span) in &this.non_main_fns {\n-                this.session.span_note(span, \"here is a function named 'main'\");\n+                err.span_note(span, \"here is a function named 'main'\");\n             }\n+            err.emit();\n             this.session.abort_if_errors();\n+        } else {\n+            err.emit();\n         }\n     }\n }"}, {"sha": "d628227d5e63cacad504cbc7c232eb909502c4cb", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 217, "deletions": 154, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -90,12 +90,14 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n+use syntax::errors::DiagnosticBuilder;\n use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n impl<'tcx> ty::ctxt<'tcx> {\n     pub fn note_and_explain_region(&self,\n+                                   err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region,\n                                    suffix: &str) {\n@@ -126,7 +128,10 @@ impl<'tcx> ty::ctxt<'tcx> {\n                 };\n                 let span = match scope.span(&self.region_maps, &self.map) {\n                     Some(s) => s,\n-                    None => return self.sess.note(&unknown_scope())\n+                    None => {\n+                        err.note(&unknown_scope());\n+                        return;\n+                    }\n                 };\n                 let tag = match self.map.find(scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(_)) => \"block\",\n@@ -142,7 +147,8 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     Some(ast_map::NodeStmt(_)) => \"statement\",\n                     Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n                     Some(_) | None => {\n-                        return self.sess.span_note(span, &unknown_scope());\n+                        err.span_note(span, &unknown_scope());\n+                        return;\n                     }\n                 };\n                 let scope_decorated_tag = match self.region_maps.code_extent_data(scope) {\n@@ -214,9 +220,9 @@ impl<'tcx> ty::ctxt<'tcx> {\n         };\n         let message = format!(\"{}{}{}\", prefix, description, suffix);\n         if let Some(span) = span {\n-            self.sess.span_note(span, &message);\n+            err.span_note(span, &message);\n         } else {\n-            self.sess.note(&message);\n+            err.note(&message);\n         }\n     }\n }\n@@ -228,9 +234,15 @@ pub trait ErrorReporting<'tcx> {\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n                       -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>);\n+    fn report_type_error(&self,\n+                         trace: TypeTrace<'tcx>,\n+                         terr: &TypeError<'tcx>)\n+                         -> DiagnosticBuilder<'tcx>;\n \n-    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span);\n+    fn check_and_note_conflicting_crates(&self,\n+                                         err: &mut DiagnosticBuilder,\n+                                         terr: &TypeError<'tcx>,\n+                                         sp: Span);\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n@@ -265,17 +277,20 @@ pub trait ErrorReporting<'tcx> {\n                                trace_origin: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n-    fn give_suggestion(&self, same_regions: &[SameRegions]);\n+    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]);\n }\n \n trait ErrorReportingHelpers<'tcx> {\n     fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin);\n+                                var_origin: RegionVariableOrigin)\n+                                -> DiagnosticBuilder<'tcx>;\n \n     fn note_region_origin(&self,\n+                          err: &mut DiagnosticBuilder,\n                           origin: &SubregionOrigin<'tcx>);\n \n     fn give_expl_lifetime_param(&self,\n+                                err: &mut DiagnosticBuilder,\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n@@ -460,35 +475,47 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>) {\n+    fn report_type_error(&self,\n+                         trace: TypeTrace<'tcx>,\n+                         terr: &TypeError<'tcx>)\n+                         -> DiagnosticBuilder<'tcx> {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n-                return; /* derived error */\n+                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n             }\n         };\n \n-        span_err!(self.tcx.sess, trace.origin.span(), E0308,\n-            \"{}: {} ({})\",\n-                 trace.origin,\n-                 expected_found_str,\n-                 terr);\n+        let mut err = struct_span_err!(self.tcx.sess,\n+                                       trace.origin.span(),\n+                                       E0308,\n+                                       \"{}: {} ({})\",\n+                                       trace.origin,\n+                                       expected_found_str,\n+                                       terr);\n \n-        self.check_and_note_conflicting_crates(terr, trace.origin.span());\n+        self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n \n         match trace.origin {\n             TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} =>\n-                    self.tcx.sess.span_note(arm_span, \"`if let` arm with an incompatible type\"),\n-                _ => self.tcx.sess.span_note(arm_span, \"match arm with an incompatible type\"),\n+                hir::MatchSource::IfLetDesugar{..} => {\n+                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n+                }\n+                _ => {\n+                    err.span_note(arm_span, \"match arm with an incompatible type\");\n+                }\n             },\n             _ => ()\n         }\n+        err\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span) {\n-        let report_path_match = |did1: DefId, did2: DefId| {\n+    fn check_and_note_conflicting_crates(&self,\n+                                         err: &mut DiagnosticBuilder,\n+                                         terr: &TypeError<'tcx>,\n+                                         sp: Span) {\n+        let report_path_match = |err: &mut DiagnosticBuilder, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n@@ -502,9 +529,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // for imported and non-imported crates\n                 if exp_path == found_path {\n                     let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n-                    self.tcx.sess.span_note(sp, &format!(\"Perhaps two different versions \\\n-                                                          of crate `{}` are being used?\",\n-                                                          crate_name));\n+                    err.span_note(sp, &format!(\"Perhaps two different versions \\\n+                                                of crate `{}` are being used?\",\n+                                               crate_name));\n                 }\n             }\n         };\n@@ -517,13 +544,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     (&ty::TyStruct(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n                     (&ty::TyEnum(ref exp_adt, _), &ty::TyStruct(ref found_adt, _)) |\n                     (&ty::TyStruct(ref exp_adt, _), &ty::TyEnum(ref found_adt, _)) => {\n-                        report_path_match(exp_adt.did, found_adt.did);\n+                        report_path_match(err, exp_adt.did, found_adt.did);\n                     },\n                     _ => ()\n                 }\n             },\n             TypeError::Traits(ref exp_found) => {\n-                report_path_match(exp_found.expected, exp_found.found);\n+                report_path_match(err, exp_found.expected, exp_found.found);\n             },\n             _ => () // FIXME(#22750) handle traits and stuff\n         }\n@@ -533,8 +560,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      trace: TypeTrace<'tcx>,\n                                      terr: &TypeError<'tcx>) {\n         let span = trace.origin.span();\n-        self.report_type_error(trace, terr);\n-        self.tcx.note_and_explain_type_err(terr, span);\n+        let mut err = self.report_type_error(trace, terr);\n+        self.tcx.note_and_explain_type_err(&mut err, terr, span);\n+        err.emit();\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -584,51 +612,56 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n-        match sub {\n+        let mut err = match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(\n-                    self.tcx.sess, origin.span(), E0309,\n-                    \"{} may not live long enough\", labeled_user_string);\n-                self.tcx.sess.fileline_help(\n-                    origin.span(),\n-                    &format!(\n-                        \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        bound_kind,\n-                        sub));\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               origin.span(),\n+                                               E0309,\n+                                               \"{} may not live long enough\",\n+                                               labeled_user_string);\n+                err.fileline_help(origin.span(),\n+                                  &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n+                                           bound_kind,\n+                                           sub));\n+                err\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                span_err!(\n-                    self.tcx.sess, origin.span(), E0310,\n-                    \"{} may not live long enough\", labeled_user_string);\n-                self.tcx.sess.fileline_help(\n-                    origin.span(),\n-                    &format!(\n-                        \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind));\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               origin.span(),\n+                                               E0310,\n+                                               \"{} may not live long enough\",\n+                                               labeled_user_string);\n+                err.fileline_help(origin.span(),\n+                                  &format!(\"consider adding an explicit lifetime \\\n+                                            bound `{}: 'static`...\",\n+                                           bound_kind));\n+                err\n             }\n \n             _ => {\n                 // If not, be less specific.\n-                span_err!(\n-                    self.tcx.sess, origin.span(), E0311,\n-                    \"{} may not live long enough\",\n-                    labeled_user_string);\n-                self.tcx.sess.fileline_help(\n-                    origin.span(),\n-                    &format!(\n-                        \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind));\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               origin.span(),\n+                                               E0311,\n+                                               \"{} may not live long enough\",\n+                                               labeled_user_string);\n+                err.fileline_help(origin.span(),\n+                                  &format!(\"consider adding an explicit lifetime bound for `{}`\",\n+                                           bound_kind));\n                 self.tcx.note_and_explain_region(\n+                    &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n+                err\n             }\n-        }\n+        };\n \n-        self.note_region_origin(&origin);\n+        self.note_region_origin(&mut err, &origin);\n+        err.emit();\n     }\n \n     fn report_concrete_failure(&self,\n@@ -641,239 +674,262 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n-                span_err!(self.tcx.sess, span, E0312,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                span_err!(self.tcx.sess, span, E0313,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n                     \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             self.tcx.local_var_name_str(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     &format!(\"...but `{}` is only valid for \",\n                              self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::InfStackClosure(span) => {\n-                span_err!(self.tcx.sess, span, E0314,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::InvokeClosure(span) => {\n-                span_err!(self.tcx.sess, span, E0315,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::DerefPointer(span) => {\n-                span_err!(self.tcx.sess, span, E0473,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n                           \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::FreeVariable(span, id) => {\n-                span_err!(self.tcx.sess, span, E0474,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n                           \"captured variable `{}` does not outlive the enclosing closure\",\n                           self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n+                err.emit();\n             }\n             infer::IndexSlice(span) => {\n-                span_err!(self.tcx.sess, span, E0475,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n                           \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::RelateObjectBound(span) => {\n-                span_err!(self.tcx.sess, span, E0476,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n                           \"lifetime of the source pointer does not outlive \\\n                            lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"object type is valid for \",\n                     sub,\n                     \"\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::RelateParamBound(span, ty) => {\n-                span_err!(self.tcx.sess, span, E0477,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n                           \"the type `{}` does not fulfill the required lifetime\",\n                           self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n+                err.emit();\n             }\n             infer::RelateRegionParamBound(span) => {\n-                span_err!(self.tcx.sess, span, E0478,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n                           \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n+                err.emit();\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n-                span_err!(self.tcx.sess, span, E0479,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n                           \"the type `{}` (provided as the value of \\\n                            a type parameter) is not valid at this point\",\n                           self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n+                err.emit();\n             }\n             infer::CallRcvr(span) => {\n-                span_err!(self.tcx.sess, span, E0480,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n                           \"lifetime of method receiver does not outlive \\\n                            the method call\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::CallArg(span) => {\n-                span_err!(self.tcx.sess, span, E0481,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n                           \"lifetime of function argument does not outlive \\\n                            the function call\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::CallReturn(span) => {\n-                span_err!(self.tcx.sess, span, E0482,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n                           \"lifetime of return value does not outlive \\\n                            the function call\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::Operand(span) => {\n-                span_err!(self.tcx.sess, span, E0483,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n                           \"lifetime of operand does not outlive \\\n                            the operation\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::AddrOf(span) => {\n-                span_err!(self.tcx.sess, span, E0484,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n                           \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::AutoBorrow(span) => {\n-                span_err!(self.tcx.sess, span, E0485,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n                           \"automatically reference is not valid \\\n                            at the time of borrow\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                span_err!(self.tcx.sess, span, E0486,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n                           \"type of expression contains references \\\n                            that are not valid during the expression: `{}`\",\n                           self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::SafeDestructor(span) => {\n-                span_err!(self.tcx.sess, span, E0487,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n                           \"unsafe use of destructor: destructor might be called \\\n                            while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"superregion: \",\n                     sup,\n                     \"\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"subregion: \",\n                     sub,\n                     \"\");\n+                err.emit();\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                span_err!(self.tcx.sess, span, E0488,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n                           \"lifetime of variable does not enclose its declaration\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n             infer::ParameterInScope(_, span) => {\n-                span_err!(self.tcx.sess, span, E0489,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n                           \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the parameter is only valid for \",\n                     sub,\n                     \"\");\n+                err.emit();\n             }\n             infer::DataBorrowed(ty, span) => {\n-                span_err!(self.tcx.sess, span, E0490,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n                           \"a value of type `{}` is borrowed for too long\",\n                           self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(\"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(\"but the borrow lasts for \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                err.emit();\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                span_err!(self.tcx.sess, span, E0491,\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n                           \"in type `{}`, reference has a longer lifetime \\\n                            than the data it references\",\n                           self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\");\n-                self.tcx.note_and_explain_region(\n+                self.tcx.note_and_explain_region(&mut err,\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n+                err.emit();\n             }\n         }\n     }\n@@ -884,37 +940,42 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region) {\n-        self.report_inference_failure(var_origin);\n+        let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(\n+        self.tcx.note_and_explain_region(&mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n-        self.note_region_origin(&sup_origin);\n+        self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(\n+        self.tcx.note_and_explain_region(&mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n \n-        self.note_region_origin(&sub_origin);\n+        self.note_region_origin(&mut err, &sub_origin);\n+        err.emit();\n     }\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n                                trace_origins: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]) {\n-        for vo in var_origins {\n-            self.report_inference_failure(vo.clone());\n+        for (i, vo) in var_origins.iter().enumerate() {\n+            let mut err = self.report_inference_failure(vo.clone());\n+            if i == var_origins.len() - 1 {\n+                self.give_suggestion(&mut err, same_regions);\n+            }\n+            err.emit();\n         }\n-        self.give_suggestion(same_regions);\n+\n         for &(ref trace, ref terr) in trace_origins {\n             self.report_and_explain_type_error(trace.clone(), terr);\n         }\n     }\n \n-    fn give_suggestion(&self, same_regions: &[SameRegions]) {\n+    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]) {\n         let scope_id = same_regions[0].scope_id;\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n@@ -968,7 +1029,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(&fn_decl, unsafety, constness, name,\n+        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name,\n                                       expl_self.as_ref(), &generics, span);\n     }\n }\n@@ -1520,6 +1581,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n+                                err: &mut DiagnosticBuilder,\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n@@ -1531,11 +1593,12 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                                  opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, &msg[..]);\n+        err.span_help(span, &msg[..]);\n     }\n \n     fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin) {\n+                                var_origin: RegionVariableOrigin)\n+                                -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n             let mut s = br.to_string();\n             if !s.is_empty() {\n@@ -1574,13 +1637,13 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        span_err!(self.tcx.sess, var_origin.span(), E0495,\n+        struct_span_err!(self.tcx.sess, var_origin.span(), E0495,\n                   \"cannot infer an appropriate lifetime{} \\\n                    due to conflicting requirements\",\n-                  var_description);\n+                  var_description)\n     }\n \n-    fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n+    fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -1622,7 +1685,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 match self.values_str(&trace.values) {\n                     Some(values_str) => {\n-                        self.tcx.sess.span_note(\n+                        err.span_note(\n                             trace.origin.span(),\n                             &format!(\"...so that {} ({})\",\n                                     desc, values_str));\n@@ -1632,147 +1695,147 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // all, since it is derived, but that would\n                         // require more refactoring than I feel like\n                         // doing right now. - nmatsakis\n-                        self.tcx.sess.span_note(\n+                        err.span_note(\n                             trace.origin.span(),\n                             &format!(\"...so that {}\", desc));\n                     }\n                 }\n             }\n             infer::Reborrow(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that reference does not outlive \\\n                     borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\n                         \"...so that closure can access `{}`\",\n                         self.tcx.local_var_name_str(upvar_id.var_id)\n-                            .to_string()))\n+                            .to_string()));\n             }\n             infer::InfStackClosure(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that closure does not outlive its stack frame\");\n             }\n             infer::InvokeClosure(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that closure is not invoked outside its lifetime\");\n             }\n             infer::DerefPointer(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that pointer is not dereferenced \\\n                     outside its lifetime\");\n             }\n             infer::FreeVariable(span, id) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n                             self.tcx.local_var_name_str(id)));\n             }\n             infer::IndexSlice(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that slice is not indexed outside the lifetime\");\n             }\n             infer::RelateObjectBound(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that it can be closed over into an object\");\n             }\n             infer::CallRcvr(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that method receiver is valid for the method call\");\n             }\n             infer::CallArg(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that argument is valid for the call\");\n             }\n             infer::CallReturn(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that return value is valid for the call\");\n             }\n             infer::Operand(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that operand is valid for operation\");\n             }\n             infer::AddrOf(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that reference is valid \\\n                      at the time of borrow\");\n             }\n             infer::AutoBorrow(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that auto-reference is valid \\\n                      at the time of borrow\");\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n                             self.ty_to_string(t)));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that variable is valid at time of its declaration\");\n             }\n             infer::ParameterInScope(_, span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that a type/lifetime parameter is in scope here\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so that the type `{}` is not borrowed for too long\",\n                              self.ty_to_string(ty)));\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n                             self.ty_to_string(ty)));\n             }\n             infer::RelateParamBound(span, t) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so that the type `{}` \\\n                              will meet its required lifetime bounds\",\n                             self.ty_to_string(t)));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     &format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n                             self.ty_to_string(t)));\n             }\n             infer::RelateRegionParamBound(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds \\\n                                 are satisfied\");\n             }\n             infer::SafeDestructor(span) => {\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     span,\n                     \"...so that references are valid when the destructor \\\n-                     runs\")\n+                     runs\");\n             }\n         }\n     }"}, {"sha": "21a1ee37b7f436c1e8fb772e9ad2511263193a76", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -40,6 +40,7 @@ use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::errors::DiagnosticBuilder;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n@@ -1269,19 +1270,43 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      sp: Span,\n                                      mk_msg: M,\n                                      actual_ty: String,\n-                                     err: Option<&TypeError<'tcx>>) where\n-        M: FnOnce(Option<String>, String) -> String,\n+                                     err: Option<&TypeError<'tcx>>)\n+        where M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n+    pub fn type_error_struct_str<M>(&self,\n+                                    sp: Span,\n+                                    mk_msg: M,\n+                                    actual_ty: String,\n+                                    err: Option<&TypeError<'tcx>>)\n+                                    -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(Option<String>, String) -> String,\n+    {\n+        self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n+    }\n+\n     pub fn type_error_message_str_with_expected<M>(&self,\n                                                    sp: Span,\n                                                    mk_msg: M,\n                                                    expected_ty: Option<Ty<'tcx>>,\n                                                    actual_ty: String,\n-                                                   err: Option<&TypeError<'tcx>>) where\n-        M: FnOnce(Option<String>, String) -> String,\n+                                                   err: Option<&TypeError<'tcx>>)\n+        where M: FnOnce(Option<String>, String) -> String,\n+    {\n+        self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n+            .emit();\n+    }\n+\n+    pub fn type_error_struct_str_with_expected<M>(&self,\n+                                                  sp: Span,\n+                                                  mk_msg: M,\n+                                                  expected_ty: Option<Ty<'tcx>>,\n+                                                  actual_ty: String,\n+                                                  err: Option<&TypeError<'tcx>>)\n+                                                  -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n@@ -1292,33 +1317,47 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\" ({})\", t_err)\n             });\n \n-            self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n+            let mut db = self.tcx.sess.struct_span_err(sp, &format!(\"{}{}\",\n                 mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n                 error_str));\n \n             if let Some(err) = err {\n-                self.tcx.note_and_explain_type_err(err, sp)\n+                self.tcx.note_and_explain_type_err(&mut db, err, sp);\n             }\n+            db\n+        } else {\n+            self.tcx.sess.diagnostic().struct_dummy()\n         }\n     }\n \n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>) where\n-        M: FnOnce(String) -> String,\n+                                 err: Option<&TypeError<'tcx>>)\n+        where M: FnOnce(String) -> String,\n+    {\n+        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n+    }\n+\n+    pub fn type_error_struct<M>(&self,\n+                                sp: Span,\n+                                mk_msg: M,\n+                                actual_ty: Ty<'tcx>,\n+                                err: Option<&TypeError<'tcx>>)\n+                                -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n-            return;\n+            return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        self.type_error_message_str(sp,\n+        self.type_error_struct_str(sp,\n             move |_e, a| { mk_msg(a) },\n-            self.ty_to_string(actual_ty), err);\n+            self.ty_to_string(actual_ty), err)\n     }\n \n     pub fn report_mismatched_types(&self,"}, {"sha": "29299f01ed36fcc2f4a4829a1906e8ef9549c321", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -1500,7 +1500,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             },\n                         _ => false\n                     };\n-                    span_err!(self.ir.tcx.sess, sp, E0269, \"not all control paths return a value\");\n+                    let mut err = struct_span_err!(self.ir.tcx.sess,\n+                                                   sp,\n+                                                   E0269,\n+                                                   \"not all control paths return a value\");\n                     if ends_with_stmt {\n                         let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n@@ -1510,9 +1513,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             hi: original_span.hi,\n                             expn_id: original_span.expn_id\n                         };\n-                        self.ir.tcx.sess.span_help(\n-                            span_semicolon, \"consider removing this semicolon:\");\n+                        err.span_help(span_semicolon, \"consider removing this semicolon:\");\n                     }\n+                    err.emit();\n                 }\n             }\n             ty::FnDiverging"}, {"sha": "2c74f3a82e41441e39cc501e9436691c96b5a669", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -345,25 +345,25 @@ impl ShadowKind {\n     }\n }\n \n-fn signal_shadowing_problem(\n-    sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n-    if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n+fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n+    let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n-        span_err!(sess, shadower.span, E0496,\n-                  \"{} name `{}` shadows a \\\n-                   {} name that is already in scope\",\n-                  shadower.kind.desc(), name, orig.kind.desc());\n+        struct_span_err!(sess, shadower.span, E0496,\n+                         \"{} name `{}` shadows a \\\n+                          {} name that is already in scope\",\n+                         shadower.kind.desc(), name, orig.kind.desc())\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic.\n-        sess.span_warn(shadower.span,\n-                      &format!(\"{} name `{}` shadows a \\\n-                                {} name that is already in scope\",\n-                               shadower.kind.desc(), name, orig.kind.desc()));\n-    }\n-    sess.span_note(orig.span,\n-                   &format!(\"shadowed {} `{}` declared here\",\n-                            orig.kind.desc(), name));\n+        sess.struct_span_warn(shadower.span,\n+                              &format!(\"{} name `{}` shadows a \\\n+                                        {} name that is already in scope\",\n+                                       shadower.kind.desc(), name, orig.kind.desc()))\n+    };\n+    err.span_note(orig.span,\n+                  &format!(\"shadowed {} `{}` declared here\",\n+                           orig.kind.desc(), name));\n+    err.emit();\n }\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning"}, {"sha": "f6af680d441ebc72bffe19053bb28b32685a904f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -394,17 +394,19 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 // This is an 'unmarked' API, which should not exist\n                 // in the standard library.\n                 if self.tcx.sess.features.borrow().unmarked_api {\n-                    self.tcx.sess.span_warn(span, \"use of unmarked library feature\");\n-                    self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                    self.tcx.sess.struct_span_warn(span, \"use of unmarked library feature\")\n+                                 .span_note(span, \"this is either a bug in the library you are \\\n                                                    using or a bug in the compiler - please \\\n-                                                   report it in both places\");\n+                                                   report it in both places\")\n+                                 .emit()\n                 } else {\n-                    self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n-                    self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                    self.tcx.sess.struct_span_err(span, \"use of unmarked library feature\")\n+                                 .span_note(span, \"this is either a bug in the library you are \\\n                                                    using or a bug in the compiler - please \\\n-                                                   report it in both places\");\n-                    self.tcx.sess.span_note(span, \"use #![feature(unmarked_api)] in the \\\n-                                                   crate attributes to override this\");\n+                                                   report it in both places\")\n+                                 .span_note(span, \"use #![feature(unmarked_api)] in the \\\n+                                                   crate attributes to override this\")\n+                                 .emit()\n                 }\n             }\n         }"}, {"sha": "9193b1a09f9faa7fa7f081995329be4f00bb4f7d", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 87, "deletions": 61, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -31,8 +31,9 @@ use middle::ty::fold::TypeFoldable;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::fmt;\n-use syntax::codemap::Span;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {\n@@ -94,12 +95,12 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     // then $X will be unified with TyError, but the error still needs to be\n     // reported.\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n-        span_err!(\n-            infcx.tcx.sess, obligation.cause.span, E0271,\n+        let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n             \"type mismatch resolving `{}`: {}\",\n             predicate,\n             error.err);\n-        note_obligation_cause(infcx, obligation);\n+        note_obligation_cause(infcx, &mut err, obligation);\n+        err.emit();\n     }\n }\n \n@@ -186,14 +187,15 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-    span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n-              \"overflow evaluating the requirement `{}`\",\n-              predicate);\n+    let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n+                                   \"overflow evaluating the requirement `{}`\",\n+                                   predicate);\n \n-    suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n+    suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n \n-    note_obligation_cause(infcx, obligation);\n+    note_obligation_cause(infcx, &mut err, obligation);\n \n+    err.emit();\n     infcx.tcx.sess.abort_if_errors();\n     unreachable!();\n }\n@@ -218,7 +220,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                         if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n                             let trait_ref = trait_predicate.to_poly_trait_ref();\n-                            span_err!(\n+                            let mut err = struct_span_err!(\n                                 infcx.tcx.sess, obligation.cause.span, E0277,\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref, trait_ref.self_ty());\n@@ -228,54 +230,59 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                       obligation.cause.span);\n                             if let Some(s) = custom_note {\n-                                infcx.tcx.sess.fileline_note(obligation.cause.span, &s);\n+                                err.fileline_note(obligation.cause.span, &s);\n                             }\n-                            note_obligation_cause(infcx, obligation);\n+                            note_obligation_cause(infcx, &mut err, obligation);\n+                            err.emit();\n                         }\n                     }\n \n                     ty::Predicate::Equate(ref predicate) => {\n                         let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                         let err = infcx.equality_predicate(obligation.cause.span,\n                                                            &predicate).err().unwrap();\n-                        span_err!(\n+                        let mut err = struct_span_err!(\n                             infcx.tcx.sess, obligation.cause.span, E0278,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate,\n                             err);\n-                        note_obligation_cause(infcx, obligation);\n+                        note_obligation_cause(infcx, &mut err, obligation);\n+                        err.emit();\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n                         let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                         let err = infcx.region_outlives_predicate(obligation.cause.span,\n                                                                   &predicate).err().unwrap();\n-                        span_err!(\n+                        let mut err = struct_span_err!(\n                             infcx.tcx.sess, obligation.cause.span, E0279,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate,\n                             err);\n-                        note_obligation_cause(infcx, obligation);\n+                        note_obligation_cause(infcx, &mut err, obligation);\n+                        err.emit();\n                     }\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n                             infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                        span_err!(\n+                        let mut err = struct_span_err!(\n                             infcx.tcx.sess, obligation.cause.span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n                             predicate);\n-                        note_obligation_cause(infcx, obligation);\n+                        note_obligation_cause(infcx, &mut err, obligation);\n+                        err.emit();\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n                         let violations = object_safety_violations(\n                             infcx.tcx, trait_def_id);\n-                        report_object_safety_error(infcx.tcx,\n-                                                   obligation.cause.span,\n-                                                   trait_def_id,\n-                                                   violations);\n-                        note_obligation_cause(infcx, obligation);\n+                        let mut err = report_object_safety_error(infcx.tcx,\n+                                                                 obligation.cause.span,\n+                                                                 trait_def_id,\n+                                                                 violations);\n+                        note_obligation_cause(infcx, &mut err, obligation);\n+                        err.emit();\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n@@ -296,22 +303,25 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !actual_trait_ref.self_ty().references_error() {\n-                span_err!(\n+                let mut err = struct_span_err!(\n                     infcx.tcx.sess, obligation.cause.span, E0281,\n                     \"type mismatch: the type `{}` implements the trait `{}`, \\\n                      but the trait `{}` is required ({})\",\n                     expected_trait_ref.self_ty(),\n                     expected_trait_ref,\n                     actual_trait_ref,\n                     e);\n-                note_obligation_cause(infcx, obligation);\n+                note_obligation_cause(infcx, &mut err, obligation);\n+                err.emit();\n             }\n         }\n \n         TraitNotObjectSafe(did) => {\n             let violations = object_safety_violations(infcx.tcx, did);\n-            report_object_safety_error(infcx.tcx, obligation.cause.span, did, violations);\n-            note_obligation_cause(infcx, obligation);\n+            let mut err = report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n+                                                     violations);\n+            note_obligation_cause(infcx, &mut err, obligation);\n+            err.emit();\n         }\n     }\n }\n@@ -320,8 +330,9 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         span: Span,\n                                         trait_def_id: DefId,\n                                         violations: Vec<ObjectSafetyViolation>)\n+                                        -> DiagnosticBuilder<'tcx>\n {\n-    span_err!(\n+    let mut err = struct_span_err!(\n         tcx.sess, span, E0038,\n         \"the trait `{}` cannot be made into an object\",\n         tcx.item_path_str(trait_def_id));\n@@ -333,29 +344,29 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                tcx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     \"the trait cannot require that `Self : Sized`\");\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                tcx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     \"the trait cannot use `Self` as a type parameter \\\n                      in the supertrait listing\");\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                tcx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     &format!(\"method `{}` has no receiver\",\n                              method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                tcx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     &format!(\"method `{}` references the `Self` type \\\n                               in its arguments or return type\",\n@@ -364,13 +375,14 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                tcx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     &format!(\"method `{}` has generic type parameters\",\n                              method.name));\n             }\n         }\n     }\n+    err\n }\n \n pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -424,10 +436,12 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     {\n                         need_type_info(infcx, obligation.cause.span, self_ty);\n                     } else {\n-                        span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n-                                \"type annotations required: cannot resolve `{}`\",\n-                                predicate);\n-                        note_obligation_cause(infcx, obligation);\n+                        let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n+                                                       \"type annotations required: \\\n+                                                        cannot resolve `{}`\",\n+                                                       predicate);\n+                        note_obligation_cause(infcx, &mut err, obligation);\n+                        err.emit();\n                     }\n                 }\n             }\n@@ -443,10 +457,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n-                span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n-                        \"type annotations required: cannot resolve `{}`\",\n-                        predicate);\n-                note_obligation_cause(infcx, obligation);\n+                let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n+                                               \"type annotations required: cannot resolve `{}`\",\n+                                               predicate);\n+                note_obligation_cause(infcx, &mut err, obligation);\n+                err.emit();\n             }\n         }\n     }\n@@ -463,16 +478,19 @@ fn need_type_info<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n }\n \n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      err: &mut DiagnosticBuilder,\n                                       obligation: &Obligation<'tcx, T>)\n     where T: fmt::Display\n {\n     note_obligation_cause_code(infcx,\n+                               err,\n                                &obligation.predicate,\n                                obligation.cause.span,\n                                &obligation.cause.code);\n }\n \n fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                           err: &mut DiagnosticBuilder,\n                                            predicate: &T,\n                                            cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n@@ -482,105 +500,113 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::SliceOrArrayElem => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"slice and array elements must have `Sized` type\");\n         }\n         ObligationCauseCode::ProjectionWf(data) => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"required so that the projection `{}` is well-formed\",\n                          data));\n         }\n         ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"required so that reference `{}` does not outlive its referent\",\n                          ref_ty));\n         }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\n                     \"required for the cast to the object type `{}`\",\n                     infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"the `Copy` trait is required because the \\\n                  repeated element will be copied\");\n         }\n         ObligationCauseCode::VariableType(_) => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"all local variables must have a statically known size\");\n         }\n         ObligationCauseCode::ReturnType => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"the return type of a function must have a \\\n                  statically known size\");\n         }\n         ObligationCauseCode::AssignmentLhsSized => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"the left-hand-side of an assignment must have a statically known size\");\n         }\n         ObligationCauseCode::StructInitializerSized => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"structs must have a statically known size to be initialized\");\n         }\n         ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n             let trait_name = tcx.item_path_str(def_id);\n             let name = tcx.local_var_name_str(var_id);\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"the closure that captures `{}` requires that all captured variables \\\n                           implement the trait `{}`\",\n                          name,\n                          trait_name));\n         }\n         ObligationCauseCode::FieldSized => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"only the last field of a struct or enum variant \\\n                  may have a dynamically sized type\");\n         }\n         ObligationCauseCode::SharedStatic => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 \"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"required because it appears within the type `{}`\",\n                          parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n+            note_obligation_cause_code(infcx,\n+                                       err,\n+                                       &parent_predicate,\n+                                       cause_span,\n+                                       &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                          parent_trait_ref,\n                          parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n+            note_obligation_cause_code(infcx,\n+                                       err,\n+                                       &parent_predicate,\n+                                       cause_span,\n+                                       &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n-            tcx.sess.fileline_note(\n+            err.fileline_note(\n                 cause_span,\n                 &format!(\"the requirement `{}` appears on the impl method \\\n                           but not on the corresponding trait method\",\n@@ -589,10 +615,10 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n+fn suggest_new_overflow_limit(tcx: &ty::ctxt, err:&mut DiagnosticBuilder, span: Span) {\n     let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    tcx.sess.fileline_note(\n+    err.fileline_note(\n         span,\n         &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\","}, {"sha": "ab48fd7fb8665f2727903f471f5e872ff5b6f5a8", "filename": "src/librustc/middle/ty/error.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n \n use rustc_front::hir;\n \n@@ -252,70 +253,71 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n impl<'tcx> ty::ctxt<'tcx> {\n-    pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n+    pub fn note_and_explain_type_err(&self,\n+                                     db: &mut DiagnosticBuilder,\n+                                     err: &TypeError<'tcx>,\n+                                     sp: Span) {\n         use self::TypeError::*;\n \n         match err.clone() {\n             RegionsDoesNotOutlive(subregion, superregion) => {\n-                self.note_and_explain_region(\"\", subregion, \"...\");\n-                self.note_and_explain_region(\"...does not necessarily outlive \",\n+                self.note_and_explain_region(db, \"\", subregion, \"...\");\n+                self.note_and_explain_region(db, \"...does not necessarily outlive \",\n                                            superregion, \"\");\n             }\n             RegionsNotSame(region1, region2) => {\n-                self.note_and_explain_region(\"\", region1, \"...\");\n-                self.note_and_explain_region(\"...is not the same lifetime as \",\n+                self.note_and_explain_region(db, \"\", region1, \"...\");\n+                self.note_and_explain_region(db, \"...is not the same lifetime as \",\n                                            region2, \"\");\n             }\n             RegionsNoOverlap(region1, region2) => {\n-                self.note_and_explain_region(\"\", region1, \"...\");\n-                self.note_and_explain_region(\"...does not overlap \",\n+                self.note_and_explain_region(db, \"\", region1, \"...\");\n+                self.note_and_explain_region(db, \"...does not overlap \",\n                                            region2, \"\");\n             }\n             RegionsInsufficientlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(\"concrete lifetime that was found is \",\n+                self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n             RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }\n             RegionsOverlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(\"expected concrete lifetime is \",\n+                self.note_and_explain_region(db, \"expected concrete lifetime is \",\n                                            conc_region, \"\");\n             }\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n-                    self.sess.span_note(sp,\n+                    db.span_note(sp,\n                         \"no two closures, even if identical, have the same type\");\n-                    self.sess.span_help(sp,\n+                    db.span_help(sp,\n                         \"consider boxing your closure and/or using it as a trait object\");\n                 }\n             },\n             TyParamDefaultMismatch(values) => {\n                 let expected = values.expected;\n                 let found = values.found;\n-                self.sess.span_note(sp,\n-                                    &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n-                                             expected.ty,\n-                                             found.ty));\n+                db.span_note(sp, &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n+                                          expected.ty,\n+                                          found.ty));\n \n                 match\n                     self.map.as_local_node_id(expected.def_id)\n                             .and_then(|node_id| self.map.opt_span(node_id))\n                 {\n                     Some(span) => {\n-                        self.sess.span_note(span, \"a default was defined here...\");\n+                        db.span_note(span, \"a default was defined here...\");\n                     }\n                     None => {\n-                        self.sess.note(\n-                            &format!(\"a default is defined on `{}`\",\n-                                     self.item_path_str(expected.def_id)));\n+                        db.note(&format!(\"a default is defined on `{}`\",\n+                                         self.item_path_str(expected.def_id)));\n                     }\n                 }\n \n-                self.sess.span_note(\n+                db.span_note(\n                     expected.origin_span,\n                     \"...that was applied to an unconstrained type variable here\");\n \n@@ -324,18 +326,16 @@ impl<'tcx> ty::ctxt<'tcx> {\n                             .and_then(|node_id| self.map.opt_span(node_id))\n                 {\n                     Some(span) => {\n-                        self.sess.span_note(span, \"a second default was defined here...\");\n+                        db.span_note(span, \"a second default was defined here...\");\n                     }\n                     None => {\n-                        self.sess.note(\n-                            &format!(\"a second default is defined on `{}`\",\n-                                     self.item_path_str(found.def_id)));\n+                        db.note(&format!(\"a second default is defined on `{}`\",\n+                                         self.item_path_str(found.def_id)));\n                     }\n                 }\n \n-                self.sess.span_note(\n-                    found.origin_span,\n-                    \"...that also applies to the same type variable here\");\n+                db.span_note(found.origin_span,\n+                             \"...that also applies to the same type variable here\");\n             }\n             _ => {}\n         }"}, {"sha": "80b4c1916a81626d9c28cc3b8b5271f29acf5328", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -16,7 +16,7 @@ use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::Span;\n-use syntax::errors;\n+use syntax::errors::{self, DiagnosticBuilder};\n use syntax::errors::emitter::{Emitter, BasicEmitter};\n use syntax::diagnostics;\n use syntax::feature_gate;\n@@ -80,6 +80,61 @@ pub struct Session {\n }\n \n impl Session {\n+    pub fn struct_span_warn<'a>(&'a self,\n+                                sp: Span,\n+                                msg: &str)\n+                                -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_span_warn(sp, msg)\n+    }\n+    pub fn struct_span_warn_with_code<'a>(&'a self,\n+                                          sp: Span,\n+                                          msg: &str,\n+                                          code: &str)\n+                                          -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n+    }\n+    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_warn(msg)\n+    }\n+    pub fn struct_span_err<'a>(&'a self,\n+                               sp: Span,\n+                               msg: &str)\n+                               -> DiagnosticBuilder<'a>  {\n+        match split_msg_into_multilines(msg) {\n+            Some(ref msg) => self.diagnostic().struct_span_err(sp, msg),\n+            None => self.diagnostic().struct_span_err(sp, msg),\n+        }\n+    }\n+    pub fn struct_span_err_with_code<'a>(&'a self,\n+                                         sp: Span,\n+                                         msg: &str,\n+                                         code: &str)\n+                                         -> DiagnosticBuilder<'a>  {\n+        match split_msg_into_multilines(msg) {\n+            Some(ref msg) => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n+            None => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n+        }\n+    }\n+    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_err(msg)\n+    }\n+    pub fn struct_span_fatal<'a>(&'a self,\n+                                 sp: Span,\n+                                 msg: &str)\n+                                 -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_span_fatal(sp, msg)\n+    }\n+    pub fn struct_span_fatal_with_code<'a>(&'a self,\n+                                           sp: Span,\n+                                           msg: &str,\n+                                           code: &str)\n+                                           -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n+    }\n+    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+        self.diagnostic().struct_fatal(msg)\n+    }\n+\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n@@ -98,13 +153,13 @@ impl Session {\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n+            Some(msg) => self.diagnostic().span_err(sp, &msg),\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg, code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }\n@@ -144,34 +199,6 @@ impl Session {\n             None => self.warn(msg),\n         }\n     }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.diagnostic().span_note(sp, msg)\n-    }\n-    pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.diagnostic().span_end_note(sp, msg)\n-    }\n-\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `errors::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n-        self.diagnostic().span_suggestion(sp, msg, suggestion)\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.diagnostic().span_help(sp, msg)\n-    }\n-    pub fn fileline_note(&self, sp: Span, msg: &str) {\n-        self.diagnostic().fileline_note(sp, msg)\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.diagnostic().fileline_help(sp, msg)\n-    }\n-    pub fn note(&self, msg: &str) {\n-        self.diagnostic().note(msg)\n-    }\n-    pub fn help(&self, msg: &str) {\n-        self.diagnostic().help(msg)\n-    }\n     pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n         match opt_sp {\n             Some(sp) => self.span_bug(sp, msg),\n@@ -188,6 +215,12 @@ impl Session {\n     pub fn bug(&self, msg: &str) -> ! {\n         self.diagnostic().bug(msg)\n     }\n+    pub fn note_without_error(&self, msg: &str) {\n+        self.diagnostic().note_without_error(msg)\n+    }\n+    pub fn span_note_without_error(&self, sp: Span, msg: &str) {\n+        self.diagnostic().span_note_without_error(sp, msg)\n+    }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_unimpl(sp, msg)\n     }"}, {"sha": "df181aec4ea4c536b13aba9959f6c17f1257d73e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -465,44 +465,44 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 format!(\"`{}`\", ol)\n             };\n \n-            match (new_loan.kind, old_loan.kind) {\n+            let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    span_err!(self.bccx, new_loan.span, E0499,\n-                              \"cannot borrow `{}`{} as mutable \\\n-                               more than once at a time\",\n-                              nl, new_loan_msg);\n+                    struct_span_err!(self.bccx, new_loan.span, E0499,\n+                                     \"cannot borrow `{}`{} as mutable \\\n+                                      more than once at a time\",\n+                                     nl, new_loan_msg)\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    span_err!(self.bccx, new_loan.span, E0500,\n-                              \"closure requires unique access to `{}` \\\n-                               but {} is already borrowed{}\",\n-                              nl, ol_pronoun, old_loan_msg);\n+                    struct_span_err!(self.bccx, new_loan.span, E0500,\n+                                     \"closure requires unique access to `{}` \\\n+                                      but {} is already borrowed{}\",\n+                                     nl, ol_pronoun, old_loan_msg)\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    span_err!(self.bccx, new_loan.span, E0501,\n-                              \"cannot borrow `{}`{} as {} because \\\n-                               previous closure requires unique access\",\n-                              nl, new_loan_msg, new_loan.kind.to_user_str());\n+                    struct_span_err!(self.bccx, new_loan.span, E0501,\n+                                     \"cannot borrow `{}`{} as {} because \\\n+                                      previous closure requires unique access\",\n+                                     nl, new_loan_msg, new_loan.kind.to_user_str())\n                 }\n \n                 (_, _) => {\n-                    span_err!(self.bccx, new_loan.span, E0502,\n-                              \"cannot borrow `{}`{} as {} because \\\n-                               {} is also borrowed as {}{}\",\n-                              nl,\n-                              new_loan_msg,\n-                              new_loan.kind.to_user_str(),\n-                              ol_pronoun,\n-                              old_loan.kind.to_user_str(),\n-                              old_loan_msg);\n+                    struct_span_err!(self.bccx, new_loan.span, E0502,\n+                                     \"cannot borrow `{}`{} as {} because \\\n+                                      {} is also borrowed as {}{}\",\n+                                     nl,\n+                                     new_loan_msg,\n+                                     new_loan.kind.to_user_str(),\n+                                     ol_pronoun,\n+                                     old_loan.kind.to_user_str(),\n+                                     old_loan_msg)\n                 }\n-            }\n+            };\n \n             match new_loan.cause {\n                 euv::ClosureCapture(span) => {\n-                    self.bccx.span_note(\n+                    err.span_note(\n                         span,\n                         &format!(\"borrow occurs due to use of `{}` in closure\",\n                                 nl));\n@@ -553,15 +553,15 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.bccx.span_note(\n+            err.span_note(\n                 old_loan.span,\n                 &format!(\"{}; {}\", borrow_summary, rule_summary));\n \n             let old_loan_span = self.tcx().map.span(\n                 old_loan.kill_scope.node_id(&self.tcx().region_maps));\n-            self.bccx.span_end_note(old_loan_span,\n-                                    \"previous borrow ends here\");\n-\n+            err.span_end_note(old_loan_span,\n+                              \"previous borrow ends here\");\n+            err.emit();\n             return false;\n         }\n \n@@ -616,14 +616,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                span_err!(self.bccx, span, E0503,\n-                          \"cannot use `{}` because it was mutably borrowed\",\n-                          &self.bccx.loan_path_to_string(copy_path));\n-                self.bccx.span_note(\n-                    loan_span,\n-                    &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path))\n-                    );\n+                struct_span_err!(self.bccx, span, E0503,\n+                                 \"cannot use `{}` because it was mutably borrowed\",\n+                                 &self.bccx.loan_path_to_string(copy_path))\n+                    .span_note(loan_span,\n+                               &format!(\"borrow of `{}` occurs here\",\n+                                       &self.bccx.loan_path_to_string(&*loan_path))\n+                               )\n+                    .emit();\n             }\n         }\n     }\n@@ -639,24 +639,25 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                match move_kind {\n+                let mut err = match move_kind {\n                     move_data::Captured =>\n-                        span_err!(self.bccx, span, E0504,\n-                                  \"cannot move `{}` into closure because it is borrowed\",\n-                                  &self.bccx.loan_path_to_string(move_path)),\n+                        struct_span_err!(self.bccx, span, E0504,\n+                                         \"cannot move `{}` into closure because it is borrowed\",\n+                                         &self.bccx.loan_path_to_string(move_path)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n-                        span_err!(self.bccx, span, E0505,\n-                                  \"cannot move out of `{}` because it is borrowed\",\n-                                  &self.bccx.loan_path_to_string(move_path))\n+                        struct_span_err!(self.bccx, span, E0505,\n+                                         \"cannot move out of `{}` because it is borrowed\",\n+                                         &self.bccx.loan_path_to_string(move_path))\n                 };\n \n-                self.bccx.span_note(\n+                err.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n                             &self.bccx.loan_path_to_string(&*loan_path))\n                     );\n+                err.emit();\n             }\n         }\n     }\n@@ -818,12 +819,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        span_err!(self.bccx, span, E0506,\n-                  \"cannot assign to `{}` because it is borrowed\",\n-                  self.bccx.loan_path_to_string(loan_path));\n-        self.bccx.span_note(\n-            loan.span,\n-            &format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path)));\n+        struct_span_err!(self.bccx, span, E0506,\n+                         \"cannot assign to `{}` because it is borrowed\",\n+                         self.bccx.loan_path_to_string(loan_path))\n+            .span_note(loan.span,\n+                       &format!(\"borrow of `{}` occurs here\",\n+                               self.bccx.loan_path_to_string(loan_path)))\n+            .emit();\n     }\n }"}, {"sha": "4cb9673785ecb36303ffd689cec92dd222c5ce2a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -15,6 +15,7 @@ use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::errors::DiagnosticBuilder;\n use rustc_front::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -68,13 +69,14 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 errors: &Vec<MoveError<'tcx>>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n     for error in &grouped_errors {\n-        report_cannot_move_out_of(bccx, error.move_from.clone());\n+        let mut err = report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n         for move_to in &error.move_to_places {\n-            note_move_destination(bccx, move_to.span,\n+            note_move_destination(&mut err, move_to.span,\n                                   move_to.name, is_first_note);\n             is_first_note = false;\n         }\n+        err.emit();\n     }\n }\n \n@@ -112,24 +114,28 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n \n // (keep in sync with gather_moves::check_and_get_illegal_move_origin )\n fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                       move_from: mc::cmt<'tcx>) {\n+                                       move_from: mc::cmt<'tcx>)\n+                                       -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n         Categorization::Deref(_, _, mc::BorrowedPtr(..)) |\n         Categorization::Deref(_, _, mc::Implicit(..)) |\n         Categorization::Deref(_, _, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n-            span_err!(bccx, move_from.span, E0507,\n-                      \"cannot move out of {}\",\n-                      move_from.descriptive_string(bccx.tcx));\n+            struct_span_err!(bccx, move_from.span, E0507,\n+                             \"cannot move out of {}\",\n+                             move_from.descriptive_string(bccx.tcx))\n         }\n \n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n             let expr = bccx.tcx.map.expect_expr(move_from.id);\n             if let hir::ExprIndex(..) = expr.node {\n-                span_err!(bccx, move_from.span, E0508,\n-                          \"cannot move out of type `{}`, \\\n-                           a non-copy fixed-size array\",\n-                          b.ty);\n+                struct_span_err!(bccx, move_from.span, E0508,\n+                                 \"cannot move out of type `{}`, \\\n+                                  a non-copy fixed-size array\",\n+                                 b.ty)\n+            } else {\n+                bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n+                unreachable!();\n             }\n         }\n \n@@ -138,39 +144,41 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n                 ty::TyEnum(def, _) if def.has_dtor() => {\n-                    span_err!(bccx, move_from.span, E0509,\n-                              \"cannot move out of type `{}`, \\\n-                               which defines the `Drop` trait\",\n-                              b.ty);\n+                    struct_span_err!(bccx, move_from.span, E0509,\n+                                     \"cannot move out of type `{}`, \\\n+                                      which defines the `Drop` trait\",\n+                                     b.ty)\n                 },\n                 _ => {\n-                    bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+                    bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n+                    unreachable!();\n                 }\n             }\n         }\n         _ => {\n-            bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+            bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n+            unreachable!();\n         }\n     }\n }\n \n-fn note_move_destination(bccx: &BorrowckCtxt,\n+fn note_move_destination(err: &mut DiagnosticBuilder,\n                          move_to_span: codemap::Span,\n                          pat_name: ast::Name,\n                          is_first_note: bool) {\n     if is_first_note {\n-        bccx.span_note(\n+        err.span_note(\n             move_to_span,\n             \"attempting to move value to here\");\n-        bccx.fileline_help(\n+        err.fileline_help(\n             move_to_span,\n             &format!(\"to prevent the move, \\\n-                     use `ref {0}` or `ref mut {0}` to capture value by \\\n-                     reference\",\n-                    pat_name));\n+                      use `ref {0}` or `ref mut {0}` to capture value by \\\n+                      reference\",\n+                     pat_name));\n     } else {\n-        bccx.span_note(move_to_span,\n-                       &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n+        err.span_note(move_to_span,\n+                      &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n                                pat_name));\n     }\n }"}, {"sha": "0a2586755cef429dc6f5444e223cf342fba473b4", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -40,6 +40,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n \n use rustc_front::hir;\n use rustc_front::hir::{FnDecl, Block};\n@@ -591,10 +592,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n \n         // General fallback.\n-        self.span_err(\n+        let mut db = self.struct_span_err(\n             err.span,\n             &self.bckerr_to_string(&err));\n-        self.note_and_explain_bckerr(err);\n+        self.note_and_explain_bckerr(&mut db, err);\n+        db.emit();\n     }\n \n     pub fn report_use_of_moved_value<'b>(&self,\n@@ -609,16 +611,17 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             MovedInCapture => \"capture\",\n         };\n \n-        let (ol, moved_lp_msg) = match the_move.kind {\n+        let (ol, moved_lp_msg, mut err) = match the_move.kind {\n             move_data::Declared => {\n-                span_err!(\n+                let err = struct_span_err!(\n                     self.tcx.sess, use_span, E0381,\n                     \"{} of possibly uninitialized variable: `{}`\",\n                     verb,\n                     self.loan_path_to_string(lp));\n \n                 (self.loan_path_to_string(moved_lp),\n-                 String::new())\n+                 String::new(),\n+                 err)\n             }\n             _ => {\n                 // If moved_lp is something like `x.a`, and lp is something like `x.b`, we would\n@@ -653,11 +656,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n                           else { \"\" };\n-                span_err!(\n+                let err = struct_span_err!(\n                     self.tcx.sess, use_span, E0382,\n                     \"{} of {}moved value: `{}`\",\n                     verb, msg, nl);\n-                (ol, moved_lp_msg)\n+                (ol, moved_lp_msg, err)\n             }\n         };\n \n@@ -684,15 +687,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 // multiple times. Avoid printing the same span and adjust the wording so it makes\n                 // more sense that it's from multiple evalutations.\n                 if expr_span == use_span {\n-                    self.tcx.sess.note(\n+                    err.note(\n                         &format!(\"`{}` was previously moved here{} because it has type `{}`, \\\n                                   which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n                                  expr_ty,\n                                  suggestion));\n                 } else {\n-                    self.tcx.sess.span_note(\n+                    err.span_note(\n                         expr_span,\n                         &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                                  ol,\n@@ -705,22 +708,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::MovePat => {\n                 let pat_ty = self.tcx.node_id_to_type(the_move.id);\n                 let span = self.tcx.map.span(the_move.id);\n-                self.tcx.sess.span_note(span,\n+                err.span_note(span,\n                     &format!(\"`{}` moved here{} because it has type `{}`, \\\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n                             pat_ty));\n                 match self.tcx.sess.codemap().span_to_snippet(span) {\n                     Ok(string) => {\n-                        self.tcx.sess.span_suggestion(\n+                        err.span_suggestion(\n                             span,\n                             &format!(\"if you would like to borrow the value instead, \\\n                                       use a `ref` binding as shown:\"),\n                             format!(\"ref {}\", string));\n                     },\n                     Err(_) => {\n-                        self.tcx.sess.fileline_help(span,\n+                        err.fileline_help(span,\n                             \"use `ref` to override\");\n                     },\n                 }\n@@ -746,17 +749,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                     expr_ty,\n                                     (\"moved by default\",\n                                      \"make a copy and capture that instead to override\"));\n-                self.tcx.sess.span_note(\n+                err.span_note(\n                     expr_span,\n                     &format!(\"`{}` moved into closure environment here{} because it \\\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n                             moved_lp.ty,\n                             suggestion));\n-                self.tcx.sess.fileline_help(expr_span, help);\n+                err.fileline_help(expr_span, help);\n             }\n         }\n+        err.emit();\n \n         fn move_suggestion<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n                                     span: Span,\n@@ -791,35 +795,36 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n-        span_err!(\n+        struct_span_err!(\n             self.tcx.sess, span, E0384,\n             \"re-assignment of immutable variable `{}`\",\n-            self.loan_path_to_string(lp));\n-        self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n+            self.loan_path_to_string(lp))\n+            .span_note(assign.span, \"prior assignment occurs here\")\n+            .emit();\n     }\n \n     pub fn span_err(&self, s: Span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    pub fn span_err_with_code(&self, s: Span, msg: &str, code: &str) {\n-        self.tcx.sess.span_err_with_code(s, msg, code);\n+    pub fn struct_span_err(&self, s: Span, m: &str) -> DiagnosticBuilder<'a> {\n+        self.tcx.sess.struct_span_err(s, m)\n     }\n \n-    pub fn span_bug(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_bug(s, m);\n-    }\n-\n-    pub fn span_note(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_note(s, m);\n+    pub fn struct_span_err_with_code(&self,\n+                                     s: Span,\n+                                     msg: &str,\n+                                     code: &str)\n+                                     -> DiagnosticBuilder<'a> {\n+        self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    pub fn span_end_note(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_end_note(s, m);\n+    pub fn span_err_with_code(&self, s: Span, msg: &str, code: &str) {\n+        self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    pub fn fileline_help(&self, s: Span, m: &str) {\n-        self.tcx.sess.fileline_help(s, m);\n+    pub fn span_bug(&self, s: Span, m: &str) {\n+        self.tcx.sess.span_bug(s, m);\n     }\n \n     pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n@@ -913,51 +918,52 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         };\n \n-        match cause {\n+        let mut err = match cause {\n             mc::AliasableOther => {\n-                span_err!(\n+                struct_span_err!(\n                     self.tcx.sess, span, E0385,\n-                    \"{} in an aliasable location\", prefix);\n+                    \"{} in an aliasable location\", prefix)\n             }\n             mc::AliasableReason::UnaliasableImmutable => {\n-                span_err!(\n+                struct_span_err!(\n                     self.tcx.sess, span, E0386,\n-                    \"{} in an immutable container\", prefix);\n+                    \"{} in an immutable container\", prefix)\n             }\n             mc::AliasableClosure(id) => {\n-                span_err!(\n+                let mut err = struct_span_err!(\n                     self.tcx.sess, span, E0387,\n                     \"{} in a captured outer variable in an `Fn` closure\", prefix);\n                 if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n                     // be `FnMut`.\n-                    span_help!(self.tcx.sess, self.tcx.map.span(id),\n+                    span_help!(&mut err, self.tcx.map.span(id),\n                            \"consider changing this to accept closures that implement `FnMut`\");\n                 } else {\n-                    span_help!(self.tcx.sess, self.tcx.map.span(id),\n+                    span_help!(&mut err, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n                 }\n+                err\n             }\n             mc::AliasableStatic |\n             mc::AliasableStaticMut => {\n-                span_err!(\n+                struct_span_err!(\n                     self.tcx.sess, span, E0388,\n-                    \"{} in a static location\", prefix);\n+                    \"{} in a static location\", prefix)\n             }\n             mc::AliasableBorrowed => {\n-                span_err!(\n+                struct_span_err!(\n                     self.tcx.sess, span, E0389,\n-                    \"{} in a `&` reference\", prefix);\n+                    \"{} in a `&` reference\", prefix)\n             }\n-        }\n+        };\n \n         if is_closure {\n-            self.tcx.sess.fileline_help(\n-                span,\n-                \"closures behind references must be called via `&mut`\");\n+            err.fileline_help(span,\n+                              \"closures behind references must be called via `&mut`\");\n         }\n+        err.emit();\n     }\n \n     fn report_out_of_scope_escaping_closure_capture(&self,\n@@ -966,34 +972,30 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     {\n         let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n \n-        span_err!(\n-            self.tcx.sess, err.span, E0373,\n-            \"closure may outlive the current function, \\\n-             but it borrows {}, \\\n-             which is owned by the current function\",\n-            cmt_path_or_string);\n-\n-        self.tcx.sess.span_note(\n-            capture_span,\n-            &format!(\"{} is borrowed here\",\n-                     cmt_path_or_string));\n-\n         let suggestion =\n             match self.tcx.sess.codemap().span_to_snippet(err.span) {\n                 Ok(string) => format!(\"move {}\", string),\n                 Err(_) => format!(\"move |<args>| <body>\")\n             };\n \n-        self.tcx.sess.span_suggestion(\n-            err.span,\n-            &format!(\"to force the closure to take ownership of {} \\\n-                      (and any other referenced variables), \\\n-                      use the `move` keyword, as shown:\",\n-                     cmt_path_or_string),\n-            suggestion);\n+        struct_span_err!(self.tcx.sess, err.span, E0373,\n+                         \"closure may outlive the current function, \\\n+                          but it borrows {}, \\\n+                          which is owned by the current function\",\n+                         cmt_path_or_string)\n+            .span_note(capture_span,\n+                       &format!(\"{} is borrowed here\",\n+                                cmt_path_or_string))\n+            .span_suggestion(err.span,\n+                             &format!(\"to force the closure to take ownership of {} \\\n+                                       (and any other referenced variables), \\\n+                                       use the `move` keyword, as shown:\",\n+                                      cmt_path_or_string),\n+                             suggestion)\n+            .emit();\n     }\n \n-    pub fn note_and_explain_bckerr(&self, err: BckError<'tcx>) {\n+    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n         let code = err.code;\n         match code {\n             err_mutbl => {\n@@ -1007,7 +1009,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             _ => unreachable!()\n                         };\n                         if kind == ty::FnClosureKind {\n-                            self.tcx.sess.span_help(\n+                            db.span_help(\n                                 self.tcx.map.span(upvar_id.closure_expr_id),\n                                 \"consider changing this closure to take \\\n                                  self by mutable reference\");\n@@ -1017,7 +1019,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let Categorization::Local(local_id) = err.cmt.cat {\n                             let span = self.tcx.map.span(local_id);\n                             if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                                self.tcx.sess.span_suggestion(\n+                                db.span_suggestion(\n                                     span,\n                                     &format!(\"to make the {} mutable, use `mut` as shown:\",\n                                              self.cmt_to_string(&err.cmt)),\n@@ -1030,16 +1032,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             err_out_of_scope(super_scope, sub_scope) => {\n                 self.tcx.note_and_explain_region(\n+                    db,\n                     \"reference must be valid for \",\n                     sub_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n+                    db,\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n                 if let Some(span) = statement_scope_span(self.tcx, super_scope) {\n-                    self.tcx.sess.span_help(span,\n-                        \"consider using a `let` binding to increase its lifetime\");\n+                    db.span_help(span,\n+                                 \"consider using a `let` binding to increase its lifetime\");\n                 }\n             }\n \n@@ -1051,11 +1055,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => self.cmt_to_string(&*err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n+                    db,\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n+                    db,\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n                     \"\");"}, {"sha": "27740b8fc5cf9a390145da6a5c7f8482078b3d02", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -1001,8 +1001,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                              None\n                          }\n                          _ => {\n-                             session.span_err(a.span, \"`crate_type` requires a value\");\n-                             session.note(\"for example: `#![crate_type=\\\"lib\\\"]`\");\n+                             session.struct_span_err(a.span, \"`crate_type` requires a value\")\n+                                 .note(\"for example: `#![crate_type=\\\"lib\\\"]`\")\n+                                 .emit();\n                              None\n                          }\n                      }"}, {"sha": "7bcf3276da7a450693eb3994a5d628b66d838536", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -60,7 +60,7 @@ struct ExpectErrorEmitter {\n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n         Level::Bug | Level::Fatal | Level::Error => {}\n-        Level::Warning | Level::Note | Level::Help => {\n+        _ => {\n             return;\n         }\n     }"}, {"sha": "09e6f454fb4f51c5ffaccba9fdccff42e83da4b7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -752,19 +752,19 @@ impl LateLintPass for UnconditionalRecursion {\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n-                         \"function cannot return without recurring\");\n+            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION, sp,\n+                                             \"function cannot return without recurring\");\n \n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n             if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n-                let sess = cx.sess();\n                 // offer some help to the programmer.\n                 for call in &self_call_spans {\n-                    sess.span_note(*call, \"recursive call site\")\n+                    db.span_note(*call, \"recursive call site\");\n                 }\n-                sess.fileline_help(sp, \"a `loop` may express intention \\\n-                                        better if this is on purpose\")\n+                db.fileline_help(sp, \"a `loop` may express intention \\\n+                                      better if this is on purpose\");\n             }\n+            db.emit();\n         }\n \n         // all done"}, {"sha": "9122148a8cc05ff9dc37f7927feb4fb742e3bc16", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -35,6 +35,7 @@ use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n+use syntax::errors::FatalError;\n use syntax::parse::token::InternedString;\n use syntax::util::small_vector::SmallVector;\n use rustc_front::intravisit::Visitor;\n@@ -504,7 +505,10 @@ impl<'a> CrateReader<'a> {\n                 let lo = p.span.lo;\n                 let body = match p.parse_all_token_trees() {\n                     Ok(body) => body,\n-                    Err(err) => panic!(err),\n+                    Err(mut err) => {\n+                        err.emit();\n+                        panic!(FatalError);\n+                    }\n                 };\n                 let span = mk_sp(lo, p.last_span.hi);\n                 p.abort_if_errors();"}, {"sha": "40665beaa5ac2698b08c92e6107ad139cef5ff17", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -226,7 +226,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use syntax::codemap::Span;\n-use syntax::errors::Handler;\n+use syntax::errors::DiagnosticBuilder;\n use rustc_back::target::Target;\n \n use std::cmp;\n@@ -315,62 +315,64 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\" which `{}` depends on\",\n                                     r.ident)\n         };\n-        if !self.rejected_via_hash.is_empty() {\n-            span_err!(self.sess, self.span, E0460,\n-                      \"found possibly newer version of crate `{}`{}\",\n-                      self.ident, add);\n+        let mut err = if !self.rejected_via_hash.is_empty() {\n+            struct_span_err!(self.sess, self.span, E0460,\n+                             \"found possibly newer version of crate `{}`{}\",\n+                             self.ident, add)\n         } else if !self.rejected_via_triple.is_empty() {\n-            span_err!(self.sess, self.span, E0461,\n-                      \"couldn't find crate `{}` with expected target triple {}{}\",\n-                      self.ident, self.triple, add);\n+            struct_span_err!(self.sess, self.span, E0461,\n+                             \"couldn't find crate `{}` with expected target triple {}{}\",\n+                             self.ident, self.triple, add)\n         } else if !self.rejected_via_kind.is_empty() {\n-            span_err!(self.sess, self.span, E0462,\n-                      \"found staticlib `{}` instead of rlib or dylib{}\",\n-                      self.ident, add);\n+            struct_span_err!(self.sess, self.span, E0462,\n+                             \"found staticlib `{}` instead of rlib or dylib{}\",\n+                             self.ident, add)\n         } else {\n-            span_err!(self.sess, self.span, E0463,\n-                      \"can't find crate for `{}`{}\",\n-                      self.ident, add);\n-        }\n+            struct_span_err!(self.sess, self.span, E0463,\n+                             \"can't find crate for `{}`{}\",\n+                             self.ident, add)\n+        };\n \n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n-                self.sess.fileline_note(self.span,\n+                err.fileline_note(self.span,\n                     &format!(\"crate `{}`, path #{}, triple {}: {}\",\n                             self.ident, i+1, got, path.display()));\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n-            self.sess.span_note(self.span, \"perhaps this crate needs \\\n+            err.span_note(self.span, \"perhaps this crate needs \\\n                                             to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n-                self.sess.fileline_note(self.span,\n+                err.fileline_note(self.span,\n                     &format!(\"crate `{}` path #{}: {}\",\n                             self.ident, i+1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n-                        self.sess.fileline_note(self.span,\n+                        err.fileline_note(self.span,\n                             &format!(\"crate `{}` path #{}: {}\",\n                                     r.ident, i+1, path.display()));\n                     }\n                 }\n             }\n         }\n         if !self.rejected_via_kind.is_empty() {\n-            self.sess.fileline_help(self.span, \"please recompile this crate using \\\n-                                            --crate-type lib\");\n+            err.fileline_help(self.span, \"please recompile this crate using \\\n+                                          --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n-                self.sess.fileline_note(self.span,\n-                                        &format!(\"crate `{}` path #{}: {}\",\n-                                                 self.ident, i+1, path.display()));\n+                err.fileline_note(self.span,\n+                                  &format!(\"crate `{}` path #{}: {}\",\n+                                           self.ident, i+1, path.display()));\n             }\n         }\n+\n+        err.emit();\n         self.sess.abort_if_errors();\n     }\n \n@@ -480,29 +482,30 @@ impl<'a> Context<'a> {\n             0 => None,\n             1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n-                span_err!(self.sess, self.span, E0464,\n-                          \"multiple matching crates for `{}`\",\n-                          self.crate_name);\n-                self.sess.note(\"candidates:\");\n+                let mut err = struct_span_err!(self.sess, self.span, E0464,\n+                                               \"multiple matching crates for `{}`\",\n+                                               self.crate_name);\n+                err.note(\"candidates:\");\n                 for lib in &libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n-                            self.sess.note(&format!(\"path: {}\",\n-                                                   p.display()));\n+                            err.note(&format!(\"path: {}\",\n+                                              p.display()));\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some((ref p, _)) => {\n-                            self.sess.note(&format!(\"path: {}\",\n-                                                    p.display()));\n+                            err.note(&format!(\"path: {}\",\n+                                              p.display()));\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), &name);\n+                    note_crate_name(&mut err, &name);\n                 }\n+                err.emit();\n                 None\n             }\n         }\n@@ -533,6 +536,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n+        let mut err: Option<DiagnosticBuilder> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.target, &lib) {\n@@ -555,27 +559,37 @@ impl<'a> Context<'a> {\n             // candidates have the same hash, so they're not actually\n             // duplicates that we should warn about.\n             if ret.is_some() && self.hash.is_none() {\n-                span_err!(self.sess, self.span, E0465,\n-                          \"multiple {} candidates for `{}` found\",\n-                          flavor, self.crate_name);\n-                self.sess.span_note(self.span,\n-                                    &format!(r\"candidate #1: {}\",\n-                                            ret.as_ref().unwrap().0\n-                                               .display()));\n+                let mut e = struct_span_err!(self.sess, self.span, E0465,\n+                                             \"multiple {} candidates for `{}` found\",\n+                                             flavor, self.crate_name);\n+                e.span_note(self.span,\n+                            &format!(r\"candidate #1: {}\",\n+                                     ret.as_ref().unwrap().0\n+                                        .display()));\n+                if let Some(ref mut e) = err {\n+                    e.emit();\n+                }\n+                err = Some(e);\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n-                self.sess.span_note(self.span,\n-                                    &format!(r\"candidate #{}: {}\", error,\n-                                            lib.display()));\n+                err.as_mut().unwrap().span_note(self.span,\n+                                                &format!(r\"candidate #{}: {}\", error,\n+                                                         lib.display()));\n                 continue\n             }\n             *slot = Some(metadata);\n             ret = Some((lib, kind));\n         }\n-        return if error > 0 {None} else {ret}\n+\n+        if error > 0 {\n+            err.unwrap().emit();\n+            None\n+        } else {\n+            ret\n+        }\n     }\n \n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n@@ -662,10 +676,11 @@ impl<'a> Context<'a> {\n                         return true\n                     }\n                 }\n-                sess.err(&format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display()));\n-                sess.help(&format!(\"file name should be lib*.rlib or {}*.{}\",\n-                                   dylibname.0, dylibname.1));\n+                sess.struct_err(&format!(\"extern location for {} is of an unknown type: {}\",\n+                                         self.crate_name, loc.display()))\n+                    .help(&format!(\"file name should be lib*.rlib or {}*.{}\",\n+                                   dylibname.0, dylibname.1))\n+                    .emit();\n                 false\n             });\n \n@@ -699,8 +714,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crate_name(diag: &Handler, name: &str) {\n-    diag.note(&format!(\"crate name: {}\", name));\n+pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n+    err.note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "5adde4304f57c9541b56f76523f0be4655863cb1", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -46,10 +46,11 @@ pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n             Some(node_id)\n         },\n         _ => {\n-            diagnostic.err(\"multiple plugin registration functions found\");\n+            let mut e = diagnostic.struct_err(\"multiple plugin registration functions found\");\n             for &(_, span) in &finder.registrars {\n-                diagnostic.span_note(span, \"one is here\");\n+                e.span_note(span, \"one is here\");\n             }\n+            e.emit();\n             diagnostic.abort_if_errors();\n             unreachable!();\n         }"}, {"sha": "1cc2482a39e2787c957fd0762cf45cd5990d5cc1", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -597,13 +597,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, &msg[..]);\n-                match note {\n-                    Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, &msg[..])\n-                    }\n-                    None => {},\n+                let mut err = self.tcx.sess.struct_span_err(span, &msg[..]);\n+                if let Some((span, msg)) = note {\n+                    err.span_note(span, &msg[..]);\n                 }\n+                err.emit();\n                 false\n             },\n         }\n@@ -1028,10 +1026,12 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     fn check_sane_privacy(&self, item: &hir::Item) {\n         let check_inherited = |sp, vis, note: &str| {\n             if vis != hir::Inherited {\n-                span_err!(self.tcx.sess, sp, E0449, \"unnecessary visibility qualifier\");\n+                let mut err = struct_span_err!(self.tcx.sess, sp, E0449,\n+                                               \"unnecessary visibility qualifier\");\n                 if !note.is_empty() {\n-                    self.tcx.sess.span_note(sp, note);\n+                    err.span_note(sp, note);\n                 }\n+                err.emit();\n             }\n         };\n "}, {"sha": "1d3f2b79844ea0094120458537cc139239d58055", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -24,7 +24,7 @@ use {names_to_string, module_to_string};\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n-use {resolve_error, ResolutionError};\n+use {resolve_error, resolve_struct_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n \n@@ -137,12 +137,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Record an error here by looking up the namespace that had the duplicate\n                 let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n-                resolve_error(self, sp, ResolutionError::DuplicateDefinition(ns_str, name));\n+                let mut err = resolve_struct_error(self,\n+                                                   sp,\n+                                                   ResolutionError::DuplicateDefinition(ns_str,\n+                                                                                        name));\n \n                 if let Some(sp) = child[ns].span() {\n                     let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n-                    self.session.span_note(sp, &note);\n+                    err.span_note(sp, &note);\n                 }\n+                err.emit();\n                 child\n             }\n         }\n@@ -253,13 +257,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     })\n                                                     .collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            resolve_error(self,\n+                            let mut e = resolve_struct_error(self,\n                                           mod_spans[0],\n                                           ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n                             for other_span in mod_spans.iter().skip(1) {\n-                                self.session\n-                                    .span_note(*other_span, \"another `self` import appears here\");\n+                                e.span_note(*other_span, \"another `self` import appears here\");\n                             }\n+                            e.emit();\n                         }\n \n                         for source_item in source_items {"}, {"sha": "5a17f2528c85b1aec723b921324e8c195a8ba41d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 217, "deletions": 202, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -63,8 +63,9 @@ use syntax::ast;\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::{self, special_names, special_idents};\n use syntax::codemap::{self, Span, Pos};\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::parse::token::{self, special_names, special_idents};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, FnKind, Visitor};\n@@ -215,210 +216,221 @@ pub enum UnresolvedNameContext {\n fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                        span: syntax::codemap::Span,\n                                        resolution_error: ResolutionError<'b>) {\n+    resolve_struct_error(resolver, span, resolution_error).emit();\n+}\n+\n+fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n+                                              span: syntax::codemap::Span,\n+                                              resolution_error: ResolutionError<'b>)\n+                                              -> DiagnosticBuilder<'a> {\n     if !resolver.emit_errors {\n-        return;\n+        return resolver.session.diagnostic().struct_dummy();\n     }\n+\n     match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0401,\n-                      \"can't use type parameters from outer function; try using a local type \\\n-                       parameter instead\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0401,\n+                             \"can't use type parameters from outer function; try using a local \\\n+                              type parameter instead\")\n         }\n         ResolutionError::OuterTypeParameterContext => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0402,\n-                      \"cannot use an outer type parameter in this context\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0402,\n+                             \"cannot use an outer type parameter in this context\")\n         }\n         ResolutionError::NameAlreadyUsedInTypeParameterList(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0403,\n-                      \"the name `{}` is already used for a type parameter in this type parameter \\\n-                       list\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0403,\n+                             \"the name `{}` is already used for a type parameter in this type \\\n+                              parameter list\",\n+                             name)\n         }\n         ResolutionError::IsNotATrait(name) => {\n-            span_err!(resolver.session, span, E0404, \"`{}` is not a trait\", name);\n+            struct_span_err!(resolver.session, span, E0404, \"`{}` is not a trait\", name)\n         }\n         ResolutionError::UndeclaredTraitName(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0405,\n-                      \"use of undeclared trait name `{}`\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0405,\n+                             \"use of undeclared trait name `{}`\",\n+                             name)\n         }\n         ResolutionError::UndeclaredAssociatedType => {\n-            span_err!(resolver.session, span, E0406, \"undeclared associated type\");\n+            struct_span_err!(resolver.session, span, E0406, \"undeclared associated type\")\n         }\n         ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0407,\n-                      \"method `{}` is not a member of trait `{}`\",\n-                      method,\n-                      trait_);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0407,\n+                             \"method `{}` is not a member of trait `{}`\",\n+                             method,\n+                             trait_)\n         }\n         ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0437,\n-                      \"type `{}` is not a member of trait `{}`\",\n-                      type_,\n-                      trait_);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0437,\n+                             \"type `{}` is not a member of trait `{}`\",\n+                             type_,\n+                             trait_)\n         }\n         ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0438,\n-                      \"const `{}` is not a member of trait `{}`\",\n-                      const_,\n-                      trait_);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0438,\n+                             \"const `{}` is not a member of trait `{}`\",\n+                             const_,\n+                             trait_)\n         }\n         ResolutionError::VariableNotBoundInPattern(variable_name, pattern_number) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0408,\n-                      \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n-                      variable_name,\n-                      pattern_number);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0408,\n+                             \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n+                             variable_name,\n+                             pattern_number)\n         }\n         ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0409,\n-                      \"variable `{}` is bound with different mode in pattern #{} than in pattern \\\n-                       #1\",\n-                      variable_name,\n-                      pattern_number);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0409,\n+                             \"variable `{}` is bound with different mode in pattern #{} than in \\\n+                              pattern #1\",\n+                             variable_name,\n+                             pattern_number)\n         }\n         ResolutionError::VariableNotBoundInParentPattern(variable_name, pattern_number) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0410,\n-                      \"variable `{}` from pattern #{} is not bound in pattern #1\",\n-                      variable_name,\n-                      pattern_number);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0410,\n+                             \"variable `{}` from pattern #{} is not bound in pattern #1\",\n+                             variable_name,\n+                             pattern_number)\n         }\n         ResolutionError::SelfUsedOutsideImplOrTrait => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0411,\n-                      \"use of `Self` outside of an impl or trait\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0411,\n+                             \"use of `Self` outside of an impl or trait\")\n         }\n         ResolutionError::UseOfUndeclared(kind, name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0412,\n-                      \"use of undeclared {} `{}`\",\n-                      kind,\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0412,\n+                             \"use of undeclared {} `{}`\",\n+                             kind,\n+                             name)\n         }\n         ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0413,\n-                      \"declaration of `{}` shadows an enum variant or unit-like struct in scope\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0413,\n+                             \"declaration of `{}` shadows an enum variant \\\n+                              or unit-like struct in scope\",\n+                             name)\n         }\n         ResolutionError::OnlyIrrefutablePatternsAllowedHere(did, name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0414,\n-                      \"only irrefutable patterns allowed here\");\n-            resolver.session.span_note(span,\n-                                       \"there already is a constant in scope sharing the same \\\n-                                        name as this pattern\");\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0414,\n+                                           \"only irrefutable patterns allowed here\");\n+            err.span_note(span,\n+                          \"there already is a constant in scope sharing the same \\\n+                           name as this pattern\");\n             if let Some(sp) = resolver.ast_map.span_if_local(did) {\n-                resolver.session.span_note(sp, \"constant defined here\");\n+                err.span_note(sp, \"constant defined here\");\n             }\n             if let Some(directive) = resolver.current_module\n                                              .import_resolutions\n                                              .borrow()\n                                              .get(&name) {\n                 let item = resolver.ast_map.expect_item(directive.value_ns.id);\n-                resolver.session.span_note(item.span, \"constant imported here\");\n+                err.span_note(item.span, \"constant imported here\");\n             }\n+            err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0415,\n-                      \"identifier `{}` is bound more than once in this parameter list\",\n-                      identifier);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0415,\n+                             \"identifier `{}` is bound more than once in this parameter list\",\n+                             identifier)\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0416,\n-                      \"identifier `{}` is bound more than once in the same pattern\",\n-                      identifier);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0416,\n+                             \"identifier `{}` is bound more than once in the same pattern\",\n+                             identifier)\n         }\n         ResolutionError::StaticVariableReference => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0417,\n-                      \"static variables cannot be referenced in a pattern, use a `const` instead\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0417,\n+                             \"static variables cannot be referenced in a pattern, use a \\\n+                              `const` instead\")\n         }\n         ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0418,\n-                      \"`{}` is not an enum variant, struct or const\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0418,\n+                             \"`{}` is not an enum variant, struct or const\",\n+                             name)\n         }\n         ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0419,\n-                      \"unresolved enum variant, struct or const `{}`\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0419,\n+                             \"unresolved enum variant, struct or const `{}`\",\n+                             name)\n         }\n         ResolutionError::NotAnAssociatedConst(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0420,\n-                      \"`{}` is not an associated const\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0420,\n+                             \"`{}` is not an associated const\",\n+                             name)\n         }\n         ResolutionError::UnresolvedAssociatedConst(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0421,\n-                      \"unresolved associated const `{}`\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0421,\n+                             \"unresolved associated const `{}`\",\n+                             name)\n         }\n         ResolutionError::DoesNotNameAStruct(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0422,\n-                      \"`{}` does not name a structure\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0422,\n+                             \"`{}` does not name a structure\",\n+                             name)\n         }\n         ResolutionError::StructVariantUsedAsFunction(path_name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0423,\n-                      \"`{}` is the name of a struct or struct variant, but this expression uses \\\n-                       it like a function name\",\n-                      path_name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0423,\n+                             \"`{}` is the name of a struct or struct variant, but this expression \\\n+                             uses it like a function name\",\n+                             path_name)\n         }\n         ResolutionError::SelfNotAvailableInStaticMethod => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0424,\n-                      \"`self` is not available in a static method. Maybe a `self` argument is \\\n-                       missing?\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0424,\n+                             \"`self` is not available in a static method. Maybe a `self` \\\n+                             argument is missing?\")\n         }\n         ResolutionError::UnresolvedName(path, msg, context) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0425,\n-                      \"unresolved name `{}`{}\",\n-                      path,\n-                      msg);\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0425,\n+                                           \"unresolved name `{}`{}\",\n+                                           path,\n+                                           msg);\n \n             match context {\n                 UnresolvedNameContext::Other => {} // no help available\n@@ -448,75 +460,77 @@ fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                     }\n \n                     if !help_msg.is_empty() {\n-                        resolver.session.fileline_help(span, &help_msg);\n+                        err.fileline_help(span, &help_msg);\n                     }\n                 }\n             }\n+            err\n         }\n         ResolutionError::UndeclaredLabel(name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0426,\n-                      \"use of undeclared label `{}`\",\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0426,\n+                             \"use of undeclared label `{}`\",\n+                             name)\n         }\n         ResolutionError::CannotUseRefBindingModeWith(descr) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0427,\n-                      \"cannot use `ref` binding mode with {}\",\n-                      descr);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0427,\n+                             \"cannot use `ref` binding mode with {}\",\n+                             descr)\n         }\n         ResolutionError::DuplicateDefinition(namespace, name) => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0428,\n-                      \"duplicate definition of {} `{}`\",\n-                      namespace,\n-                      name);\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0428,\n+                             \"duplicate definition of {} `{}`\",\n+                             namespace,\n+                             name)\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0429,\n-                      \"{}\",\n-                      \"`self` imports are only allowed within a { } list\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0429,\n+                             \"{}\",\n+                             \"`self` imports are only allowed within a { } list\")\n         }\n         ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0430,\n-                      \"`self` import can only appear once in the list\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0430,\n+                             \"`self` import can only appear once in the list\")\n         }\n         ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0431,\n-                      \"`self` import can only appear in an import list with a non-empty prefix\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0431,\n+                             \"`self` import can only appear in an import list with a \\\n+                              non-empty prefix\")\n         }\n         ResolutionError::UnresolvedImport(name) => {\n             let msg = match name {\n                 Some((n, p)) => format!(\"unresolved import `{}`{}\", n, p),\n                 None => \"unresolved import\".to_owned(),\n             };\n-            span_err!(resolver.session, span, E0432, \"{}\", msg);\n+            struct_span_err!(resolver.session, span, E0432, \"{}\", msg)\n         }\n         ResolutionError::FailedToResolve(msg) => {\n-            span_err!(resolver.session, span, E0433, \"failed to resolve. {}\", msg);\n+            struct_span_err!(resolver.session, span, E0433, \"failed to resolve. {}\", msg)\n         }\n         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0434,\n-                      \"{}\",\n-                      \"can't capture dynamic environment in a fn item; use the || { ... } \\\n-                       closure form instead\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0434,\n+                             \"{}\",\n+                             \"can't capture dynamic environment in a fn item; use the || { ... } \\\n+                              closure form instead\")\n         }\n         ResolutionError::AttemptToUseNonConstantValueInConstant => {\n-            span_err!(resolver.session,\n-                      span,\n-                      E0435,\n-                      \"attempt to use a non-constant value in a constant\");\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0435,\n+                             \"attempt to use a non-constant value in a constant\")\n         }\n     }\n }\n@@ -2180,16 +2194,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                resolve_error(self,\n-                              trait_path.span,\n-                              ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n-                                                                                  path_depth)));\n+                let mut err =\n+                    resolve_struct_error(self,\n+                                  trait_path.span,\n+                                  ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                                                                      path_depth)));\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n-                    self.session\n-                        .span_note(trait_path.span, \"`type` aliases cannot be used for traits\");\n+                    err.span_note(trait_path.span,\n+                                  \"`type` aliases cannot be used for traits\");\n                 }\n+                err.emit();\n                 Err(())\n             }\n         } else {\n@@ -3470,17 +3486,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n \n-                        resolve_error(self,\n-                                      expr.span,\n-                                      ResolutionError::StructVariantUsedAsFunction(&*path_name));\n+                        let mut err = resolve_struct_error(self,\n+                                        expr.span,\n+                                        ResolutionError::StructVariantUsedAsFunction(&*path_name));\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n                         if self.emit_errors {\n-                            self.session.fileline_help(expr.span, &msg);\n+                            err.fileline_help(expr.span, &msg);\n                         } else {\n-                            self.session.span_help(expr.span, &msg);\n+                            err.span_help(expr.span, &msg);\n                         }\n+                        err.emit();\n                         self.record_def(expr.id, err_path_resolution());\n                     } else {\n                         // Write the result into the def map.\n@@ -3510,20 +3527,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.record_def(expr.id, err_path_resolution());\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _)) if self.structs.contains_key(&struct_id) => {\n-                            resolve_error(\n-                                    self,\n-                                    expr.span,\n-                                    ResolutionError::StructVariantUsedAsFunction(\n-                                        &*path_name)\n-                                );\n+                            let mut err = resolve_struct_error(self,\n+                                expr.span,\n+                                ResolutionError::StructVariantUsedAsFunction(&*path_name));\n \n                             let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                               path_name);\n                             if self.emit_errors {\n-                                self.session.fileline_help(expr.span, &msg);\n+                                err.fileline_help(expr.span, &msg);\n                             } else {\n-                                self.session.span_help(expr.span, &msg);\n+                                err.span_help(expr.span, &msg);\n                             }\n+                            err.emit();\n                         }\n                         _ => {\n                             // Keep reporting some errors even if they're ignored above."}, {"sha": "40bf55efde645eb31e8d45c8fe733015a46d066a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -454,8 +454,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         let note_msg = format!(\"Consider marking `{}` as `pub` in the imported \\\n                                                 module\",\n                                                source);\n-                        span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n-                        self.resolver.session.span_note(directive.span, &note_msg);\n+                        struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n+                            .span_note(directive.span, &note_msg)\n+                            .emit();\n                         pub_err = true;\n                     }\n                     if directive.is_public && child_name_bindings.value_ns.\n@@ -479,8 +480,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n                                                source);\n-                        span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n-                        self.resolver.session.span_note(directive.span, &note_msg);\n+                        struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                            .span_note(directive.span, &note_msg)\n+                            .emit();\n                     }\n                     if !pub_err && directive.is_public && child_name_bindings.type_ns.\n                                                     defined_with(DefModifiers::PRIVATE_VARIANT) {\n@@ -959,19 +961,20 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     ValueNS => \"value\",\n                 };\n-                span_err!(self.resolver.session,\n-                          import_span,\n-                          E0252,\n-                          \"a {} named `{}` has already been imported in this module\",\n-                          ns_word,\n-                          name);\n                 let use_id = import_resolution[namespace].id;\n                 let item = self.resolver.ast_map.expect_item(use_id);\n-                // item is syntax::ast::Item;\n-                span_note!(self.resolver.session,\n+                let mut err = struct_span_err!(self.resolver.session,\n+                                               import_span,\n+                                               E0252,\n+                                               \"a {} named `{}` has already been imported \\\n+                                                in this module\",\n+                                               ns_word,\n+                                               name);\n+                span_note!(&mut err,\n                            item.span,\n                            \"previous import of `{}` here\",\n                            name);\n+                err.emit();\n             }\n             Some(_) | None => {}\n         }\n@@ -1022,14 +1025,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         match import.value_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_ns.borrow() {\n-                    span_err!(self.resolver.session,\n-                              import_span,\n-                              E0255,\n-                              \"import `{}` conflicts with value in this module\",\n-                              name);\n+                    let mut err = struct_span_err!(self.resolver.session,\n+                                                   import_span,\n+                                                   E0255,\n+                                                   \"import `{}` conflicts with \\\n+                                                    value in this module\",\n+                                                   name);\n                     if let Some(span) = value.span {\n-                        self.resolver.session.span_note(span, \"conflicting value here\");\n+                        err.span_note(span, \"conflicting value here\");\n                     }\n+                    err.emit();\n                 }\n             }\n             Some(_) | None => {}\n@@ -1045,15 +1050,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             (\"trait in this module\", \"note conflicting trait here\"),\n                         _ => (\"type in this module\", \"note conflicting type here\"),\n                     };\n-                    span_err!(self.resolver.session,\n-                              import_span,\n-                              E0256,\n-                              \"import `{}` conflicts with {}\",\n-                              name,\n-                              what);\n+                    let mut err = struct_span_err!(self.resolver.session,\n+                                                   import_span,\n+                                                   E0256,\n+                                                   \"import `{}` conflicts with {}\",\n+                                                   name,\n+                                                   what);\n                     if let Some(span) = ty.span {\n-                        self.resolver.session.span_note(span, note);\n+                        err.span_note(span, note);\n                     }\n+                    err.emit();\n                 }\n             }\n             Some(_) | None => {}"}, {"sha": "850608588234cf3ee7ccb9cc4587a5d51092cc1c", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -406,11 +406,12 @@ impl<'a> ArchiveBuilder<'a> {\n             Ok(prog) => {\n                 let o = prog.wait_with_output().unwrap();\n                 if !o.status.success() {\n-                    sess.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n-                    sess.note(&format!(\"stdout ---\\n{}\",\n-                                       str::from_utf8(&o.stdout).unwrap()));\n-                    sess.note(&format!(\"stderr ---\\n{}\",\n-                                       str::from_utf8(&o.stderr).unwrap()));\n+                    sess.struct_err(&format!(\"{:?} failed with: {}\", cmd, o.status))\n+                        .note(&format!(\"stdout ---\\n{}\",\n+                                       str::from_utf8(&o.stdout).unwrap()))\n+                        .note(&format!(\"stderr ---\\n{}\",\n+                                       str::from_utf8(&o.stderr).unwrap()))\n+                        .emit();\n                     sess.abort_if_errors();\n                 }\n                 o"}, {"sha": "8446db65a4ccb3aab6d81aa72573aa8f2b5254c7", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -817,10 +817,10 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n     ab.build();\n \n     if !all_native_libs.is_empty() {\n-        sess.note(\"link against the following native artifacts when linking against \\\n-                  this static library\");\n-        sess.note(\"the order and any duplication can be significant on some platforms, \\\n-                  and so may need to be preserved\");\n+        sess.note_without_error(\"link against the following native artifacts when linking against \\\n+                                 this static library\");\n+        sess.note_without_error(\"the order and any duplication can be significant on some \\\n+                                 platforms, and so may need to be preserved\");\n     }\n \n     for &(kind, ref lib) in &all_native_libs {\n@@ -829,7 +829,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n             NativeLibraryKind::NativeUnknown => \"library\",\n             NativeLibraryKind::NativeFramework => \"framework\",\n         };\n-        sess.note(&format!(\"{}: {}\", name, *lib));\n+        sess.note_without_error(&format!(\"{}: {}\", name, *lib));\n     }\n }\n \n@@ -902,13 +902,14 @@ fn link_natively(sess: &Session, dylib: bool,\n                     })\n             }\n             if !prog.status.success() {\n-                sess.err(&format!(\"linking with `{}` failed: {}\",\n-                                 pname,\n-                                 prog.status));\n-                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n-                sess.note(&*escape_string(&output[..]));\n+                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                         pname,\n+                                         prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(&*escape_string(&output[..]))\n+                    .emit();\n                 sess.abort_if_errors();\n             }\n             info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr[..]));"}, {"sha": "85419a072503a59ccfeb260813d13352f8c99f5d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -29,8 +29,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n            name_extra: &str,\n            output_names: &config::OutputFilenames) {\n     if sess.opts.cg.prefer_dynamic {\n-        sess.err(\"cannot prefer dynamic linking when performing LTO\");\n-        sess.note(\"only 'staticlib' and 'bin' outputs are supported with LTO\");\n+        sess.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+            .note(\"only 'staticlib' and 'bin' outputs are supported with LTO\")\n+            .emit();\n         sess.abort_if_errors();\n     }\n "}, {"sha": "9d0a83fe3635046e7828db0f438209356d3c74b3", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -359,8 +359,9 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n         }\n \n         None => {\n-            cgcx.handler.err(msg);\n-            cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n+            cgcx.handler.struct_err(msg)\n+                        .note(\"build without -C codegen-units for more exact errors\")\n+                        .emit();\n         }\n     }\n }\n@@ -397,11 +398,11 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n             if enabled {\n                 let loc = llvm::debug_loc_to_string(llcx, opt.debug_loc);\n-                cgcx.handler.note(&format!(\"optimization {} for {} at {}: {}\",\n-                                           opt.kind.describe(),\n-                                           pass_name,\n-                                           if loc.is_empty() { \"[unknown]\" } else { &*loc },\n-                                           llvm::twine_to_string(opt.message)));\n+                cgcx.handler.note_without_error(&format!(\"optimization {} for {} at {}: {}\",\n+                                                opt.kind.describe(),\n+                                                pass_name,\n+                                                if loc.is_empty() { \"[unknown]\" } else { &*loc },\n+                                                llvm::twine_to_string(opt.message)));\n             }\n         }\n \n@@ -931,13 +932,15 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     match cmd.output() {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(&format!(\"linking with `{}` failed: {}\",\n-                                 pname,\n-                                 prog.status));\n-                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut note = prog.stderr.clone();\n                 note.extend_from_slice(&prog.stdout);\n-                sess.note(str::from_utf8(&note[..]).unwrap());\n+\n+                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                         pname,\n+                                         prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(str::from_utf8(&note[..]).unwrap())\n+                    .emit();\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "996e72bdad3250e55adc87a102e26125c5c13f9f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -2181,17 +2181,20 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n             }\n     );\n \n+    // FIXME(#30505) Should use logging for this.\n     if print_info {\n         let llty = type_of::sizing_type_of(ccx, ty);\n \n         let sess = &ccx.tcx().sess;\n-        sess.span_note(sp, &*format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n+        sess.span_note_without_error(sp,\n+                                     &*format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n         match *avar {\n             adt::General(..) => {\n                 for (i, var) in enum_def.variants.iter().enumerate() {\n                     ccx.tcx()\n                        .sess\n-                       .span_note(var.span, &*format!(\"variant data: {} bytes\", sizes[i]));\n+                       .span_note_without_error(var.span,\n+                                                &*format!(\"variant data: {} bytes\", sizes[i]));\n                 }\n             }\n             _ => {}\n@@ -2203,16 +2206,16 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n     if !is_allow && largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n-        lint::raw_emit_lint(&ccx.tcx().sess,\n-                            lint::builtin::VARIANT_SIZE_DIFFERENCES,\n-                            *lvlsrc.unwrap(),\n-                            Some(sp),\n-                            &format!(\"enum variant is more than three times larger ({} bytes) \\\n-                                      than the next largest (ignoring padding)\",\n-                                     largest));\n-\n-        ccx.sess().span_note(enum_def.variants[largest_index].span,\n-                             \"this variant is the largest\");\n+        lint::raw_struct_lint(&ccx.tcx().sess,\n+                              lint::builtin::VARIANT_SIZE_DIFFERENCES,\n+                              *lvlsrc.unwrap(),\n+                              Some(sp),\n+                              &format!(\"enum variant is more than three times larger ({} bytes) \\\n+                                        than the next largest (ignoring padding)\",\n+                                       largest))\n+            .span_note(enum_def.variants[largest_index].span,\n+                       \"this variant is the largest\")\n+            .emit();\n     }\n }\n \n@@ -2489,9 +2492,10 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n         let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n \n         let llfn = declare::define_cfn(ccx, \"main\", llfty, ccx.tcx().mk_nil()).unwrap_or_else(|| {\n-            ccx.sess().span_err(sp, \"entry symbol `main` defined multiple times\");\n             // FIXME: We should be smart and show a better diagnostic here.\n-            ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");\n+            ccx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+                      .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n+                      .emit();\n             ccx.sess().abort_if_errors();\n             panic!();\n         });"}, {"sha": "e6ad5ac4f063a90b7a86a933254245f05b992dfc", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -460,12 +460,13 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &hir::FnDecl, ty: &ty::BareFnTy) {\n     if !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n             if ty.is_simd() {\n-                tcx.sess.span_err(ast_ty.span,\n+                tcx.sess.struct_span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty)));\n-                tcx.sess.fileline_help(ast_ty.span,\n-                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\");\n+                                       pprust::ty_to_string(ast_ty)))\n+                    .fileline_help(ast_ty.span,\n+                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                    .emit();\n             }\n         };\n         let sig = &ty.sig.0;"}, {"sha": "751c18dfbc43d97945cc949a250535db2f8067c8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -68,6 +68,7 @@ use util::nodemap::FnvHashSet;\n \n use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n+use syntax::errors::DiagnosticBuilder;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token;\n \n@@ -195,7 +196,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n }\n \n fn report_elision_failure(\n-    tcx: &ty::ctxt,\n+    db: &mut DiagnosticBuilder,\n     default_span: Span,\n     params: Vec<ElisionFailureInfo>)\n {\n@@ -233,26 +234,26 @@ fn report_elision_failure(\n     }\n \n     if len == 0 {\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"this function's return type contains a borrowed value, but \\\n                         there is no value for it to be borrowed from\");\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"consider giving it a 'static lifetime\");\n     } else if !any_lifetimes {\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"this function's return type contains a borrowed value with \\\n                         an elided lifetime, but the lifetime cannot be derived from \\\n                         the arguments\");\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"consider giving it an explicit bounded or 'static \\\n                         lifetime\");\n     } else if len == 1 {\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"this function's return type contains a borrowed value, but \\\n                         the signature does not say which {} it is borrowed from\",\n                        m);\n     } else {\n-        fileline_help!(tcx.sess, default_span,\n+        fileline_help!(db, default_span,\n                        \"this function's return type contains a borrowed value, but \\\n                         the signature does not say whether it is borrowed from {}\",\n                        m);\n@@ -273,11 +274,12 @@ pub fn opt_ast_region_to_region<'tcx>(\n         None => match rscope.anon_regions(default_span, 1) {\n             Ok(rs) => rs[0],\n             Err(params) => {\n-                span_err!(this.tcx().sess, default_span, E0106,\n-                          \"missing lifetime specifier\");\n+                let mut err = struct_span_err!(this.tcx().sess, default_span, E0106,\n+                                               \"missing lifetime specifier\");\n                 if let Some(params) = params {\n-                    report_elision_failure(this.tcx(), default_span, params);\n+                    report_elision_failure(&mut err, default_span, params);\n                 }\n+                err.emit();\n                 ty::ReStatic\n             }\n         }\n@@ -1044,9 +1046,9 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         _ => {\n-            span_err!(this.tcx().sess, ty.span, E0178,\n-                      \"expected a path on the left-hand side of `+`, not `{}`\",\n-                      pprust::ty_to_string(ty));\n+            let mut err = struct_span_err!(this.tcx().sess, ty.span, E0178,\n+                                           \"expected a path on the left-hand side of `+`, not `{}`\",\n+                                           pprust::ty_to_string(ty));\n             let hi = bounds.iter().map(|x| match *x {\n                 hir::TraitTyParamBound(ref tr, _) => tr.span.hi,\n                 hir::RegionTyParamBound(ref r) => r.span.hi,\n@@ -1059,29 +1061,28 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n             match (&ty.node, full_span) {\n                 (&hir::TyRptr(None, ref mut_ty), Some(full_span)) => {\n                     let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n-                    this.tcx().sess\n-                        .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                         format!(\"&{}({} +{})\",\n-                                                 mutbl_str,\n-                                                 pprust::ty_to_string(&*mut_ty.ty),\n-                                                 pprust::bounds_to_string(bounds)));\n+                    err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n+                                        format!(\"&{}({} +{})\",\n+                                                mutbl_str,\n+                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::bounds_to_string(bounds)));\n                 }\n                 (&hir::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n                     let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n-                    this.tcx().sess\n-                        .span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                         format!(\"&{} {}({} +{})\",\n-                                                 pprust::lifetime_to_string(lt),\n-                                                 mutbl_str,\n-                                                 pprust::ty_to_string(&*mut_ty.ty),\n-                                                 pprust::bounds_to_string(bounds)));\n+                    err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n+                                        format!(\"&{} {}({} +{})\",\n+                                                pprust::lifetime_to_string(lt),\n+                                                mutbl_str,\n+                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::bounds_to_string(bounds)));\n                 }\n \n                 _ => {\n-                    fileline_help!(this.tcx().sess, ty.span,\n+                    fileline_help!(&mut err, ty.span,\n                                \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }\n+            err.emit();\n             Err(ErrorReported)\n         }\n     }\n@@ -1134,7 +1135,8 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n         traits::astconv_object_safety_violations(tcx, principal.def_id());\n     if !object_safety_violations.is_empty() {\n         traits::report_object_safety_error(\n-            tcx, span, principal.def_id(), object_safety_violations);\n+            tcx, span, principal.def_id(), object_safety_violations)\n+            .emit();\n         return tcx.types.err;\n     }\n \n@@ -1235,17 +1237,18 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     if bounds.len() > 1 {\n-        span_err!(tcx.sess, span, E0221,\n-                  \"ambiguous associated type `{}` in bounds of `{}`\",\n-                  assoc_name,\n-                  ty_param_name);\n+        let mut err = struct_span_err!(tcx.sess, span, E0221,\n+                                       \"ambiguous associated type `{}` in bounds of `{}`\",\n+                                       assoc_name,\n+                                       ty_param_name);\n \n         for bound in &bounds {\n-            span_note!(tcx.sess, span,\n+            span_note!(&mut err, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        ty_param_name,\n                        bound);\n         }\n+        err.emit();\n     }\n \n     Ok(bounds[0].clone())\n@@ -1707,12 +1710,13 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     }\n                 }\n                 Err(ref r) => {\n-                    span_err!(tcx.sess, r.span, E0250,\n-                              \"array length constant evaluation error: {}\",\n-                              r.description());\n+                    let mut err = struct_span_err!(tcx.sess, r.span, E0250,\n+                                                   \"array length constant evaluation error: {}\",\n+                                                   r.description());\n                     if !ast_ty.span.contains(r.span) {\n-                        span_note!(tcx.sess, ast_ty.span, \"for array length here\")\n+                        span_note!(&mut err, ast_ty.span, \"for array length here\")\n                     }\n+                    err.emit();\n                     this.tcx().types.err\n                 }\n             }"}, {"sha": "588dee57c520e9f2dd5aab098d3698ccbbef3f67", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -700,7 +700,9 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 if !is_special_case {\n                     return\n                 } else {\n-                    span_note!(tcx.sess, pat.span,\n+                    // Boo! Too painful to attach this to the actual warning,\n+                    // it should go away at some point though.\n+                    tcx.sess.span_note_without_error(pat.span,\n                         \"this warning will become a HARD ERROR in a future release. \\\n                         See RFC 218 for details.\");\n                 }\n@@ -786,12 +788,13 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     for &Spanned { node: ref field, span } in fields {\n         let field_ty = match used_fields.entry(field.name) {\n             Occupied(occupied) => {\n-                span_err!(tcx.sess, span, E0025,\n-                    \"field `{}` bound multiple times in the pattern\",\n-                    field.name);\n-                span_note!(tcx.sess, *occupied.get(),\n-                    \"field `{}` previously bound here\",\n-                    field.name);\n+                let mut err = struct_span_err!(tcx.sess, span, E0025,\n+                                               \"field `{}` bound multiple times in the pattern\",\n+                                               field.name);\n+                span_note!(&mut err, *occupied.get(),\n+                           \"field `{}` previously bound here\",\n+                           field.name);\n+                err.emit();\n                 tcx.types.err\n             }\n             Vacant(vacant) => {"}, {"sha": "a1b378d84d0010faf8f9a1fbbb3a4c1c612d748f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -61,11 +61,12 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n             return // not a closure method, everything is OK.\n         };\n \n-        span_err!(tcx.sess, span, E0174,\n-                  \"explicit use of unboxed closure method `{}` is experimental\",\n-                  method);\n-        fileline_help!(tcx.sess, span,\n-                   \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+        struct_span_err!(tcx.sess, span, E0174,\n+                         \"explicit use of unboxed closure method `{}` is experimental\",\n+                         method)\n+            .fileline_help(span, \"add `#![feature(unboxed_closures)]` to the crate \\\n+                                  attributes to enable\")\n+            .emit();\n     }\n }\n \n@@ -228,7 +229,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             sig\n         }\n         _ => {\n-            fcx.type_error_message(call_expr.span, |actual| {\n+            let mut err = fcx.type_error_struct(call_expr.span, |actual| {\n                 format!(\"expected function, found `{}`\", actual)\n             }, callee_ty, None);\n \n@@ -237,12 +238,14 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                     if pr.depth == 0 && pr.base_def != def::DefErr {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n-                            tcx.sess.span_note(span, \"defined here\")\n+                            err.span_note(span, \"defined here\");\n                         }\n                     }\n                 }\n             }\n \n+            err.emit();\n+\n             // This is the \"default\" function signature, used in case of error.\n             // In that case, we check each argument against \"error\" in order to\n             // set up all the node type bindings."}, {"sha": "90e67944ef90481474fb4f1caf713b6c2aa8348e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -127,23 +127,25 @@ impl<'tcx> CastCheck<'tcx> {\n             CastError::NeedViaThinPtr |\n             CastError::NeedViaInt |\n             CastError::NeedViaUsize => {\n-                fcx.type_error_message(self.span, |actual| {\n+                fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n-                fcx.ccx.tcx.sess.fileline_help(self.span,\n-                    &format!(\"cast through {} first\", match e {\n-                        CastError::NeedViaPtr => \"a raw pointer\",\n-                        CastError::NeedViaThinPtr => \"a thin pointer\",\n-                        CastError::NeedViaInt => \"an integer\",\n-                        CastError::NeedViaUsize => \"a usize\",\n-                        _ => unreachable!()\n-                }));\n+                }, self.expr_ty, None)\n+                    .fileline_help(self.span,\n+                        &format!(\"cast through {} first\", match e {\n+                            CastError::NeedViaPtr => \"a raw pointer\",\n+                            CastError::NeedViaThinPtr => \"a thin pointer\",\n+                            CastError::NeedViaInt => \"an integer\",\n+                            CastError::NeedViaUsize => \"a usize\",\n+                            _ => unreachable!()\n+                        }))\n+                    .emit();\n             }\n             CastError::CastToBool => {\n-                span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\");\n-                fcx.ccx.tcx.sess.fileline_help(self.span, \"compare with zero instead\");\n+                struct_span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\")\n+                    .fileline_help(self.span, \"compare with zero instead\")\n+                    .emit();\n             }\n             CastError::CastToChar => {\n                 fcx.type_error_message(self.span, |actual| {\n@@ -165,12 +167,13 @@ impl<'tcx> CastCheck<'tcx> {\n                 }, self.expr_ty, None);\n             }\n             CastError::DifferingKinds => {\n-                fcx.type_error_message(self.span, |actual| {\n+                fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n-                fcx.ccx.tcx.sess.fileline_note(self.span, \"vtable kinds may not match\");\n+                }, self.expr_ty, None)\n+                    .fileline_note(self.span, \"vtable kinds may not match\")\n+                    .emit();\n             }\n         }\n     }"}, {"sha": "0cf552b6efecb9165a4f9ba8f9ff75c324f5fdf4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -95,12 +95,13 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n     if let Err(_) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n                                    named_type, fresh_impl_self_ty) {\n-        span_err!(tcx.sess, drop_impl_span, E0366,\n-                  \"Implementations of Drop cannot be specialized\");\n         let item_span = tcx.map.span(self_type_node_id);\n-        tcx.sess.span_note(item_span,\n-                           \"Use same sequence of generic type and region \\\n-                            parameters that is on the struct/enum definition\");\n+        struct_span_err!(tcx.sess, drop_impl_span, E0366,\n+                         \"Implementations of Drop cannot be specialized\")\n+            .span_note(item_span,\n+                       \"Use same sequence of generic type and region \\\n+                        parameters that is on the struct/enum definition\")\n+            .emit();\n         return Err(());\n     }\n \n@@ -197,11 +198,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.map.span(self_type_node_id);\n-            span_err!(tcx.sess, drop_impl_span, E0367,\n-                      \"The requirement `{}` is added only by the Drop impl.\", predicate);\n-            tcx.sess.span_note(item_span,\n-                               \"The same requirement must be part of \\\n-                                the struct/enum definition\");\n+            struct_span_err!(tcx.sess, drop_impl_span, E0367,\n+                             \"The requirement `{}` is added only by the Drop impl.\", predicate)\n+                .span_note(item_span,\n+                           \"The same requirement must be part of \\\n+                            the struct/enum definition\")\n+                .emit();\n         }\n     }\n \n@@ -289,8 +291,8 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n         Ok(()) => {}\n         Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n             let tcx = rcx.tcx();\n-            span_err!(tcx.sess, span, E0320,\n-                      \"overflow while adding drop-check rules for {}\", typ);\n+            let mut err = struct_span_err!(tcx.sess, span, E0320,\n+                                           \"overflow while adding drop-check rules for {}\", typ);\n             match *ctxt {\n                 TypeContext::Root => {\n                     // no need for an additional note if the overflow\n@@ -311,14 +313,15 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         format!(\"`{}`\", field)\n                     };\n                     span_note!(\n-                        rcx.tcx().sess,\n+                        &mut err,\n                         span,\n                         \"overflowed on {} field {} type: {}\",\n                         variant_name,\n                         field_name,\n                         detected_on_typ);\n                 }\n             }\n+            err.emit();\n         }\n     }\n }"}, {"sha": "65b0d5892756c2790735810db1a975f6daace4a3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -27,6 +27,7 @@ use util::nodemap::{FnvHashSet};\n \n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n use rustc_front::print::pprust;\n use rustc_front::hir;\n \n@@ -55,7 +56,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                            mode }) => {\n             let cx = fcx.tcx();\n \n-            fcx.type_error_message(\n+            let mut err = fcx.type_error_struct(\n                 span,\n                 |actual| {\n                     format!(\"no {} named `{}` found for type `{}` \\\n@@ -78,37 +79,44 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         // snippet\n                     };\n \n-                    let span_stored_function = || {\n-                        cx.sess.span_note(span,\n+                    macro_rules! span_stored_function {\n+                        () => {\n+                            err.span_note(span,\n                                           &format!(\"use `({0}.{1})(...)` if you meant to call \\\n                                                     the function stored in the `{1}` field\",\n                                                    expr_string, item_name));\n-                    };\n+                        }\n+                    }\n \n-                    let span_did_you_mean = || {\n-                        cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                    macro_rules! span_did_you_mean {\n+                        () => {\n+                            err.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n                                                          expr_string, item_name));\n-                    };\n+                        }\n+                    }\n \n                     // Determine if the field can be used as a function in some way\n                     let field_ty = field.ty(cx, substs);\n \n                     match field_ty.sty {\n                         // Not all of these (e.g. unsafe fns) implement FnOnce\n                         // so we look for these beforehand\n-                        ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n+                        ty::TyClosure(..) | ty::TyBareFn(..) => {\n+                            span_stored_function!();\n+                        }\n                         // If it's not a simple function, look for things which implement FnOnce\n                         _ => {\n                             if let Ok(fn_once_trait_did) =\n                                     cx.lang_items.require(FnOnceTraitLangItem) {\n                                 let infcx = fcx.infcx();\n                                 infcx.probe(|_| {\n-                                    let fn_once_substs = Substs::new_trait(vec![\n-                                                                            infcx.next_ty_var()],\n-                                                                           Vec::new(),\n-                                                                           field_ty);\n-                                    let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n-                                                                      cx.mk_substs(fn_once_substs));\n+                                    let fn_once_substs =\n+                                        Substs::new_trait(vec![infcx.next_ty_var()],\n+                                                          Vec::new(),\n+                                                          field_ty);\n+                                    let trait_ref =\n+                                      ty::TraitRef::new(fn_once_trait_did,\n+                                                        cx.mk_substs(fn_once_substs));\n                                     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                                     let obligation = Obligation::misc(span,\n                                                                       fcx.body_id,\n@@ -117,25 +125,25 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     let mut selcx = SelectionContext::new(infcx);\n \n                                     if selcx.evaluate_obligation(&obligation) {\n-                                        span_stored_function();\n+                                        span_stored_function!();\n                                     } else {\n-                                        span_did_you_mean();\n+                                        span_did_you_mean!();\n                                     }\n                                 });\n                             } else {\n-                                span_did_you_mean()\n+                                span_did_you_mean!();\n                             }\n                         }\n                     }\n                 }\n             }\n \n             if !static_sources.is_empty() {\n-                cx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n \n-                report_candidates(fcx, span, item_name, static_sources);\n+                report_candidates(fcx, &mut err, span, item_name, static_sources);\n             }\n \n             if !unsatisfied_predicates.is_empty() {\n@@ -145,23 +153,25 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      p))\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n-                cx.sess.fileline_note(\n+                err.fileline_note(\n                     span,\n                     &format!(\"the method `{}` exists but the \\\n                              following trait bounds were not satisfied: {}\",\n                              item_name,\n                              bound_list));\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, item_name,\n-                                     rcvr_expr, out_of_scope_traits)\n+            suggest_traits_to_import(fcx, &mut err, span, rcvr_ty, item_name,\n+                                     rcvr_expr, out_of_scope_traits);\n+            err.emit();\n         }\n \n         MethodError::Ambiguity(sources) => {\n-            span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable items in scope\");\n+            let mut err = struct_span_err!(fcx.sess(), span, E0034,\n+                                           \"multiple applicable items in scope\");\n \n-            report_candidates(fcx, span, item_name, sources);\n+            report_candidates(fcx, &mut err, span, item_name, sources);\n+            err.emit();\n         }\n \n         MethodError::ClosureAmbiguity(trait_def_id) => {\n@@ -181,6 +191,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn report_candidates(fcx: &FnCtxt,\n+                         err: &mut DiagnosticBuilder,\n                          span: Span,\n                          item_name: ast::Name,\n                          mut sources: Vec<CandidateSource>) {\n@@ -213,7 +224,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         }\n                     };\n \n-                    span_note!(fcx.sess(), item_span,\n+                    span_note!(err, item_span,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n@@ -222,7 +233,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 CandidateSource::TraitSource(trait_did) => {\n                     let item = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n                     let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n-                    span_note!(fcx.sess(), item_span,\n+                    span_note!(err, item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n                                fcx.tcx().item_path_str(trait_did));\n@@ -236,6 +247,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub type AllTraitsVec = Vec<TraitInfo>;\n \n fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      err: &mut DiagnosticBuilder,\n                                       span: Span,\n                                       rcvr_ty: Ty<'tcx>,\n                                       item_name: ast::Name,\n@@ -255,14 +267,13 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n-        fcx.sess().fileline_help(span, &msg[..]);\n+        err.fileline_help(span, &msg[..]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n-            fcx.sess().fileline_help(span,\n-                                     &*format!(\"candidate #{}: use `{}`\",\n-                                               i + 1,\n-                                               fcx.tcx().item_path_str(*trait_did)))\n-\n+            err.fileline_help(span,\n+                              &*format!(\"candidate #{}: use `{}`\",\n+                                        i + 1,\n+                                        fcx.tcx().item_path_str(*trait_did)));\n         }\n         return\n     }\n@@ -301,13 +312,13 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = item_name);\n \n-        fcx.sess().fileline_help(span, &msg[..]);\n+        err.fileline_help(span, &msg[..]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n-            fcx.sess().fileline_help(span,\n-                                     &*format!(\"candidate #{}: `{}`\",\n-                                               i + 1,\n-                                               fcx.tcx().item_path_str(trait_info.def_id)))\n+            err.fileline_help(span,\n+                              &*format!(\"candidate #{}: `{}`\",\n+                                        i + 1,\n+                                        fcx.tcx().item_path_str(trait_info.def_id)));\n         }\n     }\n }"}, {"sha": "ca2db8c3deffb50727b9df1a52addf920c71f5b1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 46, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -119,6 +119,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n+use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -702,11 +703,12 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             for item in &m.items {\n                 let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n                 if !pty.generics.types.is_empty() {\n-                    span_err!(ccx.tcx.sess, item.span, E0044,\n+                    let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n-                    span_help!(ccx.tcx.sess, item.span,\n+                    span_help!(&mut err, item.span,\n                         \"consider using specialization instead of \\\n                         type parameters\");\n+                    err.emit();\n                 }\n \n                 if let hir::ForeignItemFn(ref fn_decl, _) = item.node {\n@@ -1037,7 +1039,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          t_expr: Ty<'tcx>,\n                                          id: ast::NodeId) {\n     let tstr = fcx.infcx().ty_to_string(t_cast);\n-    fcx.type_error_message(span, |actual| {\n+    let mut err = fcx.type_error_struct(span, |actual| {\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n     }, t_expr, None);\n     match t_expr.sty {\n@@ -1049,36 +1051,37 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if t_cast.is_trait() {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n-                        fcx.tcx().sess.span_suggestion(t_span,\n-                                                       \"try casting to a reference instead:\",\n-                                                       format!(\"&{}{}\", mtstr, s));\n+                        err.span_suggestion(t_span,\n+                                            \"try casting to a reference instead:\",\n+                                            format!(\"&{}{}\", mtstr, s));\n                     },\n                     Err(_) =>\n-                        span_help!(fcx.tcx().sess, t_span,\n+                        span_help!(err, t_span,\n                                    \"did you mean `&{}{}`?\", mtstr, tstr),\n                 }\n             } else {\n-                span_help!(fcx.tcx().sess, span,\n+                span_help!(err, span,\n                            \"consider using an implicit coercion to `&{}{}` instead\",\n                            mtstr, tstr);\n             }\n         }\n         ty::TyBox(..) => {\n             match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                 Ok(s) => {\n-                    fcx.tcx().sess.span_suggestion(t_span,\n-                                                   \"try casting to a `Box` instead:\",\n-                                                   format!(\"Box<{}>\", s));\n+                    err.span_suggestion(t_span,\n+                                                          \"try casting to a `Box` instead:\",\n+                                                           format!(\"Box<{}>\", s));\n                 },\n                 Err(_) =>\n-                    span_help!(fcx.tcx().sess, t_span, \"did you mean `Box<{}>`?\", tstr),\n+                    span_help!(err, t_span, \"did you mean `Box<{}>`?\", tstr),\n             }\n         }\n         _ => {\n-            span_help!(fcx.tcx().sess, e_span,\n+            span_help!(err, e_span,\n                        \"consider using a box or reference as appropriate\");\n         }\n     }\n+    err.emit();\n     fcx.write_error(id);\n }\n \n@@ -1443,10 +1446,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some((adt, variant))\n         } else if var_kind == ty::VariantKind::Unit {\n             if !self.tcx().sess.features.borrow().braced_empty_structs {\n-                self.tcx().sess.span_err(span, \"empty structs and enum variants \\\n-                                                with braces are unstable\");\n-                fileline_help!(self.tcx().sess, span, \"add #![feature(braced_empty_structs)] to \\\n-                                                       the crate features to enable\");\n+                let mut err = self.tcx().sess.struct_span_err(span,\n+                                                              \"empty structs and enum variants \\\n+                                                               with braces are unstable\");\n+                fileline_help!(&mut err, span, \"add #![feature(braced_empty_structs)] to \\\n+                                                the crate features to enable\");\n+                err.emit();\n             }\n \n              Some((adt, variant))\n@@ -1614,12 +1619,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>) where\n-        M: FnOnce(String) -> String,\n+                                 err: Option<&TypeError<'tcx>>)\n+        where M: FnOnce(String) -> String,\n     {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n+    pub fn type_error_struct<M>(&self,\n+                                sp: Span,\n+                                mk_msg: M,\n+                                actual_ty: Ty<'tcx>,\n+                                err: Option<&TypeError<'tcx>>)\n+                                -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(String) -> String,\n+    {\n+        self.infcx().type_error_struct(sp, mk_msg, actual_ty, err)\n+    }\n+\n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n                                    e: Ty<'tcx>,\n@@ -2913,7 +2929,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             lvalue_pref: LvaluePreference,\n                             base: &'tcx hir::Expr,\n                             field: &Spanned<ast::Name>) {\n-        let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n@@ -2945,19 +2960,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n-            fcx.type_error_message(\n-                field.span,\n-                |actual| {\n-                    format!(\"attempted to take value of method `{}` on type \\\n-                            `{}`\", field.node, actual)\n-                },\n-                expr_t, None);\n-\n-            tcx.sess.fileline_help(field.span,\n+            fcx.type_error_struct(field.span,\n+                                  |actual| {\n+                                       format!(\"attempted to take value of method `{}` on type \\\n+                                               `{}`\", field.node, actual)\n+                                   },\n+                                   expr_t, None)\n+                .fileline_help(field.span,\n                                \"maybe a `()` to call it is missing? \\\n-                               If not, try an anonymous function\");\n+                               If not, try an anonymous function\")\n+                .emit();\n         } else {\n-            fcx.type_error_message(\n+            let mut err = fcx.type_error_struct(\n                 expr.span,\n                 |actual| {\n                     format!(\"attempted access of field `{}` on \\\n@@ -2968,17 +2982,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 },\n                 expr_t, None);\n             if let ty::TyStruct(def, _) = expr_t.sty {\n-                suggest_field_names(def.struct_variant(), field, tcx, vec![]);\n+                suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n+            err.emit();\n         }\n \n         fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n-    fn suggest_field_names<'tcx>(variant: ty::VariantDef<'tcx>,\n+    fn suggest_field_names<'tcx>(err: &mut DiagnosticBuilder,\n+                                 variant: ty::VariantDef<'tcx>,\n                                  field: &Spanned<ast::Name>,\n-                                 tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n         let name = field.node.as_str();\n         let names = variant.fields\n@@ -2995,8 +3010,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // only find fits with at least one matching letter\n         if let Some(name) = find_best_match_for_name(names, &name, Some(name.len())) {\n-            tcx.sess.span_help(field.span,\n-                &format!(\"did you mean `{}`?\", name));\n+            err.span_help(field.span,\n+                          &format!(\"did you mean `{}`?\", name));\n         }\n     }\n \n@@ -3071,7 +3086,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       variant: ty::VariantDef<'tcx>,\n                                       field: &hir::Field,\n                                       skip_fields: &[hir::Field]) {\n-        fcx.type_error_message(\n+        let mut err = fcx.type_error_struct(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n@@ -3084,7 +3099,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None);\n         // prevent all specified fields from being suggested\n         let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n-        suggest_field_names(variant, &field.name, fcx.tcx(), skip_fields.collect());\n+        suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n+        err.emit();\n     }\n \n     fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -4146,9 +4162,9 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation);\n-            tcx.sess.fileline_help(\n-                sp, \"wrap the inner value in a box to make it representable\");\n+            struct_span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation)\n+                .fileline_help(sp, \"wrap the inner value in a box to make it representable\")\n+                .emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n@@ -4245,11 +4261,12 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // Check for duplicate discriminant values\n             match disr_vals.iter().position(|&x| x == current_disr_val) {\n                 Some(i) => {\n-                    span_err!(ccx.tcx.sess, v.span, E0081,\n+                    let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n                     let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variant_i_node_id),\n-                        \"conflicting discriminant here\")\n+                    span_note!(&mut err, ccx.tcx.map.span(variant_i_node_id),\n+                        \"conflicting discriminant here\");\n+                    err.emit();\n                 }\n                 None => {}\n             }\n@@ -4258,10 +4275,11 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 attr::ReprAny | attr::ReprExtern => (),\n                 attr::ReprInt(sp, ity) => {\n                     if !disr_in_range(ccx, ity, current_disr_val) {\n-                        span_err!(ccx.tcx.sess, v.span, E0082,\n+                        let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0082,\n                             \"discriminant value outside specified type\");\n-                        span_note!(ccx.tcx.sess, sp,\n+                        span_note!(&mut err, sp,\n                             \"discriminant type specified here\");\n+                        err.emit();\n                     }\n                 }\n                 attr::ReprSimd => {"}, {"sha": "c5a36fb4ada256d96cfad9da7ef91282329d320c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -187,10 +187,10 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               hir_util::binop_to_string(op.node),\n                               lhs_ty);\n                 } else {\n-                    span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n-                              \"binary operation `{}` cannot be applied to type `{}`\",\n-                              hir_util::binop_to_string(op.node),\n-                              lhs_ty);\n+                    let mut err = struct_span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n+                        \"binary operation `{}` cannot be applied to type `{}`\",\n+                        hir_util::binop_to_string(op.node),\n+                        lhs_ty);\n                     let missing_trait = match op.node {\n                         hir::BiAdd    => Some(\"std::ops::Add\"),\n                         hir::BiSub    => Some(\"std::ops::Sub\"),\n@@ -208,10 +208,11 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     if let Some(missing_trait) = missing_trait {\n-                        span_note!(fcx.tcx().sess, lhs_expr.span,\n+                        span_note!(&mut err, lhs_expr.span,\n                                    \"an implementation of `{}` might be missing for `{}`\",\n                                     missing_trait, lhs_ty);\n                     }\n+                    err.emit();\n                 }\n             }\n             fcx.tcx().types.err"}, {"sha": "d43efb17b2effea8bb81b29e7e2fc667d17c5637", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -23,6 +23,7 @@ use std::cell::RefCell;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::{Span};\n+use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::{special_idents};\n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n@@ -496,12 +497,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        error_392(self.tcx(), span, param_name);\n+        let mut err = error_392(self.tcx(), span, param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n-                self.tcx().sess.fileline_help(\n+                err.fileline_help(\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n@@ -511,6 +512,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 // no lang items, no help!\n             }\n         }\n+        err.emit();\n     }\n }\n \n@@ -621,9 +623,10 @@ pub fn error_380<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n                Trait for ..`) must have no methods or associated items\")\n }\n \n-pub fn error_392<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, param_name: ast::Name)  {\n-    span_err!(tcx.sess, span, E0392,\n-              \"parameter `{}` is never used\", param_name);\n+pub fn error_392<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, param_name: ast::Name)\n+                       -> DiagnosticBuilder<'tcx> {\n+    struct_span_err!(tcx.sess, span, E0392,\n+                     \"parameter `{}` is never used\", param_name)\n }\n \n pub fn error_194<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, name: ast::Name) {"}, {"sha": "1536f13a1d51aa21bd49ed50fca219bb93e3b44b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -129,13 +129,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             !self.fcx.expr_ty(lhs).references_error() &&\n                             !self.fcx.expr_ty(rhs).references_error()\n                         {\n-                            tcx.sess.span_err(\n-                                e.span,\n-                                \"overloaded augmented assignments are not stable\");\n-                            fileline_help!(\n-                                tcx.sess, e.span,\n-                                \"add #![feature(augmented_assignments)] to the crate root \\\n-                                 to enable\");\n+                            tcx.sess.struct_span_err(e.span,\n+                                                     \"overloaded augmented assignments \\\n+                                                      are not stable\")\n+                                .fileline_help(e.span,\n+                                               \"add #![feature(augmented_assignments)] to the \\\n+                                                crate root to enable\")\n+                                .emit()\n                         }\n                     }\n                 }"}, {"sha": "02be74a590661ff4eb48940d7d36519f42863b5d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -502,9 +502,14 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n     } else {\n         return // everything OK\n     };\n-    span_err!(tcx.sess, sp, E0183, \"manual implementations of `{}` are experimental\", trait_name);\n-    fileline_help!(tcx.sess, sp,\n-               \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    let mut err = struct_span_err!(tcx.sess,\n+                                   sp,\n+                                   E0183,\n+                                   \"manual implementations of `{}` are experimental\",\n+                                   trait_name);\n+    fileline_help!(&mut err, sp,\n+                   \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    err.emit();\n }\n \n pub fn check_coherence(crate_context: &CrateCtxt) {"}, {"sha": "76be04bb1741a13f52580cde53c56d7e08f6f2b0", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -48,11 +48,11 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n         match lang_def_id {\n             Some(lang_def_id) if lang_def_id == impl_def_id => { /* OK */ },\n             _ => {\n-                span_err!(self.tcx.sess, span, E0390,\n+                struct_span_err!(self.tcx.sess, span, E0390,\n                           \"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n-                           is allowed for the `{}` primitive\", lang, ty);\n-                span_help!(self.tcx.sess, span,\n-                           \"consider using a trait to implement these methods\");\n+                           is allowed for the `{}` primitive\", lang, ty)\n+                    .span_help(span, \"consider using a trait to implement these methods\")\n+                    .emit();\n             }\n         }\n     }"}, {"sha": "beb409f7f0f23b63ac0aecc49d0e8a41474da3c1", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -150,18 +150,19 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             }).unwrap_or(String::new())\n         };\n \n-        span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n-                  \"conflicting implementations of trait `{}`{}:\",\n-                  trait_ref,\n-                  self_type);\n+        let mut err = struct_span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n+                                       \"conflicting implementations of trait `{}`{}:\",\n+                                       trait_ref,\n+                                       self_type);\n \n         if impl2.is_local() {\n-            span_note!(self.tcx.sess, self.span_of_impl(impl2),\n+            span_note!(&mut err, self.span_of_impl(impl2),\n                        \"conflicting implementation is here:\");\n         } else {\n             let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n-            self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n+            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n         }\n+        err.emit();\n     }\n \n     fn span_of_impl(&self, impl_did: DefId) -> Span {"}, {"sha": "eaaa2c773791e8c24776d5f4d09fca35e533bb8e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -225,24 +225,24 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         assert!(!cycle.is_empty());\n         let tcx = self.tcx;\n \n-        span_err!(tcx.sess, span, E0391,\n+        let mut err = struct_span_err!(tcx.sess, span, E0391,\n             \"unsupported cyclic reference between types/traits detected\");\n \n         match cycle[0] {\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"the cycle begins when processing `{}`...\",\n                              tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n                              tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"the cycle begins when computing the bounds \\\n                               for type parameter `{}`...\",\n                              def.name));\n@@ -253,18 +253,18 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             match *request {\n                 AstConvRequest::GetItemTypeScheme(def_id) |\n                 AstConvRequest::GetTraitDef(def_id) => {\n-                    tcx.sess.note(\n+                    err.note(\n                         &format!(\"...which then requires processing `{}`...\",\n                                  tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                    tcx.sess.note(\n+                    err.note(\n                         &format!(\"...which then requires computing the supertraits of `{}`...\",\n                                  tcx.item_path_str(def_id)));\n                 }\n                 AstConvRequest::GetTypeParameterBounds(id) => {\n                     let def = tcx.type_parameter_def(id);\n-                    tcx.sess.note(\n+                    err.note(\n                         &format!(\"...which then requires computing the bounds \\\n                                   for type parameter `{}`...\",\n                                  def.name));\n@@ -275,24 +275,25 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         match cycle[0] {\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n                              tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"...which then again requires computing the supertraits of `{}`, \\\n                               completing the cycle.\",\n                              tcx.item_path_str(def_id)));\n             }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n-                tcx.sess.note(\n+                err.note(\n                     &format!(\"...which then again requires computing the bounds \\\n                               for type parameter `{}`, completing the cycle.\",\n                              def.name));\n             }\n         }\n+        err.emit();\n     }\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n@@ -1012,10 +1013,11 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n             hir::NamedField(name, vis) => {\n                 let dup_span = seen_fields.get(&name).cloned();\n                 if let Some(prev_span) = dup_span {\n-                    span_err!(tcx.sess, f.span, E0124,\n-                              \"field `{}` is already declared\",\n-                              name);\n-                    span_note!(tcx.sess, prev_span, \"previously declared here\");\n+                    let mut err = struct_span_err!(tcx.sess, f.span, E0124,\n+                                                   \"field `{}` is already declared\",\n+                                                   name);\n+                    span_note!(&mut err, prev_span, \"previously declared here\");\n+                    err.emit();\n                 } else {\n                     seen_fields.insert(name, f.span);\n                 }\n@@ -1080,12 +1082,13 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 None\n             },\n             Err(err) => {\n-                span_err!(tcx.sess, err.span, E0080,\n-                          \"constant evaluation error: {}\",\n-                          err.description());\n+                let mut diag = struct_span_err!(tcx.sess, err.span, E0080,\n+                                                \"constant evaluation error: {}\",\n+                                                err.description());\n                 if !e.span.contains(err.span) {\n-                    tcx.sess.span_note(e.span, \"for enum discriminant here\");\n+                    diag.span_note(e.span, \"for enum discriminant here\");\n                 }\n+                diag.emit();\n                 None\n             }\n         }\n@@ -1254,13 +1257,14 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n     if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n-        ccx.tcx.sess.span_err(\n+        let mut err = ccx.tcx.sess.struct_span_err(\n             it.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n              which traits can use parenthetical notation\");\n-        fileline_help!(ccx.tcx.sess, it.span,\n+        fileline_help!(&mut err, it.span,\n                    \"add `#![feature(unboxed_closures)]` to \\\n                     the crate attributes to use it\");\n+        err.emit();\n     }\n \n     let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));"}, {"sha": "bf890f3e50709b9295b6a240a0cc86e52b0d00c0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -203,8 +203,9 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n-            tcx.note_and_explain_type_err(terr, span);\n+            let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n+            tcx.note_and_explain_type_err(&mut err, terr, span);\n+            err.emit();\n             false\n         }\n     }"}, {"sha": "96d0052cf180125b659fd5ce4157960ea0b4f616", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -305,8 +305,10 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Inte\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n-                diag.span_err(attr.span, \"export_name attribute has invalid format\");\n-                diag.help(\"use #[export_name=\\\"*\\\"]\");\n+                diag.struct_span_err(attr.span,\n+                                     \"export_name attribute has invalid format\")\n+                    .help(\"use #[export_name=\\\"*\\\"]\")\n+                    .emit();\n                 None\n             }\n         } else {"}, {"sha": "95a74d875545fcfeac1fd6ef15e10dbe06ab238a", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -30,6 +30,14 @@ macro_rules! span_err {\n     })\n }\n \n+#[macro_export]\n+macro_rules! span_warn {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+    })\n+}\n+\n #[macro_export]\n macro_rules! span_err_or_warn {\n     ($is_warning:expr, $session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n@@ -43,31 +51,59 @@ macro_rules! span_err_or_warn {\n }\n \n #[macro_export]\n-macro_rules! span_warn {\n+macro_rules! struct_span_fatal {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        $session.span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+        $session.struct_span_fatal_with_code($span, &format!($($message)*), stringify!($code))\n+    })\n+}\n+\n+#[macro_export]\n+macro_rules! struct_span_err {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.struct_span_err_with_code($span, &format!($($message)*), stringify!($code))\n+    })\n+}\n+\n+#[macro_export]\n+macro_rules! struct_span_warn {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.struct_span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+    })\n+}\n+\n+#[macro_export]\n+macro_rules! struct_span_err_or_warn {\n+    ($is_warning:expr, $session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        if $is_warning {\n+            $session.struct_span_warn_with_code($span, &format!($($message)*), stringify!($code))\n+        } else {\n+            $session.struct_span_err_with_code($span, &format!($($message)*), stringify!($code))\n+        }\n     })\n }\n \n #[macro_export]\n macro_rules! span_note {\n-    ($session:expr, $span:expr, $($message:tt)*) => ({\n-        ($session).span_note($span, &format!($($message)*))\n+    ($err:expr, $span:expr, $($message:tt)*) => ({\n+        ($err).span_note($span, &format!($($message)*));\n     })\n }\n \n #[macro_export]\n macro_rules! span_help {\n-    ($session:expr, $span:expr, $($message:tt)*) => ({\n-        ($session).span_help($span, &format!($($message)*))\n+    ($err:expr, $span:expr, $($message:tt)*) => ({\n+        ($err).span_help($span, &format!($($message)*));\n     })\n }\n \n #[macro_export]\n macro_rules! fileline_help {\n-    ($session:expr, $span:expr, $($message:tt)*) => ({\n-        ($session).fileline_help($span, &format!($($message)*))\n+    ($err:expr, $span:expr, $($message:tt)*) => ({\n+        ($err).fileline_help($span, &format!($($message)*));\n     })\n }\n "}, {"sha": "d17ca3892dc684746c2e3f379b28447834940ff8", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -62,10 +62,10 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         match diagnostics.get_mut(&code.name) {\n             // Previously used errors.\n             Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n-                ecx.span_warn(span, &format!(\n+                ecx.struct_span_warn(span, &format!(\n                     \"diagnostic code {} already used\", code\n-                ));\n-                ecx.span_note(previous_span, \"previous invocation\");\n+                )).span_note(previous_span, \"previous invocation\")\n+                  .emit();\n             }\n             // Newly used errors.\n             Some(ref mut info) => {"}, {"sha": "a7bfdedf71813d0fd70ef99033069f1927598008", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -13,7 +13,7 @@ use self::Destination::*;\n use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, Pos, Span};\n use diagnostics;\n \n-use errors::{Level, RenderSpan};\n+use errors::{Level, RenderSpan, DiagnosticBuilder};\n use errors::RenderSpan::*;\n use errors::Level::*;\n \n@@ -27,6 +27,17 @@ use term;\n pub trait Emitter {\n     fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, lvl: Level);\n     fn custom_emit(&mut self, sp: RenderSpan, msg: &str, lvl: Level);\n+\n+    /// Emit a structured diagnostic.\n+    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n+        self.emit(db.span, &db.message, db.code.as_ref().map(|s| &**s), db.level);\n+        for child in &db.children {\n+            match child.render_span {\n+                Some(ref sp) => self.custom_emit(sp.clone(), &child.message, child.level),\n+                None => self.emit(child.span, &child.message, None, child.level),\n+            }\n+        }\n+    }\n }\n \n /// maximum number of lines we will print for each error; arbitrary.\n@@ -49,8 +60,8 @@ impl ColorConfig {\n     }\n }\n \n-// A basic emitter for when we don't have access to a codemap or registry. Used\n-// for reporting very early errors, etc.\n+/// A basic emitter for when we don't have access to a codemap or registry. Used\n+/// for reporting very early errors, etc.\n pub struct BasicEmitter {\n     dst: Destination,\n }\n@@ -111,9 +122,8 @@ impl Emitter for EmitterWriter {\n                    sp: RenderSpan,\n                    msg: &str,\n                    lvl: Level) {\n-        match self.emit_(sp, msg, None, lvl) {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n+        if let Err(e) = self.emit_(sp, msg, None, lvl) {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n }"}, {"sha": "a2fae975148f953e913d96b878babf75fcd01ae8", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 268, "deletions": 26, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -98,6 +98,171 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n+/// Used for emitting structured error messages and other diagnostic information.\n+#[must_use]\n+pub struct DiagnosticBuilder<'a> {\n+    emitter: &'a RefCell<Box<Emitter>>,\n+    level: Level,\n+    message: String,\n+    code: Option<String>,\n+    span: Option<Span>,\n+    children: Vec<SubDiagnostic>,\n+}\n+\n+/// For example a note attached to an error.\n+struct SubDiagnostic {\n+    level: Level,\n+    message: String,\n+    span: Option<Span>,\n+    render_span: Option<RenderSpan>,\n+}\n+\n+impl<'a> DiagnosticBuilder<'a> {\n+    /// Emit the diagnostic.\n+    pub fn emit(&mut self) {\n+        if self.cancelled() {\n+            return;\n+        }\n+\n+        self.emitter.borrow_mut().emit_struct(&self);\n+        self.cancel();\n+\n+        // if self.is_fatal() {\n+        //     panic!(FatalError);\n+        // }\n+    }\n+\n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n+    /// bump the error count on the Handler and cancelling it won't undo that.\n+    /// If you want to decrement the error count you should use `Handler::cancel`.\n+    pub fn cancel(&mut self) {\n+        self.level = Level::Cancelled;\n+    }\n+\n+    pub fn cancelled(&self) -> bool {\n+        self.level == Level::Cancelled\n+    }\n+\n+    pub fn is_fatal(&self) -> bool {\n+        self.level == Level::Fatal\n+    }\n+\n+    pub fn note(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Note, msg, None, None);\n+        self\n+    }\n+    pub fn span_note(&mut self ,\n+                     sp: Span,\n+                     msg: &str)\n+                     -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, Some(sp), None);\n+        self\n+    }\n+    pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Help, msg, None, None);\n+        self\n+    }\n+    pub fn span_help(&mut self ,\n+                     sp: Span,\n+                     msg: &str)\n+                     -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Help, msg, Some(sp), None);\n+        self\n+    }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&mut self ,\n+                           sp: Span,\n+                           msg: &str,\n+                           suggestion: String)\n+                           -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Help, msg, Some(sp), Some(Suggestion(sp, suggestion)));\n+        self\n+    }\n+    pub fn span_end_note(&mut self ,\n+                         sp: Span,\n+                         msg: &str)\n+                         -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Note, msg, Some(sp), Some(EndSpan(sp)));\n+        self\n+    }\n+    pub fn fileline_note(&mut self ,\n+                         sp: Span,\n+                         msg: &str)\n+                         -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Note, msg, Some(sp), Some(FileLine(sp)));\n+        self\n+    }\n+    pub fn fileline_help(&mut self ,\n+                         sp: Span,\n+                         msg: &str)\n+                         -> &mut DiagnosticBuilder<'a>  {\n+        self.sub(Level::Help, msg, Some(sp), Some(FileLine(sp)));\n+        self\n+    }\n+\n+    pub fn span(&mut self, sp: Span) -> &mut Self {\n+        self.span = Some(sp);\n+        self\n+    }\n+\n+    pub fn code(&mut self, s: String) -> &mut Self {\n+        self.code = Some(s);\n+        self\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    fn new(emitter: &'a RefCell<Box<Emitter>>,\n+           level: Level,\n+           message: &str) -> DiagnosticBuilder<'a>  {\n+        DiagnosticBuilder {\n+            emitter: emitter,\n+            level: level,\n+            message: message.to_owned(),\n+            code: None,\n+            span: None,\n+            children: vec![],\n+        }\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// public methods above.\n+    fn sub(&mut self,\n+           level: Level,\n+           message: &str,\n+           span: Option<Span>,\n+           render_span: Option<RenderSpan>) {\n+        let sub = SubDiagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            span: span,\n+            render_span: render_span,\n+        };\n+        self.children.push(sub);\n+    }\n+}\n+\n+impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.message.fmt(f)\n+    }\n+}\n+\n+/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n+/// we emit a bug.\n+impl<'a> Drop for DiagnosticBuilder<'a> {\n+    fn drop(&mut self) {\n+        if !self.cancelled() {\n+            self.emitter.borrow_mut().emit(None, \"Error constructed but not emitted\", None, Bug);\n+            panic!();\n+        }\n+    }\n+}\n+\n /// A handler deals with errors; certain errors\n /// (fatal, bug, unimpl) may cause immediate exit,\n /// others log errors for later reporting.\n@@ -132,18 +297,112 @@ impl Handler {\n         }\n     }\n \n+    pub fn struct_dummy<'a>(&'a self) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new(&self.emit, Level::Cancelled, \"\")\n+    }\n+\n+    pub fn struct_span_warn<'a>(&'a self,\n+                                sp: Span,\n+                                msg: &str)\n+                                -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        result.span(sp);\n+        if !self.can_emit_warnings {\n+            result.cancel();\n+        }\n+        result\n+    }\n+    pub fn struct_span_warn_with_code<'a>(&'a self,\n+                                          sp: Span,\n+                                          msg: &str,\n+                                          code: &str)\n+                                          -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n+        if !self.can_emit_warnings {\n+            result.cancel();\n+        }\n+        result\n+    }\n+    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        if !self.can_emit_warnings {\n+            result.cancel();\n+        }\n+        result\n+    }\n+    pub fn struct_span_err<'a>(&'a self,\n+                               sp: Span,\n+                               msg: &str)\n+                               -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        result.span(sp);\n+        result\n+    }\n+    pub fn struct_span_err_with_code<'a>(&'a self,\n+                                         sp: Span,\n+                                         msg: &str,\n+                                         code: &str)\n+                                         -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n+        result\n+    }\n+    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        DiagnosticBuilder::new(&self.emit, Level::Error, msg)\n+    }\n+    pub fn struct_span_fatal<'a>(&'a self,\n+                                 sp: Span,\n+                                 msg: &str)\n+                                 -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        result.span(sp);\n+        result\n+    }\n+    pub fn struct_span_fatal_with_code<'a>(&'a self,\n+                                           sp: Span,\n+                                           msg: &str,\n+                                           code: &str)\n+                                           -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n+        result\n+    }\n+    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+        self.bump_err_count();\n+        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg)\n+    }\n+\n+    pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n+        if err.level == Level::Error || err.level == Level::Fatal {\n+            assert!(self.has_errors());\n+            self.err_count.set(self.err_count.get() + 1);\n+        }\n+        err.cancel();\n+    }\n+\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n         self.emit(Some(sp), msg, Fatal);\n+        self.bump_err_count();\n         return FatalError;\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n         self.emit_with_code(Some(sp), msg, code, Fatal);\n+        self.bump_err_count();\n         return FatalError;\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n@@ -166,27 +425,6 @@ impl Handler {\n     pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n         self.emit_with_code(Some(sp), msg, code, Warning);\n     }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.emit(Some(sp), msg, Note);\n-    }\n-    pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.custom_emit(EndSpan(sp), msg, Note);\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.emit(Some(sp), msg, Help);\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n-        self.custom_emit(Suggestion(sp, suggestion), msg, Help);\n-    }\n-    pub fn fileline_note(&self, sp: Span, msg: &str) {\n-        self.custom_emit(FileLine(sp), msg, Note);\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.custom_emit(FileLine(sp), msg, Help);\n-    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.emit(Some(sp), msg, Bug);\n         panic!(ExplicitBug);\n@@ -199,6 +437,9 @@ impl Handler {\n         self.emit(Some(sp), msg, Bug);\n         self.bump_err_count();\n     }\n+    pub fn span_note_without_error(&self, sp: Span, msg: &str) {\n+        self.emit.borrow_mut().emit(Some(sp), msg, None, Note);\n+    }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n     }\n@@ -207,6 +448,7 @@ impl Handler {\n             self.bug(msg);\n         }\n         self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n@@ -219,12 +461,9 @@ impl Handler {\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);\n     }\n-    pub fn note(&self, msg: &str) {\n+    pub fn note_without_error(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Note);\n     }\n-    pub fn help(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Help);\n-    }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.emit.borrow_mut().emit(None, msg, None, Bug);\n         panic!(ExplicitBug);\n@@ -266,7 +505,7 @@ impl Handler {\n             }\n         }\n \n-        panic!(self.fatal(&s[..]));\n+        panic!(self.fatal(&s));\n     }\n \n     pub fn emit(&self,\n@@ -301,6 +540,7 @@ pub enum Level {\n     Warning,\n     Note,\n     Help,\n+    Cancelled,\n }\n \n impl fmt::Display for Level {\n@@ -313,6 +553,7 @@ impl fmt::Display for Level {\n             Warning => \"warning\".fmt(f),\n             Note => \"note\".fmt(f),\n             Help => \"help\".fmt(f),\n+            Cancelled => unreachable!(),\n         }\n     }\n }\n@@ -324,6 +565,7 @@ impl Level {\n             Warning => term::color::BRIGHT_YELLOW,\n             Note => term::color::BRIGHT_GREEN,\n             Help => term::color::BRIGHT_CYAN,\n+            Cancelled => unreachable!(),\n         }\n     }\n }"}, {"sha": "fc0f1925207ae45dbaeaa2866852e41dca8f7fa0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -14,6 +14,7 @@ use ast;\n use ast::Name;\n use codemap;\n use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n+use errors::DiagnosticBuilder;\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n@@ -678,6 +679,25 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n+    pub fn struct_span_warn(&self,\n+                            sp: Span,\n+                            msg: &str)\n+                            -> DiagnosticBuilder<'a> {\n+        self.parse_sess.span_diagnostic.struct_span_warn(sp, msg)\n+    }\n+    pub fn struct_span_err(&self,\n+                           sp: Span,\n+                           msg: &str)\n+                           -> DiagnosticBuilder<'a> {\n+        self.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n+    }\n+    pub fn struct_span_fatal(&self,\n+                             sp: Span,\n+                             msg: &str)\n+                             -> DiagnosticBuilder<'a> {\n+        self.parse_sess.span_diagnostic.struct_span_fatal(sp, msg)\n+    }\n+\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n     /// `span_err` should be strongly preferred where-ever possible:\n@@ -710,15 +730,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_note(sp, msg);\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_help(sp, msg);\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.parse_sess.span_diagnostic.fileline_help(sp, msg);\n-    }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.parse_sess.span_diagnostic.bug(msg);\n     }\n@@ -743,10 +754,13 @@ impl<'a> ExtCtxt<'a> {\n         token::intern(st)\n     }\n \n-    pub fn suggest_macro_name(&mut self, name: &str, span: Span) {\n+    pub fn suggest_macro_name(&mut self,\n+                              name: &str,\n+                              span: Span,\n+                              err: &mut DiagnosticBuilder<'a>) {\n         let names = &self.syntax_env.names;\n         if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n-            self.fileline_help(span, &format!(\"did you mean `{}!`?\", suggestion));\n+            err.fileline_help(span, &format!(\"did you mean `{}!`?\", suggestion));\n         }\n     }\n }"}, {"sha": "5f27bdfc98a41bac1f9ff0b814ab89e49a515cbc", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -201,11 +201,12 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n     let extname = pth.segments[0].identifier.name;\n     match fld.cx.syntax_env.find(extname) {\n         None => {\n-            fld.cx.span_err(\n+            let mut err = fld.cx.struct_span_err(\n                 pth.span,\n                 &format!(\"macro undefined: '{}!'\",\n                         &extname));\n-            fld.cx.suggest_macro_name(&extname.as_str(), pth.span);\n+            fld.cx.suggest_macro_name(&extname.as_str(), pth.span, &mut err);\n+            err.emit();\n \n             // let compilation continue\n             None\n@@ -334,11 +335,15 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n     for attr in attrs {\n         let mut is_use = attr.check_name(\"macro_use\");\n         if attr.check_name(\"macro_escape\") {\n-            fld.cx.span_warn(attr.span, \"macro_escape is a deprecated synonym for macro_use\");\n+            let mut err =\n+                fld.cx.struct_span_warn(attr.span,\n+                                        \"macro_escape is a deprecated synonym for macro_use\");\n             is_use = true;\n             if let ast::AttrStyle::Inner = attr.node.style {\n-                fld.cx.fileline_help(attr.span, \"consider an outer attribute, \\\n-                                             #[macro_use] mod ...\");\n+                err.fileline_help(attr.span, \"consider an outer attribute, \\\n+                                              #[macro_use] mod ...\").emit();\n+            } else {\n+                err.emit();\n             }\n         };\n "}, {"sha": "7a1a207a562a1dd23200ef4d0d54d8220bb80b2f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -802,7 +802,7 @@ fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[TokenTree])\n \n     let cx_expr = panictry!(p.parse_expr());\n     if !panictry!(p.eat(&token::Comma)) {\n-        panic!(p.fatal(\"expected token `,`\"));\n+        let _ = p.diagnostic().fatal(\"expected token `,`\");\n     }\n \n     let tts = panictry!(p.parse_all_token_trees());"}, {"sha": "f00224bacdd2d13459933750ef81c7d5076bd6a4", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -117,11 +117,9 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => panic!(self.p.span_fatal(\n-                        self.p.span,\n-                        &format!(\"expected item, found `{}`\",\n-                                 self.p.this_token_to_string())\n-                    ))\n+                    None => panic!(self.p.diagnostic().span_fatal(self.p.span,\n+                                                           &format!(\"expected item, found `{}`\",\n+                                                                    self.p.this_token_to_string())))\n                 }\n             }\n             Some(ret)"}, {"sha": "166d32a8cc62faa3f0e20a9e288f732b29470bcb", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -82,6 +82,7 @@ use ast;\n use ast::{TokenTree, Name, Ident};\n use codemap::{BytePos, mk_sp, Span, Spanned};\n use codemap;\n+use errors::FatalError;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n@@ -499,11 +500,12 @@ pub fn parse(sess: &ParseSess,\n     }\n }\n \n-pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n+pub fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n             p.quote_depth += 1; //but in theory, non-quoted tts might be useful\n-            let res = token::NtTT(P(panictry!(p.parse_token_tree())));\n+            let res: ::parse::PResult<'a, _> = p.parse_token_tree();\n+            let res = token::NtTT(P(panictry!(res)));\n             p.quote_depth -= 1;\n             return res;\n         }\n@@ -514,12 +516,18 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"item\" => match panictry!(p.parse_item()) {\n             Some(i) => token::NtItem(i),\n-            None => panic!(p.fatal(\"expected an item keyword\"))\n+            None => {\n+                p.fatal(\"expected an item keyword\").emit();\n+                panic!(FatalError);\n+            }\n         },\n         \"block\" => token::NtBlock(panictry!(p.parse_block())),\n         \"stmt\" => match panictry!(p.parse_stmt()) {\n             Some(s) => token::NtStmt(s),\n-            None => panic!(p.fatal(\"expected a statement\"))\n+            None => {\n+                p.fatal(\"expected a statement\").emit();\n+                panic!(FatalError);\n+            }\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n@@ -532,20 +540,22 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n             }\n             _ => {\n                 let token_str = pprust::token_to_string(&p.token);\n-                panic!(p.fatal(&format!(\"expected ident, found {}\",\n-                                 &token_str[..])))\n+                p.fatal(&format!(\"expected ident, found {}\",\n+                                 &token_str[..])).emit();\n+                panic!(FatalError)\n             }\n         },\n         \"path\" => {\n             token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n         },\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         _ => {\n-            panic!(p.span_fatal_help(sp,\n-                            &format!(\"invalid fragment specifier `{}`\", name),\n-                            \"valid fragment specifiers are `ident`, `block`, \\\n-                             `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                             and `item`\"))\n+            p.span_fatal_help(sp,\n+                              &format!(\"invalid fragment specifier `{}`\", name),\n+                              \"valid fragment specifiers are `ident`, `block`, \\\n+                               `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n+                               and `item`\").emit();\n+            panic!(FatalError);\n         }\n     }\n }"}, {"sha": "fd0bbf7a0723e95d71f6438d2a6918c21b854fc8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -55,12 +55,12 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, &msg[..]);\n-\n+            let mut err = parser.diagnostic().struct_span_err(span, &msg[..]);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n                                self.macro_ident, context);\n-            parser.span_note(self.site_span, &msg[..]);\n+            err.span_note(self.site_span, &msg[..])\n+               .emit();\n         }\n     }\n }\n@@ -111,7 +111,10 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n                         Some(stmt) => ret.push(stmt),\n                         None => (),\n                     },\n-                    Err(_) => break,\n+                    Err(mut e) => {\n+                        e.emit();\n+                        break;\n+                    }\n                 }\n             }\n         }"}, {"sha": "a23dc3b8871fadb89bf7ba92d64e34b8ed95d7d0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -725,17 +725,21 @@ pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIs\n         GateIssue::Library(lib) => lib,\n     };\n \n-    if let Some(n) = issue {\n-        diag.span_err(span, &format!(\"{} (see issue #{})\", explain, n));\n+    let mut err = if let Some(n) = issue {\n+        diag.struct_span_err(span, &format!(\"{} (see issue #{})\", explain, n))\n     } else {\n-        diag.span_err(span, explain);\n-    }\n+        diag.struct_span_err(span, explain)\n+    };\n \n     // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n-    if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some() { return; }\n-    diag.fileline_help(span, &format!(\"add #![feature({})] to the \\\n-                                   crate attributes to enable\",\n-                                  feature));\n+    if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some() {\n+        err.emit();\n+        return;\n+    }\n+    err.fileline_help(span, &format!(\"add #![feature({})] to the \\\n+                                      crate attributes to enable\",\n+                                     feature));\n+    err.emit();\n }\n \n pub const EXPLAIN_ASM: &'static str =\n@@ -942,11 +946,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 self.gate_feature(\"braced_empty_structs\", span,\n                                   \"empty structs and enum variants with braces are unstable\");\n             } else if s.is_tuple() {\n-                self.context.span_handler.span_err(span, \"empty tuple structs and enum variants \\\n-                                                          are not allowed, use unit structs and \\\n-                                                          enum variants instead\");\n-                self.context.span_handler.span_help(span, \"remove trailing `()` to make a unit \\\n-                                                           struct or unit enum variant\");\n+                self.context.span_handler.struct_span_err(span, \"empty tuple structs and enum \\\n+                                                                 variants are not allowed, use \\\n+                                                                 unit structs and enum variants \\\n+                                                                 instead\")\n+                                         .span_help(span, \"remove trailing `()` to make a unit \\\n+                                                           struct or unit enum variant\")\n+                                         .emit();\n             }\n         }\n         visit::walk_struct_def(self, s)"}, {"sha": "795f4044f6eb1be35c1bb8b74a49093b813be9c9", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -40,17 +40,22 @@ extern crate libc;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-// A variant of 'try!' that panics on Err(FatalError). This is used as a\n-// crutch on the way towards a non-panic!-prone parser. It should be used\n-// for fatal parsing errors; eventually we plan to convert all code using\n-// panictry to just use normal try\n+// A variant of 'try!' that panics on an Err. This is used as a crutch on the\n+// way towards a non-panic!-prone parser. It should be used for fatal parsing\n+// errors; eventually we plan to convert all code using panictry to just use\n+// normal try.\n+// Exported for syntax_ext, not meant for general use.\n+#[macro_export]\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use errors::FatalError;\n+        use $crate::errors::FatalError;\n         match $e {\n             Ok(e) => e,\n-            Err(FatalError) => panic!(FatalError)\n+            Err(mut e) => {\n+                e.emit();\n+                panic!(FatalError);\n+            }\n         }\n     })\n }"}, {"sha": "35ec3dcb0fd5f2a540ebaa924aaa26ab3e752af9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -19,7 +19,7 @@ use ptr::P;\n \n impl<'a> Parser<'a> {\n     /// Parse attributes that appear before an item\n-    pub fn parse_outer_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n+    pub fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n@@ -51,7 +51,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n-    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<ast::Attribute> {\n+    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value, mut style) = match self.token {\n@@ -64,11 +64,13 @@ impl<'a> Parser<'a> {\n                     try!(self.bump());\n                     if !permit_inner {\n                         let span = self.span;\n-                        self.span_err(span,\n-                                      \"an inner attribute is not permitted in \\\n-                                       this context\");\n-                        self.fileline_help(span,\n-                                       \"place inner attribute at the top of the module or block\");\n+                        self.diagnostic().struct_span_err(span,\n+                                                          \"an inner attribute is not permitted in \\\n+                                                           this context\")\n+                                         .fileline_help(span,\n+                                                        \"place inner attribute at the top of \\\n+                                                         the module or block\")\n+                                         .emit()\n                     }\n                     ast::AttrStyle::Inner\n                 } else {\n@@ -111,7 +113,7 @@ impl<'a> Parser<'a> {\n     /// terminated by a semicolon.\n \n     /// matches inner_attrs*\n-    pub fn parse_inner_attributes(&mut self) -> PResult<Vec<ast::Attribute>> {\n+    pub fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             match self.token {\n@@ -146,7 +148,7 @@ impl<'a> Parser<'a> {\n     /// matches meta_item = IDENT\n     /// | IDENT = lit\n     /// | IDENT meta_seq\n-    pub fn parse_meta_item(&mut self) -> PResult<P<ast::MetaItem>> {\n+    pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n         let nt_meta = match self.token {\n             token::Interpolated(token::NtMeta(ref e)) => {\n                 Some(e.clone())\n@@ -195,10 +197,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> PResult<Vec<P<ast::MetaItem>>> {\n+    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<P<ast::MetaItem>>> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n                                  &token::CloseDelim(token::Paren),\n                                  seq_sep_trailing_allowed(token::Comma),\n-                                 |p| p.parse_meta_item())\n+                                 |p: &mut Parser<'a>| p.parse_meta_item())\n     }\n }"}, {"sha": "3d8f3bcd5268fa174c9df7084c8faf8aff340305", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n-use errors::{FatalError, Handler};\n+use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n use parse::token;\n@@ -173,10 +173,6 @@ impl<'a> StringReader<'a> {\n         self.span_diagnostic.span_err(sp, m)\n     }\n \n-    /// Suggest some help with a given span.\n-    pub fn help_span(&self, sp: Span, m: &str) {\n-        self.span_diagnostic.span_help(sp, m)\n-    }\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n     fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n@@ -188,11 +184,6 @@ impl<'a> StringReader<'a> {\n         self.err_span(codemap::mk_sp(from_pos, to_pos), m)\n     }\n \n-    /// Suggest some help spanning [`from_pos`, `to_pos`).\n-    fn help_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.help_span(codemap::mk_sp(from_pos, to_pos), m)\n-    }\n-\n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> FatalError {\n@@ -201,6 +192,17 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() { m.push(c) }\n         self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n+    fn struct_fatal_span_char(&self,\n+                              from_pos: BytePos,\n+                              to_pos: BytePos,\n+                              m: &str,\n+                              c: char)\n+                              -> DiagnosticBuilder<'a>  {\n+        let mut m = m.to_string();\n+        m.push_str(\": \");\n+        for c in c.escape_default() { m.push(c) }\n+        self.span_diagnostic.struct_span_fatal(codemap::mk_sp(from_pos, to_pos), &m[..])\n+    }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n@@ -210,6 +212,17 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() { m.push(c) }\n         self.err_span_(from_pos, to_pos, &m[..]);\n     }\n+    fn struct_err_span_char(&self,\n+                            from_pos: BytePos,\n+                            to_pos: BytePos,\n+                            m: &str,\n+                            c: char)\n+                            -> DiagnosticBuilder<'a>  {\n+        let mut m = m.to_string();\n+        m.push_str(\": \");\n+        for c in c.escape_default() { m.push(c) }\n+        self.span_diagnostic.struct_span_err(codemap::mk_sp(from_pos, to_pos), &m[..])\n+    }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n     /// offending string to the error message\n@@ -746,10 +759,12 @@ impl<'a> StringReader<'a> {\n                                 let valid = if self.curr_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n-                                    self.err_span_(start, self.last_pos,\n-                                        \"incorrect unicode escape sequence\");\n-                                    self.help_span_(start, self.last_pos,\n-                                        \"format of unicode escape sequences is `\\\\u{\u2026}`\");\n+                                    let span = codemap::mk_sp(start, self.last_pos);\n+                                    self.span_diagnostic.struct_span_err(span,\n+                                        \"incorrect unicode escape sequence\")\n+                                        .span_help(span,\n+                                        \"format of unicode escape sequences is `\\\\u{\u2026}`\")\n+                                        .emit();\n                                     false\n                                 };\n                                 if ascii_only {\n@@ -771,21 +786,22 @@ impl<'a> StringReader<'a> {\n                             }\n                             c => {\n                                 let last_pos = self.last_pos;\n-                                self.err_span_char(\n+                                let mut err = self.struct_err_span_char(\n                                     escaped_pos, last_pos,\n                                     if ascii_only { \"unknown byte escape\" }\n                                     else { \"unknown character escape\" },\n                                     c);\n                                 if e == '\\r' {\n-                                    self.help_span_(escaped_pos, last_pos,\n+                                    err.span_help(codemap::mk_sp(escaped_pos, last_pos),\n                                         \"this is an isolated carriage return; consider checking \\\n-                                         your editor and version control settings\")\n+                                         your editor and version control settings\");\n                                 }\n                                 if (e == '{' || e == '}') && !ascii_only {\n-                                    self.help_span_(escaped_pos, last_pos,\n+                                    err.span_help(codemap::mk_sp(escaped_pos, last_pos),\n                                         \"if used in a formatting string, \\\n-                                        curly braces are escaped with `{{` and `}}`\")\n+                                        curly braces are escaped with `{{` and `}}`\");\n                                 }\n+                                err.emit();\n                                 false\n                             }\n                         }\n@@ -1224,8 +1240,13 @@ impl<'a> StringReader<'a> {\n           c => {\n               let last_bpos = self.last_pos;\n               let bpos = self.pos;\n-              unicode_chars::check_for_substitution(&self, c);\n-              panic!(self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c))\n+              let mut err = self.struct_fatal_span_char(last_bpos,\n+                                                        bpos,\n+                                                        \"unknown start of token\",\n+                                                        c);\n+              unicode_chars::check_for_substitution(&self, c, &mut err);\n+              err.emit();\n+              panic!(FatalError);\n           }\n         }\n     }"}, {"sha": "1d32dd4973127432562f15c14cadeb2f9ab49696", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -12,6 +12,7 @@\n // http://www.unicode.org/Public/security/revision-06/confusables.txt\n \n use codemap::mk_sp as make_span;\n+use errors::DiagnosticBuilder;\n use super::StringReader;\n \n const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n@@ -179,7 +180,9 @@ const ASCII_ARRAY: &'static [(char, &'static str)] = &[\n     ('=', \"Equals Sign\"),\n     ('>', \"Greater-Than Sign\"), ];\n \n-pub fn check_for_substitution(reader: &StringReader, ch: char) {\n+pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n+                                  ch: char,\n+                                  err: &mut DiagnosticBuilder<'a>) {\n     UNICODE_ARRAY\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n@@ -190,7 +193,7 @@ pub fn check_for_substitution(reader: &StringReader, ch: char) {\n                 let msg =\n                     format!(\"unicode character '{}' ({}) looks much like '{}' ({}), but it's not\",\n                             ch, u_name, ascii_char, ascii_name);\n-                reader.help_span(span, &msg);\n+                err.span_help(span, &msg);\n             },\n             None => {\n                 reader"}, {"sha": "efbde0f85a6b5426d99d61fd34d4e16812617623", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -12,7 +12,7 @@\n \n use ast;\n use codemap::{self, Span, CodeMap, FileMap};\n-use errors::{Handler, ColorConfig, FatalError};\n+use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n@@ -25,7 +25,7 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n \n-pub type PResult<T> = Result<T, FatalError>;\n+pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n #[macro_use]\n pub mod parser;\n@@ -76,17 +76,17 @@ pub fn parse_crate_from_file(\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> ast::Crate {\n-    panictry!(new_parser_from_file(sess, cfg, input).parse_crate_mod())\n-    // why is there no p.abort_if_errors here?\n+    let mut parser = new_parser_from_file(sess, cfg, input);\n+    abort_if_errors(parser.parse_crate_mod(), &parser)\n }\n \n pub fn parse_crate_attrs_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> Vec<ast::Attribute> {\n-    // FIXME: maybe_aborted?\n-    panictry!(new_parser_from_file(sess, cfg, input).parse_inner_attributes())\n+    let mut parser = new_parser_from_file(sess, cfg, input);\n+    abort_if_errors(parser.parse_inner_attributes(), &parser)\n }\n \n pub fn parse_crate_from_source_str(name: String,\n@@ -271,6 +271,20 @@ pub fn maybe_aborted<T>(result: T, p: Parser) -> T {\n     result\n }\n \n+fn abort_if_errors<'a, T>(result: PResult<'a, T>, p: &Parser) -> T {\n+    match result {\n+        Ok(c) => {\n+            p.abort_if_errors();\n+            c\n+        }\n+        Err(mut e) => {\n+            e.emit();\n+            p.abort_if_errors();\n+            unreachable!();\n+        }\n+    }\n+}\n+\n /// Parse a string representing a character literal into its final form.\n /// Rather than just accepting/rejecting a given literal, unescapes it as\n /// well. Can take any slice prefixed by a character escape. Returns the\n@@ -449,11 +463,13 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n         Some(suf) => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n-                sd.span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]));\n-                sd.fileline_help(sp, \"valid widths are 32 and 64\");\n+                sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n+                 .fileline_help(sp, \"valid widths are 32 and 64\")\n+                 .emit();\n             } else {\n-                sd.span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf));\n-                sd.fileline_help(sp, \"valid suffixes are `f32` and `f64`\");\n+                sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf))\n+                  .fileline_help(sp, \"valid suffixes are `f32` and `f64`\")\n+                  .emit();\n             }\n \n             ast::LitFloatUnsuffixed(data)\n@@ -622,13 +638,15 @@ pub fn integer_lit(s: &str,\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n-                    sd.span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n-                                             &suf[1..]));\n-                    sd.fileline_help(sp, \"valid widths are 8, 16, 32 and 64\");\n+                    sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n+                                             &suf[1..]))\n+                      .fileline_help(sp, \"valid widths are 8, 16, 32 and 64\")\n+                      .emit();\n                 } else {\n-                    sd.span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf));\n-                    sd.fileline_help(sp, \"the suffix must be one of the integral types \\\n-                                      (`u32`, `isize`, etc)\");\n+                    sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n+                      .fileline_help(sp, \"the suffix must be one of the integral types \\\n+                                      (`u32`, `isize`, etc)\")\n+                      .emit();\n                 }\n \n                 ty"}, {"sha": "75f1ac49c9acc92956446f5db7d56edab98e57b7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -59,18 +59,17 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               kind_str: &str,\n               desc: &str,\n               error: bool) {\n-        if error {\n-            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str));\n+        let mut err = if error {\n+            self.diagnostic().struct_span_err(sp, &format!(\"obsolete syntax: {}\", kind_str))\n         } else {\n-            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str));\n-        }\n+            self.diagnostic().struct_span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str))\n+        };\n \n         if !self.obsolete_set.contains(&kind) &&\n             (error || self.sess.span_diagnostic.can_emit_warnings) {\n-            self.sess\n-                .span_diagnostic\n-                .note(&format!(\"{}\", desc));\n+            err.note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }\n+        err.emit();\n     }\n }"}, {"sha": "efd351a632da14f73447502bca5882ee621e681f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 237, "deletions": 231, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -60,7 +60,7 @@ use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n-use errors::{self, FatalError};\n+use errors::{self, DiagnosticBuilder};\n use ext::tt::macro_parser;\n use parse;\n use parse::classify;\n@@ -392,14 +392,14 @@ impl<'a> Parser<'a> {\n         Parser::token_to_string(&self.token)\n     }\n \n-    pub fn unexpected_last(&self, t: &token::Token) -> FatalError {\n+    pub fn unexpected_last(&self, t: &token::Token) -> DiagnosticBuilder<'a> {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n         self.span_fatal(last_span, &format!(\"unexpected token: `{}`\",\n                                                 token_str))\n     }\n \n-    pub fn unexpected(&mut self) -> FatalError {\n+    pub fn unexpected(&mut self) -> DiagnosticBuilder<'a> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => e,\n             Ok(_) => unreachable!()\n@@ -408,7 +408,7 @@ impl<'a> Parser<'a> {\n \n     /// Expect and consume the token t. Signal an error if\n     /// the next token is not t.\n-    pub fn expect(&mut self, t: &token::Token) -> PResult<()> {\n+    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  ()> {\n         if self.expected_tokens.is_empty() {\n             if self.token == *t {\n                 self.bump()\n@@ -429,7 +429,7 @@ impl<'a> Parser<'a> {\n     /// anything.  Signal a fatal error if next token is unexpected.\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n-                         inedible: &[token::Token]) -> PResult<()>{\n+                         inedible: &[token::Token]) -> PResult<'a,  ()>{\n         fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n@@ -484,7 +484,7 @@ impl<'a> Parser<'a> {\n     /// true if and only if input was consumed for recovery.\n     pub fn check_for_erroneous_unit_struct_expecting(&mut self,\n                                                      expected: &[token::Token])\n-                                                     -> PResult<bool> {\n+                                                     -> PResult<'a, bool> {\n         if self.token == token::OpenDelim(token::Brace)\n             && expected.iter().all(|t| *t != token::OpenDelim(token::Brace))\n             && self.look_ahead(1, |t| *t == token::CloseDelim(token::Brace)) {\n@@ -504,7 +504,7 @@ impl<'a> Parser<'a> {\n     /// followed by some token from the set edible + inedible.  Recover\n     /// from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<()> {\n+                       inedible: &[token::Token]) -> PResult<'a, ()> {\n         debug!(\"commit_expr {:?}\", e);\n         if let ExprPath(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n@@ -517,15 +517,15 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&mut self, e: &Expr, edible: token::Token) -> PResult<()> {\n+    pub fn commit_expr_expecting(&mut self, e: &Expr, edible: token::Token) -> PResult<'a, ()> {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     /// Commit to parsing a complete statement `s`, which expects to be\n     /// followed by some token from the set edible + inedible.  Check\n     /// for recoverable input errors, discarding erroneous characters.\n     pub fn commit_stmt(&mut self, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<()> {\n+                       inedible: &[token::Token]) -> PResult<'a, ()> {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n@@ -538,11 +538,11 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&mut self, edible: token::Token) -> PResult<()> {\n+    pub fn commit_stmt_expecting(&mut self, edible: token::Token) -> PResult<'a, ()> {\n         self.commit_stmt(&[edible], &[])\n     }\n \n-    pub fn parse_ident(&mut self) -> PResult<ast::Ident> {\n+    pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.check_strict_keywords();\n         try!(self.check_reserved_keywords());\n         match self.token {\n@@ -561,15 +561,15 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ident_or_self_type(&mut self) -> PResult<ast::Ident> {\n+    pub fn parse_ident_or_self_type(&mut self) -> PResult<'a, ast::Ident> {\n         if self.is_self_type_ident() {\n             self.expect_self_type_ident()\n         } else {\n             self.parse_ident()\n         }\n     }\n \n-    pub fn parse_path_list_item(&mut self) -> PResult<ast::PathListItem> {\n+    pub fn parse_path_list_item(&mut self) -> PResult<'a, ast::PathListItem> {\n         let lo = self.span.lo;\n         let node = if try!(self.eat_keyword(keywords::SelfValue)) {\n             let rename = try!(self.parse_rename());\n@@ -595,7 +595,7 @@ impl<'a> Parser<'a> {\n \n     /// Consume token 'tok' if it exists. Returns true if the given\n     /// token was present, false otherwise.\n-    pub fn eat(&mut self, tok: &token::Token) -> PResult<bool> {\n+    pub fn eat(&mut self, tok: &token::Token) -> PResult<'a, bool> {\n         let is_present = self.check(tok);\n         if is_present { try!(self.bump())}\n         Ok(is_present)\n@@ -608,7 +608,7 @@ impl<'a> Parser<'a> {\n \n     /// If the next token is the given keyword, eat it and return\n     /// true. Otherwise, return false.\n-    pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> PResult<bool> {\n+    pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> PResult<'a, bool> {\n         if self.check_keyword(kw) {\n             try!(self.bump());\n             Ok(true)\n@@ -617,7 +617,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn eat_keyword_noexpect(&mut self, kw: keywords::Keyword) -> PResult<bool> {\n+    pub fn eat_keyword_noexpect(&mut self, kw: keywords::Keyword) -> PResult<'a, bool> {\n         if self.token.is_keyword(kw) {\n             try!(self.bump());\n             Ok(true)\n@@ -629,7 +629,7 @@ impl<'a> Parser<'a> {\n     /// If the given word is not a keyword, signal an error.\n     /// If the next token is not the given word, signal an error.\n     /// Otherwise, eat it.\n-    pub fn expect_keyword(&mut self, kw: keywords::Keyword) -> PResult<()> {\n+    pub fn expect_keyword(&mut self, kw: keywords::Keyword) -> PResult<'a, ()> {\n         if !try!(self.eat_keyword(kw) ){\n             self.expect_one_of(&[], &[])\n         } else {\n@@ -649,19 +649,18 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&mut self) -> PResult<()>{\n+    pub fn check_reserved_keywords(&mut self) -> PResult<'a, ()>{\n         if self.token.is_reserved_keyword() {\n             let token_str = self.this_token_to_string();\n-            Err(self.fatal(&format!(\"`{}` is a reserved keyword\",\n-                               token_str)))\n+            Err(self.fatal(&format!(\"`{}` is a reserved keyword\", token_str)))\n         } else {\n             Ok(())\n         }\n     }\n \n     /// Expect and consume an `&`. If `&&` is seen, replace it with a single\n     /// `&` and continue. If an `&` is not seen, signal an error.\n-    fn expect_and(&mut self) -> PResult<()> {\n+    fn expect_and(&mut self) -> PResult<'a, ()> {\n         self.expected_tokens.push(TokenType::Token(token::BinOp(token::And)));\n         match self.token {\n             token::BinOp(token::And) => self.bump(),\n@@ -693,7 +692,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// This is meant to be used when parsing generics on a path to get the\n     /// starting token.\n-    fn eat_lt(&mut self) -> PResult<bool> {\n+    fn eat_lt(&mut self) -> PResult<'a, bool> {\n         self.expected_tokens.push(TokenType::Token(token::Lt));\n         match self.token {\n             token::Lt => { try!(self.bump()); Ok(true)}\n@@ -707,7 +706,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_lt(&mut self) -> PResult<()> {\n+    fn expect_lt(&mut self) -> PResult<'a, ()> {\n         if !try!(self.eat_lt()) {\n             self.expect_one_of(&[], &[])\n         } else {\n@@ -718,7 +717,7 @@ impl<'a> Parser<'a> {\n     /// Expect and consume a GT. if a >> is seen, replace it\n     /// with a single > and continue. If a GT is not seen,\n     /// signal an error.\n-    pub fn expect_gt(&mut self) -> PResult<()> {\n+    pub fn expect_gt(&mut self) -> PResult<'a, ()> {\n         self.expected_tokens.push(TokenType::Token(token::Gt));\n         match self.token {\n             token::Gt => self.bump(),\n@@ -750,8 +749,8 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n                                                   sep: Option<token::Token>,\n                                                   mut f: F)\n-                                                  -> PResult<(P<[T]>, bool)> where\n-        F: FnMut(&mut Parser) -> PResult<Option<T>>,\n+                                                  -> PResult<'a, (P<[T]>, bool)>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a, Option<T>>,\n     {\n         let mut v = Vec::new();\n         // This loop works by alternating back and forth between parsing types\n@@ -788,8 +787,8 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_gt<T, F>(&mut self,\n                                         sep: Option<token::Token>,\n                                         mut f: F)\n-                                        -> PResult<P<[T]>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                        -> PResult<'a, P<[T]>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let (result, returned) = try!(self.parse_seq_to_before_gt_or_return(sep,\n                                                     |p| Ok(Some(try!(f(p))))));\n@@ -800,8 +799,8 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt<T, F>(&mut self,\n                                  sep: Option<token::Token>,\n                                  f: F)\n-                                 -> PResult<P<[T]>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                 -> PResult<'a, P<[T]>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let v = try!(self.parse_seq_to_before_gt(sep, f));\n         try!(self.expect_gt());\n@@ -811,8 +810,8 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n                                            sep: Option<token::Token>,\n                                            f: F)\n-                                           -> PResult<(P<[T]>, bool)> where\n-        F: FnMut(&mut Parser) -> PResult<Option<T>>,\n+                                           -> PResult<'a, (P<[T]>, bool)> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a, Option<T>>,\n     {\n         let (v, returned) = try!(self.parse_seq_to_before_gt_or_return(sep, f));\n         if !returned {\n@@ -828,8 +827,8 @@ impl<'a> Parser<'a> {\n                                   ket: &token::Token,\n                                   sep: SeqSep,\n                                   f: F)\n-                                  -> PResult<Vec<T>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                  -> PResult<'a, Vec<T>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         let val = try!(self.parse_seq_to_before_end(ket, sep, f));\n         try!(self.bump());\n@@ -843,8 +842,8 @@ impl<'a> Parser<'a> {\n                                          ket: &token::Token,\n                                          sep: SeqSep,\n                                          mut f: F)\n-                                         -> PResult<Vec<T>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                         -> PResult<'a, Vec<T>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         let mut first: bool = true;\n         let mut v = vec!();\n@@ -870,8 +869,8 @@ impl<'a> Parser<'a> {\n                                      ket: &token::Token,\n                                      sep: SeqSep,\n                                      f: F)\n-                                     -> PResult<Vec<T>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                     -> PResult<'a, Vec<T>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         try!(self.expect(bra));\n         let result = try!(self.parse_seq_to_before_end(ket, sep, f));\n@@ -886,8 +885,8 @@ impl<'a> Parser<'a> {\n                                         ket: &token::Token,\n                                         sep: SeqSep,\n                                         f: F)\n-                                        -> PResult<Vec<T>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                                        -> PResult<'a, Vec<T>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         let result = try!(self.parse_unspanned_seq(bra, ket, sep, f));\n         if result.is_empty() {\n@@ -905,8 +904,8 @@ impl<'a> Parser<'a> {\n                            ket: &token::Token,\n                            sep: SeqSep,\n                            f: F)\n-                           -> PResult<Spanned<Vec<T>>> where\n-        F: FnMut(&mut Parser) -> PResult<T>,\n+                           -> PResult<'a, Spanned<Vec<T>>> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         let lo = self.span.lo;\n         try!(self.expect(bra));\n@@ -917,7 +916,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Advance the parser by one token\n-    pub fn bump(&mut self) -> PResult<()> {\n+    pub fn bump(&mut self) -> PResult<'a,  ()> {\n         self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         self.last_token = if self.token.is_ident() ||\n@@ -950,7 +949,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Advance the parser by one token and return the bumped token.\n-    pub fn bump_and_get(&mut self) -> PResult<token::Token> {\n+    pub fn bump_and_get(&mut self) -> PResult<'a, token::Token> {\n         let old_token = mem::replace(&mut self.token, token::Underscore);\n         try!(self.bump());\n         Ok(old_token)\n@@ -981,28 +980,16 @@ impl<'a> Parser<'a> {\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as usize].tok)\n     }\n-    pub fn fatal(&self, m: &str) -> errors::FatalError {\n-        self.sess.span_diagnostic.span_fatal(self.span, m)\n+    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_fatal(self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: Span, m: &str) -> errors::FatalError {\n-        self.sess.span_diagnostic.span_fatal(sp, m)\n+    pub fn span_fatal(&self, sp: Span, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n     }\n-    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> errors::FatalError {\n-        self.span_err(sp, m);\n-        self.fileline_help(sp, help);\n-        errors::FatalError\n-    }\n-    pub fn span_note(&self, sp: Span, m: &str) {\n-        self.sess.span_diagnostic.span_note(sp, m)\n-    }\n-    pub fn span_help(&self, sp: Span, m: &str) {\n-        self.sess.span_diagnostic.span_help(sp, m)\n-    }\n-    pub fn span_suggestion(&self, sp: Span, m: &str, n: String) {\n-        self.sess.span_diagnostic.span_suggestion(sp, m, n)\n-    }\n-    pub fn fileline_help(&self, sp: Span, m: &str) {\n-        self.sess.span_diagnostic.fileline_help(sp, m)\n+    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n+        let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n+        err.fileline_help(sp, help);\n+        err\n     }\n     pub fn bug(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(self.span, m)\n@@ -1023,6 +1010,10 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.abort_if_errors();\n     }\n \n+    pub fn diagnostic(&self) -> &'a errors::Handler {\n+        &self.sess.span_diagnostic\n+    }\n+\n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n         id.name.as_str()\n     }\n@@ -1042,7 +1033,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_for_in_type(&mut self) -> PResult<Ty_> {\n+    pub fn parse_for_in_type(&mut self) -> PResult<'a, Ty_> {\n         /*\n         Parses whatever can come after a `for` keyword in a type.\n         The `for` has already been consumed.\n@@ -1085,12 +1076,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ty_path(&mut self) -> PResult<Ty_> {\n+    pub fn parse_ty_path(&mut self) -> PResult<'a, Ty_> {\n         Ok(TyPath(None, try!(self.parse_path(LifetimeAndTypesWithoutColons))))\n     }\n \n     /// parse a TyBareFn type:\n-    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> PResult<Ty_> {\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> PResult<'a, Ty_> {\n         /*\n \n         [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n@@ -1127,7 +1118,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an obsolete closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_obsolete_closure_kind(&mut self) -> PResult<()> {\n+    pub fn parse_obsolete_closure_kind(&mut self) -> PResult<'a, ()> {\n          let lo = self.span.lo;\n         if\n             self.check(&token::BinOp(token::And)) &&\n@@ -1156,7 +1147,7 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    pub fn parse_unsafety(&mut self) -> PResult<Unsafety> {\n+    pub fn parse_unsafety(&mut self) -> PResult<'a, Unsafety> {\n         if try!(self.eat_keyword(keywords::Unsafe)) {\n             return Ok(Unsafety::Unsafe);\n         } else {\n@@ -1165,12 +1156,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> PResult<Vec<P<TraitItem>>> {\n+    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<P<TraitItem>>> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(token::Brace),\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n-            |p| -> PResult<P<TraitItem>> {\n+            |p| -> PResult<'a, P<TraitItem>> {\n             maybe_whole!(no_clone p, NtTraitItem);\n             let mut attrs = try!(p.parse_outer_attributes());\n             let lo = p.span.lo;\n@@ -1200,7 +1191,7 @@ impl<'a> Parser<'a> {\n                 let ident = try!(p.parse_ident());\n                 let mut generics = try!(p.parse_generics());\n \n-                let (explicit_self, d) = try!(p.parse_fn_decl_with_self(|p|{\n+                let (explicit_self, d) = try!(p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n@@ -1251,14 +1242,14 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a possibly mutable type\n-    pub fn parse_mt(&mut self) -> PResult<MutTy> {\n+    pub fn parse_mt(&mut self) -> PResult<'a, MutTy> {\n         let mutbl = try!(self.parse_mutability());\n         let t = try!(self.parse_ty());\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n     /// Parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&mut self) -> PResult<FunctionRetTy> {\n+    pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if try!(self.eat(&token::RArrow) ){\n             if try!(self.eat(&token::Not) ){\n                 Ok(NoReturn(self.last_span))\n@@ -1272,7 +1263,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a type in a context where `T1+T2` is allowed.\n-    pub fn parse_ty_sum(&mut self) -> PResult<P<Ty>> {\n+    pub fn parse_ty_sum(&mut self) -> PResult<'a, P<Ty>> {\n         let lo = self.span.lo;\n         let lhs = try!(self.parse_ty());\n \n@@ -1297,7 +1288,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a type.\n-    pub fn parse_ty(&mut self) -> PResult<P<Ty>> {\n+    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1397,15 +1388,15 @@ impl<'a> Parser<'a> {\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}))\n     }\n \n-    pub fn parse_borrowed_pointee(&mut self) -> PResult<Ty_> {\n+    pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, Ty_> {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = try!(self.parse_opt_lifetime());\n \n         let mt = try!(self.parse_mt());\n         return Ok(TyRptr(opt_lifetime, mt));\n     }\n \n-    pub fn parse_ptr(&mut self) -> PResult<MutTy> {\n+    pub fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n         let mutbl = if try!(self.eat_keyword(keywords::Mut) ){\n             MutMutable\n         } else if try!(self.eat_keyword(keywords::Const) ){\n@@ -1443,7 +1434,7 @@ impl<'a> Parser<'a> {\n \n     /// This version of parse arg doesn't necessarily require\n     /// identifier names.\n-    pub fn parse_arg_general(&mut self, require_name: bool) -> PResult<Arg> {\n+    pub fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> {\n         maybe_whole!(no_clone self, NtArg);\n \n         let pat = if require_name || self.is_named_argument() {\n@@ -1470,12 +1461,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a single function argument\n-    pub fn parse_arg(&mut self) -> PResult<Arg> {\n+    pub fn parse_arg(&mut self) -> PResult<'a, Arg> {\n         self.parse_arg_general(true)\n     }\n \n     /// Parse an argument in a lambda header e.g. |arg, arg|\n-    pub fn parse_fn_block_arg(&mut self) -> PResult<Arg> {\n+    pub fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n         let pat = try!(self.parse_pat());\n         let t = if try!(self.eat(&token::Colon) ){\n             try!(self.parse_ty_sum())\n@@ -1493,7 +1484,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<Option<P<ast::Expr>>> {\n+    pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n         if self.check(&token::Semi) {\n             try!(self.bump());\n             Ok(Some(try!(self.parse_expr())))\n@@ -1503,7 +1494,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches token_lit = LIT_INTEGER | ...\n-    pub fn lit_from_token(&self, tok: &token::Token) -> PResult<Lit_> {\n+    pub fn lit_from_token(&self, tok: &token::Token) -> PResult<'a, Lit_> {\n         match *tok {\n             token::Interpolated(token::NtExpr(ref v)) => {\n                 match v.node {\n@@ -1562,7 +1553,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches lit = true | false | token_lit\n-    pub fn parse_lit(&mut self) -> PResult<Lit> {\n+    pub fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         let lo = self.span.lo;\n         let lit = if try!(self.eat_keyword(keywords::True) ){\n             LitBool(true)\n@@ -1577,7 +1568,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches '-' lit | lit\n-    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         let minus_lo = self.span.lo;\n         let minus_present = try!(self.eat(&token::BinOp(token::Minus)));\n         let lo = self.span.lo;\n@@ -1610,7 +1601,7 @@ impl<'a> Parser<'a> {\n     /// `<T as U>::a`\n     /// `<T as U>::F::a::<S>`\n     pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n-                                -> PResult<(QSelf, ast::Path)> {\n+                                -> PResult<'a, (QSelf, ast::Path)> {\n         let span = self.last_span;\n         let self_type = try!(self.parse_ty_sum());\n         let mut path = if try!(self.eat_keyword(keywords::As)) {\n@@ -1653,7 +1644,7 @@ impl<'a> Parser<'a> {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&mut self, mode: PathParsingMode) -> PResult<ast::Path> {\n+    pub fn parse_path(&mut self, mode: PathParsingMode) -> PResult<'a, ast::Path> {\n         // Check for a whole path...\n         let found = match self.token {\n             token::Interpolated(token::NtPath(_)) => Some(try!(self.bump_and_get())),\n@@ -1696,7 +1687,7 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1749,7 +1740,7 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1794,7 +1785,7 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self) -> PResult<Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_types(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1814,7 +1805,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&mut self) -> PResult<Option<ast::Lifetime>> {\n+    pub fn parse_opt_lifetime(&mut self) -> PResult<'a, Option<ast::Lifetime>> {\n         match self.token {\n             token::Lifetime(..) => {\n                 Ok(Some(try!(self.parse_lifetime())))\n@@ -1827,7 +1818,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a single lifetime\n     /// Matches lifetime = LIFETIME\n-    pub fn parse_lifetime(&mut self) -> PResult<ast::Lifetime> {\n+    pub fn parse_lifetime(&mut self) -> PResult<'a, ast::Lifetime> {\n         match self.token {\n             token::Lifetime(i) => {\n                 let span = self.span;\n@@ -1846,7 +1837,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses `lifetime_defs = [ lifetime_defs { ',' lifetime_defs } ]` where `lifetime_def  =\n     /// lifetime [':' lifetimes]`\n-    pub fn parse_lifetime_defs(&mut self) -> PResult<Vec<ast::LifetimeDef>> {\n+    pub fn parse_lifetime_defs(&mut self) -> PResult<'a, Vec<ast::LifetimeDef>> {\n \n         let mut res = Vec::new();\n         loop {\n@@ -1889,7 +1880,7 @@ impl<'a> Parser<'a> {\n     /// Parses zero or more comma separated lifetimes. Expects each lifetime to be followed by\n     /// either a comma or `>`.  Used when parsing type parameter lists, where we expect something\n     /// like `<'a, 'b, T>`.\n-    pub fn parse_lifetimes(&mut self, sep: token::Token) -> PResult<Vec<ast::Lifetime>> {\n+    pub fn parse_lifetimes(&mut self, sep: token::Token) -> PResult<'a, Vec<ast::Lifetime>> {\n \n         let mut res = Vec::new();\n         loop {\n@@ -1911,7 +1902,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse mutability declaration (mut/const/imm)\n-    pub fn parse_mutability(&mut self) -> PResult<Mutability> {\n+    pub fn parse_mutability(&mut self) -> PResult<'a, Mutability> {\n         if try!(self.eat_keyword(keywords::Mut) ){\n             Ok(MutMutable)\n         } else {\n@@ -1920,7 +1911,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse ident COLON expr\n-    pub fn parse_field(&mut self) -> PResult<Field> {\n+    pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let lo = self.span.lo;\n         let i = try!(self.parse_ident());\n         let hi = self.last_span.hi;\n@@ -2012,7 +2003,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expect_open_delim(&mut self) -> PResult<token::DelimToken> {\n+    fn expect_open_delim(&mut self) -> PResult<'a, token::DelimToken> {\n         self.expected_tokens.push(TokenType::Token(token::Gt));\n         match self.token {\n             token::OpenDelim(delim) => {\n@@ -2030,7 +2021,7 @@ impl<'a> Parser<'a> {\n     /// NB: This does not parse outer attributes,\n     ///     and is private because it only works\n     ///     correctly if called from parse_dot_or_call_expr().\n-    fn parse_bottom_expr(&mut self) -> PResult<P<Expr>> {\n+    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         // Outer attributes are already parsed and will be\n@@ -2294,7 +2285,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_or_use_outer_attributes(&mut self,\n                                      already_parsed_attrs: Option<ThinAttributes>)\n-                                     -> PResult<ThinAttributes> {\n+                                     -> PResult<'a, ThinAttributes> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n@@ -2305,7 +2296,7 @@ impl<'a> Parser<'a> {\n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n                             attrs: ThinAttributes)\n-                            -> PResult<P<Expr>> {\n+                            -> PResult<'a, P<Expr>> {\n \n         let outer_attrs = attrs;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n@@ -2320,7 +2311,7 @@ impl<'a> Parser<'a> {\n     /// parse a.b or a(13) or a[4] or just a\n     pub fn parse_dot_or_call_expr(&mut self,\n                                   already_parsed_attrs: Option<ThinAttributes>)\n-                                  -> PResult<P<Expr>> {\n+                                  -> PResult<'a, P<Expr>> {\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n \n         let b = try!(self.parse_bottom_expr());\n@@ -2330,7 +2321,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n                                        attrs: ThinAttributes)\n-                                       -> PResult<P<Expr>> {\n+                                       -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n@@ -2356,7 +2347,7 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2437,18 +2428,19 @@ impl<'a> Parser<'a> {\n                     try!(self.bump());\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n-                    self.span_err(last_span,\n-                                  &format!(\"unexpected token: `{}`\", n.as_str()));\n+                    let mut err = self.diagnostic().struct_span_err(last_span,\n+                        &format!(\"unexpected token: `{}`\", n.as_str()));\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n                             None => continue,\n                         };\n-                        self.fileline_help(last_span,\n+                        err.fileline_help(last_span,\n                             &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n                                     float.trunc() as usize,\n                                     format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n                     }\n+                    err.emit();\n                     self.abort_if_errors();\n \n                   }\n@@ -2489,7 +2481,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // Parse unquoted tokens after a `$` in a token tree\n-    fn parse_unquoted(&mut self) -> PResult<TokenTree> {\n+    fn parse_unquoted(&mut self) -> PResult<'a, TokenTree> {\n         let mut sp = self.span;\n         let (name, namep) = match self.token {\n             token::Dollar => {\n@@ -2541,7 +2533,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_unknown_macro_variable(&mut self) -> PResult<()> {\n+    pub fn check_unknown_macro_variable(&mut self) -> PResult<'a, ()> {\n         if self.quote_depth == 0 {\n             match self.token {\n                 token::SubstNt(name, _) =>\n@@ -2555,8 +2547,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse an optional separator followed by a Kleene-style\n     /// repetition token (+ or *).\n-    pub fn parse_sep_and_kleene_op(&mut self) -> PResult<(Option<token::Token>, ast::KleeneOp)> {\n-        fn parse_kleene_op(parser: &mut Parser) -> PResult<Option<ast::KleeneOp>> {\n+    pub fn parse_sep_and_kleene_op(&mut self)\n+                                   -> PResult<'a, (Option<token::Token>, ast::KleeneOp)> {\n+        fn parse_kleene_op<'a>(parser: &mut Parser<'a>) -> PResult<'a,  Option<ast::KleeneOp>> {\n             match parser.token {\n                 token::BinOp(token::Star) => {\n                     try!(parser.bump());\n@@ -2583,7 +2576,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// parse a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> PResult<TokenTree> {\n+    pub fn parse_token_tree(&mut self) -> PResult<'a, TokenTree> {\n         // FIXME #6994: currently, this is too eager. It\n         // parses token trees but also identifies TokenType::Sequence's\n         // and token::SubstNt's; it's too early to know yet\n@@ -2596,20 +2589,20 @@ impl<'a> Parser<'a> {\n         // not an EOF, and not the desired right-delimiter (if\n         // it were, parse_seq_to_before_end would have prevented\n         // reaching this point.\n-        fn parse_non_delim_tt_tok(p: &mut Parser) -> PResult<TokenTree> {\n+        fn parse_non_delim_tt_tok<'b>(p: &mut Parser<'b>) -> PResult<'b,  TokenTree> {\n             maybe_whole!(deref p, NtTT);\n             match p.token {\n                 token::CloseDelim(_) => {\n+                    let token_str = p.this_token_to_string();\n+                    let mut err = p.fatal(\n+                        &format!(\"incorrect close delimiter: `{}`\", token_str));\n                     // This is a conservative error: only report the last unclosed delimiter. The\n                     // previous unclosed delimiters could actually be closed! The parser just hasn't\n                     // gotten to them yet.\n-                    match p.open_braces.last() {\n-                        None => {}\n-                        Some(&sp) => p.span_note(sp, \"unclosed delimiter\"),\n+                    if let Some(&sp) = p.open_braces.last() {\n+                        err.span_note(sp, \"unclosed delimiter\");\n                     };\n-                    let token_str = p.this_token_to_string();\n-                    Err(p.fatal(&format!(\"incorrect close delimiter: `{}`\",\n-                                    token_str)))\n+                    Err(err)\n                 },\n                 /* we ought to allow different depths of unquotation */\n                 token::Dollar | token::SubstNt(..) if p.quote_depth > 0 => {\n@@ -2624,12 +2617,12 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::Eof => {\n                 let open_braces = self.open_braces.clone();\n+                let mut err: DiagnosticBuilder<'a> =\n+                    self.fatal(\"this file contains an un-closed delimiter\");\n                 for sp in &open_braces {\n-                    self.span_help(*sp, \"did you mean to close this delimiter?\");\n+                    err.span_help(*sp, \"did you mean to close this delimiter?\");\n                 }\n-                // There shouldn't really be a span, but it's easier for the test runner\n-                // if we give it one\n-                return Err(self.fatal(\"this file contains an un-closed delimiter \"));\n+                return Err(err);\n             },\n             token::OpenDelim(delim) => {\n                 // The span for beginning of the delimited section\n@@ -2668,7 +2661,7 @@ impl<'a> Parser<'a> {\n \n     // parse a stream of tokens into a list of TokenTree's,\n     // up to EOF.\n-    pub fn parse_all_token_trees(&mut self) -> PResult<Vec<TokenTree>> {\n+    pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n         let mut tts = Vec::new();\n         while self.token != token::Eof {\n             tts.push(try!(self.parse_token_tree()));\n@@ -2679,7 +2672,7 @@ impl<'a> Parser<'a> {\n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n                              already_parsed_attrs: Option<ThinAttributes>)\n-                             -> PResult<P<Expr>> {\n+                             -> PResult<'a, P<Expr>> {\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let hi;\n@@ -2740,15 +2733,15 @@ impl<'a> Parser<'a> {\n     /// the expression.\n     pub fn parse_assoc_expr(&mut self,\n                             already_parsed_attrs: Option<ThinAttributes>)\n-                            -> PResult<P<Expr>> {\n+                            -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n \n     /// Parse an associative expression with operators of at least `min_prec` precedence\n     pub fn parse_assoc_expr_with(&mut self,\n                                  min_prec: usize,\n                                  lhs: LhsExpr)\n-                                 -> PResult<P<Expr>> {\n+                                 -> PResult<'a, P<Expr>> {\n         let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n             expr\n         } else {\n@@ -2879,12 +2872,13 @@ impl<'a> Parser<'a> {\n             ExprBinary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n-                self.span_err(op_span,\n+                let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BiLt && *outer_op == AssocOp::Greater {\n-                    self.fileline_help(op_span,\n+                    err.fileline_help(op_span,\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n+                err.emit();\n             }\n             _ => {}\n         }\n@@ -2893,7 +2887,7 @@ impl<'a> Parser<'a> {\n     /// Parse prefix-forms of range notation: `..expr` and `..`\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinAttributes>)\n-                               -> PResult<P<Expr>> {\n+                               -> PResult<'a, P<Expr>> {\n         debug_assert!(self.token == token::DotDot);\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n@@ -2928,7 +2922,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n@@ -2947,7 +2941,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n     pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n-                             -> PResult<P<Expr>> {\n+                             -> PResult<'a, P<Expr>> {\n         let lo = self.last_span.lo;\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n@@ -2967,7 +2961,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_lambda_expr(&mut self, lo: BytePos,\n                              capture_clause: CaptureClause,\n                              attrs: ThinAttributes)\n-                             -> PResult<P<Expr>>\n+                             -> PResult<'a, P<Expr>>\n     {\n         let decl = try!(self.parse_fn_block_decl());\n         let body = match decl.output {\n@@ -2997,7 +2991,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // `else` token already eaten\n-    pub fn parse_else_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if try!(self.eat_keyword(keywords::If) ){\n             return self.parse_if_expr(None);\n         } else {\n@@ -3009,7 +3003,7 @@ impl<'a> Parser<'a> {\n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n                           span_lo: BytePos,\n-                          attrs: ThinAttributes) -> PResult<P<Expr>> {\n+                          attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = try!(self.parse_pat());\n@@ -3028,7 +3022,7 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n                             span_lo: BytePos,\n-                            attrs: ThinAttributes) -> PResult<P<Expr>> {\n+                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n@@ -3043,7 +3037,7 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n                                 span_lo: BytePos,\n-                                attrs: ThinAttributes) -> PResult<P<Expr>> {\n+                                attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n@@ -3057,22 +3051,23 @@ impl<'a> Parser<'a> {\n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n                            span_lo: BytePos,\n-                           attrs: ThinAttributes) -> PResult<P<Expr>> {\n+                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n         Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n-    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n+    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n         let discriminant = try!(self.parse_expr_res(\n             Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n-        if let Err(e) = self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace)) {\n+        if let Err(mut e) = self.commit_expr_expecting(&*discriminant,\n+                                                       token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n-                self.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n+                e.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n             }\n             return Err(e)\n         }\n@@ -3087,7 +3082,7 @@ impl<'a> Parser<'a> {\n         return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n     }\n \n-    pub fn parse_arm(&mut self) -> PResult<Arm> {\n+    pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         maybe_whole!(no_clone self, NtArm);\n \n         let attrs = try!(self.parse_outer_attributes());\n@@ -3118,15 +3113,16 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression\n-    pub fn parse_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n     /// Evaluate the closure with restrictions in place.\n     ///\n     /// After the closure is evaluated, restrictions are reset.\n-    pub fn with_res<F>(&mut self, r: Restrictions, f: F) -> PResult<P<Expr>>\n-    where F: FnOnce(&mut Self) -> PResult<P<Expr>> {\n+    pub fn with_res<F>(&mut self, r: Restrictions, f: F) -> PResult<'a, P<Expr>>\n+        where F: FnOnce(&mut Self) -> PResult<'a,  P<Expr>>\n+    {\n         let old = self.restrictions;\n         self.restrictions = r;\n         let r = f(self);\n@@ -3138,12 +3134,12 @@ impl<'a> Parser<'a> {\n     /// Parse an expression, subject to the given restrictions\n     pub fn parse_expr_res(&mut self, r: Restrictions,\n                           already_parsed_attrs: Option<ThinAttributes>)\n-                          -> PResult<P<Expr>> {\n+                          -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&mut self) -> PResult<Option<P<Expr>>> {\n+    fn parse_initializer(&mut self) -> PResult<'a, Option<P<Expr>>> {\n         if self.check(&token::Eq) {\n             try!(self.bump());\n             Ok(Some(try!(self.parse_expr())))\n@@ -3153,7 +3149,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> PResult<Vec<P<Pat>>> {\n+    fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(try!(self.parse_pat()));\n@@ -3162,7 +3158,7 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    fn parse_pat_tuple_elements(&mut self) -> PResult<Vec<P<Pat>>> {\n+    fn parse_pat_tuple_elements(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n         let mut fields = vec![];\n         if !self.check(&token::CloseDelim(token::Paren)) {\n             fields.push(try!(self.parse_pat()));\n@@ -3181,7 +3177,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> PResult<(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>)> {\n+    ) -> PResult<'a, (Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>)> {\n         let mut before = Vec::new();\n         let mut slice = None;\n         let mut after = Vec::new();\n@@ -3233,7 +3229,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&mut self) -> PResult<(Vec<codemap::Spanned<ast::FieldPat>> , bool)> {\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>> , bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut first = true;\n@@ -3310,7 +3306,7 @@ impl<'a> Parser<'a> {\n         return Ok((fields, etc));\n     }\n \n-    fn parse_pat_range_end(&mut self) -> PResult<P<Expr>> {\n+    fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n         if self.is_path_start() {\n             let lo = self.span.lo;\n             let (qself, path) = if try!(self.eat_lt()) {\n@@ -3336,7 +3332,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a pattern.\n-    pub fn parse_pat(&mut self) -> PResult<P<Pat>> {\n+    pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n@@ -3496,7 +3492,7 @@ impl<'a> Parser<'a> {\n     /// error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n-                       -> PResult<ast::Pat_> {\n+                       -> PResult<'a, ast::Pat_> {\n         if !self.token.is_plain_ident() {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n@@ -3529,7 +3525,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Local>> {\n         let lo = self.span.lo;\n         let pat = try!(self.parse_pat());\n \n@@ -3549,15 +3545,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a \"let\" stmt\n-    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<P<Decl>> {\n+    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n         let lo = self.span.lo;\n         let local = try!(self.parse_local(attrs));\n         Ok(P(spanned(lo, self.last_span.hi, DeclLocal(local))))\n     }\n \n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n-                         attrs: Vec<Attribute> ) -> PResult<StructField> {\n+                         attrs: Vec<Attribute> ) -> PResult<'a, StructField> {\n         let lo = match pr {\n             Inherited => self.span.lo,\n             Public => self.last_span.lo,\n@@ -3589,11 +3585,11 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement. may include decl.\n-    pub fn parse_stmt(&mut self) -> PResult<Option<P<Stmt>>> {\n+    pub fn parse_stmt(&mut self) -> PResult<'a, Option<P<Stmt>>> {\n         Ok(try!(self.parse_stmt_()).map(P))\n     }\n \n-    fn parse_stmt_(&mut self) -> PResult<Option<Stmt>> {\n+    fn parse_stmt_(&mut self) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = try!(self.parse_outer_attributes());\n@@ -3729,7 +3725,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a block. No inner attrs are allowed.\n-    pub fn parse_block(&mut self) -> PResult<P<Block>> {\n+    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(no_clone self, NtBlock);\n \n         let lo = self.span.lo;\n@@ -3746,7 +3742,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a block. Inner attrs are allowed.\n-    fn parse_inner_attrs_and_block(&mut self) -> PResult<(Vec<Attribute>, P<Block>)> {\n+    fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(pair_empty self, NtBlock);\n \n         let lo = self.span.lo;\n@@ -3757,7 +3753,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse the rest of a block expression or function body\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<P<Block>> {\n+    fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n         let mut expr = None;\n \n@@ -3851,7 +3847,7 @@ impl<'a> Parser<'a> {\n             e: P<Expr>,\n             span: Span,\n             stmts: &mut Vec<P<Stmt>>,\n-            last_block_expr: &mut Option<P<Expr>>) -> PResult<()> {\n+            last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&*e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n@@ -3887,7 +3883,7 @@ impl<'a> Parser<'a> {\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self,\n                                         mode: BoundParsingMode)\n-                                        -> PResult<TyParamBounds>\n+                                        -> PResult<'a, TyParamBounds>\n     {\n         if !try!(self.eat(&token::Colon) ){\n             Ok(P::empty())\n@@ -3902,7 +3898,7 @@ impl<'a> Parser<'a> {\n     // and     bound     = 'region | trait_ref\n     fn parse_ty_param_bounds(&mut self,\n                              mode: BoundParsingMode)\n-                             -> PResult<TyParamBounds>\n+                             -> PResult<'a, TyParamBounds>\n     {\n         let mut result = vec!();\n         loop {\n@@ -3948,7 +3944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n-    fn parse_ty_param(&mut self) -> PResult<TyParam> {\n+    fn parse_ty_param(&mut self) -> PResult<'a, TyParam> {\n         let span = self.span;\n         let ident = try!(self.parse_ident());\n \n@@ -3977,7 +3973,7 @@ impl<'a> Parser<'a> {\n     /// matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n     ///                  | ( < lifetimes , typaramseq ( , )? > )\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n-    pub fn parse_generics(&mut self) -> PResult<ast::Generics> {\n+    pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics);\n \n         if try!(self.eat(&token::Lt) ){\n@@ -4008,7 +4004,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> PResult<(Vec<ast::Lifetime>,\n+    fn parse_generic_values_after_lt(&mut self) -> PResult<'a, (Vec<ast::Lifetime>,\n                                                             Vec<P<Ty>>,\n                                                             Vec<P<TypeBinding>>)> {\n         let span_lo = self.span.lo;\n@@ -4025,7 +4021,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"expected `,` or `>` after lifetime \\\n                               name, found `{}`\",\n                               self.this_token_to_string());\n-            self.span_err(self.span, &msg);\n+            let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n \n             let span_hi = self.span.hi;\n             let span_hi = if self.parse_ty().is_ok() {\n@@ -4037,7 +4033,8 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"did you mean a single argument type &'a Type, \\\n                               or did you mean the comma-separated arguments \\\n                               'a, Type?\");\n-            self.span_note(mk_sp(span_lo, span_hi), &msg);\n+            err.span_note(mk_sp(span_lo, span_hi), &msg);\n+            err.emit();\n \n             self.abort_if_errors()\n         }\n@@ -4085,7 +4082,7 @@ impl<'a> Parser<'a> {\n         Ok((lifetimes, types.into_vec(), bindings.into_vec()))\n     }\n \n-    fn forbid_lifetime(&mut self) -> PResult<()> {\n+    fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n         if self.token.is_lifetime() {\n             let span = self.span;\n             return Err(self.span_fatal(span, \"lifetime parameters must be declared \\\n@@ -4099,7 +4096,7 @@ impl<'a> Parser<'a> {\n     /// ```ignore\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n-    pub fn parse_where_clause(&mut self) -> PResult<ast::WhereClause> {\n+    pub fn parse_where_clause(&mut self) -> PResult<'a, ast::WhereClause> {\n         maybe_whole!(self, NtWhereClause);\n \n         let mut where_clause = WhereClause {\n@@ -4215,7 +4212,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n-                     -> PResult<(Vec<Arg> , bool)> {\n+                     -> PResult<'a, (Vec<Arg> , bool)> {\n         let sp = self.span;\n         let mut args: Vec<Option<Arg>> =\n             try!(self.parse_unspanned_seq(\n@@ -4264,7 +4261,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the argument list and result type of a function declaration\n-    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> PResult<P<FnDecl>> {\n+    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> PResult<'a, P<FnDecl>> {\n \n         let (args, variadic) = try!(self.parse_fn_args(true, allow_variadic));\n         let ret_ty = try!(self.parse_ret_ty());\n@@ -4283,7 +4280,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_self_ident(&mut self) -> PResult<ast::Ident> {\n+    fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n             token::Ident(id, token::Plain) if id.name == special_idents::self_.name => {\n                 try!(self.bump());\n@@ -4304,7 +4301,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_self_type_ident(&mut self) -> PResult<ast::Ident> {\n+    fn expect_self_type_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n             token::Ident(id, token::Plain) if id.name == special_idents::type_self.name => {\n                 try!(self.bump());\n@@ -4321,11 +4318,11 @@ impl<'a> Parser<'a> {\n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n     fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F) -> PResult<(ExplicitSelf, P<FnDecl>)> where\n-        F: FnMut(&mut Parser) -> PResult<Arg>,\n+                                  parse_arg_fn: F) -> PResult<'a, (ExplicitSelf, P<FnDecl>)> where\n+        F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n     {\n-        fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n-                                              -> PResult<ast::ExplicitSelf_> {\n+        fn maybe_parse_borrowed_explicit_self<'b>(this: &mut Parser<'b>)\n+                                                  -> PResult<'b,  ast::ExplicitSelf_> {\n             // The following things are possible to see here:\n             //\n             //     fn(&mut self)\n@@ -4483,7 +4480,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> PResult<P<FnDecl>> {\n+    fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> {\n         let inputs_captures = {\n             if try!(self.eat(&token::OrOr) ){\n                 Vec::new()\n@@ -4509,7 +4506,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the name and optional generic types of a function header.\n-    fn parse_fn_header(&mut self) -> PResult<(Ident, ast::Generics)> {\n+    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, ast::Generics)> {\n         let id = try!(self.parse_ident());\n         let generics = try!(self.parse_generics());\n         Ok((id, generics))\n@@ -4533,7 +4530,7 @@ impl<'a> Parser<'a> {\n                      unsafety: Unsafety,\n                      constness: Constness,\n                      abi: abi::Abi)\n-                     -> PResult<ItemInfo> {\n+                     -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = try!(self.parse_fn_header());\n         let decl = try!(self.parse_fn_decl(false));\n         generics.where_clause = try!(self.parse_where_clause());\n@@ -4556,7 +4553,8 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc\n-    pub fn parse_fn_front_matter(&mut self) -> PResult<(ast::Constness, ast::Unsafety, abi::Abi)> {\n+    pub fn parse_fn_front_matter(&mut self)\n+                                 -> PResult<'a, (ast::Constness, ast::Unsafety, abi::Abi)> {\n         let is_const_fn = try!(self.eat_keyword(keywords::Const));\n         let unsafety = try!(self.parse_unsafety());\n         let (constness, unsafety, abi) = if is_const_fn {\n@@ -4574,7 +4572,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an impl item.\n-    pub fn parse_impl_item(&mut self) -> PResult<P<ImplItem>> {\n+    pub fn parse_impl_item(&mut self) -> PResult<'a, P<ImplItem>> {\n         maybe_whole!(no_clone self, NtImplItem);\n \n         let mut attrs = try!(self.parse_outer_attributes());\n@@ -4614,17 +4612,18 @@ impl<'a> Parser<'a> {\n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n         match visa {\n             Public => {\n-                self.span_err(span, \"can't qualify macro invocation with `pub`\");\n-                self.fileline_help(span, \"try adjusting the macro to put `pub` inside \\\n-                                      the invocation\");\n+                self.diagnostic().struct_span_err(span, \"can't qualify macro invocation with `pub`\")\n+                                 .fileline_help(span, \"try adjusting the macro to put `pub` inside \\\n+                                                       the invocation\")\n+                                 .emit();\n             }\n             Inherited => (),\n         }\n     }\n \n     /// Parse a method or a macro invocation in a trait impl.\n     fn parse_impl_method(&mut self, vis: Visibility)\n-                         -> PResult<(Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n+                         -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not)\n@@ -4673,7 +4672,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse trait Foo { ... }\n-    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<ItemInfo> {\n+    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n \n         let ident = try!(self.parse_ident());\n         let mut tps = try!(self.parse_generics());\n@@ -4691,7 +4690,7 @@ impl<'a> Parser<'a> {\n     ///    impl<T> Foo { ... }\n     ///    impl<T> ToString for &'static T { ... }\n     ///    impl Send for .. {}\n-    fn parse_item_impl(&mut self, unsafety: ast::Unsafety) -> PResult<ItemInfo> {\n+    fn parse_item_impl(&mut self, unsafety: ast::Unsafety) -> PResult<'a, ItemInfo> {\n         let impl_span = self.span;\n \n         // First, parse type parameters if necessary.\n@@ -4769,14 +4768,14 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a::B<String,i32>\n-    fn parse_trait_ref(&mut self) -> PResult<TraitRef> {\n+    fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n         Ok(ast::TraitRef {\n             path: try!(self.parse_path(LifetimeAndTypesWithoutColons)),\n             ref_id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n-    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<Vec<ast::LifetimeDef>> {\n+    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<ast::LifetimeDef>> {\n         if try!(self.eat_keyword(keywords::For) ){\n             try!(self.expect(&token::Lt));\n             let lifetime_defs = try!(self.parse_lifetime_defs());\n@@ -4788,7 +4787,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse for<'l> a::B<String,i32>\n-    fn parse_poly_trait_ref(&mut self) -> PResult<PolyTraitRef> {\n+    fn parse_poly_trait_ref(&mut self) -> PResult<'a, PolyTraitRef> {\n         let lo = self.span.lo;\n         let lifetime_defs = try!(self.parse_late_bound_lifetime_defs());\n \n@@ -4800,7 +4799,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse struct Foo { ... }\n-    fn parse_item_struct(&mut self) -> PResult<ItemInfo> {\n+    fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = try!(self.parse_ident());\n         let mut generics = try!(self.parse_generics());\n \n@@ -4851,7 +4850,9 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemStruct(vdata, generics), None))\n     }\n \n-    pub fn parse_record_struct_body(&mut self, parse_pub: ParsePub) -> PResult<Vec<StructField>> {\n+    pub fn parse_record_struct_body(&mut self,\n+                                    parse_pub: ParsePub)\n+                                    -> PResult<'a, Vec<StructField>> {\n         let mut fields = Vec::new();\n         if try!(self.eat(&token::OpenDelim(token::Brace)) ){\n             while self.token != token::CloseDelim(token::Brace) {\n@@ -4869,7 +4870,9 @@ impl<'a> Parser<'a> {\n         Ok(fields)\n     }\n \n-    pub fn parse_tuple_struct_body(&mut self, parse_pub: ParsePub) -> PResult<Vec<StructField>> {\n+    pub fn parse_tuple_struct_body(&mut self,\n+                                   parse_pub: ParsePub)\n+                                   -> PResult<'a, Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n         let fields = try!(self.parse_unspanned_seq(\n@@ -4901,7 +4904,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_single_struct_field(&mut self,\n                                      vis: Visibility,\n                                      attrs: Vec<Attribute> )\n-                                     -> PResult<StructField> {\n+                                     -> PResult<'a, StructField> {\n         let a_var = try!(self.parse_name_and_ty(vis, attrs));\n         match self.token {\n             token::Comma => {\n@@ -4921,7 +4924,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an element of a struct definition\n-    fn parse_struct_decl_field(&mut self, parse_pub: ParsePub) -> PResult<StructField> {\n+    fn parse_struct_decl_field(&mut self, parse_pub: ParsePub) -> PResult<'a, StructField> {\n \n         let attrs = try!(self.parse_outer_attributes());\n \n@@ -4937,13 +4940,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse visibility: PUB or nothing\n-    fn parse_visibility(&mut self) -> PResult<Visibility> {\n+    fn parse_visibility(&mut self) -> PResult<'a, Visibility> {\n         if try!(self.eat_keyword(keywords::Pub)) { Ok(Public) }\n         else { Ok(Inherited) }\n     }\n \n     /// Given a termination token, parse all of the items in a module\n-    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<Mod> {\n+    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = try!(self.parse_item()) {\n             items.push(item);\n@@ -4966,7 +4969,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<ItemInfo> {\n+    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n         let id = try!(self.parse_ident());\n         try!(self.expect(&token::Colon));\n         let ty = try!(self.parse_ty_sum());\n@@ -4981,7 +4984,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<ItemInfo> {\n+    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n         let id_span = self.span;\n         let id = try!(self.parse_ident());\n         if self.check(&token::Semi) {\n@@ -5060,7 +5063,7 @@ impl<'a> Parser<'a> {\n     fn submod_path(&mut self,\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n-                   id_sp: Span) -> PResult<ModulePathSuccess> {\n+                   id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n         let mut prefix = PathBuf::from(&self.sess.codemap().span_to_filename(self.span));\n         prefix.pop();\n         let mut dir_path = prefix;\n@@ -5075,21 +5078,23 @@ impl<'a> Parser<'a> {\n         let paths = Parser::default_submod_path(id, &dir_path, self.sess.codemap());\n \n         if !self.owns_directory {\n-            self.span_err(id_sp, \"cannot declare a new module at this location\");\n+            let mut err = self.diagnostic().struct_span_err(id_sp,\n+                \"cannot declare a new module at this location\");\n             let this_module = match self.mod_path_stack.last() {\n                 Some(name) => name.to_string(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n-            self.span_note(id_sp,\n-                           &format!(\"maybe move this module `{0}` to its own directory \\\n+            err.span_note(id_sp,\n+                          &format!(\"maybe move this module `{0}` to its own directory \\\n                                      via `{0}/mod.rs`\",\n                                     this_module));\n             if paths.path_exists {\n-                self.span_note(id_sp,\n-                               &format!(\"... or maybe `use` the module `{}` instead \\\n-                                         of possibly redeclaring it\",\n-                                        paths.name));\n+                err.span_note(id_sp,\n+                              &format!(\"... or maybe `use` the module `{}` instead \\\n+                                        of possibly redeclaring it\",\n+                                       paths.name));\n             }\n+            err.emit();\n             self.abort_if_errors();\n         }\n \n@@ -5104,7 +5109,7 @@ impl<'a> Parser<'a> {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> PResult<(ast::Item_, Vec<ast::Attribute> )> {\n+                    -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n         let ModulePathSuccess { path, owns_directory } = try!(self.submod_path(id,\n                                                                                outer_attrs,\n                                                                                id_sp));\n@@ -5119,7 +5124,7 @@ impl<'a> Parser<'a> {\n                               path: PathBuf,\n                               owns_directory: bool,\n                               name: String,\n-                              id_sp: Span) -> PResult<(ast::Item_, Vec<ast::Attribute> )> {\n+                              id_sp: Span) -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n@@ -5152,7 +5157,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: BytePos,\n-                             attrs: Vec<Attribute>) -> PResult<P<ForeignItem>> {\n+                             attrs: Vec<Attribute>) -> PResult<'a, P<ForeignItem>> {\n         try!(self.expect_keyword(keywords::Fn));\n \n         let (ident, mut generics) = try!(self.parse_fn_header());\n@@ -5172,7 +5177,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: BytePos,\n-                                 attrs: Vec<Attribute>) -> PResult<P<ForeignItem>> {\n+                                 attrs: Vec<Attribute>) -> PResult<'a, P<ForeignItem>> {\n         try!(self.expect_keyword(keywords::Static));\n         let mutbl = try!(self.eat_keyword(keywords::Mut));\n \n@@ -5201,7 +5206,7 @@ impl<'a> Parser<'a> {\n                                lo: BytePos,\n                                visibility: Visibility,\n                                attrs: Vec<Attribute>)\n-                                -> PResult<P<Item>> {\n+                                -> PResult<'a, P<Item>> {\n \n         let crate_name = try!(self.parse_ident());\n         let (maybe_path, ident) = if let Some(ident) = try!(self.parse_rename()) {\n@@ -5242,7 +5247,7 @@ impl<'a> Parser<'a> {\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n                               mut attrs: Vec<Attribute>)\n-                              -> PResult<P<Item>> {\n+                              -> PResult<'a, P<Item>> {\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n \n         let abi = opt_abi.unwrap_or(abi::C);\n@@ -5269,7 +5274,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse type Foo = Bar;\n-    fn parse_item_type(&mut self) -> PResult<ItemInfo> {\n+    fn parse_item_type(&mut self) -> PResult<'a, ItemInfo> {\n         let ident = try!(self.parse_ident());\n         let mut tps = try!(self.parse_generics());\n         tps.where_clause = try!(self.parse_where_clause());\n@@ -5280,7 +5285,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the part of an \"enum\" decl following the '{'\n-    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<EnumDef> {\n+    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<'a, EnumDef> {\n         let mut variants = Vec::new();\n         let mut all_nullary = true;\n         let mut any_disr = None;\n@@ -5330,7 +5335,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an \"enum\" declaration\n-    fn parse_item_enum(&mut self) -> PResult<ItemInfo> {\n+    fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         let id = try!(self.parse_ident());\n         let mut generics = try!(self.parse_generics());\n         generics.where_clause = try!(self.parse_where_clause());\n@@ -5342,7 +5347,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n-    fn parse_opt_abi(&mut self) -> PResult<Option<abi::Abi>> {\n+    fn parse_opt_abi(&mut self) -> PResult<'a, Option<abi::Abi>> {\n         match self.token {\n             token::Literal(token::Str_(s), suf) | token::Literal(token::StrRaw(s, _), suf) => {\n                 let sp = self.span;\n@@ -5371,7 +5376,7 @@ impl<'a> Parser<'a> {\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n     fn parse_item_(&mut self, attrs: Vec<Attribute>,\n-                   macros_allowed: bool, attributes_allowed: bool) -> PResult<Option<P<Item>>> {\n+                   macros_allowed: bool, attributes_allowed: bool) -> PResult<'a, Option<P<Item>>> {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5474,8 +5479,9 @@ impl<'a> Parser<'a> {\n             // CONST ITEM\n             if try!(self.eat_keyword(keywords::Mut) ){\n                 let last_span = self.last_span;\n-                self.span_err(last_span, \"const globals cannot be mutable\");\n-                self.fileline_help(last_span, \"did you mean to declare a static?\");\n+                self.diagnostic().struct_span_err(last_span, \"const globals cannot be mutable\")\n+                                 .fileline_help(last_span, \"did you mean to declare a static?\")\n+                                 .emit();\n             }\n             let (ident, item_, extra_attrs) = try!(self.parse_item_const(None));\n             let last_span = self.last_span;\n@@ -5633,7 +5639,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a foreign item.\n-    fn parse_foreign_item(&mut self) -> PResult<Option<P<ForeignItem>>> {\n+    fn parse_foreign_item(&mut self) -> PResult<'a, Option<P<ForeignItem>>> {\n         let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let visibility = try!(self.parse_visibility());\n@@ -5664,7 +5670,7 @@ impl<'a> Parser<'a> {\n         attributes_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n-    ) -> PResult<Option<P<Item>>> {\n+    ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| t.is_plain_ident())\n@@ -5736,7 +5742,7 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n-    pub fn parse_item(&mut self) -> PResult<Option<P<Item>>> {\n+    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n         let attrs = try!(self.parse_outer_attributes());\n         self.parse_item_(attrs, true, false)\n     }\n@@ -5747,7 +5753,7 @@ impl<'a> Parser<'a> {\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     /// | MOD? non_global_path MOD_SEP STAR\n     /// | MOD? non_global_path\n-    fn parse_view_path(&mut self) -> PResult<P<ViewPath>> {\n+    fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n         let lo = self.span.lo;\n \n         // Allow a leading :: because the paths are absolute either way.\n@@ -5843,7 +5849,7 @@ impl<'a> Parser<'a> {\n         Ok(P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path))))\n     }\n \n-    fn parse_rename(&mut self) -> PResult<Option<Ident>> {\n+    fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n         if try!(self.eat_keyword(keywords::As)) {\n             self.parse_ident().map(Some)\n         } else {\n@@ -5853,7 +5859,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a source module as a crate. This is the main\n     /// entry point for the parser.\n-    pub fn parse_crate_mod(&mut self) -> PResult<Crate> {\n+    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n         let lo = self.span.lo;\n         Ok(ast::Crate {\n             attrs: try!(self.parse_inner_attributes()),\n@@ -5865,7 +5871,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_optional_str(&mut self)\n-                              -> PResult<Option<(InternedString,\n+                              -> PResult<'a, Option<(InternedString,\n                                                  ast::StrStyle,\n                                                  Option<ast::Name>)>> {\n         let ret = match self.token {\n@@ -5881,7 +5887,7 @@ impl<'a> Parser<'a> {\n         Ok(Some(ret))\n     }\n \n-    pub fn parse_str(&mut self) -> PResult<(InternedString, StrStyle)> {\n+    pub fn parse_str(&mut self) -> PResult<'a, (InternedString, StrStyle)> {\n         match try!(self.parse_optional_str()) {\n             Some((s, style, suf)) => {\n                 let sp = self.last_span;"}, {"sha": "5e3cd0773aa45df290384225020a9b4f9902f7f7", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -47,21 +47,21 @@ struct ShowSpanVisitor<'a> {\n impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         if let Mode::Expression = self.mode {\n-            self.span_diagnostic.span_note(e.span, \"expression\");\n+            self.span_diagnostic.span_warn(e.span, \"expression\");\n         }\n         visit::walk_expr(self, e);\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n         if let Mode::Pattern = self.mode {\n-            self.span_diagnostic.span_note(p.span, \"pattern\");\n+            self.span_diagnostic.span_warn(p.span, \"pattern\");\n         }\n         visit::walk_pat(self, p);\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         if let Mode::Type = self.mode {\n-            self.span_diagnostic.span_note(t.span, \"type\");\n+            self.span_diagnostic.span_warn(t.span, \"type\");\n         }\n         visit::walk_ty(self, t);\n     }"}, {"sha": "454b925a4945e7133930276e1fe53d6c27edd57e", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -30,10 +30,9 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a>\n                                source_str)\n }\n \n-fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n-    F: FnOnce(&mut Parser) -> PResult<T>,\n+fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where\n+    F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n {\n-    let ps = ParseSess::new();\n     let mut p = string_to_parser(&ps, s);\n     let x = panictry!(f(&mut p));\n     p.abort_if_errors();\n@@ -42,36 +41,41 @@ fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n \n /// Parse a string, return a crate.\n pub fn string_to_crate (source_str : String) -> ast::Crate {\n-    with_error_checking_parse(source_str, |p| {\n+    let ps = ParseSess::new();\n+    with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_crate_mod()\n     })\n }\n \n /// Parse a string, return an expr\n pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n-    with_error_checking_parse(source_str, |p| {\n+    let ps = ParseSess::new();\n+    with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_expr()\n     })\n }\n \n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n-    with_error_checking_parse(source_str, |p| {\n+    let ps = ParseSess::new();\n+    with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_item()\n     })\n }\n \n /// Parse a string, return a stmt\n pub fn string_to_stmt(source_str : String) -> Option<P<ast::Stmt>> {\n-    with_error_checking_parse(source_str, |p| {\n+    let ps = ParseSess::new();\n+    with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_stmt()\n     })\n }\n \n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    with_error_checking_parse(source_str, |p| {\n+    let ps = ParseSess::new();\n+    with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_pat()\n     })\n }"}, {"sha": "78e7f7462f31742f9a90929291f2ad84e90a54bb", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -130,10 +130,11 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             match names.get(name) {\n                 None => {}\n                 Some(prev) => {\n-                    ecx.span_err(e.span,\n-                                 &format!(\"duplicate argument named `{}`\",\n-                                         name));\n-                    ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n+                    ecx.struct_span_err(e.span,\n+                                        &format!(\"duplicate argument named `{}`\",\n+                                                 name))\n+                       .span_note(prev.span, \"previously here\")\n+                       .emit();\n                     continue\n                 }\n             }"}, {"sha": "0f049fa9792553a8992a0e05d2b42f2b5a909f97", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -24,26 +24,13 @@\n #![feature(str_char)]\n \n extern crate fmt_macros;\n+#[macro_use]\n extern crate syntax;\n \n use syntax::ext::base::{MacroExpanderFn, NormalTT};\n use syntax::ext::base::{SyntaxEnv, SyntaxExtension};\n use syntax::parse::token::intern;\n \n-// A variant of 'try!' that panics on Err(FatalError). This is used as a\n-// crutch on the way towards a non-panic!-prone parser. It should be used\n-// for fatal parsing errors; eventually we plan to convert all code using\n-// panictry to just use normal try\n-macro_rules! panictry {\n-    ($e:expr) => ({\n-        use std::result::Result::{Ok, Err};\n-        use syntax::errors::FatalError;\n-        match $e {\n-            Ok(e) => e,\n-            Err(FatalError) => panic!(FatalError)\n-        }\n-    })\n-}\n \n mod asm;\n mod cfg;"}, {"sha": "b64e5778d90336ec989304a8e72110010deca8a7", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/176ee349a704a1aee9dfb79c27c5da20db7942a5/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=176ee349a704a1aee9dfb79c27c5da20db7942a5", "patch": "@@ -37,34 +37,36 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a>\n                                source_str)\n }\n \n-fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n-    F: FnOnce(&mut Parser) -> PResult<T>,\n+fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> PResult<'a, T> where\n+    F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n {\n-    let ps = ParseSess::new();\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n \n     if ps.span_diagnostic.has_errors() || p.token != token::Eof {\n+        if let Err(mut e) = x {\n+            e.cancel();\n+        }\n         return Err(p.fatal(\"parse error\"));\n     }\n \n     x\n }\n \n-fn expr(s: &str) -> PResult<P<ast::Expr>> {\n-    with_error_checking_parse(s.to_string(), |p| {\n+fn expr<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, P<ast::Expr>> {\n+    with_error_checking_parse(s.to_string(), ps, |p| {\n         p.parse_expr()\n     })\n }\n \n-fn stmt(s: &str) -> PResult<P<ast::Stmt>> {\n-    with_error_checking_parse(s.to_string(), |p| {\n+fn stmt<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, P<ast::Stmt>> {\n+    with_error_checking_parse(s.to_string(), ps, |p| {\n         p.parse_stmt().map(|s| s.unwrap())\n     })\n }\n \n-fn attr(s: &str) -> PResult<ast::Attribute> {\n-    with_error_checking_parse(s.to_string(), |p| {\n+fn attr<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, ast::Attribute> {\n+    with_error_checking_parse(s.to_string(), ps, |p| {\n         p.parse_attribute(true)\n     })\n }\n@@ -79,29 +81,39 @@ fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f:\n }\n \n fn check_expr_attrs(es: &str, expected: &[&str]) {\n-    let e = expr(es).expect(\"parse error\");\n+    let ps = ParseSess::new();\n+    let e = expr(es, &ps).expect(\"parse error\");\n     let actual = &e.attrs;\n     str_compare(es,\n-                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n                 actual.as_attr_slice(),\n                 pprust::attribute_to_string);\n }\n \n fn check_stmt_attrs(es: &str, expected: &[&str]) {\n-    let e = stmt(es).expect(\"parse error\");\n+    let ps = ParseSess::new();\n+    let e = stmt(es, &ps).expect(\"parse error\");\n     let actual = e.node.attrs();\n     str_compare(es,\n-                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n                 actual,\n                 pprust::attribute_to_string);\n }\n \n fn reject_expr_parse(es: &str) {\n-    assert!(expr(es).is_err(), \"parser did not reject `{}`\", es);\n+    let ps = ParseSess::new();\n+    match expr(es, &ps) {\n+        Ok(_) => panic!(\"parser did not reject `{}`\", es),\n+        Err(mut e) => e.cancel(),\n+    };\n }\n \n fn reject_stmt_parse(es: &str) {\n-    assert!(stmt(es).is_err(), \"parser did not reject `{}`\", es);\n+    let ps = ParseSess::new();\n+    match stmt(es, &ps) {\n+        Ok(_) => panic!(\"parser did not reject `{}`\", es),\n+        Err(mut e) => e.cancel(),\n+    };\n }\n \n fn main() {"}]}