{"sha": "790788d5f4013d8d92f110bc12a581d18cf4b6ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDc4OGQ1ZjQwMTNkOGQ5MmYxMTBiYzEyYTU4MWQxOGNmNGI2YWU=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-01-31T18:23:25Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-02-03T10:34:24Z"}, "message": "Rework how we send diagnostics to client.\n\nThe previous way of sending from the thread pool suffered from stale\ndiagnostics due to being canceled before we could clear the old ones.\n\nThe key change is moving to sending diagnostics from the main loop\nthread, but doing all the hard work in the thread pool. This should\nprovide the best of both worlds, with little to no of the downsides.\n\nThis should hopefully fix a lot of issues, but we'll need testing in\neach individual issue to be sure.", "tree": {"sha": "311e11529c7546b7a09486d5c161039d8bd8f975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311e11529c7546b7a09486d5c161039d8bd8f975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790788d5f4013d8d92f110bc12a581d18cf4b6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790788d5f4013d8d92f110bc12a581d18cf4b6ae", "html_url": "https://github.com/rust-lang/rust/commit/790788d5f4013d8d92f110bc12a581d18cf4b6ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790788d5f4013d8d92f110bc12a581d18cf4b6ae/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52456c44901c8c38c8bcb742ebe305484af8f36f", "url": "https://api.github.com/repos/rust-lang/rust/commits/52456c44901c8c38c8bcb742ebe305484af8f36f", "html_url": "https://github.com/rust-lang/rust/commit/52456c44901c8c38c8bcb742ebe305484af8f36f"}], "stats": {"total": 386, "additions": 178, "deletions": 208}, "files": [{"sha": "506370535f72a3b339dd2da44f28d4ca1da786b4", "filename": "crates/ra_cargo_watch/src/conv.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -1,12 +1,11 @@\n //! This module provides the functionality needed to convert diagnostics from\n //! `cargo check` json format to the LSP diagnostic format.\n use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n-    DiagnosticSpanMacroExpansion,\n+    Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n };\n use lsp_types::{\n-    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n-    NumberOrString, Position, Range, Url,\n+    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n+    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n };\n use std::{\n     fmt::Write,\n@@ -117,38 +116,9 @@ fn is_deprecated(rd: &RustDiagnostic) -> bool {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct SuggestedFix {\n-    pub title: String,\n-    pub location: Location,\n-    pub replacement: String,\n-    pub applicability: Applicability,\n-    pub diagnostics: Vec<Diagnostic>,\n-}\n-\n-impl std::cmp::PartialEq<SuggestedFix> for SuggestedFix {\n-    fn eq(&self, other: &SuggestedFix) -> bool {\n-        if self.title == other.title\n-            && self.location == other.location\n-            && self.replacement == other.replacement\n-        {\n-            // Applicability doesn't impl PartialEq...\n-            match (&self.applicability, &other.applicability) {\n-                (Applicability::MachineApplicable, Applicability::MachineApplicable) => true,\n-                (Applicability::HasPlaceholders, Applicability::HasPlaceholders) => true,\n-                (Applicability::MaybeIncorrect, Applicability::MaybeIncorrect) => true,\n-                (Applicability::Unspecified, Applicability::Unspecified) => true,\n-                _ => false,\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n enum MappedRustChildDiagnostic {\n     Related(DiagnosticRelatedInformation),\n-    SuggestedFix(SuggestedFix),\n+    SuggestedFix(CodeAction),\n     MessageLine(String),\n }\n \n@@ -176,12 +146,20 @@ fn map_rust_child_diagnostic(\n             rd.message.clone()\n         };\n \n-        MappedRustChildDiagnostic::SuggestedFix(SuggestedFix {\n+        let edit = {\n+            let edits = vec![TextEdit::new(location.range, suggested_replacement.clone())];\n+            let mut edit_map = std::collections::HashMap::new();\n+            edit_map.insert(location.uri, edits);\n+            WorkspaceEdit::new(edit_map)\n+        };\n+\n+        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n             title,\n-            location,\n-            replacement: suggested_replacement.clone(),\n-            applicability: span.suggestion_applicability.clone().unwrap_or(Applicability::Unknown),\n-            diagnostics: vec![],\n+            kind: Some(\"quickfix\".to_string()),\n+            diagnostics: None,\n+            edit: Some(edit),\n+            command: None,\n+            is_preferred: None,\n         })\n     } else {\n         MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n@@ -195,7 +173,7 @@ fn map_rust_child_diagnostic(\n pub(crate) struct MappedRustDiagnostic {\n     pub location: Location,\n     pub diagnostic: Diagnostic,\n-    pub suggested_fixes: Vec<SuggestedFix>,\n+    pub fixes: Vec<CodeAction>,\n }\n \n /// Converts a Rust root diagnostic to LSP form\n@@ -250,15 +228,13 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         }\n     }\n \n-    let mut suggested_fixes = vec![];\n+    let mut fixes = vec![];\n     let mut message = rd.message.clone();\n     for child in &rd.children {\n         let child = map_rust_child_diagnostic(&child, workspace_root);\n         match child {\n             MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n-            MappedRustChildDiagnostic::SuggestedFix(suggested_fix) => {\n-                suggested_fixes.push(suggested_fix)\n-            }\n+            MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action.into()),\n             MappedRustChildDiagnostic::MessageLine(message_line) => {\n                 write!(&mut message, \"\\n{}\", message_line).unwrap();\n \n@@ -295,7 +271,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         tags: if !tags.is_empty() { Some(tags) } else { None },\n     };\n \n-    Some(MappedRustDiagnostic { location, diagnostic, suggested_fixes })\n+    Some(MappedRustDiagnostic { location, diagnostic, fixes })\n }\n \n /// Returns a `Url` object from a given path, will lowercase drive letters if present."}, {"sha": "f07c3454996dd764823893b3fa1ae375d921e2d5", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 17, "deletions": 93, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -4,22 +4,20 @@\n use cargo_metadata::Message;\n use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n use lsp_types::{\n-    Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n+    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n+    WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n use std::{\n-    collections::HashMap,\n     io::{BufRead, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n-    sync::Arc,\n     thread::JoinHandle,\n     time::Instant,\n };\n \n mod conv;\n \n-use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic, SuggestedFix};\n+use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n pub use crate::conv::url_from_path_with_drive_lowercasing;\n \n@@ -38,29 +36,26 @@ pub struct CheckOptions {\n #[derive(Debug)]\n pub struct CheckWatcher {\n     pub task_recv: Receiver<CheckTask>,\n-    pub state: Arc<CheckState>,\n     cmd_send: Option<Sender<CheckCommand>>,\n     handle: Option<JoinHandle<()>>,\n }\n \n impl CheckWatcher {\n     pub fn new(options: &CheckOptions, workspace_root: PathBuf) -> CheckWatcher {\n         let options = options.clone();\n-        let state = Arc::new(CheckState::new());\n \n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n         let handle = std::thread::spawn(move || {\n             let mut check = CheckWatcherThread::new(options, workspace_root);\n             check.run(&task_send, &cmd_recv);\n         });\n-        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), state }\n+        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle) }\n     }\n \n     /// Returns a CheckWatcher that doesn't actually do anything\n     pub fn dummy() -> CheckWatcher {\n-        let state = Arc::new(CheckState::new());\n-        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, state }\n+        CheckWatcher { task_recv: never(), cmd_send: None, handle: None }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n@@ -87,84 +82,13 @@ impl std::ops::Drop for CheckWatcher {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct CheckState {\n-    diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n-    suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n-}\n-\n-impl CheckState {\n-    fn new() -> CheckState {\n-        CheckState {\n-            diagnostic_collection: HashMap::new(),\n-            suggested_fix_collection: HashMap::new(),\n-        }\n-    }\n-\n-    /// Clear the cached diagnostics, and schedule updating diagnostics by the\n-    /// server, to clear stale results.\n-    pub fn clear(&mut self) -> Vec<Url> {\n-        let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n-        self.diagnostic_collection.clear();\n-        self.suggested_fix_collection.clear();\n-        cleared_files\n-    }\n-\n-    pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n-        self.diagnostic_collection.get(uri).map(|d| d.as_slice())\n-    }\n-\n-    pub fn fixes_for(&self, uri: &Url) -> Option<&[SuggestedFix]> {\n-        self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n-    }\n-\n-    pub fn add_diagnostic_with_fixes(&mut self, file_uri: Url, diagnostic: DiagnosticWithFixes) {\n-        for fix in diagnostic.suggested_fixes {\n-            self.add_suggested_fix_for_diagnostic(fix, &diagnostic.diagnostic);\n-        }\n-        self.add_diagnostic(file_uri, diagnostic.diagnostic);\n-    }\n-\n-    fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n-        let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n-\n-        // If we're building multiple targets it's possible we've already seen this diagnostic\n-        let is_duplicate = diagnostics.iter().any(|d| are_diagnostics_equal(d, &diagnostic));\n-        if is_duplicate {\n-            return;\n-        }\n-\n-        diagnostics.push(diagnostic);\n-    }\n-\n-    fn add_suggested_fix_for_diagnostic(\n-        &mut self,\n-        mut suggested_fix: SuggestedFix,\n-        diagnostic: &Diagnostic,\n-    ) {\n-        let file_uri = suggested_fix.location.uri.clone();\n-        let file_suggestions = self.suggested_fix_collection.entry(file_uri).or_default();\n-\n-        let existing_suggestion: Option<&mut SuggestedFix> =\n-            file_suggestions.iter_mut().find(|s| s == &&suggested_fix);\n-        if let Some(existing_suggestion) = existing_suggestion {\n-            // The existing suggestion also applies to this new diagnostic\n-            existing_suggestion.diagnostics.push(diagnostic.clone());\n-        } else {\n-            // We haven't seen this suggestion before\n-            suggested_fix.diagnostics.push(diagnostic.clone());\n-            file_suggestions.push(suggested_fix);\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub enum CheckTask {\n     /// Request a clearing of all cached diagnostics from the check watcher\n     ClearDiagnostics,\n \n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic(Url, DiagnosticWithFixes),\n+    AddDiagnostic { url: Url, diagnostic: Diagnostic, fixes: Vec<CodeActionOrCommand> },\n \n     /// Request check progress notification to client\n     Status(WorkDoneProgress),\n@@ -279,10 +203,17 @@ impl CheckWatcherThread {\n                         None => return,\n                     };\n \n-                let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n+                let MappedRustDiagnostic { location, diagnostic, fixes } = map_result;\n+                let fixes = fixes\n+                    .into_iter()\n+                    .map(|fix| {\n+                        CodeAction { diagnostics: Some(vec![diagnostic.clone()]), ..fix }.into()\n+                    })\n+                    .collect();\n \n-                let diagnostic = DiagnosticWithFixes { diagnostic, suggested_fixes };\n-                task_send.send(CheckTask::AddDiagnostic(location.uri, diagnostic)).unwrap();\n+                task_send\n+                    .send(CheckTask::AddDiagnostic { url: location.uri, diagnostic, fixes })\n+                    .unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n@@ -294,7 +225,7 @@ impl CheckWatcherThread {\n #[derive(Debug)]\n pub struct DiagnosticWithFixes {\n     diagnostic: Diagnostic,\n-    suggested_fixes: Vec<SuggestedFix>,\n+    fixes: Vec<CodeAction>,\n }\n \n /// WatchThread exists to wrap around the communication needed to be able to\n@@ -429,10 +360,3 @@ impl std::ops::Drop for WatchThread {\n         }\n     }\n }\n-\n-fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n-    left.source == right.source\n-        && left.severity == right.severity\n-        && left.range == right.range\n-        && left.message == right.message\n-}"}, {"sha": "ea08bce24bc387057e177323c9a0f619bce83b29", "filename": "crates/ra_lsp_server/src/diagnostics.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -0,0 +1,85 @@\n+//! Book keeping for keeping diagnostics easily in sync with the client.\n+use lsp_types::{CodeActionOrCommand, Diagnostic, Range};\n+use ra_ide::FileId;\n+use std::{collections::HashMap, sync::Arc};\n+\n+pub type CheckFixes = Arc<HashMap<FileId, Vec<Fix>>>;\n+\n+#[derive(Debug, Default, Clone)]\n+pub struct DiagnosticCollection {\n+    pub native: HashMap<FileId, Vec<Diagnostic>>,\n+    pub check: HashMap<FileId, Vec<Diagnostic>>,\n+    pub check_fixes: CheckFixes,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Fix {\n+    pub range: Range,\n+    pub action: CodeActionOrCommand,\n+}\n+\n+#[derive(Debug)]\n+pub enum DiagnosticTask {\n+    ClearCheck,\n+    AddCheck(FileId, Diagnostic, Vec<CodeActionOrCommand>),\n+    SetNative(FileId, Vec<Diagnostic>),\n+}\n+\n+impl DiagnosticCollection {\n+    pub fn clear_check(&mut self) -> Vec<FileId> {\n+        Arc::make_mut(&mut self.check_fixes).clear();\n+        self.check.drain().map(|(key, _value)| key).collect()\n+    }\n+\n+    pub fn add_check_diagnostic(\n+        &mut self,\n+        file_id: FileId,\n+        diagnostic: Diagnostic,\n+        fixes: Vec<CodeActionOrCommand>,\n+    ) {\n+        let diagnostics = self.check.entry(file_id).or_default();\n+        for existing_diagnostic in diagnostics.iter() {\n+            if are_diagnostics_equal(&existing_diagnostic, &diagnostic) {\n+                return;\n+            }\n+        }\n+\n+        let check_fixes = Arc::make_mut(&mut self.check_fixes);\n+        check_fixes\n+            .entry(file_id)\n+            .or_default()\n+            .extend(fixes.into_iter().map(|action| Fix { range: diagnostic.range, action }));\n+        diagnostics.push(diagnostic);\n+    }\n+\n+    pub fn set_native_diagnostics(&mut self, file_id: FileId, diagnostics: Vec<Diagnostic>) {\n+        self.native.insert(file_id, diagnostics);\n+    }\n+\n+    pub fn diagnostics_for(&self, file_id: FileId) -> impl Iterator<Item = &Diagnostic> {\n+        let native = self.native.get(&file_id).into_iter().flatten();\n+        let check = self.check.get(&file_id).into_iter().flatten();\n+        native.chain(check)\n+    }\n+\n+    pub fn handle_task(&mut self, task: DiagnosticTask) -> Vec<FileId> {\n+        match task {\n+            DiagnosticTask::ClearCheck => self.clear_check(),\n+            DiagnosticTask::AddCheck(file_id, diagnostic, fixes) => {\n+                self.add_check_diagnostic(file_id, diagnostic, fixes);\n+                vec![file_id]\n+            }\n+            DiagnosticTask::SetNative(file_id, diagnostics) => {\n+                self.set_native_diagnostics(file_id, diagnostics);\n+                vec![file_id]\n+            }\n+        }\n+    }\n+}\n+\n+fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n+    left.source == right.source\n+        && left.severity == right.severity\n+        && left.range == right.range\n+        && left.message == right.message\n+}"}, {"sha": "1208c13435bae253fb8ebd2d943827a93129c5dd", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -29,6 +29,7 @@ mod markdown;\n pub mod req;\n mod config;\n mod world;\n+mod diagnostics;\n \n pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;\n pub use crate::{"}, {"sha": "12961ba377f0af9c9ff8149d18ab5e0acadc1708", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -17,16 +17,17 @@ use std::{\n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{ClientCapabilities, NumberOrString};\n-use ra_cargo_watch::{CheckOptions, CheckTask};\n+use ra_cargo_watch::{url_from_path_with_drive_lowercasing, CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n-use ra_vfs::{VfsTask, Watch};\n+use ra_vfs::{VfsFile, VfsTask, Watch};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n+    diagnostics::DiagnosticTask,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n@@ -254,6 +255,7 @@ pub fn main_loop(\n enum Task {\n     Respond(Response),\n     Notify(Notification),\n+    Diagnostic(DiagnosticTask),\n }\n \n enum Event {\n@@ -359,7 +361,7 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(pool, task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -464,6 +466,7 @@ fn on_task(\n         Task::Notify(n) => {\n             msg_sender.send(n.into()).unwrap();\n         }\n+        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, state),\n     }\n }\n \n@@ -621,23 +624,26 @@ fn on_notification(\n }\n \n fn on_check_task(\n-    pool: &ThreadPool,\n     task: CheckTask,\n     world_state: &mut WorldState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n-    let urls = match task {\n+    match task {\n         CheckTask::ClearDiagnostics => {\n-            let state = Arc::get_mut(&mut world_state.check_watcher.state)\n-                .expect(\"couldn't get check watcher state as mutable\");\n-            state.clear()\n+            task_sender.send(Task::Diagnostic(DiagnosticTask::ClearCheck))?;\n         }\n \n-        CheckTask::AddDiagnostic(url, diagnostic) => {\n-            let state = Arc::get_mut(&mut world_state.check_watcher.state)\n-                .expect(\"couldn't get check watcher state as mutable\");\n-            state.add_diagnostic_with_fixes(url.clone(), diagnostic);\n-            vec![url]\n+        CheckTask::AddDiagnostic { url, diagnostic, fixes } => {\n+            let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+            let file_id = world_state\n+                .vfs\n+                .read()\n+                .path2file(&path)\n+                .map(|it| FileId(it.0))\n+                .ok_or_else(|| format!(\"unknown file: {}\", path.to_string_lossy()))?;\n+\n+            task_sender\n+                .send(Task::Diagnostic(DiagnosticTask::AddCheck(file_id, diagnostic, fixes)))?;\n         }\n \n         CheckTask::Status(progress) => {\n@@ -647,31 +653,30 @@ fn on_check_task(\n             };\n             let not = notification_new::<req::Progress>(params);\n             task_sender.send(Task::Notify(not)).unwrap();\n-            Vec::new()\n         }\n     };\n \n-    let subscriptions = urls\n-        .into_iter()\n-        .map(|url| {\n-            let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-            Ok(world_state.vfs.read().path2file(&path).map(|it| FileId(it.0)))\n-        })\n-        .filter_map(|res| res.transpose())\n-        .collect::<Result<Vec<_>>>()?;\n+    Ok(())\n+}\n \n-    // We manually send a diagnostic update when the watcher asks\n-    // us to, to avoid the issue of having to change the file to\n-    // receive updated diagnostics.\n-    update_file_notifications_on_threadpool(\n-        pool,\n-        world_state.snapshot(),\n-        false,\n-        task_sender.clone(),\n-        subscriptions,\n-    );\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+    let subscriptions = state.diagnostics.handle_task(task);\n \n-    Ok(())\n+    for file_id in subscriptions {\n+        let path = state.vfs.read().file2path(VfsFile(file_id.0));\n+        let uri = match url_from_path_with_drive_lowercasing(&path) {\n+            Ok(uri) => uri,\n+            Err(err) => {\n+                log::error!(\"Couldn't convert path to url ({}): {:?}\", err, path.to_string_lossy());\n+                continue;\n+            }\n+        };\n+\n+        let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n+        let params = req::PublishDiagnosticsParams { uri, diagnostics, version: None };\n+        let not = notification_new::<req::PublishDiagnostics>(params);\n+        msg_sender.send(not.into()).unwrap();\n+    }\n }\n \n struct PoolDispatcher<'a> {\n@@ -819,9 +824,8 @@ fn update_file_notifications_on_threadpool(\n                             log::error!(\"failed to compute diagnostics: {:?}\", e);\n                         }\n                     }\n-                    Ok(params) => {\n-                        let not = notification_new::<req::PublishDiagnostics>(params);\n-                        task_sender.send(Task::Notify(not)).unwrap();\n+                    Ok(task) => {\n+                        task_sender.send(Task::Diagnostic(task)).unwrap();\n                     }\n                 }\n             }"}, {"sha": "839bca342de210e0561bd2338f15da2810454993", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -33,6 +33,7 @@ use crate::{\n         to_call_hierarchy_item, to_location, Conv, ConvWith, FoldConvCtx, MapConvWith, TryConvWith,\n         TryConvWithToVec,\n     },\n+    diagnostics::DiagnosticTask,\n     req::{self, Decoration, InlayHint, InlayHintsParams, InlayKind},\n     world::WorldSnapshot,\n     LspError, Result,\n@@ -656,6 +657,7 @@ pub fn handle_code_action(\n         .filter(|(diag_range, _fix)| diag_range.intersection(&range).is_some())\n         .map(|(_range, fix)| fix);\n \n+    // TODO: When done, we won't need this, only the one pulling from world.diagnostics\n     for source_edit in fixes_from_diagnostics {\n         let title = source_edit.label.clone();\n         let edit = source_edit.try_conv_with(&world)?;\n@@ -676,28 +678,12 @@ pub fn handle_code_action(\n         res.push(action.into());\n     }\n \n-    for fix in world.check_watcher.fixes_for(&params.text_document.uri).into_iter().flatten() {\n-        let fix_range = fix.location.range.conv_with(&line_index);\n+    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+        let fix_range = fix.range.conv_with(&line_index);\n         if fix_range.intersection(&range).is_none() {\n             continue;\n         }\n-\n-        let edit = {\n-            let edits = vec![TextEdit::new(fix.location.range, fix.replacement.clone())];\n-            let mut edit_map = std::collections::HashMap::new();\n-            edit_map.insert(fix.location.uri.clone(), edits);\n-            WorkspaceEdit::new(edit_map)\n-        };\n-\n-        let action = CodeAction {\n-            title: fix.title.clone(),\n-            kind: Some(\"quickfix\".to_string()),\n-            diagnostics: Some(fix.diagnostics.clone()),\n-            edit: Some(edit),\n-            command: None,\n-            is_preferred: None,\n-        };\n-        res.push(action.into());\n+        res.push(fix.action.clone());\n     }\n \n     for assist in world.analysis().assists(FileRange { file_id, range })?.into_iter() {\n@@ -875,14 +861,10 @@ pub fn handle_document_highlight(\n     ))\n }\n \n-pub fn publish_diagnostics(\n-    world: &WorldSnapshot,\n-    file_id: FileId,\n-) -> Result<req::PublishDiagnosticsParams> {\n+pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let mut diagnostics: Vec<Diagnostic> = world\n+    let diagnostics: Vec<Diagnostic> = world\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -896,10 +878,7 @@ pub fn publish_diagnostics(\n             tags: None,\n         })\n         .collect();\n-    if let Some(check_diags) = world.check_watcher.diagnostics_for(&uri) {\n-        diagnostics.extend(check_diags.iter().cloned());\n-    }\n-    Ok(req::PublishDiagnosticsParams { uri, diagnostics, version: None })\n+    Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n }\n \n pub fn publish_decorations("}, {"sha": "1ee02b47c93cabd337217a35d069b604a349ef2f", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790788d5f4013d8d92f110bc12a581d18cf4b6ae/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=790788d5f4013d8d92f110bc12a581d18cf4b6ae", "patch": "@@ -12,9 +12,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_cargo_watch::{\n-    url_from_path_with_drive_lowercasing, CheckOptions, CheckState, CheckWatcher,\n-};\n+use ra_cargo_watch::{url_from_path_with_drive_lowercasing, CheckOptions, CheckWatcher};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n@@ -25,6 +23,7 @@ use ra_vfs_glob::{Glob, RustPackageFilterBuilder};\n use relative_path::RelativePathBuf;\n \n use crate::{\n+    diagnostics::{CheckFixes, DiagnosticCollection},\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     LspError, Result,\n };\n@@ -55,6 +54,7 @@ pub struct WorldState {\n     pub task_receiver: Receiver<VfsTask>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n     pub check_watcher: CheckWatcher,\n+    pub diagnostics: DiagnosticCollection,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -63,7 +63,7 @@ pub struct WorldSnapshot {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n-    pub check_watcher: CheckState,\n+    pub check_fixes: CheckFixes,\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n@@ -159,6 +159,7 @@ impl WorldState {\n             task_receiver,\n             latest_requests: Default::default(),\n             check_watcher,\n+            diagnostics: Default::default(),\n         }\n     }\n \n@@ -220,7 +221,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n-            check_watcher: (*self.check_watcher.state).clone(),\n+            check_fixes: Arc::clone(&self.diagnostics.check_fixes),\n         }\n     }\n "}]}