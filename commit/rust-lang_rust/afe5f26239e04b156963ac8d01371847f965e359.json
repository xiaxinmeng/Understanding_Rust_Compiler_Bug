{"sha": "afe5f26239e04b156963ac8d01371847f965e359", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZTVmMjYyMzllMDRiMTU2OTYzYWM4ZDAxMzcxODQ3Zjk2NWUzNTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-13T10:51:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-13T10:51:26Z"}, "message": "tweak readme", "tree": {"sha": "dffa82790e5753493c1dbe817d224ecb316e585b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffa82790e5753493c1dbe817d224ecb316e585b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe5f26239e04b156963ac8d01371847f965e359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe5f26239e04b156963ac8d01371847f965e359", "html_url": "https://github.com/rust-lang/rust/commit/afe5f26239e04b156963ac8d01371847f965e359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe5f26239e04b156963ac8d01371847f965e359/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e554ea5faa1158e084462162d5e1932db5c81c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e554ea5faa1158e084462162d5e1932db5c81c2", "html_url": "https://github.com/rust-lang/rust/commit/8e554ea5faa1158e084462162d5e1932db5c81c2"}], "stats": {"total": 76, "additions": 33, "deletions": 43}, "files": [{"sha": "cbb72c8cfe6ce0b911ab36417300248620312c42", "filename": "README.md", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/afe5f26239e04b156963ac8d01371847f965e359/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/afe5f26239e04b156963ac8d01371847f965e359/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=afe5f26239e04b156963ac8d01371847f965e359", "patch": "@@ -2,15 +2,13 @@\n \n [![Build Status](https://travis-ci.org/rust-analyzer/rust-analyzer.svg?branch=master)](https://travis-ci.org/rust-analyzer/rust-analyzer)\n \n-Rust Analyzer is an **experimental** modular compiler frontend for the\n-Rust language, which aims to lay a foundation for excellent IDE\n-support.\n+Rust Analyzer is an **experimental** modular compiler frontend for the Rust\n+language, which aims to lay a foundation for excellent IDE support.\n \n-It doesn't implement much of compiler functionality yet, but the\n-white-space preserving Rust parser works, and there are significant\n-chunks of overall architecture (indexing, on-demand & lazy\n-computation, snapshotable world view) in place. Some basic IDE\n-functionality is provided via a language server.\n+It doesn't implement much of compiler functionality yet, but the white-space\n+preserving Rust parser works, and there are significant chunks of overall\n+architecture (indexing, on-demand & lazy computation, snapshotable world view)\n+in place. Some basic IDE functionality is provided via a language server.\n \n Work on the Rust Analyzer is sponsored by\n \n@@ -30,53 +28,45 @@ $ cargo run --package ra_cli parse < crates/ra_syntax/src/lib.rs\n \n # show symbols of a Rust file\n $ cargo run --package ra_cli symbols < crates/ra_syntax/src/lib.rs\n-```\n \n-To try out the language server, see [these\n-instructions](./editors/README.md). Please note that the server is not\n-ready for general use yet. If you are looking for a Rust IDE that\n-works, use [IntelliJ\n-Rust](https://github.com/intellij-rust/intellij-rust) or\n-[RLS](https://github.com/rust-lang-nursery/rls). That being said, the\n-basic stuff works, and rust analyzer is developed in the rust analyzer\n-powered editor.\n+# install the language server\n+$ cargo install --path crates/ra_lsp_server\n+```\n \n+See [these instructions](./editors/README.md) for VS Code setup and the list of\n+features (some of which are VS Code specific).\n \n ## Current Status and Plans\n \n-Rust analyzer aims to fill the same niche as the official [Rust\n-Language Server](https://github.com/rust-lang-nursery/rls), but uses a\n-significantly different architecture. More details can be found [in\n-this\n+Rust analyzer aims to fill the same niche as the official [Rust Language\n+Server](https://github.com/rust-lang-nursery/rls), but uses a significantly\n+different architecture. More details can be found [in this\n thread](https://internals.rust-lang.org/t/2019-strategy-for-rustc-and-the-rls/8361),\n-but the core issue is that RLS works in the \"wait until user stops\n-typing, run the build process, save the results of the analysis\" mode,\n-which arguably is the wrong foundation for IDE.\n+but the core issue is that RLS works in the \"wait until user stops typing, run\n+the build process, save the results of the analysis\" mode, which arguably is the\n+wrong foundation for IDE.\n \n-Rust Analyzer is a hobby project at the moment, there's exactly zero\n+Rust Analyzer is an experimental project at the moment, there's exactly zero\n guarantees that it becomes production-ready one day.\n \n-The near/mid term plan is to work independently of the main rustc\n-compiler and implement at least simplistic versions of name\n-resolution, macro expansion and type inference. The purpose is two\n-fold:\n+The near/mid term plan is to work independently of the main rustc compiler and\n+implement at least simplistic versions of name resolution, macro expansion and\n+type inference. The purpose is two fold:\n \n-* to quickly bootstrap usable and useful language server: solution\n-  that covers 80% of Rust code will be useful for IDEs, and will be\n-  vastly simpler than 100% solution.\n+* to quickly bootstrap usable and useful language server: solution that covers\n+  80% of Rust code will be useful for IDEs, and will be vastly simpler than 100%\n+  solution.\n \n * to understand how the consumer-side of compiler API should look like\n-  (especially it's on-demand aspects). If you have\n-  `get_expression_type` function, you can write a ton of purely-IDE\n-  features on top of it, even if the function is only partially\n-  correct. Plugin in the precise function afterwards should just make\n-  IDE features more reliable.\n-\n-The long term plan is to merge with the mainline rustc compiler,\n-probably around the HIR boundary? That is, use rust analyzer for\n-parsing, macro expansion and related bits of name resolution, but\n-leave the rest (including type inference and trait selection) to the\n-existing rustc.\n+  (especially it's on-demand aspects). If you have `get_expression_type`\n+  function, you can write a ton of purely-IDE features on top of it, even if the\n+  function is only partially correct. Pluging in the precise function afterwards\n+  should just make IDE features more reliable.\n+\n+The long term plan is to merge with the mainline rustc compiler, probably around\n+the HIR boundary? That is, use rust analyzer for parsing, macro expansion and\n+related bits of name resolution, but leave the rest (including type inference\n+and trait selection) to the existing rustc.\n \n ## Getting in touch\n "}]}