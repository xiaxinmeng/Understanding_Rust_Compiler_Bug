{"sha": "f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxM2FjYmRiZjE3ZDgwYmQ3NjM4ZDI4YThiNTRiODZhZmMyNzA0Yzc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T21:38:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T21:38:52Z"}, "message": "Remove talk of 'sharing boxes between tasks', old GC layer, etc. Add description of unique boxes.", "tree": {"sha": "1aa484513ef049ef32a9cc8d9bbed56c0fe02e07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aa484513ef049ef32a9cc8d9bbed56c0fe02e07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "html_url": "https://github.com/rust-lang/rust/commit/f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f13acbdbf17d80bd7638d28a8b54b86afc2704c7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e93ea8b1eee062ada604fb1ff4f3f1272a2edbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e93ea8b1eee062ada604fb1ff4f3f1272a2edbd", "html_url": "https://github.com/rust-lang/rust/commit/4e93ea8b1eee062ada604fb1ff4f3f1272a2edbd"}], "stats": {"total": 70, "additions": 41, "deletions": 29}, "files": [{"sha": "2dce38ecd31a87e4f118ba081ec5f240df9533ea", "filename": "doc/rust.texi", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f13acbdbf17d80bd7638d28a8b54b86afc2704c7/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/f13acbdbf17d80bd7638d28a8b54b86afc2704c7/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "patch": "@@ -1269,38 +1269,39 @@ entry to each function as the task executes. A stack allocation is reclaimed\n when control leaves the frame containing it.\n \n The @dfn{heap} is a general term that describes two separate sets of boxes:\n-@emph{task-local} state and GC boxes, and the @emph{shared} immutable boxes.\n-\n-State and GC boxes are @dfn{task-local}, owned by the task. Like any other\n-state or GC value, they cannot pass over channels. State and GC boxes do not\n-outlive the task that owns them. When unreferenced, they are either\n-immediately destructed (if acyclic) or else collected using a general\n-(cycle-aware) garbage-collector local to each task. Garbage collection within\n-a local heap does not interrupt execution of other tasks.\n+shared boxes -- which may be subject to garbage collection -- and unique\n+boxes.  The lifetime of an allocation in the heap depends on the lifetime of\n+the box values pointing to it. Since box values may themselves be passed in\n+and out of frames, or stored in the heap, heap allocations may outlive the\n+frame they are allocated within.\n \n \n @node       Ref.Mem.Own\n @subsection Ref.Mem.Own\n @c * Ref.Mem.Own::                 Memory ownership model.\n @cindex Ownership\n \n-A task @emph{owns} all the @emph{stack-local} slot allocations in its stack\n-and @emph{task-local} boxes accessible from its stack. A task @emph{shares}\n-ownership of @emph{shared} boxes accessible from its stack. A task does not\n-own any items.\n-\n-@dfn{Ownership} of an allocation means that the owning task is the only task\n-that can access the allocation.\n+A task owns all memory it can @emph{safely} reach through local variables,\n+shared or unique boxes, and/or references. Sharing memory between tasks can\n+only be accomplished using @emph{unsafe} constructs, such as raw pointer\n+operations or calling C code.\n \n-@dfn{Sharing} of an allocation means that the same allocation may be\n-concurrently read by multiple tasks. The only shared allocations are those\n-that are non-state.\n+When a task sends a value of @emph{unique} kind over a channel, it loses\n+ownership of the value sent and can no longer refer to it. This is statically\n+guaranteed by the combined use of ``move semantics'' and unique kinds, within\n+the communication system.\n \n When a stack frame is exited, its local allocations are all released, and its\n references to boxes (both shared and owned) are dropped.\n \n+A shared box may (in the case of a recursive, mutable shared type) be cyclic;\n+in this case the release of memory inside the shared structure may be deferred\n+until task-local garbage collection can reclaim it. Code can ensure no such\n+delayed deallocation occurs by restricting itself to unique boxes and similar\n+unshared kinds of data.\n+\n When a task finishes, its stack is necessarily empty and it therefore has no\n-references to any boxes.\n+references to any boxes; the remainder of its heap is immediately freed.\n \n @node       Ref.Mem.Slot\n @subsection Ref.Mem.Slot\n@@ -1352,14 +1353,26 @@ fn incr(&i: int) @{\n @cindex Box\n @cindex Dereference operator\n \n-A @dfn{box} is a reference to a reference-counted heap allocation holding\n-another value.\n+A @dfn{box} is a reference to a heap allocation holding another value. There\n+are two kinds of boxes: @emph{shared boxes} and @emph{unique boxes}.\n+\n+A @dfn{shared box} type or value is constructed by the prefix @emph{at} sigil @code{@@}.\n \n-Box types and values are constructed by the @emph{at} sigil @code{@@}.\n+A @dfn{unique box} type or value is constructed by the prefix @emph{tilde} sigil @code{~}.\n \n-An example of constructing a box type and value:\n+Multiple shared box values can point to the same heap allocation; copying a\n+shared box value makes a shallow copy of the pointer (optionally incrementing\n+a reference count, if the shared box is implemented through\n+reference-counting).\n+\n+Unique box values exist in 1:1 correspondence with their heap allocation;\n+copying a unique box value makes a deep copy of the heap allocation and\n+produces a pointer to the new allocation.\n+\n+An example of constructing one shared box type and value, and one unique box type and value:\n @example\n let x: @@int = @@10;\n+let x: ~int = ~10;\n @end example\n \n Some operations implicitly dereference boxes. Examples of such @dfn{implicit\n@@ -1376,12 +1389,11 @@ let y: @@int = @@12;\n assert (x + y == 22);\n @end example\n \n-Other operations act on box values as single-word-sized address values,\n-automatically adjusting reference counts on the associated heap\n-allocation. For these operations, to access the value held in the box requires\n-an explicit dereference of the box value. Explicitly dereferencing a box is\n-indicated with the unary @emph{star} operator @code{*}. Examples of such\n-@dfn{explicit dereference} operations are:\n+Other operations act on box values as single-word-sized address values. For\n+these operations, to access the value held in the box requires an explicit\n+dereference of the box value. Explicitly dereferencing a box is indicated with\n+the unary @emph{star} operator @code{*}. Examples of such @dfn{explicit\n+dereference} operations are:\n @itemize\n @item copying box values (@code{x = y})\n @item passing box values to functions (@code{f(x,y)})"}]}