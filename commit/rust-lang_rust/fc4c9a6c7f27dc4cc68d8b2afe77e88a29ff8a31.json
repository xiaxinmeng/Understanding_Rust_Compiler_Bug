{"sha": "fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNGM5YTZjN2YyN2RjNGNjNjhkOGIyYWZlNzdlODhhMjlmZjhhMzE=", "commit": {"author": {"name": "Tymoteusz Jankowski", "email": "tymoteusz.jankowski@gmail.com", "date": "2020-05-19T11:54:22Z"}, "committer": {"name": "Tymoteusz Jankowski", "email": "tymoteusz.jankowski@gmail.com", "date": "2020-05-19T12:32:17Z"}, "message": "Make intra-link resolve links for both trait and impl items", "tree": {"sha": "2081d32b4a5e8f514ba43aafef5e88436297df4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2081d32b4a5e8f514ba43aafef5e88436297df4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJSBAABCAA8FiEEz+VEfPVBkDAIKjASdufZPLFRDjEFAl7D0dMeHHR5bW90ZXVz\nei5qYW5rb3dza2lAZ21haWwuY29tAAoJEHbn2TyxUQ4xBHIP/RcQxDLbGCFJOjQo\n9alH5tOigjGpfIGU1culii4l/4RnCv80SQRFQ0RP5TkRYREfqPbn6krkiz7ECqga\nkDc0ger2XA/KFxagSbjIyU6WYGJ3y1zMihqDdCVGKXm1aABDfoEV++kQbBSDbrug\n3cjs0oZS6T+vEJ5f2Pm/Cdqg+DnU8Ig/zDLqpFmGHcHOrrsZIM5zV5fkq2IdSBF2\neJIEfAkATnIfF0tS/Eepwkr/mfT9ga+5FvkDYiWqAGASsGdXLbnMwAZMLXfO6RgQ\nbGFIuukU9/WdCfkSXw96k2OwAFsNL5+wsi9DeTQ5/jxXSiPWuP06WhYfis8ccxM8\n1O5vCNJU5O0N450JiGPGojAxPPwfRW5DFACmyMEHhfLsn80CS9U0Q+3KI62+i8j1\ngxs9ETJqXK4+Z57RcrC5xFxAfDd3/AbeYIi+kH3OTB0wg7ZuZQp5ndBeoCheenTE\n7FnDIjU+6oC93zIkwf9rjaEXWKfOvrmlatUUMzZZMVfXVIeYlEL1k7ncet3CzhH0\nmophVfeDWI45iMTjEjoHBGtBzkiYJUoubl8iv5eAMhQuTKEq28+tVppU9v2H2GGs\nfvyIOD9nL/6K3FArjIkoEQ60Y/pgGInfVK7LuyBX3CK452or6LNn3YOADx8+0MGx\nwUSu6OckPIjZe1W8p4z5I/ZpWYQR\n=O8xL\n-----END PGP SIGNATURE-----", "payload": "tree 2081d32b4a5e8f514ba43aafef5e88436297df4d\nparent 914adf04af1c1a984707f778da3d04590c03d144\nauthor Tymoteusz Jankowski <tymoteusz.jankowski@gmail.com> 1589889262 +0200\ncommitter Tymoteusz Jankowski <tymoteusz.jankowski@gmail.com> 1589891537 +0200\n\nMake intra-link resolve links for both trait and impl items\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "html_url": "https://github.com/rust-lang/rust/commit/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31/comments", "author": null, "committer": null, "parents": [{"sha": "914adf04af1c1a984707f778da3d04590c03d144", "url": "https://api.github.com/repos/rust-lang/rust/commits/914adf04af1c1a984707f778da3d04590c03d144", "html_url": "https://github.com/rust-lang/rust/commit/914adf04af1c1a984707f778da3d04590c03d144"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "05f3b598ecdf4d1d672b0f4bc3641c4f0024b839", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "patch": "@@ -232,37 +232,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n-                    // We need item's parent to know if it's\n-                    // trait impl or struct/enum/etc impl\n-                    let item_parent = item_opt\n+                    // Checks if item_name belongs to `impl SomeItem`\n+                    let impl_item = cx\n+                        .tcx\n+                        .inherent_impls(did)\n+                        .iter()\n+                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                        .find(|item| item.ident.name == item_name);\n+                    let trait_item = item_opt\n                         .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n                         .and_then(|item_hir| {\n+                            // Checks if item_name belongs to `impl SomeTrait for SomeItem`\n                             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-                            self.cx.tcx.hir().find(parent_hir)\n+                            let item_parent = self.cx.tcx.hir().find(parent_hir);\n+                            match item_parent {\n+                                Some(hir::Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n+                                    ..\n+                                })) => cx\n+                                    .tcx\n+                                    .associated_item_def_ids(self_ty.hir_id.owner)\n+                                    .iter()\n+                                    .map(|child| {\n+                                        let associated_item = cx.tcx.associated_item(*child);\n+                                        associated_item\n+                                    })\n+                                    .find(|child| child.ident.name == item_name),\n+                                _ => None,\n+                            }\n                         });\n-                    let item = match item_parent {\n-                        Some(hir::Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n-                            ..\n-                        })) => {\n-                            // trait impl\n-                            cx.tcx\n-                                .associated_item_def_ids(self_ty.hir_id.owner)\n-                                .iter()\n-                                .map(|child| {\n-                                    let associated_item = cx.tcx.associated_item(*child);\n-                                    associated_item\n-                                })\n-                                .find(|child| child.ident.name == item_name)\n-                        }\n-                        _ => {\n-                            // struct/enum/etc. impl\n-                            cx.tcx\n-                                .inherent_impls(did)\n-                                .iter()\n-                                .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                                .find(|item| item.ident.name == item_name)\n+                    let item = match (impl_item, trait_item) {\n+                        (Some(from_impl), Some(_)) => {\n+                            // Although it's ambiguous, return impl version for compat. sake.\n+                            // To handle that properly resolve() would have to support\n+                            // something like\n+                            // [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                            Some(from_impl)\n                         }\n+                        (None, Some(from_trait)) => Some(from_trait),\n+                        (Some(from_impl), None) => Some(from_impl),\n+                        _ => None,\n                     };\n \n                     if let Some(item) = item {"}, {"sha": "6ed3bfbe3e54bdcd64f54c9d89bdb4ebe39f43bc", "filename": "src/test/rustdoc/issue-72340.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-72340.rs?ref=fc4c9a6c7f27dc4cc68d8b2afe77e88a29ff8a31", "patch": "@@ -0,0 +1,19 @@\n+#![crate_name = \"foo\"]\n+\n+pub struct Body;\n+\n+impl Body {\n+    pub fn empty() -> Self {\n+        Body\n+    }\n+\n+}\n+\n+impl Default for Body {\n+    // @has foo/struct.Body.html '//a/@href' '../foo/struct.Body.html#method.empty'\n+\n+    /// Returns [`Body::empty()`](Body::empty).\n+    fn default() -> Body {\n+        Body::empty()\n+    }\n+}"}]}