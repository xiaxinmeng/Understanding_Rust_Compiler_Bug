{"sha": "e96f4be03d791715b20855f700862c3b532e713b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NmY0YmUwM2Q3OTE3MTViMjA4NTVmNzAwODYyYzNiNTMyZTcxM2I=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-09T10:49:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:51Z"}, "message": "extract `instantiate_anon_types` to the `InferCtxt`\n\nNo functional change.", "tree": {"sha": "46646b4fb2a9cdcfc53558f04b38c05eefa0b900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46646b4fb2a9cdcfc53558f04b38c05eefa0b900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e96f4be03d791715b20855f700862c3b532e713b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e96f4be03d791715b20855f700862c3b532e713b", "html_url": "https://github.com/rust-lang/rust/commit/e96f4be03d791715b20855f700862c3b532e713b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e96f4be03d791715b20855f700862c3b532e713b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a967c9df75dd0a86def21cce02d0b721f619007", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a967c9df75dd0a86def21cce02d0b721f619007", "html_url": "https://github.com/rust-lang/rust/commit/4a967c9df75dd0a86def21cce02d0b721f619007"}], "stats": {"total": 337, "additions": 225, "deletions": 112}, "files": [{"sha": "6af4f13db885f617749dd3e9c82dbed36615cdf5", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=e96f4be03d791715b20855f700862c3b532e713b", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use infer::{InferCtxt, InferOk, TypeVariableOrigin};\n+use syntax::ast;\n+use traits::{self, PredicateObligation};\n+use ty::{self, Ty};\n+use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::subst::Substs;\n+use util::nodemap::DefIdMap;\n+\n+pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n+\n+/// Information about the anonymous, abstract types whose values we\n+/// are inferring in this function (these are the `impl Trait` that\n+/// appear in the return type).\n+#[derive(Copy, Clone, Debug)]\n+pub struct AnonTypeDecl<'tcx> {\n+    /// The substitutions that we apply to the abstract that that this\n+    /// `impl Trait` desugars to. e.g., if:\n+    ///\n+    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n+    ///\n+    /// winds up desugared to:\n+    ///\n+    ///     abstract type Foo<'x, T>: Trait<'x>\n+    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n+    ///\n+    /// then `substs` would be `['a, T]`.\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// The type variable that represents the value of the abstract type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    pub concrete_ty: Ty<'tcx>,\n+\n+    /// True if the `impl Trait` bounds include region bounds.\n+    /// For example, this would be true for:\n+    ///\n+    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n+    ///\n+    /// but false for:\n+    ///\n+    ///     fn foo<'c>() -> impl Trait<'c>\n+    ///\n+    /// unless `Trait` was declared like:\n+    ///\n+    ///     trait Trait<'c>: 'c\n+    ///\n+    /// in which case it would be true.\n+    ///\n+    /// This is used during regionck to decide whether we need to\n+    /// impose any additional constraints to ensure that region\n+    /// variables in `concrete_ty` wind up being constrained to\n+    /// something from `substs` (or, at minimum, things that outlive\n+    /// the fn body). (Ultimately, writeback is responsible for this\n+    /// check.)\n+    pub has_required_region_bounds: bool,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// Replace all anonymized types in `value` with fresh inference variables\n+    /// and creates appropriate obligations. For example, given the input:\n+    ///\n+    ///     impl Iterator<Item = impl Debug>\n+    ///\n+    /// this method would create two type variables, `?0` and `?1`. It would\n+    /// return the type `?0` but also the obligations:\n+    ///\n+    ///     ?0: Iterator<Item = ?1>\n+    ///     ?1: Debug\n+    ///\n+    /// Moreover, it returns a `AnonTypeMap` that would map `?0` to\n+    /// info about the `impl Iterator<..>` type and `?1` to info about\n+    /// the `impl Debug` type.\n+    pub fn instantiate_anon_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n+        debug!(\n+            \"instantiate_anon_types(value={:?}, body_id={:?}, param_env={:?})\",\n+            value,\n+            body_id,\n+            param_env,\n+        );\n+        let mut instantiator = Instantiator {\n+            infcx: self,\n+            body_id,\n+            param_env,\n+            anon_types: DefIdMap(),\n+            obligations: vec![],\n+        };\n+        let value = instantiator.instantiate_anon_types_in_map(value);\n+        InferOk {\n+            value: (value, instantiator.anon_types),\n+            obligations: instantiator.obligations,\n+        }\n+    }\n+}\n+\n+struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    anon_types: AnonTypeMap<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n+    fn instantiate_anon_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        debug!(\"instantiate_anon_types_in_map(value={:?})\", value);\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx: self.infcx.tcx,\n+            fldop: |ty| if let ty::TyAnon(def_id, substs) = ty.sty {\n+                self.fold_anon_ty(ty, def_id, substs)\n+            } else {\n+                ty\n+            },\n+        })\n+    }\n+\n+    fn fold_anon_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+\n+        debug!(\n+            \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n+            def_id,\n+            substs\n+        );\n+\n+        // Use the same type variable if the exact same TyAnon appears more\n+        // than once in the return type (e.g. if it's passed to a type alias).\n+        if let Some(anon_defn) = self.anon_types.get(&def_id) {\n+            return anon_defn.concrete_ty;\n+        }\n+        let span = tcx.def_span(def_id);\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+\n+        let predicates_of = tcx.predicates_of(def_id);\n+        let bounds = predicates_of.instantiate(tcx, substs);\n+        debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n+\n+        let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n+        debug!(\n+            \"instantiate_anon_types: required_region_bounds={:?}\",\n+            required_region_bounds\n+        );\n+\n+        self.anon_types.insert(\n+            def_id,\n+            AnonTypeDecl {\n+                substs,\n+                concrete_ty: ty_var,\n+                has_required_region_bounds: !required_region_bounds.is_empty(),\n+            },\n+        );\n+        debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n+\n+        for predicate in bounds.predicates {\n+            // Change the predicate to refer to the type variable,\n+            // which will be the concrete type, instead of the TyAnon.\n+            // This also instantiates nested `impl Trait`.\n+            let predicate = self.instantiate_anon_types_in_map(&predicate);\n+\n+            let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);\n+\n+            // Require that the predicate holds for the concrete type.\n+            debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n+            self.obligations\n+                .push(traits::Obligation::new(cause, self.param_env, predicate));\n+        }\n+\n+        ty_var\n+    }\n+}"}, {"sha": "32da08bf476cf0ca7ed5c3eba7bce326e6d67d10", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e96f4be03d791715b20855f700862c3b532e713b", "patch": "@@ -48,6 +48,7 @@ use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n+pub mod anon_types;\n pub mod at;\n mod combine;\n mod equate;"}, {"sha": "ef66920604b11ecd4438eafecfc1b5d33e374515", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 112, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e96f4be03d791715b20855f700862c3b532e713b", "patch": "@@ -90,14 +90,15 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n+use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n-use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -225,62 +226,6 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: Option<hir::BodyId>,\n }\n \n-/// Information about the anonymous, abstract types whose values we\n-/// are inferring in this function (these are the `impl Trait` that\n-/// appear in the return type).\n-#[derive(Debug)]\n-struct AnonTypeDecl<'tcx> {\n-    /// The substitutions that we apply to the abstract that that this\n-    /// `impl Trait` desugars to. e.g., if:\n-    ///\n-    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n-    ///\n-    /// winds up desugared to:\n-    ///\n-    ///     abstract type Foo<'x, T>: Trait<'x>\n-    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n-    ///\n-    /// then `substs` would be `['a, T]`.\n-    substs: &'tcx Substs<'tcx>,\n-\n-    /// The type variable that represents the value of the abstract type\n-    /// that we require. In other words, after we compile this function,\n-    /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n-    /// where `?C` is the value of this type variable. =) It may\n-    /// naturally refer to the type and lifetime parameters in scope\n-    /// in this function, though ultimately it should only reference\n-    /// those that are arguments to `Foo` in the constraint above. (In\n-    /// other words, `?C` should not include `'b`, even though it's a\n-    /// lifetime parameter on `foo`.)\n-    concrete_ty: Ty<'tcx>,\n-\n-    /// True if the `impl Trait` bounds include region bounds.\n-    /// For example, this would be true for:\n-    ///\n-    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n-    ///\n-    /// but false for:\n-    ///\n-    ///     fn foo<'c>() -> impl Trait<'c>\n-    ///\n-    /// unless `Trait` was declared like:\n-    ///\n-    ///     trait Trait<'c>: 'c\n-    ///\n-    /// in which case it would be true.\n-    ///\n-    /// This is used during regionck to decide whether we need to\n-    /// impose any additional constraints to ensure that region\n-    /// variables in `concrete_ty` wind up being constrained to\n-    /// something from `substs` (or, at minimum, things that outlive\n-    /// the fn body). (Ultimately, writeback is responsible for this\n-    /// check.)\n-    has_required_region_bounds: bool,\n-}\n-\n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     type Target = InferCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -892,8 +837,6 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   &fn_sig);\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, false).0;\n-            // Ensure anon_types have been instantiated prior to entering regionck\n-            fcx.instantiate_anon_types(&fn_sig.output());\n             fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n@@ -1042,7 +985,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let ret_ty = fcx.instantiate_anon_types(&ret_ty);\n+    let ret_ty = fcx.instantiate_anon_types_from_return_value(&ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1933,60 +1876,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Replace all anonymized types with fresh inference variables\n-    /// and record them for writeback.\n-    fn instantiate_anon_types<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n-        debug!(\"instantiate_anon_types(value={:?})\", value);\n-        value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n-            if let ty::TyAnon(def_id, substs) = ty.sty {\n-                debug!(\"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\", def_id, substs);\n+    /// Replace the anonymized types from the return value of the\n+    /// function with type variables and records the `AnonTypeMap` for\n+    /// later use during writeback. See\n+    /// `InferCtxt::instantiate_anon_types` for more details.\n+    fn instantiate_anon_types_from_return_value<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        debug!(\"instantiate_anon_types_from_return_value(value={:?})\", value);\n \n-                // Use the same type variable if the exact same TyAnon appears more\n-                // than once in the return type (e.g. if it's passed to a type alias).\n-                if let Some(anon_defn) = self.anon_types.borrow().get(&def_id) {\n-                    return anon_defn.concrete_ty;\n-                }\n-                let span = self.tcx.def_span(def_id);\n-                let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-\n-                let predicates_of = self.tcx.predicates_of(def_id);\n-                let bounds = predicates_of.instantiate(self.tcx, substs);\n-                debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n-\n-                let required_region_bounds =\n-                    self.tcx.required_region_bounds(ty, bounds.predicates.clone());\n-                debug!(\"instantiate_anon_types: required_region_bounds={:?}\",\n-                       required_region_bounds);\n-\n-                self.anon_types.borrow_mut().insert(def_id, AnonTypeDecl {\n-                    substs,\n-                    concrete_ty: ty_var,\n-                    has_required_region_bounds: !required_region_bounds.is_empty(),\n-                });\n-                debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n-\n-                for predicate in bounds.predicates {\n-                    // Change the predicate to refer to the type variable,\n-                    // which will be the concrete type, instead of the TyAnon.\n-                    // This also instantiates nested `impl Trait`.\n-                    let predicate = self.instantiate_anon_types(&predicate);\n-\n-                    // Require that the predicate holds for the concrete type.\n-                    let cause = traits::ObligationCause::new(span,\n-                                                             self.body_id,\n-                                                             traits::SizedReturnType);\n-\n-                    debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n-                    self.register_predicate(traits::Obligation::new(cause,\n-                                                                    self.param_env,\n-                                                                    predicate));\n-                }\n+        let (value, anon_type_map) = self.register_infer_ok_obligations(\n+            self.instantiate_anon_types(\n+                self.body_id,\n+                self.param_env,\n+                value,\n+            )\n+        );\n \n-                ty_var\n-            } else {\n-                ty\n-            }\n-        }})\n+        let mut anon_types = self.anon_types.borrow_mut();\n+        for (ty, decl) in anon_type_map {\n+            let old_value = anon_types.insert(ty, decl);\n+            assert!(old_value.is_none(), \"instantiated twice: {:?}/{:?}\", ty, decl);\n+        }\n+\n+        value\n     }\n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T"}, {"sha": "e8d669838d3fbcbd95c343969bea35c131d6ffab", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96f4be03d791715b20855f700862c3b532e713b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e96f4be03d791715b20855f700862c3b532e713b", "patch": "@@ -81,6 +81,7 @@ This API is completely unstable and subject to change.\n #![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(quote)]\n+#![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n "}]}