{"sha": "dde2e0b3865ba040261d2078db371adbefb32506", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZTJlMGIzODY1YmEwNDAyNjFkMjA3OGRiMzcxYWRiZWZiMzI1MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T04:46:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T04:46:30Z"}, "message": "auto merge of #12066 : huonw/rust/show2, r=alexcrichton\n\n- Convert the formatting traits to `&self` rather than `_: &Self`\r\n- Rejig `syntax::ext::{format,deriving}` a little in preparation\r\n- Implement `#[deriving(Show)]`", "tree": {"sha": "f7e98095e05ec7f5be10dd73f7e307f3e0921c5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7e98095e05ec7f5be10dd73f7e307f3e0921c5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde2e0b3865ba040261d2078db371adbefb32506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde2e0b3865ba040261d2078db371adbefb32506", "html_url": "https://github.com/rust-lang/rust/commit/dde2e0b3865ba040261d2078db371adbefb32506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde2e0b3865ba040261d2078db371adbefb32506/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c6c73647cc3294c587d8089d6628d8969f0b71", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c6c73647cc3294c587d8089d6628d8969f0b71", "html_url": "https://github.com/rust-lang/rust/commit/80c6c73647cc3294c587d8089d6628d8969f0b71"}, {"sha": "b89afe2af7bdd9b65836b278c6e0322a8f91fb07", "url": "https://api.github.com/repos/rust-lang/rust/commits/b89afe2af7bdd9b65836b278c6e0322a8f91fb07", "html_url": "https://github.com/rust-lang/rust/commit/b89afe2af7bdd9b65836b278c6e0322a8f91fb07"}], "stats": {"total": 956, "additions": 622, "deletions": 334}, "files": [{"sha": "bae8f562af526f7ea947ac949bfe090702f22894", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -1969,13 +1969,14 @@ impl<T: Eq> Eq for Foo<T> {\n Supported traits for `deriving` are:\n \n * Comparison traits: `Eq`, `TotalEq`, `Ord`, `TotalOrd`.\n-* Serialization: `Encodable`, `Decodable`. These require `extra`.\n+* Serialization: `Encodable`, `Decodable`. These require `serialize`.\n * `Clone` and `DeepClone`, to perform (deep) copies.\n * `IterBytes`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n * `Default`, to create an empty instance of a data type.\n * `Zero`, to create an zero instance of a numeric data type.\n-* `FromPrimitive`, to create an instance from a numeric primitve.\n+* `FromPrimitive`, to create an instance from a numeric primitive.\n+* `Show`, to format a value using the `{}` formatter.\n \n ### Stability\n One can indicate the stability of an API using the following attributes:"}, {"sha": "a5426c20619e044c19b6516407e38d5b6d3a5e26", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -2523,7 +2523,7 @@ enum ABC { A, B, C }\n \n The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable` `Decodable`, `Clone`, `DeepClone`,\n-`IterBytes`, `Rand`, `Default`, `Zero`, and `ToStr`.\n+`IterBytes`, `Rand`, `Default`, `Zero`, `FromPrimitive` and `Show`.\n \n # Crates and the module system\n "}, {"sha": "7acaa761bb21531a4a49ed22209257a49f7aa20b", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -118,7 +118,8 @@ def write_file(name, string):\n for (trait, supers, errs) in [('Rand', [], 1),\n                               ('Clone', [], 1), ('DeepClone', ['Clone'], 1),\n                               ('Eq', [], 2), ('Ord', [], 8),\n-                              ('TotalEq', [], 1), ('TotalOrd', ['TotalEq'], 1)]:\n+                              ('TotalEq', [], 1), ('TotalOrd', ['TotalEq'], 1),\n+                              ('Show', [], 1)]:\n     traits[trait] = (ALL, supers, errs)\n \n for (trait, (types, super_traits, error_count)) in traits.items():"}, {"sha": "153de66363bdb8fba32be01f47c76ce097faf846", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -20,10 +20,10 @@ use std::fmt;\n pub struct Escape<'a>(&'a str);\n \n impl<'a> fmt::Show for Escape<'a> {\n-    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n-        let Escape(s) = *s;\n+        let Escape(s) = *self;\n         let pile_o_bits = s.as_slice();\n         let mut last = 0;\n         for (i, ch) in s.bytes().enumerate() {"}, {"sha": "024d010f0b927c9195f1c172e64087be9a7d3b9b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -48,23 +48,23 @@ impl PuritySpace {\n }\n \n impl fmt::Show for clean::Generics {\n-    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) -> fmt::Result {\n-        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return Ok(()) }\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n         if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n \n-        for (i, life) in g.lifetimes.iter().enumerate() {\n+        for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n                 if_ok!(f.buf.write(\", \".as_bytes()));\n             }\n             if_ok!(write!(f.buf, \"{}\", *life));\n         }\n \n-        if g.type_params.len() > 0 {\n-            if g.lifetimes.len() > 0 {\n+        if self.type_params.len() > 0 {\n+            if self.lifetimes.len() > 0 {\n                 if_ok!(f.buf.write(\", \".as_bytes()));\n             }\n \n-            for (i, tp) in g.type_params.iter().enumerate() {\n+            for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n                     if_ok!(f.buf.write(\", \".as_bytes()))\n                 }\n@@ -87,16 +87,16 @@ impl fmt::Show for clean::Generics {\n }\n \n impl fmt::Show for clean::Lifetime {\n-    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if_ok!(f.buf.write(\"'\".as_bytes()));\n-        if_ok!(f.buf.write(l.get_ref().as_bytes()));\n+        if_ok!(f.buf.write(self.get_ref().as_bytes()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::TyParamBound {\n-    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *bound {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::RegionBound => {\n                 f.buf.write(\"'static\".as_bytes())\n             }\n@@ -108,11 +108,11 @@ impl fmt::Show for clean::TyParamBound {\n }\n \n impl fmt::Show for clean::Path {\n-    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) -> fmt::Result {\n-        if path.global {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.global {\n             if_ok!(f.buf.write(\"::\".as_bytes()))\n         }\n-        for (i, seg) in path.segments.iter().enumerate() {\n+        for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n                 if_ok!(f.buf.write(\"::\".as_bytes()))\n             }\n@@ -297,8 +297,8 @@ fn typarams(w: &mut io::Writer,\n }\n \n impl fmt::Show for clean::Type {\n-    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *g {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n                     let m = cache.unwrap().get();\n@@ -405,18 +405,18 @@ impl fmt::Show for clean::Type {\n }\n \n impl fmt::Show for clean::FnDecl {\n-    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n-               args = d.inputs,\n-               arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output)\n+               args = self.inputs,\n+               arrow = match self.output { clean::Unit => \"no\", _ => \"yes\" },\n+               ret = self.output)\n     }\n }\n \n impl fmt::Show for ~[clean::Argument] {\n-    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut args = ~\"\";\n-        for (i, input) in inputs.iter().enumerate() {\n+        for (i, input) in self.iter().enumerate() {\n             if i > 0 { args.push_str(\", \"); }\n             if input.name.len() > 0 {\n                 args.push_str(format!(\"{}: \", input.name));\n@@ -428,8 +428,8 @@ impl fmt::Show for ~[clean::Argument] {\n }\n \n impl<'a> fmt::Show for Method<'a> {\n-    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Method(selfty, d) = *m;\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let Method(selfty, d) = *self;\n         let mut args = ~\"\";\n         match *selfty {\n             clean::SelfStatic => {},\n@@ -463,8 +463,8 @@ impl<'a> fmt::Show for Method<'a> {\n }\n \n impl fmt::Show for VisSpace {\n-    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.get() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n             Some(ast::Public) => write!(f.buf, \"pub \"),\n             Some(ast::Private) => write!(f.buf, \"priv \"),\n             Some(ast::Inherited) | None => Ok(())\n@@ -473,8 +473,8 @@ impl fmt::Show for VisSpace {\n }\n \n impl fmt::Show for PuritySpace {\n-    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) -> fmt::Result {\n-        match p.get() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n             ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n             ast::ExternFn => write!(f.buf, \"extern \"),\n             ast::ImpureFn => Ok(())\n@@ -483,8 +483,8 @@ impl fmt::Show for PuritySpace {\n }\n \n impl fmt::Show for clean::ViewPath {\n-    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *v {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n                     write!(f.buf, \"use {};\", *src)\n@@ -510,14 +510,14 @@ impl fmt::Show for clean::ViewPath {\n }\n \n impl fmt::Show for clean::ImportSource {\n-    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.did {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.did {\n             // FIXME: shouldn't be restricted to just local imports\n             Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true)\n+                resolved_path(f.buf, did.node, &self.path, true)\n             }\n             _ => {\n-                for (i, seg) in v.path.segments.iter().enumerate() {\n+                for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n                         if_ok!(write!(f.buf, \"::\"))\n                     }\n@@ -530,21 +530,21 @@ impl fmt::Show for clean::ImportSource {\n }\n \n impl fmt::Show for clean::ViewListIdent {\n-    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.source {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.source {\n             // FIXME: shouldn't be limited to just local imports\n             Some(did) if ast_util::is_local(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n-                        name: v.name.clone(),\n+                        name: self.name.clone(),\n                         lifetimes: ~[],\n                         types: ~[],\n                     }]\n                 };\n                 resolved_path(f.buf, did.node, &path, false)\n             }\n-            _ => write!(f.buf, \"{}\", v.name),\n+            _ => write!(f.buf, \"{}\", self.name),\n         }\n     }\n }"}, {"sha": "63748203a1ab102ff1cece5376f4846a1ae4cada", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -211,8 +211,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n }\n \n impl<'a> fmt::Show for Markdown<'a> {\n-    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *md;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n         render(fmt.buf, md.as_slice())"}, {"sha": "5bd970834a64d59d0eada046a83847525334d5e1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -801,8 +801,8 @@ impl<'a> Item<'a> {\n }\n \n impl<'a> fmt::Show for Item<'a> {\n-    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match attr::find_stability(it.item.attrs.iter()) {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match attr::find_stability(self.item.attrs.iter()) {\n             Some(ref stability) => {\n                 if_ok!(write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n@@ -815,38 +815,38 @@ impl<'a> fmt::Show for Item<'a> {\n             None => {}\n         }\n \n-        if it.cx.include_sources {\n+        if self.cx.include_sources {\n             let mut path = ~[];\n-            clean_srcpath(it.item.source.filename.as_bytes(), |component| {\n+            clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_owned());\n             });\n-            let href = if it.item.source.loline == it.item.source.hiline {\n-                format!(\"{}\", it.item.source.loline)\n+            let href = if self.item.source.loline == self.item.source.hiline {\n+                format!(\"{}\", self.item.source.loline)\n             } else {\n-                format!(\"{}-{}\", it.item.source.loline, it.item.source.hiline)\n+                format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n             };\n             if_ok!(write!(fmt.buf,\n                           \"<a class='source'\n                               href='{root}src/{crate}/{path}.html\\\\#{href}'>\\\n                               [src]</a>\",\n-                          root = it.cx.root_path,\n-                          crate = it.cx.layout.crate,\n+                          root = self.cx.root_path,\n+                          crate = self.cx.layout.crate,\n                           path = path.connect(\"/\"),\n                           href = href));\n         }\n \n         // Write the breadcrumb trail header for the top\n         if_ok!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n-        match it.item.inner {\n+        match self.item.inner {\n             clean::ModuleItem(..) => if_ok!(write!(fmt.buf, \"Module \")),\n             clean::FunctionItem(..) => if_ok!(write!(fmt.buf, \"Function \")),\n             clean::TraitItem(..) => if_ok!(write!(fmt.buf, \"Trait \")),\n             clean::StructItem(..) => if_ok!(write!(fmt.buf, \"Struct \")),\n             clean::EnumItem(..) => if_ok!(write!(fmt.buf, \"Enum \")),\n             _ => {}\n         }\n-        let cur = it.cx.current.as_slice();\n-        let amt = if it.ismodule() { cur.len() - 1 } else { cur.len() };\n+        let cur = self.cx.current.as_slice();\n+        let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n         for (i, component) in cur.iter().enumerate().take(amt) {\n             let mut trail = ~\"\";\n             for _ in range(0, cur.len() - i - 1) {\n@@ -856,17 +856,17 @@ impl<'a> fmt::Show for Item<'a> {\n                           trail, component.as_slice()));\n         }\n         if_ok!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n-                      shortty(it.item), it.item.name.get_ref().as_slice()));\n+                      shortty(self.item), self.item.name.get_ref().as_slice()));\n \n-        match it.item.inner {\n-            clean::ModuleItem(ref m) => item_module(fmt.buf, it.cx,\n-                                                    it.item, m.items),\n+        match self.item.inner {\n+            clean::ModuleItem(ref m) => item_module(fmt.buf, self.cx,\n+                                                    self.item, m.items),\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt.buf, it.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt.buf, it.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n-            clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n+                item_function(fmt.buf, self.item, f),\n+            clean::TraitItem(ref t) => item_trait(fmt.buf, self.item, t),\n+            clean::StructItem(ref s) => item_struct(fmt.buf, self.item, s),\n+            clean::EnumItem(ref e) => item_enum(fmt.buf, self.item, e),\n+            clean::TypedefItem(ref t) => item_typedef(fmt.buf, self.item, t),\n             _ => Ok(())\n         }\n     }\n@@ -992,9 +992,8 @@ fn item_module(w: &mut Writer, cx: &Context,\n             clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n                 struct Initializer<'a>(&'a str);\n                 impl<'a> fmt::Show for Initializer<'a> {\n-                    fn fmt(s: &Initializer<'a>,\n-                           f: &mut fmt::Formatter) -> fmt::Result {\n-                        let Initializer(s) = *s;\n+                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                        let Initializer(s) = *self;\n                         if s.len() == 0 { return Ok(()); }\n                         if_ok!(write!(f.buf, \"<code> = </code>\"));\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n@@ -1518,9 +1517,9 @@ fn item_typedef(w: &mut Writer, it: &clean::Item,\n }\n \n impl<'a> fmt::Show for Sidebar<'a> {\n-    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let cx = s.cx;\n-        let it = s.item;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let cx = self.cx;\n+        let it = self.item;\n         if_ok!(write!(fmt.buf, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n@@ -1588,8 +1587,8 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n }\n \n impl<'a> fmt::Show for Source<'a> {\n-    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Source(s) = *s;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Source(s) = *self;\n         let lines = s.lines().len();\n         let mut cols = 0;\n         let mut tmp = lines;"}, {"sha": "7d50cf551a0cea99ac52e06f50b07cf2ce525191", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -36,6 +36,7 @@\n use std::char;\n use std::cmp;\n use std::fmt;\n+use std::fmt::Show;\n use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n \n@@ -62,10 +63,10 @@ impl cmp::Ord for Identifier {\n \n impl fmt::Show for Identifier {\n     #[inline]\n-    fn fmt(version: &Identifier, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *version {\n-            Numeric(ref n) => fmt::Show::fmt(n, f),\n-            AlphaNumeric(ref s) => fmt::Show::fmt(s, f)\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Numeric(ref n) => n.fmt(f),\n+            AlphaNumeric(ref s) => s.fmt(f)\n         }\n     }\n }\n@@ -97,20 +98,20 @@ pub struct Version {\n \n impl fmt::Show for Version {\n     #[inline]\n-    fn fmt(version: &Version, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}.{}.{}\", version.major, version.minor, version.patch))\n-        if !version.pre.is_empty() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n+        if !self.pre.is_empty() {\n             if_ok!(write!(f.buf, \"-\"));\n-            for (i, x) in version.pre.iter().enumerate() {\n+            for (i, x) in self.pre.iter().enumerate() {\n                 if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(fmt::Show::fmt(x, f));\n+                if_ok!(x.fmt(f));\n             }\n         }\n-        if !version.build.is_empty() {\n+        if !self.build.is_empty() {\n             if_ok!(write!(f.buf, \"+\"));\n-            for (i, x) in version.build.iter().enumerate() {\n+            for (i, x) in self.build.iter().enumerate() {\n                 if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(fmt::Show::fmt(x, f));\n+                if_ok!(x.fmt(f));\n             }\n         }\n         Ok(())"}, {"sha": "d2e9fe040f7eddebad15b223733dfc4f2694f7be", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -166,11 +166,11 @@ method of the signature:\n # mod fmt { pub type Result = (); }\n # struct T;\n # trait SomeName<T> {\n-fn fmt(value: &T, f: &mut std::fmt::Formatter) -> fmt::Result;\n+fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n # }\n ```\n \n-Your type will be passed by-reference in `value`, and then the function should\n+Your type will be passed as `self` by-reference, and then the function should\n emit output into the `f.buf` stream. It is up to each format trait\n implementation to correctly adhere to the requested formatting parameters. The\n values of these parameters will be listed in the fields of the `Formatter`\n@@ -195,19 +195,19 @@ struct Vector2D {\n }\n \n impl fmt::Show for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // The `f.buf` value is of the type `&mut io::Writer`, which is what th\n         // write! macro is expecting. Note that this formatting ignores the\n         // various flags provided to format strings.\n-        write!(f.buf, \"({}, {})\", obj.x, obj.y)\n+        write!(f.buf, \"({}, {})\", self.x, self.y)\n     }\n }\n \n // Different traits allow different forms of output of a type. The meaning of\n // this format is to print the magnitude of a vector.\n impl fmt::Binary for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n-        let magnitude = (obj.x * obj.x + obj.y * obj.y) as f64;\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n         let magnitude = magnitude.sqrt();\n \n         // Respect the formatting flags by using the helper method\n@@ -558,50 +558,50 @@ pub struct Arguments<'a> {\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n #[allow(missing_doc)]\n-pub trait Show { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Show { fn fmt(&self, &mut Formatter) -> Result; }\n \n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Bool { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Bool { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `c` character\n #[allow(missing_doc)]\n-pub trait Char { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Char { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `i` and `d` characters\n #[allow(missing_doc)]\n-pub trait Signed { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Signed { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `u` character\n #[allow(missing_doc)]\n-pub trait Unsigned { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Unsigned { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `o` character\n #[allow(missing_doc)]\n-pub trait Octal { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Octal { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Binary { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Binary { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `x` character\n #[allow(missing_doc)]\n-pub trait LowerHex { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait LowerHex { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `X` character\n #[allow(missing_doc)]\n-pub trait UpperHex { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait UpperHex { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `s` character\n #[allow(missing_doc)]\n-pub trait String { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait String { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `?` character\n #[allow(missing_doc)]\n-pub trait Poly { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Poly { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `p` character\n #[allow(missing_doc)]\n-pub trait Pointer { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Pointer { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `f` character\n #[allow(missing_doc)]\n-pub trait Float { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Float { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `e` character\n #[allow(missing_doc)]\n-pub trait LowerExp { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait LowerExp { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `E` character\n #[allow(missing_doc)]\n-pub trait UpperExp { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait UpperExp { fn fmt(&self, &mut Formatter) -> Result; }\n \n // FIXME #11938 - UFCS would make us able call the above methods\n // directly Show::show(x, fmt).\n@@ -615,7 +615,7 @@ macro_rules! uniform_fn_call_workaround {\n         $(\n             #[doc(hidden)]\n             pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n-                $trait_::fmt(x, fmt)\n+                x.fmt(fmt)\n             }\n             )*\n     }\n@@ -1042,53 +1042,53 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n /// (such as for select), then it invokes this method.\n #[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(String::fmt, s)\n+    argument(secret_string, s)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n #[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Unsigned::fmt, s)\n+    argument(secret_unsigned, s)\n }\n \n // Implementations of the core formatting traits\n \n impl Bool for bool {\n-    fn fmt(b: &bool, f: &mut Formatter) -> Result {\n-        String::fmt(&(if *b {\"true\"} else {\"false\"}), f)\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n     }\n }\n \n impl<'a, T: str::Str> String for T {\n-    fn fmt(s: &T, f: &mut Formatter) -> Result {\n-        f.pad(s.as_slice())\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(self.as_slice())\n     }\n }\n \n impl Char for char {\n-    fn fmt(c: &char, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n-        let amt = c.encode_utf8(utf8);\n+        let amt = self.encode_utf8(utf8);\n         let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n-        String::fmt(&s, f)\n+        secret_string(&s, f)\n     }\n }\n \n macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*c as $into, $base, |buf| {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$into::to_str_bytes(*self as $into, $base, |buf| {\n                 f.pad_integral(buf, $prefix, true)\n             })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*c as $into, 16, |buf| {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$into::to_str_bytes(*self as $into, 16, |buf| {\n                 upperhex(buf, f)\n             })\n         }\n@@ -1112,9 +1112,9 @@ macro_rules! integer(($signed:ident, $unsigned:ident) => {\n     // Signed is special because it actuall emits the negative sign,\n     // nothing else should do that, however.\n     impl Signed for $signed {\n-        fn fmt(c: &$signed, f: &mut Formatter) -> Result {\n-            ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *c >= 0)\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$unsigned::to_str_bytes(self.abs() as $unsigned, 10, |buf| {\n+                f.pad_integral(buf, \"\", *self >= 0)\n             })\n         }\n     }\n@@ -1138,103 +1138,103 @@ integer!(i64, u64)\n \n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exact(f.abs(), i),\n-                None => ::$ty::to_str_digits(f.abs(), 6)\n+                Some(i) => ::$ty::to_str_exact(self.abs(), i),\n+                None => ::$ty::to_str_digits(self.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n \n     impl LowerExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, false),\n-                None => ::$ty::to_str_exp_digits(f.abs(), 6, false)\n+                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n+                None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n \n     impl UpperExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, true),\n-                None => ::$ty::to_str_exp_digits(f.abs(), 6, true)\n+                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n+                None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n })\n floating!(f32)\n floating!(f64)\n \n impl<T> Poly for T {\n-    fn fmt(t: &T, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         match (f.width, f.precision) {\n             (None, None) => {\n-                repr::write_repr(f.buf, t)\n+                repr::write_repr(f.buf, self)\n             }\n \n             // If we have a specified width for formatting, then we have to make\n             // this allocation of a new string\n             _ => {\n-                let s = repr::repr_to_str(t);\n+                let s = repr::repr_to_str(self);\n                 f.pad(s)\n             }\n         }\n     }\n }\n \n impl<T> Pointer for *T {\n-    fn fmt(t: &*T, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        ::uint::to_str_bytes(*t as uint, 16, |buf| {\n+        ::uint::to_str_bytes(*self as uint, 16, |buf| {\n             f.pad_integral(buf, \"0x\", true)\n         })\n     }\n }\n impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) -> Result {\n-        Pointer::fmt(&(*t as *T), f)\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer(&(*self as *T), f)\n     }\n }\n \n // Implementation of Show for various core types\n \n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl<'a> Show for $ty {\n-        fn fmt(me: &$ty, f: &mut Formatter) -> Result {\n-            $other::fmt(me, f)\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            (concat_idents!(secret_, $other)(self, f))\n         }\n     }\n })\n-delegate!(int to Signed)\n-delegate!( i8 to Signed)\n-delegate!(i16 to Signed)\n-delegate!(i32 to Signed)\n-delegate!(i64 to Signed)\n-delegate!(uint to Unsigned)\n-delegate!(  u8 to Unsigned)\n-delegate!( u16 to Unsigned)\n-delegate!( u32 to Unsigned)\n-delegate!( u64 to Unsigned)\n-delegate!(~str to String)\n-delegate!(&'a str to String)\n-delegate!(bool to Bool)\n-delegate!(char to Char)\n-delegate!(f32 to Float)\n-delegate!(f64 to Float)\n+delegate!(int to signed)\n+delegate!( i8 to signed)\n+delegate!(i16 to signed)\n+delegate!(i32 to signed)\n+delegate!(i64 to signed)\n+delegate!(uint to unsigned)\n+delegate!(  u8 to unsigned)\n+delegate!( u16 to unsigned)\n+delegate!( u32 to unsigned)\n+delegate!( u64 to unsigned)\n+delegate!(~str to string)\n+delegate!(&'a str to string)\n+delegate!(bool to bool)\n+delegate!(char to char)\n+delegate!(f32 to float)\n+delegate!(f64 to float)\n \n impl<T> Show for *T {\n-    fn fmt(me: &*T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n impl<T> Show for *mut T {\n-    fn fmt(me: &*mut T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "4d28143c75ab65d1e8ba6e5bd482cb615edae805", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -364,9 +364,9 @@ pub struct IoError {\n }\n \n impl fmt::Show for IoError {\n-    fn fmt(err: &IoError, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(fmt.buf.write_str(err.desc));\n-        match err.detail {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(fmt.buf.write_str(self.desc));\n+        match self.detail {\n             Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n             None => Ok(())\n         }"}, {"sha": "b515cd9d31c0eb5048e22a46d112b8104f531daa", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -93,8 +93,8 @@ pub enum ProcessExit {\n \n impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *obj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n             ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n         }"}, {"sha": "5d986a73ca14d1d46326a81db98aaf32d371e233", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -382,8 +382,8 @@ impl<T: Default> Option<T> {\n \n impl<T: fmt::Show> fmt::Show for Option<T> {\n     #[inline]\n-    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *s {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             Some(ref t) => write!(f.buf, \"Some({})\", *t),\n             None        => write!(f.buf, \"None\")\n         }"}, {"sha": "78cae2964570c995ab965af89e55ad728a175acf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -942,8 +942,8 @@ pub enum MapError {\n }\n \n impl fmt::Show for MapError {\n-    fn fmt(val: &MapError, out: &mut fmt::Formatter) -> fmt::Result {\n-        let str = match *val {\n+    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n+        let str = match *self {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n             ErrInvalidFd => \"Invalid fd\",\n             ErrUnaligned => {"}, {"sha": "18f28994cba9697835114365f2c755d2862ded95", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -494,8 +494,8 @@ pub struct Display<'a, P> {\n }\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n-    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Result {\n-        d.with_str(|s| f.pad(s))\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.with_str(|s| f.pad(s))\n     }\n }\n "}, {"sha": "39e8b6ad6c1d2608f0634bf6aa0dc217d13ab5cc", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -208,8 +208,8 @@ impl<T, E> Result<T, E> {\n \n impl<T: fmt::Show, E: fmt::Show> fmt::Show for Result<T, E> {\n     #[inline]\n-    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *s {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n             Err(ref e) => write!(f.buf, \"Err({})\", *e)\n         }"}, {"sha": "848f4ba3871d293f964f6cd99a247352e09ded1b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -36,7 +36,7 @@ pub struct MacroDef {\n }\n \n pub type ItemDecorator =\n-    fn(&ExtCtxt, Span, @ast::MetaItem, ~[@ast::Item]) -> ~[@ast::Item];\n+    fn(&mut ExtCtxt, Span, @ast::MetaItem, ~[@ast::Item]) -> ~[@ast::Item];\n \n pub struct BasicMacroExpander {\n     expander: MacroExpanderFn,"}, {"sha": "1736124062862d3c705e68e615253a08bb030856", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_clone(cx: &ExtCtxt,\n+pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: @MetaItem,\n                              in_items: ~[@Item])\n@@ -42,7 +42,7 @@ pub fn expand_deriving_clone(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n+pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@Item])\n@@ -74,7 +74,7 @@ pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: &ExtCtxt, trait_span: Span,\n+    cx: &mut ExtCtxt, trait_span: Span,\n     substr: &Substructure) -> @Expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;"}, {"sha": "a469c4a960b4013bb41f7f5fe094c5ffdf08c014", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -14,17 +14,17 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_eq(cx: &ExtCtxt,\n+pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: @MetaItem,\n                           in_items: ~[@Item]) -> ~[@Item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "83f623e30666d0797bb1220b54400010ff1747c2", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -15,7 +15,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_ord(cx: &ExtCtxt,\n+pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: @MetaItem,\n                            in_items: ~[@Item]) -> ~[@Item] {\n@@ -51,7 +51,7 @@ pub fn expand_deriving_ord(cx: &ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,"}, {"sha": "0a38a2ce30dc877cb4d6f3876d67c6cce8dbb367", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -14,11 +14,11 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_totaleq(cx: &ExtCtxt,\n+pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: @MetaItem,\n                                in_items: ~[@Item]) -> ~[@Item] {\n-    fn cs_equals(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_equals(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }"}, {"sha": "27a766c0e7562f759364364ea08541dea1a8af77", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -16,7 +16,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use std::cmp::{Ordering, Equal, Less, Greater};\n \n-pub fn expand_deriving_totalord(cx: &ExtCtxt,\n+pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@Item]) -> ~[@Item] {\n@@ -44,7 +44,7 @@ pub fn expand_deriving_totalord(cx: &ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: &ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n+pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n@@ -56,7 +56,7 @@ pub fn ordering_const(cx: &ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n                      cx.ident_of(cnst)])\n }\n \n-pub fn cs_cmp(cx: &ExtCtxt, span: Span,\n+pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> @Expr {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);\n@@ -106,8 +106,10 @@ pub fn cs_cmp(cx: &ExtCtxt, span: Span,\n                 // an earlier nonmatching variant is Less than a\n                 // later one.\n                 [(self_var, _, _),\n-                 (other_var, _, _)] => cx.expr_path(ordering_const(cx, span,\n-                                                                   self_var.cmp(&other_var))),\n+                 (other_var, _, _)] => {\n+                    let order = ordering_const(cx, span, self_var.cmp(&other_var));\n+                    cx.expr_path(order)\n+                }\n                 _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(TotalOrd)`\")\n             }\n         },"}, {"sha": "7324500a8a0eb91fc72540b57f6accbd4192cdd6", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -21,7 +21,7 @@ use ext::deriving::generic::*;\n use parse::token::InternedString;\n use parse::token;\n \n-pub fn expand_deriving_decodable(cx: &ExtCtxt,\n+pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n@@ -53,7 +53,7 @@ pub fn expand_deriving_decodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n+fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"serialize\"),\n@@ -77,7 +77,7 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                                               trait_span,\n                                               substr.type_ident,\n                                               summary,\n-                                              |span, name, field| {\n+                                              |cx, span, name, field| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n                                     ~[cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n@@ -108,10 +108,10 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                                                    v_span,\n                                                    name,\n                                                    parts,\n-                                                   |span, _, field| {\n+                                                   |cx, span, _, field| {\n+                    let idx = cx.expr_uint(span, field);\n                     cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                        ~[cx.expr_uint(span, field),\n-                                          lambdadecode])\n+                                        ~[idx, lambdadecode])\n                 });\n \n                 arms.push(cx.arm(v_span,\n@@ -143,19 +143,19 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: &ExtCtxt,\n+fn decode_static_fields(cx: &mut ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |Span, InternedString, uint| -> @Expr)\n+                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> @Expr)\n                         -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {\n                 cx.expr_ident(trait_span, outer_pat_ident)\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n-                    getarg(span,\n+                    getarg(cx, span,\n                            token::intern_and_get_ident(format!(\"_field{}\",\n                                                                i)),\n                            i)\n@@ -167,9 +167,8 @@ fn decode_static_fields(cx: &ExtCtxt,\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n-                cx.field_imm(span,\n-                             name,\n-                             getarg(span, token::get_ident(name.name), i))\n+                let arg = getarg(cx, span, token::get_ident(name.name), i);\n+                cx.field_imm(span, name, arg)\n             }).collect();\n             cx.expr_struct_ident(trait_span, outer_pat_ident, fields)\n         }"}, {"sha": "922ee164353208a96634824df8e2f7dd078bab7f", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_default(cx: &ExtCtxt,\n+pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n@@ -41,7 +41,7 @@ pub fn expand_deriving_default(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn default_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let default_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "4de31adc7f2c7cf76320600ef46434f5e93261ac", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -82,7 +82,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use parse::token;\n \n-pub fn expand_deriving_encodable(cx: &ExtCtxt,\n+pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n@@ -114,7 +114,7 @@ pub fn expand_deriving_encodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n+fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings"}, {"sha": "8c06f0b8c8a0ec182164f7f6d10647fe145b4d97", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -194,7 +194,7 @@ mod ty;\n \n pub struct TraitDef<'a> {\n     /// The extension context\n-    cx: &'a ExtCtxt<'a>,\n+    cx: &'a mut ExtCtxt<'a>,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n@@ -304,15 +304,15 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    'a |&ExtCtxt, Span, &Substructure| -> @Expr;\n+    'a |&mut ExtCtxt, Span, &Substructure| -> @Expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::Variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'a> =\n-    'a |&ExtCtxt,\n+    'a |&mut ExtCtxt,\n            Span,\n            &[(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])],\n            &[@Expr]|\n@@ -356,7 +356,7 @@ impl<'a> TraitDef<'a> {\n     fn create_derived_impl(&self,\n                            type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::Method]) -> @ast::Item {\n-        let cx = self.cx;\n+        let cx = &*self.cx;\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let mut trait_generics = self.generics.to_generics(cx, self.span,\n@@ -764,7 +764,7 @@ impl<'a> MethodDef<'a> {\n                         matches_so_far: &mut ~[(uint, P<ast::Variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n-        let cx = trait_.cx;\n+        let cx = &trait_.cx;\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n@@ -990,7 +990,7 @@ impl<'a> TraitDef<'a> {\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = self.cx;\n+        let cx = &self.cx;\n \n         if struct_def.fields.is_empty() {\n             return (\n@@ -1050,7 +1050,7 @@ impl<'a> TraitDef<'a> {\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = self.cx;\n+        let cx = &*self.cx;\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n@@ -1093,10 +1093,10 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |&ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n+               f: |&mut ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n                base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: &ExtCtxt,\n+               cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n                -> @Expr {\n@@ -1132,9 +1132,9 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&ExtCtxt, Span, ~[@Expr]| -> @Expr,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, ~[@Expr]| -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: &ExtCtxt,\n+                      cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n                       -> @Expr {\n@@ -1166,10 +1166,10 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n+                           f: |&mut ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n                            base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: &ExtCtxt,\n+                           cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n                            -> @Expr {\n@@ -1196,7 +1196,7 @@ on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: &ExtCtxt, trait_span: Span,\n+                cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> @Expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n@@ -1214,7 +1214,7 @@ pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n /// cs_binop with binop == or\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             cx: &ExtCtxt, span: Span,\n+             cx: &mut ExtCtxt, span: Span,\n              substructure: &Substructure) -> @Expr {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n@@ -1224,7 +1224,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              cx: &ExtCtxt, span: Span,\n+              cx: &mut ExtCtxt, span: Span,\n               substructure: &Substructure) -> @Expr {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,"}, {"sha": "5380569472582b6ae2dc012df1e1f28c933ee442", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -15,7 +15,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n \n-pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n+pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@Item]) -> ~[@Item] {\n@@ -45,7 +45,7 @@ pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn iter_bytes_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n         _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(IterBytes)`\")"}, {"sha": "01e31fc5724d20b1200353c200a1c8ff322f5f66", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -18,8 +18,7 @@ library.\n \n */\n \n-use ast::{EnumDef, Ident, Item, Generics, StructDef};\n-use ast::{MetaItem, MetaList, MetaNameValue, MetaWord};\n+use ast::{Item, MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n \n@@ -29,6 +28,7 @@ pub mod encodable;\n pub mod decodable;\n pub mod rand;\n pub mod to_str;\n+pub mod show;\n pub mod zero;\n pub mod default;\n pub mod primitive;\n@@ -45,20 +45,7 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub type ExpandDerivingStructDefFn<'a> = 'a |&ExtCtxt,\n-                                                   Span,\n-                                                   x: &StructDef,\n-                                                   Ident,\n-                                                   y: &Generics|\n-                                                   -> @Item;\n-pub type ExpandDerivingEnumDefFn<'a> = 'a |&ExtCtxt,\n-                                                 Span,\n-                                                 x: &EnumDef,\n-                                                 Ident,\n-                                                 y: &Generics|\n-                                                 -> @Item;\n-\n-pub fn expand_meta_deriving(cx: &ExtCtxt,\n+pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n@@ -97,6 +84,7 @@ pub fn expand_meta_deriving(cx: &ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"Show\" => expand!(show::expand_deriving_show),\n \n                             \"Zero\" => expand!(zero::expand_deriving_zero),\n                             \"Default\" => expand!(default::expand_deriving_default),"}, {"sha": "86c46705d81b98d0ba82808be37e268af6555d7d", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -16,7 +16,7 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use parse::token::InternedString;\n \n-pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n+pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n                                       mitem: @MetaItem,\n                                       in_items: ~[@Item]) -> ~[@Item] {\n@@ -65,7 +65,7 @@ pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let n = match substr.nonself_args {\n         [n] => n,\n         _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")"}, {"sha": "15595f6eddc404922e7469e8dbaa64c0b4ac7980", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -16,7 +16,7 @@ use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use opt_vec;\n \n-pub fn expand_deriving_rand(cx: &ExtCtxt,\n+pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n@@ -50,7 +50,7 @@ pub fn expand_deriving_rand(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn rand_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -112,9 +112,8 @@ fn rand_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @\n                 let i_expr = cx.expr_uint(v_span, i);\n                 let pat = cx.pat_lit(v_span, i_expr);\n \n-                cx.arm(v_span,\n-                       ~[ pat ],\n-                       rand_thing(cx, v_span, ident, summary, |sp| rand_call(sp)))\n+                let thing = rand_thing(cx, v_span, ident, summary, |sp| rand_call(sp));\n+                cx.arm(v_span, ~[ pat ], thing)\n             }).collect::<~[ast::Arm]>();\n \n             // _ => {} at the end. Should never occur\n@@ -128,7 +127,7 @@ fn rand_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: &ExtCtxt,\n+    fn rand_thing(cx: &mut ExtCtxt,\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,"}, {"sha": "67cfd151f6293e07d293137873dfb334d507a1d7", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use ast::{MetaItem, Item, Expr};\n+use codemap::Span;\n+use ext::format;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use parse::token;\n+\n+use std::hashmap::HashMap;\n+\n+pub fn expand_deriving_show(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: @MetaItem,\n+                            in_items: ~[@Item])\n+    -> ~[@Item] {\n+    // &mut ::std::fmt::Formatter\n+    let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n+                   Borrowed(None, ast::MutMutable));\n+\n+    let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n+        path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"fmt\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[fmtr],\n+                ret_ty: Literal(Path::new(~[\"std\", \"fmt\", \"Result\"])),\n+                inline: false,\n+                const_nonmatching: false,\n+                combine_substructure: show_substructure\n+            }\n+        ]\n+    };\n+    trait_def.expand(mitem, in_items)\n+}\n+\n+// we construct a format string and then defer to std::fmt, since that\n+// knows what's up with formatting at so on.\n+fn show_substructure(cx: &mut ExtCtxt, span: Span,\n+                     substr: &Substructure) -> @Expr {\n+    // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n+    // <field>: {}, ... }` based on the \"shape\".\n+    //\n+    // Easy start: they all start with the name.\n+    let name = match *substr.fields {\n+        Struct(_) => substr.type_ident,\n+        EnumMatching(_, v, _) => v.node.name,\n+\n+        EnumNonMatching(..) | StaticStruct(..) | StaticEnum(..) => {\n+            cx.span_bug(span, \"nonsensical .fields in `#[deriving(Show)]`\")\n+        }\n+    };\n+\n+    let mut format_string = token::get_ident(name.name).get().to_owned();\n+    // the internal fields we're actually formatting\n+    let mut exprs = ~[];\n+\n+    // Getting harder... making the format string:\n+    match *substr.fields {\n+        // unit struct/nullary variant: no work necessary!\n+        Struct([]) | EnumMatching(_, _, []) => {}\n+\n+        Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n+            if fields[0].name.is_none() {\n+                // tuple struct/\"normal\" variant\n+\n+                format_string.push_str(\"(\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 { format_string.push_str(\", \"); }\n+\n+                    format_string.push_str(\"{}\");\n+\n+                    exprs.push(field.self_);\n+                }\n+\n+                format_string.push_str(\")\");\n+            } else {\n+                // normal struct/struct variant\n+\n+                format_string.push_str(\" \\\\{\");\n+\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 { format_string.push_str(\",\"); }\n+\n+                    let name = token::get_ident(field.name.unwrap().name);\n+                    format_string.push_str(\" \");\n+                    format_string.push_str(name.get());\n+                    format_string.push_str(\": {}\");\n+\n+                    exprs.push(field.self_);\n+                }\n+\n+                format_string.push_str(\" \\\\}\");\n+            }\n+        }\n+        _ => unreachable!()\n+    }\n+\n+    // AST construction!\n+    // we're basically calling\n+    //\n+    // format_arg!(|__args| ::std::fmt::write(fmt.buf, __args), \"<format_string>\", exprs...)\n+    //\n+    // but doing it directly via ext::format.\n+    let formatter = substr.nonself_args[0];\n+    let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n+\n+    let std_write = ~[cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\")];\n+    let args = cx.ident_of(\"__args\");\n+    let write_call = cx.expr_call_global(span, std_write, ~[buf, cx.expr_ident(span, args)]);\n+    let format_closure = cx.lambda_expr(span, ~[args], write_call);\n+\n+    let s = token::intern_and_get_ident(format_string);\n+    let format_string = cx.expr_str(span, s);\n+\n+    // phew, not our responsibility any more!\n+    format::expand_preparsed_format_args(cx, span,\n+                                         format_closure,\n+                                         format_string, exprs, HashMap::new())\n+}"}, {"sha": "2f50d5ad121cb77abfb2b7169a72ffb931fb1b52", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -17,7 +17,7 @@ use ext::deriving::generic::*;\n use parse::token::InternedString;\n use parse::token;\n \n-pub fn expand_deriving_to_str(cx: &ExtCtxt,\n+pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n                               span: Span,\n                               mitem: @MetaItem,\n                               in_items: ~[@Item])\n@@ -49,7 +49,7 @@ pub fn expand_deriving_to_str(cx: &ExtCtxt,\n // doesn't invoke the to_str() method on each field. Hence we mirror\n // the logic of the repr_to_str() method, but with tweaks to call to_str()\n // on sub-fields.\n-fn to_str_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure)\n+fn to_str_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure)\n                        -> @Expr {\n     let to_str = cx.ident_of(\"to_str\");\n "}, {"sha": "ecd06b3f49e5678debec88805e096910fdb927ac", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -14,7 +14,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_zero(cx: &ExtCtxt,\n+pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n@@ -57,7 +57,7 @@ pub fn expand_deriving_zero(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn zero_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "4bc3b804c7ff7a5fb3cd503370b446e7adf659c9", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 92, "deletions": 74, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -56,78 +56,83 @@ struct Context<'a> {\n     next_arg: uint,\n }\n \n-impl<'a> Context<'a> {\n-    /// Parses the arguments from the given list of tokens, returning None if\n-    /// there's a parse error so we can continue parsing other format! expressions.\n-    fn parse_args(&mut self, sp: Span, tts: &[ast::TokenTree])\n-                  -> (@ast::Expr, Option<@ast::Expr>) {\n-        let mut p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n-                                                 self.ecx.cfg(),\n-                                                 tts.to_owned());\n-        // Parse the leading function expression (maybe a block, maybe a path)\n-        let extra = p.parse_expr();\n-        if !p.eat(&token::COMMA) {\n-            self.ecx.span_err(sp, \"expected token: `,`\");\n-            return (extra, None);\n-        }\n+/// Parses the arguments from the given list of tokens, returning None\n+/// if there's a parse error so we can continue parsing other format!\n+/// expressions.\n+///\n+/// If parsing succeeds, the second return value is:\n+///\n+///     Some((fmtstr, unnamed arguments, named arguments))\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span,\n+              tts: &[ast::TokenTree]) -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr],\n+                                                              HashMap<~str, @ast::Expr>)>) {\n+    let mut args = ~[];\n+    let mut names = HashMap::<~str, @ast::Expr>::new();\n+\n+    let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n+                                             ecx.cfg(),\n+                                             tts.to_owned());\n+    // Parse the leading function expression (maybe a block, maybe a path)\n+    let extra = p.parse_expr();\n+    if !p.eat(&token::COMMA) {\n+        ecx.span_err(sp, \"expected token: `,`\");\n+        return (extra, None);\n+    }\n \n-        if p.token == token::EOF {\n-            self.ecx.span_err(sp, \"requires at least a format string argument\");\n+    if p.token == token::EOF {\n+        ecx.span_err(sp, \"requires at least a format string argument\");\n+        return (extra, None);\n+    }\n+    let fmtstr = p.parse_expr();\n+    let mut named = false;\n+    while p.token != token::EOF {\n+        if !p.eat(&token::COMMA) {\n+            ecx.span_err(sp, \"expected token: `,`\");\n             return (extra, None);\n         }\n-        let fmtstr = p.parse_expr();\n-        let mut named = false;\n-        while p.token != token::EOF {\n-            if !p.eat(&token::COMMA) {\n-                self.ecx.span_err(sp, \"expected token: `,`\");\n-                return (extra, None);\n-            }\n-            if p.token == token::EOF { break } // accept trailing commas\n-            if named || (token::is_ident(&p.token) &&\n-                         p.look_ahead(1, |t| *t == token::EQ)) {\n-                named = true;\n-                let ident = match p.token {\n-                    token::IDENT(i, _) => {\n-                        p.bump();\n-                        i\n-                    }\n-                    _ if named => {\n-                        self.ecx.span_err(p.span,\n-                                          \"expected ident, positional arguments \\\n-                                           cannot follow named arguments\");\n-                        return (extra, None);\n-                    }\n-                    _ => {\n-                        self.ecx.span_err(p.span,\n-                                          format!(\"expected ident for named \\\n-                                                argument, but found `{}`\",\n-                                               p.this_token_to_str()));\n-                        return (extra, None);\n-                    }\n-                };\n-                let interned_name = token::get_ident(ident.name);\n-                let name = interned_name.get();\n-                p.expect(&token::EQ);\n-                let e = p.parse_expr();\n-                match self.names.find_equiv(&name) {\n-                    None => {}\n-                    Some(prev) => {\n-                        self.ecx.span_err(e.span, format!(\"duplicate argument \\\n-                                                        named `{}`\", name));\n-                        self.ecx.parse_sess.span_diagnostic.span_note(\n-                            prev.span, \"previously here\");\n-                        continue\n-                    }\n+        if p.token == token::EOF { break } // accept trailing commas\n+        if named || (token::is_ident(&p.token) &&\n+                     p.look_ahead(1, |t| *t == token::EQ)) {\n+            named = true;\n+            let ident = match p.token {\n+                token::IDENT(i, _) => {\n+                    p.bump();\n+                    i\n+                }\n+                _ if named => {\n+                    ecx.span_err(p.span,\n+                                 \"expected ident, positional arguments \\\n+                                 cannot follow named arguments\");\n+                    return (extra, None);\n+                }\n+                _ => {\n+                    ecx.span_err(p.span,\n+                                 format!(\"expected ident for named argument, but found `{}`\",\n+                                         p.this_token_to_str()));\n+                    return (extra, None);\n+                }\n+            };\n+            let interned_name = token::get_ident(ident.name);\n+            let name = interned_name.get();\n+            p.expect(&token::EQ);\n+            let e = p.parse_expr();\n+            match names.find_equiv(&name) {\n+                None => {}\n+                Some(prev) => {\n+                    ecx.span_err(e.span, format!(\"duplicate argument named `{}`\", name));\n+                    ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n+                    continue\n                 }\n-                self.names.insert(name.to_str(), e);\n-            } else {\n-                self.args.push(p.parse_expr());\n-                self.arg_types.push(None);\n             }\n+            names.insert(name.to_str(), e);\n+        } else {\n+            args.push(p.parse_expr());\n         }\n-        return (extra, Some(fmtstr));\n     }\n+    return (extra, Some((fmtstr, args, names)));\n+}\n \n+impl<'a> Context<'a> {\n     /// Verifies one piece of a parse string. All errors are not emitted as\n     /// fatal so we can continue giving errors about this and possibly other\n     /// format strings.\n@@ -758,11 +763,28 @@ impl<'a> Context<'a> {\n \n pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                    tts: &[ast::TokenTree]) -> base::MacResult {\n+\n+    match parse_args(ecx, sp, tts) {\n+        (extra, Some((efmt, args, names))) => {\n+            MRExpr(expand_preparsed_format_args(ecx, sp, extra, efmt, args, names))\n+        }\n+        (_, None) => MRExpr(ecx.expr_uint(sp, 2))\n+    }\n+}\n+\n+/// Take the various parts of `format_args!(extra, efmt, args...,\n+/// name=names...)` and construct the appropriate formatting\n+/// expression.\n+pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n+                                    extra: @ast::Expr,\n+                                    efmt: @ast::Expr, args: ~[@ast::Expr],\n+                                    names: HashMap<~str, @ast::Expr>) -> @ast::Expr {\n+    let arg_types = vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,\n-        args: ~[],\n-        arg_types: ~[],\n-        names: HashMap::new(),\n+        args: args,\n+        arg_types: arg_types,\n+        names: names,\n         name_positions: HashMap::new(),\n         name_types: HashMap::new(),\n         nest_level: 0,\n@@ -771,10 +793,6 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let (extra, efmt) = match cx.parse_args(sp, tts) {\n-        (extra, Some(e)) => (extra, e),\n-        (_, None) => { return MRExpr(cx.ecx.expr_uint(sp, 2)); }\n-    };\n     cx.fmtsp = efmt.span;\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n@@ -783,7 +801,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                                 expr,\n                                 \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n-        None => return MacResult::dummy_expr()\n+        None => return efmt\n     };\n \n     let mut parser = parse::Parser::new(fmt.get());\n@@ -801,7 +819,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n     match parser.errors.shift() {\n         Some(error) => {\n             cx.ecx.span_err(efmt.span, \"invalid format string: \" + error);\n-            return MRExpr(efmt);\n+            return efmt;\n         }\n         None => {}\n     }\n@@ -818,5 +836,5 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    MRExpr(cx.to_expr(extra))\n+    cx.to_expr(extra)\n }"}, {"sha": "d32411b4f050ae1f10aa28000c99706db59c4f32", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -588,8 +588,8 @@ impl BytesContainer for InternedString {\n }\n \n impl fmt::Show for InternedString {\n-    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", obj.string.as_slice())\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, \"{}\", self.string.as_slice())\n     }\n }\n "}, {"sha": "582c95b746b7a45cce817b83be675de4b65b8389", "filename": "src/test/compile-fail/deriving-span-Show-enum-struct-variant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Show)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "92efe01fa3863120457a732d95a17cbd3ff3396c", "filename": "src/test/compile-fail/deriving-span-Show-enum.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Show)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "7eff82f9d13ff39548d55a7c60a99a10ed50417a", "filename": "src/test/compile-fail/deriving-span-Show-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Show)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "600a0400350dbea8ace9f00b164dcf8e9b380d74", "filename": "src/test/compile-fail/deriving-span-Show-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Show)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "40965615506c79d0d9d3a1326eef0b58fd0aa240", "filename": "src/test/run-pass/deriving-show.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant, macro_rules)];\n+\n+#[deriving(Show)]\n+struct Unit;\n+\n+#[deriving(Show)]\n+struct Tuple(int, uint);\n+\n+#[deriving(Show)]\n+struct Struct { x: int, y: uint }\n+\n+#[deriving(Show)]\n+enum Enum {\n+    Nullary,\n+    Variant(int, uint),\n+    StructVariant { x: int, y : uint }\n+}\n+\n+macro_rules! t {\n+    ($x:expr, $expected:expr) => {\n+        assert_eq!(format!(\"{}\", $x), $expected.to_owned())\n+    }\n+}\n+\n+pub fn main() {\n+    t!(Unit, \"Unit\");\n+    t!(Tuple(1, 2), \"Tuple(1, 2)\");\n+    t!(Struct { x: 1, y: 2 }, \"Struct { x: 1, y: 2 }\");\n+    t!(Nullary, \"Nullary\");\n+    t!(Variant(1, 2), \"Variant(1, 2)\");\n+    t!(StructVariant { x: 1, y: 2 }, \"StructVariant { x: 1, y: 2 }\");\n+}"}, {"sha": "4a82007f0600462a846913179ec1e72b634d5ab8", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -23,12 +23,12 @@ struct A;\n struct B;\n \n impl fmt::Signed for A {\n-    fn fmt(_: &A, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.buf.write(\"aloha\".as_bytes())\n     }\n }\n impl fmt::Signed for B {\n-    fn fmt(_: &B, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.buf.write(\"adios\".as_bytes())\n     }\n }"}, {"sha": "8c6a366220cec522ee66a91e991ce45f0591d356", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde2e0b3865ba040261d2078db371adbefb32506/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=dde2e0b3865ba040261d2078db371adbefb32506", "patch": "@@ -17,8 +17,8 @@ use std::fmt;\n struct Foo(Cell<int>);\n \n impl fmt::Show for Foo {\n-    fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Foo(ref f) = *f;\n+    fn fmt(&self, _fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Foo(ref f) = *self;\n         assert!(f.get() == 0);\n         f.set(1);\n         Ok(())"}]}