{"sha": "8e9d0faff28cff0290d76c2cda175bb8a79b293b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOWQwZmFmZjI4Y2ZmMDI5MGQ3NmMyY2RhMTc1YmI4YTc5YjI5M2I=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-29T07:36:42Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-29T08:05:59Z"}, "message": "adding a err macro for each of the InterpError variants", "tree": {"sha": "bdc31ce12bcede6a20eb620ca2d0a6e0aa4a8141", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc31ce12bcede6a20eb620ca2d0a6e0aa4a8141"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9d0faff28cff0290d76c2cda175bb8a79b293b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9d0faff28cff0290d76c2cda175bb8a79b293b", "html_url": "https://github.com/rust-lang/rust/commit/8e9d0faff28cff0290d76c2cda175bb8a79b293b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9d0faff28cff0290d76c2cda175bb8a79b293b/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9782b373b381906c57967b2854a3164de95ea88a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9782b373b381906c57967b2854a3164de95ea88a", "html_url": "https://github.com/rust-lang/rust/commit/9782b373b381906c57967b2854a3164de95ea88a"}], "stats": {"total": 264, "additions": 140, "deletions": 124}, "files": [{"sha": "51b2d0272a59713c89ae2b6db91e6d0af73f2f92", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -4,7 +4,6 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n-use super::error::UnsupportedInfo::*;\n use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n@@ -245,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => err!(Unsupported(UnterminatedCString(ptr.erase_tag()))),\n+            None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n@@ -447,7 +446,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            err!(Unsupported(ReadPointerAsBytes))\n+            err!(ReadPointerAsBytes)\n         }\n     }\n \n@@ -517,7 +516,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| err!(Unsupported(ReadUndefBytes(idx))))\n+        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "c4a3bbfc28b18b61b20d7fb0317dea98f8246b23", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -2,7 +2,47 @@\n \n #[macro_export]\n macro_rules! err {\n-    ($($tt:tt)*) => { Err($crate::mir::interpret::InterpError::$($tt)*.into()) };\n+    ($($tt:tt)*) => {\n+        Err($crate::mir::interpret::InterpError::Unsupported(\n+            $crate::mir::interpret::UnsupportedInfo::$($tt)*\n+        ).into())\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_inval {\n+    ($($tt:tt)*) => {\n+        Err($crate::mir::interpret::InterpError::InvalidProgram(\n+            $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n+        ).into())\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_ub {\n+    ($($tt:tt)*) => {\n+        Err($crate::mir::interpret::InterpError::UndefinedBehaviour(\n+            $crate::mir::interpret::UndefinedBehaviourInfo::$($tt)*\n+        ).into())\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_panic {\n+    ($($tt:tt)*) => {\n+        Err($crate::mir::interpret::InterpError::Panic(\n+            $crate::mir::interpret::PanicMessage::$($tt)*\n+        ).into())\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err_exhaust {\n+    ($($tt:tt)*) => {\n+        Err($crate::mir::interpret::InterpError::ResourceExhaustion(\n+            $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n+        ).into())\n+    };\n }\n \n mod error;"}, {"sha": "faca04412402e36da7ae9dbaadcf472a1b298bd0", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -1,13 +1,10 @@\n use std::fmt::{self, Display};\n \n-use super::error::UnsupportedInfo::*;\n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n \n-use super::{\n-    AllocId, InterpResult, PanicMessage\n-};\n+use super::{AllocId, InterpResult};\n \n /// Used by `check_in_alloc` to indicate context of check\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n@@ -77,13 +74,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     #[inline]\n     fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Panic(PanicMessage::Overflow(mir::BinOp::Add))) } else { Ok(res) }\n+        if over { err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Panic(PanicMessage::Overflow(mir::BinOp::Add))) } else { Ok(res) }\n+        if over { err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n }\n \n@@ -199,11 +196,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            err!(Unsupported(PointerOutOfBounds {\n-                ptr: self.erase_tag(),\n-                msg,\n-                allocation_size,\n-            }))\n+            err!(PointerOutOfBounds { ptr: self.erase_tag(),msg,allocation_size })\n         } else {\n             Ok(())\n         }"}, {"sha": "4a59d845b3b42eebf76cf722e7e642d200126f68", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -2,7 +2,6 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use super::error::UnsupportedInfo::*;\n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n@@ -361,7 +360,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => err!(Unsupported(ReadPointerAsBytes)),\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n     }\n \n@@ -374,8 +373,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => err!(Unsupported(InvalidNullPointerUsage)),\n-            Scalar::Raw { .. } => err!(Unsupported(ReadBytesAsPointer)),\n+            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -407,15 +406,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => err!(Unsupported(InvalidBool)),\n+            _ => err!(InvalidBool),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => err!(Unsupported(InvalidChar(val as u128))),\n+            None => err!(InvalidChar(val as u128)),\n         }\n     }\n \n@@ -538,7 +537,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => err!(Unsupported(ReadUndefBytes(Size::from_bytes(0)))),\n+            ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "bbee3b392345e37384f448a735194657bff94035", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -353,9 +353,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    err!(Unsupported(\n-                        MachineError(format!(\"calling non-const function `{}`\", instance))\n-                    ))\n+                    err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n                 };\n             }\n         }\n@@ -415,7 +413,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        err!(Unsupported(ReadForeignStatic))\n+        err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]"}, {"sha": "7157e714f05221d35e9b9f98179060496dbab3f4", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -9,7 +9,7 @@ use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n     Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n };\n-use rustc::mir::{CastKind, interpret::{UnsupportedInfo::*, InvalidProgramInfo::*}};\n+use rustc::mir::{CastKind, interpret::{InvalidProgramInfo::*}};\n \n \n use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n@@ -200,7 +200,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => err!(Unsupported(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty)))),\n+            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n "}, {"sha": "1ee6871f5efc71b4b3260477282f29fd6dc6a7b0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -17,8 +17,7 @@ use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n     InterpResult, InterpError,\n-    truncate, sign_extend, UnsupportedInfo::*, InvalidProgramInfo::*,\n-    ResourceExhaustionInfo::*, UndefinedBehaviourInfo::*,\n+    truncate, sign_extend, InvalidProgramInfo::*,\n };\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -136,7 +135,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => err!(Unsupported(DeadLocal)),\n+            LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -149,7 +148,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => err!(Unsupported(DeadLocal)),\n+            LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -303,7 +302,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 &substs,\n             )),\n             None => if substs.needs_subst() {\n-                err!(InvalidProgram(TooGeneric)).into()\n+                err_inval!(TooGeneric).into()\n             } else {\n                 Ok(substs)\n             },\n@@ -337,14 +336,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             && self.tcx.has_typeck_tables(did)\n             && self.tcx.typeck_tables_of(did).tainted_by_errors\n         {\n-            return err!(InvalidProgram(TypeckError));\n+            return err_inval!(TypeckError);\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(Unsupported(NoMirFor(self.tcx.def_path_str(def_id))))\n+                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -357,7 +356,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n-                err!(InvalidProgram(TooGeneric)).into()\n+                err_inval!(TooGeneric).into()\n             } else {\n                 Ok(t)\n             },\n@@ -374,7 +373,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let substituted = t.subst(*self.tcx, substs);\n \n         if substituted.needs_subst() {\n-            return err!(InvalidProgram(TooGeneric));\n+            return err_inval!(TooGeneric);\n         }\n \n         Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n@@ -573,7 +572,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n-            err!(ResourceExhaustion(StackFrameLimitReached))\n+            err_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n         }\n@@ -621,7 +620,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         } else {\n             // Uh, that shouldn't happen... the function did not intend to return\n-            return err!(UndefinedBehaviour(Unreachable));\n+            return err_ub!(Unreachable);\n         }\n         // Jump to new block -- *after* validation so that the spans make more sense.\n         match frame.return_to_block {"}, {"sha": "261cfbce171448d6dcd76e184c59db8c4c3d64be", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -328,9 +328,7 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return err!(Unsupported(ValidationFailure(\n-                \"encountered dangling pointer in final constant\".into(),\n-            )))\n+            return err!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         }\n     }\n     Ok(())"}, {"sha": "f943ff67c085891965b6c89a19c5f9433bb0199b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -104,9 +104,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return err!(\n-                            Unsupported(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n-                        );\n+                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -192,9 +190,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return err!(Unsupported(Intrinsic(\n+                    return err!(Intrinsic(\n                         format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n-                    )));\n+                    ));\n                 }\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "4f04803addd8b673c8b800d454cf0265f39ab73e", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        err!(Unsupported(ReadPointerAsBytes))\n+        err!(ReadPointerAsBytes)\n     }\n }"}, {"sha": "72feb73f751a477689777a774e320af35842b989", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -67,9 +67,9 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) => err!(Unsupported(MachineError(format!(\n+            FnVal::Other(_) => err!(MachineError(format!(\n                 \"Expected instance function pointer, got 'other' pointer\"\n-            )))),\n+            ))),\n         }\n     }\n }\n@@ -203,7 +203,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return err!(Unsupported(ReallocateNonBasePtr));\n+            return err!(ReallocateNonBasePtr);\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -244,41 +244,38 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return err!(Unsupported(DeallocateNonBasePtr));\n+            return err!(DeallocateNonBasePtr);\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err!(Unsupported(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n-                    ))),\n+                    )),\n                     Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => err!(Unsupported(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n-                    ))),\n-                    None => err!(Unsupported(DoubleFree))\n+                    )),\n+                    None => err!(DoubleFree)\n                 }\n             }\n         };\n \n         if alloc_kind != kind {\n-            return err!(Unsupported(DeallocatedWrongMemoryKind(\n+            return err!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n-            )));\n+            ));\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return err!(Unsupported(IncorrectAllocationInformation(size,\n-                                                           bytes,\n-                                                           align,\n-                                                           alloc.align)));\n+                return err!(IncorrectAllocationInformation(size, bytes, align, alloc.align));\n             }\n         }\n \n@@ -323,10 +320,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                err!(Unsupported(AlignmentCheckFailed {\n+                err!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n-                }))\n+                })\n             }\n         }\n \n@@ -345,7 +342,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return err!(Unsupported(InvalidNullPointerUsage));\n+                    return err!(InvalidNullPointerUsage);\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -366,10 +363,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return err!(Unsupported(AlignmentCheckFailed {\n+                    return err!(AlignmentCheckFailed {\n                         has: alloc_align,\n                         required: align,\n-                    }));\n+                    });\n                 }\n                 check_offset_align(ptr.offset.bytes(), align)?;\n \n@@ -417,9 +414,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return err!(Unsupported(DerefFunctionPointer)),\n+                return err!(DerefFunctionPointer),\n             None =>\n-                return err!(Unsupported(DanglingPointerDeref)),\n+                return err!(DanglingPointerDeref),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -507,11 +504,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return err!(Unsupported(ModifiedConstantMemory));\n+                return err!(ModifiedConstantMemory);\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => err!(Unsupported(ModifiedStatic)),\n+                None => err!(ModifiedStatic),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -521,7 +518,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return err!(Unsupported(ModifiedConstantMemory));\n+                    return err!(ModifiedConstantMemory);\n                 }\n                 Ok(a)\n             }\n@@ -604,7 +601,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return err!(Unsupported(InvalidFunctionPointer));\n+            return err!(InvalidFunctionPointer);\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -839,9 +836,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return err!(Unsupported(Intrinsic(\n+                        return err!(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n-                        )));\n+                        ));\n                     }\n                 }\n "}, {"sha": "1896c3cda13d6b981c8b8f0e0211b97d267e3e77", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n     InterpResult, InterpError,\n-    sign_extend, truncate, UnsupportedInfo::*, InvalidProgramInfo::*\n+    sign_extend, truncate, UnsupportedInfo::*,\n };\n use super::{\n     InterpCx, Machine,\n@@ -460,7 +460,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n                 PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    return err!(Unsupported(ReadFromReturnPointer)),\n+                    return err!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -533,7 +533,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match val.val {\n             ConstValue::Param(_) =>\n                 // FIXME(oli-obk): try to monomorphize\n-                return err!(InvalidProgram(TooGeneric)),\n+                return err_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n@@ -608,7 +608,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n                     Err(_) =>\n-                        return err!(Unsupported(InvalidDiscriminant(raw_discr.erase_tag()))),\n+                        return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -655,9 +655,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return err!(Unsupported(InvalidDiscriminant(\n-                                raw_discr.erase_tag().into()\n-                            )));\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "eecb752e72be293a6b3ebb2de4553b9a42d9c42e", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -2,9 +2,9 @@ use rustc::mir;\n use rustc::ty::{self, layout::TyLayout};\n use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n-use rustc::mir::interpret::{InterpResult, PanicMessage, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n \n-use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy, UnsupportedInfo::*};\n+use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return err!(Unsupported(Unimplemented(msg)));\n+            return err!(Unimplemented(msg));\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -173,8 +173,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Div if r == 0 => return err!(Panic(PanicMessage::DivisionByZero)),\n-                Rem if r == 0 => return err!(Panic(PanicMessage::RemainderByZero)),\n+                Div if r == 0 => return err_panic!(DivisionByZero),\n+                Rem if r == 0 => return err_panic!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -231,8 +231,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Div if r == 0 => return err!(Panic(PanicMessage::DivisionByZero)),\n-                    Rem if r == 0 => return err!(Panic(PanicMessage::RemainderByZero)),\n+                    Div if r == 0 => return err_panic!(DivisionByZero),\n+                    Rem if r == 0 => return err_panic!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return err!(Unsupported(Unimplemented(msg)));\n+                return err!(Unimplemented(msg));\n             }\n         };\n "}, {"sha": "75e3f70aebb31dcb90f6bd33fa47d312b4960ecd", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -13,9 +13,8 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n-    InterpCx, Machine, AllocMap, AllocationExtra, PanicMessage,\n+    InterpCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n-    UnsupportedInfo::*,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -357,7 +356,7 @@ where\n                     // This can be violated because this runs during promotion on code where the\n                     // type system has not yet ensured that such things don't happen.\n                     debug!(\"tried to access element {} of array/slice with length {}\", field, len);\n-                    return err!(Panic(PanicMessage::BoundsCheck { len, index: field }));\n+                    return err_panic!(BoundsCheck { len, index: field });\n                 }\n                 stride * field\n             }\n@@ -623,7 +622,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return err!(Unsupported(InvalidNullPointerUsage)),\n+                    None => return err!(InvalidNullPointerUsage),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "246c90ba48e3aa3661ca61a81dbaf4ea932a0a0a", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic, UnsupportedInfo};\n+use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n \n use super::{InterpCx, Machine};\n \n@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return err!(Unsupported(UnsupportedInfo::InlineAsm)),\n+            InlineAsm { .. } => return err!(InlineAsm),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "b7dbc8384586ec1fd7a14953adae9ad8db0dd044", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -9,7 +9,7 @@ use rustc_target::spec::abi::Abi;\n use super::{\n     InterpResult, PointerArithmetic, InterpError, Scalar,\n     InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n-    UndefinedBehaviourInfo, UnsupportedInfo::*,\n+    UnsupportedInfo::*,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -20,7 +20,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n-            err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable))\n+            err_ub!(Unreachable)\n         }\n     }\n \n@@ -90,7 +90,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return err!(Unsupported(Unimplemented(msg)));\n+                        return err!(Unimplemented(msg));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -145,20 +145,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let index = self.read_immediate(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            err!(Panic(BoundsCheck { len, index }))\n+                            err_panic!(BoundsCheck { len, index })\n                         }\n                         Overflow(op) =>\n-                            err!(Panic(Overflow(*op))),\n+                            err_panic!(Overflow(*op)),\n                         OverflowNeg =>\n-                            err!(Panic(OverflowNeg)),\n+                            err_panic!(OverflowNeg),\n                         DivisionByZero =>\n-                            err!(Panic(DivisionByZero)),\n+                            err_panic!(DivisionByZero),\n                         RemainderByZero =>\n-                            err!(Panic(RemainderByZero)),\n+                            err_panic!(RemainderByZero),\n                         GeneratorResumedAfterReturn =>\n-                            err!(Panic(GeneratorResumedAfterReturn)),\n+                            err_panic!(GeneratorResumedAfterReturn),\n                         GeneratorResumedAfterPanic =>\n-                            err!(Panic(GeneratorResumedAfterPanic)),\n+                            err_panic!(GeneratorResumedAfterPanic),\n                         Panic { .. } =>\n                             bug!(\"`Panic` variant cannot occur in MIR\"),\n                     };\n@@ -174,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n                                        `simplify_branches` mir pass\"),\n-            Unreachable => return err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable)),\n+            Unreachable => return err_ub!(Unreachable),\n         }\n \n         Ok(())\n@@ -227,9 +227,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return err!(\n-                Unsupported(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n-            );\n+            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -257,13 +255,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return err!(Unsupported(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic)));\n+                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n-                    None => return err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable))\n+                    None => return err_ub!(Unreachable)\n                 };\n                 M::call_intrinsic(self, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n@@ -298,7 +296,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return err!(Unsupported(FunctionAbiMismatch(caller_abi, callee_abi)));\n+                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n                     }\n                 }\n \n@@ -393,7 +391,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return err!(Unsupported(FunctionArgCountMismatch));\n+                        return err!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -405,15 +403,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return err!(Unsupported(\n+                            return err!(\n                                 FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n-                            ));\n+                            );\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return err!(Unsupported(FunctionRetMismatch(self.tcx.types.never, ty)));\n+                            return err!(FunctionRetMismatch(self.tcx.types.never, ty));\n                         }\n                     }\n                     Ok(())"}, {"sha": "ea8b88e51f0a0c00b4e99cd0c9a958579c1b60cd", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -22,10 +22,10 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(Unsupported(ValidationFailure(format!(\n+        err!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n-        ))))\n+        )))\n     }};\n     ($what:expr, $where:expr) => {{\n         let where_ = path_format(&$where);\n@@ -34,10 +34,10 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(Unsupported(ValidationFailure(format!(\n+        err!(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n-        ))))\n+        )))\n     }};\n }\n "}, {"sha": "9918356d355b84858937098c83c37a50fa347649", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d0faff28cff0290d76c2cda175bb8a79b293b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8e9d0faff28cff0290d76c2cda175bb8a79b293b", "patch": "@@ -448,7 +448,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n                             if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                return err!(Panic(PanicMessage::OverflowNeg));\n+                                return err_panic!(OverflowNeg);\n                             }\n                         }\n                         UnOp::Not => {"}]}