{"sha": "ba0072401c3b8b6c9391428672bd91055150c8ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMDA3MjQwMWMzYjhiNmM5MzkxNDI4NjcyYmQ5MTA1NTE1MGM4ZWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T12:46:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T12:46:01Z"}, "message": "use Completions to collect completions", "tree": {"sha": "aecfd8e5e2a55fad6b963b1b9f436cb902f910ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aecfd8e5e2a55fad6b963b1b9f436cb902f910ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba0072401c3b8b6c9391428672bd91055150c8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0072401c3b8b6c9391428672bd91055150c8ee", "html_url": "https://github.com/rust-lang/rust/commit/ba0072401c3b8b6c9391428672bd91055150c8ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba0072401c3b8b6c9391428672bd91055150c8ee/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "052e20162a026356c716116ac10ea795ca5dc28d", "url": "https://api.github.com/repos/rust-lang/rust/commits/052e20162a026356c716116ac10ea795ca5dc28d", "html_url": "https://github.com/rust-lang/rust/commit/052e20162a026356c716116ac10ea795ca5dc28d"}], "stats": {"total": 64, "additions": 38, "deletions": 26}, "files": [{"sha": "074033ad890090adeb56c701b60dbe7846a18a62", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=ba0072401c3b8b6c9391428672bd91055150c8ee", "patch": "@@ -15,7 +15,8 @@ use hir::source_binder;\n \n use crate::{\n     db,\n-    Cancelable, FilePosition\n+    Cancelable, FilePosition,\n+    completion::completion_item::Completions,\n };\n \n pub use crate::completion::completion_item::{CompletionItem, InsertText};\n@@ -33,34 +34,38 @@ pub(crate) fn completions(\n \n     let module = ctry!(source_binder::module_from_position(db, position)?);\n \n-    let mut res = Vec::new();\n+    let mut acc = Completions::default();\n     let mut has_completions = false;\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        reference_completion::completions(&mut res, db, &module, &file, name_ref)?;\n+        reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(&mut res, name_ref.syntax());\n+            param_completions(&mut acc, name_ref.syntax());\n         }\n     }\n \n     // Otherwise, if this is a declaration, use heuristics to suggest a name.\n     if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if is_node::<ast::Param>(name.syntax()) {\n             has_completions = true;\n-            param_completions(&mut res, name.syntax());\n+            param_completions(&mut acc, name.syntax());\n         }\n     }\n-    let res = if has_completions { Some(res) } else { None };\n+    let res = if has_completions {\n+        Some(acc.into())\n+    } else {\n+        None\n+    };\n     Ok(res)\n }\n \n /// Complete repeated parametes, both name and type. For example, if all\n /// functions in a file have a `spam: &mut Spam` parameter, a completion with\n /// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n /// suggested.\n-fn param_completions(acc: &mut Vec<CompletionItem>, ctx: SyntaxNodeRef) {\n+fn param_completions(acc: &mut Completions, ctx: SyntaxNodeRef) {\n     let mut params = FxHashMap::default();\n     for node in ctx.ancestors() {\n         let _ = visitor_ctx(&mut params)"}, {"sha": "8aa9da005a51c9ddef1164d654b273a369d40254", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=ba0072401c3b8b6c9391428672bd91055150c8ee", "patch": "@@ -53,8 +53,8 @@ pub(crate) struct Builder {\n }\n \n impl Builder {\n-    pub fn add_to(self, acc: &mut Vec<CompletionItem>) {\n-        acc.push(self.build())\n+    pub fn add_to(self, acc: &mut Completions) {\n+        acc.add(self.build())\n     }\n \n     pub fn build(self) -> CompletionItem {\n@@ -81,7 +81,7 @@ impl Into<CompletionItem> for Builder {\n }\n \n /// Represents an in-progress set of completions being built.\n-#[derive(Debug)]\n+#[derive(Debug, Default)]\n pub(crate) struct Completions {\n     buf: Vec<CompletionItem>,\n }\n@@ -90,6 +90,13 @@ impl Completions {\n     pub(crate) fn add(&mut self, item: impl Into<CompletionItem>) {\n         self.buf.push(item.into())\n     }\n+    pub(crate) fn add_all<I>(&mut self, items: I)\n+    where\n+        I: IntoIterator,\n+        I::Item: Into<CompletionItem>,\n+    {\n+        items.into_iter().for_each(|item| self.add(item.into()))\n+    }\n }\n \n impl Into<Vec<CompletionItem>> for Completions {"}, {"sha": "c578e9e8b937c7d6b94d188865a2adfa5c63b16a", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0072401c3b8b6c9391428672bd91055150c8ee/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=ba0072401c3b8b6c9391428672bd91055150c8ee", "patch": "@@ -13,12 +13,12 @@ use hir::{\n \n use crate::{\n     db::RootDatabase,\n-    completion::CompletionItem,\n+    completion::{CompletionItem, Completions},\n     Cancelable\n };\n \n pub(super) fn completions(\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n     db: &RootDatabase,\n     module: &hir::Module,\n     file: &SourceFileNode,\n@@ -117,7 +117,7 @@ fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n     None\n }\n \n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n+fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions) {\n     let mut shadowed = FxHashSet::default();\n     scopes\n         .scope_chain(name_ref.syntax())\n@@ -130,7 +130,7 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n }\n \n fn complete_path(\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n     db: &RootDatabase,\n     module: &hir::Module,\n     mut path: Path,\n@@ -154,7 +154,7 @@ fn complete_path(\n     Ok(())\n }\n \n-fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n+fn complete_mod_item_snippets(acc: &mut Completions) {\n     CompletionItem::new(\"Test function\")\n         .lookup_by(\"tfn\")\n         .snippet(\n@@ -174,26 +174,26 @@ fn complete_expr_keywords(\n     file: &SourceFileNode,\n     fn_def: ast::FnDef,\n     name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n+    acc: &mut Completions,\n ) {\n-    acc.push(keyword(\"if\", \"if $0 {}\"));\n-    acc.push(keyword(\"match\", \"match $0 {}\"));\n-    acc.push(keyword(\"while\", \"while $0 {}\"));\n-    acc.push(keyword(\"loop\", \"loop {$0}\"));\n+    acc.add(keyword(\"if\", \"if $0 {}\"));\n+    acc.add(keyword(\"match\", \"match $0 {}\"));\n+    acc.add(keyword(\"while\", \"while $0 {}\"));\n+    acc.add(keyword(\"loop\", \"loop {$0}\"));\n \n     if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n         if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n             if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.push(keyword(\"else\", \"else {$0}\"));\n-                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n+                acc.add(keyword(\"else\", \"else {$0}\"));\n+                acc.add(keyword(\"else if\", \"else if $0 {}\"));\n             }\n         }\n     }\n     if is_in_loop_body(name_ref) {\n-        acc.push(keyword(\"continue\", \"continue\"));\n-        acc.push(keyword(\"break\", \"break\"));\n+        acc.add(keyword(\"continue\", \"continue\"));\n+        acc.add(keyword(\"break\", \"break\"));\n     }\n-    acc.extend(complete_return(fn_def, name_ref));\n+    acc.add_all(complete_return(fn_def, name_ref));\n }\n \n fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n@@ -252,7 +252,7 @@ fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n     CompletionItem::new(kw).snippet(snippet).build()\n }\n \n-fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n+fn complete_expr_snippets(acc: &mut Completions) {\n     CompletionItem::new(\"pd\")\n         .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n         .add_to(acc);"}]}