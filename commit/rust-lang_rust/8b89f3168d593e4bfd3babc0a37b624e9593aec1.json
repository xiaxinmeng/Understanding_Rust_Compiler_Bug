{"sha": "8b89f3168d593e4bfd3babc0a37b624e9593aec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiODlmMzE2OGQ1OTNlNGJmZDNiYWJjMGEzN2I2MjRlOTU5M2FlYzE=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-17T18:45:30Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-17T18:49:55Z"}, "message": "code review fixes", "tree": {"sha": "db9509faba282bd2a740e60a2b6cd649630b7370", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db9509faba282bd2a740e60a2b6cd649630b7370"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b89f3168d593e4bfd3babc0a37b624e9593aec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b89f3168d593e4bfd3babc0a37b624e9593aec1", "html_url": "https://github.com/rust-lang/rust/commit/8b89f3168d593e4bfd3babc0a37b624e9593aec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b89f3168d593e4bfd3babc0a37b624e9593aec1/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1cee113c7ecc6eac0d9898d5e5870ad15f70f77", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1cee113c7ecc6eac0d9898d5e5870ad15f70f77", "html_url": "https://github.com/rust-lang/rust/commit/b1cee113c7ecc6eac0d9898d5e5870ad15f70f77"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "4a2b751f5e864f506568394f36018702e51fe081", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=8b89f3168d593e4bfd3babc0a37b624e9593aec1", "patch": "@@ -50,7 +50,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if let (Some(anon_reg_sup), Some(anon_reg_sub)) =\n                 (self.is_suitable_anonymous_region(sup, true),\n                  self.is_suitable_anonymous_region(sub, true)) {\n-                let ((def_id_sup, br_sup), (def_id_sub, br_sub)) = (anon_reg_sup, anon_reg_sub);\n+                let (def_id_sup, br_sup, def_id_sub, br_sub) = (anon_reg_sup.def_id,\n+                                                                anon_reg_sup.boundregion,\n+                                                                anon_reg_sub.def_id,\n+                                                                anon_reg_sub.boundregion);\n                 if let (Some(anonarg_sup), Some(anonarg_sub)) =\n                     (self.find_anon_type(sup, &br_sup), self.find_anon_type(sub, &br_sub)) {\n                     (anonarg_sup, anonarg_sub, def_id_sup, def_id_sub, br_sup, br_sub)\n@@ -124,7 +127,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// for e.g. `&u8` and Vec<`&u8`.\n     pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n         if let Some(anon_reg) = self.is_suitable_anonymous_region(region, true) {\n-            let (def_id, _) = anon_reg;\n+            let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let ret_ty = self.tcx.type_of(def_id);\n                 if let ty::TyFnDef(_, _) = ret_ty.sty {"}, {"sha": "7fa1eca553591a6b340c9566a3f6d74bc7af4ac5", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=8b89f3168d593e4bfd3babc0a37b624e9593aec1", "patch": "@@ -29,25 +29,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.\n-        let (named, anon_arg_info, (scope_def_id, _)) = if\n-            sub.is_named_region() && self.is_suitable_anonymous_region(sup, false).is_some() {\n-            (sub,\n-             self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-             self.is_suitable_anonymous_region(sup, false).unwrap())\n-        } else if\n-            sup.is_named_region() && self.is_suitable_anonymous_region(sub, false).is_some() {\n-            (sup,\n-             self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-             self.is_suitable_anonymous_region(sub, false).unwrap())\n-        } else {\n-            return false; // inapplicable\n-        };\n+        // with the named one.//scope_def_id\n+        let (named, anon_arg_info, region_info) =\n+            if sub.is_named_region() && self.is_suitable_anonymous_region(sup, false).is_some() {\n+                (sub,\n+                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+                 self.is_suitable_anonymous_region(sup, false).unwrap())\n+            } else if sup.is_named_region() &&\n+                      self.is_suitable_anonymous_region(sub, false).is_some() {\n+                (sup,\n+                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+                 self.is_suitable_anonymous_region(sub, false).unwrap())\n+            } else {\n+                return false; // inapplicable\n+            };\n \n-        let (arg, new_ty, br, is_first) = (anon_arg_info.arg,\n-                                           anon_arg_info.arg_ty,\n-                                           anon_arg_info.bound_region,\n-                                           anon_arg_info.is_first);\n+        let (arg, new_ty, br, is_first, scope_def_id) = (anon_arg_info.arg,\n+                                                         anon_arg_info.arg_ty,\n+                                                         anon_arg_info.bound_region,\n+                                                         anon_arg_info.is_first,\n+                                                         region_info.def_id);\n         if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n             return false;\n         } else {"}, {"sha": "84429fea86ec4de9ba397f79c0a7257ebc565347", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b89f3168d593e4bfd3babc0a37b624e9593aec1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=8b89f3168d593e4bfd3babc0a37b624e9593aec1", "patch": "@@ -30,6 +30,15 @@ pub struct AnonymousArgInfo<'tcx> {\n     pub is_first: bool,\n }\n \n+// This struct contains information regarding the\n+// Refree((FreeRegion) corresponding to lifetime conflict\n+pub struct FreeRegionInfo {\n+    // def id corresponding to FreeRegion\n+    pub def_id: DefId,\n+    // the bound region corresponding to FreeRegion\n+    pub boundregion: ty::BoundRegion,\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n@@ -102,7 +111,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_suitable_anonymous_region(&self,\n                                         region: Region<'tcx>,\n                                         is_anon_anon: bool)\n-                                        -> Option<(DefId, ty::BoundRegion)> {\n+                                        -> Option<FreeRegionInfo> {\n         if let ty::ReFree(ref free_region) = *region {\n             if let ty::BrAnon(..) = free_region.bound_region {\n                 let anonymous_region_binding_scope = free_region.scope;\n@@ -136,7 +145,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => return None, // inapplicable\n                     // we target only top-level functions\n                 }\n-                return Some((anonymous_region_binding_scope, free_region.bound_region));\n+                return Some(FreeRegionInfo {\n+                                def_id: anonymous_region_binding_scope,\n+                                boundregion: free_region.bound_region,\n+                            });\n             }\n         }\n         None"}]}