{"sha": "fc304384e6ed40f505fa0f04043044dd44e73118", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMzA0Mzg0ZTZlZDQwZjUwNWZhMGYwNDA0MzA0NGRkNDRlNzMxMTg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-19T22:46:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-24T17:24:38Z"}, "message": "Use a Vec instead of an HashMap for the scope hierarchy\n\nThis increases regionck performance greatly - type-checking on\nlibrustc decreased from 9.1s to 8.1s. Because of Amdahl's law,\ntotal performance is improved only by about 1.5% (LLVM wizards,\nthis is your opportunity to shine!).\n\nbefore:\n576.91user 4.26system 7:42.36elapsed 125%CPU (0avgtext+0avgdata 1142192maxresident)k\nafter:\n566.50user 4.84system 7:36.84elapsed 125%CPU (0avgtext+0avgdata 1124304maxresident)k\n\nI am somewhat worried really need to find out why we have this Red Queen's\nRace going on here. Originally I suspected it may be a problem from RFC1214's\nwarnings, but it seems to be an effect from other changes.\n\nHowever, the increase seems to be mostly in LLVM's time, so I guess\nit's the LLVM wizards' problem.", "tree": {"sha": "b595551863601a56187c8f7b87237ac10bca2915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b595551863601a56187c8f7b87237ac10bca2915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc304384e6ed40f505fa0f04043044dd44e73118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc304384e6ed40f505fa0f04043044dd44e73118", "html_url": "https://github.com/rust-lang/rust/commit/fc304384e6ed40f505fa0f04043044dd44e73118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc304384e6ed40f505fa0f04043044dd44e73118/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bcc6d8ec7f525328a1e8c8ce423ac3ac015eb6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bcc6d8ec7f525328a1e8c8ce423ac3ac015eb6d", "html_url": "https://github.com/rust-lang/rust/commit/2bcc6d8ec7f525328a1e8c8ce423ac3ac015eb6d"}], "stats": {"total": 1101, "additions": 561, "deletions": 540}, "files": [{"sha": "768e769efedc4e965970d5eb1b697aa9b5b7468d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -207,6 +207,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n+                // this is totally wrong, but nobody relevant cares about\n+                // this field - it will die soon(TM).\n                 let node_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), '|');\n                 let space = self.parse_param_space();\n@@ -246,24 +248,26 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     fn parse_scope(&mut self) -> region::CodeExtent {\n-        match self.next() {\n+        self.tcx.region_maps.bogus_code_extent(match self.next() {\n+            // the scopes created here are totally bogus with their\n+            // NodeIDs\n             'P' => {\n                 assert_eq!(self.next(), '[');\n                 let fn_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), '|');\n                 let body_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), ']');\n-                region::CodeExtent::ParameterScope {\n+                region::CodeExtentData::ParameterScope {\n                     fn_id: fn_id, body_id: body_id\n                 }\n             }\n             'M' => {\n                 let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtent::Misc(node_id)\n+                region::CodeExtentData::Misc(node_id)\n             }\n             'D' => {\n                 let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtent::DestructionScope(node_id)\n+                region::CodeExtentData::DestructionScope(node_id)\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n@@ -274,10 +278,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let block_remainder = region::BlockRemainder {\n                     block: node_id, first_statement_index: first_stmt_index,\n                 };\n-                region::CodeExtent::Remainder(block_remainder)\n+                region::CodeExtentData::Remainder(block_remainder)\n             }\n             _ => panic!(\"parse_scope: bad input\")\n-        }\n+        })\n     }\n \n     fn parse_destruction_scope_data(&mut self) -> region::DestructionScopeData {\n@@ -619,6 +623,33 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n+    pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+        let name = self.parse_name(':');\n+        let def_id = self.parse_def(NominalType);\n+        let space = self.parse_param_space();\n+        assert_eq!(self.next(), '|');\n+        let index = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let mut bounds = vec![];\n+        loop {\n+            match self.next() {\n+                'R' => bounds.push(self.parse_region()),\n+                '.' => { break; }\n+                c => {\n+                    panic!(\"parse_region_param_def: bad bounds ('{}')\", c)\n+                }\n+            }\n+        }\n+        ty::RegionParameterDef {\n+            name: name,\n+            def_id: def_id,\n+            space: space,\n+            index: index,\n+            bounds: bounds\n+        }\n+    }\n+\n+\n     fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n         match self.next() {\n             'a' => ty::ObjectLifetimeDefault::Ambiguous,"}, {"sha": "a17d27acc2a26614893928d6800b0cb83c6e103d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -278,14 +278,14 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_scope(w: &mut Encoder, _cx: &ctxt, scope: region::CodeExtent) {\n-    match scope {\n-        region::CodeExtent::ParameterScope {\n+fn enc_scope(w: &mut Encoder, cx: &ctxt, scope: region::CodeExtent) {\n+    match cx.tcx.region_maps.code_extent_data(scope) {\n+        region::CodeExtentData::ParameterScope {\n             fn_id, body_id } => mywrite!(w, \"P[{}|{}]\", fn_id, body_id),\n-        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n-        region::CodeExtent::Remainder(region::BlockRemainder {\n+        region::CodeExtentData::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+        region::CodeExtentData::Remainder(region::BlockRemainder {\n             block: b, first_statement_index: i }) => mywrite!(w, \"B[{}|{}]\", b, i),\n-        region::CodeExtent::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n+        region::CodeExtentData::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n     }\n }\n \n@@ -396,17 +396,6 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n-                            cx: &ctxt<'a, 'tcx>,\n-                            rs: &[ty::Region]) {\n-    for &r in rs {\n-        mywrite!(w, \"R\");\n-        enc_region(w, cx, r);\n-    }\n-\n-    mywrite!(w, \".\");\n-}\n-\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|{}|\",\n@@ -416,6 +405,18 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n+pub fn enc_region_param_def(w: &mut Encoder, cx: &ctxt,\n+                            v: &ty::RegionParameterDef) {\n+    mywrite!(w, \"{}:{}|{}|{}|\",\n+             v.name, (cx.ds)(v.def_id),\n+             v.space.to_uint(), v.index);\n+    for &r in &v.bounds {\n+        mywrite!(w, \"R\");\n+        enc_region(w, cx, r);\n+    }\n+    mywrite!(w, \".\");\n+}\n+\n fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n                                          default: ty::ObjectLifetimeDefault)"}, {"sha": "2edf2b896ba175273d8220af07c773d562a59eba", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 89, "deletions": 98, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -478,67 +478,6 @@ impl tr for def::Def {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding of ancillary information\n-\n-impl tr for ty::Region {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n-        match *self {\n-            ty::ReLateBound(debruijn, br) => {\n-                ty::ReLateBound(debruijn, br.tr(dcx))\n-            }\n-            ty::ReEarlyBound(data) => {\n-                ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    param_id: dcx.tr_id(data.param_id),\n-                    space: data.space,\n-                    index: data.index,\n-                    name: data.name,\n-                })\n-            }\n-            ty::ReScope(scope) => {\n-                ty::ReScope(scope.tr(dcx))\n-            }\n-            ty::ReEmpty | ty::ReStatic | ty::ReVar(..) | ty::ReSkolemized(..) => {\n-                *self\n-            }\n-            ty::ReFree(ref fr) => {\n-                ty::ReFree(fr.tr(dcx))\n-            }\n-        }\n-    }\n-}\n-\n-impl tr for ty::FreeRegion {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::FreeRegion {\n-        ty::FreeRegion { scope: self.scope.tr(dcx),\n-                         bound_region: self.bound_region.tr(dcx) }\n-    }\n-}\n-\n-impl tr for region::CodeExtent {\n-    fn tr(&self, dcx: &DecodeContext) -> region::CodeExtent {\n-        self.map_id(|id| dcx.tr_id(id))\n-    }\n-}\n-\n-impl tr for region::DestructionScopeData {\n-    fn tr(&self, dcx: &DecodeContext) -> region::DestructionScopeData {\n-        region::DestructionScopeData { node_id: dcx.tr_id(self.node_id) }\n-    }\n-}\n-\n-impl tr for ty::BoundRegion {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n-        match *self {\n-            ty::BrAnon(_) |\n-            ty::BrFresh(_) |\n-            ty::BrEnv => *self,\n-            ty::BrNamed(id, ident) => ty::BrNamed(dcx.tr_def_id(id),\n-                                                    ident),\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n@@ -574,24 +513,6 @@ impl tr for ty::Freevar {\n     }\n }\n \n-impl tr for ty::UpvarBorrow {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarBorrow {\n-        ty::UpvarBorrow {\n-            kind: self.kind,\n-            region: self.region.tr(dcx)\n-        }\n-    }\n-}\n-\n-impl tr for ty::UpvarCapture {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarCapture {\n-        match *self {\n-            ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n-            ty::UpvarCapture::ByRef(ref data) => ty::UpvarCapture::ByRef(data.tr(dcx)),\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -703,10 +624,13 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>);\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>);\n+    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n+                             region_param_def: &ty::RegionParameterDef);\n     fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -718,9 +642,11 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n+    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>);\n-    fn emit_autoref<'a>(&mut self, autoref: &ty::AutoRef<'tcx>);\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>);\n     fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n }\n@@ -734,6 +660,10 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n+        self.emit_opaque(|this| Ok(e::write_region(ecx, this, r)));\n+    }\n+\n     fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -755,7 +685,14 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                          type_param_def))\n         });\n     }\n-\n+    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n+                             region_param_def: &ty::RegionParameterDef) {\n+        self.emit_opaque(|this| {\n+            Ok(tyencode::enc_region_param_def(this,\n+                                              &ecx.ty_str_ctxt(),\n+                                              region_param_def))\n+        });\n+    }\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n@@ -781,7 +718,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_struct_field(\"regions\", 1, |this| {\n                         Ok(encode_vec_per_param_space(\n                             this, &type_scheme.generics.regions,\n-                            |this, def| def.encode(this).unwrap()))\n+                            |this, def| this.emit_region_param_def(ecx, def)))\n                     })\n                 })\n             });\n@@ -804,6 +741,26 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n+    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n+        use serialize::Encoder;\n+\n+        self.emit_enum(\"UpvarCapture\", |this| {\n+            match *capture {\n+                ty::UpvarCapture::ByValue => {\n+                    this.emit_enum_variant(\"ByValue\", 1, 0, |_| Ok(()))\n+                }\n+                ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, region }) => {\n+                    this.emit_enum_variant(\"ByRef\", 2, 0, |this| {\n+                        this.emit_enum_variant_arg(0,\n+                            |this| kind.encode(this));\n+                        this.emit_enum_variant_arg(1,\n+                            |this| Ok(this.emit_region(ecx, region)))\n+                    })\n+                }\n+            }\n+        }).unwrap()\n+    }\n+\n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this,\n@@ -837,14 +794,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref<'b>(&mut self, autoref: &ty::AutoRef<'tcx>) {\n+    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n                 &ty::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(0,\n+                            |this| Ok(this.emit_region(ecx, *r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -868,7 +827,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                 this.emit_option(|this| {\n                     match auto_deref_ref.autoref {\n                         None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(a))),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n                     }\n                 })\n             });\n@@ -983,7 +942,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                        .unwrap()\n                                        .clone();\n                 var_id.encode(rbml_w);\n-                upvar_capture.encode(rbml_w);\n+                rbml_w.emit_upvar_capture(ecx, &upvar_capture);\n             })\n         }\n     }\n@@ -1080,6 +1039,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                      f: F) -> R\n         where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n \n+    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1088,6 +1048,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n+    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n+                             -> ty::RegionParameterDef;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n     fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1096,6 +1058,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                        -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> subst::Substs<'tcx>;\n+    fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n+                          -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1180,13 +1144,14 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             str\n         }\n     }\n-\n-    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n+    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n-        // are not used during trans.\n-\n+        // are not used during trans. This also applies to read_ty.\n+        return self.read_ty_encoded(dcx, |decoder| decoder.parse_region());\n+    }\n+    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         return self.read_ty_encoded(dcx, |decoder| decoder.parse_ty());\n     }\n \n@@ -1209,7 +1174,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_type_param_def())\n     }\n-\n+    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n+                             -> ty::RegionParameterDef {\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_region_param_def())\n+    }\n     fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n@@ -1232,7 +1200,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                             regions:\n                             this.read_struct_field(\"regions\", 1, |this| {\n                                 Ok(this.read_vec_per_param_space(\n-                                    |this| Decodable::decode(this).unwrap()))\n+                                    |this| this.read_region_param_def(dcx)))\n                             }).unwrap(),\n                         })\n                     })\n@@ -1258,7 +1226,23 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                .parse_substs())\n         }).unwrap()\n     }\n-\n+    fn read_upvar_capture(&mut self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+        self.read_enum(\"UpvarCapture\", |this| {\n+            let variants = [\"ByValue\", \"ByRef\"];\n+            this.read_enum_variant(&variants, |this, i| {\n+                Ok(match i {\n+                    1 => ty::UpvarCapture::ByValue,\n+                    2 => ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: this.read_enum_variant_arg(0,\n+                                  |this| Decodable::decode(this)).unwrap(),\n+                        region: this.read_enum_variant_arg(1,\n+                                    |this| Ok(this.read_region(dcx))).unwrap()\n+                    }),\n+                    _ => panic!(\"bad enum variant for ty::UpvarCapture\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n@@ -1317,11 +1301,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                 Ok(match i {\n                     0 => {\n                         let r: ty::Region =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                            this.read_enum_variant_arg(0, |this| {\n+                                Ok(this.read_region(dcx))\n+                            }).unwrap();\n                         let m: ast::Mutability =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                            this.read_enum_variant_arg(1, |this| {\n+                                Decodable::decode(this)\n+                            }).unwrap();\n \n-                        ty::AutoPtr(dcx.tcx.mk_region(r.tr(dcx)), m)\n+                        ty::AutoPtr(dcx.tcx.mk_region(r), m)\n                     }\n                     1 => {\n                         let m: ast::Mutability =\n@@ -1376,6 +1364,9 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     /// case. We translate them with `tr_def_id()` which will map\n     /// the crate numbers back to the original source crate.\n     ///\n+    /// Scopes will end up as being totally bogus. This can actually\n+    /// be fixed through.\n+    ///\n     /// Unboxed closures are cloned along with the function being\n     /// inlined, and all side tables use interned node IDs, so we\n     /// translate their def IDs accordingly.\n@@ -1453,8 +1444,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n-                        let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub.tr(dcx));\n+                        let ub = val_dsr.read_upvar_capture(dcx);\n+                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);"}, {"sha": "91e35c0679bf2502eaf3b3d50dceafb62e4af043", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::graph;\n use middle::cfg::*;\n use middle::def;\n use middle::pat_util;\n-use middle::region::CodeExtent;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n@@ -585,11 +584,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData {exiting_scopes: vec!() };\n-        let mut scope = CodeExtent::from_node_id(from_expr.id);\n-        let target_scope = CodeExtent::from_node_id(to_loop.loop_id);\n+        let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n+        let target_scope = self.tcx.region_maps.node_extent(to_loop.loop_id);\n         while scope != target_scope {\n-\n-            data.exiting_scopes.push(scope.node_id());\n+            data.exiting_scopes.push(scope.node_id(&self.tcx.region_maps));\n             scope = self.tcx.region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);"}, {"sha": "ce03e10418d2e14b2887a22d772fda75488db6a1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -20,7 +20,7 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use middle::{def, region, pat_util};\n+use middle::{def, pat_util};\n use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n@@ -296,7 +296,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n-            let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n+            let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -579,7 +579,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n-        let call_scope = region::CodeExtent::from_node_id(call.id);\n+        let call_scope = self.tcx().region_maps.node_extent(call.id);\n         match callee_ty.sty {\n             ty::TyBareFn(..) => {\n                 self.consume_expr(callee);\n@@ -862,7 +862,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n+                let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n@@ -917,7 +917,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // methods are implicitly autoref'd which sadly does not use\n         // adjustments, so we must hardcode the borrow here.\n \n-        let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n         let bk = ty::ImmBorrow;\n \n         for &arg in &rhs {"}, {"sha": "4b81117f2e9a9ba007e77e5373e09782bf17d1fb", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -135,7 +135,8 @@ impl FreeRegionMap {\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n                 (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()) ||\n+                    tcx.region_maps.is_subscope_of(sub_scope,\n+                                                   fr.scope.to_code_extent(&tcx.region_maps)) ||\n                     self.is_static(fr),\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n@@ -177,4 +178,3 @@ fn lub() {\n     map.relate_free_regions(frs[1], frs[2]);\n     assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n }\n-"}, {"sha": "c7261b4a781c12b0ffe5bd04bb3d3aa9f221001c", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -121,11 +121,11 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.map) {\n+                let span = match scope.span(&self.region_maps, &self.map) {\n                     Some(s) => s,\n                     None => return self.sess.note(&unknown_scope())\n                 };\n-                let tag = match self.map.find(scope.node_id()) {\n+                let tag = match self.map.find(scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(_)) => \"block\",\n                     Some(ast_map::NodeExpr(expr)) => match expr.node {\n                         ast::ExprCall(..) => \"call\",\n@@ -142,16 +142,16 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         return self.sess.span_note(span, &unknown_scope());\n                     }\n                 };\n-                let scope_decorated_tag = match scope {\n-                    region::CodeExtent::Misc(_) => tag,\n-                    region::CodeExtent::ParameterScope { .. } => {\n+                let scope_decorated_tag = match self.region_maps.code_extent_data(scope) {\n+                    region::CodeExtentData::Misc(_) => tag,\n+                    region::CodeExtentData::ParameterScope { .. } => {\n                         \"scope of parameters for function\"\n                     }\n-                    region::CodeExtent::DestructionScope(_) => {\n+                    region::CodeExtentData::DestructionScope(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::CodeExtent::Remainder(r) => {\n+                    region::CodeExtentData::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n                                              r.first_statement_index);\n                         &new_string[..]"}, {"sha": "4a6c30853df468173418a9cf6fda34d9d7aff1cb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -790,7 +790,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            let fr_scope = fr.scope.to_code_extent();\n+            let fr_scope = fr.scope.to_code_extent(&self.tcx.region_maps);\n             let r_id = self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id);\n \n             if r_id == fr_scope {\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                let fr_scope = fr.scope.to_code_extent();\n+                let fr_scope = fr.scope.to_code_extent(&self.tcx.region_maps);\n                 if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope ||\n                         free_regions.is_static(fr) {\n                     Ok(s)\n@@ -927,8 +927,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n-                                      a.scope.to_code_extent(),\n-                                      b.scope.to_code_extent())\n+                                      a.scope.to_code_extent(&this.tcx.region_maps),\n+                                      b.scope.to_code_extent(&this.tcx.region_maps))\n             }\n         }\n     }"}, {"sha": "f4260dd700d65d0e56b9b89d75b34effc79d298d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 306, "deletions": 320, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -20,16 +20,27 @@ use ast_map;\n use metadata::inline::InlinedItem;\n use middle::ty::{self, Ty};\n use session::Session;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n+use std::mem;\n use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::stmt_id;\n-use syntax::ptr::P;\n use syntax::visit::{Visitor, FnKind};\n \n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+           RustcDecodable, Debug, Copy)]\n+pub struct CodeExtent(u32);\n+\n+/// The root of everything. I should be using NonZero or profiling\n+/// instead of this (probably).\n+pub const ROOT_CODE_EXTENT : CodeExtent = CodeExtent(0);\n+/// A placeholder used in trans to stand for real code extents\n+pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n+\n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n@@ -91,9 +102,8 @@ use syntax::visit::{Visitor, FnKind};\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Debug, Copy)]\n-pub enum CodeExtent {\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy)]\n+pub enum CodeExtentData {\n     Misc(ast::NodeId),\n \n     // extent of parameters passed to a function or closure (they\n@@ -118,8 +128,9 @@ impl DestructionScopeData {\n     pub fn new(node_id: ast::NodeId) -> DestructionScopeData {\n         DestructionScopeData { node_id: node_id }\n     }\n-    pub fn to_code_extent(&self) -> CodeExtent {\n-        CodeExtent::DestructionScope(self.node_id)\n+    pub fn to_code_extent(&self, region_maps: &RegionMaps) -> CodeExtent {\n+        region_maps.lookup_code_extent(\n+            CodeExtentData::DestructionScope(self.node_id))\n     }\n }\n \n@@ -134,9 +145,9 @@ impl DestructionScopeData {\n /// * the subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n+///   includes EXPR_1 as well, then do not use `CodeExtentData::Remainder`,\n ///   but instead another `CodeExtent` that encompasses the whole block,\n-///   e.g. `CodeExtent::Misc`.\n+///   e.g. `CodeExtentData::Misc`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -147,58 +158,41 @@ pub struct BlockRemainder {\n     pub first_statement_index: u32,\n }\n \n-impl CodeExtent {\n-    /// Creates a scope that represents the dynamic extent associated\n-    /// with `node_id`.\n-    pub fn from_node_id(node_id: ast::NodeId) -> CodeExtent {\n-        CodeExtent::Misc(node_id)\n-    }\n-\n+impl CodeExtentData {\n     /// Returns a node id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n-            CodeExtent::Misc(node_id) => node_id,\n+            CodeExtentData::Misc(node_id) => node_id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n-            CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(node_id) => node_id,\n-            CodeExtent::ParameterScope { fn_id: _, body_id } => body_id,\n+            CodeExtentData::Remainder(br) => br.block,\n+            CodeExtentData::DestructionScope(node_id) => node_id,\n+            CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n+}\n \n-    /// Maps this scope to a potentially new one according to the\n-    /// NodeId transformer `f_id`.\n-    pub fn map_id<F>(&self, mut f_id: F) -> CodeExtent where\n-        F: FnMut(ast::NodeId) -> ast::NodeId,\n-    {\n-        match *self {\n-            CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n-            CodeExtent::Remainder(br) =>\n-                CodeExtent::Remainder(BlockRemainder {\n-                    block: f_id(br.block), first_statement_index: br.first_statement_index }),\n-            CodeExtent::DestructionScope(node_id) =>\n-                CodeExtent::DestructionScope(f_id(node_id)),\n-            CodeExtent::ParameterScope { fn_id, body_id } =>\n-                CodeExtent::ParameterScope { fn_id: f_id(fn_id), body_id: f_id(body_id) },\n-        }\n+impl CodeExtent {\n+    pub fn node_id(&self, region_maps: &RegionMaps) -> ast::NodeId {\n+        region_maps.code_extent_data(*self).node_id()\n     }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, ast_map: &ast_map::Map) -> Option<Span> {\n-        match ast_map.find(self.node_id()) {\n+    pub fn span(&self, region_maps: &RegionMaps, ast_map: &ast_map::Map) -> Option<Span> {\n+        match ast_map.find(self.node_id(region_maps)) {\n             Some(ast_map::NodeBlock(ref blk)) => {\n-                match *self {\n-                    CodeExtent::ParameterScope { .. } |\n-                    CodeExtent::Misc(_) |\n-                    CodeExtent::DestructionScope(_) => Some(blk.span),\n+                match region_maps.code_extent_data(*self) {\n+                    CodeExtentData::ParameterScope { .. } |\n+                    CodeExtentData::Misc(_) |\n+                    CodeExtentData::DestructionScope(_) => Some(blk.span),\n \n-                    CodeExtent::Remainder(r) => {\n+                    CodeExtentData::Remainder(r) => {\n                         assert_eq!(r.block, blk.id);\n                         // Want span for extent starting after the\n                         // indexed statement and ending at end of\n@@ -222,13 +216,15 @@ impl CodeExtent {\n \n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n+    code_extents: RefCell<Vec<CodeExtentData>>,\n+    code_extent_interner: RefCell<FnvHashMap<CodeExtentData, CodeExtent>>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n+    scope_map: RefCell<Vec<CodeExtent>>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n@@ -242,26 +238,6 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n \n-    /// `terminating_scopes` is a set containing the ids of each\n-    /// statement, or conditional/repeating expression. These scopes\n-    /// are calling \"terminating scopes\" because, when attempting to\n-    /// find the scope of a temporary, by default we search up the\n-    /// enclosing scopes until we encounter the terminating scope. A\n-    /// conditional/repeating expression is one which is not\n-    /// guaranteed to execute exactly once upon entering the parent\n-    /// scope. This could be because the expression only executes\n-    /// conditionally, such as the expression `b` in `a && b`, or\n-    /// because the expression may execute many times, such as a loop\n-    /// body. The reason that we distinguish such expressions is that,\n-    /// upon exiting the parent scope, we cannot statically know how\n-    /// many times the expression executed, and thus if the expression\n-    /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore we ensure that\n-    /// the temporaries never outlast the conditional/repeating\n-    /// expression, preventing the need for dynamic checks and/or\n-    /// arbitrary amounts of stack space.\n-    terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n-\n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n     /// the block that is the fn body. This map points from the id of\n@@ -275,75 +251,6 @@ pub struct RegionMaps {\n     fn_tree: RefCell<NodeMap<ast::NodeId>>,\n }\n \n-/// Carries the node id for the innermost block or match expression,\n-/// for building up the `var_map` which maps ids to the blocks in\n-/// which they were declared.\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-enum InnermostDeclaringBlock {\n-    None,\n-    Block(ast::NodeId),\n-    Statement(DeclaringStatementContext),\n-    Match(ast::NodeId),\n-    FnDecl { fn_id: ast::NodeId, body_id: ast::NodeId },\n-}\n-\n-impl InnermostDeclaringBlock {\n-    fn to_code_extent(&self) -> Option<CodeExtent> {\n-        let extent = match *self {\n-            InnermostDeclaringBlock::None => {\n-                return Option::None;\n-            }\n-            InnermostDeclaringBlock::FnDecl { fn_id, body_id } =>\n-                CodeExtent::ParameterScope { fn_id: fn_id, body_id: body_id },\n-            InnermostDeclaringBlock::Block(id) |\n-            InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n-            InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n-        };\n-        Option::Some(extent)\n-    }\n-}\n-\n-/// Contextual information for declarations introduced by a statement\n-/// (i.e. `let`). It carries node-id's for statement and enclosing\n-/// block both, as well as the statement's index within the block.\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-struct DeclaringStatementContext {\n-    stmt_id: ast::NodeId,\n-    block_id: ast::NodeId,\n-    stmt_index: u32,\n-}\n-\n-impl DeclaringStatementContext {\n-    fn to_code_extent(&self) -> CodeExtent {\n-        CodeExtent::Remainder(BlockRemainder {\n-            block: self.block_id,\n-            first_statement_index: self.stmt_index,\n-        })\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-enum InnermostEnclosingExpr {\n-    None,\n-    Some(ast::NodeId),\n-    Statement(DeclaringStatementContext),\n-}\n-\n-impl InnermostEnclosingExpr {\n-    fn to_code_extent(&self) -> Option<CodeExtent> {\n-        let extent = match *self {\n-            InnermostEnclosingExpr::None => {\n-                return Option::None;\n-            }\n-            InnermostEnclosingExpr::Statement(s) =>\n-                s.to_code_extent(),\n-            InnermostEnclosingExpr::Some(parent_id) =>\n-                CodeExtent::from_node_id(parent_id),\n-        };\n-        Some(extent)\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// the root of the current region tree. This is typically the id\n@@ -355,10 +262,10 @@ pub struct Context {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: InnermostDeclaringBlock,\n+    var_parent: CodeExtent,\n \n     /// region parent of expressions etc\n-    parent: InnermostEnclosingExpr,\n+    parent: CodeExtent\n }\n \n struct RegionResolutionVisitor<'a> {\n@@ -367,14 +274,94 @@ struct RegionResolutionVisitor<'a> {\n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n-    cx: Context\n+    cx: Context,\n+\n+    /// `terminating_scopes` is a set containing the ids of each\n+    /// statement, or conditional/repeating expression. These scopes\n+    /// are calling \"terminating scopes\" because, when attempting to\n+    /// find the scope of a temporary, by default we search up the\n+    /// enclosing scopes until we encounter the terminating scope. A\n+    /// conditional/repeating expression is one which is not\n+    /// guaranteed to execute exactly once upon entering the parent\n+    /// scope. This could be because the expression only executes\n+    /// conditionally, such as the expression `b` in `a && b`, or\n+    /// because the expression may execute many times, such as a loop\n+    /// body. The reason that we distinguish such expressions is that,\n+    /// upon exiting the parent scope, we cannot statically know how\n+    /// many times the expression executed, and thus if the expression\n+    /// creates temporaries we cannot know statically how many such\n+    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// the temporaries never outlast the conditional/repeating\n+    /// expression, preventing the need for dynamic checks and/or\n+    /// arbitrary amounts of stack space. Terminating scopes end\n+    /// up being contained in a DestructionScope that contains the\n+    /// destructor's execution.\n+    terminating_scopes: NodeSet\n }\n \n \n impl RegionMaps {\n+    /// create a bogus code extent for the regions in astencode types. Nobody\n+    /// really cares about the contents of these.\n+    pub fn bogus_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n+        self.intern_code_extent(e, DUMMY_CODE_EXTENT)\n+    }\n+    pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n+        self.code_extent_interner.borrow()[&e]\n+    }\n+    pub fn intern_code_extent(&self,\n+                              e: CodeExtentData,\n+                              parent: CodeExtent) -> CodeExtent {\n+        match self.code_extent_interner.borrow_mut().entry(e) {\n+            Entry::Occupied(o) => {\n+                // this can happen when the bogus code extents from tydecode\n+                // have (bogus) NodeId-s that overlap items created during\n+                // inlining.\n+                // We probably shouldn't be creating bogus code extents\n+                // through.\n+                let idx = *o.get();\n+                if parent == DUMMY_CODE_EXTENT {\n+                    info!(\"CodeExtent({}) = {:?} [parent={}] BOGUS!\",\n+                          idx.0, e, parent.0);\n+                } else {\n+                    assert_eq!(self.scope_map.borrow()[idx.0 as usize],\n+                               DUMMY_CODE_EXTENT);\n+                    info!(\"CodeExtent({}) = {:?} [parent={}] RECLAIMED!\",\n+                          idx.0, e, parent.0);\n+                    self.scope_map.borrow_mut()[idx.0 as usize] = parent;\n+                }\n+                idx\n+            }\n+            Entry::Vacant(v) => {\n+                if self.code_extents.borrow().len() > 0xffffffffusize {\n+                    unreachable!() // should pass a sess,\n+                                   // but this isn't the only place\n+                }\n+                let idx = CodeExtent(self.code_extents.borrow().len() as u32);\n+                info!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n+                self.code_extents.borrow_mut().push(e);\n+                self.scope_map.borrow_mut().push(parent);\n+                *v.insert(idx)\n+            }\n+        }\n+    }\n+    pub fn intern_node(&self,\n+                       n: ast::NodeId,\n+                       parent: CodeExtent) -> CodeExtent {\n+        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n+    }\n+    pub fn node_extent(&self, n: ast::NodeId) -> CodeExtent {\n+        self.lookup_code_extent(CodeExtentData::Misc(n))\n+    }\n+    pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n+        self.code_extents.borrow()[e.0 as usize]\n+    }\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for (child, parent) in self.scope_map.borrow().iter() {\n-            e(child, parent)\n+        for child_id in (1..self.code_extents.borrow().len()) {\n+            let child = CodeExtent(child_id as u32);\n+            if let Some(parent) = self.opt_encl_scope(child) {\n+                e(&child, &parent)\n+            }\n         }\n     }\n     pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n@@ -387,12 +374,6 @@ impl RegionMaps {\n             e(child, parent)\n         }\n     }\n-    pub fn each_terminating_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent) {\n-        for scope in self.terminating_scopes.borrow().iter() {\n-            e(scope)\n-        }\n-    }\n-\n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n@@ -414,44 +395,30 @@ impl RegionMaps {\n         }\n     }\n \n-    pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n-        debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n-        assert!(sub != sup);\n-        self.scope_map.borrow_mut().insert(sub, sup);\n-    }\n-\n     fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.node_id(self));\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n     fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.node_id(self));\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n \n-    /// Records that a scope is a TERMINATING SCOPE. Whenever we create automatic temporaries --\n-    /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n-    /// scope.\n-    fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n-        debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n-        self.terminating_scopes.borrow_mut().insert(scope_id);\n-    }\n-\n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow().get(&id).cloned()\n+        match self.scope_map.borrow()[id.0 as usize] {\n+            ROOT_CODE_EXTENT => None,\n+            c => Some(c)\n+        }\n     }\n \n     #[allow(dead_code)] // used in middle::cfg\n     pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        match self.scope_map.borrow().get(&id) {\n-            Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {:?}\", id); }\n-        }\n+        self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n@@ -478,24 +445,28 @@ impl RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = match self.opt_encl_scope(CodeExtent::from_node_id(expr_id)) {\n+        // For some reason, the expr's scope itself is skipped here.\n+        let mut id = match self.opt_encl_scope(self.node_extent(expr_id)) {\n             Some(i) => i,\n             None => { return None; }\n         };\n \n-        while !self.terminating_scopes.borrow().contains(&id) {\n-            match self.opt_encl_scope(id) {\n-                Some(p) => {\n-                    id = p;\n-                }\n-                None => {\n-                    debug!(\"temporary_scope({:?}) = None\", expr_id);\n-                    return None;\n+        loop { match self.opt_encl_scope(id) {\n+            Some(p) => {\n+                match self.code_extent_data(p) {\n+                    CodeExtentData::DestructionScope(..) => {\n+                        debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n+                               expr_id, id);\n+                        return Some(id);\n+                    }\n+                    _ => id = p\n                 }\n             }\n-        }\n-        debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n-        return Some(id);\n+            None => {\n+                debug!(\"temporary_scope({:?}) = None\", expr_id);\n+                return None;\n+            }\n+        } }\n     }\n \n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n@@ -519,15 +490,15 @@ impl RegionMaps {\n                           superscope: CodeExtent)\n                           -> bool {\n         let mut s = subscope;\n+        debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);\n         while superscope != s {\n-            match self.scope_map.borrow().get(&s) {\n+            match self.opt_encl_scope(s) {\n                 None => {\n                     debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n-\n                     return false;\n                 }\n-                Some(&scope) => s = scope\n+                Some(scope) => s = scope\n             }\n         }\n \n@@ -545,8 +516,15 @@ impl RegionMaps {\n                                    -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n-        let a_ancestors = ancestors_of(self, scope_a);\n-        let b_ancestors = ancestors_of(self, scope_b);\n+        let mut a_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        let mut a_vec: Vec<CodeExtent> = vec![];\n+        let mut b_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        let mut b_vec: Vec<CodeExtent> = vec![];\n+        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n+        let a_ancestors = ancestors_of(scope_map,\n+                                       scope_a, &mut a_buf, &mut a_vec);\n+        let b_ancestors = ancestors_of(scope_map,\n+                                       scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n@@ -564,11 +542,11 @@ impl RegionMaps {\n             // nesting. The reasoning behind this is subtle.  See the\n             // \"Modeling closures\" section of the README in\n             // middle::infer::region_inference for more details.\n-            let a_root_scope = a_ancestors[a_index];\n-            let b_root_scope = a_ancestors[a_index];\n+            let a_root_scope = self.code_extent_data(a_ancestors[a_index]);\n+            let b_root_scope = self.code_extent_data(a_ancestors[a_index]);\n             return match (a_root_scope, b_root_scope) {\n-                (CodeExtent::DestructionScope(a_root_id),\n-                 CodeExtent::DestructionScope(b_root_id)) => {\n+                (CodeExtentData::DestructionScope(a_root_id),\n+                 CodeExtentData::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -599,69 +577,60 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of(this: &RegionMaps, scope: CodeExtent) -> Vec<CodeExtent> {\n+        fn ancestors_of<'a>(scope_map: &[CodeExtent],\n+                            scope: CodeExtent,\n+                            buf: &'a mut [CodeExtent; 32],\n+                            vec: &'a mut Vec<CodeExtent>) -> &'a [CodeExtent] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n-            let mut result = vec!(scope);\n             let mut scope = scope;\n+\n+            let mut i = 0;\n+            while i < 32 {\n+                buf[i] = scope;\n+                let superscope = scope_map[scope.0 as usize];\n+                if superscope == ROOT_CODE_EXTENT {\n+                    return &buf[..i+1];\n+                } else {\n+                    scope = superscope;\n+                }\n+                i += 1;\n+            }\n+\n+            *vec = Vec::with_capacity(64);\n+            vec.extend((*buf).into_iter());\n             loop {\n-                match this.scope_map.borrow().get(&scope) {\n-                    None => return result,\n-                    Some(&superscope) => {\n-                        result.push(superscope);\n-                        scope = superscope;\n-                    }\n+                vec.push(scope);\n+                let superscope = scope_map[scope.0 as usize];\n+                if superscope == ROOT_CODE_EXTENT {\n+                    return &*vec;\n+                } else {\n+                    scope = superscope;\n                 }\n-                // debug!(\"ancestors_of_loop(scope={:?})\", scope);\n             }\n         }\n     }\n }\n \n-/// Records the current parent (if any) as the parent of `child_scope`.\n-fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        child_scope: CodeExtent,\n-                        _sp: Span) {\n-    match visitor.cx.parent.to_code_extent() {\n-        Some(parent_scope) =>\n-            visitor.region_maps.record_encl_scope(child_scope, parent_scope),\n-        None => {}\n-    }\n-}\n-\n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match visitor.cx.var_parent.to_code_extent() {\n-        Some(parent_scope) =>\n-            visitor.region_maps.record_var_scope(var_id, parent_scope),\n-        None => {\n+    match visitor.cx.var_parent {\n+        ROOT_CODE_EXTENT => {\n             // this can happen in extern fn declarations like\n             //\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n+        parent_scope =>\n+            visitor.region_maps.record_var_scope(var_id, parent_scope),\n     }\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n-\n-    let blk_scope = CodeExtent::Misc(blk.id);\n-\n-    // If block was previously marked as a terminating scope during\n-    // the recursive visit of its parent node in the AST, then we need\n-    // to account for the destruction scope representing the extent of\n-    // the destructors that run immediately after the the block itself\n-    // completes.\n-    if visitor.region_maps.terminating_scopes.borrow().contains(&blk_scope) {\n-        let dtor_scope = CodeExtent::DestructionScope(blk.id);\n-        record_superlifetime(visitor, dtor_scope, blk.span);\n-        visitor.region_maps.record_encl_scope(blk_scope, dtor_scope);\n-    } else {\n-        record_superlifetime(visitor, blk_scope, blk.span);\n-    }\n+    let block_extent = visitor.new_node_extent_with_dtor(blk.id);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -690,35 +659,34 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n \n     visitor.cx = Context {\n         root_id: prev_cx.root_id,\n-        var_parent: InnermostDeclaringBlock::Block(blk.id),\n-        parent: InnermostEnclosingExpr::Some(blk.id),\n+        var_parent: block_extent,\n+        parent: block_extent,\n     };\n \n     {\n         // This block should be kept approximately in sync with\n         // `visit::walk_block`. (We manually walk the block, rather\n         // than call `walk_block`, in order to maintain precise\n-        // `InnermostDeclaringBlock` information.)\n+        // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let ast::StmtDecl(_, stmt_id) = statement.node {\n+            if let ast::StmtDecl(..) = statement.node {\n                 // Each StmtDecl introduces a subscope for bindings\n                 // introduced by the declaration; this subscope covers\n                 // a suffix of the block . Each subscope in a block\n                 // has the previous subscope in the block as a parent,\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n-                let declaring = DeclaringStatementContext {\n-                    stmt_id: stmt_id,\n-                    block_id: blk.id,\n-                    stmt_index: i as u32,\n-                };\n-                record_superlifetime(\n-                    visitor, declaring.to_code_extent(), statement.span);\n+                let stmt_extent = visitor.new_code_extent(\n+                    CodeExtentData::Remainder(BlockRemainder {\n+                        block: blk.id,\n+                        first_statement_index: i as u32\n+                    })\n+                );\n                 visitor.cx = Context {\n                     root_id: prev_cx.root_id,\n-                    var_parent: InnermostDeclaringBlock::Statement(declaring),\n-                    parent: InnermostEnclosingExpr::Statement(declaring),\n+                    var_parent: stmt_extent,\n+                    parent: stmt_extent,\n                 };\n             }\n             visitor.visit_stmt(&**statement)\n@@ -730,22 +698,17 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n }\n \n fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n-    let arm_body_scope = CodeExtent::from_node_id(arm.body.id);\n-    visitor.region_maps.mark_as_terminating_scope(arm_body_scope);\n+    visitor.terminating_scopes.insert(arm.body.id);\n \n-    match arm.guard {\n-        Some(ref expr) => {\n-            let guard_scope = CodeExtent::from_node_id(expr.id);\n-            visitor.region_maps.mark_as_terminating_scope(guard_scope);\n-        }\n-        None => { }\n+    if let Some(ref expr) = arm.guard {\n+        visitor.terminating_scopes.insert(expr.id);\n     }\n \n     visit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n-    record_superlifetime(visitor, CodeExtent::from_node_id(pat.id), pat.span);\n+    visitor.new_node_extent(pat.id);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n@@ -763,53 +726,31 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n-    let stmt_scope = CodeExtent::from_node_id(stmt_id);\n-\n     // Every statement will clean up the temporaries created during\n     // execution of that statement. Therefore each statement has an\n     // associated destruction scope that represents the extent of the\n     // statement plus its destructors, and thus the extent for which\n     // regions referenced by the destructors need to survive.\n-    visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    let dtor_scope = CodeExtent::DestructionScope(stmt_id);\n-    visitor.region_maps.record_encl_scope(stmt_scope, dtor_scope);\n-    record_superlifetime(visitor, dtor_scope, stmt.span);\n+    visitor.terminating_scopes.insert(stmt_id);\n+    let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n+    visitor.cx.parent = stmt_extent;\n     visit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    let expr_scope = CodeExtent::Misc(expr.id);\n-    // If expr was previously marked as a terminating scope during the\n-    // recursive visit of its parent node in the AST, then we need to\n-    // account for the destruction scope representing the extent of\n-    // the destructors that run immediately after the the expression\n-    // itself completes.\n-    if visitor.region_maps.terminating_scopes.borrow().contains(&expr_scope) {\n-        let dtor_scope = CodeExtent::DestructionScope(expr.id);\n-        record_superlifetime(visitor, dtor_scope, expr.span);\n-        visitor.region_maps.record_encl_scope(expr_scope, dtor_scope);\n-    } else {\n-        record_superlifetime(visitor, expr_scope, expr.span);\n-    }\n-\n+    let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n+    visitor.cx.parent = expr_extent;\n \n     {\n-        let region_maps = &mut visitor.region_maps;\n-        let terminating = |e: &P<ast::Expr>| {\n-            let scope = CodeExtent::from_node_id(e.id);\n-            region_maps.mark_as_terminating_scope(scope)\n-        };\n-        let terminating_block = |b: &P<ast::Block>| {\n-            let scope = CodeExtent::from_node_id(b.id);\n-            region_maps.mark_as_terminating_scope(scope)\n+        let terminating_scopes = &mut visitor.terminating_scopes;\n+        let mut terminating = |id: ast::NodeId| {\n+            terminating_scopes.insert(id);\n         };\n         match expr.node {\n             // Conditional or repeating scopes are always terminating\n@@ -820,30 +761,30 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r);\n+                terminating(r.id);\n             }\n \n             ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n-                terminating_block(then);\n-                terminating(otherwise);\n+                terminating(then.id);\n+                terminating(otherwise.id);\n             }\n \n             ast::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr);\n-                terminating_block(then);\n+                terminating(expr.id);\n+                terminating(then.id);\n             }\n \n             ast::ExprLoop(ref body, _) => {\n-                terminating_block(body);\n+                terminating(body.id);\n             }\n \n             ast::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr);\n-                terminating_block(body);\n+                terminating(expr.id);\n+                terminating(body.id);\n             }\n \n             ast::ExprMatch(..) => {\n-                visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n+                visitor.cx.var_parent = expr_extent;\n             }\n \n             ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -883,10 +824,8 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    let blk_scope = visitor.cx.var_parent.to_code_extent()\n-        .unwrap_or_else(|| visitor.sess.span_bug(\n-            local.span, \"local without enclosing block\"));\n-\n+    let blk_scope = visitor.cx.var_parent;\n+    assert!(blk_scope != ROOT_CODE_EXTENT); // locals must be within a block\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -1109,13 +1048,16 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n+    let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n     visitor.cx = Context {\n         root_id: None,\n-        var_parent: InnermostDeclaringBlock::None,\n-        parent: InnermostEnclosingExpr::None\n+        var_parent: ROOT_CODE_EXTENT,\n+        parent: ROOT_CODE_EXTENT\n     };\n     visit::walk_item(visitor, item);\n+    visitor.create_item_scope_if_needed(item.id);\n     visitor.cx = prev_cx;\n+    visitor.terminating_scopes = prev_ts;\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n@@ -1133,51 +1075,76 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n            body.id,\n            visitor.cx.parent);\n \n-    // This scope covers the function body, which includes the\n-    // bindings introduced by let statements as well as temporaries\n-    // created by the fn's tail expression (if any). It does *not*\n-    // include the fn parameters (see below).\n-    let body_scope = CodeExtent::from_node_id(body.id);\n-    visitor.region_maps.mark_as_terminating_scope(body_scope);\n-\n-    let dtor_scope = CodeExtent::DestructionScope(body.id);\n-    visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n-\n-    let fn_decl_scope = CodeExtent::ParameterScope { fn_id: id, body_id: body.id };\n-    visitor.region_maps.record_encl_scope(dtor_scope, fn_decl_scope);\n-\n-    record_superlifetime(visitor, fn_decl_scope, body.span);\n+    let fn_decl_scope = visitor.new_code_extent(\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n \n     if let Some(root_id) = visitor.cx.root_id {\n         visitor.region_maps.record_fn_parent(body.id, root_id);\n     }\n \n     let outer_cx = visitor.cx;\n+    let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n+    visitor.terminating_scopes.insert(body.id);\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n         root_id: Some(body.id),\n-        parent: InnermostEnclosingExpr::None,\n-        var_parent: InnermostDeclaringBlock::FnDecl {\n-            fn_id: id, body_id: body.id\n-        },\n+        parent: ROOT_CODE_EXTENT,\n+        var_parent: fn_decl_scope,\n     };\n+\n     visit::walk_fn_decl(visitor, decl);\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n         root_id: Some(body.id),\n-        parent: InnermostEnclosingExpr::None,\n-        var_parent: InnermostDeclaringBlock::None\n+        parent: fn_decl_scope,\n+        var_parent: fn_decl_scope\n     };\n     visitor.visit_block(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n+    visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n+impl<'a> RegionResolutionVisitor<'a> {\n+    /// Records the current parent (if any) as the parent of `child_scope`.\n+    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n+        self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n+    }\n \n+    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent {\n+        self.new_code_extent(CodeExtentData::Misc(child_scope))\n+    }\n+\n+    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent {\n+        // If node was previously marked as a terminating scope during the\n+        // recursive visit of its parent node in the AST, then we need to\n+        // account for the destruction scope representing the extent of\n+        // the destructors that run immediately after it completes.\n+        if self.terminating_scopes.contains(&id) {\n+            let ds = self.new_code_extent(\n+                CodeExtentData::DestructionScope(id));\n+            self.region_maps.intern_node(id, ds)\n+        } else {\n+            self.new_node_extent(id)\n+        }\n+    }\n+\n+    fn create_item_scope_if_needed(&mut self, id: ast::NodeId) {\n+        // create a region for the destruction scope - this is needed\n+        // for constructing parameter environments based on the item.\n+        // functions put their destruction scopes *inside* their parameter\n+        // scopes.\n+        let scope = CodeExtentData::DestructionScope(id);\n+        if !self.region_maps.code_extent_interner.borrow().contains_key(&scope) {\n+            self.region_maps.intern_code_extent(scope, ROOT_CODE_EXTENT);\n+        }\n+    }\n+}\n+\n+impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     fn visit_block(&mut self, b: &Block) {\n         resolve_block(self, b);\n     }\n@@ -1186,6 +1153,16 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n         resolve_item(self, i);\n     }\n \n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        visit::walk_impl_item(self, ii);\n+        self.create_item_scope_if_needed(ii.id);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        visit::walk_trait_item(self, ti);\n+        self.create_item_scope_if_needed(ti.id);\n+    }\n+\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n                 b: &'v Block, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n@@ -1209,21 +1186,29 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n \n pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n-        scope_map: RefCell::new(FnvHashMap()),\n+        code_extents: RefCell::new(vec![]),\n+        code_extent_interner: RefCell::new(FnvHashMap()),\n+        scope_map: RefCell::new(vec![]),\n         var_map: RefCell::new(NodeMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),\n-        terminating_scopes: RefCell::new(FnvHashSet()),\n         fn_tree: RefCell::new(NodeMap()),\n     };\n+    let root_extent = maps.bogus_code_extent(\n+        CodeExtentData::DestructionScope(ast::DUMMY_NODE_ID));\n+    assert_eq!(root_extent, ROOT_CODE_EXTENT);\n+    let bogus_extent = maps.bogus_code_extent(\n+        CodeExtentData::Misc(ast::DUMMY_NODE_ID));\n+    assert_eq!(bogus_extent, DUMMY_CODE_EXTENT);\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n             cx: Context {\n                 root_id: None,\n-                parent: InnermostEnclosingExpr::None,\n-                var_parent: InnermostDeclaringBlock::None,\n-            }\n+                parent: ROOT_CODE_EXTENT,\n+                var_parent: ROOT_CODE_EXTENT\n+            },\n+            terminating_scopes: NodeSet()\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -1238,9 +1223,10 @@ pub fn resolve_inlined_item(sess: &Session,\n         region_maps: region_maps,\n         cx: Context {\n             root_id: None,\n-            parent: InnermostEnclosingExpr::None,\n-            var_parent: InnermostDeclaringBlock::None\n-        }\n+            parent: ROOT_CODE_EXTENT,\n+            var_parent: ROOT_CODE_EXTENT\n+        },\n+        terminating_scopes: NodeSet()\n     };\n     item.visit(&mut visitor);\n }"}, {"sha": "a18bff5591dd19bc132f412a68436f1b22cb7e64", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -1503,7 +1503,7 @@ pub struct DebruijnIndex {\n }\n \n /// Representation of regions:\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1609,7 +1609,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(PartialEq, Clone, Debug, Copy)]\n pub enum UpvarCapture {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -1620,7 +1620,7 @@ pub enum UpvarCapture {\n     ByRef(UpvarBorrow),\n }\n \n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(PartialEq, Clone, Copy)]\n pub struct UpvarBorrow {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -2271,7 +2271,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub object_lifetime_default: ObjectLifetimeDefault,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: DefId,\n@@ -6673,7 +6673,8 @@ impl<'tcx> ctxt<'tcx> {\n         let unnormalized_env = ty::ParameterEnvironment {\n             tcx: self,\n             free_substs: free_substs,\n-            implicit_region_bound: ty::ReScope(free_id_outlive.to_code_extent()),\n+            implicit_region_bound: ty::ReScope(\n+                free_id_outlive.to_code_extent(&self.region_maps)),\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n             free_id: free_id,"}, {"sha": "3e3ce5c7be00211889e58d3b818f8bd4a7226b8e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n             None => { }\n         }\n \n-        self.check_for_conflicting_loans(region::CodeExtent::from_node_id(borrow_id));\n+        self.check_for_conflicting_loans(borrow_id);\n     }\n \n     fn mutate(&mut self,\n@@ -230,16 +230,16 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+    pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Iterates over each loan that has been issued\n-        //! on entrance to `scope`, regardless of whether it is\n+        //! on entrance to `node`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        self.dfcx_loans.each_bit_on_entry(scope.node_id(), |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry(node, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n         })\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! currently in scope.\n \n         let tcx = self.tcx();\n-        self.each_issued_loan(scope, |loan| {\n+        self.each_issued_loan(scope.node_id(&tcx.region_maps), |loan| {\n             if tcx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -336,33 +336,33 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<usize> {\n+    pub fn loans_generated_by(&self, node: ast::NodeId) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n-        //! we enter `scope`.\n+        //! we enter `node`.\n \n         let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit(scope.node_id(), |loan_index| {\n+        self.dfcx_loans.each_gen_bit(node, |loan_index| {\n             result.push(loan_index);\n             true\n         });\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, scope: region::CodeExtent) {\n+    pub fn check_for_conflicting_loans(&self, node: ast::NodeId) {\n         //! Checks to see whether any of the loans that are issued\n-        //! on entrance to `scope` conflict with loans that have already been\n-        //! issued when we enter `scope` (for example, we do not\n+        //! on entrance to `node` conflict with loans that have already been\n+        //! issued when we enter `node` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n         //!\n         //! (Note that some loans can be *issued* without necessarily\n         //! taking effect yet.)\n \n-        debug!(\"check_for_conflicting_loans(scope={:?})\", scope);\n+        debug!(\"check_for_conflicting_loans(node={:?})\", node);\n \n-        let new_loan_indices = self.loans_generated_by(scope);\n+        let new_loan_indices = self.loans_generated_by(node);\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n-        self.each_issued_loan(scope, |issued_loan| {\n+        self.each_issued_loan(node, |issued_loan| {\n             for &new_loan_index in &new_loan_indices {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n@@ -557,7 +557,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 old_loan.span,\n                 &format!(\"{}; {}\", borrow_summary, rule_summary));\n \n-            let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n+            let old_loan_span = self.tcx().map.span(\n+                old_loan.kill_scope.node_id(&self.tcx().region_maps));\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n \n@@ -673,7 +674,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            region::CodeExtent::from_node_id(expr_id), use_path, |loan| {\n+            self.tcx().region_maps.node_extent(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -787,7 +788,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = region::CodeExtent::from_node_id(assignment_id);\n+            let scope = self.tcx().region_maps.node_extent(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false"}, {"sha": "c3801f436e5823e98b30df905ef76273e17e81d6", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -44,7 +44,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::from_node_id(body.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -360,7 +360,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope.to_code_extent(),\n+                    ty::ReFree(ref fr) => {\n+                        fr.scope.to_code_extent(&self.tcx().region_maps)\n+                    }\n \n                     ty::ReStatic => {\n                         // If we get here, an error must have been\n@@ -387,7 +389,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = region::CodeExtent::from_node_id(borrow_id);\n+                let borrow_scope = self.tcx().region_maps.node_extent(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n "}, {"sha": "9a684021fcdd33d8d261ed1497cbf3cbf2448827", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -191,6 +191,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n+    let tcx = this.tcx;\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n@@ -204,8 +205,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n-        loan_dfcx.add_kill(KillFrom::ScopeEnd, loan.kill_scope.node_id(), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.node_id(&tcx.region_maps), loan_idx);\n+        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n+                           loan.kill_scope.node_id(&tcx.region_maps), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);\n@@ -414,7 +416,7 @@ impl<'tcx> LoanPath<'tcx> {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n-                region::CodeExtent::from_node_id(block_id)\n+                tcx.region_maps.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n@@ -1135,7 +1137,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n fn statement_scope_span(tcx: &ty::ctxt, region: ty::Region) -> Option<Span> {\n     match region {\n         ty::ReScope(scope) => {\n-            match tcx.map.find(scope.node_id()) {\n+            match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n                 Some(ast_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }"}, {"sha": "a389095df791181ad0760304a57f01936ca05117", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -494,7 +494,7 @@ impl<'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(),\n+                    self.kill_moves(path, kill_scope.node_id(&tcx.region_maps),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -509,7 +509,7 @@ impl<'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(tcx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(),\n+                                         kill_scope.node_id(&tcx.region_maps),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {"}, {"sha": "dcc92efc2a2ca03a52efdb50aa8a5e6adc381b05", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -18,6 +18,7 @@ use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n use rustc_typeck::middle::free_region::FreeRegionMap;\n use rustc_typeck::middle::region::{self, CodeExtent, DestructionScopeData};\n+use rustc_typeck::middle::region::CodeExtentData;\n use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n@@ -153,24 +154,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&self, rh: &RH) {\n+    pub fn create_region_hierarchy(&self, rh: &RH, parent: CodeExtent) {\n+        let me = self.infcx.tcx.region_maps.intern_node(rh.id, parent);\n         for child_rh in rh.sub {\n-            self.create_region_hierarchy(child_rh);\n-            self.infcx.tcx.region_maps.record_encl_scope(\n-                CodeExtent::from_node_id(child_rh.id),\n-                CodeExtent::from_node_id(rh.id));\n+            self.create_region_hierarchy(child_rh, me);\n         }\n     }\n \n     pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n+        let dscope = self.infcx.tcx.region_maps.intern_code_extent(\n+            CodeExtentData::DestructionScope(1), region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(\n             &RH {id: 1,\n                  sub: &[RH {id: 10,\n                             sub: &[]},\n                         RH {id: 11,\n-                            sub: &[]}]});\n+                            sub: &[]}]},\n+            dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -321,7 +323,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::from_node_id(id));\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n                                    self.tcx().types.isize)\n     }\n@@ -462,7 +464,8 @@ fn sub_free_bound_false() {\n     //! does NOT hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -478,8 +481,9 @@ fn sub_bound_free_true() {\n     //! DOES hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n@@ -512,9 +516,10 @@ fn lub_free_bound_infer() {\n     //! anyhow.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -535,8 +540,9 @@ fn lub_bound_bound() {\n #[test]\n fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -568,8 +574,9 @@ fn lub_bound_bound_inverse_order() {\n #[test]\n fn lub_free_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        let t_rptr_free2 = env.t_rptr_free(0, 2);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free2 = env.t_rptr_free(1, 2);\n         let t_rptr_static = env.t_rptr_static();\n         env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -594,9 +601,10 @@ fn lub_returning_scope() {\n #[test]\n fn glb_free_free_with_common_scope() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        let t_rptr_free2 = env.t_rptr_free(0, 2);\n-        let t_rptr_scope = env.t_rptr_scope(0);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_scope = env.t_rptr_scope(1);\n         env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n@@ -617,8 +625,9 @@ fn glb_bound_bound() {\n #[test]\n fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -738,10 +747,11 @@ fn escaping() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n+        env.create_simple_region_hierarchy();\n \n         assert!(!env.t_nil().has_escaping_regions());\n \n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));"}, {"sha": "ecfbaf57903060885e8382816355a3f0b12b6ce7", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -253,18 +253,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n+        let region_maps = &self.ccx.tcx().region_maps;\n         if top_scope.is_some() {\n-            assert!((self.ccx\n-                     .tcx()\n-                     .region_maps\n-                     .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n-                     .map(|s|s.node_id()) == top_scope)\n+            assert!((region_maps\n+                     .opt_encl_scope(region_maps.node_extent(debug_loc.id))\n+                     .map(|s|s.node_id(region_maps)) == top_scope)\n                     ||\n-                    (self.ccx\n-                     .tcx()\n-                     .region_maps\n-                     .opt_encl_scope(region::CodeExtent::DestructionScope(debug_loc.id))\n-                     .map(|s|s.node_id()) == top_scope));\n+                    (region_maps\n+                     .opt_encl_scope(region_maps.lookup_code_extent(\n+                         region::CodeExtentData::DestructionScope(debug_loc.id)))\n+                     .map(|s|s.node_id(region_maps)) == top_scope));\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n@@ -1111,7 +1109,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n-            let r = AstScope(scope.node_id());\n+            let r = AstScope(scope.node_id(&tcx.region_maps));\n             debug!(\"temporary_scope({}) = {:?}\", id, r);\n             r\n         }\n@@ -1125,7 +1123,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n-    let r = AstScope(tcx.region_maps.var_scope(id).node_id());\n+    let r = AstScope(tcx.region_maps.var_scope(id).node_id(&tcx.region_maps));\n     debug!(\"var_scope({}) = {:?}\", id, r);\n     r\n }"}, {"sha": "847cbfdbec6237d8aed4a0be8c441c3c46528412", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc304384e6ed40f505fa0f04043044dd44e73118/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fc304384e6ed40f505fa0f04043044dd44e73118", "patch": "@@ -294,7 +294,9 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let old_body_id = self.set_body_id(body.id);\n         self.relate_free_regions(&fn_sig[..], body.id, span);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[..]);\n+        link_fn_args(self,\n+                     self.tcx().region_maps.node_extent(body.id),\n+                     &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n \n@@ -564,17 +566,15 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n     let expr_ty = rcx.resolve_node_type(expr.id);\n-\n+    // the region corresponding to this expression\n+    let expr_region = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                      expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                      expr_ty, expr_region);\n \n     let method_call = MethodCall::expr(expr.id);\n     let opt_method_callee = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n     let has_method_map = opt_method_callee.is_some();\n \n-    // the region corresponding to this expression\n-    let expr_region = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-\n     // If we are calling a method (either explicitly or via an\n     // overloaded operator), check that all of the types provided as\n     // arguments for its type parameters are well-formed, and all the regions\n@@ -609,7 +609,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     // FIXME(#6268) remove to support nested method calls\n                     type_of_node_must_outlive(\n                         rcx, infer::AutoBorrow(expr.span),\n-                        expr.id, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                        expr.id, expr_region);\n                 }\n             }\n             /*\n@@ -726,7 +726,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 type_must_outlive(rcx,\n                                   infer::Operand(expr.span),\n                                   ty,\n-                                  ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                                  expr_region);\n             }\n             visit::walk_expr(rcx, expr);\n         }\n@@ -756,7 +756,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             };\n             if let ty::TyRef(r_ptr, _) = base_ty.sty {\n                 mk_subregion_due_to_dereference(\n-                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), *r_ptr);\n+                    rcx, expr.span, expr_region, *r_ptr);\n             }\n \n             visit::walk_expr(rcx, expr);\n@@ -789,8 +789,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            type_must_outlive(rcx, infer::AddrOf(expr.span),\n-                              ty0, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+            type_must_outlive(rcx, infer::AddrOf(expr.span), ty0, expr_region);\n             visit::walk_expr(rcx, expr);\n         }\n \n@@ -919,7 +918,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     // call occurs.\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n-    let callee_scope = CodeExtent::from_node_id(call_expr.id);\n+    let callee_scope = rcx.tcx().region_maps.node_extent(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n     debug!(\"callee_region={:?}\", callee_region);\n@@ -966,7 +965,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            derefs,\n            derefd_ty);\n \n-    let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n+    let s_deref_expr = rcx.tcx().region_maps.node_extent(deref_expr.id);\n+    let r_deref_expr = ty::ReScope(s_deref_expr);\n     for i in 0..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n@@ -1083,7 +1083,7 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n-    let r_index_expr = ty::ReScope(CodeExtent::from_node_id(index_expr.id));\n+    let r_index_expr = ty::ReScope(rcx.tcx().region_maps.node_extent(index_expr.id));\n     if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n             ty::TySlice(_) | ty::TyStr => {\n@@ -1234,7 +1234,7 @@ fn link_autoref(rcx: &Rcx,\n         }\n \n         ty::AutoUnsafe(m) => {\n-            let r = ty::ReScope(CodeExtent::from_node_id(expr.id));\n+            let r = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n             link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n     }"}]}