{"sha": "06968954f7e11454d49377629bb57d13253384b9", "node_id": "C_kwDOAAsO6NoAKDA2OTY4OTU0ZjdlMTE0NTRkNDkzNzc2MjliYjU3ZDEzMjUzMzg0Yjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T04:04:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T04:04:46Z"}, "message": "Auto merge of #100845 - timvermeulen:iter_compare, r=scottmcm\n\nUse internal iteration in `Iterator` comparison methods\n\nUpdates the `Iterator` methods `cmp_by`, `partial_cmp_by`, and `eq_by` to use internal iteration on `self`. I've also extracted their shared logic into a private helper function `iter_compare`, which will either short-circuit once the comparison result is known or return the comparison of the lengths of the iterators.\n\nThis change also indirectly benefits calls to `cmp`, `partial_cmp`, `eq`, `lt`, `le`, `gt`, and `ge`.\n\nUnsurprising benchmark results: iterators that benefit from internal iteration (like `Chain`) see a speedup, while other iterators are unaffected.\n```\n name                           before ns/iter  after ns/iter  diff ns/iter   diff %  speedup\n iter::bench_chain_partial_cmp  208,301         54,978             -153,323  -73.61%   x 3.79\n iter::bench_partial_cmp        55,527          55,702                  175    0.32%   x 1.00\n iter::bench_lt                 55,502          55,322                 -180   -0.32%   x 1.00\n```", "tree": {"sha": "561ae3d588c1da030fcd8fe616daf988a9e01893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/561ae3d588c1da030fcd8fe616daf988a9e01893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06968954f7e11454d49377629bb57d13253384b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06968954f7e11454d49377629bb57d13253384b9", "html_url": "https://github.com/rust-lang/rust/commit/06968954f7e11454d49377629bb57d13253384b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06968954f7e11454d49377629bb57d13253384b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c28e0c857280ce829beab16ef6082cd518db98", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c28e0c857280ce829beab16ef6082cd518db98", "html_url": "https://github.com/rust-lang/rust/commit/e1c28e0c857280ce829beab16ef6082cd518db98"}, {"sha": "db2b4a3a7e4f75699d767311bf8b49a7c2946892", "url": "https://api.github.com/repos/rust-lang/rust/commits/db2b4a3a7e4f75699d767311bf8b49a7c2946892", "html_url": "https://github.com/rust-lang/rust/commit/db2b4a3a7e4f75699d767311bf8b49a7c2946892"}], "stats": {"total": 150, "additions": 88, "deletions": 62}, "files": [{"sha": "4b40485d207c8c6a9cccc13ac905a86575a26afa", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06968954f7e11454d49377629bb57d13253384b9/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06968954f7e11454d49377629bb57d13253384b9/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=06968954f7e11454d49377629bb57d13253384b9", "patch": "@@ -363,6 +363,13 @@ fn bench_partial_cmp(b: &mut Bencher) {\n     b.iter(|| (0..100000).map(black_box).partial_cmp((0..100000).map(black_box)))\n }\n \n+#[bench]\n+fn bench_chain_partial_cmp(b: &mut Bencher) {\n+    b.iter(|| {\n+        (0..50000).chain(50000..100000).map(black_box).partial_cmp((0..100000).map(black_box))\n+    })\n+}\n+\n #[bench]\n fn bench_lt(b: &mut Bencher) {\n     b.iter(|| (0..100000).map(black_box).lt((0..100000).map(black_box)))"}, {"sha": "45be7bdd8dba562b3bec457a865771a727bdeb2f", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 81, "deletions": 62, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/06968954f7e11454d49377629bb57d13253384b9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06968954f7e11454d49377629bb57d13253384b9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=06968954f7e11454d49377629bb57d13253384b9", "patch": "@@ -3461,36 +3461,27 @@ pub trait Iterator {\n     /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n     /// ```\n     #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n-    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n+    fn cmp_by<I, F>(self, other: I, cmp: F) -> Ordering\n     where\n         Self: Sized,\n         I: IntoIterator,\n         F: FnMut(Self::Item, I::Item) -> Ordering,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => {\n-                    if other.next().is_none() {\n-                        return Ordering::Equal;\n-                    } else {\n-                        return Ordering::Less;\n-                    }\n-                }\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return Ordering::Greater,\n-                Some(val) => val,\n-            };\n-\n-            match cmp(x, y) {\n-                Ordering::Equal => (),\n-                non_eq => return non_eq,\n+        #[inline]\n+        fn compare<X, Y, F>(mut cmp: F) -> impl FnMut(X, Y) -> ControlFlow<Ordering>\n+        where\n+            F: FnMut(X, Y) -> Ordering,\n+        {\n+            move |x, y| match cmp(x, y) {\n+                Ordering::Equal => ControlFlow::CONTINUE,\n+                non_eq => ControlFlow::Break(non_eq),\n             }\n         }\n+\n+        match iter_compare(self, other.into_iter(), compare(cmp)) {\n+            ControlFlow::Continue(ord) => ord,\n+            ControlFlow::Break(ord) => ord,\n+        }\n     }\n \n     /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those\n@@ -3546,36 +3537,27 @@ pub trait Iterator {\n     /// );\n     /// ```\n     #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n-    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n+    fn partial_cmp_by<I, F>(self, other: I, partial_cmp: F) -> Option<Ordering>\n     where\n         Self: Sized,\n         I: IntoIterator,\n         F: FnMut(Self::Item, I::Item) -> Option<Ordering>,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => {\n-                    if other.next().is_none() {\n-                        return Some(Ordering::Equal);\n-                    } else {\n-                        return Some(Ordering::Less);\n-                    }\n-                }\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return Some(Ordering::Greater),\n-                Some(val) => val,\n-            };\n-\n-            match partial_cmp(x, y) {\n-                Some(Ordering::Equal) => (),\n-                non_eq => return non_eq,\n+        #[inline]\n+        fn compare<X, Y, F>(mut partial_cmp: F) -> impl FnMut(X, Y) -> ControlFlow<Option<Ordering>>\n+        where\n+            F: FnMut(X, Y) -> Option<Ordering>,\n+        {\n+            move |x, y| match partial_cmp(x, y) {\n+                Some(Ordering::Equal) => ControlFlow::CONTINUE,\n+                non_eq => ControlFlow::Break(non_eq),\n             }\n         }\n+\n+        match iter_compare(self, other.into_iter(), compare(partial_cmp)) {\n+            ControlFlow::Continue(ord) => Some(ord),\n+            ControlFlow::Break(ord) => ord,\n+        }\n     }\n \n     /// Determines if the elements of this [`Iterator`] are equal to those of\n@@ -3613,29 +3595,26 @@ pub trait Iterator {\n     /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n     /// ```\n     #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n-    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n+    fn eq_by<I, F>(self, other: I, eq: F) -> bool\n     where\n         Self: Sized,\n         I: IntoIterator,\n         F: FnMut(Self::Item, I::Item) -> bool,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_none(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return false,\n-                Some(val) => val,\n-            };\n-\n-            if !eq(x, y) {\n-                return false;\n+        #[inline]\n+        fn compare<X, Y, F>(mut eq: F) -> impl FnMut(X, Y) -> ControlFlow<()>\n+        where\n+            F: FnMut(X, Y) -> bool,\n+        {\n+            move |x, y| {\n+                if eq(x, y) { ControlFlow::CONTINUE } else { ControlFlow::BREAK }\n             }\n         }\n+\n+        match iter_compare(self, other.into_iter(), compare(eq)) {\n+            ControlFlow::Continue(ord) => ord == Ordering::Equal,\n+            ControlFlow::Break(()) => false,\n+        }\n     }\n \n     /// Determines if the elements of this [`Iterator`] are unequal to those of\n@@ -3860,6 +3839,46 @@ pub trait Iterator {\n     }\n }\n \n+/// Compares two iterators element-wise using the given function.\n+///\n+/// If `ControlFlow::CONTINUE` is returned from the function, the comparison moves on to the next\n+/// elements of both iterators. Returning `ControlFlow::Break(x)` short-circuits the iteration and\n+/// returns `ControlFlow::Break(x)`. If one of the iterators runs out of elements,\n+/// `ControlFlow::Continue(ord)` is returned where `ord` is the result of comparing the lengths of\n+/// the iterators.\n+///\n+/// Isolates the logic shared by ['cmp_by'](Iterator::cmp_by),\n+/// ['partial_cmp_by'](Iterator::partial_cmp_by), and ['eq_by'](Iterator::eq_by).\n+#[inline]\n+fn iter_compare<A, B, F, T>(mut a: A, mut b: B, f: F) -> ControlFlow<T, Ordering>\n+where\n+    A: Iterator,\n+    B: Iterator,\n+    F: FnMut(A::Item, B::Item) -> ControlFlow<T>,\n+{\n+    #[inline]\n+    fn compare<'a, B, X, T>(\n+        b: &'a mut B,\n+        mut f: impl FnMut(X, B::Item) -> ControlFlow<T> + 'a,\n+    ) -> impl FnMut(X) -> ControlFlow<ControlFlow<T, Ordering>> + 'a\n+    where\n+        B: Iterator,\n+    {\n+        move |x| match b.next() {\n+            None => ControlFlow::Break(ControlFlow::Continue(Ordering::Greater)),\n+            Some(y) => f(x, y).map_break(ControlFlow::Break),\n+        }\n+    }\n+\n+    match a.try_for_each(compare(&mut b, f)) {\n+        ControlFlow::Continue(()) => ControlFlow::Continue(match b.next() {\n+            None => Ordering::Equal,\n+            Some(_) => Ordering::Less,\n+        }),\n+        ControlFlow::Break(x) => x,\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator + ?Sized> Iterator for &mut I {\n     type Item = I::Item;"}]}