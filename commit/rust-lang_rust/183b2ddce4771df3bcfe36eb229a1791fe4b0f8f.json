{"sha": "183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4M2IyZGRjZTQ3NzFkZjNiY2ZlMzZlYjIyOWExNzkxZmU0YjBmOGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-14T17:10:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-30T21:02:52Z"}, "message": "Ignore entire test modules on emscripten instead of individual tests", "tree": {"sha": "eb9c8b8990972cbc42a4ca74399cbbad81415f23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb9c8b8990972cbc42a4ca74399cbbad81415f23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "html_url": "https://github.com/rust-lang/rust/commit/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37abec06e502b147b9ebc730030efe10bf235765", "url": "https://api.github.com/repos/rust-lang/rust/commits/37abec06e502b147b9ebc730030efe10bf235765", "html_url": "https://github.com/rust-lang/rust/commit/37abec06e502b147b9ebc730030efe10bf235765"}], "stats": {"total": 142, "additions": 10, "deletions": 132}, "files": [{"sha": "a77d83a23ce73d12fbba3510eac555a7face9e11", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -519,7 +519,7 @@ impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use net::*;\n     use net::test::{tsa, sa6, sa4};"}, {"sha": "ba2cd70e0d7776a77f0b553b2006eeb95c38d850", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -669,7 +669,7 @@ impl From<[u8; 16]> for Ipv6Addr {\n }\n \n // Tests for this module\n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use net::*;\n     use net::Ipv6MulticastScope::*;"}, {"sha": "7dd0e30df0368cf5abd3b3dd42facc610096ddf2", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -31,7 +31,8 @@ mod addr;\n mod tcp;\n mod udp;\n mod parser;\n-#[cfg(test)] mod test;\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod test;\n \n /// Possible values which can be passed to the [`shutdown`] method of\n /// [`TcpStream`]."}, {"sha": "0e7c5b06713fb31a58d3977a85f7f4f1aa5e27ac", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -428,7 +428,7 @@ impl fmt::Debug for TcpListener {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use io::ErrorKind;\n     use io::prelude::*;\n@@ -454,7 +454,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bind_error() {\n         match TcpListener::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n@@ -464,7 +463,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n@@ -477,7 +475,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn listen_localhost() {\n         let socket_addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&socket_addr));\n@@ -495,7 +492,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_loopback() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -517,7 +513,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_test() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -538,7 +533,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn read_eof() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -558,7 +552,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn write_close() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -585,7 +578,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_serial() {\n         each_ip(&mut |addr| {\n             let max = 10;\n@@ -608,7 +600,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_interleaved_greedy_schedule() {\n         const MAX: usize = 10;\n         each_ip(&mut |addr| {\n@@ -644,7 +635,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_interleaved_lazy_schedule() {\n         const MAX: usize = 10;\n         each_ip(&mut |addr| {\n@@ -678,7 +668,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_and_peer_name() {\n         each_ip(&mut |addr| {\n             let listener = t!(TcpListener::bind(&addr));\n@@ -694,7 +683,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn partial_read() {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n@@ -716,7 +704,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn double_bind() {\n         each_ip(&mut |addr| {\n             let _listener = t!(TcpListener::bind(&addr));\n@@ -733,7 +720,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn fast_rebind() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -749,7 +735,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_smoke() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -781,7 +766,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_two_read() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -816,7 +800,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_two_write() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -844,7 +827,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -865,7 +847,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn close_readwrite_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -904,7 +885,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn close_read_wakes_up() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -932,7 +912,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_while_reading() {\n         each_ip(&mut |addr| {\n             let accept = t!(TcpListener::bind(&addr));\n@@ -973,7 +952,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_accept_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -992,7 +970,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_accept_concurrent() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -1021,7 +998,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn debug() {\n         let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n         let socket_addr = next_test_ip4();\n@@ -1048,7 +1024,6 @@ mod tests {\n     //        no longer has rounding errors.\n     #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn timeouts() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1075,7 +1050,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1092,7 +1066,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_with_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1115,7 +1088,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn nodelay() {\n         let addr = next_test_ip4();\n         let _listener = t!(TcpListener::bind(&addr));\n@@ -1130,7 +1102,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn ttl() {\n         let ttl = 100;\n \n@@ -1147,7 +1118,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_nonblocking() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));"}, {"sha": "c03ac496adbb27b6f9c4ecef20e412a7f833764e", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -353,7 +353,7 @@ impl fmt::Debug for UdpSocket {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use io::ErrorKind;\n     use net::*;\n@@ -378,7 +378,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bind_error() {\n         match UdpSocket::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n@@ -389,7 +388,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_smoke_test_ip4() {\n         each_ip(&mut |server_ip, client_ip| {\n             let (tx1, rx1) = channel();\n@@ -414,7 +412,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_name_ip4() {\n         each_ip(&mut |addr, _| {\n             let server = t!(UdpSocket::bind(&addr));\n@@ -423,7 +420,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_smoke() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -453,7 +449,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_two_read() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -486,7 +481,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_two_write() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -525,7 +519,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn debug() {\n         let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n         let socket_addr = next_test_ip4();\n@@ -541,7 +534,6 @@ mod tests {\n     //        no longer has rounding errors.\n     #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn timeouts() {\n         let addr = next_test_ip4();\n \n@@ -566,7 +558,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_timeout() {\n         let addr = next_test_ip4();\n \n@@ -582,7 +573,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_with_timeout() {\n         let addr = next_test_ip4();\n \n@@ -602,7 +592,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_send_recv() {\n         let addr = next_test_ip4();\n \n@@ -617,7 +606,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn ttl() {\n         let ttl = 100;\n \n@@ -630,7 +618,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_nonblocking() {\n         let addr = next_test_ip4();\n "}, {"sha": "94348155779814c9ae71099d3a22aafadc05b2bf", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -807,7 +807,7 @@ pub fn exit(code: i32) -> ! {\n     ::sys::os::exit(code)\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use io::prelude::*;\n \n@@ -819,7 +819,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke() {\n         let p = Command::new(\"true\").spawn();\n         assert!(p.is_ok());\n@@ -838,7 +837,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn exit_reported_right() {\n         let p = Command::new(\"false\").spawn();\n         assert!(p.is_ok());\n@@ -850,7 +848,6 @@ mod tests {\n     #[test]\n     #[cfg(unix)]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn signal_reported_right() {\n         use os::unix::process::ExitStatusExt;\n \n@@ -879,7 +876,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(Stdio::piped());\n@@ -888,7 +884,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_current_dir_works() {\n         let mut cmd = Command::new(\"/bin/sh\");\n         cmd.arg(\"-c\").arg(\"pwd\")\n@@ -899,7 +894,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"read line; echo $line\")\n@@ -918,7 +912,6 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     #[cfg(unix)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn uid_works() {\n         use os::unix::prelude::*;\n         use libc;\n@@ -945,7 +938,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_status() {\n         let mut status = Command::new(\"false\").status().unwrap();\n         assert!(status.code() == Some(1));\n@@ -955,7 +947,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind(), ErrorKind::NotFound),\n@@ -965,7 +956,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_output() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n@@ -978,7 +968,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_error() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n@@ -990,15 +979,13 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_finish_once() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().code() == Some(1));\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_finish_twice() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().code() == Some(1));\n@@ -1007,7 +994,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_wait_with_output_once() {\n         let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n             .spawn().unwrap();\n@@ -1038,7 +1024,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_inherit_env() {\n         use env;\n \n@@ -1064,7 +1049,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_override_env() {\n         use env;\n \n@@ -1085,7 +1069,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_add_to_env() {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();"}, {"sha": "d9c14ef2f771eb83a81cdb8ea9130704449d66d9", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -1268,7 +1268,7 @@ impl error::Error for TryRecvError {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use env;\n     use super::*;\n@@ -1314,7 +1314,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1347,7 +1346,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1357,7 +1355,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n@@ -1384,7 +1381,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1395,7 +1391,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n@@ -1408,7 +1403,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_shared() {\n         const AMT: u32 = 10000;\n         const NTHREADS: u32 = 8;\n@@ -1435,7 +1429,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -1456,7 +1449,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n@@ -1471,7 +1463,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -1510,7 +1501,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n@@ -1580,7 +1570,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n@@ -1591,7 +1580,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n@@ -1604,7 +1592,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1616,7 +1603,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1630,7 +1616,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1649,7 +1634,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<Box<isize>>();\n@@ -1661,7 +1645,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n@@ -1700,7 +1683,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -1742,7 +1724,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -1781,7 +1762,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -1800,7 +1780,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n@@ -1817,7 +1796,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_nested_recv_iter() {\n         let (tx, rx) = channel::<i32>();\n         let (total_tx, total_rx) = channel::<i32>();\n@@ -1838,7 +1816,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_iter_break() {\n         let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n@@ -1864,7 +1841,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_try_iter() {\n         let (request_tx, request_rx) = channel();\n         let (response_tx, response_rx) = channel();\n@@ -1919,7 +1895,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn try_recv_states() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n@@ -1946,7 +1921,6 @@ mod tests {\n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n@@ -1968,7 +1942,7 @@ mod tests {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod sync_tests {\n     use env;\n     use thread;\n@@ -2014,7 +1988,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -2040,7 +2013,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -2050,7 +2022,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n@@ -2077,7 +2048,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n@@ -2088,7 +2058,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n@@ -2100,7 +2069,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2124,7 +2092,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;\n@@ -2163,7 +2130,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;\n@@ -2214,7 +2180,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n@@ -2299,7 +2264,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n@@ -2310,7 +2274,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n@@ -2323,7 +2286,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2335,7 +2297,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2349,7 +2310,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2368,7 +2328,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n@@ -2380,7 +2339,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n@@ -2417,7 +2375,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n@@ -2434,7 +2391,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_nested_recv_iter() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (total_tx, total_rx) = sync_channel::<i32>(0);\n@@ -2455,7 +2411,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_iter_break() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n@@ -2481,7 +2436,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn try_recv_states() {\n         let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n@@ -2508,7 +2462,6 @@ mod sync_tests {\n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n@@ -2530,23 +2483,20 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send1() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send3() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n@@ -2555,7 +2505,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send4() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n@@ -2596,7 +2545,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn issue_15761() {\n         fn repro() {\n             let (tx1, rx1) = sync_channel::<()>(3);"}, {"sha": "91896e1ab85dca7ccadbfb4f3d980949a4330ec5", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183b2ddce4771df3bcfe36eb229a1791fe4b0f8f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=183b2ddce4771df3bcfe36eb229a1791fe4b0f8f", "patch": "@@ -366,7 +366,7 @@ impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n #[allow(unused_imports)]\n mod tests {\n     use thread;\n@@ -444,7 +444,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn unblocks() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -469,7 +468,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn both_ready() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -496,7 +494,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         const AMT: i32 = 10000;\n         let (tx1, rx1) = channel::<i32>();\n@@ -524,7 +521,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -547,7 +543,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning2() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -570,7 +565,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning3() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n@@ -688,7 +682,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -705,7 +698,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -726,7 +718,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -755,7 +746,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn sync2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -768,7 +758,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn sync3() {\n         let (tx1, rx1) = sync_channel::<i32>(0);\n         let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();"}]}