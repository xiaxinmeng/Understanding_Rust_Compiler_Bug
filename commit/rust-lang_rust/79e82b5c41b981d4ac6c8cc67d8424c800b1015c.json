{"sha": "79e82b5c41b981d4ac6c8cc67d8424c800b1015c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZTgyYjVjNDFiOTgxZDRhYzZjOGNjNjdkODQyNGM4MDBiMTAxNWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-28T16:17:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-01T19:06:41Z"}, "message": "Implement `Deref` for `ImportResolver` to `Resolver`.", "tree": {"sha": "45b26b1a8962b685962bf3bf9bc25ab0442c681a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45b26b1a8962b685962bf3bf9bc25ab0442c681a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79e82b5c41b981d4ac6c8cc67d8424c800b1015c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79e82b5c41b981d4ac6c8cc67d8424c800b1015c", "html_url": "https://github.com/rust-lang/rust/commit/79e82b5c41b981d4ac6c8cc67d8424c800b1015c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79e82b5c41b981d4ac6c8cc67d8424c800b1015c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c1612c62aa59e40cf1a4bddde943938e0147eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1612c62aa59e40cf1a4bddde943938e0147eec", "html_url": "https://github.com/rust-lang/rust/commit/2c1612c62aa59e40cf1a4bddde943938e0147eec"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "796e0f5518a0cc0c569afae6611e48c575c2d612", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 62, "deletions": 53, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/79e82b5c41b981d4ac6c8cc67d8424c800b1015c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e82b5c41b981d4ac6c8cc67d8424c800b1015c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=79e82b5c41b981d4ac6c8cc67d8424c800b1015c", "patch": "@@ -21,7 +21,7 @@ use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n use rustc::ty;\n-use rustc::lint;\n+use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n@@ -343,6 +343,25 @@ struct ImportResolver<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n }\n \n+impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> {\n+    type Target = Resolver<'b>;\n+    fn deref(&self) -> &Resolver<'b> {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> {\n+    fn deref_mut(&mut self) -> &mut Resolver<'b> {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a, 'b: 'a> ty::NodeIdTree for ImportResolver<'a, 'b> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        self.resolver.is_descendant_of(node, ancestor)\n+    }\n+}\n+\n impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // Import resolution\n     //\n@@ -360,31 +379,29 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut errors = Vec::new();\n \n         loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\",\n-                   i,\n-                   self.resolver.unresolved_imports);\n+            debug!(\"(resolving imports) iteration {}, {} imports left\", i, self.unresolved_imports);\n \n             // Attempt to resolve imports in all local modules.\n-            for module in self.resolver.arenas.local_modules().iter() {\n-                self.resolver.current_module = module;\n+            for module in self.arenas.local_modules().iter() {\n+                self.current_module = module;\n                 self.resolve_imports_in_current_module(&mut errors);\n             }\n \n-            if self.resolver.unresolved_imports == 0 {\n+            if self.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n-                for module in self.resolver.arenas.local_modules().iter() {\n+                for module in self.arenas.local_modules().iter() {\n                     self.finalize_resolutions_in(module, false);\n                 }\n                 break;\n             }\n \n-            if self.resolver.unresolved_imports == prev_unresolved_imports {\n+            if self.unresolved_imports == prev_unresolved_imports {\n                 // resolving failed\n                 // Report unresolved imports only if no hard error was already reported\n                 // to avoid generating multiple errors on the same import.\n                 // Imports that are still indeterminate at this point are actually blocked\n                 // by errored imports, so there is no point reporting them.\n-                for module in self.resolver.arenas.local_modules().iter() {\n+                for module in self.arenas.local_modules().iter() {\n                     self.finalize_resolutions_in(module, errors.len() == 0);\n                 }\n                 for e in errors {\n@@ -394,15 +411,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n \n             i += 1;\n-            prev_unresolved_imports = self.resolver.unresolved_imports;\n+            prev_unresolved_imports = self.unresolved_imports;\n         }\n     }\n \n     // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n     // failed resolution\n     fn import_dummy_binding(&self, source_module: Module<'b>, directive: &'b ImportDirective<'b>) {\n         if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n+            let dummy_binding = self.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n@@ -430,7 +447,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n         let mut imports = Vec::new();\n-        let mut unresolved_imports = self.resolver.current_module.unresolved_imports.borrow_mut();\n+        let mut unresolved_imports = self.current_module.unresolved_imports.borrow_mut();\n         ::std::mem::swap(&mut imports, &mut unresolved_imports);\n \n         for import_directive in imports {\n@@ -441,7 +458,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         None => (import_directive.span, String::new()),\n                     };\n                     errors.push(ImportResolvingError {\n-                        source_module: self.resolver.current_module,\n+                        source_module: self.current_module,\n                         import_directive: import_directive,\n                         span: span,\n                         help: help,\n@@ -450,8 +467,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Indeterminate => unresolved_imports.push(import_directive),\n                 Success(()) => {\n                     // Decrement the count of unresolved imports.\n-                    assert!(self.resolver.unresolved_imports >= 1);\n-                    self.resolver.unresolved_imports -= 1;\n+                    assert!(self.unresolved_imports >= 1);\n+                    self.unresolved_imports -= 1;\n                 }\n             }\n         }\n@@ -465,13 +482,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n-               module_to_string(self.resolver.current_module));\n+               module_to_string(self.current_module));\n \n         let target_module = match directive.target_module.get() {\n             Some(module) => module,\n-            _ => match self.resolver.resolve_module_path(&directive.module_path,\n-                                                         DontUseLexicalScope,\n-                                                         directive.span) {\n+            _ => match self.resolve_module_path(&directive.module_path,\n+                                                DontUseLexicalScope,\n+                                                directive.span) {\n                 Success(module) => module,\n                 Indeterminate => return Indeterminate,\n                 Failed(err) => return Failed(err),\n@@ -486,12 +503,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let value_result =\n-            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result =\n-            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+        let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n+        let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n-        let module_ = self.resolver.current_module;\n+        let module_ = self.current_module;\n         let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n@@ -504,20 +519,20 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 Success(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n-                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n+                    span_err!(self.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n                     self.import_dummy_binding(module_, directive);\n                     return Success(());\n                 }\n-                Success(binding) if !self.resolver.is_accessible(binding.vis) => {}\n+                Success(binding) if !self.is_accessible(binding.vis) => {}\n                 Success(binding) if !determined.get() => {\n                     determined.set(true);\n                     let imported_binding = directive.import(binding);\n                     let conflict = module_.try_define_child(target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &directive.import(binding);\n-                        self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                        self.report_conflict(module_, target, ns, binding, old_binding);\n                     }\n                     privacy_error = false;\n                 }\n@@ -556,39 +571,34 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if privacy_error {\n             for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n                 let binding = match *result { Success(binding) => binding, _ => continue };\n-                self.resolver.privacy_errors.push(PrivacyError(directive.span, source, binding));\n+                self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n                 let _ = module_.try_define_child(target, ns, directive.import(binding));\n             }\n         }\n \n         match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis()\n-                                              .is_at_least(directive.vis, self.resolver) &&\n-                                      self.resolver.is_accessible(binding.vis) => {\n+            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                      self.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n-                struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n+                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis()\n-                                              .is_at_least(directive.vis, self.resolver) &&\n-                                      self.resolver.is_accessible(binding.vis) => {\n+            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                      self.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n                                        source);\n-                    self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                   directive.id,\n-                                                   directive.span,\n-                                                   msg);\n+                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n                 } else {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n                         format!(\"consider declaring type or module `{}` with `pub`\", source);\n-                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                    struct_span_err!(self.session, directive.span, E0365, \"{}\", &msg)\n                         .span_note(directive.span, &note_msg)\n                         .emit();\n                 }\n@@ -605,7 +615,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n-        self.resolver.def_map.insert(directive.id, path_resolution);\n+        self.def_map.insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -618,19 +628,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n                            -> ResolveResult<()> {\n         if let Some(Def::Trait(_)) = target_module.def {\n-            self.resolver.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n-        let module_ = self.resolver.current_module;\n+        let module_ = self.current_module;\n         if module_.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n         }\n-        self.resolver.populate_module_if_necessary(target_module);\n+        self.populate_module_if_necessary(target_module);\n \n         if let GlobImport { is_prelude: true } = directive.subclass {\n-            self.resolver.prelude = Some(target_module);\n+            self.prelude = Some(target_module);\n             return Success(());\n         }\n \n@@ -651,7 +661,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n             let resolution = PathResolution::new(Def::Mod(did));\n-            self.resolver.def_map.insert(directive.id, resolution);\n+            self.def_map.insert(directive.id, resolution);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -668,7 +678,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             resolution.report_conflicts(|b1, b2| {\n-                self.resolver.report_conflict(module, name, ns, b1, b2)\n+                self.report_conflict(module, name, ns, b1, b2)\n             });\n \n             let binding = match resolution.binding {\n@@ -685,20 +695,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                   !orig_binding.vis.is_at_least(binding.vis, self.resolver) {\n+                   !orig_binding.vis.is_at_least(binding.vis, self) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);\n-                    let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n-                    self.resolver.session.add_lint(lint, directive.id, binding.span, msg);\n+                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n                 }\n             }\n         }\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                let node_id = self.resolver.definitions.as_local_node_id(def_id).unwrap();\n-                self.resolver.export_map.insert(node_id, reexports);\n+                let node_id = self.definitions.as_local_node_id(def_id).unwrap();\n+                self.export_map.insert(node_id, reexports);\n             }\n         }\n "}]}