{"sha": "a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmVlN2IwNWQ1OTQ2N2JjNjMwNGIzMmViMTRlNjE3YzJlZmJmYzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-14T18:24:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-15T20:50:37Z"}, "message": "Add a crate for missing stubs from libcore\n\nThe core library in theory has 0 dependencies, but in practice it has some in\norder for it to be efficient. These dependencies are in the form of the basic\nmemory operations provided by libc traditionally, such as memset, memcmp, etc.\nThese functions are trivial to implement and themselves have 0 dependencies.\n\nThis commit adds a new crate, librlibc, which will serve the purpose of\nproviding these dependencies. The crate is never linked to by default, but is\navailable to be linked to by downstream consumers. Normally these functions are\nprovided by the system libc, but in other freestanding contexts a libc may not\nbe available. In these cases, librlibc will suffice for enabling execution with\nlibcore.\n\ncc #10116", "tree": {"sha": "99c06196f44ecfcebfaace1827cea6e6befa119f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c06196f44ecfcebfaace1827cea6e6befa119f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "html_url": "https://github.com/rust-lang/rust/commit/a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e043644cea119ea701a293a01b6d4c5c0f13f450", "url": "https://api.github.com/repos/rust-lang/rust/commits/e043644cea119ea701a293a01b6d4c5c0f13f450", "html_url": "https://github.com/rust-lang/rust/commit/e043644cea119ea701a293a01b6d4c5c0f13f450"}], "stats": {"total": 157, "additions": 141, "deletions": 16}, "files": [{"sha": "b43accf610489eef5cd7f74974a8d4413a883e68", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -51,12 +51,13 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-\t\t workcache url log regex graphviz core\n+\t\t workcache url log regex graphviz core rlibc\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n+DEPS_rlibc :=\n DEPS_std := core libc native:rustrt native:compiler-rt native:backtrace native:jemalloc\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n@@ -98,6 +99,7 @@ TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n \n ONLY_RLIB_core := 1\n+ONLY_RLIB_rlibc := 1\n \n ################################################################################\n # You should not need to edit below this line"}, {"sha": "838ddca042dfc661c2b5f70676bbdaec59659565", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -1799,6 +1799,8 @@ type int8_t = i8;\n - `no_start` - disable linking to the `native` crate, which specifies the\n   \"start\" language item.\n - `no_std` - disable linking to the `std` crate.\n+- `no_builtins` - disable optimizing certain code patterns to invocations of\n+                  library functions that are assumed to exist\n \n ### Module-only attributes\n "}, {"sha": "4102c72d8b64bf3eb0570723fe4ade5875544bc7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -18,6 +18,9 @@\n //! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n //!   often generated by LLVM. Additionally, this library can make explicit\n //!   calls to these funcitons. Their signatures are the same as found in C.\n+//!   These functions are often provided by the system libc, but can also be\n+//!   provided by `librlibc` which is distributed with the standard rust\n+//!   distribution.\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n //!   `&fmt::Arguments`, a `&str`, and a `uint. These three arguments dictate"}, {"sha": "904fbe9be9b279e1fd558c58e317efa0b9821ec7", "filename": "src/librlibc/lib.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A bare-metal library supplying functions rustc may lower code to\n+//!\n+//! This library is not intended for general use, and is superseded by a system\n+//! libc if one is available. In a freestanding context, however, common\n+//! functions such as memset, memcpy, etc are not implemented. This library\n+//! provides an implementation of these functions which are either required by\n+//! libcore or called by rustc implicitly.\n+//!\n+//! This library is never included by default, and must be manually included if\n+//! necessary. It is an error to include this library when also linking with\n+//! the system libc library.\n+\n+#![crate_id = \"rlibc#0.11.0-pre\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://static.rust-lang.org/doc/master\")]\n+\n+#![no_std]\n+#![experimental]\n+\n+// This library is definining the builtin functions, so it would be a shame for\n+// LLVM to optimize these function calls to themselves!\n+#![no_builtins]\n+\n+#[cfg(test)] extern crate std;\n+#[cfg(test)] extern crate native;\n+\n+// Require the offset intrinsics for LLVM to properly optimize the\n+// implementations below. If pointer arithmetic is done through integers the\n+// optimizations start to break down.\n+extern \"rust-intrinsic\" {\n+    fn offset<T>(dst: *T, offset: int) -> *T;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n+    let mut i = 0;\n+    while i < n {\n+        *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+        i += 1;\n+    }\n+    return dest;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n+    if src < dest as *u8 { // copy from end\n+        let mut i = n;\n+        while i != 0 {\n+            i -= 1;\n+            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+        }\n+    } else { // copy from beginning\n+        let mut i = 0;\n+        while i < n {\n+            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+            i += 1;\n+        }\n+    }\n+    return dest;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn memset(s: *mut u8, c: i32, n: uint) -> *mut u8 {\n+    let mut i = 0;\n+    while i < n {\n+        *(offset(s as *u8, i as int) as *mut u8) = c as u8;\n+        i += 1;\n+    }\n+    return s;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn memcmp(s1: *u8, s2: *u8, n: uint) -> i32 {\n+    let mut i = 0;\n+    while i < n {\n+        let a = *offset(s1, i as int);\n+        let b = *offset(s2, i as int);\n+        if a != b {\n+            return (a - b) as i32\n+        }\n+        i += 1;\n+    }\n+    return 0;\n+}\n+\n+#[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows"}, {"sha": "429a8f5be5eb5f54604b862465c7e1fe82e952d1", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -212,7 +212,8 @@ pub mod write {\n             if !sess.opts.cg.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, opt_level);\n+                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n+                                     trans.no_builtins);\n             }\n \n             for pass in sess.opts.cg.passes.iter() {\n@@ -264,11 +265,11 @@ pub mod write {\n             // escape the closure itself, and the manager should only be\n             // used once.\n             fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                            f: |PassManagerRef|) {\n+                            no_builtins: bool, f: |PassManagerRef|) {\n                 unsafe {\n                     let cpm = llvm::LLVMCreatePassManager();\n                     llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                    llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+                    llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n                     f(cpm);\n                     llvm::LLVMDisposePassManager(cpm);\n                 }\n@@ -286,7 +287,7 @@ pub mod write {\n                     }\n                     OutputTypeLlvmAssembly => {\n                         path.with_c_str(|output| {\n-                            with_codegen(tm, llmod, |cpm| {\n+                            with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n                                 llvm::LLVMRustPrintModule(cpm, llmod, output);\n                             })\n                         })\n@@ -303,7 +304,7 @@ pub mod write {\n                             needs_metadata = true;\n                             output.temp_path(OutputTypeAssembly)\n                         };\n-                        with_codegen(tm, llmod, |cpm| {\n+                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n                             WriteOutputFile(sess, tm, cpm, llmod, &path,\n                                             lib::llvm::AssemblyFile);\n                         });\n@@ -321,15 +322,16 @@ pub mod write {\n             time(sess.time_passes(), \"codegen passes\", (), |()| {\n                 match object_file {\n                     Some(ref path) => {\n-                        with_codegen(tm, llmod, |cpm| {\n+                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n                             WriteOutputFile(sess, tm, cpm, llmod, path,\n                                             lib::llvm::ObjectFile);\n                         });\n                     }\n                     None => {}\n                 }\n                 if needs_metadata {\n-                    with_codegen(tm, trans.metadata_module, |cpm| {\n+                    with_codegen(tm, trans.metadata_module,\n+                                 trans.no_builtins, |cpm| {\n                         let out = output.temp_path(OutputTypeObject)\n                                         .with_extension(\"metadata.o\");\n                         WriteOutputFile(sess, tm, cpm,\n@@ -437,7 +439,8 @@ pub mod write {\n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,\n                                    mpm: lib::llvm::PassManagerRef,\n                                    llmod: ModuleRef,\n-                                   opt: lib::llvm::CodeGenOptLevel) {\n+                                   opt: lib::llvm::CodeGenOptLevel,\n+                                   no_builtins: bool) {\n         // Create the PassManagerBuilder for LLVM. We configure it with\n         // reasonable defaults and prepare it to actually populate the pass\n         // manager.\n@@ -461,7 +464,7 @@ pub mod write {\n             }\n         }\n         llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n-        llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod);\n+        llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n \n         // Use the builder to populate the function/module pass managers.\n         llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);"}, {"sha": "0b731e18f557480264b0630181a937c57b093a2d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -356,6 +356,7 @@ pub struct CrateTranslation {\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<StrBuf>,\n     pub crate_formats: dependency_format::Dependencies,\n+    pub no_builtins: bool,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can"}, {"sha": "711081f46d6669703a276c2d8981881c4398b078", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -1755,8 +1755,10 @@ pub mod llvm {\n                                          PM: PassManagerRef,\n                                          M: ModuleRef);\n         pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                             M: ModuleRef);\n-        pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef);\n+                                             M: ModuleRef,\n+                                             DisableSimplifyLibCalls: bool);\n+        pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n+                                      DisableSimplifyLibCalls: bool);\n         pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n         pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n                                        PM: PassManagerRef,"}, {"sha": "1c24d609551ab992d7791537ff8af17a96e1f80b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -1050,6 +1050,7 @@ fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n static crate_attrs: &'static [&'static str] = &[\n     \"crate_type\", \"feature\", \"no_start\", \"no_main\", \"no_std\", \"crate_id\",\n     \"desc\", \"comment\", \"license\", \"copyright\", // not used in rustc now\n+    \"no_builtins\",\n ];\n \n "}, {"sha": "92e3b95abadc1d34eb94c867a55c04a7a22fe0f2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -2226,6 +2226,7 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let metadata_module = ccx.metadata_llmod;\n     let formats = ccx.tcx.dependency_formats.borrow().clone();\n+    let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n \n     (ccx.tcx, CrateTranslation {\n         context: llcx,\n@@ -2235,5 +2236,6 @@ pub fn trans_crate(krate: ast::Crate,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,\n+        no_builtins: no_builtins,\n     })\n }"}, {"sha": "64776421fa1451c122839a93926844d4b8b52087", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a7bee7b05d59467bc6304b32eb14e617c2efbfc9/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=a7bee7b05d59467bc6304b32eb14e617c2efbfc9", "patch": "@@ -128,17 +128,27 @@ LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n // field of a PassManagerBuilder, we expose our own method of doing so.\n extern \"C\" void\n-LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB, LLVMModuleRef M) {\n+LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n+                              LLVMModuleRef M,\n+                              bool DisableSimplifyLibCalls) {\n     Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    unwrap(PMB)->LibraryInfo = new TargetLibraryInfo(TargetTriple);\n+    TargetLibraryInfo *TLI = new TargetLibraryInfo(TargetTriple);\n+    if (DisableSimplifyLibCalls)\n+      TLI->disableAllFunctions();\n+    unwrap(PMB)->LibraryInfo = TLI;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n extern \"C\" void\n-LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB, LLVMModuleRef M) {\n+LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB,\n+                       LLVMModuleRef M,\n+                       bool DisableSimplifyLibCalls) {\n     Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    unwrap(PMB)->add(new TargetLibraryInfo(TargetTriple));\n+    TargetLibraryInfo *TLI = new TargetLibraryInfo(TargetTriple);\n+    if (DisableSimplifyLibCalls)\n+      TLI->disableAllFunctions();\n+    unwrap(PMB)->add(TLI);\n }\n \n // Unfortunately, the LLVM C API doesn't provide an easy way of iterating over"}]}