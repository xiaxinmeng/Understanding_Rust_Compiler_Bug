{"sha": "0aa72ad55de5b431e04e26316358a629574bf79f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYTcyYWQ1NWRlNWI0MzFlMDRlMjYzMTYzNThhNjI5NTc0YmY3OWY=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-12-06T06:48:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-06T06:48:53Z"}, "message": "Rollup merge of #56426 - petrochenkov:syntweak, r=nikomatsakis\n\nlibsyntax_pos: A few tweaks", "tree": {"sha": "a6f6cc609f11ca9c3ae9938d0be3b566304cf987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f6cc609f11ca9c3ae9938d0be3b566304cf987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aa72ad55de5b431e04e26316358a629574bf79f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcCMZWCRBK7hj4Ov3rIwAAdHIIAKun9Mm20bM0BzY77/rnAJxM\nYty0g9puqMWL3hYiuc8QArhY3VG/GQ+flycIesJXTfiQK9d2t43O8QbGOD/l+odF\n29ny/C6rmJEGwsn10jNifdbGd5GhcrsJPnbhgfW4JN/UR6JDHouGtbPlrat4k+tJ\nKye+qWBHwrahCzNa0wnwBUSMDG45yRGie8p6a5ngfeI3siHRkRJdKQW7JggZFpV1\nLxStZTSWT5CGCa0OOA6cCeikxEE1ozTC58EbDEoMm/NkzuhcozMmmzT2pYGn44Ru\nIVs/gFiOMD/VsrZlNDr+CSOeUIlcPmrtqEbkW9L0K2irg7bd8M4PFHaojsD35fU=\n=S3Gb\n-----END PGP SIGNATURE-----\n", "payload": "tree a6f6cc609f11ca9c3ae9938d0be3b566304cf987\nparent e57ed0ddab4403a62d129f52af696420b94439d8\nparent d08f7dcdca861f46bedf8a37af135a7a46633540\nauthor Pietro Albini <pietro@pietroalbini.org> 1544078933 +0100\ncommitter GitHub <noreply@github.com> 1544078933 +0100\n\nRollup merge of #56426 - petrochenkov:syntweak, r=nikomatsakis\n\nlibsyntax_pos: A few tweaks\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa72ad55de5b431e04e26316358a629574bf79f", "html_url": "https://github.com/rust-lang/rust/commit/0aa72ad55de5b431e04e26316358a629574bf79f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aa72ad55de5b431e04e26316358a629574bf79f/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57ed0ddab4403a62d129f52af696420b94439d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57ed0ddab4403a62d129f52af696420b94439d8", "html_url": "https://github.com/rust-lang/rust/commit/e57ed0ddab4403a62d129f52af696420b94439d8"}, {"sha": "d08f7dcdca861f46bedf8a37af135a7a46633540", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08f7dcdca861f46bedf8a37af135a7a46633540", "html_url": "https://github.com/rust-lang/rust/commit/d08f7dcdca861f46bedf8a37af135a7a46633540"}], "stats": {"total": 255, "additions": 119, "deletions": 136}, "files": [{"sha": "8ea1cb26dc0c7f0239dac52fa1f67ef48165042d", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -741,14 +741,14 @@ fn_anon_params\n ;\n \n fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n ;\n \n fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }"}, {"sha": "a485af0a5eef9fa1a989f0d614660c81b4ba0868", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1201,7 +1201,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfUpper.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -2425,7 +2425,7 @@ impl<'a> LoweringContext<'a> {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                let ident = if param.ident.name == keywords::SelfType.name() {\n+                let ident = if param.ident.name == keywords::SelfUpper.name() {\n                     param.ident.gensym()\n                 } else {\n                     param.ident\n@@ -2981,7 +2981,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {"}, {"sha": "4ac07d78a26137f0d4003a639bdfefa5a8ce1d7d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -475,7 +475,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfType.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }"}, {"sha": "85bf257df237fa3052614cb9431e990ea726adbf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -311,7 +311,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n "}, {"sha": "eb11d40440b19de34719b26a9a510e6d3bbe6427", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1622,7 +1622,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name() {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n@@ -1636,7 +1636,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n@@ -1664,7 +1664,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                    if segment.ident.name != keywords::PathRoot.name() &&\n                        segment.ident.name != keywords::DollarCrate.name() {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {"}, {"sha": "db643e4fd726ba5c07bbb7ae0ad9a081c8a03a83", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -134,14 +134,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     const_stability\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::syntax::edition::Edition {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(enum ::syntax::edition::Edition {\n+    Edition2015,\n+    Edition2018,\n+});\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {"}, {"sha": "b846a1c4930fbf4675537e55f4d7ce6c2db45a48", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                if ident.name != keywords::SelfValue.name() {\n+                if ident.name != keywords::SelfLower.name() {\n                     if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);"}, {"sha": "f041192413107b38845b019b857ee4390781529e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1493,12 +1493,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             BorrowckMode::Ast => match self.sess.edition() {\n                 Edition::Edition2015 => BorrowckMode::Ast,\n                 Edition::Edition2018 => BorrowckMode::Migrate,\n-\n-                // For now, future editions mean Migrate. (But it\n-                // would make a lot of sense for it to be changed to\n-                // `BorrowckMode::Mir`, depending on how we plan to\n-                // time the forcing of full migration to NLL.)\n-                _ => BorrowckMode::Migrate,\n             },\n         }\n     }\n@@ -2710,7 +2704,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n+        self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {"}, {"sha": "d861fb367813ae51677d9f38b8d1f13d8510bcbc", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1020,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n+        ParamTy::new(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name == keywords::SelfType.name().as_str() && self.idx == 0\n+        self.name == keywords::SelfUpper.name().as_str() && self.idx == 0\n     }\n }\n "}, {"sha": "c7eb06cbe00535eebc180e7b58d97743a5d5f8ff", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -473,7 +473,7 @@ impl UnusedImportBraces {\n             match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n-                    if orig_ident.name == keywords::SelfValue.name() {\n+                    if orig_ident.name == keywords::SelfLower.name() {\n                         return;\n                     }\n                     node_ident = rename.unwrap_or(orig_ident);"}, {"sha": "4bcabfef4fd7f41c59e06e26d0d961ec73ff5132", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             // Deliberately fall into this case for all implicit self types,\n                             // so that we don't fall in to the next case with them.\n                             *kind == mir::ImplicitSelfKind::MutRef\n-                        } else if Some(keywords::SelfValue.name()) == local_decl.name {\n+                        } else if Some(keywords::SelfLower.name()) == local_decl.name {\n                             // Otherwise, check if the name is the self kewyord - in which case\n                             // we have an explicit self. Do the same thing in this case and check\n                             // for a `self: &mut Self` to suggest removing the `&mut`."}, {"sha": "4e773124c8dab77ce41b455fde140ddc0b548ed4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -145,15 +145,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n             _ => None,\n         }.map(|ctxt| Segment::from_ident(Ident::new(\n-            keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+            keywords::PathRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n         )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n-            prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n+            prefix.len() == 1 && prefix[0].ident.name == keywords::PathRoot.name()\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n@@ -164,7 +164,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n@@ -185,7 +185,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.ident.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfLower.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n@@ -205,7 +205,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             // `crate_name` should not be interpreted as relative.\n                             module_path.push(Segment {\n                                 ident: Ident {\n-                                    name: keywords::CrateRoot.name(),\n+                                    name: keywords::PathRoot.name(),\n                                     span: source.ident.span,\n                                 },\n                                 id: Some(self.session.next_node_id()),\n@@ -270,7 +270,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n                     if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n-                        if use_tree.ident().name == keywords::SelfValue.name() {\n+                        if use_tree.ident().name == keywords::SelfLower.name() {\n                             return Some(use_tree.span);\n                         }\n                     }\n@@ -305,7 +305,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     let new_span = prefix[prefix.len() - 1].ident.span;\n                     let tree = ast::UseTree {\n                         prefix: ast::Path::from_ident(\n-                            Ident::new(keywords::SelfValue.name(), new_span)\n+                            Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n                             Some(Ident::new(keywords::Underscore.name().gensymed(), new_span)),\n@@ -344,13 +344,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             ItemKind::ExternCrate(orig_name) => {\n-                let module = if orig_name.is_none() && ident.name == keywords::SelfValue.name() {\n+                let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(item.span, \"try\", \"extern crate self as name;\".into())\n                         .emit();\n                     return;\n-                } else if orig_name == Some(keywords::SelfValue.name()) {\n+                } else if orig_name == Some(keywords::SelfLower.name()) {\n                     if !self.session.features_untracked().extern_crate_self {\n                         emit_feature_err(&self.session.parse_sess, \"extern_crate_self\", item.span,\n                                          GateIssue::Language, \"`extern crate self` is unstable\");\n@@ -783,7 +783,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n-                    if orig_name == keywords::SelfValue.name() {\n+                    if orig_name == keywords::SelfLower.name() {\n                         self.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }"}, {"sha": "23edaf12438121fd682389ae45f9ff7c741ca0f0", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         match (path.get(0), path.get(1)) {\n             // `{{root}}::ident::...` on both editions.\n             // On 2015 `{{root}}` is usually added implicitly.\n-            (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n+            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018\n             (Some(fst), _) if fst.ident.span.rust_2018() &&\n@@ -61,7 +61,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].ident.name = keywords::SelfValue.name();\n+        path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {"}, {"sha": "9ea39aea86867ea99455a352c1df7192f9492210", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -769,7 +769,7 @@ impl<'a, 'tcx, 'cl> Visitor<'tcx> for Resolver<'a, 'cl> {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n             TyKind::ImplicitSelf => {\n-                let self_ty = keywords::SelfType.ident();\n+                let self_ty = keywords::SelfUpper.ident();\n                 let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Def::Err, |d| d.def());\n                 self.record_def(ty.id, PathResolution::new(def));\n@@ -1679,7 +1679,7 @@ impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n         components: &[&str],\n         is_value: bool\n     ) -> hir::Path {\n-        let segments = iter::once(keywords::CrateRoot.ident())\n+        let segments = iter::once(keywords::PathRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n@@ -1721,7 +1721,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let path = if path_str.starts_with(\"::\") {\n             ast::Path {\n                 span,\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain({\n                         path_str.split(\"::\").skip(1).map(Ident::from_str)\n                     })\n@@ -2036,7 +2036,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let record_used = record_used_id.is_some();\n         assert!(ns == TypeNS  || ns == ValueNS);\n         if ns == TypeNS {\n-            ident.span = if ident.name == keywords::SelfType.name() {\n+            ident.span = if ident.name == keywords::SelfUpper.name() {\n                 // FIXME(jseyfried) improve `Self` hygiene\n                 ident.span.with_ctxt(SyntaxContext::empty())\n             } else {\n@@ -2649,7 +2649,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -2660,7 +2660,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     {\n         let self_def = Def::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -3146,7 +3146,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 let item_span = path.last().unwrap().ident.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].ident.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -3515,13 +3515,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfUpper.ident(),\n                                                           TypeNS, None, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n-        let ident = Ident::new(keywords::SelfValue.name(), self_span);\n+        let ident = Ident::new(keywords::SelfLower.name(), self_span);\n         let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n@@ -3673,7 +3673,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].ident.name != keywords::CrateRoot.name() &&\n+           path[0].ident.name != keywords::PathRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path_without_parent_scope(\n@@ -3755,7 +3755,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let name = ident.name;\n \n             allow_super &= ns == TypeNS &&\n-                (name == keywords::SelfValue.name() ||\n+                (name == keywords::SelfLower.name() ||\n                  name == keywords::Super.name());\n \n             if ns == TypeNS {\n@@ -3779,24 +3779,24 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n                 if i == 0 {\n-                    if name == keywords::SelfValue.name() {\n+                    if name == keywords::SelfLower.name() {\n                         let mut ctxt = ident.span.ctxt().modern();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, self.current_module)));\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n+                       name == keywords::PathRoot.name() && ident.span.rust_2018() {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() &&\n+                    if name == keywords::PathRoot.name() &&\n                        ident.span.rust_2015() && self.session.rust_2018() {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;\n                     }\n-                    if name == keywords::CrateRoot.name() ||\n+                    if name == keywords::PathRoot.name() ||\n                        name == keywords::Crate.name() ||\n                        name == keywords::DollarCrate.name() {\n                         // `::a::b`, `crate::a::b` or `$crate::a::b`\n@@ -3809,12 +3809,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                let name_str = if name == keywords::CrateRoot.name() {\n+                let name_str = if name == keywords::PathRoot.name() {\n                     \"crate root\".to_string()\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].ident.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].ident.name == keywords::PathRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3944,7 +3944,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         // We're only interested in `use` paths which should start with\n         // `{{root}}` or `extern` currently.\n-        if first_name != keywords::Extern.name() && first_name != keywords::CrateRoot.name() {\n+        if first_name != keywords::Extern.name() && first_name != keywords::PathRoot.name() {\n             return\n         }\n \n@@ -3953,7 +3953,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n-            // If the path has length one (and it's `CrateRoot` most likely)\n+            // If the path has length one (and it's `PathRoot` most likely)\n             // then we don't know whether we're gonna be importing a crate or an\n             // item in our crate. Defer this lint to elsewhere\n             None => return,\n@@ -4740,7 +4740,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     let ctxt = ident.span.ctxt();\n                     Some(Segment::from_ident(Ident::new(\n-                        keywords::CrateRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        keywords::PathRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n                     )))\n                 };\n \n@@ -5090,17 +5090,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n }\n \n fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfType.name()\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfUpper.name()\n }\n \n fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfValue.name()\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfLower.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|ident| ident.name != keywords::CrateRoot.name())\n+                            .filter(|ident| ident.name != keywords::PathRoot.name())\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");"}, {"sha": "65a9652cd237cb0675157f070899b78184b6ba3f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n                 if path.segments[0].ident.name == keywords::DollarCrate.name() {\n                     let module = self.0.resolve_crate_root(path.segments[0].ident);\n-                    path.segments[0].ident.name = keywords::CrateRoot.name();\n+                    path.segments[0].ident.name = keywords::PathRoot.name();\n                     if !module.is_local() {\n                         let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n@@ -674,7 +674,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::CrateRoot => {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     let binding = self.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n@@ -960,7 +960,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     break 'ok;\n                 }\n                 if rust_2015 {\n-                    let root_ident = Ident::new(keywords::CrateRoot.name(), orig_ident.span);\n+                    let root_ident = Ident::new(keywords::PathRoot.name(), orig_ident.span);\n                     let root_module = self.resolve_crate_root(root_ident);\n                     if self.resolve_ident_in_module_ext(ModuleOrUniformRoot::Module(root_module),\n                                                         orig_ident, ns, None, false, path_span)"}, {"sha": "865aace8aabb51c66c6321c26e4b4439f466dde0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                         .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == keywords::Super.name() ||\n-                                ident.name == keywords::SelfValue.name() {\n+                                ident.name == keywords::SelfLower.name() {\n                         // FIXME: Implement these with renaming requirements so that e.g.\n                         // `use super;` doesn't work, but `use super as name;` does.\n                         // Fall through here to get an error from `early_resolve_...`.\n@@ -1263,8 +1263,8 @@ fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.name != keywords::CrateRoot.name());\n-    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n+        .position(|p| span == p.span && p.name != keywords::PathRoot.name());\n+    let global = !names.is_empty() && names[0].name == keywords::PathRoot.name();\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "5682a73bed573ffd51f06bf3192a8a6921eac47b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -938,7 +938,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n-                        name: keywords::SelfType.name().as_interned_str(),\n+                        name: keywords::SelfUpper.name().as_interned_str(),\n                         def_id: tcx.hir.local_def_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n@@ -1007,7 +1007,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     synthetic,\n                     ..\n                 } => {\n-                    if param.name.ident().name == keywords::SelfType.name() {\n+                    if param.name.ident().name == keywords::SelfUpper.name() {\n                         span_bug!(\n                             param.span,\n                             \"`Self` should not be the name of a regular parameter\""}, {"sha": "310c369a4d092656586c03aae49e2fb3b898b9d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime => None,\n             ty::GenericParamDefKind::Type { .. } => {\n-                if param.name == keywords::SelfType.name().as_str() {\n+                if param.name == keywords::SelfUpper.name().as_str() {\n                     assert_eq!(param.index, 0);\n                     return None;\n                 }\n@@ -3174,7 +3174,7 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.ident.name != keywords::CrateRoot.name() {\n+        if seg.ident.name != keywords::PathRoot.name() {\n             s.push_str(&*seg.ident.as_str());\n         }\n     }\n@@ -3726,7 +3726,7 @@ fn resolve_type(cx: &DocContext,\n             hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(keywords::SelfType.name().to_string());\n+            return Generic(keywords::SelfUpper.name().to_string());\n         }\n         Def::TyParam(..) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));"}, {"sha": "872257118714e55930bd45ad21bb76319a7cd006", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -73,7 +73,7 @@ impl fmt::Debug for Lifetime {\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n-    /// Global paths begin with `keywords::CrateRoot`.\n+    /// Global paths begin with `keywords::PathRoot`.\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -105,19 +105,8 @@ impl Path {\n         }\n     }\n \n-    // Make a \"crate root\" segment for this path unless it already has it\n-    // or starts with something like `self`/`super`/`$crate`/etc.\n-    pub fn make_root(&self) -> Option<PathSegment> {\n-        if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n-            if ident.is_path_segment_keyword() {\n-                return None;\n-            }\n-        }\n-        Some(PathSegment::crate_root(self.span.shrink_to_lo()))\n-    }\n-\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n \n@@ -144,8 +133,8 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n         PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n-    pub fn crate_root(span: Span) -> Self {\n-        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n+    pub fn path_root(span: Span) -> Self {\n+        PathSegment::from_ident(Ident::new(keywords::PathRoot.name(), span))\n     }\n }\n \n@@ -1688,7 +1677,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.name == keywords::SelfValue.name() {\n+            if ident.name == keywords::SelfLower.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n@@ -1706,7 +1695,7 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.name == keywords::SelfValue.name()\n+            ident.name == keywords::SelfLower.name()\n         } else {\n             false\n         }"}, {"sha": "5770f6bb8a28c442f10fd76f8065f65d1696742c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -318,9 +318,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 args: Vec<ast::GenericArg>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n+        assert!(!idents.is_empty());\n+        let add_root = global && !idents[0].is_path_segment_keyword();\n+        let mut segments = Vec::with_capacity(idents.len() + add_root as usize);\n+        if add_root {\n+            segments.push(ast::PathSegment::path_root(span));\n+        }\n         let last_ident = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = vec![];\n-\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n@@ -334,13 +338,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             args,\n         });\n-        let mut path = ast::Path { span, segments };\n-        if global {\n-            if let Some(seg) = path.make_root() {\n-                path.segments.insert(0, seg);\n-            }\n-        }\n-        path\n+        ast::Path { span, segments }\n     }\n \n     /// Constructs a qualified path.\n@@ -625,7 +623,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_ident(span, keywords::SelfValue.ident())\n+        self.expr_ident(span, keywords::SelfLower.ident())\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,"}, {"sha": "67f3dc1bb527226ed2dd4e3f0227f6b8025d8152", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -204,7 +204,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(\"::\");\n         }\n \n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n             segment.ident.name != keywords::DollarCrate.name()\n         {\n             path_str.push_str(&segment.ident.as_str())"}, {"sha": "a7415e845cae398b45aad0311139c9ab678b8b2b", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -444,7 +444,6 @@ where\n             macro_node_id,\n         ),\n         Edition::Edition2018 => parse_sep_and_kleene_op_2018(input, span, sess, features, attrs),\n-        _ => unimplemented!(),\n     }\n }\n "}, {"sha": "8165c0e44c413a3469fe8f2de6c8fc706857902c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -2082,7 +2082,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.span.ctxt();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n+            segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -5508,7 +5508,7 @@ impl<'a> Parser<'a> {\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(keywords::SelfValue)) &&\n+            this.look_ahead(n, |t| t.is_keyword(keywords::SelfLower)) &&\n             this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n \n@@ -6330,7 +6330,7 @@ impl<'a> Parser<'a> {\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n                       self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n-                                             t.is_keyword(keywords::SelfValue))\n+                                             t.is_keyword(keywords::SelfLower))\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6782,7 +6782,7 @@ impl<'a> Parser<'a> {\n         let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n         let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n                               in the code\";\n-        let mut ident = if self.token.is_keyword(keywords::SelfValue) {\n+        let mut ident = if self.token.is_keyword(keywords::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()\n@@ -7685,7 +7685,7 @@ impl<'a> Parser<'a> {\n             let mod_sep_ctxt = self.span.ctxt();\n             if self.eat(&token::ModSep) {\n                 prefix.segments.push(\n-                    PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                    PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n                 );\n             }\n "}, {"sha": "e50f28897dd1287db983f5918bf184191bf17317", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -724,7 +724,7 @@ pub trait PrintState<'a> {\n             if i > 0 {\n                 self.writer().word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n+            if segment.ident.name != keywords::PathRoot.name() &&\n                segment.ident.name != keywords::DollarCrate.name()\n             {\n                 self.writer().word(segment.ident.as_str().get())?;\n@@ -2463,7 +2463,7 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n+        if segment.ident.name != keywords::PathRoot.name() &&\n            segment.ident.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.ident)?;\n             if let Some(ref args) = segment.args {"}, {"sha": "5c994558ab06feb3aafc0f72df4634bc04b683f6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -112,7 +112,7 @@ pub fn maybe_inject_crates_ref(\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: iter::once(keywords::CrateRoot.ident())\n+                segments: iter::once(keywords::PathRoot.ident())\n                     .chain(\n                         [name, \"prelude\", \"v1\"].iter().cloned()\n                             .map(ast::Ident::from_str)"}, {"sha": "b9e0933331cb87814deb4a4177d9d454249eea14", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -140,7 +140,7 @@ fn cs_clone_shallow(name: &str,\n     let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n-        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfUpper.ident()));\n         assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n     } else {\n         match *substr.fields {"}, {"sha": "c0c11f64bc3b88b722e65f96846e96fa15ed63c1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -938,7 +938,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self,\n-                                    keywords::SelfValue.ident().with_span_pos(trait_.span))\n+                                    keywords::SelfLower.ident().with_span_pos(trait_.span))\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));"}, {"sha": "d57078ce914078375dab2ae8bf575d7715aebe3a", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -13,7 +13,6 @@ use std::str::FromStr;\n \n /// The edition of the compiler (RFC 2052)\n #[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n-#[non_exhaustive]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest\n "}, {"sha": "074687fc726e8fd209d4e5c69df09d15a8d128e0", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -17,7 +17,7 @@\n \n use GLOBALS;\n use Span;\n-use edition::Edition;\n+use edition::{Edition, DEFAULT_EDITION};\n use symbol::Symbol;\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -217,7 +217,7 @@ impl HygieneData {\n                 opaque_and_semitransparent: SyntaxContext(0),\n             }],\n             markings: FxHashMap::default(),\n-            default_edition: Edition::Edition2015,\n+            default_edition: DEFAULT_EDITION,\n         }\n     }\n "}, {"sha": "4f2eb74c0722766a3181ff9559fd8e205636e9b0", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -349,11 +349,11 @@ declare_keywords! {\n     // Special reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,            \"\")\n-    (1,  CrateRoot,          \"{{root}}\")\n+    (1,  PathRoot,           \"{{root}}\")\n     (2,  DollarCrate,        \"$crate\")\n     (3,  Underscore,         \"_\")\n \n-    // Keywords used in the language.\n+    // Keywords that are used in stable Rust.\n     (4,  As,                 \"as\")\n     (5,  Box,                \"box\")\n     (6,  Break,              \"break\")\n@@ -378,8 +378,8 @@ declare_keywords! {\n     (25, Pub,                \"pub\")\n     (26, Ref,                \"ref\")\n     (27, Return,             \"return\")\n-    (28, SelfValue,          \"self\")\n-    (29, SelfType,           \"Self\")\n+    (28, SelfLower,          \"self\")\n+    (29, SelfUpper,          \"Self\")\n     (30, Static,             \"static\")\n     (31, Struct,             \"struct\")\n     (32, Super,              \"super\")\n@@ -391,7 +391,7 @@ declare_keywords! {\n     (38, Where,              \"where\")\n     (39, While,              \"while\")\n \n-    // Keywords reserved for future use.\n+    // Keywords that are used in unstable Rust or reserved for future use.\n     (40, Abstract,           \"abstract\")\n     (41, Become,             \"become\")\n     (42, Do,                 \"do\")\n@@ -404,9 +404,11 @@ declare_keywords! {\n     (49, Virtual,            \"virtual\")\n     (50, Yield,              \"yield\")\n \n-    // Edition-specific keywords reserved for future use.\n-    (51, Async,              \"async\") // >= 2018 Edition only\n-    (52, Dyn,                \"dyn\") // >= 2018 Edition only\n+    // Edition-specific keywords that are used in stable Rust.\n+    (51, Dyn,                \"dyn\") // >= 2018 Edition only\n+\n+    // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n+    (52, Async,              \"async\") // >= 2018 Edition only\n     (53, Try,                \"try\") // >= 2018 Edition only\n \n     // Special lifetime names\n@@ -417,11 +419,15 @@ declare_keywords! {\n     (56, Auto,               \"auto\")\n     (57, Catch,              \"catch\")\n     (58, Default,            \"default\")\n-    (59, Union,              \"union\")\n-    (60, Existential,        \"existential\")\n+    (59, Existential,        \"existential\")\n+    (60, Union,              \"union\")\n }\n \n impl Symbol {\n+    fn is_used_keyword_2018(self) -> bool {\n+        self == keywords::Dyn.name()\n+    }\n+\n     fn is_unused_keyword_2018(self) -> bool {\n         self >= keywords::Async.name() && self <= keywords::Try.name()\n     }\n@@ -436,7 +442,9 @@ impl Ident {\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(self) -> bool {\n-        self.name >= keywords::As.name() && self.name <= keywords::While.name()\n+        // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n+        self.name >= keywords::As.name() && self.name <= keywords::While.name() ||\n+        self.name.is_used_keyword_2018() && self.span.rust_2018()\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n@@ -454,11 +462,11 @@ impl Ident {\n     /// A keyword or reserved identifier that can be used as a path segment.\n     pub fn is_path_segment_keyword(self) -> bool {\n         self.name == keywords::Super.name() ||\n-        self.name == keywords::SelfValue.name() ||\n-        self.name == keywords::SelfType.name() ||\n+        self.name == keywords::SelfLower.name() ||\n+        self.name == keywords::SelfUpper.name() ||\n         self.name == keywords::Extern.name() ||\n         self.name == keywords::Crate.name() ||\n-        self.name == keywords::CrateRoot.name() ||\n+        self.name == keywords::PathRoot.name() ||\n         self.name == keywords::DollarCrate.name()\n     }\n "}, {"sha": "377c85fef490a7d34a8b0077e87dee85d54208c8", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n \n type A0 = dyn;\n-type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n+type A1 = dyn::dyn; //~ERROR expected identifier, found keyword `dyn`\n type A2 = dyn<dyn, dyn>; //~ERROR expected identifier, found `<`\n type A3 = dyn<<dyn as dyn>::dyn>;\n "}, {"sha": "bd72f9c6786b2a8ca2d80dc1e7f94360a8bc825b", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0aa72ad55de5b431e04e26316358a629574bf79f/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr?ref=0aa72ad55de5b431e04e26316358a629574bf79f", "patch": "@@ -1,8 +1,8 @@\n-error: expected identifier, found reserved keyword `dyn`\n+error: expected identifier, found keyword `dyn`\n   --> $DIR/dyn-trait-compatibility.rs:4:16\n    |\n-LL | type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n-   |                ^^^ expected identifier, found reserved keyword\n+LL | type A1 = dyn::dyn; //~ERROR expected identifier, found keyword `dyn`\n+   |                ^^^ expected identifier, found keyword\n \n error: expected identifier, found `<`\n   --> $DIR/dyn-trait-compatibility.rs:5:14"}]}