{"sha": "85e6f38e797959d2f65f908f88a81d3e6891d609", "node_id": "C_kwDOAAsO6NoAKDg1ZTZmMzhlNzk3OTU5ZDJmNjVmOTA4Zjg4YTgxZDNlNjg5MWQ2MDk", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-27T09:01:16Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-27T09:05:14Z"}, "message": "assert that solver results are stable", "tree": {"sha": "f368353fc7354c82395c552bf90011816af1eecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f368353fc7354c82395c552bf90011816af1eecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85e6f38e797959d2f65f908f88a81d3e6891d609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85e6f38e797959d2f65f908f88a81d3e6891d609", "html_url": "https://github.com/rust-lang/rust/commit/85e6f38e797959d2f65f908f88a81d3e6891d609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85e6f38e797959d2f65f908f88a81d3e6891d609/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "html_url": "https://github.com/rust-lang/rust/commit/9c3fe58917cbd06c7747fe2c2b09bf85636207ae"}], "stats": {"total": 54, "additions": 46, "deletions": 8}, "files": [{"sha": "ca14fe0a8c8f06521557a3c0b391c65185b59f6d", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=85e6f38e797959d2f65f908f88a81d3e6891d609", "patch": "@@ -174,6 +174,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n             search_graph: &mut search_graph,\n             infcx: self,\n             var_values: CanonicalVarValues::dummy(),\n+            in_projection_eq_hack: false,\n         }\n         .evaluate_goal(goal);\n \n@@ -187,6 +188,10 @@ struct EvalCtxt<'a, 'tcx> {\n     var_values: CanonicalVarValues<'tcx>,\n \n     search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+\n+    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    in_projection_eq_hack: bool,\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -213,7 +218,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         loop {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let mut ecx =\n+                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n             let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n@@ -243,10 +249,28 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-        Ok((\n-            !canonical_response.value.var_values.is_identity(),\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n-        ))\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty =\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions) && has_changed && !self.in_projection_eq_hack {\n+            let mut orig_values = OriginalQueryValues::default();\n+            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            assert!(canonical_response.value.var_values.is_identity());\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {"}, {"sha": "83fcdf496c85a77973b1ec0bcabb28472260c22d", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=85e6f38e797959d2f65f908f88a81d3e6891d609", "patch": "@@ -45,8 +45,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n             });\n-            let (_has_changed, normalize_certainty) =\n-                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n+                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n+            })?;\n \n             let nested_eq_goals =\n                 self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n@@ -55,6 +56,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.in_projection_eq_hack = true;\n+        let result = f(self);\n+        self.in_projection_eq_hack = false;\n+        result\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe"}, {"sha": "7514c7ee55170482df63a66136f376b39492629f", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85e6f38e797959d2f65f908f88a81d3e6891d609/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=85e6f38e797959d2f65f908f88a81d3e6891d609", "patch": "@@ -45,6 +45,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// Tries putting the new goal on the stack, returning an error if it is already cached.\n     ///\n     /// This correctly updates the provisional cache if there is a cycle.\n+    #[instrument(level = \"debug\", skip(self, tcx), ret)]\n     pub(super) fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -79,8 +80,10 @@ impl<'tcx> SearchGraph<'tcx> {\n             Entry::Occupied(entry_index) => {\n                 let entry_index = *entry_index.get();\n \n-                cache.add_dependency_of_leaf_on(entry_index);\n                 let stack_depth = cache.depth(entry_index);\n+                debug!(\"encountered cycle with depth {stack_depth:?}\");\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n \n                 self.stack[stack_depth].has_been_used = true;\n                 // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n@@ -117,6 +120,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n     pub(super) fn try_finalize_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,"}]}