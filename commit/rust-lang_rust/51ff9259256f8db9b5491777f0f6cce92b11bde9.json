{"sha": "51ff9259256f8db9b5491777f0f6cce92b11bde9", "node_id": "C_kwDOAAsO6NoAKDUxZmY5MjU5MjU2ZjhkYjliNTQ5MTc3N2YwZjZjY2U5MmIxMWJkZTk", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-11-24T00:43:02Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-11-24T02:11:48Z"}, "message": "impl assign.rs<U> for Simd<T, _>\n\nInstead of implementing {Op}Assign traits for individual scalar type args\nto Simd<_, _>, use parametric impls that reassert the bounds of the binary op.", "tree": {"sha": "f71397238ed2af49ce9ef1ab759fd68a7ee8f374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f71397238ed2af49ce9ef1ab759fd68a7ee8f374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ff9259256f8db9b5491777f0f6cce92b11bde9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ff9259256f8db9b5491777f0f6cce92b11bde9", "html_url": "https://github.com/rust-lang/rust/commit/51ff9259256f8db9b5491777f0f6cce92b11bde9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ff9259256f8db9b5491777f0f6cce92b11bde9/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6992f5bfb6a2e879d23ff015ae27e2534095aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6992f5bfb6a2e879d23ff015ae27e2534095aa", "html_url": "https://github.com/rust-lang/rust/commit/0a6992f5bfb6a2e879d23ff015ae27e2534095aa"}], "stats": {"total": 290, "additions": 136, "deletions": 154}, "files": [{"sha": "aee5a111a82f26ed0ca792714aaf8fd4c1a7b4ec", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 12, "deletions": 154, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9259256f8db9b5491777f0f6cce92b11bde9/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9259256f8db9b5491777f0f6cce92b11bde9/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=51ff9259256f8db9b5491777f0f6cce92b11bde9", "patch": "@@ -5,6 +5,7 @@ use core::ops::{BitAnd, BitOr, BitXor};\n use core::ops::{Div, Rem, Sub};\n use core::ops::{Shl, Shr};\n \n+mod assign;\n mod deref;\n \n impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n@@ -65,25 +66,6 @@ macro_rules! impl_ref_ops {\n         }\n     };\n \n-    // binary assignment op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            $(#[$attrs:meta])*\n-            fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            $(#[$attrs])*\n-            fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n-        }\n-    };\n-\n     // unary op\n     {\n         impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n@@ -107,34 +89,34 @@ macro_rules! impl_ref_ops {\n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n     { impl Add for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n+        impl_op! { @binary $scalar, Add::add, simd_add }\n     };\n     { impl Sub for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+        impl_op! { @binary $scalar, Sub::sub, simd_sub }\n     };\n     { impl Mul for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+        impl_op! { @binary $scalar, Mul::mul, simd_mul }\n     };\n     { impl Div for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n+        impl_op! { @binary $scalar, Div::div, simd_div }\n     };\n     { impl Rem for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+        impl_op! { @binary $scalar, Rem::rem, simd_rem }\n     };\n     { impl Shl for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+        impl_op! { @binary $scalar, Shl::shl, simd_shl }\n     };\n     { impl Shr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+        impl_op! { @binary $scalar, Shr::shr, simd_shr }\n     };\n     { impl BitAnd for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+        impl_op! { @binary $scalar, BitAnd::bitand, simd_and }\n     };\n     { impl BitOr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+        impl_op! { @binary $scalar, BitOr::bitor, simd_or }\n     };\n     { impl BitXor for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n+        impl_op! { @binary $scalar, BitXor::bitxor, simd_xor }\n     };\n \n     { impl Not for $scalar:ty } => {\n@@ -166,7 +148,7 @@ macro_rules! impl_op {\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n             where\n@@ -210,32 +192,6 @@ macro_rules! impl_op {\n                 }\n             }\n         }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: Self) {\n-                    unsafe {\n-                        *self = intrinsics::$intrinsic(*self, rhs);\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: $scalar) {\n-                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n-                }\n-            }\n-        }\n     };\n }\n \n@@ -331,30 +287,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: Self) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: $scalar) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n             // remainder panics on zero divisor\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n@@ -421,30 +353,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: Self) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: $scalar) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n             // shifts panic on overflow\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n@@ -486,31 +394,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: Self) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: $scalar) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n                 where\n@@ -550,31 +433,6 @@ macro_rules! impl_unsigned_int_ops {\n                     }\n                 }\n             }\n-\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: Self) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: $scalar) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n         )*\n     };\n }"}, {"sha": "d2b48614fc96671296ac0a3380ec8232ee3dbb8f", "filename": "crates/core_simd/src/ops/assign.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9259256f8db9b5491777f0f6cce92b11bde9/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9259256f8db9b5491777f0f6cce92b11bde9/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs?ref=51ff9259256f8db9b5491777f0f6cce92b11bde9", "patch": "@@ -0,0 +1,124 @@\n+//! Assignment operators\n+use super::*;\n+use core::ops::{AddAssign, MulAssign}; // commutative binary op-assignment\n+use core::ops::{BitAndAssign, BitOrAssign, BitXorAssign}; // commutative bit binary op-assignment\n+use core::ops::{DivAssign, RemAssign, SubAssign}; // non-commutative binary op-assignment\n+use core::ops::{ShlAssign, ShrAssign}; // non-commutative bit binary op-assignment\n+\n+// Arithmetic\n+\n+macro_rules! assign_ops {\n+    ($(impl<T, U, const LANES: usize> $assignTrait:ident<U> for Simd<T, LANES>\n+        where\n+            Self: $trait:ident,\n+        {\n+            fn $assign_call:ident(rhs: U) {\n+                $call:ident\n+            }\n+        })*) => {\n+        $(impl<T, U, const LANES: usize> $assignTrait<U> for Simd<T, LANES>\n+        where\n+            Self: $trait<U, Output = Self>,\n+            T: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn $assign_call(&mut self, rhs: U) {\n+                *self = self.$call(rhs);\n+            }\n+        })*\n+    }\n+}\n+\n+assign_ops! {\n+    // Arithmetic\n+    impl<T, U, const LANES: usize> AddAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Add,\n+    {\n+        fn add_assign(rhs: U) {\n+            add\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> MulAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Mul,\n+    {\n+        fn mul_assign(rhs: U) {\n+            mul\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> SubAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Sub,\n+    {\n+        fn sub_assign(rhs: U) {\n+            sub\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> DivAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Div,\n+    {\n+        fn div_assign(rhs: U) {\n+            div\n+        }\n+    }\n+    impl<T, U, const LANES: usize> RemAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Rem,\n+    {\n+        fn rem_assign(rhs: U) {\n+            rem\n+        }\n+    }\n+\n+    // Bitops\n+    impl<T, U, const LANES: usize> BitAndAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitAnd,\n+    {\n+        fn bitand_assign(rhs: U) {\n+            bitand\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitOrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitOr,\n+    {\n+        fn bitor_assign(rhs: U) {\n+            bitor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitXorAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitXor,\n+    {\n+        fn bitxor_assign(rhs: U) {\n+            bitxor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShlAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shl,\n+    {\n+        fn shl_assign(rhs: U) {\n+            shl\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shr,\n+    {\n+        fn shr_assign(rhs: U) {\n+            shr\n+        }\n+    }\n+}"}]}