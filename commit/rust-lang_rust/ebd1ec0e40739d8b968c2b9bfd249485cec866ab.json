{"sha": "ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZDFlYzBlNDA3MzlkOGI5NjhjMmI5YmZkMjQ5NDg1Y2VjODY2YWI=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T08:15:18Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T08:17:04Z"}, "message": "Move cast_ptr_alignment to its own module", "tree": {"sha": "e3d83bd9cbb3b7449e55c087b3636049710c8b6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d83bd9cbb3b7449e55c087b3636049710c8b6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "html_url": "https://github.com/rust-lang/rust/commit/ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebd1ec0e40739d8b968c2b9bfd249485cec866ab/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a24877e2cd68f22edd3de4a44f59c9899953f91", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a24877e2cd68f22edd3de4a44f59c9899953f91", "html_url": "https://github.com/rust-lang/rust/commit/9a24877e2cd68f22edd3de4a44f59c9899953f91"}], "stats": {"total": 148, "additions": 85, "deletions": 63}, "files": [{"sha": "87fb5557be066abf082b02f672dec71963d7d668", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ebd1ec0e40739d8b968c2b9bfd249485cec866ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd1ec0e40739d8b968c2b9bfd249485cec866ab/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "patch": "@@ -0,0 +1,81 @@\n+use rustc_hir::{Expr, ExprKind, GenericArg};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{is_hir_ty_cfg_dependant, span_lint};\n+\n+use super::CAST_PTR_ALIGNMENT;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+        if is_hir_ty_cfg_dependant(cx, cast_to) {\n+            return;\n+        }\n+        let (cast_from, cast_to) = (\n+            cx.typeck_results().expr_ty(cast_expr),\n+            cx.typeck_results().expr_ty(expr),\n+        );\n+        lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+    } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+        if_chain! {\n+            if method_path.ident.name == sym!(cast);\n+            if let Some(generic_args) = method_path.args;\n+            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n+            if !is_hir_ty_cfg_dependant(cx, cast_to);\n+            then {\n+                let (cast_from, cast_to) =\n+                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+    if_chain! {\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n+        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n+        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n+        if from_layout.align.abi < to_layout.align.abi;\n+        // with c_void, we inherently need to trust the user\n+        if !is_c_void(cx, from_ptr_ty.ty);\n+        // when casting from a ZST, we don't know enough to properly lint\n+        if !from_layout.is_zst();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_PTR_ALIGNMENT,\n+                expr.span,\n+                &format!(\n+                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                    cast_from,\n+                    cast_to,\n+                    from_layout.align.abi.bytes(),\n+                    to_layout.align.abi.bytes(),\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Check if the given type is either `core::ffi::c_void` or\n+/// one of the platform specific `libc::<platform>::c_void` of libc.\n+fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind() {\n+        let names = cx.get_def_path(adt.did);\n+\n+        if names.is_empty() {\n+            return false;\n+        }\n+        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "cf8a64e1fd847060189075d7b4bb835764183017", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 4, "deletions": 63, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ebd1ec0e40739d8b968c2b9bfd249485cec866ab/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd1ec0e40739d8b968c2b9bfd249485cec866ab/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=ebd1ec0e40739d8b968c2b9bfd249485cec866ab", "patch": "@@ -2,6 +2,7 @@ mod cast_lossless;\n mod cast_possible_truncation;\n mod cast_possible_wrap;\n mod cast_precision_loss;\n+mod cast_ptr_alignment;\n mod cast_sign_loss;\n mod fn_to_numeric_cast;\n mod fn_to_numeric_cast_with_truncation;\n@@ -13,22 +14,18 @@ use std::borrow::Cow;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, GenericArg, MutTy, Mutability, TyKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, MutTy, Mutability, TyKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty, TypeAndMut, UintTy};\n+use rustc_middle::ty::{self, TypeAndMut, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::sym;\n-use rustc_target::abi::LayoutOf;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n     is_hir_ty_cfg_dependant, meets_msrv, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n };\n \n-use utils::int_ty_to_nbits;\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for casts from any numerical to a float type where\n     /// the receiving type cannot store all values from the original type without\n@@ -270,22 +267,6 @@ declare_lint_pass!(Casts => [\n     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n ]);\n \n-/// Check if the given type is either `core::ffi::c_void` or\n-/// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for Casts {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n@@ -306,56 +287,16 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n \n             fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n-            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n                 cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n                 cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n                 cast_precision_loss::check(cx, expr, cast_from, cast_to);\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to);\n                 cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n             }\n-        } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n-            if_chain! {\n-            if method_path.ident.name == sym!(cast);\n-            if let Some(generic_args) = method_path.args;\n-            if let [GenericArg::Type(cast_to)] = generic_args.args;\n-            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n-            if !is_hir_ty_cfg_dependant(cx, cast_to);\n-            then {\n-                let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n-                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-            }\n-            }\n         }\n-    }\n-}\n \n-fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n-    if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n-        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-        if from_layout.align.abi < to_layout.align.abi;\n-        // with c_void, we inherently need to trust the user\n-        if !is_c_void(cx, from_ptr_ty.ty);\n-        // when casting from a ZST, we don't know enough to properly lint\n-        if !from_layout.is_zst();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_PTR_ALIGNMENT,\n-                expr.span,\n-                &format!(\n-                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                    cast_from,\n-                    cast_to,\n-                    from_layout.align.abi.bytes(),\n-                    to_layout.align.abi.bytes(),\n-                ),\n-            );\n-        }\n+        cast_ptr_alignment::check(cx, expr);\n     }\n }\n "}]}