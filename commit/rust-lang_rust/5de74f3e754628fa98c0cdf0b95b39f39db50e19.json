{"sha": "5de74f3e754628fa98c0cdf0b95b39f39db50e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTc0ZjNlNzU0NjI4ZmE5OGMwY2RmMGI5NWIzOWYzOWRiNTBlMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T19:09:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T19:09:35Z"}, "message": "auto merge of #6070 : thestinger/rust/tutorial, r=pcwalton", "tree": {"sha": "617c8236034c826be26df695b3d1a159207bba77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617c8236034c826be26df695b3d1a159207bba77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de74f3e754628fa98c0cdf0b95b39f39db50e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de74f3e754628fa98c0cdf0b95b39f39db50e19", "html_url": "https://github.com/rust-lang/rust/commit/5de74f3e754628fa98c0cdf0b95b39f39db50e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de74f3e754628fa98c0cdf0b95b39f39db50e19/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ea32a380d84affbe979b91980f8179cee8925b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea32a380d84affbe979b91980f8179cee8925b9", "html_url": "https://github.com/rust-lang/rust/commit/9ea32a380d84affbe979b91980f8179cee8925b9"}, {"sha": "195911fca412527472233aee163782c3bca11517", "url": "https://api.github.com/repos/rust-lang/rust/commits/195911fca412527472233aee163782c3bca11517", "html_url": "https://github.com/rust-lang/rust/commit/195911fca412527472233aee163782c3bca11517"}], "stats": {"total": 200, "additions": 101, "deletions": 99}, "files": [{"sha": "127f81589234f8e2ae392105c0ec73968f5e9773", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5de74f3e754628fa98c0cdf0b95b39f39db50e19/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5de74f3e754628fa98c0cdf0b95b39f39db50e19/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=5de74f3e754628fa98c0cdf0b95b39f39db50e19", "patch": "@@ -139,6 +139,74 @@ pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n+# Destructors\n+\n+Foreign libraries often hand off ownership of resources to the calling code,\n+which should be wrapped in a destructor to provide safety and guarantee their\n+release.\n+\n+A type with the same functionality as owned boxes can be implemented by\n+wrapping `malloc` and `free`:\n+\n+~~~~\n+use core::libc::{c_void, size_t, malloc, free};\n+\n+#[abi = \"rust-intrinsic\"]\n+extern \"rust-intrinsic\" mod rusti {\n+    fn init<T>() -> T;\n+}\n+\n+// a wrapper around the handle returned by the foreign code\n+pub struct Unique<T> {\n+    priv ptr: *mut T\n+}\n+\n+pub impl<'self, T: Owned> Unique<T> {\n+    fn new(value: T) -> Unique<T> {\n+        unsafe {\n+            let ptr = malloc(core::sys::size_of::<T>() as size_t) as *mut T;\n+            assert!(!ptr::is_null(ptr));\n+            *ptr = value;\n+            Unique{ptr: ptr}\n+        }\n+    }\n+\n+    // the 'self lifetime results in the same semantics as `&*x` with ~T\n+    fn borrow(&self) -> &'self T {\n+        unsafe { cast::transmute(self.ptr) }\n+    }\n+\n+    // the 'self lifetime results in the same semantics as `&mut *x` with ~T\n+    fn borrow_mut(&mut self) -> &'self mut T {\n+        unsafe { cast::transmute(self.ptr) }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Owned> Drop for Unique<T> {\n+    fn finalize(&self) {\n+        unsafe {\n+            let mut x = rusti::init(); // dummy value to swap in\n+            x <-> *self.ptr; // moving the object out is needed to call the destructor\n+            free(self.ptr as *c_void)\n+        }\n+    }\n+}\n+\n+// A comparison between the built-in ~ and this reimplementation\n+fn main() {\n+    {\n+        let mut x = ~5;\n+        *x = 10;\n+    } // `x` is freed here\n+\n+    {\n+        let mut y = Unique::new(5);\n+        *y.borrow_mut() = 10;\n+    } // `y` is freed here\n+}\n+~~~~\n+\n # Linking\n \n In addition to the `#[link_args]` attribute for explicitly passing arguments to the linker, an"}, {"sha": "c757329a45f0609ec80a6cd544aac41e24b45775", "filename": "doc/tutorial.md", "status": "modified", "additions": 33, "deletions": 99, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5de74f3e754628fa98c0cdf0b95b39f39db50e19/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5de74f3e754628fa98c0cdf0b95b39f39db50e19/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=5de74f3e754628fa98c0cdf0b95b39f39db50e19", "patch": "@@ -868,108 +868,27 @@ fn first((value, _): (int, float)) -> int { value }\n \n # Destructors\n \n-C-style resource management requires the programmer to match every allocation\n-with a free, which means manually tracking the responsibility for cleaning up\n-(the owner). Correctness is left to the programmer, and it's easy to get wrong.\n+A *destructor* is a function responsible for cleaning up the resources used by\n+an object when it is no longer accessible. Destructors can be defined to handle\n+the release of resources like files, sockets and heap memory.\n \n-The following code demonstrates manual memory management, in order to contrast\n-it with Rust's resource management. Rust enforces safety, so the `unsafe`\n-keyword is used to explicitly wrap the unsafe code. The keyword is a promise to\n-the compiler that unsafety does not leak outside of the unsafe block, and is\n-used to create safe concepts on top of low-level code.\n+Objects are never accessible after their destructor has been called, so there\n+are no dynamic failures from accessing freed resources. When a task fails, the\n+destructors of all objects in the task are called.\n \n-~~~~\n-use core::libc::{calloc, free, size_t};\n-\n-fn main() {\n-    unsafe {\n-        let a = calloc(1, int::bytes as size_t);\n-\n-        let d;\n+The `~` sigil represents a unique handle for a memory allocation on the heap:\n \n-        {\n-            let b = calloc(1, int::bytes as size_t);\n-\n-            let c = calloc(1, int::bytes as size_t);\n-            d = c; // move ownership to d\n-\n-            free(b);\n-        }\n-\n-        free(d);\n-        free(a);\n-    }\n-}\n ~~~~\n-\n-Rust uses destructors to handle the release of resources like memory\n-allocations, files and sockets. An object will only be destroyed when there is\n-no longer any way to access it, which prevents dynamic failures from an attempt\n-to use a freed resource. When a task fails, the stack unwinds and the\n-destructors of all objects owned by that task are called.\n-\n-The unsafe code from above can be contained behind a safe API that prevents\n-memory leaks or use-after-free:\n-\n-~~~~\n-use core::libc::{calloc, free, c_void, size_t};\n-\n-struct Blob { priv ptr: *c_void }\n-\n-impl Blob {\n-    fn new() -> Blob {\n-        unsafe { Blob{ptr: calloc(1, int::bytes as size_t)} }\n-    }\n-}\n-\n-impl Drop for Blob {\n-    fn finalize(&self) {\n-        unsafe { free(self.ptr); }\n-    }\n-}\n-\n-fn main() {\n-    let a = Blob::new();\n-\n-    let d;\n-\n-    {\n-        let b = Blob::new();\n-\n-        let c = Blob::new();\n-        d = c; // move ownership to d\n-\n-        // b is destroyed here\n-    }\n-\n-    // d is destroyed here\n-    // a is destroyed here\n+{\n+    // an integer allocated on the heap\n+    let y = ~10;\n }\n+// the destructor frees the heap memory as soon as `y` goes out of scope\n ~~~~\n \n-This pattern is common enough that Rust includes dynamically allocated memory\n-as first-class types (`~` and `@`). Non-memory resources like files are cleaned\n-up with custom destructors.\n-\n-~~~~\n-fn main() {\n-    let a = ~0;\n-\n-    let d;\n-\n-    {\n-        let b = ~0;\n-\n-        let c = ~0;\n-        d = c; // move ownership to d\n-\n-        // b is destroyed here\n-    }\n-\n-    // d is destroyed here\n-    // a is destroyed here\n-}\n-~~~~\n+Rust includes syntax for heap memory allocation in the language since it's\n+commonly used, but the same semantics can be implemented by a type with a\n+custom destructor.\n \n # Ownership\n \n@@ -984,6 +903,22 @@ and destroy the contained object when they go out of scope. A box managed by\n the garbage collector starts a new ownership tree, and the destructor is called\n when it is collected.\n \n+~~~~\n+// the struct owns the objects contained in the `x` and `y` fields\n+struct Foo { x: int, y: ~int }\n+\n+{\n+    // `a` is the owner of the struct, and thus the owner of the struct's fields\n+    let a = Foo { x: 5, y: ~10 };\n+}\n+// when `a` goes out of scope, the destructor for the `~int` in the struct's\n+// field is called\n+\n+// `b` is mutable, and the mutability is inherited by the objects it owns\n+let mut b = Foo { x: 5, y: ~10 };\n+b.x = 10;\n+~~~~\n+\n If an object doesn't contain garbage-collected boxes, it consists of a single\n ownership tree and is given the `Owned` trait which allows it to be sent\n between tasks. Custom destructors can only be implemented directly on types\n@@ -1007,7 +942,7 @@ refer to that through a pointer.\n ## Owned boxes\n \n An owned box (`~`) is a uniquely owned allocation on the heap. It inherits the\n-mutability and lifetime of the owner as it would if there was no box.\n+mutability and lifetime of the owner as it would if there was no box:\n \n ~~~~\n let x = 5; // immutable\n@@ -1021,8 +956,8 @@ let mut y = ~5; // mutable\n \n The purpose of an owned box is to add a layer of indirection in order to create\n recursive data structures or cheaply pass around an object larger than a\n-pointer. Since an owned box has a unique owner, it can be used to represent any\n-tree data structure.\n+pointer. Since an owned box has a unique owner, it can only be used to\n+represent a tree data structure.\n \n The following struct won't compile, because the lack of indirection would mean\n it has an infinite size:\n@@ -1092,7 +1027,6 @@ d = b;          // box type is the same, okay\n c = b;          // error\n ~~~~\n \n-\n # Move semantics\n \n Rust uses a shallow copy for parameter passing, assignment and returning values"}]}