{"sha": "d54477e97415c8c4931533f98ebf2704cd60e9b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NDQ3N2U5NzQxNWM4YzQ5MzE1MzNmOThlYmYyNzA0Y2Q2MGU5YjQ=", "commit": {"author": {"name": "Alexey Shmalko", "email": "rasen.dubi@gmail.com", "date": "2019-05-01T19:01:01Z"}, "committer": {"name": "Alexey Shmalko", "email": "rasen.dubi@gmail.com", "date": "2019-05-02T13:38:29Z"}, "message": "Address review comments", "tree": {"sha": "ad31086d64c38baa73c5dc75384648dba8a79d56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad31086d64c38baa73c5dc75384648dba8a79d56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54477e97415c8c4931533f98ebf2704cd60e9b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54477e97415c8c4931533f98ebf2704cd60e9b4", "html_url": "https://github.com/rust-lang/rust/commit/d54477e97415c8c4931533f98ebf2704cd60e9b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54477e97415c8c4931533f98ebf2704cd60e9b4/comments", "author": {"login": "rasendubi", "id": 1366419, "node_id": "MDQ6VXNlcjEzNjY0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1366419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasendubi", "html_url": "https://github.com/rasendubi", "followers_url": "https://api.github.com/users/rasendubi/followers", "following_url": "https://api.github.com/users/rasendubi/following{/other_user}", "gists_url": "https://api.github.com/users/rasendubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasendubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasendubi/subscriptions", "organizations_url": "https://api.github.com/users/rasendubi/orgs", "repos_url": "https://api.github.com/users/rasendubi/repos", "events_url": "https://api.github.com/users/rasendubi/events{/privacy}", "received_events_url": "https://api.github.com/users/rasendubi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasendubi", "id": 1366419, "node_id": "MDQ6VXNlcjEzNjY0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1366419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasendubi", "html_url": "https://github.com/rasendubi", "followers_url": "https://api.github.com/users/rasendubi/followers", "following_url": "https://api.github.com/users/rasendubi/following{/other_user}", "gists_url": "https://api.github.com/users/rasendubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasendubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasendubi/subscriptions", "organizations_url": "https://api.github.com/users/rasendubi/orgs", "repos_url": "https://api.github.com/users/rasendubi/repos", "events_url": "https://api.github.com/users/rasendubi/events{/privacy}", "received_events_url": "https://api.github.com/users/rasendubi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5ba6d4b3cef4f7f54295d3a475411cedf1254fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ba6d4b3cef4f7f54295d3a475411cedf1254fb", "html_url": "https://github.com/rust-lang/rust/commit/d5ba6d4b3cef4f7f54295d3a475411cedf1254fb"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "c7a109e05098743f7d79b36f2cf4f2ecb98b0c40", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d54477e97415c8c4931533f98ebf2704cd60e9b4/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54477e97415c8c4931533f98ebf2704cd60e9b4/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=d54477e97415c8c4931533f98ebf2704cd60e9b4", "patch": "@@ -20,8 +20,8 @@ use regex::{Regex, escape};\n mod version;\n use self::version::Version;\n \n-const FEATURE_GROUP_START_PREFIX: &str = \"// feature group start:\";\n-const FEATURE_GROUP_END_PREFIX: &str = \"// feature group end\";\n+const FEATURE_GROUP_START_PREFIX: &str = \"// feature-group-start:\";\n+const FEATURE_GROUP_END_PREFIX: &str = \"// feature-group-end\";\n \n #[derive(Debug, PartialEq, Clone)]\n pub enum Status {\n@@ -47,7 +47,6 @@ pub struct Feature {\n     pub since: Option<Version>,\n     pub has_gate_test: bool,\n     pub tracking_issue: Option<u32>,\n-    pub group: Option<String>,\n }\n \n pub type Features = HashMap<String, Feature>;\n@@ -139,31 +138,28 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n     }\n \n     let mut lines = Vec::new();\n-    for (name, feature) in features.iter() {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lang\",\n-                           feature.level,\n-                           feature.since.as_ref().map_or(\"None\".to_owned(),\n-                                                         |since| since.to_string())));\n-    }\n-    for (name, feature) in lib_features {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lib\",\n-                           feature.level,\n-                           feature.since.as_ref().map_or(\"None\".to_owned(),\n-                                                         |since| since.to_string())));\n-    }\n+    lines.extend(format_features(&features, \"lang\"));\n+    lines.extend(format_features(&lib_features, \"lib\"));\n \n     lines.sort();\n     for line in lines {\n         println!(\"* {}\", line);\n     }\n }\n \n+fn format_features<'a>(features: &'a Features, family: &'a str) -> impl Iterator<Item=String> + 'a {\n+    features.iter().map(move |(name, feature)| {\n+        format!(\"{:<32} {:<8} {:<12} {:<8}\",\n+                name,\n+                family,\n+                feature.level,\n+                feature.since.as_ref().map_or(\"None\".to_owned(),\n+                                              |since| since.to_string()))\n+    })\n+}\n+\n fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n-    let r = Regex::new(&format!(r#\"{} *= *\"([^\"]*)\"\"#, escape(attr)))\n+    let r = Regex::new(&format!(r#\"{}\\s*=\\s*\"([^\"]*)\"\"#, escape(attr)))\n         .expect(\"malformed regex for find_attr_val\");\n     r.captures(line)\n         .and_then(|c| c.get(1))\n@@ -219,6 +215,15 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n             }\n \n             if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+                if next_feature_group.is_some() {\n+                    tidy_error!(\n+                        bad,\n+                        // ignore-tidy-linelength\n+                        \"libsyntax/feature_gate.rs:{}: new feature group is started without ending the previous one\",\n+                        line_number,\n+                    );\n+                }\n+\n                 let group = line.trim_start_matches(FEATURE_GROUP_START_PREFIX).trim();\n                 next_feature_group = Some(group.to_owned());\n                 prev_since = None;\n@@ -286,7 +291,6 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                     since,\n                     has_gate_test: false,\n                     tracking_issue,\n-                    group: next_feature_group.clone(),\n                 }))\n         })\n         .collect()\n@@ -304,7 +308,6 @@ pub fn collect_lib_features(base_src_path: &Path) -> Features {\n         since: None,\n         has_gate_test: false,\n         tracking_issue: None,\n-        group: None,\n     });\n \n     map_lib_features(base_src_path,\n@@ -399,7 +402,7 @@ fn map_lib_features(base_src_path: &Path,\n                 // `const fn` features are handled specially.\n                 let feature_name = match find_attr_val(line, \"feature\") {\n                     Some(name) => name,\n-                    None => err!(\"malformed stability attribute\"),\n+                    None => err!(\"malformed stability attribute: missing `feature` key\"),\n                 };\n                 let feature = Feature {\n                     level: Status::Unstable,\n@@ -409,7 +412,6 @@ fn map_lib_features(base_src_path: &Path,\n                     // although we would like to have specific tracking issues for each\n                     // `rustc_const_unstable` in the future.\n                     tracking_issue: Some(57563),\n-                    group: None,\n                 };\n                 mf(Ok((feature_name, feature)), file, i + 1);\n                 continue;\n@@ -423,15 +425,15 @@ fn map_lib_features(base_src_path: &Path,\n             };\n             let feature_name = match find_attr_val(line, \"feature\") {\n                 Some(name) => name,\n-                None => err!(\"malformed stability attribute\"),\n+                None => err!(\"malformed stability attribute: missing `feature` key\"),\n             };\n             let since = match find_attr_val(line, \"since\").map(|x| x.parse()) {\n                 Some(Ok(since)) => Some(since),\n                 Some(Err(_err)) => {\n-                    err!(\"malformed since attribute\");\n+                    err!(\"malformed stability attribute: can't parse `since` key\");\n                 },\n                 None if level == Status::Stable => {\n-                    err!(\"malformed stability attribute\");\n+                    err!(\"malformed stability attribute: missing the `since` key\");\n                 }\n                 None => None,\n             };\n@@ -442,7 +444,6 @@ fn map_lib_features(base_src_path: &Path,\n                 since,\n                 has_gate_test: false,\n                 tracking_issue,\n-                group: None,\n             };\n             if line.contains(']') {\n                 mf(Ok((feature_name, feature)), file, i + 1);"}]}