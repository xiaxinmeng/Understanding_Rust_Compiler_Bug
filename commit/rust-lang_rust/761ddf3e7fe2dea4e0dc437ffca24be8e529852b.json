{"sha": "761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "node_id": "C_kwDOAAsO6NoAKDc2MWRkZjNlN2ZlMmRlYTRlMGRjNDM3ZmZjYTI0YmU4ZTUyOTg1MmI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-01T01:55:19Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-24T16:50:05Z"}, "message": "Remove some redundant checks from BufReader\n\nThe implementation of BufReader contains a lot of redundant checks.\nWhile any one of these checks is not particularly expensive to execute,\nespecially when taken together they dramatically inhibit LLVM's ability\nto make subsequent optimizations.", "tree": {"sha": "1b4f19b40e110ef9b9285c007755c6623850e628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4f19b40e110ef9b9285c007755c6623850e628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "html_url": "https://github.com/rust-lang/rust/commit/761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4151a41a0b275dee59ffbbc115e7bfc5be8a8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4151a41a0b275dee59ffbbc115e7bfc5be8a8c3", "html_url": "https://github.com/rust-lang/rust/commit/b4151a41a0b275dee59ffbbc115e7bfc5be8a8c3"}], "stats": {"total": 159, "additions": 106, "deletions": 53}, "files": [{"sha": "1569b0415c606ef8478e6bcef4907352e245e66d", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 30, "deletions": 53, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "patch": "@@ -1,9 +1,10 @@\n-use crate::cmp;\n+mod buffer;\n+\n use crate::fmt;\n use crate::io::{\n     self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n };\n-use crate::mem::MaybeUninit;\n+use buffer::Buffer;\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n ///\n@@ -48,10 +49,7 @@ use crate::mem::MaybeUninit;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n-    buf: Box<[MaybeUninit<u8>]>,\n-    pos: usize,\n-    cap: usize,\n-    init: usize,\n+    buf: Buffer,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -93,8 +91,7 @@ impl<R: Read> BufReader<R> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n-        let buf = Box::new_uninit_slice(capacity);\n-        BufReader { inner, buf, pos: 0, cap: 0, init: 0 }\n+        BufReader { inner, buf: Buffer::with_capacity(capacity) }\n     }\n }\n \n@@ -170,8 +167,7 @@ impl<R> BufReader<R> {\n     /// ```\n     #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n-        // SAFETY: self.cap is always <= self.init, so self.buf[self.pos..self.cap] is always init\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[self.pos..self.cap]) }\n+        self.buf.buffer()\n     }\n \n     /// Returns the number of bytes the internal buffer can hold at once.\n@@ -194,7 +190,7 @@ impl<R> BufReader<R> {\n     /// ```\n     #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.buf.len()\n+        self.buf.capacity()\n     }\n \n     /// Unwraps this `BufReader<R>`, returning the underlying reader.\n@@ -224,8 +220,7 @@ impl<R> BufReader<R> {\n     /// Invalidates all data in the internal buffer.\n     #[inline]\n     fn discard_buffer(&mut self) {\n-        self.pos = 0;\n-        self.cap = 0;\n+        self.buf.discard_buffer()\n     }\n }\n \n@@ -236,15 +231,15 @@ impl<R: Seek> BufReader<R> {\n     /// must track this information themselves if it is required.\n     #[stable(feature = \"bufreader_seek_relative\", since = \"1.53.0\")]\n     pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n-        let pos = self.pos as u64;\n+        let pos = self.buf.pos() as u64;\n         if offset < 0 {\n-            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n-                self.pos = new_pos as usize;\n+            if let Some(_) = pos.checked_sub((-offset) as u64) {\n+                self.buf.unconsume((-offset) as usize);\n                 return Ok(());\n             }\n         } else if let Some(new_pos) = pos.checked_add(offset as u64) {\n-            if new_pos <= self.cap as u64 {\n-                self.pos = new_pos as usize;\n+            if new_pos <= self.buf.cap() as u64 {\n+                self.buf.consume(offset as usize);\n                 return Ok(());\n             }\n         }\n@@ -259,7 +254,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n+        if self.buf.pos() == self.buf.cap() && buf.len() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read(buf);\n         }\n@@ -275,7 +270,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.pos == self.cap && buf.remaining() >= self.buf.len() {\n+        if self.buf.pos() == self.buf.cap() && buf.remaining() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_buf(buf);\n         }\n@@ -295,9 +290,9 @@ impl<R: Read> Read for BufReader<R> {\n     // generation for the common path where the buffer has enough bytes to fill the passed-in\n     // buffer.\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n-        if self.buffer().len() >= buf.len() {\n-            buf.copy_from_slice(&self.buffer()[..buf.len()]);\n-            self.consume(buf.len());\n+        if let Some(claimed) = self.buffer().get(..buf.len()) {\n+            buf.copy_from_slice(claimed);\n+            self.consume(claimed.len());\n             return Ok(());\n         }\n \n@@ -306,7 +301,7 @@ impl<R: Read> Read for BufReader<R> {\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.pos == self.cap && total_len >= self.buf.len() {\n+        if self.buf.pos() == self.buf.cap() && total_len >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_vectored(bufs);\n         }\n@@ -325,8 +320,9 @@ impl<R: Read> Read for BufReader<R> {\n     // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n     // delegate to the inner implementation.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let nread = self.cap - self.pos;\n-        buf.extend_from_slice(&self.buffer());\n+        let inner_buf = self.buffer();\n+        buf.extend_from_slice(inner_buf);\n+        let nread = inner_buf.len();\n         self.discard_buffer();\n         Ok(nread + self.inner.read_to_end(buf)?)\n     }\n@@ -371,33 +367,11 @@ impl<R: Read> Read for BufReader<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-        // If we've reached the end of our internal buffer then we need to fetch\n-        // some more data from the underlying reader.\n-        // Branch using `>=` instead of the more correct `==`\n-        // to tell the compiler that the pos..cap slice is always valid.\n-        if self.pos >= self.cap {\n-            debug_assert!(self.pos == self.cap);\n-\n-            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n-\n-            // SAFETY: `self.init` is either 0 or set to `readbuf.initialized_len()`\n-            // from the last time this function was called\n-            unsafe {\n-                readbuf.assume_init(self.init);\n-            }\n-\n-            self.inner.read_buf(&mut readbuf)?;\n-\n-            self.cap = readbuf.filled_len();\n-            self.init = readbuf.initialized_len();\n-\n-            self.pos = 0;\n-        }\n-        Ok(self.buffer())\n+        self.buf.fill_buf(&mut self.inner)\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        self.pos = cmp::min(self.pos + amt, self.cap);\n+        self.buf.consume(amt)\n     }\n }\n \n@@ -409,7 +383,10 @@ where\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n             .field(\"reader\", &self.inner)\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.buf.cap() - self.buf.pos(), self.capacity()),\n+            )\n             .finish()\n     }\n }\n@@ -441,7 +418,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         let result: u64;\n         if let SeekFrom::Current(n) = pos {\n-            let remainder = (self.cap - self.pos) as i64;\n+            let remainder = (self.buf.cap() - self.buf.pos()) as i64;\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n             // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n@@ -499,7 +476,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// }\n     /// ```\n     fn stream_position(&mut self) -> io::Result<u64> {\n-        let remainder = (self.cap - self.pos) as u64;\n+        let remainder = (self.buf.cap() - self.buf.pos()) as u64;\n         self.inner.stream_position().map(|pos| {\n             pos.checked_sub(remainder).expect(\n                 \"overflow when subtracting remaining buffer size from inner stream position\","}, {"sha": "92fe47745d932aa88cd0fbc73855798f01d9b1c9", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "patch": "@@ -0,0 +1,75 @@\n+use crate::cmp;\n+use crate::io::{self, Read, ReadBuf};\n+use crate::mem::MaybeUninit;\n+\n+pub struct Buffer {\n+    buf: Box<[MaybeUninit<u8>]>,\n+    pos: usize,\n+    cap: usize,\n+    init: usize,\n+}\n+\n+impl Buffer {\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        let buf = Box::new_uninit_slice(capacity);\n+        Self { buf, pos: 0, cap: 0, init: 0 }\n+    }\n+\n+    pub fn buffer(&self) -> &[u8] {\n+        // SAFETY: self.cap is always <= self.init, so self.buf[self.pos..self.cap] is always init\n+        // Additionally, both self.pos and self.cap are valid and and self.cap => self.pos, and\n+        // that region is initialized because those are all invariants of this type.\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf.get_unchecked(self.pos..self.cap)) }\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    pub fn cap(&self) -> usize {\n+        self.cap\n+    }\n+\n+    pub fn pos(&self) -> usize {\n+        self.pos\n+    }\n+\n+    pub fn discard_buffer(&mut self) {\n+        self.pos = 0;\n+        self.cap = 0;\n+    }\n+\n+    pub fn consume(&mut self, amt: usize) {\n+        self.pos = cmp::min(self.pos + amt, self.cap);\n+    }\n+\n+    pub fn unconsume(&mut self, amt: usize) {\n+        self.pos = self.pos.saturating_sub(amt);\n+    }\n+\n+    pub fn fill_buf(&mut self, mut reader: impl Read) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the underlying reader.\n+        // Branch using `>=` instead of the more correct `==`\n+        // to tell the compiler that the pos..cap slice is always valid.\n+        if self.pos >= self.cap {\n+            debug_assert!(self.pos == self.cap);\n+\n+            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n+\n+            // SAFETY: `self.init` is either 0 or set to `readbuf.initialized_len()`\n+            // from the last time this function was called\n+            unsafe {\n+                readbuf.assume_init(self.init);\n+            }\n+\n+            reader.read_buf(&mut readbuf)?;\n+\n+            self.cap = readbuf.filled_len();\n+            self.init = readbuf.initialized_len();\n+\n+            self.pos = 0;\n+        }\n+        Ok(self.buffer())\n+    }\n+}"}, {"sha": "fe45b1326384416239fd6c04ef767967698556fe", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/761ddf3e7fe2dea4e0dc437ffca24be8e529852b/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=761ddf3e7fe2dea4e0dc437ffca24be8e529852b", "patch": "@@ -523,6 +523,7 @@ fn bench_buffered_reader_small_reads(b: &mut test::Bencher) {\n         let mut buf = [0u8; 4];\n         for _ in 0..1024 {\n             reader.read_exact(&mut buf).unwrap();\n+            core::hint::black_box(&buf);\n         }\n     });\n }"}]}