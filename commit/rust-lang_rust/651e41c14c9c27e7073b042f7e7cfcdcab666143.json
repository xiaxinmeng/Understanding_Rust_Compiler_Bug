{"sha": "651e41c14c9c27e7073b042f7e7cfcdcab666143", "node_id": "C_kwDOAAsO6NoAKDY1MWU0MWMxNGM5YzI3ZTcwNzNiMDQyZjdlN2NmY2RjYWI2NjYxNDM", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-15T19:40:16Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-15T19:45:35Z"}, "message": "Move `TypeckResults` to seperate module", "tree": {"sha": "0c42998974389c7d8aca31b9336500f1625dbc46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c42998974389c7d8aca31b9336500f1625dbc46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/651e41c14c9c27e7073b042f7e7cfcdcab666143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/651e41c14c9c27e7073b042f7e7cfcdcab666143", "html_url": "https://github.com/rust-lang/rust/commit/651e41c14c9c27e7073b042f7e7cfcdcab666143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/651e41c14c9c27e7073b042f7e7cfcdcab666143/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "153419b78fcf12e4644f78a377b12ba6f74b758c", "url": "https://api.github.com/repos/rust-lang/rust/commits/153419b78fcf12e4644f78a377b12ba6f74b758c", "html_url": "https://github.com/rust-lang/rust/commit/153419b78fcf12e4644f78a377b12ba6f74b758c"}], "stats": {"total": 1392, "additions": 708, "deletions": 684}, "files": [{"sha": "173c5ed4feef0f9de96add81d3ddf7094fdacc5d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 11, "deletions": 680, "changes": 691, "blob_url": "https://github.com/rust-lang/rust/blob/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=651e41c14c9c27e7073b042f7e7cfcdcab666143", "patch": "@@ -4,8 +4,7 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n-use crate::hir::place::Place as HirPlace;\n-use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n+use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n@@ -18,13 +17,13 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n-    GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind, ReprOptions,\n-    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstS, DefIdTree, FloatTy, FloatVar,\n+    FloatVid, GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n+    ParamTy, PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind,\n+    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy,\n+    Visibility,\n };\n-use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n+use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -35,25 +34,20 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n-use rustc_data_structures::unord::UnordSet;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, LOCAL_CRATE};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_hir::hir_id::OwnerId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n-    Constness, ExprKind, HirId, ImplItemKind, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet,\n-    Node, TraitCandidate, TraitItemKind,\n+    Constness, ExprKind, HirId, ImplItemKind, ItemKind, Node, TraitCandidate, TraitItemKind,\n };\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n-use rustc_middle::mir::FakeReadCause;\n use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n@@ -75,16 +69,13 @@ use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlag\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::{self, Entry};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, RvalueScopes};\n-\n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n@@ -284,666 +275,6 @@ pub struct CommonConsts<'tcx> {\n     pub unit: Const<'tcx>,\n }\n \n-pub struct LocalTableInContext<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a ItemLocalMap<V>,\n-}\n-\n-/// Validate that the given HirId (respectively its `local_id` part) can be\n-/// safely used as a key in the maps of a TypeckResults. For that to be\n-/// the case, the HirId must have the same `owner` as all the other IDs in\n-/// this table (signified by `hir_owner`). Otherwise the HirId\n-/// would be in a different frame of reference and using its `local_id`\n-/// would result in lookup errors, or worse, in silently wrong data being\n-/// stored/returned.\n-#[inline]\n-fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    if hir_id.owner != hir_owner {\n-        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n-    }\n-}\n-\n-#[cold]\n-#[inline(never)]\n-fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n-    ty::tls::with(|tcx| {\n-        bug!(\n-            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n-            tcx.hir().node_to_string(hir_id),\n-            hir_id.owner,\n-            hir_owner\n-        )\n-    });\n-}\n-\n-impl<'a, V> LocalTableInContext<'a, V> {\n-    pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.contains_key(&id.local_id)\n-    }\n-\n-    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get(&id.local_id)\n-    }\n-\n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n-    }\n-}\n-\n-impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n-    type Output = V;\n-\n-    fn index(&self, key: hir::HirId) -> &V {\n-        self.get(key).expect(\"LocalTableInContext: key not found\")\n-    }\n-}\n-\n-pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: OwnerId,\n-    data: &'a mut ItemLocalMap<V>,\n-}\n-\n-impl<'a, V> LocalTableInContextMut<'a, V> {\n-    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.get_mut(&id.local_id)\n-    }\n-\n-    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.entry(id.local_id)\n-    }\n-\n-    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.insert(id.local_id, val)\n-    }\n-\n-    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.data.remove(&id.local_id)\n-    }\n-}\n-\n-/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n-/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n-/// captured types that can be useful for diagnostics. In particular, it stores the span that\n-/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n-/// be used to find the await that the value is live across).\n-///\n-/// For example:\n-///\n-/// ```ignore (pseudo-Rust)\n-/// async move {\n-///     let x: T = expr;\n-///     foo.await\n-///     ...\n-/// }\n-/// ```\n-///\n-/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n-/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct GeneratorInteriorTypeCause<'tcx> {\n-    /// Type of the captured binding.\n-    pub ty: Ty<'tcx>,\n-    /// Span of the binding that was captured.\n-    pub span: Span,\n-    /// Span of the scope of the captured binding.\n-    pub scope_span: Option<Span>,\n-    /// Span of `.await` or `yield` expression.\n-    pub yield_span: Span,\n-    /// Expr which the type evaluated from.\n-    pub expr: Option<hir::HirId>,\n-}\n-\n-// This type holds diagnostic information on generators and async functions across crate boundaries\n-// and is used to provide better error messages\n-#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n-pub struct GeneratorDiagnosticData<'tcx> {\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-    pub hir_owner: DefId,\n-    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n-    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-}\n-\n-#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n-pub struct TypeckResults<'tcx> {\n-    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: OwnerId,\n-\n-    /// Resolved definitions for `<T>::X` associated paths and\n-    /// method calls, including those of overloaded operators.\n-    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n-\n-    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n-    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n-    /// about the field you also need definition of the variant to which the field\n-    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n-    field_indices: ItemLocalMap<usize>,\n-\n-    /// Stores the types for various nodes in the AST. Note that this table\n-    /// is not guaranteed to be populated outside inference. See\n-    /// typeck::check::fn_ctxt for details.\n-    node_types: ItemLocalMap<Ty<'tcx>>,\n-\n-    /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node. This only applies to nodes that refer to entities\n-    /// parameterized by type parameters, such as generic fns, types, or\n-    /// other items.\n-    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n-\n-    /// This will either store the canonicalized types provided by the user\n-    /// or the substitutions that the user explicitly gave (if any) attached\n-    /// to `id`. These will not include any inferred values. The canonical form\n-    /// is used to capture things like `_` or other unspecified values.\n-    ///\n-    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n-    ///\n-    /// See also `AscribeUserType` statement in MIR.\n-    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n-\n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n-\n-    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n-\n-    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pat_binding_modes: ItemLocalMap<BindingMode>,\n-\n-    /// Stores the types which were implicitly dereferenced in pattern binding modes\n-    /// for later usage in THIR lowering. For example,\n-    ///\n-    /// ```\n-    /// match &&Some(5i32) {\n-    ///     Some(n) => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n-    ///\n-    /// See:\n-    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n-    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// Records the reasons that we picked the kind of each closure;\n-    /// not all closures are present in the map.\n-    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n-\n-    /// For each fn, records the \"liberated\" types of its arguments\n-    /// and return type. Liberated means that all bound regions\n-    /// (including late-bound regions) are replaced with free\n-    /// equivalents. This table is not used in codegen (since regions\n-    /// are erased there) and hence is not serialized to metadata.\n-    ///\n-    /// This table also contains the \"revealed\" values for any `impl Trait`\n-    /// that appear in the signature and whose values are being inferred\n-    /// by this function.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # use std::fmt::Debug;\n-    /// fn foo(x: &u32) -> impl Debug { *x }\n-    /// ```\n-    ///\n-    /// The function signature here would be:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// for<'a> fn(&'a u32) -> Foo\n-    /// ```\n-    ///\n-    /// where `Foo` is an opaque type created for this function.\n-    ///\n-    ///\n-    /// The *liberated* form of this would be\n-    ///\n-    /// ```ignore (illustrative)\n-    /// fn(&'a u32) -> u32\n-    /// ```\n-    ///\n-    /// Note that `'a` is not bound (it would be an `ReFree`) and\n-    /// that the `Foo` opaque type is replaced by its hidden type.\n-    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n-\n-    /// For each FRU expression, record the normalized types of the fields\n-    /// of the struct - this is needed because it is non-trivial to\n-    /// normalize while preserving regions. This table is used only in\n-    /// MIR construction and hence is not serialized to metadata.\n-    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n-\n-    /// For every coercion cast we add the HIR node ID of the cast\n-    /// expression to this set.\n-    coercion_casts: ItemLocalSet,\n-\n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports. During type\n-    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n-    /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n-\n-    /// If any errors occurred while type-checking this body,\n-    /// this field will be set to `Some(ErrorGuaranteed)`.\n-    pub tainted_by_errors: Option<ErrorGuaranteed>,\n-\n-    /// All the opaque types that have hidden types set\n-    /// by this function. We also store the\n-    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n-    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n-\n-    /// Tracks the minimum captures required for a closure;\n-    /// see `MinCaptureInformationMap` for more details.\n-    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n-\n-    /// Tracks the fake reads required for a closure and the reason for the fake read.\n-    /// When performing pattern matching for closures, there are times we don't end up\n-    /// reading places that are mentioned in a closure (because of _ patterns). However,\n-    /// to ensure the places are initialized, we introduce fake reads.\n-    /// Consider these two examples:\n-    /// ``` (discriminant matching with only wildcard arm)\n-    /// let x: u8;\n-    /// let c = || match x { _ => () };\n-    /// ```\n-    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n-    /// want to capture it. However, we do still want an error here, because `x` should have\n-    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n-    /// instead.\n-    /// ``` (destructured assignments)\n-    /// let c = || {\n-    ///     let (t1, t2) = t;\n-    /// }\n-    /// ```\n-    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n-    /// we never capture `t`. This becomes an issue when we build MIR as we require\n-    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n-    /// issue by fake reading `t`.\n-    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n-\n-    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n-    /// by applying extended parameter rules.\n-    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n-    pub rvalue_scopes: RvalueScopes,\n-\n-    /// Stores the type, expression, span and optional scope span of all types\n-    /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n-\n-    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n-    /// as `&[u8]`, depending on the pattern  in which they are used.\n-    /// This hashset records all instances where we behave\n-    /// like this to allow `const_to_pat` to reliably handle this situation.\n-    pub treat_byte_string_as_slice: ItemLocalSet,\n-\n-    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n-    /// on closure size.\n-    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n-}\n-\n-impl<'tcx> TypeckResults<'tcx> {\n-    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n-        TypeckResults {\n-            hir_owner,\n-            type_dependent_defs: Default::default(),\n-            field_indices: Default::default(),\n-            user_provided_types: Default::default(),\n-            user_provided_sigs: Default::default(),\n-            node_types: Default::default(),\n-            node_substs: Default::default(),\n-            adjustments: Default::default(),\n-            pat_binding_modes: Default::default(),\n-            pat_adjustments: Default::default(),\n-            closure_kind_origins: Default::default(),\n-            liberated_fn_sigs: Default::default(),\n-            fru_field_types: Default::default(),\n-            coercion_casts: Default::default(),\n-            used_trait_imports: Lrc::new(Default::default()),\n-            tainted_by_errors: None,\n-            concrete_opaque_types: Default::default(),\n-            closure_min_captures: Default::default(),\n-            closure_fake_reads: Default::default(),\n-            rvalue_scopes: Default::default(),\n-            generator_interior_types: ty::Binder::dummy(Default::default()),\n-            treat_byte_string_as_slice: Default::default(),\n-            closure_size_eval: Default::default(),\n-        }\n-    }\n-\n-    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n-        match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n-                .type_dependent_def(id)\n-                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n-        }\n-    }\n-\n-    pub fn type_dependent_defs(\n-        &self,\n-    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n-    }\n-\n-    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n-    }\n-\n-    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n-        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n-    }\n-\n-    pub fn type_dependent_defs_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n-    }\n-\n-    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n-    }\n-\n-    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n-    }\n-\n-    pub fn field_index(&self, id: hir::HirId) -> usize {\n-        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n-    }\n-\n-    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n-        self.field_indices().get(id).cloned()\n-    }\n-\n-    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n-    }\n-\n-    pub fn user_provided_types_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n-    }\n-\n-    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n-    }\n-\n-    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n-    }\n-\n-    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n-        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n-            vec.iter()\n-                .map(|item| {\n-                    GeneratorInteriorTypeCause {\n-                        ty: item.ty,\n-                        span: item.span,\n-                        scope_span: item.scope_span,\n-                        yield_span: item.yield_span,\n-                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        });\n-        GeneratorDiagnosticData {\n-            generator_interior_types: generator_interior_type,\n-            hir_owner: self.hir_owner.to_def_id(),\n-            nodes_types: self.node_types.clone(),\n-            adjustments: self.adjustments.clone(),\n-        }\n-    }\n-\n-    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        self.node_type_opt(id).unwrap_or_else(|| {\n-            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n-        })\n-    }\n-\n-    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_types.get(&id.local_id).cloned()\n-    }\n-\n-    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n-    }\n-\n-    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n-    }\n-\n-    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_results(self.hir_owner, id);\n-        self.node_substs.get(&id.local_id).cloned()\n-    }\n-\n-    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n-    /// doesn't provide type parameter substitutions.\n-    ///\n-    /// [`expr_ty`]: TypeckResults::expr_ty\n-    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n-        self.node_type(pat.hir_id)\n-    }\n-\n-    /// Returns the type of an expression as a monotype.\n-    ///\n-    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n-    /// auto-ref.  The type returned by this function does not consider such\n-    /// adjustments.  See `expr_ty_adjusted()` instead.\n-    ///\n-    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n-    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n-    /// instead of `fn(ty) -> T with T = isize`.\n-    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.node_type(expr.hir_id)\n-    }\n-\n-    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(expr.hir_id)\n-    }\n-\n-    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n-    }\n-\n-    pub fn adjustments_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n-    }\n-\n-    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n-        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n-    }\n-\n-    /// Returns the type of `expr`, considering any `Adjustment`\n-    /// entry recorded for that expression.\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n-        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n-    }\n-\n-    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n-        // Only paths and method calls/overloaded operators have\n-        // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprKind::Path(_) = expr.kind {\n-            return false;\n-        }\n-\n-        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n-    }\n-\n-    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n-        self.pat_binding_modes().get(id).copied().or_else(|| {\n-            s.delay_span_bug(sp, \"missing binding mode\");\n-            None\n-        })\n-    }\n-\n-    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n-    }\n-\n-    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n-    }\n-\n-    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n-    }\n-\n-    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n-    /// by the closure.\n-    pub fn closure_min_captures_flattened(\n-        &self,\n-        closure_def_id: LocalDefId,\n-    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n-        self.closure_min_captures\n-            .get(&closure_def_id)\n-            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n-            .into_iter()\n-            .flatten()\n-    }\n-\n-    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n-    }\n-\n-    pub fn closure_kind_origins_mut(\n-        &mut self,\n-    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n-    }\n-\n-    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n-    }\n-\n-    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n-    }\n-\n-    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n-    }\n-\n-    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n-    }\n-\n-    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n-        self.coercion_casts.contains(&hir_id.local_id)\n-    }\n-\n-    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n-        self.coercion_casts.insert(id);\n-    }\n-\n-    pub fn coercion_casts(&self) -> &ItemLocalSet {\n-        &self.coercion_casts\n-    }\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct UserTypeAnnotationIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"UserType({})\",\n-        const START_INDEX = 0,\n-    }\n-}\n-\n-/// Mapping of type annotation indices to canonical user type annotations.\n-pub type CanonicalUserTypeAnnotations<'tcx> =\n-    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n-\n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub struct CanonicalUserTypeAnnotation<'tcx> {\n-    pub user_ty: Box<CanonicalUserType<'tcx>>,\n-    pub span: Span,\n-    pub inferred_ty: Ty<'tcx>,\n-}\n-\n-/// Canonicalized user type annotation.\n-pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n-\n-impl<'tcx> CanonicalUserType<'tcx> {\n-    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        match self.value {\n-            UserType::Ty(_) => false,\n-            UserType::TypeOf(_, user_substs) => {\n-                if user_substs.user_self_ty.is_some() {\n-                    return false;\n-                }\n-\n-                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n-                    match kind.unpack() {\n-                        GenericArgKind::Type(ty) => match ty.kind() {\n-                            ty::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == b.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Lifetime(r) => match *r {\n-                            ty::ReLateBound(debruijn, br) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == br.var\n-                            }\n-                            _ => false,\n-                        },\n-\n-                        GenericArgKind::Const(ct) => match ct.kind() {\n-                            ty::ConstKind::Bound(debruijn, b) => {\n-                                // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n-                                cvar == b\n-                            }\n-                            _ => false,\n-                        },\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-/// A user-given type annotation attached to a constant. These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub enum UserType<'tcx> {\n-    Ty(Ty<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, UserSubsts<'tcx>),\n-}\n-\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,"}, {"sha": "7290f0ae7c0350f4d34b3e08be5303af6da875d1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=651e41c14c9c27e7073b042f7e7cfcdcab666143", "patch": "@@ -83,10 +83,8 @@ pub use self::consts::{\n     Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n-    tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyCtxtFeed, TypeckResults,\n-    UserType, UserTypeAnnotationIndex,\n+    tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n+    TyCtxtFeed,\n };\n pub use self::instance::{Instance, InstanceDef, ShortInstance};\n pub use self::list::List;\n@@ -103,6 +101,11 @@ pub use self::sty::{\n     Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n+pub use self::typeck_results::{\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, TypeckResults, UserType,\n+    UserTypeAnnotationIndex,\n+};\n \n pub mod _match;\n pub mod abstract_const;\n@@ -143,6 +146,7 @@ mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n mod sty;\n+mod typeck_results;\n \n // Data types\n "}, {"sha": "4fe85d4366f3e3d3b1027800b906f86797a7c32a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651e41c14c9c27e7073b042f7e7cfcdcab666143/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=651e41c14c9c27e7073b042f7e7cfcdcab666143", "patch": "@@ -0,0 +1,689 @@\n+use crate::{\n+    hir::place::Place as HirPlace,\n+    infer::canonical::Canonical,\n+    ty::{\n+        self, tls, BindingMode, BoundVar, CanonicalPolyFnSig, ClosureSizeProfileData,\n+        GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n+    },\n+};\n+use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir as hir;\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    def_id::{DefId, LocalDefId, LocalDefIdMap},\n+    hir_id::OwnerId,\n+    HirId, ItemLocalId, ItemLocalMap, ItemLocalSet,\n+};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_macros::HashStable;\n+use rustc_middle::mir::FakeReadCause;\n+use rustc_session::Session;\n+use rustc_span::Span;\n+use std::{\n+    collections::hash_map::{self, Entry},\n+    hash::Hash,\n+    iter,\n+};\n+\n+use super::RvalueScopes;\n+\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n+pub struct TypeckResults<'tcx> {\n+    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n+    pub hir_owner: OwnerId,\n+\n+    /// Resolved definitions for `<T>::X` associated paths and\n+    /// method calls, including those of overloaded operators.\n+    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorGuaranteed>>,\n+\n+    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n+    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n+    /// about the field you also need definition of the variant to which the field\n+    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n+    field_indices: ItemLocalMap<usize>,\n+\n+    /// Stores the types for various nodes in the AST. Note that this table\n+    /// is not guaranteed to be populated outside inference. See\n+    /// typeck::check::fn_ctxt for details.\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node. This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    node_substs: ItemLocalMap<SubstsRef<'tcx>>,\n+\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserType<'tcx>>,\n+\n+    /// Stores the canonicalized types provided by the user. See also\n+    /// `AscribeUserType` statement in MIR.\n+    pub user_provided_sigs: LocalDefIdMap<CanonicalPolyFnSig<'tcx>>,\n+\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+\n+    /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n+\n+    /// Stores the types which were implicitly dereferenced in pattern binding modes\n+    /// for later usage in THIR lowering. For example,\n+    ///\n+    /// ```\n+    /// match &&Some(5i32) {\n+    ///     Some(n) => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// leads to a `vec![&&Option<i32>, &Option<i32>]`. Empty vectors are not stored.\n+    ///\n+    /// See:\n+    /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n+    pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// Records the reasons that we picked the kind of each closure;\n+    /// not all closures are present in the map.\n+    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n+\n+    /// For each fn, records the \"liberated\" types of its arguments\n+    /// and return type. Liberated means that all bound regions\n+    /// (including late-bound regions) are replaced with free\n+    /// equivalents. This table is not used in codegen (since regions\n+    /// are erased there) and hence is not serialized to metadata.\n+    ///\n+    /// This table also contains the \"revealed\" values for any `impl Trait`\n+    /// that appear in the signature and whose values are being inferred\n+    /// by this function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::fmt::Debug;\n+    /// fn foo(x: &u32) -> impl Debug { *x }\n+    /// ```\n+    ///\n+    /// The function signature here would be:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// for<'a> fn(&'a u32) -> Foo\n+    /// ```\n+    ///\n+    /// where `Foo` is an opaque type created for this function.\n+    ///\n+    ///\n+    /// The *liberated* form of this would be\n+    ///\n+    /// ```ignore (illustrative)\n+    /// fn(&'a u32) -> u32\n+    /// ```\n+    ///\n+    /// Note that `'a` is not bound (it would be an `ReFree`) and\n+    /// that the `Foo` opaque type is replaced by its hidden type.\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n+\n+    /// For each FRU expression, record the normalized types of the fields\n+    /// of the struct - this is needed because it is non-trivial to\n+    /// normalize while preserving regions. This table is used only in\n+    /// MIR construction and hence is not serialized to metadata.\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n+\n+    /// For every coercion cast we add the HIR node ID of the cast\n+    /// expression to this set.\n+    coercion_casts: ItemLocalSet,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports. During type\n+    /// checking, this `Lrc` should not be cloned: it must have a ref-count\n+    /// of 1 so that we can insert things into the set mutably.\n+    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n+\n+    /// If any errors occurred while type-checking this body,\n+    /// this field will be set to `Some(ErrorGuaranteed)`.\n+    pub tainted_by_errors: Option<ErrorGuaranteed>,\n+\n+    /// All the opaque types that have hidden types set\n+    /// by this function. We also store the\n+    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n+    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// Tracks the minimum captures required for a closure;\n+    /// see `MinCaptureInformationMap` for more details.\n+    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n+\n+    /// Tracks the fake reads required for a closure and the reason for the fake read.\n+    /// When performing pattern matching for closures, there are times we don't end up\n+    /// reading places that are mentioned in a closure (because of _ patterns). However,\n+    /// to ensure the places are initialized, we introduce fake reads.\n+    /// Consider these two examples:\n+    /// ``` (discriminant matching with only wildcard arm)\n+    /// let x: u8;\n+    /// let c = || match x { _ => () };\n+    /// ```\n+    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n+    /// want to capture it. However, we do still want an error here, because `x` should have\n+    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n+    /// instead.\n+    /// ``` (destructured assignments)\n+    /// let c = || {\n+    ///     let (t1, t2) = t;\n+    /// }\n+    /// ```\n+    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n+    /// we never capture `t`. This becomes an issue when we build MIR as we require\n+    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n+    /// issue by fake reading `t`.\n+    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n+\n+    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n+    /// by applying extended parameter rules.\n+    /// Details may be find in `rustc_hir_analysis::check::rvalue_scopes`.\n+    pub rvalue_scopes: RvalueScopes,\n+\n+    /// Stores the type, expression, span and optional scope span of all types\n+    /// that are live across the yield of this generator (if a generator).\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+\n+    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n+    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// This hashset records all instances where we behave\n+    /// like this to allow `const_to_pat` to reliably handle this situation.\n+    pub treat_byte_string_as_slice: ItemLocalSet,\n+\n+    /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n+    /// on closure size.\n+    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n+}\n+\n+/// Whenever a value may be live across a generator yield, the type of that value winds up in the\n+/// `GeneratorInteriorTypeCause` struct. This struct adds additional information about such\n+/// captured types that can be useful for diagnostics. In particular, it stores the span that\n+/// caused a given type to be recorded, along with the scope that enclosed the value (which can\n+/// be used to find the await that the value is live across).\n+///\n+/// For example:\n+///\n+/// ```ignore (pseudo-Rust)\n+/// async move {\n+///     let x: T = expr;\n+///     foo.await\n+///     ...\n+/// }\n+/// ```\n+///\n+/// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n+/// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub struct GeneratorInteriorTypeCause<'tcx> {\n+    /// Type of the captured binding.\n+    pub ty: Ty<'tcx>,\n+    /// Span of the binding that was captured.\n+    pub span: Span,\n+    /// Span of the scope of the captured binding.\n+    pub scope_span: Option<Span>,\n+    /// Span of `.await` or `yield` expression.\n+    pub yield_span: Span,\n+    /// Expr which the type evaluated from.\n+    pub expr: Option<hir::HirId>,\n+}\n+\n+// This type holds diagnostic information on generators and async functions across crate boundaries\n+// and is used to provide better error messages\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, HashStable)]\n+pub struct GeneratorDiagnosticData<'tcx> {\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+    pub hir_owner: DefId,\n+    pub nodes_types: ItemLocalMap<Ty<'tcx>>,\n+    pub adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+}\n+\n+impl<'tcx> TypeckResults<'tcx> {\n+    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n+        TypeckResults {\n+            hir_owner,\n+            type_dependent_defs: Default::default(),\n+            field_indices: Default::default(),\n+            user_provided_types: Default::default(),\n+            user_provided_sigs: Default::default(),\n+            node_types: Default::default(),\n+            node_substs: Default::default(),\n+            adjustments: Default::default(),\n+            pat_binding_modes: Default::default(),\n+            pat_adjustments: Default::default(),\n+            closure_kind_origins: Default::default(),\n+            liberated_fn_sigs: Default::default(),\n+            fru_field_types: Default::default(),\n+            coercion_casts: Default::default(),\n+            used_trait_imports: Lrc::new(Default::default()),\n+            tainted_by_errors: None,\n+            concrete_opaque_types: Default::default(),\n+            closure_min_captures: Default::default(),\n+            closure_fake_reads: Default::default(),\n+            rvalue_scopes: Default::default(),\n+            generator_interior_types: ty::Binder::dummy(Default::default()),\n+            treat_byte_string_as_slice: Default::default(),\n+            closure_size_eval: Default::default(),\n+        }\n+    }\n+\n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.res,\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n+                .type_dependent_def(id)\n+                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n+        }\n+    }\n+\n+    pub fn type_dependent_defs(\n+        &self,\n+    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n+    }\n+\n+    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n+    }\n+\n+    pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n+        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n+    }\n+\n+    pub fn type_dependent_defs_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorGuaranteed>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n+    }\n+\n+    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n+    }\n+\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n+    }\n+\n+    pub fn field_index(&self, id: hir::HirId) -> usize {\n+        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+        self.field_indices().get(id).cloned()\n+    }\n+\n+    pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n+    }\n+\n+    pub fn user_provided_types_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n+    }\n+\n+    pub fn get_generator_diagnostic_data(&self) -> GeneratorDiagnosticData<'tcx> {\n+        let generator_interior_type = self.generator_interior_types.map_bound_ref(|vec| {\n+            vec.iter()\n+                .map(|item| {\n+                    GeneratorInteriorTypeCause {\n+                        ty: item.ty,\n+                        span: item.span,\n+                        scope_span: item.scope_span,\n+                        yield_span: item.yield_span,\n+                        expr: None, //FIXME: Passing expression over crate boundaries is impossible at the moment\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        });\n+        GeneratorDiagnosticData {\n+            generator_interior_types: generator_interior_type,\n+            hir_owner: self.hir_owner.to_def_id(),\n+            nodes_types: self.node_types.clone(),\n+            adjustments: self.adjustments.clone(),\n+        }\n+    }\n+\n+    pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n+        self.node_type_opt(id).unwrap_or_else(|| {\n+            bug!(\"node_type: no type for node `{}`\", tls::with(|tcx| tcx.hir().node_to_string(id)))\n+        })\n+    }\n+\n+    pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_types.get(&id.local_id).cloned()\n+    }\n+\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n+    }\n+\n+    pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n+    }\n+\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.node_substs.get(&id.local_id).cloned()\n+    }\n+\n+    /// Returns the type of a pattern as a monotype. Like [`expr_ty`], this function\n+    /// doesn't provide type parameter substitutions.\n+    ///\n+    /// [`expr_ty`]: TypeckResults::expr_ty\n+    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n+        self.node_type(pat.hir_id)\n+    }\n+\n+    /// Returns the type of an expression as a monotype.\n+    ///\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// some cases, we insert `Adjustment` annotations such as auto-deref or\n+    /// auto-ref.  The type returned by this function does not consider such\n+    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    ///\n+    /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n+    /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n+    /// instead of `fn(ty) -> T with T = isize`.\n+    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.node_type(expr.hir_id)\n+    }\n+\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.node_type_opt(expr.hir_id)\n+    }\n+\n+    pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n+    }\n+\n+    pub fn adjustments_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n+    }\n+\n+    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n+        validate_hir_id_for_typeck_results(self.hir_owner, expr.hir_id);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n+    }\n+\n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n+        self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n+        self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n+\n+    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n+        // Only paths and method calls/overloaded operators have\n+        // entries in type_dependent_defs, ignore the former here.\n+        if let hir::ExprKind::Path(_) = expr.kind {\n+            return false;\n+        }\n+\n+        matches!(self.type_dependent_defs().get(expr.hir_id), Some(Ok((DefKind::AssocFn, _))))\n+    }\n+\n+    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n+        self.pat_binding_modes().get(id).copied().or_else(|| {\n+            s.delay_span_bug(sp, \"missing binding mode\");\n+            None\n+        })\n+    }\n+\n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n+    }\n+\n+    pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n+    }\n+\n+    pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n+    }\n+\n+    /// For a given closure, returns the iterator of `ty::CapturedPlace`s that are captured\n+    /// by the closure.\n+    pub fn closure_min_captures_flattened(\n+        &self,\n+        closure_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n+        self.closure_min_captures\n+            .get(&closure_def_id)\n+            .map(|closure_min_captures| closure_min_captures.values().flat_map(|v| v.iter()))\n+            .into_iter()\n+            .flatten()\n+    }\n+\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n+    }\n+\n+    pub fn closure_kind_origins_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n+    }\n+\n+    pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, hir_id);\n+        self.coercion_casts.contains(&hir_id.local_id)\n+    }\n+\n+    pub fn set_coercion_cast(&mut self, id: ItemLocalId) {\n+        self.coercion_casts.insert(id);\n+    }\n+\n+    pub fn coercion_casts(&self) -> &ItemLocalSet {\n+        &self.coercion_casts\n+    }\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the maps of a TypeckResults. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `hir_owner`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+#[inline]\n+fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    if hir_id.owner != hir_owner {\n+        invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n+    }\n+}\n+\n+#[cold]\n+#[inline(never)]\n+fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n+    ty::tls::with(|tcx| {\n+        bug!(\n+            \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n+            tcx.hir().node_to_string(hir_id),\n+            hir_id.owner,\n+            hir_owner\n+        )\n+    });\n+}\n+\n+pub struct LocalTableInContext<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V> {\n+    hir_owner: OwnerId,\n+    data: &'a mut ItemLocalMap<V>,\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_results(self.hir_owner, id);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"UserType({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n+\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub struct CanonicalUserTypeAnnotation<'tcx> {\n+    pub user_ty: Box<CanonicalUserType<'tcx>>,\n+    pub span: Span,\n+    pub inferred_ty: Ty<'tcx>,\n+}\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n+\n+impl<'tcx> CanonicalUserType<'tcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserType::Ty(_) => false,\n+            UserType::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                iter::zip(user_substs.substs, BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        GenericArgKind::Type(ty) => match ty.kind() {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Lifetime(r) => match *r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == br.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        GenericArgKind::Const(ct) => match ct.kind() {\n+                            ty::ConstKind::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant. These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub enum UserType<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}"}]}