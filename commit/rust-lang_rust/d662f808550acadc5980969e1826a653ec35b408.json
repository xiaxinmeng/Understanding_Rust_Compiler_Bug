{"sha": "d662f808550acadc5980969e1826a653ec35b408", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NjJmODA4NTUwYWNhZGM1OTgwOTY5ZTE4MjZhNjUzZWMzNWI0MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T06:56:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T06:56:46Z"}, "message": "Auto merge of #78697 - JohnTitor:rollup-q0fchpv, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #78376 (Treat trailing semicolon as a statement in macro call)\n - #78400 (Fix unindent in doc comments)\n - #78575 (Add a test for compiletest rustc-env & unset-rustc-env directives)\n - #78616 (Document -Zinstrument-coverage)\n - #78663 (Fix ICE when a future-incompat-report has its command-line level capped)\n - #78664 (Fix intrinsic size_of stable link)\n - #78668 (inliner: Remove redundant loop)\n - #78676 (add mipsel-unknown-none target)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3ad8fc155db24f83d351e68d520bf6c3043c8629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad8fc155db24f83d351e68d520bf6c3043c8629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d662f808550acadc5980969e1826a653ec35b408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d662f808550acadc5980969e1826a653ec35b408", "html_url": "https://github.com/rust-lang/rust/commit/d662f808550acadc5980969e1826a653ec35b408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d662f808550acadc5980969e1826a653ec35b408/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b5a9e9cd27f01311b5e19cefa1fb574d086d3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5a9e9cd27f01311b5e19cefa1fb574d086d3da", "html_url": "https://github.com/rust-lang/rust/commit/7b5a9e9cd27f01311b5e19cefa1fb574d086d3da"}, {"sha": "1cb137b3e955375115c76d2d66e9881435adfada", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cb137b3e955375115c76d2d66e9881435adfada", "html_url": "https://github.com/rust-lang/rust/commit/1cb137b3e955375115c76d2d66e9881435adfada"}], "stats": {"total": 763, "additions": 578, "deletions": 185}, "files": [{"sha": "f13d67b9c15840178eb35adf6e9fd90fd87c47e1", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -905,6 +905,13 @@ pub struct Stmt {\n }\n \n impl Stmt {\n+    pub fn has_trailing_semicolon(&self) -> bool {\n+        match &self.kind {\n+            StmtKind::Semi(_) => true,\n+            StmtKind::MacCall(mac) => matches!(mac.style, MacStmtStyle::Semicolon),\n+            _ => false,\n+        }\n+    }\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.kind = match self.kind {\n             StmtKind::Expr(expr) => StmtKind::Semi(expr),"}, {"sha": "0cffca17271247d3d1f5e622c04b5fb586608623", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -310,8 +310,44 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         };\n \n         if style == ast::MacStmtStyle::Semicolon {\n+            // Implement the proposal described in\n+            // https://github.com/rust-lang/rust/issues/61733#issuecomment-509626449\n+            //\n+            // The macro invocation expands to the list of statements.\n+            // If the list of statements is empty, then 'parse'\n+            // the trailing semicolon on the original invocation\n+            // as an empty statement. That is:\n+            //\n+            // `empty();` is parsed as a single `StmtKind::Empty`\n+            //\n+            // If the list of statements is non-empty, see if the\n+            // final statement alreayd has a trailing semicolon.\n+            //\n+            // If it doesn't have a semicolon, then 'parse' the trailing semicolon\n+            // from the invocation as part of the final statement,\n+            // using `stmt.add_trailing_semicolon()`\n+            //\n+            // If it does have a semicolon, then 'parse' the trailing semicolon\n+            // from the invocation as a new StmtKind::Empty\n+\n+            // FIXME: We will need to preserve the original\n+            // semicolon token and span as part of #15701\n+            let empty_stmt = ast::Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                kind: ast::StmtKind::Empty,\n+                span: DUMMY_SP,\n+                tokens: None,\n+            };\n+\n             if let Some(stmt) = stmts.pop() {\n-                stmts.push(stmt.add_trailing_semicolon());\n+                if stmt.has_trailing_semicolon() {\n+                    stmts.push(stmt);\n+                    stmts.push(empty_stmt);\n+                } else {\n+                    stmts.push(stmt.add_trailing_semicolon());\n+                }\n+            } else {\n+                stmts.push(empty_stmt);\n             }\n         }\n "}, {"sha": "aca28988364e6802a0d83e9ea3528cd58f80e330", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -74,6 +74,7 @@ impl<'s> LintLevelsBuilder<'s> {\n \n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n             store.check_lint_name_cmdline(sess, &lint_name, level);\n+            let orig_level = level;\n \n             // If the cap is less than this specified level, e.g., if we've got\n             // `--cap-lints allow` but we've also got `-D foo` then we ignore\n@@ -88,7 +89,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             };\n             for id in ids {\n                 self.check_gated_lint(id, DUMMY_SP);\n-                let src = LintSource::CommandLine(lint_flag_val);\n+                let src = LintSource::CommandLine(lint_flag_val, orig_level);\n                 specs.insert(id, (level, src));\n             }\n         }\n@@ -123,7 +124,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                             diag_builder.note(&rationale.as_str());\n                         }\n                     }\n-                    LintSource::CommandLine(_) => {\n+                    LintSource::CommandLine(_, _) => {\n                         diag_builder.note(\"`forbid` lint level was set on command line\");\n                     }\n                 }\n@@ -422,7 +423,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             let forbidden_lint_name = match forbid_src {\n                 LintSource::Default => id.to_string(),\n                 LintSource::Node(name, _, _) => name.to_string(),\n-                LintSource::CommandLine(name) => name.to_string(),\n+                LintSource::CommandLine(name, _) => name.to_string(),\n             };\n             let (lint_attr_name, lint_attr_span) = match *src {\n                 LintSource::Node(name, span, _) => (name, span),\n@@ -446,7 +447,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                         diag_builder.note(&rationale.as_str());\n                     }\n                 }\n-                LintSource::CommandLine(_) => {\n+                LintSource::CommandLine(_, _) => {\n                     diag_builder.note(\"`forbid` lint level was set on command line\");\n                 }\n             }"}, {"sha": "84cc7b68d4ca9ef45bc9f14b8395b54347638fab", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -42,6 +42,11 @@ impl EarlyLintPass for RedundantSemicolons {\n \n fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, bool)>) {\n     if let Some((span, multiple)) = seq.take() {\n+        // FIXME: Find a better way of ignoring the trailing\n+        // semicolon from macro expansion\n+        if span == rustc_span::DUMMY_SP {\n+            return;\n+        }\n         cx.struct_span_lint(REDUNDANT_SEMICOLONS, span, |lint| {\n             let (msg, rem) = if multiple {\n                 (\"unnecessary trailing semicolons\", \"remove these semicolons\")"}, {"sha": "781c1744ac62da86d15d91f5955a4b2fe482e4e6", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -22,23 +22,25 @@ pub enum LintSource {\n     Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n \n     /// Lint level was set by a command-line flag.\n-    CommandLine(Symbol),\n+    /// The provided `Level` is the level specified on the command line -\n+    /// the actual level may be lower due to `--cap-lints`\n+    CommandLine(Symbol, Level),\n }\n \n impl LintSource {\n     pub fn name(&self) -> Symbol {\n         match *self {\n             LintSource::Default => symbol::kw::Default,\n             LintSource::Node(name, _, _) => name,\n-            LintSource::CommandLine(name) => name,\n+            LintSource::CommandLine(name, _) => name,\n         }\n     }\n \n     pub fn span(&self) -> Span {\n         match *self {\n             LintSource::Default => DUMMY_SP,\n             LintSource::Node(_, span, _) => span,\n-            LintSource::CommandLine(_) => DUMMY_SP,\n+            LintSource::CommandLine(_, _) => DUMMY_SP,\n         }\n     }\n }\n@@ -279,12 +281,12 @@ pub fn struct_lint_level<'s, 'd>(\n                     &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n                 );\n             }\n-            LintSource::CommandLine(lint_flag_val) => {\n-                let flag = match level {\n+            LintSource::CommandLine(lint_flag_val, orig_level) => {\n+                let flag = match orig_level {\n                     Level::Warn => \"-W\",\n                     Level::Deny => \"-D\",\n                     Level::Forbid => \"-F\",\n-                    Level::Allow => panic!(),\n+                    Level::Allow => \"-A\",\n                 };\n                 let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n                 if lint_flag_val.as_str() == name {"}, {"sha": "010a7470ccd38d29166260b7e9814d693ba5e3a2", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 60, "deletions": 77, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -93,96 +93,79 @@ impl Inliner<'tcx> {\n             return;\n         }\n \n-        let mut local_change;\n         let mut changed = false;\n+        while let Some(callsite) = callsites.pop_front() {\n+            debug!(\"checking whether to inline callsite {:?}\", callsite);\n \n-        loop {\n-            local_change = false;\n-            while let Some(callsite) = callsites.pop_front() {\n-                debug!(\"checking whether to inline callsite {:?}\", callsite);\n-\n-                if let InstanceDef::Item(_) = callsite.callee.def {\n-                    if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n-                        debug!(\n-                            \"checking whether to inline callsite {:?} - MIR unavailable\",\n-                            callsite,\n-                        );\n-                        continue;\n-                    }\n+            if let InstanceDef::Item(_) = callsite.callee.def {\n+                if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n+                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite,);\n+                    continue;\n                 }\n+            }\n \n-                let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n-                    let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                    // Avoid a cycle here by only using `instance_mir` only if we have\n-                    // a lower `HirId` than the callee. This ensures that the callee will\n-                    // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled. Also avoid inlining into generators,\n-                    // since their `optimized_mir` is used for layout computation, which can\n-                    // create a cycle, even when no attempt is made to inline the function\n-                    // in the other direction.\n-                    if !self.tcx.dep_graph.is_fully_enabled()\n-                        && self_hir_id < callee_hir_id\n-                        && caller_body.generator_kind.is_none()\n-                    {\n-                        self.tcx.instance_mir(callsite.callee.def)\n-                    } else {\n-                        continue;\n-                    }\n-                } else {\n-                    // This cannot result in a cycle since the callee MIR is from another crate\n-                    // and is already optimized.\n+            let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n+                let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+                // Avoid a cycle here by only using `instance_mir` only if we have\n+                // a lower `HirId` than the callee. This ensures that the callee will\n+                // not inline us. This trick only works without incremental compilation.\n+                // So don't do it if that is enabled. Also avoid inlining into generators,\n+                // since their `optimized_mir` is used for layout computation, which can\n+                // create a cycle, even when no attempt is made to inline the function\n+                // in the other direction.\n+                if !self.tcx.dep_graph.is_fully_enabled()\n+                    && self_hir_id < callee_hir_id\n+                    && caller_body.generator_kind.is_none()\n+                {\n                     self.tcx.instance_mir(callsite.callee.def)\n-                };\n-\n-                let callee_body: &Body<'tcx> = &*callee_body;\n-\n-                let callee_body = if self.consider_optimizing(callsite, callee_body) {\n-                    self.tcx.subst_and_normalize_erasing_regions(\n-                        &callsite.callee.substs,\n-                        self.param_env,\n-                        callee_body,\n-                    )\n                 } else {\n                     continue;\n-                };\n+                }\n+            } else {\n+                // This cannot result in a cycle since the callee MIR is from another crate\n+                // and is already optimized.\n+                self.tcx.instance_mir(callsite.callee.def)\n+            };\n \n-                // Copy only unevaluated constants from the callee_body into the caller_body.\n-                // Although we are only pushing `ConstKind::Unevaluated` consts to\n-                // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n-                // because we are calling `subst_and_normalize_erasing_regions`.\n-                caller_body.required_consts.extend(\n-                    callee_body.required_consts.iter().copied().filter(|&constant| {\n-                        matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n-                    }),\n-                );\n+            let callee_body: &Body<'tcx> = &*callee_body;\n \n-                let start = caller_body.basic_blocks().len();\n-                debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-                if !self.inline_call(callsite, caller_body, callee_body) {\n-                    debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n-                    continue;\n-                }\n-                debug!(\"attempting to inline callsite {:?} - success\", callsite);\n-\n-                // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n-                    if let Some(new_callsite) =\n-                        self.get_valid_function_call(bb, bb_data, caller_body)\n-                    {\n-                        // Don't inline the same function multiple times.\n-                        if callsite.callee != new_callsite.callee {\n-                            callsites.push_back(new_callsite);\n-                        }\n+            let callee_body = if self.consider_optimizing(callsite, callee_body) {\n+                self.tcx.subst_and_normalize_erasing_regions(\n+                    &callsite.callee.substs,\n+                    self.param_env,\n+                    callee_body,\n+                )\n+            } else {\n+                continue;\n+            };\n+\n+            // Copy only unevaluated constants from the callee_body into the caller_body.\n+            // Although we are only pushing `ConstKind::Unevaluated` consts to\n+            // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n+            // because we are calling `subst_and_normalize_erasing_regions`.\n+            caller_body.required_consts.extend(callee_body.required_consts.iter().copied().filter(\n+                |&constant| matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _)),\n+            ));\n+\n+            let start = caller_body.basic_blocks().len();\n+            debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n+            if !self.inline_call(callsite, caller_body, callee_body) {\n+                debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n+                continue;\n+            }\n+            debug!(\"attempting to inline callsite {:?} - success\", callsite);\n+\n+            // Add callsites from inlined function\n+            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n+                if let Some(new_callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n+                    // Don't inline the same function multiple times.\n+                    if callsite.callee != new_callsite.callee {\n+                        callsites.push_back(new_callsite);\n                     }\n                 }\n-\n-                local_change = true;\n-                changed = true;\n             }\n \n-            if !local_change {\n-                break;\n-            }\n+            changed = true;\n         }\n \n         // Simplify if we inlined anything."}, {"sha": "1651ff9c2d6fc704fd7439e2a5b1357f4a20c94a", "filename": "compiler/rustc_target/src/spec/mipsel_unknown_none.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_none.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,42 @@\n+//! Bare MIPS32r2, little endian, softfloat, O32 calling convention\n+//!\n+//! Can be used for MIPS M4K core (e.g. on PIC32MX devices)\n+\n+use crate::spec::abi::Abi;\n+use crate::spec::{LinkerFlavor, LldFlavor, RelocModel};\n+use crate::spec::{PanicStrategy, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"mipsel-unknown-none\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        pointer_width: 32,\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n+        arch: \"mips\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: String::new(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+\n+        options: TargetOptions {\n+            cpu: \"mips32r2\".to_string(),\n+            features: \"+mips32r2,+soft-float,+noabicalls\".to_string(),\n+            max_atomic_width: Some(32),\n+            executables: true,\n+            linker: Some(\"rust-lld\".to_owned()),\n+            panic_strategy: PanicStrategy::Abort,\n+            relocation_model: RelocModel::Static,\n+            unsupported_abis: vec![\n+                Abi::Stdcall,\n+                Abi::Fastcall,\n+                Abi::Vectorcall,\n+                Abi::Thiscall,\n+                Abi::Win64,\n+                Abi::SysV64,\n+            ],\n+            emit_debug_gdb_scripts: false,\n+            ..Default::default()\n+        },\n+    }\n+}"}, {"sha": "ba9e2f7fa0648d6e057d9a83e03bcc18ec9da0e9", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -653,6 +653,7 @@ supported_targets! {\n     (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n \n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n+    (\"mipsel-unknown-none\", mipsel_unknown_none),\n     (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),\n }\n "}, {"sha": "3e5d7caa2fe5d0ff3c0d9ca5a3dde56e3d82b82f", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -764,7 +764,7 @@ extern \"rust-intrinsic\" {\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n-    /// The stabilized version of this intrinsic is [`size_of`].\n+    /// The stabilized version of this intrinsic is [`crate::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     pub fn size_of<T>() -> usize;\n "}, {"sha": "85c6f91f085824fafdded7982c72bee1e5d0f7b5", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -180,6 +180,7 @@ target | std | host | notes\n `i686-wrs-vxworks` | ? |  |\n `mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n `mipsel-unknown-linux-uclibc` | \u2713 |  | MIPS (LE) Linux with uClibc\n+`mipsel-unknown-none` | * |  | Bare MIPS (LE) softfloat\n `mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n `mipsisa32r6-unknown-linux-gnu` | ? |  |\n `mipsisa32r6el-unknown-linux-gnu` | ? |  |"}, {"sha": "35f04594347a398ca8321faf85fa018b192fa843", "filename": "src/doc/unstable-book/src/compiler-flags/img/llvm-cov-show-01.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fimg%2Fllvm-cov-show-01.png", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fimg%2Fllvm-cov-show-01.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fimg%2Fllvm-cov-show-01.png?ref=d662f808550acadc5980969e1826a653ec35b408"}, {"sha": "1dd7272e0f92a972d0d8be5bf67477b128d45304", "filename": "src/doc/unstable-book/src/compiler-flags/source-based-code-coverage.md", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,169 @@\n+# `source-based-code-coverage`\n+\n+The feature request for this feature is: [#34701]\n+\n+The Major Change Proposal (MCP) for this feature is: [#278](https://github.com/rust-lang/compiler-team/issues/278)\n+\n+------------------------\n+\n+## Introduction\n+\n+The Rust compiler includes two code coverage implementations:\n+\n+* A GCC-compatible, gcov-based coverage implementation, enabled with [`-Zprofile`](profile.md), which operates on DebugInfo.\n+* A source-based code coverage implementation, enabled with `-Zinstrument-coverage`, which uses LLVM's native coverage instrumentation to generate very precise coverage data.\n+\n+This document describes how to enable and use the LLVM instrumentation-based coverage, via the `-Zinstrument-coverage` compiler flag.\n+\n+## How it works\n+\n+When `-Zinstrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n+\n+* Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n+* Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format]), to define the code regions (start and end positions in the source code) being counted.\n+\n+When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n+\n+## Enable coverage profiling in the Rust compiler\n+\n+Rust's source-based code coverage requires the Rust \"profiler runtime\". Without it, compiling with `-Zinstrument-coverage` generates an error that the profiler runtime is missing.\n+\n+The Rust `nightly` distribution channel should include the profiler runtime, by default.\n+\n+*IMPORTANT:* If you are building the Rust compiler from the source distribution, the profiler runtime is *not* enabled in the default `config.toml.example`, and may not be enabled in your `config.toml`. Edit the `config.toml` file, and find the `profiler` feature entry. Uncomment it and set it to `true`:\n+\n+```toml\n+# Build the profiler runtime (required when compiling with options that depend\n+# on this runtime, such as `-C profile-generate` or `-Z instrument-coverage`).\n+profiler = true\n+```\n+\n+Then rebuild the Rust compiler (see [rustc-dev-guide-how-to-build-and-run]).\n+\n+### Building the demangler\n+\n+LLVM coverage reporting tools generate results that can include function names and other symbol references, and the raw coverage results report symbols using the compiler's \"mangled\" version of the symbol names, which can be difficult to interpret. To work around this issue, LLVM coverage tools also support a user-specified symbol name demangler.\n+\n+One option for a Rust demangler is [`rustfilt`](https://crates.io/crates/rustfilt), which can be installed with:\n+\n+```shell\n+cargo install rustfilt\n+```\n+\n+Another option, if you are building from the Rust compiler source distribution, is to use the `rust-demangler` tool included in the Rust source distribution, which can be built with:\n+\n+```shell\n+$ ./x.py build rust-demangler\n+```\n+\n+## Compiling with coverage enabled\n+\n+Set the `-Zinstrument-coverage` compiler flag in order to enable LLVM source-based code coverage profiling.\n+\n+With `cargo`, you can instrument your program binary *and* dependencies at the same time.\n+\n+For example (if your project's Cargo.toml builds a binary by default):\n+\n+```shell\n+$ cd your-project\n+$ cargo clean\n+$ RUSTFLAGS=\"-Zinstrument-coverage\" cargo build\n+```\n+\n+If `cargo` is not configured to use your `profiler`-enabled version of `rustc`, set the path explicitly via the `RUSTC` environment variable. Here is another example, using a `stage1` build of `rustc` to compile an `example` binary (from the [`json5format`](https://crates.io/crates/json5format) crate):\n+\n+```shell\n+$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \\\n+    RUSTFLAGS=\"-Zinstrument-coverage\" \\\n+    cargo build --example formatjson5\n+```\n+\n+## Running the instrumented binary to generate raw coverage profiling data\n+\n+In the previous example, `cargo` generated the coverage-instrumented binary `formatjson5`:\n+\n+```shell\n+$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n+```\n+```json5\n+{\n+    some: 'thing',\n+}\n+```\n+\n+After running this program, a new file, `default.profraw`, should be in the current working directory. It's often preferable to set a specific file name or path. You can change the output file using the environment variable `LLVM_PROFILE_FILE`:\n+\n+\n+```shell\n+$ echo \"{some: 'thing'}\" \\\n+    | LLVM_PROFILE_FILE=\"formatjson5.profraw\" target/debug/examples/formatjson5 -\n+...\n+$ ls formatjson5.profraw\n+formatjson5.profraw\n+```\n+\n+If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing directory structure will be created. Additionally, the following special pattern strings are rewritten:\n+\n+* `%p` - The process ID.\n+* `%h` - The hostname of the machine running the program.\n+* `%t` - The value of the TMPDIR environment variable.\n+* `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n+* `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n+\n+## Creating coverage reports\n+\n+LLVM's tools to process coverage data and coverage maps have some version dependencies. If you encounter a version mismatch, try updating your LLVM tools.\n+\n+If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: `rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*`. (Look for `llvm-profdata` and `llvm-cov`.)\n+\n+Raw profiles have to be indexed before they can be used to generate coverage reports. This is done using [`llvm-profdata merge`] (which can combine multiple raw profiles and index them at the same time):\n+\n+```shell\n+$ llvm-profdata merge -sparse formatjson5.profraw -o formatjson5.profdata\n+```\n+\n+Finally, the `.profdata` file is used, in combination with the coverage map (from the program binary) to generate coverage reports using [`llvm-cov report`]--for a coverage summaries--and [`llvm-cov show`]--to see detailed coverage of lines and regions (character ranges), overlaid on the original source code.\n+\n+These commands have several display and filtering options. For example:\n+\n+```shell\n+$ llvm-cov show -Xdemangler=rustfilt target/debug/examples/formatjson5 \\\n+    -instr-profile=formatjson5.profdata \\\n+    -show-line-counts-or-regions \\\n+    -show-instantiations \\\n+    -name=add_quoted_string\n+```\n+\n+<img alt=\"Screenshot of sample `llvm-cov show` result, for function add_quoted_string\" src=\"img/llvm-cov-show-01.png\" class=\"center\"/>\n+<br/>\n+<br/>\n+\n+Some of the more notable options in this example include:\n+\n+* `--Xdemangler=rustfilt` - the command name or path used to demangle Rust symbols (`rustfilt` in the example, but this could also be a path to the `rust-demangler` tool)\n+* `target/debug/examples/formatjson5` - the instrumented binary (from which to extract the coverage map)\n+* `--instr-profile=<path-to-file>.profdata` - the location of the `.profdata` file created by `llvm-profdata merge` (from the `.profraw` file generated by the instrumented binary)\n+* `--name=<exact-function-name>` - to show coverage for a specific function (or, consider using another filter option, such as `--name-regex=<pattern>`)\n+\n+## Interpreting reports\n+\n+There are four statistics tracked in a coverage summary:\n+\n+* Function coverage is the percentage of functions that have been executed at least once. A function is considered to be executed if any of its instantiations are executed.\n+* Instantiation coverage is the percentage of function instantiations that have been executed at least once. Generic functions and functions generated from macros are two kinds of functions that may have multiple instantiations.\n+* Line coverage is the percentage of code lines that have been executed at least once. Only executable lines within function bodies are considered to be code lines.\n+* Region coverage is the percentage of code regions that have been executed at least once. A code region may span multiple lines: for example, in a large function body with no control flow. In other cases, a single line can contain multiple code regions: `return x || (y && z)` has countable code regions for `x` (which may resolve the expression, if `x` is `true`), `|| (y && z)` (executed only if `x` was `false`), and `return` (executed in either situation).\n+\n+Of these four statistics, function coverage is usually the least granular while region coverage is the most granular. The project-wide totals for each statistic are listed in the summary.\n+\n+## Other references\n+\n+Rust's implementation and workflow for source-based code coverage is based on the same library and tools used to implement [source-based code coverage in Clang](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html). (This document is partially based on the Clang guide.)\n+\n+[#34701]: https://github.com/rust-lang/rust/issues/34701\n+[`llvm.instrprof.increment`]: https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic\n+[LLVM Code Coverage Mapping Format]: https://llvm.org/docs/CoverageMappingFormat.html\n+[rustc-dev-guide-how-to-build-and-run]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n+[`llvm-profdata merge`]: https://llvm.org/docs/CommandGuide/llvm-profdata.html#profdata-merge\n+[`llvm-cov report`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-report\n+[`llvm-cov show`]: https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-show"}, {"sha": "51c380f438cc95230b0d84655e6842ac23f818d8", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -1,7 +1,6 @@\n use std::cmp;\n-use std::string::String;\n \n-use crate::clean::{self, DocFragment, Item};\n+use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n@@ -35,65 +34,81 @@ impl clean::Attributes {\n }\n \n fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    for fragment in docs {\n-        fragment.doc = unindent(&fragment.doc);\n-    }\n-}\n-\n-fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str>>();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line && !saw_second_line && !line.chars().all(|c| c.is_whitespace());\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n+    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n \n-        let min_indent = if ignore_previous_indents { usize::MAX } else { min_indent };\n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n+    let min_indent = match docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n+                } else {\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n+                }\n+            })\n+        })\n+        .min()\n+    {\n+        Some(x) => x,\n+        None => return,\n+    };\n \n-        if saw_first_line {\n-            saw_second_line = true;\n+    for fragment in docs {\n+        if fragment.doc.lines().count() == 0 {\n+            continue;\n         }\n \n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n+        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+            min_indent - add\n         } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n+            min_indent\n+        };\n+\n+        fragment.doc = fragment\n+            .doc\n+            .lines()\n+            .map(|line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    line.to_string()\n                 } else {\n-                    false\n+                    assert!(line.len() >= min_indent);\n+                    line[min_indent..].to_string()\n                 }\n-            });\n-            cmp::min(min_indent, whitespace)\n-        }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![lines[0].trim_start().to_string()];\n-        unindented.extend_from_slice(\n-            &lines[1..]\n-                .iter()\n-                .map(|&line| {\n-                    if line.chars().all(|c| c.is_whitespace()) {\n-                        line.to_string()\n-                    } else {\n-                        assert!(line.len() >= min_indent);\n-                        line[min_indent..].to_string()\n-                    }\n-                })\n-                .collect::<Vec<_>>(),\n-        );\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n     }\n }"}, {"sha": "9dec71f7683aa757a6ae901842e3809ff3549060", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -1,72 +1,63 @@\n use super::*;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n+    vec![DocFragment {\n+        line: 0,\n+        span: DUMMY_SP,\n+        parent_module: None,\n+        doc: s.to_string(),\n+        kind: DocFragmentKind::SugaredDoc,\n+    }]\n+}\n+\n+#[track_caller]\n+fn run_test(input: &str, expected: &str) {\n+    let mut s = create_doc_fragment(input);\n+    unindent_fragments(&mut s);\n+    assert_eq!(s[0].doc, expected);\n+}\n \n #[test]\n fn should_unindent() {\n-    let s = \"    line1\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"    line1\\n    line2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n-    let s = \"    line1\\n\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\nline2\");\n+    run_test(\"    line1\\n\\n    line2\", \"line1\\n\\nline2\");\n }\n \n #[test]\n fn should_leave_multiple_indent_levels() {\n     // Line 2 is indented another level beyond the\n     // base indentation and should be preserved\n-    let s = \"    line1\\n\\n        line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\n    line2\");\n+    run_test(\"    line1\\n\\n        line2\", \"line1\\n\\n    line2\");\n }\n \n #[test]\n fn should_ignore_first_line_indent() {\n-    // The first line of the first paragraph may not be indented as\n-    // far due to the way the doc string was written:\n-    //\n-    // #[doc = \"Start way over here\n-    //          and continue here\"]\n-    let s = \"line1\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"line1\\n    line2\", \"line1\\n    line2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-    let s = \"line1\\n\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\n    line2\");\n+    run_test(\"line1\\n\\n    line2\", \"line1\\n\\n    line2\");\n }\n \n #[test]\n fn should_unindent_tabs() {\n-    let s = \"\\tline1\\n\\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"\\tline1\\n\\tline2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_trim_mixed_indentation() {\n-    let s = \"\\t    line1\\n\\t    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n-\n-    let s = \"    \\tline1\\n    \\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"\\t    line1\\n\\t    line2\", \"line1\\nline2\");\n+    run_test(\"    \\tline1\\n    \\tline2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_not_trim() {\n-    let s = \"\\t    line1  \\n\\t    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1  \\nline2\");\n-\n-    let s = \"    \\tline1  \\n    \\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1  \\nline2\");\n+    run_test(\"\\t    line1  \\n\\t    line2\", \"line1  \\nline2\");\n+    run_test(\"    \\tline1  \\n    \\tline2\", \"line1  \\nline2\");\n }"}, {"sha": "8e4e7a25af8d7cf877218f00f43b835b5f360038", "filename": "src/test/rustdoc/unindent.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Frustdoc%2Funindent.md", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Frustdoc%2Funindent.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funindent.md?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1 @@\n+Just some text."}, {"sha": "d10e1ec89c59ea19f85bbe9869fe446407e6c434", "filename": "src/test/rustdoc/unindent.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Frustdoc%2Funindent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Frustdoc%2Funindent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funindent.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,64 @@\n+#![feature(external_doc)]\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.Example.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n    \\.first\\(\\)\\n    \\.second\\(\\)\\n    \\.build\\(\\);\\Z'\n+/// ```rust\n+/// let example = Example::new()\n+///     .first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .second()\")]\n+///     .build();\n+/// ```\n+pub struct Example;\n+\n+// @has foo/struct.F.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n    \\.first\\(\\)\\n    \\.another\\(\\)\\n    \\.build\\(\\);\\Z'\n+///```rust\n+///let example = Example::new()\n+///    .first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .another()\")]\n+///    .build();\n+/// ```\n+pub struct F;\n+\n+// @has foo/struct.G.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n\\.first\\(\\)\\n    \\.another\\(\\)\\n\\.build\\(\\);\\Z'\n+///```rust\n+///let example = Example::new()\n+///.first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .another()\")]\n+///.build();\n+///```\n+pub struct G;\n+\n+// @has foo/struct.H.html\n+// @has - '//div[@class=\"docblock\"]/p' 'no whitespace lol'\n+///no whitespace\n+#[doc = \" lol\"]\n+pub struct H;\n+\n+// @has foo/struct.I.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' '(?m)4 whitespaces!\\Z'\n+///     4 whitespaces!\n+#[doc = \"something\"]\n+pub struct I;\n+\n+// @has foo/struct.J.html\n+// @matches - '//div[@class=\"docblock\"]/p' '(?m)a\\nno whitespace\\nJust some text.\\Z'\n+///a\n+///no whitespace\n+#[doc(include = \"unindent.md\")]\n+pub struct J;\n+\n+// @has foo/struct.K.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' '(?m)4 whitespaces!\\Z'\n+///a\n+///\n+///    4 whitespaces!\n+///\n+#[doc(include = \"unindent.md\")]\n+pub struct K;"}, {"sha": "4d98f0ad62d4ddceff454fc3106e60c84ad392e7", "filename": "src/test/ui/lint/issue-78660-cap-lints-future-compat.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -D warnings --cap-lints allow\n+// check-pass\n+\n+// Regression test for issue #78660\n+// Tests that we don't ICE when a future-incompat-report lint has\n+// has a command-line source, but is capped to allow\n+\n+fn main() {\n+    [\"hi\"].into_iter();\n+}"}, {"sha": "79958ba90d409c9f8eb4af66051261dea3b5eef8", "filename": "src/test/ui/lint/issue-78660-cap-lints-future-compat.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-78660-cap-lints-future-compat.stderr?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,11 @@\n+Future incompatibility report: Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/issue-78660-cap-lints-future-compat.rs:9:12\n+   |\n+LL |     [\"hi\"].into_iter();\n+   |            ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = note: `-D array-into-iter` implied by `-D warnings`\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+"}, {"sha": "3d78ed4a4759a2515bf201d54cb6b6a4012adf46", "filename": "src/test/ui/macros/empty-trailing-stmt.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! empty {\n+    () => { }\n+}\n+\n+fn foo() -> bool { //~ ERROR mismatched\n+    { true } //~ ERROR mismatched\n+    empty!();\n+}\n+\n+fn main() {}"}, {"sha": "e88b12712fb8c8ef7c1769d14c8b68c0d82459b4", "filename": "src/test/ui/macros/empty-trailing-stmt.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fempty-trailing-stmt.stderr?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/empty-trailing-stmt.rs:6:7\n+   |\n+LL |     { true }\n+   |       ^^^^ expected `()`, found `bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/empty-trailing-stmt.rs:5:13\n+   |\n+LL | fn foo() -> bool {\n+   |    ---      ^^^^ expected `bool`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b3644d8d5943f188e192099b2b557050ad6fb766", "filename": "src/test/ui/meta/auxiliary/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fauxiliary%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fauxiliary%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Fauxiliary%2Fenv.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,9 @@\n+// Check that aux builds can also use rustc-env, but environment is configured\n+// separately from the main test case.\n+//\n+// rustc-env:COMPILETEST_BAR=bar\n+\n+pub fn test() {\n+    assert_eq!(option_env!(\"COMPILETEST_FOO\"), None);\n+    assert_eq!(env!(\"COMPILETEST_BAR\"), \"bar\");\n+}"}, {"sha": "df4dbdbc8e62d36496faf9c500ad3fd73a7180d3", "filename": "src/test/ui/meta/expected-error-correct-rev.a.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.a.stderr?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/meta-expected-error-correct-rev.rs:7:18\n+  --> $DIR/expected-error-correct-rev.rs:7:18\n    |\n LL |     let x: u32 = 22_usize;\n    |            ---   ^^^^^^^^ expected `u32`, found `usize`", "previous_filename": "src/test/ui/meta-expected-error-correct-rev.a.stderr"}, {"sha": "26798c3dfc29f0567eadc5c75bb69b724f3ae6df", "filename": "src/test/ui/meta/expected-error-correct-rev.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Fexpected-error-correct-rev.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -1,6 +1,6 @@\n // revisions: a\n \n-// Counterpart to `meta-expected-error-wrong-rev.rs`\n+// Counterpart to `expected-error-wrong-rev.rs`\n \n #[cfg(a)]\n fn foo() {", "previous_filename": "src/test/ui/meta-expected-error-correct-rev.rs"}, {"sha": "01f1518c1c6ed9f044e11adcb08bcb70fed5e18e", "filename": "src/test/ui/meta/revision-bad.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frevision-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frevision-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Frevision-bad.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "previous_filename": "src/test/ui/meta-revision-bad.rs"}, {"sha": "bbeae41b8bb95bb45344f12817cc766eb5f75dc7", "filename": "src/test/ui/meta/revision-ok.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frevision-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frevision-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Frevision-ok.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -1,5 +1,5 @@\n // Meta test for compiletest: check that when we give the right error\n-// patterns, the test passes. See all `meta-revision-bad.rs`.\n+// patterns, the test passes. See all `revision-bad.rs`.\n \n // run-fail\n // revisions: foo bar", "previous_filename": "src/test/ui/meta-revision-ok.rs"}, {"sha": "7d4e005be10cff89f0fb1fc61f6f82910363471d", "filename": "src/test/ui/meta/rustc-env.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frustc-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fmeta%2Frustc-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmeta%2Frustc-env.rs?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -0,0 +1,18 @@\n+// Compiletest meta test checking that rustc-env and unset-rustc-env directives\n+// can be used to configure environment for rustc.\n+//\n+// run-pass\n+// aux-build:env.rs\n+// rustc-env:COMPILETEST_FOO=foo\n+//\n+// An environment variable that is likely to be set, but should be safe to unset.\n+// unset-rustc-env:PWD\n+\n+extern crate env;\n+\n+fn main() {\n+    assert_eq!(env!(\"COMPILETEST_FOO\"), \"foo\");\n+    assert_eq!(option_env!(\"COMPILETEST_BAR\"), None);\n+    assert_eq!(option_env!(\"PWD\"), None);\n+    env::test();\n+}"}, {"sha": "a067b7b5411dd87e05f1b5c0df6f7b506e78f7f7", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d662f808550acadc5980969e1826a653ec35b408/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=d662f808550acadc5980969e1826a653ec35b408", "patch": "@@ -40,7 +40,7 @@ macro_rules! produce_it\n     }\n }\n \n-fn main /* 0#0 */() { }\n+fn main /* 0#0 */() { ; }\n \n /*\n Expansions:"}]}