{"sha": "1f929659acff378adad85fcea747f8b19a0f819f", "node_id": "C_kwDOAAsO6NoAKDFmOTI5NjU5YWNmZjM3OGFkYWQ4NWZjZWE3NDdmOGIxOWEwZjgxOWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T09:28:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T09:28:41Z"}, "message": "Auto merge of #13209 - lowr:feat/inference-for-generator, r=Veykril\n\nfeat: type inference for generators\n\nThis PR implements basic type inference for generator and yield expressions.\n\nThings not included in this PR:\n- Generator upvars and generator witnesses are not implemented. They are only used to determine auto trait impls, so basic type inference should be fine without them, but method resolutions with auto trait bounds may not be resolved correctly.\n\nOpen questions:\n- I haven't (yet) implemented `HirDisplay` for `TyKind::Generator`, so generator types are just shown as \"{{generator}}\" (in tests, inlay hints, hovers, etc.), which is not really nice. How should we show them?\n- I added moderate amount of stuffs to minicore. I especially didn't want to add `impl<T> Deref for &T` and `impl<T> Deref for &mut T` exclusively for tests for generators; should I move them into the test fixtures or can they be placed in minicore?\n\ncc #4309", "tree": {"sha": "31f21c019d021f78100998ee0b499f5fc3b371fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31f21c019d021f78100998ee0b499f5fc3b371fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f929659acff378adad85fcea747f8b19a0f819f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f929659acff378adad85fcea747f8b19a0f819f", "html_url": "https://github.com/rust-lang/rust/commit/1f929659acff378adad85fcea747f8b19a0f819f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f929659acff378adad85fcea747f8b19a0f819f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73ab709b38b171d561c119f5c6f94af1bf2e4f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/73ab709b38b171d561c119f5c6f94af1bf2e4f3b", "html_url": "https://github.com/rust-lang/rust/commit/73ab709b38b171d561c119f5c6f94af1bf2e4f3b"}, {"sha": "9ede5f073564f140194229546fc2bf5eb6267b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ede5f073564f140194229546fc2bf5eb6267b62", "html_url": "https://github.com/rust-lang/rust/commit/9ede5f073564f140194229546fc2bf5eb6267b62"}], "stats": {"total": 422, "additions": 388, "deletions": 34}, "files": [{"sha": "c4f91e49a6e1b4d53d3f57df2bf2cc8da2f6efdc", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -29,8 +29,9 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, FloatTypeWrapper, Label, LabelId,\n-        Literal, MatchArm, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n+        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n+        Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -97,6 +98,7 @@ pub(super) fn lower(\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n         is_lowering_assignee_expr: false,\n+        is_lowering_generator: false,\n     }\n     .collect(params, body)\n }\n@@ -111,6 +113,7 @@ struct ExprCollector<'a> {\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n     is_lowering_assignee_expr: bool,\n+    is_lowering_generator: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -358,6 +361,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::YieldExpr(e) => {\n+                self.is_lowering_generator = true;\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n@@ -459,13 +463,31 @@ impl ExprCollector<'_> {\n                     .ret_type()\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+\n+                let prev_is_lowering_generator = self.is_lowering_generator;\n+                self.is_lowering_generator = false;\n+\n                 let body = self.collect_expr_opt(e.body());\n+\n+                let closure_kind = if self.is_lowering_generator {\n+                    let movability = if e.static_token().is_some() {\n+                        Movability::Static\n+                    } else {\n+                        Movability::Movable\n+                    };\n+                    ClosureKind::Generator(movability)\n+                } else {\n+                    ClosureKind::Closure\n+                };\n+                self.is_lowering_generator = prev_is_lowering_generator;\n+\n                 self.alloc_expr(\n                     Expr::Closure {\n                         args: args.into(),\n                         arg_types: arg_types.into(),\n                         ret_type,\n                         body,\n+                        closure_kind,\n                     },\n                     syntax_ptr,\n                 )"}, {"sha": "162d173d52404d9adcc05c3eae3dde82c461a855", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -5,7 +5,7 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, Literal, Statement},\n+    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -362,7 +362,10 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n+                    w!(self, \"static \");\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {"}, {"sha": "16264655020712fe2caa3afcc1563c960cdbfc09", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -198,6 +198,7 @@ pub enum Expr {\n         arg_types: Box<[Option<Interned<TypeRef>>]>,\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n+        closure_kind: ClosureKind,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -211,6 +212,18 @@ pub enum Expr {\n     Underscore,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ClosureKind {\n+    Closure,\n+    Generator(Movability),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Movability {\n+    Static,\n+    Movable,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n     ElementList { elements: Box<[ExprId]>, is_assignee_expr: bool },"}, {"sha": "3ae7fb2a617cf92fdf446923fdd9d47947989347", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -9,8 +9,8 @@ use chalk_ir::{\n     AdtId, BoundVar, DebruijnIndex, Scalar,\n };\n use hir_def::{\n-    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, GenericDefId, TraitId,\n-    TypeAliasId,\n+    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, DefWithBodyId,\n+    GenericDefId, TraitId, TypeAliasId,\n };\n use smallvec::SmallVec;\n \n@@ -205,6 +205,38 @@ impl TyBuilder<()> {\n         )\n     }\n \n+    /// Creates a `TyBuilder` to build `Substitution` for a generator defined in `parent`.\n+    ///\n+    /// A generator's substitution consists of:\n+    /// - generic parameters in scope on `parent`\n+    /// - resume type of generator\n+    /// - yield type of generator ([`Generator::Yield`](std::ops::Generator::Yield))\n+    /// - return type of generator ([`Generator::Return`](std::ops::Generator::Return))\n+    /// in this order.\n+    ///\n+    /// This method prepopulates the builder with placeholder substitution of `parent`, so you\n+    /// should only push exactly 3 `GenericArg`s before building.\n+    pub fn subst_for_generator(db: &dyn HirDatabase, parent: DefWithBodyId) -> TyBuilder<()> {\n+        let parent_subst = match parent.as_generic_def_id() {\n+            Some(parent) => generics(db.upcast(), parent).placeholder_subst(db),\n+            // Static initializers *may* contain generators.\n+            None => Substitution::empty(Interner),\n+        };\n+        let builder = TyBuilder::new(\n+            (),\n+            parent_subst\n+                .iter(Interner)\n+                .map(|arg| match arg.constant(Interner) {\n+                    Some(c) => ParamKind::Const(c.data(Interner).ty.clone()),\n+                    None => ParamKind::Type,\n+                })\n+                // These represent resume type, yield type, and return type of generator.\n+                .chain(std::iter::repeat(ParamKind::Type).take(3))\n+                .collect(),\n+        );\n+        builder.use_parent_substs(&parent_subst)\n+    }\n+\n     pub fn build(self) -> Substitution {\n         let ((), subst) = self.build_internal();\n         subst"}, {"sha": "c5cf6729d119991ff1d95fef4062be613339354e", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -11,6 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::CrateId;\n use hir_def::{\n+    expr::Movability,\n     lang_item::{lang_attr, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n@@ -26,9 +27,9 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n-    AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, Interner, ProjectionTy,\n-    ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind, WhereClause,\n+    wrap_empty_binders, AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId,\n+    Interner, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef,\n+    TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n };\n \n pub(crate) type AssociatedTyDatum = chalk_solve::rust_ir::AssociatedTyDatum<Interner>;\n@@ -372,17 +373,63 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn generator_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        let (parent, expr) = self.db.lookup_intern_generator(id.into());\n+\n+        // We fill substitution with unknown type, because we only need to know whether the generic\n+        // params are types or consts to build `Binders` and those being filled up are for\n+        // `resume_type`, `yield_type`, and `return_type` of the generator in question.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+\n+        let len = subst.len(Interner);\n+        let input_output = rust_ir::GeneratorInputOutputDatum {\n+            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 3))\n+                .intern(Interner),\n+            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 2))\n+                .intern(Interner),\n+            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 1))\n+                .intern(Interner),\n+            // FIXME: calculate upvars\n+            upvars: vec![],\n+        };\n+\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let input_output = crate::make_type_and_const_binders(it, input_output);\n+\n+        let movability = match self.db.body(parent)[expr] {\n+            hir_def::expr::Expr::Closure {\n+                closure_kind: hir_def::expr::ClosureKind::Generator(movability),\n+                ..\n+            } => movability,\n+            _ => unreachable!(\"non generator expression interned as generator\"),\n+        };\n+        let movability = match movability {\n+            Movability::Static => rust_ir::Movability::Static,\n+            Movability::Movable => rust_ir::Movability::Movable,\n+        };\n+\n+        Arc::new(rust_ir::GeneratorDatum { movability, input_output })\n     }\n     fn generator_witness_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorWitnessDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        // FIXME: calculate inner types\n+        let inner_types =\n+            rust_ir::GeneratorWitnessExistential { types: wrap_empty_binders(vec![]) };\n+\n+        let (parent, _) = self.db.lookup_intern_generator(id.into());\n+        // See the comment in `generator_datum()` for unknown types.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let inner_types = crate::make_type_and_const_binders(it, inner_types);\n+\n+        Arc::new(rust_ir::GeneratorWitnessDatum { inner_types })\n     }\n \n     fn unification_database(&self) -> &dyn chalk_ir::UnificationDatabase<Interner> {"}, {"sha": "932fce83563d7ea22d0904fbc7038eebd91d6cbf", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -120,6 +120,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn intern_impl_trait_id(&self, id: ImplTraitId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n     fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> InternedClosureId;\n+    #[salsa::interned]\n+    fn intern_generator(&self, id: (DefWithBodyId, ExprId)) -> InternedGeneratorId;\n \n     #[salsa::invoke(chalk_db::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_db::AssocTypeId) -> Arc<chalk_db::AssociatedTyDatum>;\n@@ -233,6 +235,10 @@ impl_intern_key!(InternedOpaqueTyId);\n pub struct InternedClosureId(salsa::InternId);\n impl_intern_key!(InternedClosureId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedGeneratorId(salsa::InternId);\n+impl_intern_key!(InternedGeneratorId);\n+\n /// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n /// we have different IDs for struct and enum variant constructors.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]"}, {"sha": "a5058f71a4a6d030fd9d40e7650d50eb26583d49", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -20,6 +20,7 @@ use hir_def::{\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n+use smallvec::SmallVec;\n use syntax::SmolStr;\n \n use crate::{\n@@ -221,6 +222,7 @@ pub enum DisplaySourceCodeError {\n     PathNotFound,\n     UnknownType,\n     Closure,\n+    Generator,\n }\n \n pub enum HirDisplayError {\n@@ -783,7 +785,34 @@ impl HirDisplay for Ty {\n                 write!(f, \"{{unknown}}\")?;\n             }\n             TyKind::InferenceVar(..) => write!(f, \"_\")?,\n-            TyKind::Generator(..) => write!(f, \"{{generator}}\")?,\n+            TyKind::Generator(_, subst) => {\n+                if f.display_target.is_source_code() {\n+                    return Err(HirDisplayError::DisplaySourceCodeError(\n+                        DisplaySourceCodeError::Generator,\n+                    ));\n+                }\n+\n+                let subst = subst.as_slice(Interner);\n+                let a: Option<SmallVec<[&Ty; 3]>> = subst\n+                    .get(subst.len() - 3..)\n+                    .map(|args| args.iter().map(|arg| arg.ty(Interner)).collect())\n+                    .flatten();\n+\n+                if let Some([resume_ty, yield_ty, ret_ty]) = a.as_deref() {\n+                    write!(f, \"|\")?;\n+                    resume_ty.hir_fmt(f)?;\n+                    write!(f, \"|\")?;\n+\n+                    write!(f, \" yields \")?;\n+                    yield_ty.hir_fmt(f)?;\n+\n+                    write!(f, \" -> \")?;\n+                    ret_ty.hir_fmt(f)?;\n+                } else {\n+                    // This *should* be unreachable, but fallback just in case.\n+                    write!(f, \"{{generator}}\")?;\n+                }\n+            }\n             TyKind::GeneratorWitness(..) => write!(f, \"{{generator witness}}\")?,\n         }\n         Ok(())"}, {"sha": "039824694ace0bd688f29b2bde8446784b0593ed", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -339,7 +339,7 @@ pub struct InferenceResult {\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n-    /// Interned Unknown to return references to.\n+    /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n@@ -419,6 +419,8 @@ pub(crate) struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    /// The resume type and the yield type, respectively, of the generator being inferred.\n+    resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n }\n@@ -483,6 +485,7 @@ impl<'a> InferenceContext<'a> {\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n+            resume_yield_tys: None,\n             db,\n             owner,\n             body,"}, {"sha": "094e460dbf79b0b08b35f2911c0bf83d78d8faca", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -12,6 +12,7 @@ use crate::{\n use super::{Expectation, InferenceContext};\n \n impl InferenceContext<'_> {\n+    // This function handles both closures and generators.\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n         closure_expr: ExprId,\n@@ -27,6 +28,11 @@ impl InferenceContext<'_> {\n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n         let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n+        // Generators are not Fn* so return early.\n+        if matches!(closure_ty.kind(Interner), TyKind::Generator(..)) {\n+            return;\n+        }\n+\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "e3d6be23e6586e33f1895ad81e650430552e4d53", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -10,7 +10,10 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n+    expr::{\n+        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n+        UnaryOp,\n+    },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -216,7 +219,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::new();\n@@ -244,20 +247,40 @@ impl<'a> InferenceContext<'a> {\n                     ),\n                 })\n                 .intern(Interner);\n-                let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                        .intern(Interner);\n+\n+                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n+                    // FIXME: report error when there are more than 1 parameter.\n+                    let resume_ty = match sig_tys.first() {\n+                        // When `sig_tys.len() == 1` the first type is the return type, not the\n+                        // first parameter type.\n+                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                        _ => self.result.standard_types.unit.clone(),\n+                    };\n+                    let yield_ty = self.table.new_type_var();\n+\n+                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                        .push(resume_ty.clone())\n+                        .push(yield_ty.clone())\n+                        .push(ret_ty.clone())\n+                        .build();\n+\n+                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+\n+                    (generator_ty, Some((resume_ty, yield_ty)))\n+                } else {\n+                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                    let closure_ty =\n+                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                            .intern(Interner);\n+\n+                    (closure_ty, None)\n+                };\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(\n-                    tgt_expr,\n-                    &closure_ty,\n-                    &sig_ty,\n-                    expected,\n-                );\n+                self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -266,15 +289,18 @@ impl<'a> InferenceContext<'a> {\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_resume_yield_tys =\n+                    mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n                 self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n                     this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.resume_yield_tys = prev_resume_yield_tys;\n \n-                closure_ty\n+                ty\n             }\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n@@ -423,11 +449,18 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Never.intern(Interner)\n             }\n             Expr::Yield { expr } => {\n-                // FIXME: track yield type for coercion\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none());\n+                if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n+                    if let Some(expr) = expr {\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(yield_ty));\n+                    } else {\n+                        let unit = self.result.standard_types.unit.clone();\n+                        let _ = self.coerce(Some(tgt_expr), &unit, &yield_ty);\n+                    }\n+                    resume_ty\n+                } else {\n+                    // FIXME: report error (yield expr in non-generator)\n+                    TyKind::Error.intern(Interner)\n                 }\n-                TyKind::Never.intern(Interner)\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);"}, {"sha": "f80fb39c1f84e24854bfecbe3fd06a06786f86b2", "filename": "crates/hir-ty/src/mapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmapping.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -103,6 +103,18 @@ impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n     }\n }\n \n+impl From<chalk_ir::GeneratorId<Interner>> for crate::db::InternedGeneratorId {\n+    fn from(id: chalk_ir::GeneratorId<Interner>) -> Self {\n+        Self::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedGeneratorId> for chalk_ir::GeneratorId<Interner> {\n+    fn from(id: crate::db::InternedGeneratorId) -> Self {\n+        chalk_ir::GeneratorId(id.as_intern_id())\n+    }\n+}\n+\n pub fn to_foreign_def_id(id: TypeAliasId) -> ForeignDefId {\n     chalk_ir::ForeignDefId(salsa::InternKey::as_intern_id(&id))\n }"}, {"sha": "d301595bcd98a5ac3f29fda2bc5626cf8e546a8c", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -294,6 +294,24 @@ fn foo() {\n     );\n }\n \n+#[test]\n+fn generator_yield_return_coerce() {\n+    check_no_mismatches(\n+        r#\"\n+fn test() {\n+    let g = || {\n+        yield &1u32;\n+        yield &&1u32;\n+        if true {\n+            return &1u32;\n+        }\n+        &&1u32\n+    };\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn assign_coerce() {\n     check_no_mismatches("}, {"sha": "080e2ac1b8e1e4a1a6ced3cb7227614a998bfa88", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -1952,6 +1952,88 @@ fn closure_return_inferred() {\n     );\n }\n \n+#[test]\n+fn generator_types_inferred() {\n+    check_infer(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+\n+fn f(v: i64) {}\n+fn test() {\n+    let mut g = |r| {\n+        let a = yield 0;\n+        let a = yield 1;\n+        let a = yield 2;\n+        \"return value\"\n+    };\n+\n+    match Pin::new(&mut g).resume(0usize) {\n+        GeneratorState::Yielded(y) => { f(y); }\n+        GeneratorState::Complete(r) => {}\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            70..71 'v': i64\n+            78..80 '{}': ()\n+            91..362 '{     ...   } }': ()\n+            101..106 'mut g': |usize| yields i64 -> &str\n+            109..218 '|r| { ...     }': |usize| yields i64 -> &str\n+            110..111 'r': usize\n+            113..218 '{     ...     }': &str\n+            127..128 'a': usize\n+            131..138 'yield 0': usize\n+            137..138 '0': i64\n+            152..153 'a': usize\n+            156..163 'yield 1': usize\n+            162..163 '1': i64\n+            177..178 'a': usize\n+            181..188 'yield 2': usize\n+            187..188 '2': i64\n+            198..212 '\"return value\"': &str\n+            225..360 'match ...     }': ()\n+            231..239 'Pin::new': fn new<&mut |usize| yields i64 -> &str>(&mut |usize| yields i64 -> &str) -> Pin<&mut |usize| yields i64 -> &str>\n+            231..247 'Pin::n...mut g)': Pin<&mut |usize| yields i64 -> &str>\n+            231..262 'Pin::n...usize)': GeneratorState<i64, &str>\n+            240..246 '&mut g': &mut |usize| yields i64 -> &str\n+            245..246 'g': |usize| yields i64 -> &str\n+            255..261 '0usize': usize\n+            273..299 'Genera...ded(y)': GeneratorState<i64, &str>\n+            297..298 'y': i64\n+            303..312 '{ f(y); }': ()\n+            305..306 'f': fn f(i64)\n+            305..309 'f(y)': ()\n+            307..308 'y': i64\n+            321..348 'Genera...ete(r)': GeneratorState<i64, &str>\n+            346..347 'r': &str\n+            352..354 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn generator_resume_yield_return_unit() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+fn test() {\n+    let mut g = || {\n+        let () = yield;\n+    };\n+\n+    match Pin::new(&mut g).resume(()) {\n+        GeneratorState::Yielded(()) => {}\n+        GeneratorState::Complete(()) => {}\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn fn_pointer_return() {\n     check_infer("}, {"sha": "10386b5b7bcdd41e033144c705702b71d3dd27a5", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f929659acff378adad85fcea747f8b19a0f819f/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=1f929659acff378adad85fcea747f8b19a0f819f", "patch": "@@ -37,6 +37,7 @@\n //!     add:\n //!     as_ref: sized\n //!     drop:\n+//!     generator: pin\n \n pub mod marker {\n     // region:sized\n@@ -182,6 +183,19 @@ pub mod ops {\n             type Target: ?Sized;\n             fn deref(&self) -> &Self::Target;\n         }\n+\n+        impl<T: ?Sized> Deref for &T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n+        impl<T: ?Sized> Deref for &mut T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n         // region:deref_mut\n         #[lang = \"deref_mut\"]\n         pub trait DerefMut: Deref {\n@@ -347,6 +361,27 @@ pub mod ops {\n         fn add(self, rhs: Rhs) -> Self::Output;\n     }\n     // endregion:add\n+\n+    // region:generator\n+    mod generator {\n+        use crate::pin::Pin;\n+\n+        #[lang = \"generator\"]\n+        pub trait Generator<R = ()> {\n+            type Yield;\n+            #[lang = \"generator_return\"]\n+            type Return;\n+            fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n+        }\n+\n+        #[lang = \"generator_state\"]\n+        pub enum GeneratorState<Y, R> {\n+            Yielded(Y),\n+            Complete(R),\n+        }\n+    }\n+    pub use self::generator::{Generator, GeneratorState};\n+    // endregion:generator\n }\n \n // region:eq\n@@ -455,6 +490,19 @@ pub mod pin {\n     pub struct Pin<P> {\n         pointer: P,\n     }\n+    impl<P> Pin<P> {\n+        pub fn new(pointer: P) -> Pin<P> {\n+            loop {}\n+        }\n+    }\n+    // region:deref\n+    impl<P: crate::ops::Deref> crate::ops::Deref for Pin<P> {\n+        type Target = P::Target;\n+        fn deref(&self) -> &P::Target {\n+            loop {}\n+        }\n+    }\n+    // endregion:deref\n }\n // endregion:pin\n "}]}