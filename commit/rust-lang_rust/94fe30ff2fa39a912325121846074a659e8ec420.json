{"sha": "94fe30ff2fa39a912325121846074a659e8ec420", "node_id": "C_kwDOAAsO6NoAKDk0ZmUzMGZmMmZhMzlhOTEyMzI1MTIxODQ2MDc0YTY1OWU4ZWM0MjA", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-10-27T12:00:21Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-11-21T16:06:07Z"}, "message": "Treat different opaque types of the same def id as equal during coherence", "tree": {"sha": "cdfaaddd14ca4f9e324841d5aaa6b921dd8a2de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdfaaddd14ca4f9e324841d5aaa6b921dd8a2de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94fe30ff2fa39a912325121846074a659e8ec420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94fe30ff2fa39a912325121846074a659e8ec420", "html_url": "https://github.com/rust-lang/rust/commit/94fe30ff2fa39a912325121846074a659e8ec420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94fe30ff2fa39a912325121846074a659e8ec420/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2752e328c9696aa3f8f61046507392ecdedc6667", "url": "https://api.github.com/repos/rust-lang/rust/commits/2752e328c9696aa3f8f61046507392ecdedc6667", "html_url": "https://github.com/rust-lang/rust/commit/2752e328c9696aa3f8f61046507392ecdedc6667"}], "stats": {"total": 232, "additions": 182, "deletions": 50}, "files": [{"sha": "923a55f705d6c656606c203d4e9d1c94cce8192d", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -244,6 +244,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         self.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }"}, {"sha": "2483ab724a4e32142a0e7078f1a277d22ba38131", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -81,6 +81,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate: self.intercrate,\n         }\n     }\n }"}, {"sha": "743e776d58c9e7fd3a0a9fb36179852c543a14af", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -521,6 +521,11 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -799,6 +804,10 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }"}, {"sha": "dca955778f866a1cda0beebe241e1a81a320f5c1", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -32,6 +32,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.fields.tcx()\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.fields.param_env\n     }"}, {"sha": "8b14fe18fec449bfe3b7d6ebaf6b28bb0d0650ab", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -2937,6 +2937,10 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         self.0.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.0.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         // Unused, only for consts which we treat as always equal\n         ty::ParamEnv::empty()"}, {"sha": "16a80a1a5d63c6d6883762a16d8f54e90239a2dd", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -30,6 +30,10 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         \"Glb\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }"}, {"sha": "ef6b7ebfeea67c09579e4379ed57255b7c2340ad", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -30,6 +30,10 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         \"Lub\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }"}, {"sha": "fd4ca9365f97694f241d37356b09fce59a65ef62", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -337,6 +337,26 @@ pub struct InferCtxt<'tcx> {\n \n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+\n+    /// During coherence we have to assume that other crates may add\n+    /// additional impls which we currently don't know about.\n+    ///\n+    /// To deal with this evaluation should be conservative\n+    /// and consider the possibility of impls from outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`.\n+    ///\n+    /// Outside of coherence we set this to false because we are only\n+    /// interested in types that the user could actually have written.\n+    /// In other words, we consider `$0: Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    pub intercrate: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -554,6 +574,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     considering_regions: bool,\n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+    intercrate: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -567,6 +588,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n             normalize_fn_sig_for_diagnostic: None,\n+            intercrate: false,\n         }\n     }\n }\n@@ -583,6 +605,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn intercrate(mut self) -> Self {\n+        self.intercrate = true;\n+        self\n+    }\n+\n     pub fn ignoring_regions(mut self) -> Self {\n         self.considering_regions = false;\n         self\n@@ -622,6 +649,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             defining_use_anchor,\n             considering_regions,\n             ref normalize_fn_sig_for_diagnostic,\n+            intercrate,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -641,6 +669,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate,\n         }\n     }\n }"}, {"sha": "6e846171d67dbd0e840ffb16bb7eaa6fc1e6de5d", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -531,6 +531,10 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -898,6 +902,10 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }"}, {"sha": "198e6b1d4f22561077bcf6758ac3231884e12900", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -136,6 +136,11 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Match\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "2faf7db5b136f670814d2481c44b31e7e7976337", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -35,6 +35,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Sub\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.infcx.tcx\n     }"}, {"sha": "bcf2058b9f0329f028bd5be168749b95b46d90c8", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -36,6 +36,11 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }"}, {"sha": "1a9b959fb845bf91150cee3d3bd3888fa880fa96", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -23,6 +23,8 @@ pub enum Cause {\n pub trait TypeRelation<'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n+    fn intercrate(&self) -> bool;\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     /// Returns a static string we can use for printouts.\n@@ -562,16 +564,22 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let opt_variances = tcx.variances_of(a_def_id);\n-            let substs = relate_substs_with_variances(\n-                relation,\n-                a_def_id,\n-                opt_variances,\n-                a_substs,\n-                b_substs,\n-                false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n-            )?;\n-            Ok(tcx.mk_opaque(a_def_id, substs))\n+            if relation.intercrate() {\n+                // During coherence, opaque types should be treated as equal to each other, even if their generic params\n+                // differ, as they could resolve to the same hidden type, even for different generic params.\n+                Ok(a)\n+            } else {\n+                let opt_variances = tcx.variances_of(a_def_id);\n+                let substs = relate_substs_with_variances(\n+                    relation,\n+                    a_def_id,\n+                    opt_variances,\n+                    a_substs,\n+                    b_substs,\n+                    false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n+                )?;\n+                Ok(tcx.mk_opaque(a_def_id, substs))\n+            }\n         }\n \n         _ => Err(TypeError::Sorts(expected_found(relation, a, b))),"}, {"sha": "8006af2a40f9f243e9c53c2bbc821ee568bf3041", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -94,8 +94,9 @@ pub fn overlapping_impls<'tcx>(\n         return None;\n     }\n \n-    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n@@ -105,8 +106,9 @@ pub fn overlapping_impls<'tcx>(\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n     Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }"}, {"sha": "87fcfdb33fc6cab2f57a13219357d1ca30868538", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -110,25 +110,6 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'tcx>,\n \n-    /// During coherence we have to assume that other crates may add\n-    /// additional impls which we currently don't know about.\n-    ///\n-    /// To deal with this evaluation should be conservative\n-    /// and consider the possibility of impls from outside this crate.\n-    /// This comes up primarily when resolving ambiguity. Imagine\n-    /// there is some trait reference `$0: Bar` where `$0` is an\n-    /// inference variable. If `intercrate` is true, then we can never\n-    /// say for sure that this reference is not implemented, even if\n-    /// there are *no impls at all for `Bar`*, because `$0` could be\n-    /// bound to some type that in a downstream crate that implements\n-    /// `Bar`.\n-    ///\n-    /// Outside of coherence we set this to false because we are only\n-    /// interested in types that the user could actually have written.\n-    /// In other words, we consider `$0: Bar` to be unimplemented if\n-    /// there is no type that the user could *actually name* that\n-    /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n     /// If `intercrate` is set, we remember predicates which were\n     /// considered ambiguous because of impls potentially added in other crates.\n     /// This is used in coherence to give improved diagnostics.\n@@ -226,16 +207,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener_keep_static(),\n-            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext { intercrate: true, ..SelectionContext::new(infcx) }\n-    }\n-\n     pub fn with_query_mode(\n         infcx: &'cx InferCtxt<'tcx>,\n         query_mode: TraitQueryMode,\n@@ -247,7 +223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Enables tracking of intercrate ambiguity causes. See\n     /// the documentation of [`Self::intercrate_ambiguity_causes`] for more.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         assert!(self.intercrate_ambiguity_causes.is_none());\n         self.intercrate_ambiguity_causes = Some(FxIndexSet::default());\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n@@ -257,7 +233,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n     pub fn take_intercrate_ambiguity_causes(&mut self) -> FxIndexSet<IntercrateAmbiguityCause> {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n@@ -270,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn is_intercrate(&self) -> bool {\n-        self.intercrate\n+        self.infcx.intercrate\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -751,7 +727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && obligation.is_global()\n             && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n         {\n@@ -1014,7 +990,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n \n@@ -1044,7 +1020,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return;\n         }\n \n@@ -1225,9 +1201,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Result<(), Conflict> {\n-        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.is_intercrate());\n \n-        if !self.intercrate || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n+        if !self.is_intercrate() || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n             return Ok(());\n         }\n \n@@ -1258,7 +1234,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate, I don't think.\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n \n@@ -1275,7 +1251,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n         let tcx = self.tcx();\n@@ -1314,7 +1290,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n         match result {\n@@ -2192,7 +2168,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{e}`\"))?;\n         nested_obligations.extend(obligations);\n \n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n             debug!(\"reservation impls only apply in intercrate mode\");"}, {"sha": "d942a268a7a1b131cb3dcb2bf09c6d16f929ab53", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -0,0 +1,34 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {}\n+impl Foo for () {}\n+impl Foo for i32 {}\n+\n+type Bar<T: Foo> = impl std::fmt::Debug;\n+fn defining_use<T: Foo>() -> Bar<T> {\n+    42\n+}\n+\n+trait Bop {}\n+\n+impl Bop for Bar<()> {}\n+\n+// If the hidden type is the same, this is effectively a second impl for the same type.\n+impl Bop for Bar<i32> {}\n+//~^ ERROR conflicting implementations\n+\n+type Barr = impl std::fmt::Debug;\n+fn defining_use2() -> Barr {\n+    42\n+}\n+\n+// Even completely different opaque types must conflict.\n+impl Bop for Barr {}\n+//~^ ERROR conflicting implementations\n+\n+// And obviously the hidden type must conflict, too.\n+impl Bop for i32 {}\n+//~^ ERROR conflicting implementations\n+\n+fn main() {\n+}"}, {"sha": "aaf75cc3db97c48316aff9408b4ad11a53214318", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94fe30ff2fa39a912325121846074a659e8ec420/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94fe30ff2fa39a912325121846074a659e8ec420/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr?ref=94fe30ff2fa39a912325121846074a659e8ec420", "patch": "@@ -0,0 +1,30 @@\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:17:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Bar<i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:26:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Barr {}\n+   | ^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:30:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for i32 {}\n+   | ^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}]}