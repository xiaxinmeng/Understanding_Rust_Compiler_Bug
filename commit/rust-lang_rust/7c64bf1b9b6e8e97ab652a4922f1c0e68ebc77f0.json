{"sha": "7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNjRiZjFiOWI2ZThlOTdhYjY1MmE0OTIyZjFjMGU2OGViYzc3ZjA=", "commit": {"author": {"name": "Kamal Marhubi", "email": "kamal@marhubi.com", "date": "2016-01-15T20:29:45Z"}, "committer": {"name": "Kamal Marhubi", "email": "kamal@marhubi.com", "date": "2016-02-03T15:54:29Z"}, "message": "std: Properly handle interior NULs in std::process\n\nThis reports an error at the point of calling `Command::spawn()` or one of\nits equivalents.\n\nFixes https://github.com/rust-lang/rust/issues/30858\nFixes https://github.com/rust-lang/rust/issues/30862", "tree": {"sha": "52eef97ff332e10c18c7469df5d296fc4f64ef0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52eef97ff332e10c18c7469df5d296fc4f64ef0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "html_url": "https://github.com/rust-lang/rust/commit/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/comments", "author": {"login": "kamalmarhubi", "id": 50936, "node_id": "MDQ6VXNlcjUwOTM2", "avatar_url": "https://avatars.githubusercontent.com/u/50936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kamalmarhubi", "html_url": "https://github.com/kamalmarhubi", "followers_url": "https://api.github.com/users/kamalmarhubi/followers", "following_url": "https://api.github.com/users/kamalmarhubi/following{/other_user}", "gists_url": "https://api.github.com/users/kamalmarhubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/kamalmarhubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kamalmarhubi/subscriptions", "organizations_url": "https://api.github.com/users/kamalmarhubi/orgs", "repos_url": "https://api.github.com/users/kamalmarhubi/repos", "events_url": "https://api.github.com/users/kamalmarhubi/events{/privacy}", "received_events_url": "https://api.github.com/users/kamalmarhubi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kamalmarhubi", "id": 50936, "node_id": "MDQ6VXNlcjUwOTM2", "avatar_url": "https://avatars.githubusercontent.com/u/50936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kamalmarhubi", "html_url": "https://github.com/kamalmarhubi", "followers_url": "https://api.github.com/users/kamalmarhubi/followers", "following_url": "https://api.github.com/users/kamalmarhubi/following{/other_user}", "gists_url": "https://api.github.com/users/kamalmarhubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/kamalmarhubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kamalmarhubi/subscriptions", "organizations_url": "https://api.github.com/users/kamalmarhubi/orgs", "repos_url": "https://api.github.com/users/kamalmarhubi/repos", "events_url": "https://api.github.com/users/kamalmarhubi/events{/privacy}", "received_events_url": "https://api.github.com/users/kamalmarhubi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28bed3f5e64dfc083dc193412b65d95533a61d72", "url": "https://api.github.com/repos/rust-lang/rust/commits/28bed3f5e64dfc083dc193412b65d95533a61d72", "html_url": "https://github.com/rust-lang/rust/commit/28bed3f5e64dfc083dc193412b65d95533a61d72"}], "stats": {"total": 215, "additions": 163, "deletions": 52}, "files": [{"sha": "2456226b54cdeadfcd1169b0e0f36e353795c47c", "filename": "src/libstd/process.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "patch": "@@ -343,11 +343,7 @@ impl fmt::Debug for Command {\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.inner.program));\n-        for arg in &self.inner.args {\n-            try!(write!(f, \" {:?}\", arg));\n-        }\n-        Ok(())\n+        self.inner.fmt(f)\n     }\n }\n \n@@ -877,4 +873,54 @@ mod tests {\n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n+\n+    // Regression tests for #30858.\n+    #[test]\n+    fn test_interior_nul_in_progname_is_error() {\n+        match Command::new(\"has-some-\\0\\0s-inside\").spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_interior_nul_in_arg_is_error() {\n+        match Command::new(\"echo\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_interior_nul_in_args_is_error() {\n+        match Command::new(\"echo\").args(&[\"has-some-\\0\\0s-inside\"]).spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_interior_nul_in_current_dir_is_error() {\n+        match Command::new(\"echo\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n+\n+    // Regression tests for #30862.\n+    #[test]\n+    fn test_interior_nul_in_env_key_is_error() {\n+        match env_cmd().env(\"has-some-\\0\\0s-inside\", \"value\").spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_interior_nul_in_env_value_is_error() {\n+        match env_cmd().env(\"key\", \"has-some-\\0\\0s-inside\").spawn() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n+            Ok(_) => panic!(),\n+        }\n+    }\n }"}, {"sha": "212aeb0406ebadaae897c2b8689bcfadfffe5c75", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "patch": "@@ -49,17 +49,17 @@ pub trait CommandExt {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CommandExt for process::Command {\n     fn uid(&mut self, id: uid_t) -> &mut process::Command {\n-        self.as_inner_mut().uid = Some(id);\n+        self.as_inner_mut().uid(id);\n         self\n     }\n \n     fn gid(&mut self, id: gid_t) -> &mut process::Command {\n-        self.as_inner_mut().gid = Some(id);\n+        self.as_inner_mut().gid(id);\n         self\n     }\n \n     fn session_leader(&mut self, on: bool) -> &mut process::Command {\n-        self.as_inner_mut().session_leader = on;\n+        self.as_inner_mut().session_leader(on);\n         self\n     }\n }"}, {"sha": "04b39f0851a3f760e2a7e58711aa7a9f8f9e8b2c", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "patch": "@@ -31,57 +31,95 @@ use sys::{self, cvt, cvt_r};\n \n #[derive(Clone)]\n pub struct Command {\n-    pub program: CString,\n-    pub args: Vec<CString>,\n-    pub env: Option<HashMap<OsString, OsString>>,\n-    pub cwd: Option<CString>,\n-    pub uid: Option<uid_t>,\n-    pub gid: Option<gid_t>,\n-    pub session_leader: bool,\n+    program: CString,\n+    args: Vec<CString>,\n+    env: Option<HashMap<OsString, OsString>>, // Guaranteed to have no NULs.\n+    cwd: Option<CString>,\n+    uid: Option<uid_t>,\n+    gid: Option<gid_t>,\n+    session_leader: bool,\n+    saw_nul: bool,\n }\n \n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n+        let mut saw_nul = false;\n         Command {\n-            program: os2c(program),\n+            program: os2c(program, &mut saw_nul),\n             args: Vec::new(),\n             env: None,\n             cwd: None,\n             uid: None,\n             gid: None,\n             session_leader: false,\n+            saw_nul: saw_nul,\n         }\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(os2c(arg));\n+        self.args.push(os2c(arg, &mut self.saw_nul));\n     }\n     pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        self.args.extend(args.map(os2c));\n+        let mut saw_nul = self.saw_nul;\n+        self.args.extend(args.map(|arg| os2c(arg, &mut saw_nul)));\n+        self.saw_nul = saw_nul;\n     }\n     fn init_env_map(&mut self) {\n         if self.env.is_none() {\n+            // Will not add NULs to env: preexisting environment will not contain any.\n             self.env = Some(env::vars_os().collect());\n         }\n     }\n     pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        let k = OsString::from_vec(os2c(key, &mut self.saw_nul).into_bytes());\n+        let v = OsString::from_vec(os2c(val, &mut self.saw_nul).into_bytes());\n+\n+        // Will not add NULs to env: return without inserting if any were seen.\n+        if self.saw_nul {\n+            return;\n+        }\n+\n         self.init_env_map();\n-        self.env.as_mut().unwrap().insert(key.to_os_string(), val.to_os_string());\n+        self.env.as_mut()\n+            .unwrap()\n+            .insert(k, v);\n     }\n     pub fn env_remove(&mut self, key: &OsStr) {\n         self.init_env_map();\n-        self.env.as_mut().unwrap().remove(&key.to_os_string());\n+        self.env.as_mut().unwrap().remove(key);\n     }\n     pub fn env_clear(&mut self) {\n         self.env = Some(HashMap::new())\n     }\n     pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(os2c(dir));\n+        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n+    }\n+    pub fn uid(&mut self, id: uid_t) {\n+        self.uid = Some(id);\n     }\n+    pub fn gid(&mut self, id: gid_t) {\n+        self.gid = Some(id);\n+    }\n+    pub fn session_leader(&mut self, session_leader: bool) {\n+        self.session_leader = session_leader;\n+    }\n+}\n+\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n }\n \n-fn os2c(s: &OsStr) -> CString {\n-    CString::new(s.as_bytes()).unwrap()\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -175,6 +213,10 @@ impl Process {\n                  in_fd: Stdio,\n                  out_fd: Stdio,\n                  err_fd: Stdio) -> io::Result<Process> {\n+        if cfg.saw_nul {\n+            return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n+        }\n+\n         let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n         let (envp, _a, _b) = make_envp(cfg.env.as_ref());"}, {"sha": "61cf28be16f918072868d04e2d55c4ff5acbf47b", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=7c64bf1b9b6e8e97ab652a4922f1c0e68ebc77f0", "patch": "@@ -18,7 +18,7 @@ use env;\n use ffi::{OsString, OsStr};\n use fmt;\n use fs;\n-use io::{self, Error};\n+use io::{self, Error, ErrorKind};\n use libc::c_void;\n use mem;\n use os::windows::ffi::OsStrExt;\n@@ -43,13 +43,21 @@ fn mk_key(s: &OsStr) -> OsString {\n     })\n }\n \n+fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n+    if str.as_ref().encode_wide().any(|b| b == 0) {\n+        Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n+    } else {\n+        Ok(str)\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct Command {\n-    pub program: OsString,\n-    pub args: Vec<OsString>,\n-    pub env: Option<HashMap<OsString, OsString>>,\n-    pub cwd: Option<OsString>,\n-    pub detach: bool, // not currently exposed in std::process\n+    program: OsString,\n+    args: Vec<OsString>,\n+    env: Option<HashMap<OsString, OsString>>,\n+    cwd: Option<OsString>,\n+    detach: bool, // not currently exposed in std::process\n }\n \n impl Command {\n@@ -92,6 +100,16 @@ impl Command {\n     }\n }\n \n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.program));\n+        for arg in &self.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Processes\n ////////////////////////////////////////////////////////////////////////////////\n@@ -153,7 +171,7 @@ impl Process {\n         si.hStdError = stderr.raw();\n \n         let program = program.as_ref().unwrap_or(&cfg.program);\n-        let mut cmd_str = make_command_line(program, &cfg.args);\n+        let mut cmd_str = try!(make_command_line(program, &cfg.args));\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -162,8 +180,8 @@ impl Process {\n             flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        let (envp, _data) = make_envp(cfg.env.as_ref());\n-        let (dirp, _data) = make_dirp(cfg.cwd.as_ref());\n+        let (envp, _data) = try!(make_envp(cfg.env.as_ref()));\n+        let (dirp, _data) = try!(make_dirp(cfg.cwd.as_ref()));\n         let mut pi = zeroed_process_information();\n         try!(unsafe {\n             // `CreateProcess` is racy!\n@@ -265,22 +283,24 @@ fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n     }\n }\n \n-// Produces a wide string *without terminating null*\n-fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n+// Produces a wide string *without terminating null*; returns an error if\n+// `prog` or any of the `args` contain a nul.\n+fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n-    append_arg(&mut cmd, prog);\n+    try!(append_arg(&mut cmd, prog));\n     for arg in args {\n         cmd.push(' ' as u16);\n-        append_arg(&mut cmd, arg);\n+        try!(append_arg(&mut cmd, arg));\n     }\n-    return cmd;\n+    return Ok(cmd);\n \n-    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) {\n+    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) -> io::Result<()> {\n         // If an argument has 0 characters then we need to quote it to ensure\n         // that it actually gets passed through on the command line or otherwise\n         // it will be dropped entirely when parsed on the other end.\n+        try!(ensure_no_nuls(arg));\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n         let quote = arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n             || arg_bytes.is_empty();\n@@ -312,11 +332,12 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n             }\n             cmd.push('\"' as u16);\n         }\n+        Ok(())\n     }\n }\n \n fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n-             -> (*mut c_void, Vec<u16>) {\n+             -> io::Result<(*mut c_void, Vec<u16>)> {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -325,26 +346,27 @@ fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n             let mut blk = Vec::new();\n \n             for pair in env {\n-                blk.extend(pair.0.encode_wide());\n+                blk.extend(try!(ensure_no_nuls(pair.0)).encode_wide());\n                 blk.push('=' as u16);\n-                blk.extend(pair.1.encode_wide());\n+                blk.extend(try!(ensure_no_nuls(pair.1)).encode_wide());\n                 blk.push(0);\n             }\n             blk.push(0);\n-            (blk.as_mut_ptr() as *mut c_void, blk)\n+            Ok((blk.as_mut_ptr() as *mut c_void, blk))\n         }\n-        _ => (ptr::null_mut(), Vec::new())\n+        _ => Ok((ptr::null_mut(), Vec::new()))\n     }\n }\n \n-fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n+fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n+\n     match d {\n         Some(dir) => {\n-            let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n+            let mut dir_str: Vec<u16> = try!(ensure_no_nuls(dir)).encode_wide().collect();\n             dir_str.push(0);\n-            (dir_str.as_ptr(), dir_str)\n+            Ok((dir_str.as_ptr(), dir_str))\n         },\n-        None => (ptr::null(), Vec::new())\n+        None => Ok((ptr::null(), Vec::new()))\n     }\n }\n \n@@ -397,11 +419,12 @@ mod tests {\n     #[test]\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n-            String::from_utf16(\n-                &make_command_line(OsStr::new(prog),\n-                                   &args.iter()\n-                                        .map(|a| OsString::from(a))\n-                                        .collect::<Vec<OsString>>())).unwrap()\n+            let command_line = &make_command_line(OsStr::new(prog),\n+                                                  &args.iter()\n+                                                       .map(|a| OsString::from(a))\n+                                                       .collect::<Vec<OsString>>())\n+                                    .unwrap();\n+            String::from_utf16(command_line).unwrap()\n         }\n \n         assert_eq!("}]}