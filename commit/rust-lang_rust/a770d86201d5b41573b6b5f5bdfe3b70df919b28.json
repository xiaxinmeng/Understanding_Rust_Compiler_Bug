{"sha": "a770d86201d5b41573b6b5f5bdfe3b70df919b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NzBkODYyMDFkNWI0MTU3M2I2YjVmNWJkZmUzYjcwZGY5MTliMjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T22:21:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T22:22:08Z"}, "message": "rustc: Move generally useful functions out of shape.rs in preparation for its destruction", "tree": {"sha": "c63aeb511f2af3ff2f0a3f0330c2528ead5a6fda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c63aeb511f2af3ff2f0a3f0330c2528ead5a6fda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a770d86201d5b41573b6b5f5bdfe3b70df919b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a770d86201d5b41573b6b5f5bdfe3b70df919b28", "html_url": "https://github.com/rust-lang/rust/commit/a770d86201d5b41573b6b5f5bdfe3b70df919b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a770d86201d5b41573b6b5f5bdfe3b70df919b28/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "349ef79ce7aca24f6633893285cc9a5fc9dd7f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/349ef79ce7aca24f6633893285cc9a5fc9dd7f37", "html_url": "https://github.com/rust-lang/rust/commit/349ef79ce7aca24f6633893285cc9a5fc9dd7f37"}], "stats": {"total": 293, "additions": 150, "deletions": 143}, "files": [{"sha": "5515d80f4bdea18ac81c8e90872197abb21e19a7", "filename": "src/rustc/middle/trans/machine.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=a770d86201d5b41573b6b5f5bdfe3b70df919b28", "patch": "@@ -0,0 +1,148 @@\n+// Information concerning the machine representation of various types.\n+\n+use middle::trans::common::*;\n+\n+// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n+// to have (a) the same size as the type that was passed in; (b) to be non-\n+// recursive. This is done by replacing all boxes in a type with boxed unit\n+// types.\n+// This should reduce all pointers to some simple pointer type, to\n+// ensure that we don't recurse endlessly when computing the size of a\n+// nominal type that has pointers to itself in it.\n+pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n+    fn nilptr(tcx: ty::ctxt) -> ty::t {\n+        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n+    }\n+    fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n+        match ty::get(typ).sty {\n+          ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n+          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n+          ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n+          ty::ty_ptr(_) | ty::ty_rptr(_,_) => nilptr(tcx),\n+          ty::ty_fn(_) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n+          ty::ty_evec(_, ty::vstore_slice(_)) |\n+          ty::ty_estr(ty::vstore_slice(_)) => {\n+            ty::mk_tup(tcx, ~[nilptr(tcx), ty::mk_int(tcx)])\n+          }\n+          // Reduce a class type to a record type in which all the fields are\n+          // simplified\n+          ty::ty_class(did, ref substs) => {\n+            let simpl_fields = (if ty::ty_dtor(tcx, did).is_some() {\n+                // remember the drop flag\n+                  ~[{ident: syntax::parse::token::special_idents::dtor,\n+                     mt: {ty: ty::mk_u8(tcx),\n+                          mutbl: ast::m_mutbl}}] }\n+                else { ~[] }) +\n+                do ty::lookup_class_fields(tcx, did).map |f| {\n+                 let t = ty::lookup_field_type(tcx, did, f.id, substs);\n+                 {ident: f.ident,\n+                  mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n+            };\n+            ty::mk_rec(tcx, simpl_fields)\n+          }\n+          _ => typ\n+        }\n+    }\n+    ty::fold_ty(tcx, typ, |t| simplifier(tcx, t))\n+}\n+\n+// ______________________________________________________________________\n+// compute sizeof / alignof\n+\n+pub type metrics = {\n+    bcx: block,\n+    sz: ValueRef,\n+    align: ValueRef\n+};\n+\n+pub type tag_metrics = {\n+    bcx: block,\n+    sz: ValueRef,\n+    align: ValueRef,\n+    payload_align: ValueRef\n+};\n+\n+// Returns the number of bytes clobbered by a Store to this type.\n+pub fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns the number of bytes between successive elements of type T in an\n+// array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n+pub fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns, as near as we can figure, the \"real\" size of a type. As in, the\n+// bits in this number of bytes actually carry data related to the datum\n+// with the type. Not junk, padding, accidentally-damaged words, or\n+// whatever. Rounds up to the nearest byte though, so if you have a 1-bit\n+// value, we return 1 here, not 0. Most of rustc works in bytes.\n+pub fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n+    if nbits & 7u != 0u {\n+        // Not an even number of bytes, spills into \"next\" byte.\n+        1u + (nbits >> 3)\n+    } else {\n+        nbits >> 3\n+    }\n+}\n+\n+// Returns the \"default\" size of t, which is calculated by casting null to a\n+// *T and then doing gep(1) on it and measuring the result. Really, look in\n+// the LLVM sources. It does that. So this is likely similar to the ABI size\n+// (i.e. including alignment-padding), but goodness knows which alignment it\n+// winds up using. Probably the ABI one? Not recommended.\n+pub fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    return llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n+                               False);\n+}\n+\n+// Returns the preferred alignment of the given type for the current target.\n+// The preffered alignment may be larger than the alignment used when\n+// packing the type into structs. This will be used for things like\n+// allocations inside a stack frame, which LLVM has a free hand in.\n+pub fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns the minimum alignment of a type required by the plattform.\n+// This is the alignment that will be used for struct fields, arrays,\n+// and similar ABI-mandated things.\n+pub fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns the \"default\" alignment of t, which is calculated by casting\n+// null to a record containing a single-bit followed by a t value, then\n+// doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n+pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    return llvm::LLVMConstIntCast(\n+        lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n+}\n+\n+// Computes the size of the data part of an enum.\n+pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n+    if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n+    match ty::get(t).sty {\n+      ty::ty_enum(tid, ref substs) => {\n+        // Compute max(variant sizes).\n+        let mut max_size = 0u;\n+        let variants = ty::enum_variants(cx.tcx, tid);\n+        for vec::each(*variants) |variant| {\n+            let tup_ty = simplify_type(cx.tcx,\n+                                       ty::mk_tup(cx.tcx, variant.args));\n+            // Perform any type parameter substitutions.\n+            let tup_ty = ty::subst(cx.tcx, substs, tup_ty);\n+            // Here we possibly do a recursive call.\n+            let this_size =\n+                llsize_of_real(cx, type_of::type_of(cx, tup_ty));\n+            if max_size < this_size { max_size = this_size; }\n+        }\n+        cx.enum_sizes.insert(t, max_size);\n+        return max_size;\n+      }\n+      _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n+    }\n+}\n+"}, {"sha": "28d24be77df1590ca329d63c484c64005e4d9541", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 143, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=a770d86201d5b41573b6b5f5bdfe3b70df919b28", "patch": "@@ -7,6 +7,7 @@ use driver::session;\n use driver::session::session;\n use trans::base;\n use middle::trans::common::*;\n+use middle::trans::machine::*;\n use back::abi;\n use middle::ty;\n use middle::ty::field;\n@@ -634,151 +635,8 @@ fn gen_shape_tables(ccx: @crate_ctxt) {\n                           lib::llvm::InternalLinkage);\n }\n \n-// ______________________________________________________________________\n-// compute sizeof / alignof\n-\n-type metrics = {\n-    bcx: block,\n-    sz: ValueRef,\n-    align: ValueRef\n-};\n-\n-type tag_metrics = {\n-    bcx: block,\n-    sz: ValueRef,\n-    align: ValueRef,\n-    payload_align: ValueRef\n-};\n-\n-// Returns the number of bytes clobbered by a Store to this type.\n-fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns the number of bytes between successive elements of type T in an\n-// array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns, as near as we can figure, the \"real\" size of a type. As in, the\n-// bits in this number of bytes actually carry data related to the datum\n-// with the type. Not junk, padding, accidentally-damaged words, or\n-// whatever. Rounds up to the nearest byte though, so if you have a 1-bit\n-// value, we return 1 here, not 0. Most of rustc works in bytes.\n-fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n-    if nbits & 7u != 0u {\n-        // Not an even number of bytes, spills into \"next\" byte.\n-        1u + (nbits >> 3)\n-    } else {\n-        nbits >> 3\n-    }\n-}\n-\n-// Returns the \"default\" size of t, which is calculated by casting null to a\n-// *T and then doing gep(1) on it and measuring the result. Really, look in\n-// the LLVM sources. It does that. So this is likely similar to the ABI size\n-// (i.e. including alignment-padding), but goodness knows which alignment it\n-// winds up using. Probably the ABI one? Not recommended.\n-fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    return llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n-                               False);\n-}\n-\n-// Returns the preferred alignment of the given type for the current target.\n-// The preffered alignment may be larger than the alignment used when\n-// packing the type into structs. This will be used for things like\n-// allocations inside a stack frame, which LLVM has a free hand in.\n-fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns the minimum alignment of a type required by the plattform.\n-// This is the alignment that will be used for struct fields, arrays,\n-// and similar ABI-mandated things.\n-fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns the \"default\" alignment of t, which is calculated by casting\n-// null to a record containing a single-bit followed by a t value, then\n-// doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    return llvm::LLVMConstIntCast(\n-        lib::llvm::llvm::LLVMAlignOf(t), cx.int_type, False);\n-}\n-\n // Computes the static size of a enum, without using mk_tup(), which is\n // bad for performance.\n //\n // NB: Migrate trans over to use this.\n \n-// Computes the size of the data part of an enum.\n-fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n-    match ty::get(t).sty {\n-      ty::ty_enum(tid, ref substs) => {\n-        // Compute max(variant sizes).\n-        let mut max_size = 0u;\n-        let variants = ty::enum_variants(cx.tcx, tid);\n-        for vec::each(*variants) |variant| {\n-            let tup_ty = simplify_type(cx.tcx,\n-                                       ty::mk_tup(cx.tcx, variant.args));\n-            // Perform any type parameter substitutions.\n-            let tup_ty = ty::subst(cx.tcx, substs, tup_ty);\n-            // Here we possibly do a recursive call.\n-            let this_size =\n-                llsize_of_real(cx, type_of::type_of(cx, tup_ty));\n-            if max_size < this_size { max_size = this_size; }\n-        }\n-        cx.enum_sizes.insert(t, max_size);\n-        return max_size;\n-      }\n-      _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n-    }\n-}\n-\n-// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n-// to have (a) the same size as the type that was passed in; (b) to be non-\n-// recursive. This is done by replacing all boxes in a type with boxed unit\n-// types.\n-// This should reduce all pointers to some simple pointer type, to\n-// ensure that we don't recurse endlessly when computing the size of a\n-// nominal type that has pointers to itself in it.\n-fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-    fn nilptr(tcx: ty::ctxt) -> ty::t {\n-        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n-    }\n-    fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n-        match ty::get(typ).sty {\n-          ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n-          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n-          ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_ptr(_) | ty::ty_rptr(_,_) => nilptr(tcx),\n-          ty::ty_fn(_) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n-          ty::ty_evec(_, ty::vstore_slice(_)) |\n-          ty::ty_estr(ty::vstore_slice(_)) => {\n-            ty::mk_tup(tcx, ~[nilptr(tcx), ty::mk_int(tcx)])\n-          }\n-          // Reduce a class type to a record type in which all the fields are\n-          // simplified\n-          ty::ty_class(did, ref substs) => {\n-            let simpl_fields = (if ty::ty_dtor(tcx, did).is_some() {\n-                // remember the drop flag\n-                  ~[{ident: syntax::parse::token::special_idents::dtor,\n-                     mt: {ty: ty::mk_u8(tcx),\n-                          mutbl: ast::m_mutbl}}] }\n-                else { ~[] }) +\n-                do ty::lookup_class_fields(tcx, did).map |f| {\n-                 let t = ty::lookup_field_type(tcx, did, f.id, substs);\n-                 {ident: f.ident,\n-                  mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n-            };\n-            ty::mk_rec(tcx, simpl_fields)\n-          }\n-          _ => typ\n-        }\n-    }\n-    ty::fold_ty(tcx, typ, |t| simplifier(tcx, t))\n-}"}, {"sha": "ca5491245e0f5148a7a4f0e3a77989f5bdd78808", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a770d86201d5b41573b6b5f5bdfe3b70df919b28/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=a770d86201d5b41573b6b5f5bdfe3b70df919b28", "patch": "@@ -86,6 +86,7 @@ mod middle {\n         mod type_use;\n         #[legacy_exports]\n         mod reachable;\n+        mod machine;\n     }\n     #[legacy_exports]\n     mod ty;"}]}