{"sha": "0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MDVmYzY3NTAxZThlNzRmNWRkN2U1N2I5ZGNmMDg1YWNlNmNhMDg=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-09-01T22:50:37Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-09-01T22:50:37Z"}, "message": "Merge pull request #3343 from killerswan/modes9\n\nMore deprecated mode removal (sort.rs, fun_treemap.rs)", "tree": {"sha": "2759c1a0054324d63886fe3790d2aec4e0dd4a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2759c1a0054324d63886fe3790d2aec4e0dd4a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "html_url": "https://github.com/rust-lang/rust/commit/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aea422014bb16a799522acbae3c7986052dde056", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea422014bb16a799522acbae3c7986052dde056", "html_url": "https://github.com/rust-lang/rust/commit/aea422014bb16a799522acbae3c7986052dde056"}, {"sha": "134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "html_url": "https://github.com/rust-lang/rust/commit/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8"}], "stats": {"total": 47, "additions": 30, "deletions": 17}, "files": [{"sha": "17a448001bd5ce35ecc33c5e313547f61022297d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1499,7 +1499,8 @@ fn print_pkg(s: source, p: package) {\n fn print_source(s: source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n-    let pks = sort::merge_sort(sys::shape_lt, copy s.packages);\n+    let unsorted_pks = s.packages;  // to prevent illegal borrow?\n+    let pks = sort::merge_sort(sys::shape_lt, unsorted_pks);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {"}, {"sha": "d0552c64c99453959146075a777e303e469d13c0", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n #[deny(non_camel_case_types)];\n import io::Reader;\n "}, {"sha": "2325b0e092e4ee88d6c72d6c98480b18eec358ad", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /// A dynamic, mutable location.\n ///\n /// Similar to a mutable option type, but friendlier."}, {"sha": "2cd5f8e24d136bf85809cbb2123d1c99a69c30ce", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,4 +1,6 @@\n #[deny(non_camel_case_types)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n /*!\n  * A functional key,value store that works on anything.\n@@ -32,8 +34,8 @@ enum TreeNode<K, V> {\n fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, k: K, v: V)\n-                                -> Treemap<K, V> {\n+fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, +k: K, +v: V)\n+  -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n        @Node(@kk, vv, left, right) => {\n@@ -47,7 +49,7 @@ fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, k: K, v: V)\n }\n \n /// Find a value based on the key\n-fn find<K: Eq Ord, V: copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n+fn find<K: Eq Ord, V: copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@kk, @v, left, right) => {"}, {"sha": "9e2770a1f02323976b9aaf3751d6e0d50d225c68", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,6 +1,7 @@\n //! A map type\n \n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n import io::WriterUtil;\n import to_str::ToStr;"}, {"sha": "07552a0a94f859d7910ee41ac92ae6818b36da1b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,4 +1,7 @@\n //! Sorting methods\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import vec::{len, push};\n import core::cmp::{Eq, Ord};\n \n@@ -15,12 +18,12 @@ type le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n+fn merge_sort<T: copy>(le: le<T>, v: &[const T]) -> ~[T] {\n     type slice = (uint, uint);\n \n     return merge_sort_(le, v, (0u, len(v)));\n \n-    fn merge_sort_<T: copy>(le: le<T>, v: ~[const T], slice: slice)\n+    fn merge_sort_<T: copy>(le: le<T>, v: &[const T], slice: slice)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -35,7 +38,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n         return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n     }\n \n-    fn merge<T: copy>(le: le<T>, a: ~[T], b: ~[T]) -> ~[T] {\n+    fn merge<T: copy>(le: le<T>, a: &[T], b: &[T]) -> ~[T] {\n         let mut rs = ~[];\n         vec::reserve(rs, len(a) + len(b));\n         let a_len = len(a);\n@@ -54,7 +57,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n     }\n }\n \n-fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n+fn part<T: copy>(compare_func: le<T>, arr: &[mut T], left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -71,7 +74,7 @@ fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n+fn qsort<T: copy>(compare_func: le<T>, arr: &[mut T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -90,12 +93,12 @@ fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-fn quick_sort<T: copy>(compare_func: le<T>, arr: ~[mut T]) {\n+fn quick_sort<T: copy>(compare_func: le<T>, arr: &[mut T]) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n-fn qsort3<T: copy Ord Eq>(arr: ~[mut T], left: int, right: int) {\n+fn qsort3<T: copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -152,14 +155,14 @@ fn qsort3<T: copy Ord Eq>(arr: ~[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-fn quick_sort3<T: copy Ord Eq>(arr: ~[mut T]) {\n+fn quick_sort3<T: copy Ord Eq>(arr: &[mut T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n-    fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n+    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0u;\n@@ -198,7 +201,7 @@ mod test_qsort3 {\n \n #[cfg(test)]\n mod test_qsort {\n-    fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n+    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(leual, v1);\n@@ -258,7 +261,7 @@ mod test_qsort {\n #[cfg(test)]\n mod tests {\n \n-    fn check_sort(v1: ~[int], v2: ~[int]) {\n+    fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n         pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;"}, {"sha": "9136ad2708f5c3f49d51f53f125f696eb3b66c52", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0505fc67501e8e74f5dd7e57b9dcf085ace6ca08/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=0505fc67501e8e74f5dd7e57b9dcf085ace6ca08", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n mod icu {\n     type UBool = u8;\n@@ -231,4 +233,4 @@ mod tests {\n         assert (unicode::icu::is_upper('M'));\n         assert (!unicode::icu::is_upper('m'));\n     }\n-}\n\\ No newline at end of file\n+}"}]}