{"sha": "7ec6df5f458c599e16641ec3d1265622743054ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYzZkZjVmNDU4YzU5OWUxNjY0MWVjM2QxMjY1NjIyNzQzMDU0ZmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-29T20:50:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-01T04:59:50Z"}, "message": "rustdoc: Fix cross-crate links to reexported items\n\nCross crate links can target items which are not rendered in the documentation.\nIf the item is reexported at a higher level, the destination of the link (a\nconcatenation of the fully qualified name) may actually lead to nowhere. This\nfixes this problem by altering rustdoc to emit pages which redirect to the local\ncopy of the reexported structure.\n\ncc #14515\nCloses #14137", "tree": {"sha": "247b30baa2e853b2ac3207b05519ec3f4d4abfe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/247b30baa2e853b2ac3207b05519ec3f4d4abfe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ec6df5f458c599e16641ec3d1265622743054ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec6df5f458c599e16641ec3d1265622743054ff", "html_url": "https://github.com/rust-lang/rust/commit/7ec6df5f458c599e16641ec3d1265622743054ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ec6df5f458c599e16641ec3d1265622743054ff/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5830a954e3be1cc19f7ec4700599fcb0030b1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5830a954e3be1cc19f7ec4700599fcb0030b1fd", "html_url": "https://github.com/rust-lang/rust/commit/c5830a954e3be1cc19f7ec4700599fcb0030b1fd"}], "stats": {"total": 128, "additions": 98, "deletions": 30}, "files": [{"sha": "4e1a96710be84b044834a51305331e9f199975f5", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -511,7 +511,7 @@ function is never called.\n With the above techniques, we've got a bare-metal executable running some Rust\n code. There is a good deal of functionality provided by the standard library,\n however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](../core/index.html) is designed to be used\n+not sufficient, then [libcore](core/index.html) is designed to be used\n instead.\n \n The core library has very few dependencies and is much more portable than the"}, {"sha": "22aab89ef6279c1841223523413f4310fd658cd5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -104,12 +104,27 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         let id = link::find_crate_id(self.attrs.as_slice(),\n                                      t_outputs.out_filestem.as_slice());\n \n-        // Clean the module, translating the entire libsyntax AST to one that is\n+        // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n         let mut module = self.module.clean();\n \n         // Collect all inner modules which are tagged as implementations of\n         // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n         let mut primitives = Vec::new();\n         {\n             let m = match module.inner {"}, {"sha": "41d84deea6f4105661c96cdf66cfb742ef8064a7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -424,14 +424,8 @@ impl fmt::Show for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                try!(f.write(\"(\".as_bytes()));\n-                for (i, typ) in typs.iter().enumerate() {\n-                    if i > 0 {\n-                        try!(f.write(\", \".as_bytes()))\n-                    }\n-                    try!(write!(f, \"{}\", *typ));\n-                }\n-                f.write(\")\".as_bytes())\n+                primitive_link(f, clean::PrimitiveTuple,\n+                               format!(\"({:#})\", typs).as_slice())\n             }\n             clean::Vector(ref t) => {\n                 primitive_link(f, clean::Slice, format!(\"[{}]\", **t).as_slice())"}, {"sha": "80653878247fad444f20c419a7db4d955731c736", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -130,3 +130,17 @@ r##\"<!DOCTYPE html>\n fn nonestr<'a>(s: &'a str) -> &'a str {\n     if s == \"\" { \"none\" } else { s }\n }\n+\n+pub fn redirect(dst: &mut io::Writer, url: &str) -> io::IoResult<()> {\n+    write!(dst,\n+r##\"<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL={url}\">\n+</head>\n+<body>\n+</body>\n+</html>\"##,\n+    url = url,\n+    )\n+}"}, {"sha": "16becde164ff3e2a3dd27fd16517fbdc83e1c596", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -70,7 +70,7 @@ use html::markdown;\n pub struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<String> ,\n+    pub current: Vec<String>,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n@@ -90,6 +90,10 @@ pub struct Context {\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n     pub include_sources: bool,\n+    /// A flag, which when turned off, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n }\n \n /// Indicates where an external crate can be found.\n@@ -227,6 +231,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             krate: krate.name.clone(),\n         },\n         include_sources: true,\n+        render_redirect_pages: false,\n     };\n     try!(mkdir(&cx.dst));\n \n@@ -493,7 +498,17 @@ fn write_shared(cx: &Context,\n     let dst = cx.dst.join(\"implementors\");\n     try!(mkdir(&dst));\n     for (&did, imps) in cache.implementors.iter() {\n-        let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n+        // Private modules can leak through to this phase of rustdoc, which\n+        // could contain implementations for otherwise private types. In some\n+        // rare cases we could find an implementation for an item which wasn't\n+        // indexed, so we just skip this step in that case.\n+        //\n+        // FIXME: this is a vague explanation for why this can't be a `get`, in\n+        //        theory it should be...\n+        let &(ref remote_path, remote_item_type) = match cache.paths.find(&did) {\n+            Some(p) => p,\n+            None => continue,\n+        };\n \n         let mut mydst = dst.clone();\n         for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n@@ -823,7 +838,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) => {\n+            clean::ForeignFunctionItem(..) if !self.privmod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -840,7 +855,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) => {\n+            clean::VariantItem(..) if !self.privmod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, item_type::Enum));\n@@ -932,14 +947,6 @@ impl DocFolder for Cache {\n                         }\n                         None\n                     }\n-                    // Private modules may survive the strip-private pass if\n-                    // they contain impls for public types, but those will get\n-                    // stripped here\n-                    clean::Item { inner: clean::ModuleItem(ref m),\n-                                  visibility, .. }\n-                            if (m.items.len() == 0 &&\n-                                item.doc_value().is_none()) ||\n-                               visibility != Some(ast::Public) => None,\n \n                     i => Some(i),\n                 }\n@@ -1020,7 +1027,7 @@ impl Context {\n     /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item,\n             f: |&mut Context, clean::Item|) -> io::IoResult<()> {\n-        fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n+        fn render(w: io::File, cx: &Context, it: &clean::Item,\n                   pushname: bool) -> io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n@@ -1047,16 +1054,42 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            try!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                                &Sidebar{ cx: cx, item: it },\n-                                &Item{ cx: cx, item: it }));\n+            if !cx.render_redirect_pages {\n+                try!(layout::render(&mut writer, &cx.layout, &page,\n+                                    &Sidebar{ cx: cx, item: it },\n+                                    &Item{ cx: cx, item: it }));\n+            } else {\n+                let mut url = \"../\".repeat(cx.current.len());\n+                match cache_key.get().unwrap().paths.find(&it.def_id) {\n+                    Some(&(ref names, _)) => {\n+                        for name in names.slice_to(names.len() - 1).iter() {\n+                            url.push_str(name.as_slice());\n+                            url.push_str(\"/\");\n+                        }\n+                        url.push_str(item_path(it).as_slice());\n+                        try!(layout::redirect(&mut writer, url.as_slice()));\n+                    }\n+                    None => {}\n+                }\n+            }\n             writer.flush()\n         }\n \n         match item.inner {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n+                // Private modules may survive the strip-private pass if they\n+                // contain impls for public types. These modules can also\n+                // contain items such as publicly reexported structures.\n+                //\n+                // External crates will provide links to these structures, so\n+                // these modules are recursed into, but not rendered normally (a\n+                // flag on the context).\n+                if !self.render_redirect_pages {\n+                    self.render_redirect_pages = ignore_private_module(&item);\n+                }\n+\n                 let name = item.name.get_ref().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n@@ -1289,8 +1322,9 @@ fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n-    debug!(\"{:?}\", items);\n-    let mut indices = Vec::from_fn(items.len(), |i| i);\n+    let mut indices = range(0, items.len()).filter(|i| {\n+        !ignore_private_module(&items[*i])\n+    }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {\n@@ -1332,7 +1366,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n     }\n \n-    debug!(\"{:?}\", indices);\n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n@@ -1976,6 +2009,8 @@ impl<'a> fmt::Show for Sidebar<'a> {\n fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n+        if ignore_private_module(item) { continue }\n+\n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n             None => continue,\n@@ -2023,3 +2058,13 @@ fn item_primitive(w: &mut fmt::Formatter,\n     try!(document(w, it));\n     render_methods(w, it)\n }\n+\n+fn ignore_private_module(it: &clean::Item) -> bool {\n+    match it.inner {\n+        clean::ModuleItem(ref m) => {\n+            (m.items.len() == 0 && it.doc_value().is_none()) ||\n+               it.visibility != Some(ast::Public)\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "7176ad1a6c151020c975da1ca637187c1f68ad17", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec6df5f458c599e16641ec3d1265622743054ff/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=7ec6df5f458c599e16641ec3d1265622743054ff", "patch": "@@ -70,7 +70,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                         for_: clean::ResolvedPath{ did, .. },\n                         ref trait_, ..\n                     }) => {\n-                        // Impls for stripped don't need to exist\n+                        // Impls for stripped types don't need to exist\n                         if self.stripped.contains(&did.node) {\n                             return None;\n                         }"}]}