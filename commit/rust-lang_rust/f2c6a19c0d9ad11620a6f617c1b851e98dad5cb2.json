{"sha": "f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzZhMTljMGQ5YWQxMTYyMGE2ZjYxN2MxYjg1MWU5OGRhZDVjYjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-30T08:40:44Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-30T13:05:17Z"}, "message": "check_fn: simplify", "tree": {"sha": "4eb6b3260a724fdf01b63351b76aed2d9aa52d83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb6b3260a724fdf01b63351b76aed2d9aa52d83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2", "html_url": "https://github.com/rust-lang/rust/commit/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7e2f3aee5508538c5de14211ab5b31362e1164a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e2f3aee5508538c5de14211ab5b31362e1164a", "html_url": "https://github.com/rust-lang/rust/commit/d7e2f3aee5508538c5de14211ab5b31362e1164a"}], "stats": {"total": 74, "additions": 38, "deletions": 36}, "files": [{"sha": "41313ffbab6cf528da3492e82f70c775083a8f6c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f2c6a19c0d9ad11620a6f617c1b851e98dad5cb2", "patch": "@@ -1242,13 +1242,17 @@ fn check_fn<'a, 'tcx>(\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n+    let tcx = fcx.tcx;\n+    let sess = tcx.sess;\n+    let hir = tcx.hir();\n+\n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n-    fn_sig = fcx.tcx.mk_fn_sig(\n+    fn_sig = tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n         fn_sig.c_variadic,\n@@ -1258,7 +1262,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    fn_maybe_err(fcx.tcx, span, fn_sig.abi);\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n \n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n@@ -1267,23 +1271,23 @@ fn check_fn<'a, 'tcx>(\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n-    let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did = fcx.tcx.require_lang_item(\n+        let va_list_did = tcx.require_lang_item(\n             lang_items::VaListTypeLangItem,\n             Some(body.params.last().unwrap().span),\n         );\n-        let region = fcx.tcx.mk_region(ty::ReScope(region::Scope {\n+        let region = tcx.mk_region(ty::ReScope(region::Scope {\n             id: body.value.hir_id.local_id,\n             data: region::ScopeData::CallSite,\n         }));\n \n-        Some(fcx.tcx.type_of(va_list_did).subst(fcx.tcx, &[region.into()]))\n+        Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n     } else {\n         None\n     };\n@@ -1297,7 +1301,7 @@ fn check_fn<'a, 'tcx>(\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n             fcx.require_type_is_sized(param_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n@@ -1358,11 +1362,11 @@ fn check_fn<'a, 'tcx>(\n     fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n \n     // Check that the main return type implements the termination trait.\n-    if let Some(term_id) = fcx.tcx.lang_items().termination() {\n-        if let Some((def_id, EntryFnType::Main)) = fcx.tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+    if let Some(term_id) = tcx.lang_items().termination() {\n+        if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n+            let main_id = hir.as_local_hir_id(def_id).unwrap();\n             if main_id == fn_id {\n-                let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n                 let cause = traits::ObligationCause::new(\n@@ -1381,15 +1385,15 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n+        if panic_impl_did == hir.local_def_id(fn_id) {\n+            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].kind {\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n@@ -1404,52 +1408,50 @@ fn check_fn<'a, 'tcx>(\n                     };\n \n                     if !arg_is_panic_info {\n-                        fcx.tcx\n-                            .sess\n-                            .span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(span, \"should have no type parameters\");\n+                                sess.span_err(span, \"should have no type parameters\");\n                             }\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+                sess.err(\"language item required, but not found: `panic_info`\");\n             }\n         }\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id) {\n+            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].kind {\n                         ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n                         _ => false,\n                     };\n \n                     if !arg_is_alloc_layout {\n-                        fcx.tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(\n+                                sess.span_err(\n                                     span,\n                                     \"`#[alloc_error_handler]` function should have no type \\\n                                      parameters\",\n@@ -1458,11 +1460,11 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+                sess.err(\"language item required, but not found: `alloc_layout`\");\n             }\n         }\n     }"}]}