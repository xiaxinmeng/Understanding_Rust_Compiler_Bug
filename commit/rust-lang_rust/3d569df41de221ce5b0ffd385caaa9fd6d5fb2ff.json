{"sha": "3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNTY5ZGY0MWRlMjIxY2U1YjBmZmQzODVjYWFhOWZkNmQ1ZmIyZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-18T21:46:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-18T21:46:55Z"}, "message": "auto merge of #10555 : TeXitoi/rust/pidigits-resurected, r=alexcrichton\n\nChanges:\r\n* default value when no args\r\n* license\r\n* removed libc printing\r\n* use extra::bigint instead of handmade gmp binding\r\n\r\nThe drawback is that it's 2 order of magnitude slower, the good news is that there is a good bench for extra::bigint.", "tree": {"sha": "434710c89c8d6aa1ce1d2b6ce8a26b7e51b668ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/434710c89c8d6aa1ce1d2b6ce8a26b7e51b668ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff", "html_url": "https://github.com/rust-lang/rust/commit/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c8b702cf7f7b67e3076091cdf12750551f3830c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8b702cf7f7b67e3076091cdf12750551f3830c", "html_url": "https://github.com/rust-lang/rust/commit/6c8b702cf7f7b67e3076091cdf12750551f3830c"}, {"sha": "ec27c09bdfa9fbdbf643b3f2f29146c1747e7297", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec27c09bdfa9fbdbf643b3f2f29146c1747e7297", "html_url": "https://github.com/rust-lang/rust/commit/ec27c09bdfa9fbdbf643b3f2f29146c1747e7297"}], "stats": {"total": 203, "additions": 66, "deletions": 137}, "files": [{"sha": "041d86c3d955a9ec1bf653514baf5d67c965d169", "filename": "src/test/bench/shootout-pidigits.rs", "status": "modified", "additions": 66, "deletions": 137, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=3d569df41de221ce5b0ffd385caaa9fd6d5fb2ff", "patch": "@@ -1,167 +1,96 @@\n-// xfail-test\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n \n-use std::cast::transmute;\n use std::from_str::FromStr;\n-use std::libc::{STDOUT_FILENO, c_char, c_int, c_uint, c_void, fdopen, fputc};\n-use std::libc::{fputs};\n-use std::ptr::null;\n-\n-struct mpz_t {\n-    _mp_alloc: c_int,\n-    _mp_size: c_int,\n-    _mp_limb_t: *c_void,\n-}\n-\n-impl mpz_t {\n-    fn new() -> mpz_t {\n-        mpz_t {\n-            _mp_alloc: 0,\n-            _mp_size: 0,\n-            _mp_limb_t: null(),\n-        }\n-    }\n-}\n-\n-#[link_args=\"-lgmp\"]\n-extern {\n-    #[link_name=\"__gmpz_add\"]\n-    fn mpz_add(x: *mpz_t, y: *mpz_t, z: *mpz_t);\n-    #[link_name=\"__gmpz_cmp\"]\n-    fn mpz_cmp(x: *mpz_t, y: *mpz_t) -> c_int;\n-    #[link_name=\"__gmpz_fdiv_qr\"]\n-    fn mpz_fdiv_qr(a: *mpz_t, b: *mpz_t, c: *mpz_t, d: *mpz_t);\n-    #[link_name=\"__gmpz_get_ui\"]\n-    fn mpz_get_ui(x: *mpz_t) -> c_uint;\n-    #[link_name=\"__gmpz_init\"]\n-    fn mpz_init(x: *mpz_t);\n-    #[link_name=\"__gmpz_init_set_ui\"]\n-    fn mpz_init_set_ui(x: *mpz_t, y: c_uint);\n-    #[link_name=\"__gmpz_mul_2exp\"]\n-    fn mpz_mul_2exp(x: *mpz_t, y: *mpz_t, z: c_uint);\n-    #[link_name=\"__gmpz_mul_ui\"]\n-    fn mpz_mul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n-    #[link_name=\"__gmpz_submul_ui\"]\n-    fn mpz_submul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n-}\n+use std::num::One;\n+use std::num::Zero;\n+use std::num::FromPrimitive;\n+use extra::bigint::BigInt;\n \n struct Context {\n-    numer: mpz_t,\n-    accum: mpz_t,\n-    denom: mpz_t,\n-    tmp1: mpz_t,\n-    tmp2: mpz_t,\n+    numer: BigInt,\n+    accum: BigInt,\n+    denom: BigInt,\n }\n \n impl Context {\n     fn new() -> Context {\n-        unsafe {\n-            let mut result = Context {\n-                numer: mpz_t::new(),\n-                accum: mpz_t::new(),\n-                denom: mpz_t::new(),\n-                tmp1: mpz_t::new(),\n-                tmp2: mpz_t::new(),\n-            };\n-            mpz_init(&result.tmp1);\n-            mpz_init(&result.tmp2);\n-            mpz_init_set_ui(&result.numer, 1);\n-            mpz_init_set_ui(&result.accum, 0);\n-            mpz_init_set_ui(&result.denom, 1);\n-            result\n+        Context {\n+            numer: One::one(),\n+            accum: Zero::zero(),\n+            denom: One::one(),\n         }\n     }\n \n-    fn extract_digit(&mut self) -> i32 {\n-        unsafe {\n-            if mpz_cmp(&self.numer, &self.accum) > 0 {\n-                return -1;\n-            }\n-\n-            // Compute (numer * 3 + accum) / denom\n-            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n-            mpz_add(&self.tmp1, &self.tmp1, &self.numer);\n-            mpz_add(&self.tmp1, &self.tmp1, &self.accum);\n-            mpz_fdiv_qr(&self.tmp1, &self.tmp2, &self.tmp1, &self.denom);\n-\n-            // Now, if (numer * 4 + accum) % denom...\n-            mpz_add(&self.tmp2, &self.tmp2, &self.numer);\n-\n-            // ... is normalized, then the two divisions have the same result.\n-            if mpz_cmp(&self.tmp2, &self.denom) >= 0 {\n-                return -1;\n-            }\n-\n-            mpz_get_ui(&self.tmp1) as i32\n-        }\n+    fn from_int(i: int) -> BigInt {\n+        FromPrimitive::from_int(i).unwrap()\n     }\n \n-    fn next_term(&mut self, k: u32) {\n-        unsafe {\n-            let y2 = k*2 + 1;\n+    fn extract_digit(&self) -> int {\n+        if self.numer > self.accum {return -1;}\n+        let (q, r) =\n+            (self.numer * Context::from_int(3) + self.accum)\n+            .div_rem(&self.denom);\n+        if r + self.numer >= self.denom {return -1;}\n+        q.to_int().unwrap()\n+    }\n \n-            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n-            mpz_add(&self.accum, &self.accum, &self.tmp1);\n-            mpz_mul_ui(&self.accum, &self.accum, y2);\n-            mpz_mul_ui(&self.numer, &self.numer, k);\n-            mpz_mul_ui(&self.denom, &self.denom, y2);\n-        }\n+    fn next_term(&mut self, k: int) {\n+        let y2 = Context::from_int(k * 2 + 1);\n+        self.accum = (self.accum + (self.numer << 1)) * y2;\n+        self.numer = self.numer * Context::from_int(k);\n+        self.denom = self.denom * y2;\n     }\n \n-    fn eliminate_digit(&mut self, d: u32) {\n-        unsafe {\n-            mpz_submul_ui(&self.accum, &self.denom, d);\n-            mpz_mul_ui(&self.accum, &self.accum, 10);\n-            mpz_mul_ui(&self.numer, &self.numer, 10);\n-        }\n+    fn eliminate_digit(&mut self, d: int) {\n+        let d = Context::from_int(d);\n+        let ten = Context::from_int(10);\n+        self.accum = (self.accum - self.denom * d) * ten;\n+        self.numer = self.numer * ten;\n     }\n }\n \n-fn pidigits(n: u32) {\n-    unsafe {\n-        let mode = \"w\";\n-        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+fn pidigits(n: int) {\n+    let mut k = 0;\n+    let mut context = Context::new();\n \n-        let mut d: i32;\n-        let mut i: u32 = 0, k: u32 = 0, m: u32;\n-\n-        let mut context = Context::new();\n+    for i in range(1, n + 1) {\n+        let mut d;\n         loop {\n-            loop {\n-                k += 1;\n-                context.next_term(k);\n-                d = context.extract_digit();\n-                if d != -1 {\n-                    break;\n-                }\n-            }\n+            k += 1;\n+            context.next_term(k);\n+            d = context.extract_digit();\n+            if d != -1 {break;}\n+        }\n \n-            fputc((d as c_int) + ('0' as c_int), stdout);\n+        print!(\"{}\", d);\n+        if i % 10 == 0 {print!(\"\\t:{}\\n\", i);}\n \n-            i += 1;\n-            m = i % 10;\n-            if m == 0 {\n-                let res = fmt!(\"\\t:%d\\n\", i as int);\n-                fputs(transmute(&res[0]), stdout);\n-            }\n-            if i >= n {\n-                break;\n-            }\n-            context.eliminate_digit(d as u32);\n-        }\n+        context.eliminate_digit(d);\n+    }\n \n-        if m != 0 {\n-            m = 10 - m;\n-            while m != 0 {\n-                m -= 1;\n-                fputc(' ' as c_int, stdout);\n-            }\n-            let res = fmt!(\"\\t:%d\\n\", i as int);\n-            fputs(transmute(&res[0]), stdout);\n-        }\n+    let m = n % 10;\n+    if m != 0 {\n+        for _ in range(m, 10) {print(\" \");}\n+        print!(\"\\t:{}\\n\", n);\n     }\n }\n \n fn main() {\n-    let n: u32 = FromStr::from_str(os::args()[1]).get();\n+    let args = std::os::args();\n+    let n = if args.len() < 2 {\n+        512\n+    } else {\n+        FromStr::from_str(args[1]).unwrap()\n+    };\n     pidigits(n);\n }"}]}