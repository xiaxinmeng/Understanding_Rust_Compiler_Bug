{"sha": "7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "node_id": "C_kwDOAAsO6NoAKDdhMmNkZjIwZTQyYzViMmE0ZDBmMjU5ZWFiODk2OGNkYTdhZTU1YzI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-27T19:05:09Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-06T18:44:22Z"}, "message": "Move alias-relate to its own module", "tree": {"sha": "078db472efde97e107432aff0de413d014144ffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/078db472efde97e107432aff0de413d014144ffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "html_url": "https://github.com/rust-lang/rust/commit/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3572d7451d1062e8bccf310af6bbf6255091d296", "url": "https://api.github.com/repos/rust-lang/rust/commits/3572d7451d1062e8bccf310af6bbf6255091d296", "html_url": "https://github.com/rust-lang/rust/commit/3572d7451d1062e8bccf310af6bbf6255091d296"}], "stats": {"total": 283, "additions": 147, "deletions": 136}, "files": [{"sha": "59ab3bc3a727bb1e7bb91756882bf997f747550e", "filename": "compiler/rustc_trait_selection/src/solve/alias_relate.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Falias_relate.rs?ref=7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "patch": "@@ -0,0 +1,146 @@\n+use super::{EvalCtxt, SolverMode};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::ty;\n+\n+/// We may need to invert the alias relation direction if dealing an alias on the RHS.\n+#[derive(Debug)]\n+enum Invert {\n+    No,\n+    Yes,\n+}\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn compute_alias_relate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let Goal { param_env, predicate: (lhs, rhs, direction) } = goal;\n+        if lhs.is_infer() || rhs.is_infer() {\n+            bug!(\n+                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n+            );\n+        }\n+\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n+            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n+\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_lhs,\n+                rhs,\n+                direction,\n+                Invert::No,\n+            ),\n+\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => self.assemble_normalizes_to_candidate(\n+                param_env,\n+                alias_rhs,\n+                lhs,\n+                direction,\n+                Invert::Yes,\n+            ),\n+\n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"both sides are aliases\");\n+\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_lhs,\n+                    rhs,\n+                    direction,\n+                    Invert::No,\n+                ));\n+                // RHS normalizes-to RHS\n+                candidates.extend(self.assemble_normalizes_to_candidate(\n+                    param_env,\n+                    alias_rhs,\n+                    lhs,\n+                    direction,\n+                    Invert::Yes,\n+                ));\n+                // Relate via substs\n+                let subst_relate_response = self\n+                    .assemble_subst_relate_candidate(param_env, alias_lhs, alias_rhs, direction);\n+                candidates.extend(subst_relate_response);\n+                debug!(?candidates);\n+\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    // When relating two aliases and we have ambiguity, we prefer\n+                    // relating the generic arguments of the aliases over normalizing\n+                    // them. This is necessary for inference during typeck.\n+                    //\n+                    // As this is incomplete, we must not do so during coherence.\n+                    match (self.solver_mode(), subst_relate_response) {\n+                        (SolverMode::Normal, Ok(response)) => Ok(response),\n+                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n+                            self.flounder(&candidates)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn assemble_normalizes_to_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias: ty::AliasTy<'tcx>,\n+        other: ty::Term<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+        invert: Invert,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            let other = match direction {\n+                // This is purely an optimization.\n+                ty::AliasRelationDirection::Equate => other,\n+\n+                ty::AliasRelationDirection::Subtype => {\n+                    let fresh = ecx.next_term_infer_of_kind(other);\n+                    let (sub, sup) = match invert {\n+                        Invert::No => (fresh, other),\n+                        Invert::Yes => (other, fresh),\n+                    };\n+                    ecx.sub(param_env, sub, sup)?;\n+                    fresh\n+                }\n+            };\n+            ecx.add_goal(Goal::new(\n+                ecx.tcx(),\n+                param_env,\n+                ty::Binder::dummy(ty::ProjectionPredicate { projection_ty: alias, term: other }),\n+            ));\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    fn assemble_subst_relate_candidate(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        alias_lhs: ty::AliasTy<'tcx>,\n+        alias_rhs: ty::AliasTy<'tcx>,\n+        direction: ty::AliasRelationDirection,\n+    ) -> QueryResult<'tcx> {\n+        self.probe(|ecx| {\n+            match direction {\n+                ty::AliasRelationDirection::Equate => {\n+                    ecx.eq(param_env, alias_lhs, alias_rhs)?;\n+                }\n+                ty::AliasRelationDirection::Subtype => {\n+                    ecx.sub(param_env, alias_lhs, alias_rhs)?;\n+                }\n+            }\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+}"}, {"sha": "f4c29c837b8841a5ec71ef21079dfc350f94d3a1", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 136, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=7a2cdf20e42c5b2a4d0f259eab8968cda7ae55c2", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n+mod alias_relate;\n mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n@@ -154,142 +155,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_alias_relate_goal(\n-        &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n-    ) -> QueryResult<'tcx> {\n-        let tcx = self.tcx();\n-        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n-        #[derive(Debug)]\n-        enum Invert {\n-            No,\n-            Yes,\n-        }\n-        let evaluate_normalizes_to =\n-            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n-                let span = tracing::span!(\n-                    tracing::Level::DEBUG,\n-                    \"compute_alias_relate_goal(evaluate_normalizes_to)\",\n-                    ?alias,\n-                    ?other,\n-                    ?direction,\n-                    ?invert\n-                );\n-                let _enter = span.enter();\n-                let result = ecx.probe(|ecx| {\n-                    let other = match direction {\n-                        // This is purely an optimization.\n-                        ty::AliasRelationDirection::Equate => other,\n-\n-                        ty::AliasRelationDirection::Subtype => {\n-                            let fresh = ecx.next_term_infer_of_kind(other);\n-                            let (sub, sup) = match invert {\n-                                Invert::No => (fresh, other),\n-                                Invert::Yes => (other, fresh),\n-                            };\n-                            ecx.sub(goal.param_env, sub, sup)?;\n-                            fresh\n-                        }\n-                    };\n-                    ecx.add_goal(goal.with(\n-                        tcx,\n-                        ty::Binder::dummy(ty::ProjectionPredicate {\n-                            projection_ty: alias,\n-                            term: other,\n-                        }),\n-                    ));\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                debug!(?result);\n-                result\n-            };\n-\n-        let (lhs, rhs, direction) = goal.predicate;\n-\n-        if lhs.is_infer() || rhs.is_infer() {\n-            bug!(\n-                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n-            );\n-        }\n-\n-        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n-            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n-\n-            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n-            (Some(alias_lhs), None) => {\n-                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n-            }\n-\n-            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n-            (None, Some(alias_rhs)) => {\n-                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n-            }\n-\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"both sides are aliases\");\n-\n-                let mut candidates = Vec::new();\n-                // LHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_lhs,\n-                    rhs,\n-                    direction,\n-                    Invert::No,\n-                ));\n-                // RHS normalizes-to RHS\n-                candidates.extend(evaluate_normalizes_to(\n-                    self,\n-                    alias_rhs,\n-                    lhs,\n-                    direction,\n-                    Invert::Yes,\n-                ));\n-                // Relate via substs\n-                let subst_relate_response = self.probe(|ecx| {\n-                    let span = tracing::span!(\n-                        tracing::Level::DEBUG,\n-                        \"compute_alias_relate_goal(relate_via_substs)\",\n-                        ?alias_lhs,\n-                        ?alias_rhs,\n-                        ?direction\n-                    );\n-                    let _enter = span.enter();\n-\n-                    match direction {\n-                        ty::AliasRelationDirection::Equate => {\n-                            ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                        ty::AliasRelationDirection::Subtype => {\n-                            ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n-                        }\n-                    }\n-\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                });\n-                candidates.extend(subst_relate_response);\n-                debug!(?candidates);\n-\n-                if let Some(merged) = self.try_merge_responses(&candidates) {\n-                    Ok(merged)\n-                } else {\n-                    // When relating two aliases and we have ambiguity, we prefer\n-                    // relating the generic arguments of the aliases over normalizing\n-                    // them. This is necessary for inference during typeck.\n-                    //\n-                    // As this is incomplete, we must not do so during coherence.\n-                    match (self.solver_mode(), subst_relate_response) {\n-                        (SolverMode::Normal, Ok(response)) => Ok(response),\n-                        (SolverMode::Normal, Err(NoSolution)) | (SolverMode::Coherence, _) => {\n-                            self.flounder(&candidates)\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     #[instrument(level = \"debug\", skip(self), ret)]\n     fn compute_const_arg_has_type_goal(\n         &mut self,"}]}