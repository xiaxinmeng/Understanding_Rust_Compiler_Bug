{"sha": "b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGEzNWE1YWE3NjAzYzMwMTBlMWFhOWU1ZmY2ZGU1NjYwMDU4ZmI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-23T09:51:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-23T17:42:08Z"}, "message": "Remove field `expr` of `ast::Block`", "tree": {"sha": "9707bfa5eb1bab73f138bca605a79f112b8a9d9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9707bfa5eb1bab73f138bca605a79f112b8a9d9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "html_url": "https://github.com/rust-lang/rust/commit/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "html_url": "https://github.com/rust-lang/rust/commit/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8"}], "stats": {"total": 208, "additions": 88, "deletions": 120}, "files": [{"sha": "2690edc46448988de4194c7cc7549a1fb18258dd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -587,10 +587,23 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n+        let mut stmts = Vec::new();\n+        let mut expr = None;\n+\n+        if let Some((last, rest)) = b.stmts.split_last() {\n+            stmts = rest.iter().map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n+            let last = self.lower_stmt(last);\n+            if let hir::StmtExpr(e, _) = last.node {\n+                expr = Some(e);\n+            } else {\n+                stmts.push(last);\n+            }\n+        }\n+\n         P(hir::Block {\n             id: b.id,\n-            stmts: b.stmts.iter().map(|s| self.lower_stmt(s)).collect(),\n-            expr: b.expr.as_ref().map(|ref x| self.lower_expr(x)),\n+            stmts: stmts.into(),\n+            expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n         })"}, {"sha": "4c0082ed5b85cb56448d7261f6d8196bf6973de0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -657,8 +657,10 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                expr: e,\n-                stmts: vec![],\n+                stmts: e.map(|e| codemap::Spanned {\n+                    span: e.span,\n+                    node: ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n+                }).into_iter().collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,"}, {"sha": "e138119149c679fef66635cf9aad3a98f081989a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -528,9 +528,6 @@ impl PartialEq for MetaItemKind {\n pub struct Block {\n     /// Statements in a block\n     pub stmts: Vec<Stmt>,\n-    /// An expression at the end of the block\n-    /// without a semicolon, if any\n-    pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n@@ -803,7 +800,7 @@ pub enum StmtKind {\n     /// Could be an item or a local (let) binding:\n     Decl(P<Decl>, NodeId),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n+    /// Expr without trailing semi-colon\n     Expr(P<Expr>, NodeId),\n \n     /// Expr with trailing semi-colon (may have any type):"}, {"sha": "1a01fa2e9e0111e58873ac0d4135258a2fd81ef0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -98,12 +98,9 @@ pub trait AstBuilder {\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n-    fn block_all(&self, span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block_all(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n \n     // expressions\n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n@@ -508,7 +505,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID))\n+        respan(expr.span, ast::StmtKind::Expr(expr, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n@@ -556,9 +553,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, stmts, expr)\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+        self.block_all(span, stmts)\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n@@ -567,19 +563,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Some(expr))\n-    }\n-    fn block_all(&self,\n-                 span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n-            P(ast::Block {\n-               stmts: stmts,\n-               expr: expr,\n-               id: ast::DUMMY_NODE_ID,\n-               rules: BlockCheckMode::Default,\n-               span: span,\n-            })\n+        self.block_all(expr.span, vec![Spanned {\n+            span: expr.span,\n+            node: ast::StmtKind::Expr(expr, ast::DUMMY_NODE_ID),\n+        }])\n+    }\n+    fn block_all(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+        P(ast::Block {\n+           stmts: stmts,\n+           id: ast::DUMMY_NODE_ID,\n+           rules: BlockCheckMode::Default,\n+           span: span,\n+        })\n     }\n \n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n@@ -948,14 +943,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block(span, stmts, None))\n+        self.lambda(span, ids, self.block(span, stmts))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block(span, stmts, None))\n+        self.lambda0(span, self.block(span, stmts))\n     }\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block(span, stmts, None), ident)\n+        self.lambda1(span, self.block(span, stmts), ident)\n     }\n \n     fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {"}, {"sha": "263c10cee5bf7b0b2f5c7d07e6eb4bb7656b55e1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -636,23 +636,14 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| {\n+    b.map(|Block {id, stmts, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform pending renames and expand macros in the statement\n             fld.fold_stmt(x).into_iter()\n         }).collect();\n-        let new_expr = expr.map(|x| {\n-            let expr = {\n-                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-                let mut rename_fld = IdentRenamer{renames:pending_renames};\n-                rename_fld.fold_expr(x)\n-            };\n-            fld.fold_expr(expr)\n-        });\n         Block {\n             id: fld.new_id(id),\n             stmts: new_stmts,\n-            expr: new_expr,\n             rules: rules,\n             span: span\n         }"}, {"sha": "b1290451cbfc9156b2a4f218275b407a7047aac4", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -512,10 +512,8 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], true));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block_all(sp, vector));\n \n     let expanded = expand_wrapper(cx, sp, cx_expr, block, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n@@ -765,8 +763,9 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n             let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n             let mut tts_stmts = vec![stmt_let_tt];\n             tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher));\n-            let e_tts = cx.expr_block(cx.block(sp, tts_stmts,\n-                                                   Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+            tts_stmts.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+            let e_tts = cx.expr_block(cx.block(sp, tts_stmts));\n+\n             let e_separator = match seq.separator {\n                 Some(ref sep) => cx.expr_some(sp, expr_mk_token(cx, sp, sep)),\n                 None => cx.expr_none(sp),\n@@ -884,10 +883,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[TokenTree])\n \n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], false));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block_all(sp, vector));\n \n     (cx_expr, block)\n }\n@@ -901,13 +898,14 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    let stmts = imports.iter().map(|path| {\n+    let mut stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n         cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n-    }).chain(Some(stmt_let_ext_cx)).collect();\n+    }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n+    stmts.push(cx.stmt_expr(expr));\n \n-    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n+    cx.expr_block(cx.block_all(sp, stmts))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "8647937027b40b64844b1675cea6c042df0c3a46", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -845,10 +845,9 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, rules, span}| Block {\n         id: folder.new_id(id),\n         stmts: stmts.move_flat_map(|s| folder.fold_stmt(s).into_iter()),\n-        expr: expr.and_then(|x| folder.fold_opt_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n     })"}, {"sha": "dea6589fe7caeb348ab2813fb2ab536519ee4c79", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -3217,9 +3217,11 @@ impl<'a> Parser<'a> {\n                 let body_expr = self.parse_expr()?;\n                 P(ast::Block {\n                     id: ast::DUMMY_NODE_ID,\n-                    stmts: vec![],\n                     span: body_expr.span,\n-                    expr: Some(body_expr),\n+                    stmts: vec![Spanned {\n+                        span: body_expr.span,\n+                        node: StmtKind::Expr(body_expr, ast::DUMMY_NODE_ID),\n+                    }],\n                     rules: BlockCheckMode::Default,\n                 })\n             }\n@@ -4082,7 +4084,6 @@ impl<'a> Parser<'a> {\n     /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n-        let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n@@ -4095,11 +4096,10 @@ impl<'a> Parser<'a> {\n             };\n             match node {\n                 StmtKind::Expr(e, _) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts, &mut expr)?;\n+                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n                 }\n                 StmtKind::Mac(mac, MacStmtStyle::NoBraces, attrs) => {\n-                    // statement macro without braces; might be an\n-                    // expr depending on whether a semicolon follows\n+                    // statement macro without braces\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(Spanned {\n@@ -4115,11 +4115,7 @@ impl<'a> Parser<'a> {\n                             let lo = e.span.lo;\n                             let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n                             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                            self.handle_expression_like_statement(\n-                                e,\n-                                span,\n-                                &mut stmts,\n-                                &mut expr)?;\n+                            self.handle_expression_like_statement(e, span, &mut stmts)?;\n                         }\n                     }\n                 }\n@@ -4133,13 +4129,6 @@ impl<'a> Parser<'a> {\n                             });\n                             self.bump();\n                         }\n-                        token::CloseDelim(token::Brace) => {\n-                            // if a block ends in `m!(arg)` without\n-                            // a `;`, it must be an expr\n-                            expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node),\n-                                                         attrs));\n-                        }\n                         _ => {\n                             stmts.push(Spanned {\n                                 node: StmtKind::Mac(m, style, attrs),\n@@ -4165,7 +4154,6 @@ impl<'a> Parser<'a> {\n \n         Ok(P(ast::Block {\n             stmts: stmts,\n-            expr: expr,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: mk_sp(lo, self.last_span.hi),\n@@ -4175,8 +4163,7 @@ impl<'a> Parser<'a> {\n     fn handle_expression_like_statement(&mut self,\n                                         e: P<Expr>,\n                                         span: Span,\n-                                        stmts: &mut Vec<Stmt>,\n-                                        last_block_expr: &mut Option<P<Expr>>)\n+                                        stmts: &mut Vec<Stmt>)\n                                         -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n@@ -4202,7 +4189,6 @@ impl<'a> Parser<'a> {\n                     span: span_with_semi,\n                 });\n             }\n-            token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n                 stmts.push(Spanned {\n                     node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),"}, {"sha": "d38d5d9b6b660895b6c10b5d2b5d2b96a6de5460", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -1619,9 +1619,6 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        if parse::classify::stmt_ends_with_semi(&st.node) {\n-            try!(word(&mut self.s, \";\"));\n-        }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n@@ -1668,14 +1665,6 @@ impl<'a> State<'a> {\n         for st in &blk.stmts {\n             try!(self.print_stmt(st));\n         }\n-        match blk.expr {\n-            Some(ref expr) => {\n-                try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&expr, false));\n-                try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n-            }\n-            _ => ()\n-        }\n         try!(self.bclose_maybe_open(blk.span, indented, close_box));\n         self.ann.post(self, NodeBlock(blk))\n     }\n@@ -2084,24 +2073,23 @@ impl<'a> State<'a> {\n                     _ => false\n                 };\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&body));\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    let i_expr = body.expr.as_ref().unwrap();\n-                    match i_expr.node {\n-                        ast::ExprKind::Block(ref blk) => {\n+                match body.stmts.last().map(|stmt| &stmt.node) {\n+                    Some(&ast::StmtKind::Expr(ref i_expr, _)) if default_return &&\n+                                                                 body.stmts.len() == 1 => {\n+                        // we extract the block, so as not to create another set of boxes\n+                        if let ast::ExprKind::Block(ref blk) = i_expr.node {\n                             try!(self.print_block_unclosed_with_attrs(\n                                 &blk,\n                                 i_expr.attrs.as_attr_slice()));\n-                        }\n-                        _ => {\n+                        } else {\n                             // this is a bare expression\n                             try!(self.print_expr(&i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n+                    _ => try!(self.print_block_unclosed(&body)),\n                 }\n+\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close.\n@@ -2295,6 +2283,7 @@ impl<'a> State<'a> {\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_expr(&init));\n                 }\n+                try!(word(&mut self.s, \";\"));\n                 self.end()\n             }\n             ast::DeclKind::Item(ref item) => self.print_item(&item)"}, {"sha": "72beea0421b654f924b60b0bbeba7ceff7ec048d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -474,7 +474,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n-    let main_body = ecx.block_all(sp, vec![call_test_main], None);\n+    let main_body = ecx.block_all(sp, vec![call_test_main]);\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,"}, {"sha": "cf91f5ece725b71f9cd15d8a8d56117682d6f8e6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -608,7 +608,6 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n     walk_list!(visitor, visit_stmt, &block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {"}, {"sha": "1e3e853df010e16d4a46799c0915457b58ba3f16", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -145,12 +145,10 @@ fn cs_clone(\n \n     match mode {\n         Mode::Shallow => {\n-            cx.expr_block(cx.block(trait_span,\n-                                   all_fields.iter()\n-                                             .map(subcall)\n-                                             .map(|e| cx.stmt_expr(e))\n-                                             .collect(),\n-                                   Some(cx.expr_deref(trait_span, cx.expr_self(trait_span)))))\n+            let mut stmts: Vec<_> =\n+                all_fields.iter().map(subcall).map(|e| cx.stmt_expr(e)).collect();\n+            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+            cx.expr_block(cx.block(trait_span, stmts))\n         }\n         Mode::Deep => {\n             match *vdata {"}, {"sha": "b0e4491ffe2b01a498ea0d16c268ca08cfac5c4b", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 // create `a.<method>(); b.<method>(); c.<method>(); ...`\n                 // (where method is `assert_receiver_is_total_eq`)\n                 let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-                let block = cx.block(span, stmts, None);\n+                let block = cx.block(span, stmts);\n                 cx.expr_block(block)\n             },\n             Box::new(|cx, sp, _, _| {"}, {"sha": "0c6548be60b710743951307c8fa471ec26805f70", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -78,7 +78,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let stmts = match *substr.fields {\n+    let mut stmts = match *substr.fields {\n         Struct(_, ref fields) | EnumMatching(_, _, ref fields) => {\n             let mut stmts = vec![];\n             if !is_struct {\n@@ -136,7 +136,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                                    token::str_to_ident(\"finish\"),\n                                    vec![]);\n \n-    let block = cx.block(span, stmts, Some(expr));\n+    stmts.push(cx.stmt_expr(expr));\n+    let block = cx.block(span, stmts);\n     cx.expr_block(block)\n }\n "}, {"sha": "76b83c8a0f1f0f2cf2985a5fccaf27128ec8531f", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -285,7 +285,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 blk\n             ));\n-            cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))\n+            cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\")"}, {"sha": "dd27c1ec202a67ece9382134734c68390d002dee", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -1332,8 +1332,8 @@ impl<'a> MethodDef<'a> {\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n-            cx.expr_block(\n-                cx.block_all(sp, index_let_stmts, Some(arm_expr)))\n+            index_let_stmts.push(cx.stmt_expr(arm_expr));\n+            cx.expr_block(cx.block_all(sp, index_let_stmts))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler"}, {"sha": "1c7b36313c554126b8030c5723d0bf2f43e78bd3", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -99,5 +99,5 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         stmts.push(call_hash(span, self_.clone()));\n     }\n \n-    cx.expr_block(cx.block(trait_span, stmts, None))\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "41f93cb4744b6df6620f64da402933033c8a4904", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -297,8 +297,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {\n-        stmts: vec![],\n-        expr: Some(call),\n+        stmts: vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span: span }))"}, {"sha": "8cf956256949327f3d8f034ffdd291196bca94bc", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7da35a5aa7603c3010e1aa9e5ff6de5660058fb/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b7da35a5aa7603c3010e1aa9e5ff6de5660058fb", "patch": "@@ -444,9 +444,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         let decl = respan(sp, ast::DeclKind::Item(item));\n \n         // Wrap the declaration in a block so that it forms a single expression.\n-        ecx.expr_block(ecx.block(sp,\n-            vec![respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))],\n-            Some(ecx.expr_ident(sp, name))))\n+        ecx.expr_block(ecx.block(sp, vec![\n+            respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)),\n+            ecx.stmt_expr(ecx.expr_ident(sp, name)),\n+        ]))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded"}]}