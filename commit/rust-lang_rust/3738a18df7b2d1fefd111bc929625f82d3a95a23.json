{"sha": "3738a18df7b2d1fefd111bc929625f82d3a95a23", "node_id": "C_kwDOAAsO6NoAKDM3MzhhMThkZjdiMmQxZmVmZDExMWJjOTI5NjI1ZjgyZDNhOTVhMjM", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-30T20:45:46Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-30T20:45:46Z"}, "message": "Migrate `builtin_macros::asm` diagnostics to translatable diagnostics", "tree": {"sha": "8bd9d72a384d8981f48a613bea00663a2b461505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd9d72a384d8981f48a613bea00663a2b461505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3738a18df7b2d1fefd111bc929625f82d3a95a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3738a18df7b2d1fefd111bc929625f82d3a95a23", "html_url": "https://github.com/rust-lang/rust/commit/3738a18df7b2d1fefd111bc929625f82d3a95a23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3738a18df7b2d1fefd111bc929625f82d3a95a23/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "831c9298c8e6542e3ab395216e98aec21f60b470", "url": "https://api.github.com/repos/rust-lang/rust/commits/831c9298c8e6542e3ab395216e98aec21f60b470", "html_url": "https://github.com/rust-lang/rust/commit/831c9298c8e6542e3ab395216e98aec21f60b470"}], "stats": {"total": 251, "additions": 179, "deletions": 72}, "files": [{"sha": "0d7cf7cdb267c6bb6ff52704c2b93de8044517a0", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=3738a18df7b2d1fefd111bc929625f82d3a95a23", "patch": "@@ -169,5 +169,40 @@ builtin_macros_asm_pure_no_output = asm with the `pure` option must have at leas\n \n builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n \n+builtin_macros_asm_requires_template = requires at least a template string argument\n+\n+builtin_macros_asm_expected_comma = expected token: `,`\n+    .label = expected `,`\n+\n+builtin_macros_asm_underscore_input = _ cannot be used for input operands\n+\n+builtin_macros_asm_sym_no_path = expected a path for argument to `sym`\n+\n+builtin_macros_asm_expected_other = expected operand, {$is_global_asm ->\n+    [true] options\n+    *[false] clobber_abi, options\n+    }, or additional template string\n+\n+builtin_macros_asm_duplicate_arg = duplicate argument named `{$name}`\n+    .label = previously here\n+    .arg = duplicate argument\n+\n+builtin_macros_asm_pos_after = positional arguments cannot follow named arguments or explicit register arguments\n+    .pos = positional argument\n+    .named = named argument\n+    .explicit = explicit register argument\n+\n+builtin_macros_asm_noreturn = asm outputs are not allowed with the `noreturn` option\n+\n+builtin_macros_global_asm_clobber_abi = `clobber_abi` cannot be used with `global_asm!`\n+\n+builtin_macros_asm_clobber_no_reg = asm with `clobber_abi` must specify explicit registers for outputs\n+builtin_macros_asm_clobber_abi = clobber_abi\n+builtin_macros_asm_clobber_outputs = generic outputs\n+\n+builtin_macros_asm_opt_already_provided = the `{$symbol}` option was already provided\n+    .label = this option was already provided\n+    .suggestion = remove this option\n+\n builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument"}, {"sha": "c066512b09ee366e8c7ede79e061371df5c1ff83", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 26, "deletions": 67, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=3738a18df7b2d1fefd111bc929625f82d3a95a23", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::PResult;\n use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n@@ -49,7 +49,7 @@ pub fn parse_asm_args<'a>(\n     let diag = &sess.span_diagnostic;\n \n     if p.token == token::Eof {\n-        return Err(diag.struct_span_err(sp, \"requires at least a template string argument\"));\n+        return Err(diag.create_err(errors::AsmRequiresTemplate { span: sp }));\n     }\n \n     let first_template = p.parse_expr()?;\n@@ -68,8 +68,7 @@ pub fn parse_asm_args<'a>(\n         if !p.eat(&token::Comma) {\n             if allow_templates {\n                 // After a template string, we always expect *only* a comma...\n-                let mut err = diag.struct_span_err(p.token.span, \"expected token: `,`\");\n-                err.span_label(p.token.span, \"expected `,`\");\n+                let mut err = diag.create_err(errors::AsmExpectedComma { span: p.token.span });\n                 p.maybe_annotate_with_ascription(&mut err, false);\n                 return Err(err);\n             } else {\n@@ -112,7 +111,7 @@ pub fn parse_asm_args<'a>(\n         let op = if !is_global_asm && p.eat_keyword(kw::In) {\n             let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.create_err(errors::AsmUnderscoreInput { span: p.token.span });\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n@@ -128,7 +127,7 @@ pub fn parse_asm_args<'a>(\n         } else if !is_global_asm && p.eat_keyword(sym::inout) {\n             let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.create_err(errors::AsmUnderscoreInput { span: p.token.span });\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n@@ -142,7 +141,7 @@ pub fn parse_asm_args<'a>(\n         } else if !is_global_asm && p.eat_keyword(sym::inlateout) {\n             let reg = parse_reg(p, &mut explicit_reg)?;\n             if p.eat_keyword(kw::Underscore) {\n-                let err = diag.struct_span_err(p.token.span, \"_ cannot be used for input operands\");\n+                let err = diag.create_err(errors::AsmUnderscoreInput { span: p.token.span });\n                 return Err(err);\n             }\n             let expr = p.parse_expr()?;\n@@ -160,7 +159,7 @@ pub fn parse_asm_args<'a>(\n             let expr = p.parse_expr()?;\n             let ast::ExprKind::Path(qself, path) = &expr.kind else {\n                 let err = diag\n-                    .struct_span_err(expr.span, \"expected a path for argument to `sym`\");\n+                    .create_err(errors::AsmSymNoPath { span: expr.span });\n                 return Err(err);\n             };\n             let sym = ast::InlineAsmSym {\n@@ -181,13 +180,10 @@ pub fn parse_asm_args<'a>(\n                     ) => {}\n                 ast::ExprKind::MacCall(..) => {}\n                 _ => {\n-                    let errstr = if is_global_asm {\n-                        \"expected operand, options, or additional template string\"\n-                    } else {\n-                        \"expected operand, clobber_abi, options, or additional template string\"\n-                    };\n-                    let mut err = diag.struct_span_err(template.span, errstr);\n-                    err.span_label(template.span, errstr);\n+                    let err = diag.create_err(errors::AsmExpectedOther {\n+                        span: template.span,\n+                        is_global_asm,\n+                    });\n                     return Err(err);\n                 }\n             }\n@@ -212,28 +208,16 @@ pub fn parse_asm_args<'a>(\n             args.reg_args.insert(slot);\n         } else if let Some(name) = name {\n             if let Some(&prev) = args.named_args.get(&name) {\n-                diag.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n-                    .span_label(args.operands[prev].1, \"previously here\")\n-                    .span_label(span, \"duplicate argument\")\n-                    .emit();\n+                diag.emit_err(errors::AsmDuplicateArg { span, name, prev: args.operands[prev].1 });\n                 continue;\n             }\n             args.named_args.insert(name, slot);\n         } else {\n             if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n-                let mut err = diag.struct_span_err(\n-                    span,\n-                    \"positional arguments cannot follow named arguments \\\n-                     or explicit register arguments\",\n-                );\n-                err.span_label(span, \"positional argument\");\n-                for pos in args.named_args.values() {\n-                    err.span_label(args.operands[*pos].1, \"named argument\");\n-                }\n-                for pos in &args.reg_args {\n-                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n-                }\n-                err.emit();\n+                let named = args.named_args.values().map(|p| args.operands[*p].1).collect();\n+                let explicit = args.reg_args.iter().map(|p| args.operands[*p].1).collect();\n+\n+                diag.emit_err(errors::AsmPositionalAfter { span, named, explicit });\n             }\n         }\n     }\n@@ -284,34 +268,25 @@ pub fn parse_asm_args<'a>(\n         diag.emit_err(errors::AsmPureNoOutput { spans: args.options_spans.clone() });\n     }\n     if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n-        let err = diag\n-            .struct_span_err(outputs_sp, \"asm outputs are not allowed with the `noreturn` option\");\n-\n+        let err = diag.create_err(errors::AsmNoReturn { outputs_sp });\n         // Bail out now since this is likely to confuse MIR\n         return Err(err);\n     }\n \n     if args.clobber_abis.len() > 0 {\n         if is_global_asm {\n-            let err = diag.struct_span_err(\n-                args.clobber_abis.iter().map(|(_, span)| *span).collect::<Vec<Span>>(),\n-                \"`clobber_abi` cannot be used with `global_asm!`\",\n-            );\n+            let err = diag.create_err(errors::GlobalAsmClobberAbi {\n+                spans: args.clobber_abis.iter().map(|(_, span)| *span).collect(),\n+            });\n \n             // Bail out now since this is likely to confuse later stages\n             return Err(err);\n         }\n         if !regclass_outputs.is_empty() {\n-            diag.struct_span_err(\n-                regclass_outputs.clone(),\n-                \"asm with `clobber_abi` must specify explicit registers for outputs\",\n-            )\n-            .span_labels(\n-                args.clobber_abis.iter().map(|(_, span)| *span).collect::<Vec<Span>>(),\n-                \"clobber_abi\",\n-            )\n-            .span_labels(regclass_outputs, \"generic outputs\")\n-            .emit();\n+            diag.emit_err(errors::AsmClobberNoReg {\n+                spans: regclass_outputs,\n+                clobbers: args.clobber_abis.iter().map(|(_, span)| *span).collect(),\n+            });\n         }\n     }\n \n@@ -323,25 +298,9 @@ pub fn parse_asm_args<'a>(\n /// This function must be called immediately after the option token is parsed.\n /// Otherwise, the suggestion will be incorrect.\n fn err_duplicate_option(p: &mut Parser<'_>, symbol: Symbol, span: Span) {\n-    let mut err = p\n-        .sess\n-        .span_diagnostic\n-        .struct_span_err(span, &format!(\"the `{}` option was already provided\", symbol));\n-    err.span_label(span, \"this option was already provided\");\n-\n     // Tool-only output\n-    let mut full_span = span;\n-    if p.token.kind == token::Comma {\n-        full_span = full_span.to(p.token.span);\n-    }\n-    err.tool_only_span_suggestion(\n-        full_span,\n-        \"remove this option\",\n-        \"\",\n-        Applicability::MachineApplicable,\n-    );\n-\n-    err.emit();\n+    let full_span = if p.token.kind == token::Comma { span.to(p.token.span) } else { span };\n+    p.sess.span_diagnostic.emit_err(errors::AsmOptAlreadyprovided { span, symbol, full_span });\n }\n \n /// Try to set the provided option in the provided `AsmArgs`."}, {"sha": "d0d78646009e1db2bf50111164ba07246bb3eb3e", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "modified", "additions": 118, "deletions": 5, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3738a18df7b2d1fefd111bc929625f82d3a95a23/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=3738a18df7b2d1fefd111bc929625f82d3a95a23", "patch": "@@ -1,5 +1,6 @@\n use rustc_errors::{\n-    AddToDiagnostic, EmissionGuarantee, IntoDiagnostic, MultiSpan, SingleLabelManySpans,\n+    AddToDiagnostic, DiagnosticBuilder, EmissionGuarantee, Handler, IntoDiagnostic, MultiSpan,\n+    SingleLabelManySpans,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n@@ -370,11 +371,12 @@ pub(crate) struct EnvNotDefined {\n // Hand-written implementation to support custom user messages\n impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for EnvNotDefined {\n     #[track_caller]\n-    fn into_diagnostic(\n-        self,\n-        handler: &'a rustc_errors::Handler,\n-    ) -> rustc_errors::DiagnosticBuilder<'a, G> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, G> {\n         let mut diag = if let Some(msg) = self.msg {\n+            #[expect(\n+                rustc::untranslatable_diagnostic,\n+                reason = \"cannot translate user-provided messages\"\n+            )]\n             handler.struct_diagnostic(msg.as_str())\n         } else {\n             handler.struct_diagnostic(crate::fluent_generated::builtin_macros_env_not_defined)\n@@ -606,6 +608,117 @@ pub(crate) struct AsmModifierInvalid {\n     pub(crate) span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_requires_template)]\n+pub(crate) struct AsmRequiresTemplate {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_expected_comma)]\n+pub(crate) struct AsmExpectedComma {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_underscore_input)]\n+pub(crate) struct AsmUnderscoreInput {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_sym_no_path)]\n+pub(crate) struct AsmSymNoPath {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_expected_other)]\n+pub(crate) struct AsmExpectedOther {\n+    #[primary_span]\n+    #[label(builtin_macros_asm_expected_other)]\n+    pub(crate) span: Span,\n+    pub(crate) is_global_asm: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_duplicate_arg)]\n+pub(crate) struct AsmDuplicateArg {\n+    #[primary_span]\n+    #[label(builtin_macros_arg)]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) prev: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pos_after)]\n+pub(crate) struct AsmPositionalAfter {\n+    #[primary_span]\n+    #[label(builtin_macros_pos)]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_named)]\n+    pub(crate) named: Vec<Span>,\n+    #[label(builtin_macros_explicit)]\n+    pub(crate) explicit: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_noreturn)]\n+pub(crate) struct AsmNoReturn {\n+    #[primary_span]\n+    pub(crate) outputs_sp: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_global_asm_clobber_abi)]\n+pub(crate) struct GlobalAsmClobberAbi {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+pub(crate) struct AsmClobberNoReg {\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) clobbers: Vec<Span>,\n+}\n+\n+impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for AsmClobberNoReg {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, G> {\n+        let mut diag =\n+            handler.struct_diagnostic(crate::fluent_generated::builtin_macros_asm_clobber_no_reg);\n+        diag.set_span(self.spans.clone());\n+        // eager translation as `span_labels` takes `AsRef<str>`\n+        let lbl1 = handler.eagerly_translate_to_string(\n+            crate::fluent_generated::builtin_macros_asm_clobber_abi,\n+            [].into_iter(),\n+        );\n+        diag.span_labels(self.clobbers, &lbl1);\n+        let lbl2 = handler.eagerly_translate_to_string(\n+            crate::fluent_generated::builtin_macros_asm_clobber_outputs,\n+            [].into_iter(),\n+        );\n+        diag.span_labels(self.spans, &lbl2);\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_opt_already_provided)]\n+pub(crate) struct AsmOptAlreadyprovided {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) symbol: Symbol,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\", style = \"tool-only\")]\n+    pub(crate) full_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(builtin_macros_test_runner_invalid)]\n pub(crate) struct TestRunnerInvalid {"}]}