{"sha": "6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDc4YzdkZTg4OWVjNDk0M2I5ZGNkY2JmYmI4YTgyNDRmNDc5Y2M=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-03T03:51:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-03T03:51:56Z"}, "message": "Merge remote-tracking branch 'brson/io' into incoming\n\nConflicts:\n\tmk/rt.mk\n\tsrc/libcore/run.rs", "tree": {"sha": "7f9fd01150a7611007255cbb2e45cf41e0cd4989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f9fd01150a7611007255cbb2e45cf41e0cd4989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "html_url": "https://github.com/rust-lang/rust/commit/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baa1c1834f608c8c789db6d2495626ff9d28dd96", "url": "https://api.github.com/repos/rust-lang/rust/commits/baa1c1834f608c8c789db6d2495626ff9d28dd96", "html_url": "https://github.com/rust-lang/rust/commit/baa1c1834f608c8c789db6d2495626ff9d28dd96"}, {"sha": "f8dffc6789113a10c9dbf1d815c3569b19b53e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8dffc6789113a10c9dbf1d815c3569b19b53e96", "html_url": "https://github.com/rust-lang/rust/commit/f8dffc6789113a10c9dbf1d815c3569b19b53e96"}], "stats": {"total": 1746, "additions": 1399, "deletions": 347}, "files": [{"sha": "33077872c1696df4966f256d11ac739a61be83d1", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -238,7 +238,7 @@ $(foreach target,$(CFG_TARGET_TRIPLES),\\\n \n CORELIB_CRATE := $(S)src/libcore/core.rc\n CORELIB_INPUTS := $(wildcard $(addprefix $(S)src/libcore/,        \\\n-                                           core.rc *.rs */*.rs */*/*rs))\n+                                           core.rc *.rs */*.rs */*/*rs */*/*/*rs))\n \n ######################################################################\n # Standard library variables"}, {"sha": "f49c75d6acb010405a9dde6e9013b5e9dbc8a086", "filename": "mk/docs.mk", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -16,15 +16,8 @@ DOCS :=\n \n \n ######################################################################\n-# Pandoc (reference-manual related)\n+# Docs, from pandoc, rustdoc (which runs pandoc), and node\n ######################################################################\n-ifeq ($(CFG_PANDOC),)\n-  $(info cfg: no pandoc found, omitting doc/rust.pdf)\n-else\n-\n-  ifeq ($(CFG_NODE),)\n-    $(info cfg: no node found, omitting doc/tutorial.html)\n-  else\n \n doc/rust.css: rust.css\n \t@$(call E, cp: $@)\n@@ -34,6 +27,18 @@ doc/manual.css: manual.css\n \t@$(call E, cp: $@)\n \t$(Q)cp -a $< $@ 2> /dev/null\n \n+ifeq ($(CFG_PANDOC),)\n+  $(info cfg: no pandoc found, omitting docs)\n+  NO_DOCS = 1\n+endif\n+\n+ifeq ($(CFG_NODE),)\n+  $(info cfg: no node found, omitting docs)\n+  NO_DOCS = 1\n+endif\n+\n+ifneq ($(NO_DOCS),1)\n+\n DOCS += doc/rust.html\n doc/rust.html: rust.md doc/version_info.html doc/rust.css doc/manual.css\n \t@$(call E, pandoc: $@)\n@@ -47,19 +52,8 @@ doc/rust.html: rust.md doc/version_info.html doc/rust.css doc/manual.css\n          --css=manual.css \\\n \t     --include-before-body=doc/version_info.html \\\n          --output=$@\n-  endif\n \n-  ifeq ($(CFG_PDFLATEX),)\n-    $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n-  else\n-    ifeq ($(CFG_XETEX),)\n-      $(info cfg: no xetex found, disabling doc/rust.pdf)\n-    else\n-      ifeq ($(CFG_LUATEX),)\n-        $(info cfg: lacking luatex, disabling pdflatex)\n-      else\n-\n-DOCS += doc/rust.pdf\n+DOCS += doc/rust.tex\n doc/rust.tex: rust.md doc/version.md\n \t@$(call E, pandoc: $@)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js $< | \\\n@@ -70,17 +64,6 @@ doc/rust.tex: rust.md doc/version.md\n          --from=markdown --to=latex \\\n          --output=$@\n \n-doc/rust.pdf: doc/rust.tex\n-\t@$(call E, pdflatex: $@)\n-\t$(Q)$(CFG_PDFLATEX) \\\n-        -interaction=batchmode \\\n-        -output-directory=doc \\\n-        $<\n-\n-      endif\n-    endif\n-  endif\n-\n DOCS += doc/rustpkg.html\n doc/rustpkg.html: rustpkg.md doc/version_info.html doc/rust.css doc/manual.css\n \t@$(call E, pandoc: $@)\n@@ -95,13 +78,6 @@ doc/rustpkg.html: rustpkg.md doc/version_info.html doc/rust.css doc/manual.css\n \t     --include-before-body=doc/version_info.html \\\n          --output=$@\n \n-######################################################################\n-# Node (tutorial related)\n-######################################################################\n-  ifeq ($(CFG_NODE),)\n-    $(info cfg: no node found, omitting doc/tutorial.html)\n-  else\n-\n DOCS += doc/tutorial.html\n doc/tutorial.html: tutorial.md doc/version_info.html doc/rust.css\n \t@$(call E, pandoc: $@)\n@@ -153,9 +129,29 @@ doc/tutorial-tasks.html: tutorial-tasks.md doc/version_info.html doc/rust.css\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+  ifeq ($(CFG_PDFLATEX),)\n+    $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n+  else\n+    ifeq ($(CFG_XETEX),)\n+      $(info cfg: no xetex found, disabling doc/rust.pdf)\n+    else\n+      ifeq ($(CFG_LUATEX),)\n+        $(info cfg: lacking luatex, disabling pdflatex)\n+      else\n+\n+DOCS += doc/rust.pdf\n+doc/rust.pdf: doc/rust.tex\n+\t@$(call E, pdflatex: $@)\n+\t$(Q)$(CFG_PDFLATEX) \\\n+        -interaction=batchmode \\\n+        -output-directory=doc \\\n+        $<\n+\n+      endif\n+    endif\n   endif\n-endif\n \n+endif # No pandoc / node\n \n ######################################################################\n # LLnextgen (grammar analysis from refman)"}, {"sha": "1240fe03dd54de78d3094c29c833c90904283e14", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -192,4 +192,27 @@ mod test {\n \n         assert!(trapped);\n     }\n+\n+    // Issue #6009\n+    mod m {\n+        condition! {\n+            sadness: int -> int;\n+        }\n+\n+        mod n {\n+            use super::sadness;\n+\n+            #[test]\n+            fn test_conditions_are_public() {\n+                let mut trapped = false;\n+                do sadness::cond.trap(|_| {\n+                    trapped = true;\n+                    0\n+                }).in {\n+                    sadness::cond.raise(0);\n+                }\n+                assert!(trapped);\n+            }\n+        }\n+    }\n }"}, {"sha": "40966f50e4b53d1b4d64e600193fb79618d46021", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -124,6 +124,9 @@ pub mod linkhack {\n     }\n }\n \n+// Internal macros\n+mod macros;\n+\n /* The Prelude. */\n \n pub mod prelude;"}, {"sha": "b19a753b71577110590d9b29d76993080905a018", "filename": "src/libcore/macros.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_escape];\n+\n+// Some basic logging\n+macro_rules! rtdebug_ (\n+    ($( $arg:expr),+) => ( {\n+        dumb_println(fmt!( $($arg),+ ));\n+\n+        fn dumb_println(s: &str) {\n+            use io::WriterUtil;\n+            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+            dbg.write_str(s);\n+            dbg.write_str(\"\\n\");\n+        }\n+\n+    } )\n+)\n+\n+// An alternate version with no output, for turning off logging\n+macro_rules! rtdebug (\n+    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n+)\n+\n+macro_rules! abort(\n+    ($( $msg:expr),+) => ( {\n+        rtdebug!($($msg),+);\n+\n+        unsafe { ::libc::abort(); }\n+    } )\n+)"}, {"sha": "cff224a80bee283cd2730af0a8ae5ada5ba0e9d1", "filename": "src/libcore/rt/io/extensions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "previous_filename": "src/libcore/rt/io/util.rs"}, {"sha": "85dc180452ffc71fd541e85b27bcf3a38f7b24d2", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -9,13 +9,9 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::misc::PathLike;\n+use super::support::PathLike;\n use super::{Reader, Writer, Seek, Close};\n-use super::{IoError, SeekStyle};\n-\n-/// Open a file with the default FileMode and FileAccess\n-/// # XXX are there sane defaults here?\n-pub fn open_file<P: PathLike>(_path: &P) -> FileStream { fail!() }\n+use super::SeekStyle;\n \n /// # XXX\n /// * Ugh, this is ridiculous. What is the best way to represent these options?\n@@ -46,7 +42,7 @@ impl FileStream {\n     pub fn open<P: PathLike>(_path: &P,\n                              _mode: FileMode,\n                              _access: FileAccess\n-                            ) -> Result<FileStream, IoError> {\n+                            ) -> Option<FileStream> {\n         fail!()\n     }\n }"}, {"sha": "06e1466831df0e21b8f81b3abebe4b1baa6111c5", "filename": "src/libcore/rt/io/mem.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmem.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::*;\n use super::*;\n-\n+use cmp::min;\n \n /// Writes to an owned, growable byte vector\n pub struct MemWriter {\n@@ -29,13 +29,15 @@ impl MemWriter {\n }\n \n impl Writer for MemWriter {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        self.buf.push_all(buf)\n+    }\n \n     fn flush(&mut self) { /* no-op */ }\n }\n \n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { self.buf.len() as u64 }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n@@ -77,13 +79,27 @@ impl MemReader {\n }\n \n impl Reader for MemReader {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        { if self.eof() { return None; } }\n+\n+        let write_len = min(buf.len(), self.buf.len() - self.pos);\n+        {\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = vec::mut_slice(buf, 0, write_len);\n+            assert!(input.len() == output.len());\n+            vec::bytes::copy_memory(output, input, write_len);\n+        }\n+        self.pos += write_len;\n+        assert!(self.pos <= self.buf.len());\n \n-    fn eof(&mut self) -> bool { fail!() }\n+        return Some(write_len);\n+    }\n+\n+    fn eof(&mut self) -> bool { self.pos == self.buf.len() }\n }\n \n impl Seek for MemReader {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { self.pos as u64 }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n@@ -163,4 +179,43 @@ impl<'self> Seek for BufReader<'self> {\n     fn tell(&self) -> u64 { fail!() }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n\\ No newline at end of file\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+\n+    #[test]\n+    fn test_mem_writer() {\n+        let mut writer = MemWriter::new();\n+        assert!(writer.tell() == 0);\n+        writer.write([0]);\n+        assert!(writer.tell() == 1);\n+        writer.write([1, 2, 3]);\n+        writer.write([4, 5, 6, 7]);\n+        assert!(writer.tell() == 8);\n+        assert!(writer.inner() == ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n+    }\n+\n+    #[test]\n+    fn test_mem_reader() {\n+        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut buf = [];\n+        assert!(reader.read(buf) == Some(0));\n+        assert!(reader.tell() == 0);\n+        let mut buf = [0];\n+        assert!(reader.read(buf) == Some(1));\n+        assert!(reader.tell() == 1);\n+        assert!(buf == [0]);\n+        let mut buf = [0, ..4];\n+        assert!(reader.read(buf) == Some(4));\n+        assert!(reader.tell() == 5);\n+        assert!(buf == [1, 2, 3, 4]);\n+        assert!(reader.read(buf) == Some(3));\n+        assert!(buf.slice(0, 3) == [5, 6, 7]);\n+        assert!(reader.eof());\n+        assert!(reader.read(buf) == None);\n+        assert!(reader.eof());\n+    }\n+}"}, {"sha": "ced4ba0ee23094cd34aea77b105616df04bf951e", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 218, "deletions": 28, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -11,7 +11,13 @@\n /*! Synchronous I/O\n \n This module defines the Rust interface for synchronous I/O.\n-It supports file access,\n+It models byte-oriented input and output with the Reader and Writer traits.\n+Types that implement both `Reader` and `Writer` and called 'streams',\n+and automatically implement trait `Stream`.\n+Implementations are provided for common I/O streams like\n+file, TCP, UDP, Unix domain sockets.\n+Readers and Writers may be composed to add capabilities like string\n+parsing, encoding, and compression.\n \n This will likely live in core::io, not core::rt::io.\n \n@@ -27,44 +33,177 @@ Some examples of obvious things you might want to do\n \n * Read a complete file to a string, (converting newlines?)\n \n-    let contents = open(\"message.txt\").read_to_str(); // read_to_str??\n+    let contents = File::open(\"message.txt\").read_to_str(); // read_to_str??\n \n * Write a line to a file\n \n-    let file = FileStream::open(\"message.txt\", Create, Write);\n+    let file = File::open(\"message.txt\", Create, Write);\n     file.write_line(\"hello, file!\");\n \n * Iterate over the lines of a file\n \n+    do File::open(\"message.txt\").each_line |line| {\n+        println(line)\n+    }\n+\n * Pull the lines of a file into a vector of strings\n \n+    let lines = File::open(\"message.txt\").line_iter().to_vec();\n+\n+* Make an simple HTTP request\n+\n+    let socket = TcpStream::open(\"localhost:8080\");\n+    socket.write_line(\"GET / HTTP/1.0\");\n+    socket.write_line(\"\");\n+    let response = socket.read_to_end();\n+\n * Connect based on URL? Requires thinking about where the URL type lives\n   and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n   yields a `TcpStream`.\n \n-    connect(\"tcp://localhost:8080\").write_line(\"HTTP 1.0 GET /\");\n+    connect(\"tcp://localhost:8080\");\n \n # Terms\n \n-* reader\n-* writer\n-* stream\n-* Blocking vs. non-blocking\n-* synchrony and asynchrony\n-\n-I tend to call this implementation non-blocking, because performing I/O\n-doesn't block the progress of other tasks. Is that how we want to present\n-it, 'synchronous but non-blocking'?\n+* Reader - An I/O source, reads bytes into a buffer\n+* Writer - An I/O sink, writes bytes from a buffer\n+* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n+  and are collectively referred to a `streams`.\n+* Decorator - A Reader or Writer that composes with others to add additional capabilities\n+  such as encoding or decoding\n+\n+# Blocking and synchrony\n+\n+When discussing I/O you often hear the terms 'synchronous' and\n+'asynchronous', along with 'blocking' and 'non-blocking' compared and\n+contrasted. A synchronous I/O interface performs each I/O operation to\n+completion before proceeding to the next. Synchronous interfaces are\n+usually used in imperative style as a sequence of commands. An\n+asynchronous interface allows multiple I/O requests to be issued\n+simultaneously, without waiting for each to complete before proceeding\n+to the next.\n+\n+Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n+traditional single-threaded systems, performing a synchronous I/O\n+operation means that the program stops all activity (it 'blocks')\n+until the I/O is complete. Blocking is bad for performance when\n+there are other computations that could be done.\n+\n+Asynchronous interfaces are most often associated with the callback\n+(continuation-passing) style popularised by node.js. Such systems rely\n+on all computations being run inside an event loop which maintains a\n+list of all pending I/O events; when one completes the registered\n+callback is run and the code that made the I/O request continiues.\n+Such interfaces achieve non-blocking at the expense of being more\n+difficult to reason about.\n+\n+Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n+\n+Remember that Rust tasks are 'green threads', lightweight threads that\n+are multiplexed onto a single operating system thread. If that system\n+thread blocks then no other task may proceed. Rust tasks are\n+relatively cheap to create, so as long as other tasks are free to\n+execute then non-blocking code may be written by simply creating a new\n+task.\n+\n+When discussing blocking in regards to Rust's I/O model, we are\n+concerned with whether performing I/O blocks other Rust tasks from\n+proceeding. In other words, when a task calls `read`, it must then\n+wait (or 'sleep', or 'block') until the call to `read` is complete.\n+During this time, other tasks may or may not be executed, depending on\n+how `read` is implemented.\n+\n+\n+Rust's default I/O implementation is non-blocking; by cooperating\n+directly with the task scheduler it arranges to never block progress\n+of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n+per-scheduler (and hence per-thread) event loop. Synchronous I/O\n+requests are implemented by descheduling the running task and\n+performing an asynchronous request; the task is only resumed once the\n+asynchronous request completes.\n+\n+For blocking (but possibly more efficient) implementations, look\n+in the `io::native` module.\n \n # Error Handling\n \n+I/O is an area where nearly every operation can result in unexpected\n+errors. It should allow errors to be handled efficiently.\n+It needs to be convenient to use I/O when you don't care\n+about dealing with specific errors.\n+\n+Rust's I/O employs a combination of techniques to reduce boilerplate\n+while still providing feedback about errors. The basic strategy:\n+\n+* Errors are fatal by default, resulting in task failure\n+* Errors raise the `io_error` conditon which provides an opportunity to inspect\n+  an IoError object containing details.\n+* Return values must have a sensible null or zero value which is returned\n+  if a condition is handled successfully. This may be an `Option`, an empty\n+  vector, or other designated error value.\n+* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n+  so that nullable values do not have to be 'unwrapped' before use.\n+\n+These features combine in the API to allow for expressions like\n+`File::new(\"diary.txt\").write_line(\"met a girl\")` without having to\n+worry about whether \"diary.txt\" exists or whether the write\n+succeeds. As written, if either `new` or `write_line` encounters\n+an error the task will fail.\n+\n+If you wanted to handle the error though you might write\n+\n+    let mut error = None;\n+    do io_error::cond(|e: IoError| {\n+        error = Some(e);\n+    }).in {\n+        File::new(\"diary.txt\").write_line(\"met a girl\");\n+    }\n+\n+    if error.is_some() {\n+        println(\"failed to write my diary\");\n+    }\n+\n+XXX: Need better condition handling syntax\n+\n+In this case the condition handler will have the opportunity to\n+inspect the IoError raised by either the call to `new` or the call to\n+`write_line`, but then execution will continue.\n+\n+So what actually happens if `new` encounters an error? To understand\n+that it's important to know that what `new` returns is not a `File`\n+but an `Option<File>`.  If the file does not open, and the condition\n+is handled, then `new` will simply return `None`. Because there is an\n+implementation of `Writer` (the trait required ultimately required for\n+types to implement `write_line`) there is no need to inspect or unwrap\n+the `Option<File>` and we simply call `write_line` on it.  If `new`\n+returned a `None` then the followup call to `write_line` will also\n+raise an error.\n+\n+## Concerns about this strategy\n+\n+This structure will encourage a programming style that is prone\n+to errors similar to null pointer dereferences.\n+In particular code written to ignore errors and expect conditions to be unhandled\n+will start passing around null or zero objects when wrapped in a condition handler.\n+\n+* XXX: How should we use condition handlers that return values?\n+\n+\n+# Issues withi/o scheduler affinity, work stealing, task pinning\n+\n # Resource management\n \n * `close` vs. RAII\n \n-# Paths and URLs\n+# Paths, URLs and overloaded constructors\n+\n+\n+\n+# Scope\n \n-# std\n+In scope for core\n+\n+* Url?\n \n Some I/O things don't belong in core\n \n@@ -73,7 +212,12 @@ Some I/O things don't belong in core\n     - http\n   - flate\n \n-# XXX\n+Out of scope\n+\n+* Async I/O. We'll probably want it eventually\n+\n+\n+# XXX Questions and issues\n \n * Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n   Overloading would be nice.\n@@ -83,6 +227,7 @@ Some I/O things don't belong in core\n * fsync\n * relationship with filesystem querying, Directory, File types etc.\n * Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n+* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n * Trait for things that are both readers and writers, Stream?\n * How to handle newline conversion\n * String conversion\n@@ -92,6 +237,7 @@ Some I/O things don't belong in core\n * Do we need `close` at all? dtors might be good enough\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n+* Using conditions is a big unknown since we don't have much experience with them\n \n */\n \n@@ -104,25 +250,29 @@ pub use self::stdio::stderr;\n pub use self::stdio::print;\n pub use self::stdio::println;\n \n-pub use self::file::open_file;\n pub use self::file::FileStream;\n-pub use self::net::Listener;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n // Some extension traits that all Readers and Writers get.\n-pub use self::util::ReaderUtil;\n-pub use self::util::ReaderByteConversions;\n-pub use self::util::WriterByteConversions;\n+pub use self::extensions::ReaderUtil;\n+pub use self::extensions::ReaderByteConversions;\n+pub use self::extensions::WriterByteConversions;\n \n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n-#[path = \"net/mod.rs\"]\n-pub mod net;\n+pub mod net {\n+    pub mod tcp;\n+    pub mod udp;\n+    pub mod ip;\n+    #[cfg(unix)]\n+    pub mod unix;\n+    pub mod http;\n+}\n \n /// Readers and Writers for memory buffers and strings.\n #[cfg(not(stage0))] // XXX Using unsnapshotted features\n@@ -131,6 +281,10 @@ pub mod mem;\n /// Non-blocking access to stdin, stdout, stderr\n pub mod stdio;\n \n+/// Implementations for Option\n+#[cfg(not(stage0))] // Requires condition! fixes\n+mod option;\n+\n /// Basic stream compression. XXX: Belongs with other flate code\n #[cfg(not(stage0))] // XXX Using unsnapshotted features\n pub mod flate;\n@@ -140,10 +294,10 @@ pub mod flate;\n pub mod comm_adapters;\n \n /// Extension traits\n-mod util;\n+mod extensions;\n \n /// Non-I/O things needed by the I/O module\n-mod misc;\n+mod support;\n \n /// Thread-blocking implementations\n pub mod native {\n@@ -173,12 +327,14 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+#[deriving(Eq)]\n pub enum IoErrorKind {\n     FileNotFound,\n     FilePermission,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError\n+    OtherIoError,\n+    PreviousIoError\n }\n \n // XXX: Can't put doc comments on macros\n@@ -211,9 +367,9 @@ pub trait Reader {\n     ///         println(reader.read_line());\n     ///     }\n     ///\n-    /// # XXX\n+    /// # Failue\n     ///\n-    /// What does this return if the Reader is in an error state?\n+    /// Returns `true` on failure.\n     fn eof(&mut self) -> bool;\n }\n \n@@ -253,9 +409,30 @@ pub enum SeekStyle {\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     fn tell(&self) -> u64;\n+\n+    /// Seek to an offset in a stream\n+    ///\n+    /// A successful seek clears the EOF indicator.\n+    ///\n+    /// # XXX\n+    ///\n+    /// * What is the behavior when seeking past the end of a stream?\n     fn seek(&mut self, pos: i64, style: SeekStyle);\n }\n \n+/// A listener is a value that listens for connections\n+pub trait Listener<S> {\n+    /// Wait for and accept an incoming connection\n+    ///\n+    /// Returns `None` on timeout.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises `io_error` condition. If the condition is handled,\n+    /// then `accept` returns `None`.\n+    fn accept(&mut self) -> Option<S>;\n+}\n+\n /// Common trait for decorator types.\n ///\n /// Provides accessors to get the inner, 'decorated' values. The I/O library\n@@ -281,3 +458,16 @@ pub trait Decorator<T> {\n     /// Take a mutable reference to the decorated value\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n }\n+\n+pub fn standard_error(kind: IoErrorKind) -> IoError {\n+    match kind {\n+        PreviousIoError => {\n+            IoError {\n+                kind: PreviousIoError,\n+                desc: \"Failing due to a previous I/O error\",\n+                detail: None\n+            }\n+        }\n+        _ => fail!()\n+    }\n+}"}, {"sha": "130ff6b38fa82f3f1a8a8a8e06c4d8294e672d18", "filename": "src/libcore/rt/io/net/mod.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baa1c1834f608c8c789db6d2495626ff9d28dd96/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs?ref=baa1c1834f608c8c789db6d2495626ff9d28dd96", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-\n-pub mod tcp;\n-pub mod udp;\n-pub mod ip;\n-#[cfg(unix)]\n-pub mod unix;\n-pub mod http;\n-\n-/// A listener is a value that listens for connections\n-pub trait Listener<S> {\n-    /// Wait for and accept an incoming connection\n-    ///\n-    /// Returns `None` on timeout.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises `io_error` condition. If the condition is handled,\n-    /// then `accept` returns `None`.\n-    fn accept(&mut self) -> Option<S>;\n-}"}, {"sha": "c95b4344fe75d4ffe9531b12b8973278da77649b", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n use super::ip::IpAddr;\n \n pub struct TcpStream;\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Result<TcpStream, IoError> {\n+    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n         fail!()\n     }\n }\n@@ -40,11 +39,36 @@ impl Close for TcpStream {\n pub struct TcpListener;\n \n impl TcpListener {\n-    pub fn new(_addr: IpAddr) -> TcpListener {\n+    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n         fail!()\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n     fn accept(&mut self) -> Option<TcpStream> { fail!() }\n }\n+\n+#[cfg(test)]\n+mod test {\n+\n+    #[test] #[ignore]\n+    fn smoke_test() {\n+        /*do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawn_immediately {\n+                let listener = TcpListener::bind(addr);\n+                do listener.accept() {\n+                    let mut buf = [0];\n+                    listener.read(buf);\n+                    assert!(buf[0] == 99);\n+                }\n+            }\n+\n+            do spawn_immediately {\n+                let stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }*/\n+    }\n+}"}, {"sha": "0cb2978fb1a68a79223f1dfe6ecf7febf33ba065", "filename": "src/libcore/rt/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n use super::ip::IpAddr;\n \n pub struct UdpStream;\n \n impl UdpStream {\n-    pub fn connect(_addr: IpAddr) -> Result<UdpStream, IoError> {\n+    pub fn connect(_addr: IpAddr) -> Option<UdpStream> {\n         fail!()\n     }\n }\n@@ -40,7 +39,7 @@ impl Close for UdpStream {\n pub struct UdpListener;\n \n impl UdpListener {\n-    pub fn new(_addr: IpAddr) -> UdpListener {\n+    pub fn bind(_addr: IpAddr) -> Option<UdpListener> {\n         fail!()\n     }\n }"}, {"sha": "262816beecc98450c2cacabb5cd9840960bc9551", "filename": "src/libcore/rt/io/net/unix.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n-use super::super::misc::PathLike;\n+use super::super::support::PathLike;\n \n pub struct UnixStream;\n \n impl UnixStream {\n-    pub fn connect<P: PathLike>(_path: &P) -> Result<UnixStream, IoError> {\n+    pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n         fail!()\n     }\n }\n@@ -40,7 +39,7 @@ impl Close for UnixStream {\n pub struct UnixListener;\n \n impl UnixListener {\n-    pub fn new<P: PathLike>(_path: &P) -> UnixListener {\n+    pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n         fail!()\n     }\n }"}, {"sha": "95f8711cb5bd555bd893a3ce7874054fb7b4e1bc", "filename": "src/libcore/rt/io/option.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of I/O traits for the Option type\n+//!\n+//! I/O constructors return option types to allow errors to be handled.\n+//! These implementations allow e.g. `Option<FileStream>` to be used\n+//! as a `Reader` without unwrapping the option first.\n+//!\n+//! # XXX Seek and Close\n+\n+use option::*;\n+use super::{Reader, Writer, Listener};\n+use super::{standard_error, PreviousIoError, io_error, IoError};\n+\n+fn prev_io_error() -> IoError {\n+    standard_error(PreviousIoError)\n+}\n+\n+impl<W: Writer> Writer for Option<W> {\n+    fn write(&mut self, buf: &[u8]) {\n+        match *self {\n+            Some(ref mut writer) => writer.write(buf),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+\n+    fn flush(&mut self) {\n+        match *self {\n+            Some(ref mut writer) => writer.flush(),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for Option<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match *self {\n+            Some(ref mut reader) => reader.read(buf),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        match *self {\n+            Some(ref mut reader) => reader.eof(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                true\n+            }\n+        }\n+    }\n+}\n+\n+impl<L: Listener<S>, S> Listener<S> for Option<L> {\n+    fn accept(&mut self) -> Option<S> {\n+        match *self {\n+            Some(ref mut listener) => listener.accept(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::*;\n+    use super::super::mem::*;\n+    use rt::test::*;\n+    use super::super::{PreviousIoError, io_error};\n+\n+    #[test]\n+    fn test_option_writer() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = Some(MemWriter::new());\n+            writer.write([0, 1, 2]);\n+            writer.flush();\n+            assert!(writer.unwrap().inner() == ~[0, 1, 2]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_writer_error() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = None;\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.write([0, 0, 0]);\n+            }\n+            assert!(called);\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.flush();\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader() {\n+        do run_in_newsched_task {\n+            let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+            let mut buf = [0, 0];\n+            reader.read(buf);\n+            assert!(buf == [0, 1]);\n+            assert!(!reader.eof());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader_error() {\n+        let mut reader: Option<MemReader> = None;\n+        let mut buf = [];\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            reader.read(buf);\n+        }\n+        assert!(called);\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            assert!(reader.eof());\n+        }\n+        assert!(called);\n+    }\n+}"}, {"sha": "7bace5d6df2ccfdba1cfe7538ab05cbed10da6cb", "filename": "src/libcore/rt/io/support.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fsupport.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "previous_filename": "src/libcore/rt/io/misc.rs"}, {"sha": "fbd4a77d79b98342a0fe0565de675eb888ceb517", "filename": "src/libcore/rt/local_heap.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_heap.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The local, garbage collected heap\n+\n+use libc::{c_void, uintptr_t, size_t};\n+use ops::Drop;\n+\n+type MemoryRegion = c_void;\n+type BoxedRegion = c_void;\n+\n+pub type OpaqueBox = c_void;\n+pub type TypeDesc = c_void;\n+\n+pub struct LocalHeap {\n+    memory_region: *MemoryRegion,\n+    boxed_region: *BoxedRegion\n+}\n+\n+impl LocalHeap {\n+    pub fn new() -> LocalHeap {\n+        unsafe {\n+            // Don't need synchronization for the single-threaded local heap\n+            let synchronized = false as uintptr_t;\n+            // XXX: These usually come from the environment\n+            let detailed_leaks = false as uintptr_t;\n+            let poison_on_free = false as uintptr_t;\n+            let region = rust_new_memory_region(synchronized, detailed_leaks, poison_on_free);\n+            assert!(region.is_not_null());\n+            let boxed = rust_new_boxed_region(region, poison_on_free);\n+            assert!(boxed.is_not_null());\n+            LocalHeap {\n+                memory_region: region,\n+                boxed_region: boxed\n+            }\n+        }\n+    }\n+\n+    pub fn alloc(&mut self, td: *TypeDesc, size: uint) -> *OpaqueBox {\n+        unsafe {\n+            return rust_boxed_region_malloc(self.boxed_region, td, size as size_t);\n+        }\n+    }\n+\n+    pub fn free(&mut self, box: *OpaqueBox) {\n+        unsafe {\n+            return rust_boxed_region_free(self.boxed_region, box);\n+        }\n+    }\n+}\n+\n+impl Drop for LocalHeap {\n+    fn finalize(&self) {\n+        unsafe {\n+            rust_delete_boxed_region(self.boxed_region);\n+            rust_delete_memory_region(self.memory_region);\n+        }\n+    }\n+}\n+\n+extern {\n+    fn rust_new_memory_region(synchronized: uintptr_t,\n+                               detailed_leaks: uintptr_t,\n+                               poison_on_free: uintptr_t) -> *MemoryRegion;\n+    fn rust_delete_memory_region(region: *MemoryRegion);\n+    fn rust_new_boxed_region(region: *MemoryRegion,\n+                             poison_on_free: uintptr_t) -> *BoxedRegion;\n+    fn rust_delete_boxed_region(region: *BoxedRegion);\n+    fn rust_boxed_region_malloc(region: *BoxedRegion,\n+                                td: *TypeDesc,\n+                                size: size_t) -> *OpaqueBox;\n+    fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n+}\n+"}, {"sha": "a03bc6c409f8b4092283ab442450896aa9fbccdf", "filename": "src/libcore/rt/local_services.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Language-level runtime services that should reasonably expected\n+//! to be available 'everywhere'. Local heaps, GC, unwinding,\n+//! local storage, and logging. Even a 'freestanding' Rust would likely want\n+//! to implement this.\n+\n+//! Local services may exist in at least three different contexts:\n+//! when running as a task, when running in the scheduler's context,\n+//! or when running outside of a scheduler but with local services\n+//! (freestanding rust with local services?).\n+\n+use prelude::*;\n+use libc::{c_void, uintptr_t};\n+use cast::transmute;\n+use super::sched::local_sched;\n+use super::local_heap::LocalHeap;\n+\n+pub struct LocalServices {\n+    heap: LocalHeap,\n+    gc: GarbageCollector,\n+    storage: LocalStorage,\n+    logger: Logger,\n+    unwinder: Option<Unwinder>,\n+    destroyed: bool\n+}\n+\n+pub struct GarbageCollector;\n+pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n+pub struct Logger;\n+\n+pub struct Unwinder {\n+    unwinding: bool,\n+}\n+\n+impl LocalServices {\n+    pub fn new() -> LocalServices {\n+        LocalServices {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: Logger,\n+            unwinder: Some(Unwinder { unwinding: false }),\n+            destroyed: false\n+        }\n+    }\n+\n+    pub fn without_unwinding() -> LocalServices {\n+        LocalServices {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: Logger,\n+            unwinder: None,\n+            destroyed: false\n+        }\n+    }\n+\n+    pub fn run(&mut self, f: &fn()) {\n+        // This is just an assertion that `run` was called unsafely\n+        // and this instance of LocalServices is still accessible.\n+        do borrow_local_services |sched| {\n+            assert!(ptr::ref_eq(sched, self));\n+        }\n+\n+        match self.unwinder {\n+            Some(ref mut unwinder) => {\n+                // If there's an unwinder then set up the catch block\n+                unwinder.try(f);\n+            }\n+            None => {\n+                // Otherwise, just run the body\n+                f()\n+            }\n+        }\n+        self.destroy();\n+    }\n+\n+    /// Must be called manually before finalization to clean up\n+    /// thread-local resources. Some of the routines here expect\n+    /// LocalServices to be available recursively so this must be\n+    /// called unsafely, without removing LocalServices from\n+    /// thread-local-storage.\n+    fn destroy(&mut self) {\n+        // This is just an assertion that `destroy` was called unsafely\n+        // and this instance of LocalServices is still accessible.\n+        do borrow_local_services |sched| {\n+            assert!(ptr::ref_eq(sched, self));\n+        }\n+        match self.storage {\n+            LocalStorage(ptr, Some(ref dtor)) => {\n+                (*dtor)(ptr)\n+            }\n+            _ => ()\n+        }\n+        self.destroyed = true;\n+    }\n+}\n+\n+impl Drop for LocalServices {\n+    fn finalize(&self) { assert!(self.destroyed) }\n+}\n+\n+// Just a sanity check to make sure we are catching a Rust-thrown exception\n+static UNWIND_TOKEN: uintptr_t = 839147;\n+\n+impl Unwinder {\n+    pub fn try(&mut self, f: &fn()) {\n+        use sys::Closure;\n+\n+        unsafe {\n+            let closure: Closure = transmute(f);\n+            let code = transmute(closure.code);\n+            let env = transmute(closure.env);\n+\n+            let token = rust_try(try_fn, code, env);\n+            assert!(token == 0 || token == UNWIND_TOKEN);\n+        }\n+\n+        extern fn try_fn(code: *c_void, env: *c_void) {\n+            unsafe {\n+                let closure: Closure = Closure {\n+                    code: transmute(code),\n+                    env: transmute(env),\n+                };\n+                let closure: &fn() = transmute(closure);\n+                closure();\n+            }\n+        }\n+\n+        extern {\n+            #[rust_stack]\n+            fn rust_try(f: *u8, code: *c_void, data: *c_void) -> uintptr_t;\n+        }\n+    }\n+\n+    pub fn begin_unwind(&mut self) -> ! {\n+        self.unwinding = true;\n+        unsafe {\n+            rust_begin_unwind(UNWIND_TOKEN);\n+            return transmute(());\n+        }\n+        extern {\n+            fn rust_begin_unwind(token: uintptr_t);\n+        }\n+    }\n+}\n+\n+/// Borrow a pointer to the installed local services.\n+/// Fails (likely aborting the process) if local services are not available.\n+pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n+    do local_sched::borrow |sched| {\n+        match sched.current_task {\n+            Some(~ref mut task) => {\n+                f(&mut task.local_services)\n+            }\n+            None => {\n+                fail!(~\"no local services for schedulers yet\")\n+            }\n+        }\n+    }\n+}\n+\n+pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n+    use cast::transmute_mut_region;\n+\n+    match local_sched::unsafe_borrow().current_task {\n+        Some(~ref mut task) => {\n+            transmute_mut_region(&mut task.local_services)\n+        }\n+        None => {\n+            fail!(~\"no local services for schedulers yet\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rt::test::*;\n+\n+    #[test]\n+    fn local_heap() {\n+        do run_in_newsched_task() {\n+            let a = @5;\n+            let b = a;\n+            assert!(*a == 5);\n+            assert!(*b == 5);\n+        }\n+    }\n+\n+    #[test]\n+    fn tls() {\n+        use task::local_data::*;\n+        do run_in_newsched_task() {\n+            unsafe {\n+                fn key(_x: @~str) { }\n+                local_data_set(key, @~\"data\");\n+                assert!(*local_data_get(key).get() == ~\"data\");\n+                fn key2(_x: @~str) { }\n+                local_data_set(key2, @~\"data\");\n+                assert!(*local_data_get(key2).get() == ~\"data\");\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn unwind() {\n+        do run_in_newsched_task() {\n+            let result = spawntask_try(||());\n+            assert!(result.is_ok());\n+            let result = spawntask_try(|| fail!());\n+            assert!(result.is_err());\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "56ed7dc95b6dfaad3764742c1f1e11300509a848", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -8,30 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! The Rust runtime, including the scheduler and I/O interface */\n+\n #[doc(hidden)];\n \n use libc::c_char;\n \n-// Some basic logging\n-macro_rules! rtdebug_ (\n-    ($( $arg:expr),+) => ( {\n-        dumb_println(fmt!( $($arg),+ ));\n-\n-        fn dumb_println(s: &str) {\n-            use io::WriterUtil;\n-            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-            dbg.write_str(s);\n-            dbg.write_str(\"\\n\");\n-        }\n-\n-    } )\n-)\n-\n-// An alternate version with no output, for turning off logging\n-macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n-)\n-\n #[path = \"sched/mod.rs\"]\n mod sched;\n mod rtio;\n@@ -48,6 +30,12 @@ mod stack;\n mod context;\n mod thread;\n pub mod env;\n+pub mod local_services;\n+mod local_heap;\n+\n+/// Tools for testing the runtime\n+#[cfg(test)]\n+pub mod test;\n \n #[cfg(stage0)]\n pub fn start(main: *u8, _argc: int, _argv: *c_char, _crate_map: *u8) -> int {\n@@ -93,7 +81,7 @@ pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n /// Different runtime services are available depending on context.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n-    // Only default services, e.g. exchange heap\n+    // Only the exchange heap is available\n     GlobalContext,\n     // The scheduler may be accessed\n     SchedulerContext,\n@@ -160,24 +148,3 @@ fn test_context() {\n         sched.run();\n     }\n }\n-\n-// For setting up tests of the new scheduler\n-#[cfg(test)]\n-pub fn run_in_newsched_task(f: ~fn()) {\n-    use cell::Cell;\n-    use unstable::run_in_bare_thread;\n-    use self::sched::Task;\n-    use self::uvio::UvEventLoop;\n-\n-    let f = Cell(Cell(f));\n-\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let f = f.take();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            (f.take())();\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n-    }\n-}"}, {"sha": "d7543ae138c40eaa96fe319f0a32169abee4f31d", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -16,6 +16,7 @@ use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n+use super::local_services::LocalServices;\n use cell::Cell;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n@@ -38,7 +39,7 @@ pub struct Scheduler {\n     /// Always valid when a task is executing, otherwise not\n     priv saved_context: Context,\n     /// The currently executing task\n-    priv current_task: Option<~Task>,\n+    current_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>\n@@ -148,7 +149,7 @@ pub impl Scheduler {\n             }\n         }\n \n-        // Control never reaches here\n+        abort!(\"control reached end of task\");\n     }\n \n     fn schedule_new_task(~self, task: ~Task) {\n@@ -326,17 +327,26 @@ pub struct Task {\n     /// These are always valid when the task is not running, unless\n     /// the task is dead\n     priv saved_context: Context,\n+    /// The heap, GC, unwinding, local storage, logging\n+    local_services: LocalServices\n }\n \n pub impl Task {\n     fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+        Task::with_local(stack_pool, LocalServices::new(), start)\n+    }\n+\n+    fn with_local(stack_pool: &mut StackPool,\n+                  local_services: LocalServices,\n+                  start: ~fn()) -> Task {\n         let start = Task::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n         return Task {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n+            local_services: local_services\n         };\n     }\n \n@@ -349,9 +359,12 @@ pub impl Task {\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n                 sched.run_cleanup_job();\n-            }\n \n-            start();\n+                let sched = local_sched::unsafe_borrow();\n+                let task = sched.current_task.get_mut_ref();\n+                // FIXME #6141: shouldn't neet to put `start()` in another closure\n+                task.local_services.run(||start());\n+            }\n \n             let sched = local_sched::take();\n             sched.terminate_current_task();"}, {"sha": "63db705408800a26e4aa48a308e9f775a168de93", "filename": "src/libcore/rt/test.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::Cell;\n+use result::{Result, Ok, Err};\n+use super::io::net::ip::{IpAddr, Ipv4};\n+use rt::local_services::LocalServices;\n+\n+/// Creates a new scheduler in a new thread and runs a task in it,\n+/// then waits for the scheduler to exit. Failure of the task\n+/// will abort the process.\n+pub fn run_in_newsched_task(f: ~fn()) {\n+    use unstable::run_in_bare_thread;\n+    use super::sched::Task;\n+    use super::uvio::UvEventLoop;\n+\n+    let f = Cell(f);\n+\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~Task::with_local(&mut sched.stack_pool,\n+                                     LocalServices::without_unwinding(),\n+                                     f.take());\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}\n+\n+/// Test tasks will abort on failure instead of unwinding\n+pub fn spawntask(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        let sched = local_sched::take();\n+        sched.schedule_new_task(task.take());\n+    }\n+}\n+\n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_immediately(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        do local_sched::borrow |sched| {\n+            sched.task_queue.push_front(task.take());\n+        }\n+    }\n+}\n+\n+/// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n+pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n+    use cell::Cell;\n+    use super::sched::*;\n+    use task;\n+    use unstable::finally::Finally;\n+\n+    // Our status variables will be filled in from the scheduler context\n+    let mut failed = false;\n+    let failed_ptr: *mut bool = &mut failed;\n+\n+    // Switch to the scheduler\n+    let f = Cell(Cell(f));\n+    let mut sched = local_sched::take();\n+    do sched.deschedule_running_task_and_then() |old_task| {\n+        let old_task = Cell(old_task);\n+        let f = f.take();\n+        let mut sched = local_sched::take();\n+        let new_task = ~do Task::new(&mut sched.stack_pool) {\n+            do (|| {\n+                (f.take())()\n+            }).finally {\n+                // Check for failure then resume the parent task\n+                unsafe { *failed_ptr = task::failing(); }\n+                let sched = local_sched::take();\n+                do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n+                    let new_task = Cell(new_task);\n+                    do local_sched::borrow |sched| {\n+                        sched.task_queue.push_front(new_task.take());\n+                    }\n+                }\n+            }\n+        };\n+\n+        sched.resume_task_immediately(new_task);\n+    }\n+\n+    if !failed { Ok(()) } else { Err(()) }\n+}\n+\n+/// Get a port number, starting at 9600, for use in tests\n+pub fn next_test_port() -> u16 {\n+    unsafe {\n+        return rust_dbg_next_port() as u16;\n+    }\n+    extern {\n+        fn rust_dbg_next_port() -> ::libc::uintptr_t;\n+    }\n+}\n+\n+/// Get a unique localhost:port pair starting at 9600\n+pub fn next_test_ip4() -> IpAddr {\n+    Ipv4(127, 0, 0, 1, next_test_port())\n+}"}, {"sha": "013a28abf2813ecf961a42d3f99b1a3cb23791e6", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -301,7 +301,8 @@ struct WatcherData {\n     write_cb: Option<ConnectionCallback>,\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>\n+    alloc_cb: Option<AllocCallback>,\n+    buf: Option<Buf>\n }\n \n pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n@@ -311,7 +312,8 @@ pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n             write_cb: None,\n             connect_cb: None,\n             close_cb: None,\n-            alloc_cb: None\n+            alloc_cb: None,\n+            buf: None\n         };\n         let data = transmute::<~WatcherData, *c_void>(data);\n         uvll::set_data_for_uv_handle(watcher.native_handle(), data);"}, {"sha": "04b9008b0677018ce4d67d6271e176f9cbb6cc87", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 16, "deletions": 48, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -19,12 +19,10 @@ use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCa\n             vec_to_uv_buf, vec_from_uv_buf};\n use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n \n-#[cfg(test)]\n-use unstable::run_in_bare_thread;\n-#[cfg(test)]\n-use super::super::thread::Thread;\n-#[cfg(test)]\n-use cell::Cell;\n+#[cfg(test)] use cell::Cell;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::super::thread::Thread;\n+#[cfg(test)] use super::super::test::*;\n \n fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n     match addr {\n@@ -109,21 +107,25 @@ pub impl StreamWatcher {\n \n         let req = WriteRequest::new();\n         let buf = vec_to_uv_buf(msg);\n-        // XXX: Allocation\n-        let bufs = ~[buf];\n+        assert!(data.buf.is_none());\n+        data.buf = Some(buf);\n+        let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n                                           self.native_handle(),\n-                                          &bufs, write_cb));\n+                                          bufs, write_cb));\n         }\n-        // XXX: Freeing immediately after write. Is this ok?\n-        let _v = vec_from_uv_buf(buf);\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n-            let cb = get_watcher_data(&mut stream_watcher).write_cb.swap_unwrap();\n+            let cb = {\n+                let data = get_watcher_data(&mut stream_watcher);\n+                let _vec = vec_from_uv_buf(data.buf.swap_unwrap());\n+                let cb = data.write_cb.swap_unwrap();\n+                cb\n+            };\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }\n@@ -361,7 +363,7 @@ fn connect_close() {\n         let mut loop_ = Loop::new();\n         let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n         // Connect to a port where nobody is listening\n-        let addr = Ipv4(127, 0, 0, 1, 2923);\n+        let addr = next_test_ip4();\n         do tcp_watcher.connect(addr) |stream_watcher, status| {\n             rtdebug!(\"tcp_watcher.connect!\");\n             assert!(status.is_some());\n@@ -373,47 +375,13 @@ fn connect_close() {\n     }\n }\n \n-#[test]\n-#[ignore(reason = \"need a server to connect to\")]\n-fn connect_read() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2924);\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            let mut stream_watcher = stream_watcher;\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_none());\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do stream_watcher.read_start(alloc)\n-                |stream_watcher, _nread, buf, status| {\n-\n-                let buf = vec_from_uv_buf(buf);\n-                rtdebug!(\"read cb!\");\n-                if status.is_none() {\n-                    let _bytes = buf.unwrap();\n-                    rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n-                } else {\n-                    rtdebug!(\"status after read: %s\", status.get().to_str());\n-                    rtdebug!(\"closing\");\n-                    stream_watcher.close(||());\n-                }\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n #[test]\n fn listen() {\n     do run_in_bare_thread() {\n         static MAX: int = 10;\n         let mut loop_ = Loop::new();\n         let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2925);\n+        let addr = next_test_ip4();\n         server_tcp_watcher.bind(addr);\n         let loop_ = loop_;\n         rtdebug!(\"listening\");"}, {"sha": "94f8c0bf707dd4c9aa225d84627e916a46419355", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -19,10 +19,9 @@ use cell::{Cell, empty_cell};\n use cast::transmute;\n use super::sched::{Scheduler, local_sched};\n \n-#[cfg(test)] use super::io::net::ip::Ipv4;\n-#[cfg(test)] use super::sched::Task;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use uint;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -335,38 +334,22 @@ impl Stream for UvStream {\n }\n \n #[test]\n-#[ignore(reason = \"ffi struct issues\")]\n fn test_simple_io_no_connect() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let addr = Ipv4(127, 0, 0, 1, 2926);\n-            let maybe_chan = io.connect(addr);\n-            assert!(maybe_chan.is_none());\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+    do run_in_newsched_task {\n+        let io = unsafe { local_sched::unsafe_borrow_io() };\n+        let addr = next_test_ip4();\n+        let maybe_chan = io.connect(addr);\n+        assert!(maybe_chan.is_none());\n     }\n }\n \n #[test]\n-#[ignore(reason = \"ffi struct issues\")]\n fn test_simple_tcp_server_and_client() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2929);\n-\n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n-        };\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n \n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        // Start the server first so it's listening when we connect\n+        do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut listener = io.bind(addr).unwrap();\n@@ -381,32 +364,25 @@ fn test_simple_tcp_server_and_client() {\n                 stream.close();\n                 listener.close();\n             }\n-        };\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n+        }\n     }\n }\n \n #[test] #[ignore(reason = \"busted\")]\n fn test_read_and_block() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2930);\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n-        };\n-\n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut listener = io.bind(addr).unwrap();\n             let mut stream = listener.listen().unwrap();\n@@ -442,36 +418,58 @@ fn test_read_and_block() {\n \n             stream.close();\n             listener.close();\n-        };\n+        }\n+\n+        do spawntask_immediately {\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n     }\n }\n \n-#[test] #[ignore(reason = \"needs server\")]\n+#[test]\n fn test_read_read_read() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2931);\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n+        static MAX: uint = 500000;\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut listener = io.bind(addr).unwrap();\n+                let mut stream = listener.listen().unwrap();\n+                let mut buf = [1, .. 2048];\n+                let mut total_bytes_written = 0;\n+                while total_bytes_written < MAX {\n+                    stream.write(buf);\n+                    total_bytes_written += buf.len();\n+                }\n+                stream.close();\n+                listener.close();\n+            }\n+        }\n+\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;\n-            while total_bytes_read < 500000000 {\n+            while total_bytes_read < MAX {\n                 let nread = stream.read(buf).unwrap();\n                 rtdebug!(\"read %u bytes\", nread as uint);\n                 total_bytes_read += nread;\n+                for uint::range(0, nread) |i| {\n+                    assert!(buf[i] == 1);\n+                }\n             }\n-            rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n+            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n             stream.close();\n-        };\n-\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        }\n     }\n }"}, {"sha": "3eb7f8006b9eaee7a295b2d7e3944a6a86cb8f3b", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -219,9 +219,9 @@ pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n     return rust_uv_accept(server as *c_void, client as *c_void);\n }\n \n-pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: *~[uv_buf_t], cb: *u8) -> c_int {\n-    let buf_ptr = vec::raw::to_ptr(*buf_in);\n-    let buf_cnt = vec::len(*buf_in) as i32;\n+pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = vec::len(buf_in) as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {"}, {"sha": "dd36604883433d1bb7c6a885df8c2be406d797e6", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -10,6 +10,7 @@\n \n //! Misc low level stuff\n \n+use option::{Some, None};\n use cast;\n use cmp::{Eq, Ord};\n use gc;\n@@ -202,6 +203,7 @@ impl FailWithCause for &'static str {\n // NOTE: remove function after snapshot\n #[cfg(stage0)]\n pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n+\n     do str::as_buf(msg) |msg_buf, _msg_len| {\n         do str::as_buf(file) |file_buf, _file_len| {\n             unsafe {\n@@ -215,10 +217,28 @@ pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    unsafe {\n-        gc::cleanup_stack_for_failure();\n-        rustrt::rust_upcall_fail(msg, file, line);\n-        cast::transmute(())\n+    use rt::{context, OldTaskContext};\n+    use rt::local_services::unsafe_borrow_local_services;\n+\n+    match context() {\n+        OldTaskContext => {\n+            unsafe {\n+                gc::cleanup_stack_for_failure();\n+                rustrt::rust_upcall_fail(msg, file, line);\n+                cast::transmute(())\n+            }\n+        }\n+        _ => {\n+            // XXX: Need to print the failure message\n+            gc::cleanup_stack_for_failure();\n+            unsafe {\n+                let local_services = unsafe_borrow_local_services();\n+                match local_services.unwinder {\n+                    Some(ref mut unwinder) => unwinder.begin_unwind(),\n+                    None => abort!(\"failure without unwinder. aborting process\")\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "dff5908c047962e788acdc20a9f744e17c95dab4", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -27,8 +27,7 @@ magic.\n */\n \n use prelude::*;\n-use task::local_data_priv::{local_get, local_pop, local_modify, local_set};\n-use task::rt;\n+use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handle};\n \n /**\n  * Indexes a task-local data slot. The function's code pointer is used for\n@@ -53,7 +52,7 @@ pub type LocalDataKey<'self,T> = &'self fn(v: @T);\n pub unsafe fn local_data_pop<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_pop(rt::rust_get_task(), key)\n+    local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n@@ -62,7 +61,7 @@ pub unsafe fn local_data_pop<T:Durable>(\n pub unsafe fn local_data_get<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get(rt::rust_get_task(), key)\n+    local_get(Handle::new(), key)\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n@@ -71,7 +70,7 @@ pub unsafe fn local_data_get<T:Durable>(\n pub unsafe fn local_data_set<T:Durable>(\n     key: LocalDataKey<T>, data: @T) {\n \n-    local_set(rt::rust_get_task(), key, data)\n+    local_set(Handle::new(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n@@ -81,7 +80,7 @@ pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n-    local_modify(rt::rust_get_task(), key, modify_fn)\n+    local_modify(Handle::new(), key, modify_fn)\n }\n \n #[test]"}, {"sha": "10a40887e57928cfe17e27db382c9c42fe920838", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -18,15 +18,39 @@ use task::rt;\n use task::local_data::LocalDataKey;\n \n use super::rt::rust_task;\n+use rt::local_services::LocalStorage;\n+\n+pub enum Handle {\n+    OldHandle(*rust_task),\n+    NewHandle(*mut LocalStorage)\n+}\n+\n+impl Handle {\n+    pub fn new() -> Handle {\n+        use rt::{context, OldTaskContext};\n+        use rt::local_services::unsafe_borrow_local_services;\n+        unsafe {\n+            match context() {\n+                OldTaskContext => {\n+                    OldHandle(rt::rust_get_task())\n+                }\n+                _ => {\n+                    let local_services = unsafe_borrow_local_services();\n+                    NewHandle(&mut local_services.storage)\n+                }\n+            }\n+        }\n+    }\n+}\n \n pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n \n impl Eq for @LocalData {\n     fn eq(&self, other: &@LocalData) -> bool {\n         unsafe {\n-            let ptr_a: (uint, uint) = cast::transmute(*self);\n-            let ptr_b: (uint, uint) = cast::transmute(*other);\n+            let ptr_a: &(uint, uint) = cast::transmute(self);\n+            let ptr_b: &(uint, uint) = cast::transmute(other);\n             return ptr_a == ptr_b;\n         }\n     }\n@@ -39,7 +63,7 @@ type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n         assert!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n@@ -50,8 +74,19 @@ extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map(handle: Handle) -> TaskLocalMap {\n+    match handle {\n+        OldHandle(task) => get_task_local_map(task),\n+        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n+    }\n+}\n+\n unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n+    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n+        cleanup_task_local_map(map_ptr);\n+    }\n+\n     // Relies on the runtime initialising the pointer to null.\n     // Note: The map's box lives in TLS invisibly referenced once. Each time\n     // we retrieve it for get/set, we make another reference, which get/set\n@@ -60,7 +95,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     if map_ptr.is_null() {\n         let map: TaskLocalMap = @mut ~[];\n         rt::rust_set_task_local_data(task, cast::transmute(map));\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n         // Also need to reference it an extra time to keep it for now.\n         let nonmut = cast::transmute::<TaskLocalMap,\n                                        @~[Option<TaskLocalElement>]>(map);\n@@ -75,6 +110,27 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> TaskLocalMap {\n+    match &mut *local {\n+        &LocalStorage(map_ptr, Some(_)) => {\n+            assert!(map_ptr.is_not_null());\n+            let map = cast::transmute(map_ptr);\n+            let nonmut = cast::transmute::<TaskLocalMap,\n+            @~[Option<TaskLocalElement>]>(map);\n+            cast::bump_box_refcount(nonmut);\n+            return map;\n+        }\n+        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+            assert!((*map_ptr).is_null());\n+            let map: TaskLocalMap = @mut ~[];\n+            *map_ptr = cast::transmute(map);\n+            let at_exit_fn: ~fn(*libc::c_void) = |p|cleanup_task_local_map(p);\n+            *at_exit = Some(at_exit_fn);\n+            return map;\n+        }\n+    }\n+}\n+\n unsafe fn key_to_key_value<T:Durable>(key: LocalDataKey<T>) -> *libc::c_void {\n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n@@ -102,10 +158,10 @@ unsafe fn local_data_lookup<T:Durable>(\n }\n \n unsafe fn local_get_helper<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Interpreturn our findings from the map\n     do local_data_lookup(map, key).map |result| {\n         // A reference count magically appears on 'data' out of thin air. It\n@@ -124,31 +180,31 @@ unsafe fn local_get_helper<T:Durable>(\n \n \n pub unsafe fn local_pop<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, true)\n+    local_get_helper(handle, key, true)\n }\n \n pub unsafe fn local_get<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, false)\n+    local_get_helper(handle, key, false)\n }\n \n pub unsafe fn local_set<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>, data: @T) {\n+    handle: Handle, key: LocalDataKey<T>, data: @T) {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n     // We keep the data in two forms: one as an unsafe pointer, so we can get\n     // it back by casting; another in an existential box, so the reference we\n     // own on it can be dropped when the box is destroyed. The unsafe pointer\n     // does not have a reference associated with it, so it may become invalid\n     // when the box is destroyed.\n-    let data_ptr = cast::transmute(data);\n+    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n     let data_box = @data as @LocalData;\n     // Construct new entry to store in the map.\n     let new_entry = Some((keyval, data_ptr, data_box));\n@@ -170,12 +226,12 @@ pub unsafe fn local_set<T:Durable>(\n }\n \n pub unsafe fn local_modify<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(task, key));\n+    let newdata = modify_fn(local_pop(handle, key));\n     if newdata.is_some() {\n-        local_set(task, key, newdata.unwrap());\n+        local_set(handle, key, newdata.unwrap());\n     }\n }"}, {"sha": "ebf2494c8ee5bcc4f1e4d3a9d1a4a3b5686329b8", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -559,8 +559,31 @@ pub fn yield() {\n pub fn failing() -> bool {\n     //! True if the running task has failed\n \n-    unsafe {\n-        rt::rust_task_is_unwinding(rt::rust_get_task())\n+    use rt::{context, OldTaskContext};\n+    use rt::local_services::borrow_local_services;\n+\n+    match context() {\n+        OldTaskContext => {\n+            unsafe {\n+                rt::rust_task_is_unwinding(rt::rust_get_task())\n+            }\n+        }\n+        _ => {\n+            let mut unwinding = false;\n+            do borrow_local_services |local| {\n+                unwinding = match local.unwinder {\n+                    Some(unwinder) => {\n+                        unwinder.unwinding\n+                    }\n+                    None => {\n+                        // Because there is no unwinder we can't be unwinding.\n+                        // (The process will abort on failure)\n+                        false\n+                    }\n+                }\n+            }\n+            return unwinding;\n+        }\n     }\n }\n \n@@ -1194,7 +1217,7 @@ fn test_spawn_thread_on_demand() {\n \n #[test]\n fn test_simple_newsched_spawn() {\n-    use rt::run_in_newsched_task;\n+    use rt::test::run_in_newsched_task;\n \n     do run_in_newsched_task {\n         spawn(||())"}, {"sha": "267250b3642a03706879e1428c37ea6d4d58a384", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -80,7 +80,7 @@ use prelude::*;\n use unstable;\n use ptr;\n use hashmap::HashSet;\n-use task::local_data_priv::{local_get, local_set};\n+use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n use task::rt;\n use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n@@ -451,7 +451,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         /*##################################################################*\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n-        let spawner_group = match local_get(spawner, taskgroup_key!()) {\n+        let spawner_group = match local_get(OldHandle(spawner), taskgroup_key!()) {\n             None => {\n                 // Main task, doing first spawn ever. Lazily initialise here.\n                 let mut members = new_taskset();\n@@ -463,7 +463,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n                     @TCB(spawner, tasks, AncestorList(None), true, None);\n-                local_set(spawner, taskgroup_key!(), group);\n+                local_set(OldHandle(spawner), taskgroup_key!(), group);\n                 group\n             }\n             Some(group) => group\n@@ -627,7 +627,7 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n                 let group = @TCB(child, child_arc, ancestors,\n                                  is_main, notifier);\n                 unsafe {\n-                    local_set(child, taskgroup_key!(), group);\n+                    local_set(OldHandle(child), taskgroup_key!(), group);\n                 }\n \n                 // Run the child's body."}, {"sha": "a8a0d40db1f6202a9c95f33832dc12eef1adc947", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -17,6 +17,8 @@ use str;\n use sys;\n use unstable::exchange_alloc;\n use cast::transmute;\n+use rt::{context, OldTaskContext};\n+use rt::local_services::borrow_local_services;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -88,19 +90,58 @@ pub unsafe fn exchange_free(ptr: *c_char) {\n \n #[lang=\"malloc\"]\n #[inline(always)]\n+#[cfg(stage0)] // For some reason this isn't working on windows in stage0\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_malloc_noswitch(td, size);\n }\n \n+#[lang=\"malloc\"]\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+    match context() {\n+        OldTaskContext => {\n+            return rustrt::rust_upcall_malloc_noswitch(td, size);\n+        }\n+        _ => {\n+            let mut alloc = ::ptr::null();\n+            do borrow_local_services |srv| {\n+                alloc = srv.heap.alloc(td as *c_void, size as uint) as *c_char;\n+            }\n+            return alloc;\n+        }\n+    }\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[lang=\"free\"]\n #[inline(always)]\n+#[cfg(stage0)]\n pub unsafe fn local_free(ptr: *c_char) {\n     rustrt::rust_upcall_free_noswitch(ptr);\n }\n \n+// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n+// inside a landing pad may corrupt the state of the exception handler. If a\n+// problem occurs, call exit instead.\n+#[lang=\"free\"]\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub unsafe fn local_free(ptr: *c_char) {\n+    match context() {\n+        OldTaskContext => {\n+            rustrt::rust_upcall_free_noswitch(ptr);\n+        }\n+        _ => {\n+            do borrow_local_services |srv| {\n+                srv.heap.free(ptr as *c_void);\n+            }\n+        }\n+    }\n+}\n+\n #[lang=\"borrow_as_imm\"]\n #[inline(always)]\n pub unsafe fn borrow_as_imm(a: *u8) {"}, {"sha": "a35c40b852005d50d33943b7a93e186da140da81", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -394,10 +394,15 @@ pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n \n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n-    let mut bcx = bcx;\n-    let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n-    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n-    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n+    let bcx = do with_scope(bcx, None, ~\"visitor cleanup\") |bcx| {\n+        let mut bcx = bcx;\n+        let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n+        let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+        bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n+        // The visitor is a boxed object and needs to be dropped\n+        add_clean(bcx, v, object_ty);\n+        bcx\n+    };\n     build_return(bcx);\n }\n "}, {"sha": "02721a02fbd0c278cda3e56e25116559ce30bffa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -487,7 +487,7 @@ pub fn core_macros() -> ~str {\n \n         { $c:ident: $in:ty -> $out:ty; } => {\n \n-            mod $c {\n+            pub mod $c {\n                 fn key(_x: @::core::condition::Handler<$in,$out>) { }\n \n                 pub static cond :"}, {"sha": "a49b52bffe15366be65ad230daea67387d298585", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -27,11 +27,11 @@ rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n     if (live_allocs) live_allocs->prev = box;\n     live_allocs = box;\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@malloc()=%p with td %p, size %lu==%lu+%lu, \"\n         \"align %lu, prev %p, next %p\\n\",\n         box, td, total_size, sizeof(rust_opaque_box), body_size,\n-        td->align, box->prev, box->next);\n+        td->align, box->prev, box->next);*/\n \n     return box;\n }\n@@ -50,9 +50,9 @@ rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n     if (new_box->next) new_box->next->prev = new_box;\n     if (live_allocs == box) live_allocs = new_box;\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@realloc()=%p with orig=%p, size %lu==%lu+%lu\",\n-        new_box, box, total_size, sizeof(rust_opaque_box), new_size);\n+        new_box, box, total_size, sizeof(rust_opaque_box), new_size);*/\n \n     return new_box;\n }\n@@ -74,15 +74,15 @@ void boxed_region::free(rust_opaque_box *box) {\n     // double frees (kind of).\n     assert(box->td != NULL);\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@free(%p) with td %p, prev %p, next %p\\n\",\n-        box, box->td, box->prev, box->next);\n+        box, box->td, box->prev, box->next);*/\n \n     if (box->prev) box->prev->next = box->next;\n     if (box->next) box->next->prev = box->prev;\n     if (live_allocs == box) live_allocs = box->next;\n \n-    if (env->poison_on_free) {\n+    if (poison_on_free) {\n         memset(box_body(box), 0xab, box->td->size);\n     }\n "}, {"sha": "178772007e51842adabc67d9a307baeecb435ecc", "filename": "src/rt/boxed_region.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fboxed_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fboxed_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.h?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -24,7 +24,7 @@ struct rust_env;\n  * a type descr which describes the payload (what follows the header). */\n class boxed_region {\n private:\n-    rust_env *env;\n+    bool poison_on_free;\n     memory_region *backing_region;\n     rust_opaque_box *live_allocs;\n \n@@ -41,8 +41,8 @@ class boxed_region {\n     boxed_region& operator=(const boxed_region& rhs);\n \n public:\n-    boxed_region(rust_env *e, memory_region *br)\n-        : env(e)\n+    boxed_region(memory_region *br, bool poison_on_free)\n+        : poison_on_free(poison_on_free)\n         , backing_region(br)\n         , live_allocs(NULL)\n     {}"}, {"sha": "f3406712cb01251682fc8331f4122a54f10d4328", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -11,7 +11,6 @@\n \n #include \"sync/sync.h\"\n #include \"memory_region.h\"\n-#include \"rust_env.h\"\n \n #if RUSTRT_TRACK_ALLOCATIONS >= 3\n #include <execinfo.h>\n@@ -35,15 +34,19 @@ void *memory_region::get_data(alloc_header *ptr) {\n     return (void*)((char *)ptr + HEADER_SIZE);\n }\n \n-memory_region::memory_region(rust_env *env, bool synchronized) :\n-    _env(env), _parent(NULL), _live_allocations(0),\n-    _detailed_leaks(env->detailed_leaks),\n+memory_region::memory_region(bool synchronized,\n+                             bool detailed_leaks,\n+                             bool poison_on_free) :\n+    _parent(NULL), _live_allocations(0),\n+    _detailed_leaks(detailed_leaks),\n+    _poison_on_free(poison_on_free),\n     _synchronized(synchronized) {\n }\n \n memory_region::memory_region(memory_region *parent) :\n-    _env(parent->_env), _parent(parent), _live_allocations(0),\n+    _parent(parent), _live_allocations(0),\n     _detailed_leaks(parent->_detailed_leaks),\n+    _poison_on_free(parent->_poison_on_free),\n     _synchronized(parent->_synchronized) {\n }\n \n@@ -241,7 +244,7 @@ memory_region::claim_alloc(void *mem) {\n void\n memory_region::maybe_poison(void *mem) {\n \n-    if (!_env->poison_on_free)\n+    if (!_poison_on_free)\n         return;\n \n #   if RUSTRT_TRACK_ALLOCATIONS >= 1"}, {"sha": "4ad57c11809ccc67ece729980b2d23bc46258ad0", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -54,11 +54,11 @@ class memory_region {\n     inline alloc_header *get_header(void *mem);\n     inline void *get_data(alloc_header *);\n \n-    rust_env *_env;\n     memory_region *_parent;\n     int _live_allocations;\n     array_list<alloc_header *> _allocation_list;\n     const bool _detailed_leaks;\n+    const bool _poison_on_free;\n     const bool _synchronized;\n     lock_and_signal _lock;\n \n@@ -75,7 +75,8 @@ class memory_region {\n     memory_region& operator=(const memory_region& rhs);\n \n public:\n-    memory_region(rust_env *env, bool synchronized);\n+    memory_region(bool synchronized,\n+                  bool detailed_leaks, bool poison_on_free);\n     memory_region(memory_region *parent);\n     void *malloc(size_t size, const char *tag);\n     void *realloc(void *mem, size_t size);"}, {"sha": "8b7b89680fcca24b545523eba01019ce07d0a3d8", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -856,6 +856,63 @@ rust_initialize_global_state() {\n     }\n }\n \n+extern \"C\" CDECL memory_region*\n+rust_new_memory_region(uintptr_t synchronized,\n+                       uintptr_t detailed_leaks,\n+                       uintptr_t poison_on_free) {\n+    return new memory_region((bool)synchronized,\n+                             (bool)detailed_leaks,\n+                             (bool)poison_on_free);\n+}\n+\n+extern \"C\" CDECL void\n+rust_delete_memory_region(memory_region *region) {\n+    delete region;\n+}\n+\n+extern \"C\" CDECL boxed_region*\n+rust_new_boxed_region(memory_region *region,\n+                      uintptr_t poison_on_free) {\n+    return new boxed_region(region, poison_on_free);\n+}\n+\n+extern \"C\" CDECL void\n+rust_delete_boxed_region(boxed_region *region) {\n+    delete region;\n+}\n+\n+extern \"C\" CDECL rust_opaque_box*\n+rust_boxed_region_malloc(boxed_region *region, type_desc *td, size_t size) {\n+    return region->malloc(td, size);\n+}\n+\n+extern \"C\" CDECL void\n+rust_boxed_region_free(boxed_region *region, rust_opaque_box *box) {\n+    region->free(box);\n+}\n+\n+typedef void *(rust_try_fn)(void*, void*);\n+\n+extern \"C\" CDECL uintptr_t\n+rust_try(rust_try_fn f, void *fptr, void *env) {\n+    try {\n+        f(fptr, env);\n+    } catch (uintptr_t token) {\n+        assert(token != 0);\n+        return token;\n+    }\n+    return 0;\n+}\n+\n+extern \"C\" CDECL void\n+rust_begin_unwind(uintptr_t token) {\n+#ifndef __WIN32__\n+    throw token;\n+#else\n+    abort();\n+#endif\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "2911b970b1359ceea5abf246c344754e9abd9903", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -38,7 +38,7 @@ rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n     sched(sched),\n     log_lvl(log_debug),\n     min_stack_size(kernel->env->min_stack_size),\n-    local_region(kernel->env, false),\n+    local_region(false, kernel->env->detailed_leaks, kernel->env->poison_on_free),\n     // FIXME #2891: calculate a per-scheduler name.\n     name(\"main\")\n {"}, {"sha": "7e3c91f62113e532a6899937a5717367667e9ab0", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -36,7 +36,7 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     kernel(sched_loop->kernel),\n     name(name),\n     list_index(-1),\n-    boxed(sched_loop->kernel->env, &local_region),\n+    boxed(&local_region, sched_loop->kernel->env->poison_on_free),\n     local_region(&sched_loop->local_region),\n     unwinding(false),\n     total_stack_sz(0),"}, {"sha": "d82c39d6838ec7f866757d96e24a2034697a34f4", "filename": "src/rt/rust_test_helpers.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_test_helpers.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_test_helpers.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -165,3 +165,14 @@ extern \"C\" CDECL TwoDoubles\n rust_dbg_extern_identity_TwoDoubles(TwoDoubles u) {\n     return u;\n }\n+\n+// Generates increasing port numbers for network testing\n+extern \"C\" CDECL uintptr_t\n+rust_dbg_next_port() {\n+  static lock_and_signal dbg_port_lock;\n+  static uintptr_t next_port = 9600;\n+  scoped_lock with(dbg_port_lock);\n+  uintptr_t this_port = next_port;\n+  next_port += 1;\n+  return this_port;\n+}"}, {"sha": "658fdec6df2c31d2739e74e824b2a86f538ef387", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -293,7 +293,13 @@ upcall_rust_personality(int version,\n     s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n                                     version, actions, exception_class,\n                                     ue_header, context};\n-    rust_task *task = rust_get_current_task();\n+    rust_task *task = rust_try_get_current_task();\n+\n+    if (task == NULL) {\n+        // Assuming we're running with the new scheduler\n+        upcall_s_rust_personality(&args);\n+        return args.retval;\n+    }\n \n     // The personality function is run on the stack of the\n     // last function that threw or landed, which is going\n@@ -330,8 +336,12 @@ upcall_del_stack() {\n // needs to acquire the value of the stack pointer\n extern \"C\" CDECL void\n upcall_reset_stack_limit() {\n-    rust_task *task = rust_get_current_task();\n-    task->reset_stack_limit();\n+    rust_task *task = rust_try_get_current_task();\n+    if (task != NULL) {\n+        task->reset_stack_limit();\n+    } else {\n+        // We must be in a newsched task\n+    }\n }\n \n //"}, {"sha": "3ca05b94711e801832b88d0a8b24678be1493dc6", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6c478c7de889ec4943b9dcdcbfbb8a8244f479cc/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=6c478c7de889ec4943b9dcdcbfbb8a8244f479cc", "patch": "@@ -224,4 +224,12 @@ rust_uv_free_ip4_addr\n rust_uv_free_ip6_addr\n rust_call_nullary_fn\n rust_initialize_global_state\n-\n+rust_dbg_next_port\n+rust_new_memory_region\n+rust_delete_memory_region\n+rust_new_boxed_region\n+rust_delete_boxed_region\n+rust_boxed_region_malloc\n+rust_boxed_region_free\n+rust_try\n+rust_begin_unwind"}]}