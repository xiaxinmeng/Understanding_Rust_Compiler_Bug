{"sha": "ab864ed259c10ff51f7c9c3421d098eeea7b0245", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiODY0ZWQyNTljMTBmZjUxZjdjOWMzNDIxZDA5OGVlZWE3YjAyNDU=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-07T15:58:05Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-07T15:58:05Z"}, "message": "feat: add attributes support on struct fields #3870\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "a6451a9ddd7774d02974cc1dca6fbf76c8d4bb1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6451a9ddd7774d02974cc1dca6fbf76c8d4bb1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab864ed259c10ff51f7c9c3421d098eeea7b0245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab864ed259c10ff51f7c9c3421d098eeea7b0245", "html_url": "https://github.com/rust-lang/rust/commit/ab864ed259c10ff51f7c9c3421d098eeea7b0245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab864ed259c10ff51f7c9c3421d098eeea7b0245/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d688d13070a54b288486900a30680d013c66ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d688d13070a54b288486900a30680d013c66ca", "html_url": "https://github.com/rust-lang/rust/commit/f6d688d13070a54b288486900a30680d013c66ca"}], "stats": {"total": 78, "additions": 71, "deletions": 7}, "files": [{"sha": "8527a6cad4752301cbab2bd09428032997452a63", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=ab864ed259c10ff51f7c9c3421d098eeea7b0245", "patch": "@@ -4,17 +4,19 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{AsName, Name},\n     InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n+use ra_cfg::CfgOptions;\n use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef,\n-    visibility::RawVisibility, EnumId, LocalEnumVariantId, LocalStructFieldId, Lookup, StructId,\n-    UnionId, VariantId,\n+    attr::Attrs, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n+    type_ref::TypeRef, visibility::RawVisibility, EnumId, LocalEnumVariantId, LocalStructFieldId,\n+    Lookup, StructId, UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -49,11 +51,14 @@ pub struct StructFieldData {\n     pub name: Name,\n     pub type_ref: TypeRef,\n     pub visibility: RawVisibility,\n+    pub attrs: Attrs,\n+    // TODO: add attributes\n }\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let src = id.lookup(db).source(db);\n+\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n         let variant_data = Arc::new(variant_data);\n@@ -181,6 +186,10 @@ pub enum StructKind {\n     Unit,\n }\n \n+fn is_cfg_enabled(cfg_options: &CfgOptions, attrs: &Attrs) -> bool {\n+    attrs.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+}\n+\n fn lower_struct(\n     db: &dyn DefDatabase,\n     trace: &mut Trace<StructFieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n@@ -189,25 +198,41 @@ fn lower_struct(\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+\n+                // Need verification about parent cfg_options and current with current attributes\n+                // If it is we are in a case where the cfg is not enabled then we don't have to add this field to check\n+                // if !is_cfg_enabled(&crate_graph[module_id.krate].cfg_options, &attrs) {\n+                //     continue;\n+                // }\n+\n                 trace.alloc(\n                     || Either::Left(fd.clone()),\n                     || StructFieldData {\n                         name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n+                        attrs: Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id)),\n                     },\n                 );\n             }\n             StructKind::Tuple\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+                // Need verification about parent cfg_options and current with current attributes\n+                // If it is we are in a case where the cfg is not enabled then we don't have to add this field to check\n+                // if !is_cfg_enabled(&crate_graph[module_id.krate].cfg_options, &attrs) {\n+                //     continue;\n+                // }\n                 trace.alloc(\n                     || Either::Right(fd.clone()),\n                     || StructFieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n+                        attrs: Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id)),\n                     },\n                 );\n             }"}, {"sha": "934c3b94ea36075a3db34615eea5a5270fc4f9ad", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=ab864ed259c10ff51f7c9c3421d098eeea7b0245", "patch": "@@ -3,6 +3,7 @@\n use std::sync::Arc;\n \n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     AstId, InFile,\n };\n@@ -12,6 +13,7 @@ use ra_syntax::ast::{\n };\n \n use crate::{\n+    attr::Attrs,\n     db::DefDatabase,\n     path::{path, GenericArgs, Path},\n     src::HasSource,\n@@ -26,6 +28,7 @@ pub struct FunctionData {\n     pub name: Name,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n+    pub attrs: Attrs,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n@@ -63,6 +66,7 @@ impl FunctionData {\n                 params.push(type_ref);\n             }\n         }\n+        let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n         let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n             TypeRef::from_ast(type_ref)\n         } else {\n@@ -81,7 +85,7 @@ impl FunctionData {\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param, visibility };\n+        let sig = FunctionData { name, params, ret_type, has_self_param, visibility, attrs };\n         Arc::new(sig)\n     }\n }"}, {"sha": "eb1209d08bf76fcc4adc19fd48a52cf643943959", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=ab864ed259c10ff51f7c9c3421d098eeea7b0245", "patch": "@@ -8,8 +8,7 @@ use hir_def::{\n     AdtId, FunctionId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n-use ra_syntax::ast;\n-use ra_syntax::AstPtr;\n+use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -82,7 +81,14 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let variant_data = variant_data(db.upcast(), variant_def);\n \n-        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+        let lit_fields: FxHashSet<_> = fields\n+            .iter()\n+            .filter_map(|f| {\n+                // TODO: check if cfg_is_enabled with .attrs ?\n+\n+                Some(&f.name)\n+            })\n+            .collect();\n         let missed_fields: Vec<Name> = variant_data\n             .fields()\n             .iter()"}, {"sha": "c3d793cc290c268f829caf7835d88a4d38790d8e", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab864ed259c10ff51f7c9c3421d098eeea7b0245/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=ab864ed259c10ff51f7c9c3421d098eeea7b0245", "patch": "@@ -318,3 +318,32 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs\n+        struct MyStruct {\n+            my_val: usize,\n+            #[cfg(feature = \"foo\")]\n+            bar: bool,\n+        }\n+\n+        impl MyStruct {\n+            #[cfg(feature = \"foo\")]\n+            pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+                Self { my_val, bar }\n+            }\n+\n+            #[cfg(not(feature = \"foo\"))]\n+            pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+                Self { my_val }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot!(diagnostics, \"\");\n+}"}]}