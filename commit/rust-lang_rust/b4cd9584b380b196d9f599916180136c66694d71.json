{"sha": "b4cd9584b380b196d9f599916180136c66694d71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0Y2Q5NTg0YjM4MGIxOTZkOWY1OTk5MTYxODAxMzZjNjY2OTRkNzE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-23T02:20:29Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-23T03:51:32Z"}, "message": "Implement combining for tuple and block", "tree": {"sha": "1a3ffa8400acb0c5d681650fd308a9dbe2b5fbb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a3ffa8400acb0c5d681650fd308a9dbe2b5fbb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4cd9584b380b196d9f599916180136c66694d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4cd9584b380b196d9f599916180136c66694d71", "html_url": "https://github.com/rust-lang/rust/commit/b4cd9584b380b196d9f599916180136c66694d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4cd9584b380b196d9f599916180136c66694d71/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c15204f0c4a0b0d5f97460a23f10fa090f5aef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c15204f0c4a0b0d5f97460a23f10fa090f5aef9", "html_url": "https://github.com/rust-lang/rust/commit/2c15204f0c4a0b0d5f97460a23f10fa090f5aef9"}], "stats": {"total": 338, "additions": 221, "deletions": 117}, "files": [{"sha": "bfd38f86c623f7385506def85128d7cbc2cf2ba2", "filename": "src/expr.rs", "status": "modified", "additions": 156, "deletions": 92, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -96,9 +96,7 @@ fn format_expr(expr: &ast::Expr,\n                                expr.span,\n                                shape)\n         }\n-        ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context, items.iter().map(|x| &**x), expr.span, shape)\n-        }\n+        ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n         ast::ExprKind::While(ref cond, ref block, label) => {\n             ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n         }\n@@ -1345,7 +1343,9 @@ impl Rewrite for ast::Arm {\n                 }\n             }\n             ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n-            ast::ExprKind::Closure(..) => (true, &**body),\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Tup(..) => (true, &**body),\n             _ => (false, &**body),\n         };\n         extend &= context.config.fn_call_style() == IndentStyle::Block;\n@@ -1612,8 +1612,9 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n                        -> Option<String>\n     where R: Rewrite\n {\n-    let closure =\n-        |callee_max_width| rewrite_call_inner(context, callee, callee_max_width, args, span, shape);\n+    let closure = |callee_max_width| {\n+        rewrite_call_inner(context, callee, callee_max_width, args, span, shape, false)\n+    };\n \n     binary_search(1, shape.width, closure)\n }\n@@ -1623,7 +1624,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                          max_callee_width: usize,\n                          args: &[ptr::P<ast::Expr>],\n                          span: Span,\n-                         shape: Shape)\n+                         shape: Shape,\n+                         force_trailing_comma: bool)\n                          -> Result<String, Ordering>\n     where R: Rewrite\n {\n@@ -1649,80 +1651,40 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .checked_sub(used_width + 2 * paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n-    // Try combining openings and closings\n-    if args.len() == 1 && context.config.fn_call_style() == IndentStyle::Block {\n-        let expr = &*args[0];\n-        match expr.node {\n-            ast::ExprKind::Struct(..) |\n-            ast::ExprKind::Call(..) |\n-            ast::ExprKind::Closure(..) => {\n-                let max_width = min(one_line_width, context.config.fn_call_width());\n-                let shape = Shape::legacy(max_width, shape.block().indent);\n-                if let Some(expr_str) = expr.rewrite(context, shape) {\n-                    if first_line_width(&expr_str) <= max_width {\n-                        return Ok(format!(\"{}({})\", callee_str, expr_str));\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-    }\n-\n-    let nested_shape = match context.config.fn_call_style() {\n-            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces()),\n-            IndentStyle::Visual => {\n-                shape\n-                    .visual_indent(used_width + paren_overhead)\n-                    .sub_width(used_width + 2 * paren_overhead)\n-            }\n-        }\n-        .ok_or(Ordering::Greater)?;\n+    let nested_shape = shape_from_fn_call_style(context,\n+                                                shape,\n+                                                used_width + 2 * paren_overhead,\n+                                                used_width + paren_overhead)\n+            .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n     let span = mk_sp(span_lo, span.hi);\n \n-    let list_str = rewrite_call_args(context, args, span, nested_shape, one_line_width)\n-        .ok_or(Ordering::Less)?;\n-\n+    let list_str = rewrite_call_args(context,\n+                                     args,\n+                                     span,\n+                                     nested_shape,\n+                                     one_line_width,\n+                                     force_trailing_comma)\n+            .ok_or(Ordering::Less)?;\n     let arg_one_line_budget = min(one_line_width, context.config.fn_call_width());\n-    let result = if context.config.fn_call_style() == IndentStyle::Visual ||\n-                    (((can_be_overflowed(args) &&\n-                       first_line_width(&list_str) <= arg_one_line_budget) ||\n-                      !list_str.contains('\\n')) &&\n-                     list_str.chars().last().unwrap_or(' ') != ',') {\n-        if context.config.spaces_within_parens() && list_str.len() > 0 {\n-            format!(\"{}( {} )\", callee_str, list_str)\n-        } else {\n-            format!(\"{}({})\", callee_str, list_str)\n-        }\n-    } else {\n-        format!(\"{}(\\n{}{}\\n{})\",\n-                callee_str,\n-                nested_shape.indent.to_string(context.config),\n-                list_str,\n-                shape.block().indent.to_string(context.config))\n-    };\n-\n-    Ok(result)\n-}\n-\n-fn can_be_overflowed(args: &[ptr::P<ast::Expr>]) -> bool {\n-    match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Closure(..)) |\n-        Some(&ast::ExprKind::Block(..)) |\n-        Some(&ast::ExprKind::Match(..)) if args.len() > 1 => true,\n-        _ => false,\n-    }\n+    Ok(format!(\"{}{}\",\n+               callee_str,\n+               wrap_args_with_parens(context,\n+                                     &list_str,\n+                                     is_extendable(args),\n+                                     arg_one_line_budget,\n+                                     shape,\n+                                     nested_shape)))\n }\n \n fn rewrite_call_args(context: &RewriteContext,\n                      args: &[ptr::P<ast::Expr>],\n                      span: Span,\n                      shape: Shape,\n-                     one_line_width: usize)\n+                     one_line_width: usize,\n+                     force_trailing_comma: bool)\n                      -> Option<String> {\n-    let arg_count = args.len();\n-\n     let items = itemize_list(context.codemap,\n                              args.iter(),\n                              \")\",\n@@ -1736,31 +1698,32 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let overflow_last = can_be_overflowed(args);\n+    let overflow_last = can_be_overflowed(context, args);\n \n     let mut orig_last = None;\n     let mut placeholder = None;\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let last_arg = args.last().unwrap();\n-        let arg_shape = match last_arg.node {\n-            ast::ExprKind::Closure(..) if context.config.fn_call_style() == IndentStyle::Block => {\n-                let mut arg_shape = shape.block();\n-                arg_shape.indent.block_indent -= context.config.tab_spaces();\n-                arg_shape\n+        let arg_shape = if context.config.fn_call_style() == IndentStyle::Block &&\n+                           is_extendable(args) {\n+            Shape {\n+                width: context.config.fn_call_width(),\n+                indent: shape.block().indent.block_unindent(context.config),\n+                offset: 0,\n             }\n-            _ => shape.block(),\n+        } else {\n+            shape.block()\n         };\n         let rewrite = args.last().unwrap().rewrite(context, arg_shape);\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n             placeholder = Some(rewrite);\n \n-            swap(&mut item_vec[arg_count - 1].item, &mut orig_last);\n-            item_vec[arg_count - 1].item = rewrite_first_line;\n+            swap(&mut item_vec[args.len() - 1].item, &mut orig_last);\n+            item_vec[args.len() - 1].item = rewrite_first_line;\n         }\n     }\n \n@@ -1778,20 +1741,21 @@ fn rewrite_call_args(context: &RewriteContext,\n     // succeeded and its first line fits with the other arguments.\n     match (overflow_last, tactic, placeholder) {\n         (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n-            item_vec[arg_count - 1].item = placeholder;\n+            item_vec[args.len() - 1].item = placeholder;\n         }\n         (true, _, _) => {\n-            item_vec[arg_count - 1].item = orig_last;\n+            item_vec[args.len() - 1].item = orig_last;\n         }\n         (false, _, _) => {}\n     }\n \n     let mut fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n-        trailing_separator: if context.inside_macro ||\n-                               context.config.fn_call_style() == IndentStyle::Visual ||\n-                               arg_count <= 1 {\n+        trailing_separator: if force_trailing_comma {\n+            SeparatorTactic::Always\n+        } else if context.inside_macro || context.config.fn_call_style() == IndentStyle::Visual ||\n+                  args.len() <= 1 {\n             SeparatorTactic::Never\n         } else {\n             context.config.trailing_comma()\n@@ -1807,15 +1771,81 @@ fn rewrite_call_args(context: &RewriteContext,\n         // and not rewriting macro.\n         Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n                        !context.inside_macro &&\n-                       (!s.contains('\\n') &&\n-                        (s.len() > one_line_width || s.len() > context.config.fn_call_width())) => {\n+                       (first_line_width(s) > one_line_width ||\n+                        first_line_width(s) > context.config.fn_call_width()) => {\n             fmt.trailing_separator = SeparatorTactic::Vertical;\n             write_list(&item_vec, &fmt)\n         }\n         rewrite @ _ => rewrite,\n     }\n }\n \n+fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n+    match args.last().map(|x| &x.node) {\n+        Some(&ast::ExprKind::Block(..)) |\n+        Some(&ast::ExprKind::Match(..)) => {\n+            (context.config.fn_call_style() == IndentStyle::Block && args.len() == 1) ||\n+            (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n+        }\n+        Some(&ast::ExprKind::Closure(..)) => {\n+            context.config.fn_call_style() == IndentStyle::Block ||\n+            context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n+        }\n+        Some(&ast::ExprKind::Call(..)) |\n+        Some(&ast::ExprKind::Struct(..)) => {\n+            context.config.fn_call_style() == IndentStyle::Block && args.len() == 1\n+        }\n+        Some(&ast::ExprKind::Tup(..)) => context.config.fn_call_style() == IndentStyle::Block,\n+        _ => false,\n+    }\n+}\n+\n+fn is_extendable(args: &[ptr::P<ast::Expr>]) -> bool {\n+    if args.len() == 1 {\n+        match args[0].node {\n+            ast::ExprKind::Block(..) |\n+            ast::ExprKind::Call(..) |\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Match(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Tup(..) => true,\n+            _ => false,\n+        }\n+    } else if args.len() > 1 {\n+        match args[args.len() - 1].node {\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Tup(..) => true,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn wrap_args_with_parens(context: &RewriteContext,\n+                         args_str: &str,\n+                         is_extendable: bool,\n+                         one_line_budget: usize,\n+                         shape: Shape,\n+                         nested_shape: Shape)\n+                         -> String {\n+    if context.config.fn_call_style() == IndentStyle::Visual ||\n+       (context.inside_macro && !args_str.contains('\\n')) ||\n+       ((is_extendable || !args_str.contains('\\n')) &&\n+        first_line_width(&args_str) <= one_line_budget) {\n+        if context.config.spaces_within_parens() && args_str.len() > 0 {\n+            format!(\"( {} )\", args_str)\n+        } else {\n+            format!(\"({})\", args_str)\n+        }\n+    } else {\n+        format!(\"(\\n{}{}\\n{})\",\n+                nested_shape.indent.to_string(context.config),\n+                args_str,\n+                shape.block().indent.to_string(context.config))\n+    }\n+}\n+\n fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) -> Option<String> {\n     debug!(\"rewrite_paren, shape: {:?}\", shape);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n@@ -1995,17 +2025,28 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n     }\n }\n \n-pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n-                            mut items: I,\n-                            span: Span,\n-                            shape: Shape)\n-                            -> Option<String>\n+fn shape_from_fn_call_style(context: &RewriteContext,\n+                            shape: Shape,\n+                            overhead: usize,\n+                            offset: usize)\n+                            -> Option<Shape> {\n+    match context.config.fn_call_style() {\n+        IndentStyle::Block => Some(shape.block().block_indent(context.config.tab_spaces())),\n+        IndentStyle::Visual => shape.visual_indent(offset).sub_width(overhead),\n+    }\n+}\n+\n+pub fn rewrite_tuple_type<'a, I>(context: &RewriteContext,\n+                                 mut items: I,\n+                                 span: Span,\n+                                 shape: Shape)\n+                                 -> Option<String>\n     where I: ExactSizeIterator,\n           <I as Iterator>::Item: Deref,\n           <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n {\n-    debug!(\"rewrite_tuple {:?}\", shape);\n     // In case of length 1, need a trailing comma\n+    debug!(\"rewrite_tuple_type {:?}\", shape);\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n@@ -2039,6 +2080,29 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     }\n }\n \n+pub fn rewrite_tuple(context: &RewriteContext,\n+                     items: &[ptr::P<ast::Expr>],\n+                     span: Span,\n+                     shape: Shape)\n+                     -> Option<String> {\n+    debug!(\"rewrite_tuple {:?}\", shape);\n+    // Use old `rewrite_tuple`\n+    if context.config.fn_call_style() == IndentStyle::Visual {\n+        return rewrite_tuple_type(context, items.iter().map(|x| &**x), span, shape);\n+    }\n+\n+    // We use the same rule as funcation call for rewriting tuple with multiple expressions.\n+    // 1 = \",\"\n+    rewrite_call_inner(context,\n+                       &String::new(),\n+                       shape.width.checked_sub(1).unwrap_or(0),\n+                       items,\n+                       span,\n+                       shape,\n+                       items.len() == 1)\n+            .ok()\n+}\n+\n pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         prefix: &str,\n                                         rewrite: &R,"}, {"sha": "8f99be11d1a8b0608fdd99902293fe56120b95ab", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -22,7 +22,7 @@ use codemap::SpanUtils;\n use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, format_mutability, colon_spaces, wrap_str};\n-use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n+use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple_type};\n use config::TypeDensity;\n use itertools::Itertools;\n \n@@ -662,7 +662,7 @@ impl Rewrite for ast::Ty {\n                          })\n             }\n             ast::TyKind::Tup(ref items) => {\n-                rewrite_tuple(context, items.iter().map(|x| &**x), self.span, shape)\n+                rewrite_tuple_type(context, items.iter().map(|x| &**x), self.span, shape)\n             }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)"}, {"sha": "664d538fbb9bb707f3bdf1be2405ca420dc4f67d", "filename": "src/utils.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -299,29 +299,32 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n     {\n         let snippet = s.as_ref();\n \n-        if !snippet.contains('\\n') && snippet.len() > shape.width {\n-            return None;\n-        } else {\n-            let mut lines = snippet.lines();\n-\n-            // The caller of this function has already placed `shape.offset`\n-            // characters on the first line.\n-            let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n-            if lines.next().unwrap().len() > first_line_max_len {\n+        if !snippet.is_empty() {\n+            if !snippet.contains('\\n') && snippet.len() > shape.width {\n                 return None;\n-            }\n+            } else {\n+                let mut lines = snippet.lines();\n+\n+                // The caller of this function has already placed `shape.offset`\n+                // characters on the first line.\n+                let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n+                if lines.next().unwrap().len() > first_line_max_len {\n+                    return None;\n+                }\n \n-            // The other lines must fit within the maximum width.\n-            if lines.any(|line| line.len() > max_width) {\n-                return None;\n-            }\n+                // The other lines must fit within the maximum width.\n+                if lines.any(|line| line.len() > max_width) {\n+                    return None;\n+                }\n \n-            // `width` is the maximum length of the last line, excluding\n-            // indentation.\n-            // A special check for the last line, since the caller may\n-            // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > shape.indent.width() + shape.width {\n-                return None;\n+                // `width` is the maximum length of the last line, excluding\n+                // indentation.\n+                // A special check for the last line, since the caller may\n+                // place trailing characters on this line.\n+                if snippet.lines().rev().next().unwrap().len() >\n+                   shape.indent.width() + shape.width {\n+                    return None;\n+                }\n             }\n         }\n     }"}, {"sha": "14207b5adb943360ba958616444cee3f3068b293", "filename": "tests/source/expr-block.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/tests%2Fsource%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/tests%2Fsource%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-block.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -152,6 +152,22 @@ fn combine_block() {\n         },\n     );\n \n+    foo((Bar {\n+        x: value,\n+        y: value2,\n+    },));\n+\n+    foo((1, 2, 3, Bar {\n+        x: value,\n+        y: value2,\n+    }));\n+\n+    foo((1, 2, 3, |x| {\n+        let y = x + 1;\n+        let z = y + 1;\n+        z\n+    }));\n+\n     let opt = Some(\n         Struct(\n             long_argument_one,"}, {"sha": "af8238defe6b4dfd7fc3333e8a547457e4d474e5", "filename": "tests/target/configs-fn_call_style-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -13,9 +13,9 @@ fn main() {\n         \"elit\",\n     );\n     // #1501\n-    let hyper = Arc::new(Client::with_connector(HttpsConnector::new(\n-        TlsClient::new(),\n-    )));\n+    let hyper = Arc::new(Client::with_connector(\n+        HttpsConnector::new(TlsClient::new()),\n+    ));\n }\n \n // #1521"}, {"sha": "6e4d2f109ac0f244d4bdd9ca4bb8116c2218963b", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b4cd9584b380b196d9f599916180136c66694d71/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4cd9584b380b196d9f599916180136c66694d71/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=b4cd9584b380b196d9f599916180136c66694d71", "patch": "@@ -220,6 +220,27 @@ fn combine_block() {\n         y: value2,\n     });\n \n+    foo((Bar {\n+        x: value,\n+        y: value2,\n+    },));\n+\n+    foo((\n+        1,\n+        2,\n+        3,\n+        Bar {\n+            x: value,\n+            y: value2,\n+        },\n+    ));\n+\n+    foo((1, 2, 3, |x| {\n+        let y = x + 1;\n+        let z = y + 1;\n+        z\n+    }));\n+\n     let opt = Some(Struct(\n         long_argument_one,\n         long_argument_two,"}]}