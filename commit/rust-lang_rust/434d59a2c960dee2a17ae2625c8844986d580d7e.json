{"sha": "434d59a2c960dee2a17ae2625c8844986d580d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNGQ1OWEyYzk2MGRlZTJhMTdhZTI2MjVjODg0NDk4NmQ1ODBkN2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-08T00:02:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-10T02:21:24Z"}, "message": "ignore the point where the outlives requirement was added", "tree": {"sha": "d1bb1034d1e2be251611893bdecc266cae46bcb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1bb1034d1e2be251611893bdecc266cae46bcb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/434d59a2c960dee2a17ae2625c8844986d580d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/434d59a2c960dee2a17ae2625c8844986d580d7e", "html_url": "https://github.com/rust-lang/rust/commit/434d59a2c960dee2a17ae2625c8844986d580d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/434d59a2c960dee2a17ae2625c8844986d580d7e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964e0691be3262d4864aa5d97e9dd6cecf806484", "url": "https://api.github.com/repos/rust-lang/rust/commits/964e0691be3262d4864aa5d97e9dd6cecf806484", "html_url": "https://github.com/rust-lang/rust/commit/964e0691be3262d4864aa5d97e9dd6cecf806484"}], "stats": {"total": 531, "additions": 122, "deletions": 409}, "files": [{"sha": "a22dd1fececea5024fe76d917ad85c20d249f425", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=434d59a2c960dee2a17ae2625c8844986d580d7e", "patch": "@@ -326,7 +326,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// True if `sub` is a subset of `sup`\n-    pub fn subset(&self, sub: R, sup: R) -> bool {\n+    pub fn is_subset(&self, sub: R, sup: R) -> bool {\n         sub == sup || {\n             let bit_set_sub = &self.vector[sub];\n             let bit_set_sup = &self.vector[sup];"}, {"sha": "f68394d6149818833bc862f9854d233eceb191f9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/964e0691be3262d4864aa5d97e9dd6cecf806484/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964e0691be3262d4864aa5d97e9dd6cecf806484/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=964e0691be3262d4864aa5d97e9dd6cecf806484", "patch": "@@ -1,265 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Module defining the `dfs` method on `RegionInferenceContext`, along with\n-//! its associated helper traits.\n-\n-use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueElements,\n-                                              RegionValues};\n-use syntax::codemap::Span;\n-use rustc::mir::{Location, Mir};\n-use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n-\n-pub(super) struct DfsStorage {\n-    stack: Vec<Location>,\n-    visited: BitVector,\n-}\n-\n-impl<'tcx> RegionInferenceContext<'tcx> {\n-    /// Creates dfs storage for use by dfs; this should be shared\n-    /// across as many calls to dfs as possible to amortize allocation\n-    /// costs.\n-    pub(super) fn new_dfs_storage(&self) -> DfsStorage {\n-        let num_elements = self.elements.num_elements();\n-        DfsStorage {\n-            stack: vec![],\n-            visited: BitVector::new(num_elements),\n-        }\n-    }\n-\n-    /// Function used to satisfy or test a `R1: R2 @ P`\n-    /// constraint. The core idea is that it performs a DFS starting\n-    /// from `P`. The precise actions *during* that DFS depend on the\n-    /// `op` supplied, so see (e.g.) `CopyFromSourceToTarget` for more\n-    /// details.\n-    ///\n-    /// Returns:\n-    ///\n-    /// - `Ok(true)` if the walk was completed and something changed\n-    ///   along the way;\n-    /// - `Ok(false)` if the walk was completed with no changes;\n-    /// - `Err(early)` if the walk was existed early by `op`. `earlyelem` is the\n-    ///   value that `op` returned.\n-    #[inline(never)] // ensure dfs is identifiable in profiles\n-    pub(super) fn dfs<C>(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        dfs: &mut DfsStorage,\n-        mut op: C,\n-    ) -> Result<bool, C::Early>\n-    where\n-        C: DfsOp,\n-    {\n-        let mut changed = false;\n-\n-        dfs.visited.clear();\n-        dfs.stack.push(op.start_point());\n-        while let Some(p) = dfs.stack.pop() {\n-            let point_index = self.elements.index(p);\n-\n-            if !op.source_region_contains(point_index) {\n-                debug!(\"            not in from-region\");\n-                continue;\n-            }\n-\n-            if !dfs.visited.insert(point_index.index()) {\n-                debug!(\"            already visited\");\n-                continue;\n-            }\n-\n-            let new = op.add_to_target_region(point_index)?;\n-            changed |= new;\n-\n-            let block_data = &mir[p.block];\n-\n-            let start_stack_len = dfs.stack.len();\n-\n-            if p.statement_index < block_data.statements.len() {\n-                dfs.stack.push(Location {\n-                    statement_index: p.statement_index + 1,\n-                    ..p\n-                });\n-            } else {\n-                dfs.stack.extend(\n-                    block_data\n-                        .terminator()\n-                        .successors()\n-                        .map(|&basic_block| Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }),\n-                );\n-            }\n-\n-            if dfs.stack.len() == start_stack_len {\n-                // If we reach the END point in the graph, then copy\n-                // over any skolemized end points in the `from_region`\n-                // and make sure they are included in the `to_region`.\n-                changed |= op.add_universal_regions_outlived_by_source_to_target()?;\n-            }\n-        }\n-\n-        Ok(changed)\n-    }\n-}\n-\n-/// Customizes the operation of the `dfs` function. This function is\n-/// used during inference to satisfy a `R1: R2 @ P` constraint.\n-pub(super) trait DfsOp {\n-    /// If this op stops the walk early, what type does it propagate?\n-    type Early;\n-\n-    /// Returns the point from which to start the DFS.\n-    fn start_point(&self) -> Location;\n-\n-    /// Returns true if the source region contains the given point.\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool;\n-\n-    /// Adds the given point to the target region, returning true if\n-    /// something has changed. Returns `Err` if we should abort the\n-    /// walk early.\n-    fn add_to_target_region(\n-        &mut self,\n-        point_index: RegionElementIndex,\n-    ) -> Result<bool, Self::Early>;\n-\n-    /// Adds all universal regions in the source region to the target region, returning\n-    /// true if something has changed.\n-    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, Self::Early>;\n-}\n-\n-/// Used during inference to enforce a `R1: R2 @ P` constraint.  For\n-/// each point Q we reach along the DFS, we check if Q is in R2 (the\n-/// \"source region\"). If not, we stop the walk. Otherwise, we add Q to\n-/// R1 (the \"target region\") and continue to Q's successors. If we\n-/// reach the end of the graph, then we add any universal regions from\n-/// R2 into R1.\n-pub(super) struct CopyFromSourceToTarget<'v> {\n-    pub source_region: RegionVid,\n-    pub target_region: RegionVid,\n-    pub inferred_values: &'v mut RegionValues,\n-    pub constraint_point: Location,\n-    pub constraint_span: Span,\n-}\n-\n-impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n-    /// We never stop the walk early.\n-    type Early = !;\n-\n-    fn start_point(&self) -> Location {\n-        self.constraint_point\n-    }\n-\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n-        self.inferred_values\n-            .contains(self.source_region, point_index)\n-    }\n-\n-    fn add_to_target_region(&mut self, point_index: RegionElementIndex) -> Result<bool, !> {\n-        Ok(self.inferred_values.add_due_to_outlives(\n-            self.source_region,\n-            self.target_region,\n-            point_index,\n-            self.constraint_point,\n-            self.constraint_span,\n-        ))\n-    }\n-\n-    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, !> {\n-        Ok(self.inferred_values.add_universal_regions_outlived_by(\n-            self.source_region,\n-            self.target_region,\n-            self.constraint_point,\n-            self.constraint_span,\n-        ))\n-    }\n-}\n-\n-/// Used after inference to *test* a `R1: R2 @ P` constraint.  For\n-/// each point Q we reach along the DFS, we check if Q in R2 is also\n-/// contained in R1. If not, we abort the walk early with an `Err`\n-/// condition. Similarly, if we reach the end of the graph and find\n-/// that R1 contains some universal region that R2 does not contain,\n-/// we abort the walk early.\n-pub(super) struct TestTargetOutlivesSource<'v, 'tcx: 'v> {\n-    pub source_region: RegionVid,\n-    pub target_region: RegionVid,\n-    pub elements: &'v RegionValueElements,\n-    pub universal_regions: &'v UniversalRegions<'tcx>,\n-    pub inferred_values: &'v RegionValues,\n-    pub constraint_point: Location,\n-}\n-\n-impl<'v, 'tcx> DfsOp for TestTargetOutlivesSource<'v, 'tcx> {\n-    /// The element that was not found within R2.\n-    type Early = RegionElementIndex;\n-\n-    fn start_point(&self) -> Location {\n-        self.constraint_point\n-    }\n-\n-    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n-        self.inferred_values\n-            .contains(self.source_region, point_index)\n-    }\n-\n-    fn add_to_target_region(\n-        &mut self,\n-        point_index: RegionElementIndex,\n-    ) -> Result<bool, RegionElementIndex> {\n-        if !self.inferred_values\n-            .contains(self.target_region, point_index)\n-        {\n-            return Err(point_index);\n-        }\n-\n-        Ok(false)\n-    }\n-\n-    fn add_universal_regions_outlived_by_source_to_target(\n-        &mut self,\n-    ) -> Result<bool, RegionElementIndex> {\n-        // For all `ur_in_source` in `source_region`.\n-        for ur_in_source in self.inferred_values\n-            .universal_regions_outlived_by(self.source_region)\n-        {\n-            // Check that `target_region` outlives `ur_in_source`.\n-\n-            // If `ur_in_source` is a member of `target_region`, OK.\n-            //\n-            // (This is implied by the loop below, actually, just an\n-            // irresistible micro-opt. Mm. Premature optimization. So\n-            // tasty.)\n-            if self.inferred_values\n-                .contains(self.target_region, ur_in_source)\n-            {\n-                continue;\n-            }\n-\n-            // If there is some other element X such that `target_region: X` and\n-            // `X: ur_in_source`, OK.\n-            if self.inferred_values\n-                .universal_regions_outlived_by(self.target_region)\n-                .any(|ur_in_target| self.universal_regions.outlives(ur_in_target, ur_in_source))\n-            {\n-                continue;\n-            }\n-\n-            // Otherwise, not known to be true.\n-            return Err(self.elements.index(ur_in_source));\n-        }\n-\n-        Ok(false)\n-    }\n-}"}, {"sha": "2fdb7d63cb5dfe69d6970185b6f11ca137c087ec", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 53, "deletions": 81, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=434d59a2c960dee2a17ae2625c8844986d580d7e", "patch": "@@ -11,15 +11,17 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n+use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n-use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos};\n-use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Local, Location, Mir};\n+use rustc::mir::{\n+    ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n+    Mir,\n+};\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n@@ -31,8 +33,6 @@ use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n-mod dfs;\n-use self::dfs::{CopyFromSourceToTarget, TestTargetOutlivesSource};\n mod dump_mir;\n mod graphviz;\n mod values;\n@@ -422,9 +422,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n \n-        let dfs_storage = &mut self.new_dfs_storage();\n-\n-        self.propagate_constraints(mir, dfs_storage);\n+        self.propagate_constraints(mir);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -437,13 +435,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(\n-            infcx,\n-            mir,\n-            dfs_storage,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-        );\n+        self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n         self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n \n@@ -464,18 +456,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>, dfs_storage: &mut dfs::DfsStorage) {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n         self.dependency_map = Some(self.build_dependency_map());\n-        let inferred_values = self.compute_region_values(mir, dfs_storage);\n+        let inferred_values = self.compute_region_values(mir);\n         self.inferred_values = Some(inferred_values);\n     }\n \n     #[inline(never)] // ensure dfs is identifiable in profiles\n-    fn compute_region_values(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n-    ) -> RegionValues {\n+    fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n@@ -502,21 +490,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let constraint = &self.constraints[constraint_idx];\n             debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n-            // Grow the value as needed to accommodate the\n-            // outlives constraint.\n-            let Ok(made_changes) = self.dfs(\n-                mir,\n-                dfs_storage,\n-                CopyFromSourceToTarget {\n-                    source_region: constraint.sub,\n-                    target_region: constraint.sup,\n-                    inferred_values: &mut inferred_values,\n-                    constraint_point: constraint.point,\n-                    constraint_span: constraint.span,\n-                },\n-            );\n-\n-            if made_changes {\n+            if inferred_values.add_region(constraint.sup, constraint.sub) {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n@@ -561,7 +535,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -570,13 +543,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(\n-                mir,\n-                dfs_storage,\n-                type_test.point,\n-                type_test.lower_bound,\n-                &type_test.test,\n-            ) {\n+            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n                 continue;\n             }\n \n@@ -833,7 +800,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_region_test(\n         &self,\n         mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n         point: Location,\n         lower_bound: RegionVid,\n         test: &RegionTest,\n@@ -846,27 +812,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match test {\n             RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n                 .iter()\n-                .all(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n+                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n             RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n                 .iter()\n-                .any(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n+                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n             RegionTest::Any(tests) => tests\n                 .iter()\n-                .any(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n+                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n \n             RegionTest::All(tests) => tests\n                 .iter()\n-                .all(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n+                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n         }\n     }\n \n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,\n-        mir: &Mir<'tcx>,\n-        dfs_storage: &mut dfs::DfsStorage,\n+        _mir: &Mir<'tcx>,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n         point: Location,\n@@ -876,36 +841,43 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             sup_region, sub_region, point\n         );\n \n-        // Roughly speaking, do a DFS of all region elements reachable\n-        // from `point` contained in `sub_region`. If any of those are\n-        // *not* present in `sup_region`, the DFS will abort early and\n-        // yield an `Err` result.\n-        match self.dfs(\n-            mir,\n-            dfs_storage,\n-            TestTargetOutlivesSource {\n-                source_region: sub_region,\n-                target_region: sup_region,\n-                constraint_point: point,\n-                elements: &self.elements,\n-                universal_regions: &self.universal_regions,\n-                inferred_values: self.inferred_values.as_ref().unwrap(),\n-            },\n-        ) {\n-            Ok(_) => {\n-                debug!(\"eval_outlives: true\");\n-                true\n-            }\n+        let inferred_values = self.inferred_values.as_ref().expect(\"values for regions not yet inferred\");\n \n-            Err(elem) => {\n-                debug!(\n-                    \"eval_outlives: false because `{:?}` is not present in `{:?}`\",\n-                    self.elements.to_element(elem),\n-                    sup_region\n-                );\n-                false\n-            }\n+        debug!(\n+            \"eval_outlives: sup_region's value = {:?}\",\n+            inferred_values.region_value_str(sup_region),\n+        );\n+        debug!(\n+            \"eval_outlives: sub_region's value = {:?}\",\n+            inferred_values.region_value_str(sub_region),\n+        );\n+\n+        // Both the `sub_region` and `sup_region` consist of the union\n+        // of some number of universal regions (along with the union\n+        // of various points in the CFG; ignore those points for\n+        // now). Therefore, the sup-region outlives the sub-region if,\n+        // for each universal region R1 in the sub-region, there\n+        // exists some region R2 in the sup-region that outlives R1.\n+        let universal_outlives =\n+            inferred_values.universal_regions_outlived_by(sub_region)\n+            .all(|r1| {\n+                inferred_values.universal_regions_outlived_by(sup_region)\n+                    .any(|r2| self.universal_regions.outlives(r2, r1))\n+            });\n+\n+        if !universal_outlives {\n+            return false;\n+        }\n+\n+        // Now we have to compare all the points in the sub region and make\n+        // sure they exist in the sup region.\n+\n+        if self.universal_regions.is_universal_region(sup_region) {\n+            // Micro-opt: universal regions contain all points.\n+            return true;\n         }\n+\n+        inferred_values.contains_points(sup_region, sub_region)\n     }\n \n     /// Once regions have been propagated, this method is used to see"}, {"sha": "3e2d9d956e78f8a9529668ba34c1db9c097bb49b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 16, "deletions": 54, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=434d59a2c960dee2a17ae2625c8844986d580d7e", "patch": "@@ -17,7 +17,6 @@ use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n use std::fmt::Debug;\n use std::rc::Rc;\n-use syntax::codemap::Span;\n \n use super::Cause;\n \n@@ -74,11 +73,6 @@ impl RegionValueElements {\n         (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n-    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    pub(super) fn all_universal_region_indices(&self) -> impl Iterator<Item = RegionElementIndex> {\n-        (0..self.num_universal_regions).map(move |i| RegionElementIndex::new(i))\n-    }\n-\n     /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n     pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n         debug!(\"to_element(i={:?})\", i);\n@@ -244,6 +238,12 @@ impl RegionValues {\n         self.add_internal(r, i, |_| cause.clone())\n     }\n \n+    /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n+    /// r_from`).\n+    pub(super) fn add_region(&mut self, r_to: RegionVid, r_from: RegionVid) -> bool {\n+        self.matrix.merge(r_from, r_to)\n+    }\n+\n     /// Internal method to add an element to a region.\n     ///\n     /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n@@ -278,60 +278,22 @@ impl RegionValues {\n         }\n     }\n \n-    /// Adds `elem` to `to_region` because of a relation:\n-    ///\n-    ///     to_region: from_region @ constraint_location\n-    ///\n-    /// that was added by the cod at `constraint_span`.\n-    pub(super) fn add_due_to_outlives<T: ToElementIndex>(\n-        &mut self,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        elem: T,\n-        _constraint_location: Location,\n-        _constraint_span: Span,\n-    ) -> bool {\n-        let elem = self.elements.index(elem);\n-        self.add_internal(to_region, elem, |causes| causes[&(from_region, elem)])\n-    }\n-\n-    /// Adds all the universal regions outlived by `from_region` to\n-    /// `to_region`.\n-    pub(super) fn add_universal_regions_outlived_by(\n-        &mut self,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        constraint_location: Location,\n-        constraint_span: Span,\n-    ) -> bool {\n-        // We could optimize this by improving `SparseBitMatrix::merge` so\n-        // it does not always merge an entire row. That would\n-        // complicate causal tracking though.\n-        debug!(\n-            \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n-            from_region, to_region\n-        );\n-        let mut changed = false;\n-        for elem in self.elements.all_universal_region_indices() {\n-            if self.contains(from_region, elem) {\n-                changed |= self.add_due_to_outlives(\n-                    from_region,\n-                    to_region,\n-                    elem,\n-                    constraint_location,\n-                    constraint_span,\n-                );\n-            }\n-        }\n-        changed\n-    }\n-\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n         self.matrix.contains(r, i)\n     }\n \n+    /// True if `sup_region` contains all the CFG points that\n+    /// `sub_region` contains. Ignores universal regions.\n+    pub(super) fn contains_points(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n+        // This could be done faster by comparing the bitsets. But I\n+        // am lazy.\n+        self.element_indices_contained_in(sub_region)\n+            .skip_while(|&i| self.elements.to_universal_region(i).is_some())\n+            .all(|e| self.contains(sup_region, e))\n+    }\n+\n     /// Iterate over the value of the region `r`, yielding up element\n     /// indices. You may prefer `universal_regions_outlived_by` or\n     /// `elements_contained_in`."}, {"sha": "1a417b1e28c2e5629b49db7e667cce3bd4e62582", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=434d59a2c960dee2a17ae2625c8844986d580d7e", "patch": "@@ -30,8 +30,9 @@ fn ok(map: &mut Map) -> &String {\n                 return v;\n             }\n             None => {\n-                map.set(String::new()); // Just AST errors here\n+                map.set(String::new()); // Ideally, this would not error.\n                 //~^ ERROR borrowed as immutable (Ast)\n+                //~| ERROR borrowed as immutable (Mir)\n             }\n         }\n     }\n@@ -47,8 +48,9 @@ fn err(map: &mut Map) -> &String {\n                 return v;\n             }\n             None => {\n-                map.set(String::new()); // Just AST errors here\n+                map.set(String::new()); // Ideally, just AST would error here\n                 //~^ ERROR borrowed as immutable (Ast)\n+                //~| ERROR borrowed as immutable (Mir)\n             }\n         }\n     }"}, {"sha": "dd69e18652c9afc598ffeb6050598a55b560acaf", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/434d59a2c960dee2a17ae2625c8844986d580d7e/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=434d59a2c960dee2a17ae2625c8844986d580d7e", "patch": "@@ -4,14 +4,14 @@ error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as imm\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -23,19 +23,61 @@ LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:50:17\n+  --> $DIR/get_default.rs:51:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n ...\n-LL |                 map.set(String::new()); // Just AST errors here\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n    |                 ^^^ mutable borrow occurs here\n ...\n LL | }\n    | - immutable borrow ends here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:44:17\n+  --> $DIR/get_default.rs:33:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, this would not error.\n+   |                 ^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 26:1...\n+  --> $DIR/get_default.rs:26:1\n+   |\n+LL | / fn ok(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:51:17\n+   |\n+LL |         match map.get() {\n+   |               --- immutable borrow occurs here\n+...\n+LL |                 map.set(String::new()); // Ideally, just AST would error here\n+   |                 ^^^ mutable borrow occurs here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n+  --> $DIR/get_default.rs:45:17\n    |\n LL |         match map.get() {\n    |               --- immutable borrow occurs here\n@@ -46,6 +88,6 @@ LL |                 map.set(String::new()); // Both AST and MIR error here\n LL |                 return v;\n    |                        - borrow later used here\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0502`."}]}