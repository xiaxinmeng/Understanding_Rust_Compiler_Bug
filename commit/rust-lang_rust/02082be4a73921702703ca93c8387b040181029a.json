{"sha": "02082be4a73921702703ca93c8387b040181029a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDgyYmU0YTczOTIxNzAyNzAzY2E5M2M4Mzg3YjA0MDE4MTAyOWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-09T13:33:00Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-09T14:30:48Z"}, "message": "Fix various bugs in monomorphization\n\nEnough to be able to compile librustc with --monomorphize.\n\nIssue #1736", "tree": {"sha": "7408fd1ef186320229423bac94468fd9efb6a1b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7408fd1ef186320229423bac94468fd9efb6a1b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02082be4a73921702703ca93c8387b040181029a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02082be4a73921702703ca93c8387b040181029a", "html_url": "https://github.com/rust-lang/rust/commit/02082be4a73921702703ca93c8387b040181029a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02082be4a73921702703ca93c8387b040181029a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52a741754c76f147e8a009051c307091efaf45b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a741754c76f147e8a009051c307091efaf45b2", "html_url": "https://github.com/rust-lang/rust/commit/52a741754c76f147e8a009051c307091efaf45b2"}], "stats": {"total": 145, "additions": 81, "deletions": 64}, "files": [{"sha": "5c5ce3f674c8bed610b9658002908c9af3ac5abe", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -615,7 +615,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat)\n           ast::pat_rec(fs, _) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             for f in fs {\n-                let m = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm,\n+                let m = ty::get_field(ty, f.ident).mt.mut != ast::imm,\n                     c = if m { some(contains(ty)) } else { mut };\n                 walk(tcx, c, f.pat, set);\n             }"}, {"sha": "3419b6379e30c8d0fb746b6b1309e40a31be460a", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -411,7 +411,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for field in fields {\n-        let field_t = ty::get_field(ccx_tcx(cx), t, field.node.ident).mt.ty;\n+        let field_t = ty::get_field(t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = member_size_and_align(cx.tcx, field.node.mt.ty);\n         add_member(scx, field.node.ident,"}, {"sha": "af6c859b039134b546ebe2e635df333ec7103499", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -265,7 +265,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     let ccx = bcx.fcx.ccx, bcx = bcx;\n     // invariant:\n     // pat_id must have the same length ty_param_substs as vdefs?\n-    let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n+    let ty_param_substs = node_id_type_params(bcx, pat_id);\n     let blobptr = val;\n     let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n     let args = [];\n@@ -420,8 +420,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n     if vec::len(rec_fields) > 0u {\n-        let rec_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n-        let fields = ty::get_fields(ccx.tcx, rec_ty);\n+        let rec_ty = node_id_type(bcx, pat_id);\n+        let fields = ty::get_fields(rec_ty);\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n@@ -435,7 +435,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     }\n \n     if any_tup_pat(m, col) {\n-        let tup_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n+        let tup_ty = node_id_type(bcx, pat_id);\n         let n_tup_elts = alt ty::get(tup_ty).struct {\n           ty::ty_tup(elts) { vec::len(elts) }\n           _ { ccx.sess.bug(\"Non-tuple type in tuple pattern\"); }\n@@ -488,7 +488,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           }\n           lit(l) {\n             test_val = Load(bcx, val);\n-            let pty = ty::node_id_to_type(ccx.tcx, pat_id);\n+            let pty = node_id_type(bcx, pat_id);\n             kind = if ty::type_is_integral(pty) { switch }\n                    else { compare };\n           }\n@@ -539,7 +539,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n             Br(bcx, compare_cx.llbb);\n             bcx = compare_cx;\n-            let t = ty::node_id_to_type(ccx.tcx, pat_id);\n+            let t = node_id_type(bcx, pat_id);\n             let res = trans_opt(bcx, opt);\n             alt res {\n               single_result(r) {\n@@ -622,7 +622,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                         forgot to document an invariant in \\\n                         make_phi_bindings\"); }\n                 };\n-                let e_ty = ty::node_id_to_type(bcx_tcx(bcx), node_id);\n+                let e_ty = node_id_type(bcx, node_id);\n                 let {bcx: abcx, val: alloc} = base::alloc_ty(bcx, e_ty);\n                 bcx = base::copy_val(abcx, base::INIT, alloc,\n                                       load_if_immediate(abcx, local, e_ty),\n@@ -739,7 +739,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n       }\n       ast::pat_rec(fields, _) {\n         let rec_ty = node_id_type(bcx, pat.id);\n-        let rec_fields = ty::get_fields(ccx.tcx, rec_ty);\n+        let rec_fields = ty::get_fields(rec_ty);\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?"}, {"sha": "b17de7f855c649a33bb3310f808e878eef35ccc8", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -1902,7 +1902,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     alt bcx_ccx(bcx).method_map.find(un_expr.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n-        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n+        let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, e, origin)\n         }, [], un_expr.id, dest);\n@@ -2036,7 +2036,6 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> @block_ctxt {\n-    let tcx = bcx_tcx(bcx);\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == owned);\n@@ -2045,7 +2044,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n-        let fty = ty::node_id_to_type(tcx, callee_id);\n+        let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             // FIXME provide the already-computed address, not the expr\n             impl::trans_method_callee(bcx, callee_id, dst, origin)\n@@ -2169,7 +2168,7 @@ fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n-        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n+        let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, lhs, origin)\n         }, [rhs], ex.id, dest);\n@@ -2452,59 +2451,58 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, tpt.ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n-    let lldecl;\n+\n+    let map_node = ccx.tcx.items.get(fn_id.node);\n+    // Get the path so that we can create a symbol\n+    let (pt, name) = alt map_node {\n+      ast_map::node_item(i, pt) { (pt, i.ident) }\n+      ast_map::node_variant(v, _, pt) { (pt, v.node.name) }\n+      ast_map::node_method(m, _, pt) { (pt, m.ident) }\n+      // We can't monomorphize native functions\n+      ast_map::node_native_item(_, _) { ret none; }\n+      _ { fail \"Unexpected node type\"; }\n+    };\n+    let pt = *pt + [path_name(ccx.names(name))];\n+    let s = mangle_exported_name(ccx, pt, mono_ty);\n+    let lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+    ccx.monomorphized.insert(hash_id, {llfn: lldecl, fty: mono_ty});\n+\n     let psubsts = some({tys: substs, dicts: dicts, bounds: tpt.bounds});\n-    alt ccx.tcx.items.get(fn_id.node) {\n-      ast_map::node_item(item, pt) {\n-        let pt = *pt + [path_name(item.ident)];\n-        let s = mangle_exported_name(ccx, pt, mono_ty);\n-        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n-        alt item.node {\n-          ast::item_fn(decl, _, body) {\n-            trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n-                     psubsts, fn_id.node);\n-          }\n-          ast::item_res(decl, _, _, _, ctor_id) {\n-            trans_res_ctor(ccx, pt, decl, ctor_id, [], psubsts, lldecl);\n-          }\n-          _ { fail \"Unexpected item type\"; }\n-        }\n+    alt map_node {\n+      ast_map::node_item(@{node: ast::item_fn(decl, _, body), _}, _) {\n+        trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n+                 psubsts, fn_id.node);\n+      }\n+      ast_map::node_item(@{node: ast::item_res(decl, _, _, _, _), _}, _) {\n+        trans_res_ctor(ccx, pt, decl, fn_id.node, [], psubsts, lldecl);\n       }\n-      ast_map::node_variant(v, enum_id, pt) {\n-        let pt = *pt + [path_name(v.node.name)];\n-        let s = mangle_exported_name(ccx, pt, mono_ty);\n-        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+      ast_map::node_variant(v, enum_id, _) {\n         let tvs = ty::enum_variants(ccx.tcx, enum_id);\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n         trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n                            vec::len(*tvs) == 1u, [], psubsts, lldecl);\n       }\n-      ast_map::node_method(mth, impl_id, pt) {\n-        let pt = *pt + [path_name(mth.ident)];\n-        let s = mangle_exported_name(ccx, pt, mono_ty);\n-        lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n+      ast_map::node_method(mth, impl_id, _) {\n         let selfty = ty::node_id_to_type(ccx.tcx, impl_id);\n         let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), [], psubsts, fn_id.node);\n       }\n-      ast_map::node_native_item(_, _) {\n-        ret none;\n-      }\n-      _ { fail \"Unexpected node type\"; }\n+      _ { fail; }\n     }\n-    let val = {llfn: lldecl, fty: mono_ty};\n-    ccx.monomorphized.insert(hash_id, val);\n-    some(val)\n+    some({llfn: lldecl, fty: mono_ty})\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(bcx);\n-    let tys = ty::node_id_to_type_params(ccx.tcx, id);\n+    let tys = node_id_type_params(bcx, id);\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    // The awkwardness below mostly stems from the fact that we're mixing\n+    // monomorphized and non-monomorphized functions at the moment. If\n+    // monomorphizing becomes the only approach, this'll be much simpler.\n     if ccx.sess.opts.monomorphize &&\n        (option::is_some(substs) || vec::len(tys) > 0u) &&\n        fn_id.crate == ast::local_crate &&\n@@ -2634,7 +2632,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n             ret lval_static_fn(cx, vid, id, none);\n         } else {\n             // Nullary variant.\n-            let enum_ty = ty::node_id_to_type(ccx.tcx, id);\n+            let enum_ty = node_id_type(cx, id);\n             let alloc_result = alloc_ty(cx, enum_ty);\n             let llenumblob = alloc_result.val;\n             let llenumty = type_of_enum(ccx, tid, enum_ty);\n@@ -2652,7 +2650,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n             assert (ccx.consts.contains_key(did.node));\n             ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n         } else {\n-            let tp = ty::node_id_to_type(ccx.tcx, id);\n+            let tp = node_id_type(cx, id);\n             let val = trans_external_path(cx, did, {bounds: @[], ty: tp});\n             ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n@@ -3129,8 +3127,6 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-    let tcx = bcx_tcx(in_cx);\n-\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     Br(in_cx, cx.llbb);\n     let f_res = get_callee(cx);\n@@ -3157,7 +3153,7 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n       }\n     }\n \n-    let ret_ty = ty::node_id_to_type(tcx, id);\n+    let ret_ty = node_id_type(bcx, id);\n     let args_res =\n         trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n     bcx = args_res.bcx;\n@@ -3520,7 +3516,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         // If it is here, it's not an lval, so this is a user-defined index op\n         let origin = bcx_ccx(bcx).method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n-        let fty = ty::node_id_to_type(tcx, callee_id);\n+        let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, base, origin)\n         }, [idx], e.id, dest);"}, {"sha": "5ff02b63217f215b1be512bdb1ca30151c91863e", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -16,6 +16,7 @@ import back::link::{\n import util::ppaux::ty_to_str;\n import shape::{size_of};\n import ast_map::{path, path_mod, path_name};\n+import driver::session::session;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -362,7 +363,7 @@ fn build_closure(bcx0: @block_ctxt,\n     vec::iter(cap_vars) { |cap_var|\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        let ty = ty::node_id_to_type(tcx, nid);\n+        let ty = node_id_type(bcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref {\n             assert ck == ty::ck_block;\n@@ -486,7 +487,7 @@ fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option<@ast::expr>],\n               id: ast::node_id, dest: dest) -> @block_ctxt {\n     let f_res = trans_callee(cx, f);\n     ret trans_bind_1(cx, expr_ty(cx, f), f_res, args,\n-                     ty::node_id_to_type(bcx_tcx(cx), id), dest);\n+                     node_id_type(cx, id), dest);\n }\n \n fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,"}, {"sha": "7d7b5b25b47b2a2e181ff002361a74be235ad7d1", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -910,6 +910,16 @@ fn node_id_type(bcx: @block_ctxt, id: ast::node_id) -> ty::t {\n fn expr_ty(bcx: @block_ctxt, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n+fn node_id_type_params(bcx: @block_ctxt, id: ast::node_id) -> [ty::t] {\n+    let tcx = bcx_tcx(bcx);\n+    let params = ty::node_id_to_type_params(tcx, id);\n+    alt bcx.fcx.param_substs {\n+      some(substs) {\n+        vec::map(params) {|t| ty::substitute_type_params(tcx, substs.tys, t) }\n+      }\n+      _ { params }\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "41d6a47d75f21232ae1cd21561857a4b467f70f8", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -116,15 +116,15 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n     let {ty: fty, llty: llfty} =\n-        wrapper_fn_ty(ccx, val_ty(dict), ty::node_id_to_type(tcx, callee_id),\n+        wrapper_fn_ty(ccx, val_ty(dict), node_id_type(bcx, callee_id),\n                       method.tps);\n     let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n     let generic = generic_none;\n     if vec::len(*method.tps) > 0u || ty::type_has_params(fty) {\n         let tydescs = [], tis = [];\n-        let tptys = ty::node_id_to_type_params(tcx, callee_id);\n+        let tptys = node_id_type_params(bcx, callee_id);\n         for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n             let ti = none;\n             let td = get_tydesc(bcx, t, true, ti).result;\n@@ -246,7 +246,17 @@ fn resolve_dicts_in_fn_ctxt(fcx: @fn_ctxt, dicts: typeck::dict_res)\n         result += [alt dict {\n           typeck::dict_static(iid, tys, sub) {\n             alt resolve_dicts_in_fn_ctxt(fcx, sub) {\n-              some(sub) { typeck::dict_static(iid, tys, sub) }\n+              some(sub) {\n+                let tys = alt fcx.param_substs {\n+                  some(substs) {\n+                    vec::map(tys, {|t|\n+                        ty::substitute_type_params(fcx.ccx.tcx, substs.tys, t)\n+                    })\n+                  }\n+                  _ { tys }\n+                };\n+                typeck::dict_static(iid, tys, sub)\n+              }\n               none { ret none; }\n             }\n           }"}, {"sha": "11f5c2ac3a048fe9204d202637bbb8439e796f06", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02082be4a73921702703ca93c8387b040181029a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=02082be4a73921702703ca93c8387b040181029a", "patch": "@@ -1339,18 +1339,18 @@ fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n     ret none;\n }\n \n-fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n-    alt vec::find(get_fields(tcx, rec_ty), {|f| str::eq(f.ident, id) }) {\n-         some(f) { ret f; }\n-         _ { tcx.sess.bug(#fmt(\"get_field: bad field id %s\", id)); }\n+fn get_field(rec_ty: t, id: ast::ident) -> field {\n+    alt vec::find(get_fields(rec_ty), {|f| str::eq(f.ident, id) }) {\n+      some(f) { f }\n+      _ { fail #fmt(\"get_field: bad field id %s\", id); }\n     }\n }\n \n // TODO: could have a precondition instead of failing\n-fn get_fields(tcx:ctxt, rec_ty:t) -> [field] {\n+fn get_fields(rec_ty:t) -> [field] {\n     alt get(rec_ty).struct {\n-       ty_rec(fields) { fields }\n-       _ { tcx.sess.bug(\"get_fields called on non-record type\"); }\n+      ty_rec(fields) { fields }\n+      _ { fail \"get_fields called on non-record type\"; }\n     }\n }\n "}]}