{"sha": "df27699a57e056bfd3641c20a938805f55688dc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMjc2OTlhNTdlMDU2YmZkMzY0MWMyMGE5Mzg4MDVmNTU2ODhkYzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-14T20:08:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-14T20:09:00Z"}, "message": "Modernize some code in parser.rs\n\nNo more explicit type params or working around rustboot bugs", "tree": {"sha": "4b77fbea4de6040ba2c7ec7c06d451dccc3743f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b77fbea4de6040ba2c7ec7c06d451dccc3743f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df27699a57e056bfd3641c20a938805f55688dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df27699a57e056bfd3641c20a938805f55688dc7", "html_url": "https://github.com/rust-lang/rust/commit/df27699a57e056bfd3641c20a938805f55688dc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df27699a57e056bfd3641c20a938805f55688dc7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b5c3afae533e725d2eddb48df27117bdb820e15", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5c3afae533e725d2eddb48df27117bdb820e15", "html_url": "https://github.com/rust-lang/rust/commit/7b5c3afae533e725d2eddb48df27117bdb820e15"}], "stats": {"total": 214, "additions": 82, "deletions": 132}, "files": [{"sha": "f3b36b073c3f2a0505a9392fc79e93251f054ff7", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 82, "deletions": 132, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/df27699a57e056bfd3641c20a938805f55688dc7/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df27699a57e056bfd3641c20a938805f55688dc7/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=df27699a57e056bfd3641c20a938805f55688dc7", "patch": "@@ -131,7 +131,7 @@ fn new_parser(session::session sess,\n             }\n \n             fn get_str(token::str_num i) -> str {\n-                ret interner::get[str](*rdr.get_interner(), i);\n+                ret interner::get(*rdr.get_interner(), i);\n             }\n \n             fn get_reader() -> lexer::reader {\n@@ -167,8 +167,8 @@ fn new_parser(session::session sess,\n     }\n     auto srdr = io::file_reader(path);\n     auto filemap = codemap::new_filemap(path, pos);\n-    vec::push[codemap::filemap](sess.get_codemap().files, filemap);\n-    auto itr = @interner::mk[str](str::hash, str::eq);\n+    vec::push(sess.get_codemap().files, filemap);\n+    auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n     lexer::consume_whitespace_and_comments(rdr);\n@@ -183,7 +183,7 @@ fn new_parser(session::session sess,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n fn bad_expr_word_table() -> hashmap[str, ()] {\n-    auto words = new_str_hash[()]();\n+    auto words = new_str_hash();\n     words.insert(\"mod\", ());\n     words.insert(\"if\", ());\n     words.insert(\"else\", ());\n@@ -390,8 +390,7 @@ fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n     auto f = parse_method_sig;\n     auto meths = parse_seq(token::LBRACE,\n                            token::RBRACE,\n-                           none[token::token],\n-                           f, p);\n+                           none, f, p);\n     hi = meths.span.hi;\n     ret ast::ty_obj(meths.node);\n }\n@@ -440,9 +439,9 @@ fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n     auto path = parse_path(p);\n     auto pf = bind parse_constr_arg(fn_args, _);\n     let rec(vec[@ast::constr_arg] node, span span) args =\n-         parse_seq[@ast::constr_arg](token::LPAREN,\n-                                         token::RPAREN,\n-                                         some(token::COMMA), pf, p);\n+         parse_seq(token::LPAREN,\n+                   token::RPAREN,\n+                   some(token::COMMA), pf, p);\n     // FIXME fix the def_id\n     ret @spanned(lo, args.span.hi,\n                  rec(path=path, args=args.node, ann=p.get_ann()));\n@@ -461,7 +460,7 @@ fn parse_constrs(&vec[ast::arg] args,\n         while (true) {\n             auto constr = parse_ty_constr(args, p);\n             hi = constr.span.hi;\n-            vec::push[@ast::constr](constrs, constr);\n+            vec::push(constrs, constr);\n             if (p.peek() == token::COMMA) {\n                 p.bump();\n             } else {\n@@ -484,7 +483,7 @@ fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n         case (token::NOT) { p.bump(); ret a_bang[@ast::ty]; }\n-        case (_)         { ret a_ty[@ast::ty](parse_ty(p)); }\n+        case (_)         { ret a_ty(parse_ty(p)); }\n     }\n }\n \n@@ -544,19 +543,14 @@ fn parse_ty(&parser p) -> @ast::ty {\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"tup\")) {\n-        auto f = parse_mt; // FIXME: trans_const_lval bug\n-        auto elems = parse_seq[ast::mt] (token::LPAREN,\n-                                         token::RPAREN,\n-                                         some(token::COMMA), f, p);\n+        auto elems = parse_seq(token::LPAREN, token::RPAREN,\n+                               some(token::COMMA), parse_mt, p);\n         hi = elems.span.hi;\n         t = ast::ty_tup(elems.node);\n     } else if (eat_word(p, \"rec\")) {\n-        auto f = parse_ty_field; // FIXME: trans_const_lval bug\n         auto elems =\n-            parse_seq[ast::ty_field](token::LPAREN,\n-                                     token::RPAREN,\n-                                     some(token::COMMA),\n-                                     f, p);\n+            parse_seq(token::LPAREN, token::RPAREN,\n+                      some(token::COMMA), parse_ty_field, p);\n         hi = elems.span.hi;\n         t = ast::ty_rec(elems.node);\n     } else if (eat_word(p, \"fn\")) {\n@@ -640,9 +634,7 @@ fn parse_seq_to_end[T](token::token ket,\n             case (_) {\n             }\n         }\n-        // FIXME: v += f(p) doesn't work at the moment.\n-        let T t = f(p);\n-        v += [t];\n+        v += [f(p)];\n     }\n     expect(p, ket);\n     ret v;\n@@ -717,11 +709,8 @@ fn parse_ty_args(&parser p, uint hi) ->\n     util::common::spanned[vec[@ast::ty]] {\n \n     if (p.peek() == token::LBRACKET) {\n-        auto pf = parse_ty;\n-        ret parse_seq[@ast::ty](token::LBRACKET,\n-                               token::RBRACKET,\n-                               some(token::COMMA),\n-                               pf, p);\n+        ret parse_seq(token::LBRACKET, token::RBRACKET,\n+                      some(token::COMMA), parse_ty, p);\n     }\n     let vec[@ast::ty] v = [];\n     auto pos = p.get_lo_pos();\n@@ -823,23 +812,16 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             auto e = parse_expr(p);\n             ret rec(mut=m, expr=e);\n         }\n-        auto pf = parse_elt;\n-        auto es =\n-            parse_seq[ast::elt](token::LPAREN,\n-                                token::RPAREN,\n-                                some(token::COMMA),\n-                                pf, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                            some(token::COMMA), parse_elt, p);\n         hi = es.span.hi;\n         ex = ast::expr_tup(es.node, p.get_ann());\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n-        auto pf = parse_expr;\n-\n         auto mut = parse_mutability(p);\n-\n-        auto es = parse_seq_to_end[@ast::expr](token::RBRACKET,\n-                                               some(token::COMMA),\n-                                               pf, p);\n+        auto es = parse_seq_to_end(token::RBRACKET,\n+                                   some(token::COMMA),\n+                                   parse_expr, p);\n         ex = ast::expr_vec(es, mut, ast::sk_rc, p.get_ann());\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n@@ -871,8 +853,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         auto ty_params = parse_ty_params(p);\n \n         // Only make people type () if they're actually adding new fields\n-        let option::t[vec[ast::obj_field]] fields = \n-            none[vec[ast::obj_field]];\n+        let option::t[vec[ast::obj_field]] fields = none;\n         if (p.peek() == token::LPAREN) {\n             auto pf = parse_obj_field;\n             expect(p, token::LPAREN);\n@@ -886,16 +867,15 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         }\n \n         let vec[@ast::method] meths = [];\n-        let option::t[@ast::expr] with_obj = none[@ast::expr];\n+        let option::t[@ast::expr] with_obj = none;\n \n         expect(p, token::LBRACE);\n \n         while (p.peek() != token::RBRACE) {\n             if (eat_word(p, \"with\")) {\n-                with_obj = some[@ast::expr](parse_expr(p));\n+                with_obj = some(parse_expr(p));\n             } else {\n-                vec::push[@ast::method](meths,\n-                                         parse_method(p));\n+                vec::push(meths, parse_method(p));\n             }\n         }\n \n@@ -921,14 +901,14 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         auto fields = [parse_field(p)];\n \n         auto more = true;\n-        auto base = none[@ast::expr];\n+        auto base = none;\n         while (more) {\n             if (p.peek() == token::RPAREN) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n                 more = false;\n             } else if (eat_word(p, \"with\")) {\n-                base = some[@ast::expr](parse_expr(p));\n+                base = some(parse_expr(p));\n                 hi = p.get_hi_pos();\n                 expect(p, token::RPAREN);\n                 more = false;\n@@ -947,42 +927,35 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             alt (p.peek()) {\n                 case (token::UNDERSCORE) {\n                     p.bump();\n-                    ret none[@ast::expr];\n+                    ret none;\n                 }\n                 case (_) {\n-                    ret some[@ast::expr](parse_expr(p));\n+                    ret some(parse_expr(p));\n                 }\n             }\n         }\n \n-        auto pf = parse_expr_opt;\n-        auto es = parse_seq[option::t[@ast::expr]](token::LPAREN,\n-                                                   token::RPAREN,\n-                                                   some(token::COMMA),\n-                                                   pf, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                            some(token::COMMA), parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node, p.get_ann());\n     } else if (p.peek() == token::POUND) {\n         p.bump();\n         auto pth = parse_path(p);\n-        auto pf = parse_expr;\n-        auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                        token::RPAREN,\n-                                        some(token::COMMA),\n-                                        pf, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                            some(token::COMMA), parse_expr, p);\n         hi = es.span.hi;\n         auto ext_span = rec(lo=lo, hi=hi);\n-        ex = expand_syntax_ext(p, ext_span, pth, es.node,\n-                               none[str]);\n+        ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n     } else if (eat_word(p, \"fail\")) {\n         auto msg;\n         alt (p.peek()) {\n            case (token::LIT_STR(?s)) {\n-               msg = some[str](p.get_str(s));\n+               msg = some(p.get_str(s));\n                p.bump();\n            }\n            case (_) {\n-               msg = none[str];\n+               msg = none;\n            }\n         }\n         ex = ast::expr_fail(p.get_ann(), msg);\n@@ -1008,12 +981,12 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n             case (token::SEMI) {\n-                ex = ast::expr_ret(none[@ast::expr], p.get_ann());\n+                ex = ast::expr_ret(none, p.get_ann());\n             }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_ret(some[@ast::expr](e), p.get_ann());\n+                ex = ast::expr_ret(some(e), p.get_ann());\n             }\n         }\n     } else if (eat_word(p, \"break\")) {\n@@ -1023,12 +996,12 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (eat_word(p, \"put\")) {\n         alt (p.peek()) {\n             case (token::SEMI) {\n-                ex = ast::expr_put(none[@ast::expr], p.get_ann());\n+                ex = ast::expr_put(none, p.get_ann());\n             }\n             case (_) {\n                 auto e = parse_expr(p);\n                 hi = e.span.hi;\n-                ex = ast::expr_put(some[@ast::expr](e), p.get_ann());\n+                ex = ast::expr_put(some(e), p.get_ann());\n             }\n         }\n     } else if (eat_word(p, \"be\")) {\n@@ -1058,11 +1031,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         expect(p, token::DOT);\n         // The rest is a call expression.\n         let @ast::expr f = parse_self_method(p);\n-        auto pf = parse_expr;\n-        auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                        token::RPAREN,\n-                                        some(token::COMMA),\n-                                        pf, p);\n+        auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                            some(token::COMMA), parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node, p.get_ann());\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n@@ -1091,7 +1061,7 @@ fn expand_syntax_ext(&parser p, common::span sp,\n                      &ast::path path, vec[@ast::expr] args,\n                      option::t[str] body) -> ast::expr_ {\n \n-    assert (vec::len[ast::ident](path.node.idents) > 0u);\n+    assert (vec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n \n     alt (p.get_syntax_expanders().find(extname)) {\n@@ -1129,11 +1099,8 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                     ret e;\n                 } else {\n                     // Call expr.\n-                    auto pf = parse_expr;\n-                    auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                                   token::RPAREN,\n-                                                   some(token::COMMA),\n-                                                   pf, p);\n+                    auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                                        some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n                     auto e_ = ast::expr_call(e, es.node, p.get_ann());\n                     e = @spanned(lo, hi, e_);\n@@ -1351,7 +1318,7 @@ fn parse_if_expr(&parser p) -> @ast::expr {\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto thn = parse_block(p);\n-    let option::t[@ast::expr] els = none[@ast::expr];\n+    let option::t[@ast::expr] els = none;\n     auto hi = thn.span.hi;\n     if (eat_word(p, \"else\")) {\n         auto elexpr = parse_else_expr(p);\n@@ -1471,14 +1438,11 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n     // FIXME: Parse domain and name\n     // FIXME: why no full expr?\n     auto fn_expr = parse_bottom_expr(p);\n-    auto pf = parse_expr;\n-    auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                   token::RPAREN,\n-                                   some(token::COMMA),\n-                                   pf, p);\n+    auto es = parse_seq(token::LPAREN, token::RPAREN,\n+                        some(token::COMMA), parse_expr, p);\n     auto hi = es.span.hi;\n     auto spawn_expr = ast::expr_spawn(ast::dom_implicit,\n-                                     option::none[str],\n+                                     option::none,\n                                      fn_expr,\n                                      es.node,\n                                      p.get_ann());\n@@ -1517,7 +1481,7 @@ fn parse_initializer(&parser p) -> option::t[ast::initializer] {\n         //                  expr = parse_expr(p)));\n         // }\n         case (_) {\n-            ret none[ast::initializer];\n+            ret none;\n         }\n     }\n }\n@@ -1596,7 +1560,7 @@ fn parse_typed_local(&parser p) -> @ast::local_ {\n }\n \n fn parse_auto_local(&parser p) -> @ast::local_ {\n-    ret parse_local_full(none[@ast::ty], p);\n+    ret parse_local_full(none, p);\n }\n \n fn parse_let(&parser p) -> @ast::decl {\n@@ -1660,11 +1624,10 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n }\n \n fn stmt_to_expr(@ast::stmt stmt) -> option::t[@ast::expr] {\n-    alt (stmt.node) {\n-        case (ast::stmt_expr(?e,_)) { ret some[@ast::expr](e); }\n-        case (_) { /* fall through */ }\n-    }\n-    ret none[@ast::expr];\n+    ret alt (stmt.node) {\n+        case (ast::stmt_expr(?e,_)) { some(e) }\n+        case (_) { none }\n+    };\n }\n \n fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n@@ -1723,7 +1686,7 @@ fn parse_block(&parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n \n     let vec[@ast::stmt] stmts = [];\n-    let option::t[@ast::expr] expr = none[@ast::expr];\n+    let option::t[@ast::expr] expr = none;\n \n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n@@ -1777,7 +1740,7 @@ fn parse_block(&parser p) -> ast::block {\n     p.bump();\n \n     auto bloc = rec(stmts=stmts, expr=expr, a=p.get_ann());\n-    ret spanned[ast::block_](lo, hi, bloc);\n+    ret spanned(lo, hi, bloc);\n }\n \n fn parse_ty_param(&parser p) -> ast::ty_param {\n@@ -1787,23 +1750,17 @@ fn parse_ty_param(&parser p) -> ast::ty_param {\n fn parse_ty_params(&parser p) -> vec[ast::ty_param] {\n     let vec[ast::ty_param] ty_params = [];\n     if (p.peek() == token::LBRACKET) {\n-        auto f = parse_ty_param;   // FIXME: pass as lval directly\n-        ty_params = parse_seq[ast::ty_param](token::LBRACKET, token::RBRACKET,\n-                                            some(token::COMMA), f, p).node;\n+        ty_params = parse_seq(token::LBRACKET, token::RBRACKET,\n+                              some(token::COMMA), parse_ty_param, p).node;\n     }\n     ret ty_params;\n }\n \n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     auto pf = parse_arg;\n     let util::common::spanned[vec[ast::arg]] inputs =\n-        // FIXME: passing parse_arg as an lval doesn't work at the\n-        // moment.\n-        parse_seq[ast::arg]\n-        (token::LPAREN,\n-         token::RPAREN,\n-         some(token::COMMA),\n-         pf, p);\n+        parse_seq(token::LPAREN, token::RPAREN,\n+                  some(token::COMMA), parse_arg, p);\n \n     let ty_or_bang res;\n \n@@ -1813,8 +1770,8 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n         p.bump();\n         res = parse_ty_or_bang(p);\n     } else {\n-        res = a_ty[@ast::ty](@spanned(inputs.span.lo, inputs.span.hi,\n-                                      ast::ty_nil));\n+        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi,\n+                            ast::ty_nil));\n     }\n \n     alt (res) {\n@@ -1908,15 +1865,14 @@ fn parse_item_obj(&parser p, ast::layer lyr) -> @ast::item {\n          pf, p);\n \n     let vec[@ast::method] meths = [];\n-    let option::t[@ast::method] dtor = none[@ast::method];\n+    let option::t[@ast::method] dtor = none;\n \n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n         if (eat_word(p, \"drop\")) {\n-            dtor = some[@ast::method](parse_dtor(p));\n+            dtor = some(parse_dtor(p));\n         } else {\n-            vec::push[@ast::method](meths,\n-                                     parse_method(p));\n+            vec::push(meths, parse_method(p));\n         }\n     }\n     auto hi = p.get_hi_pos();\n@@ -1984,10 +1940,10 @@ fn parse_item_native_fn(&parser p) -> @ast::native_item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n-    auto link_name = none[str];\n+    auto link_name = none;\n     if (p.peek() == token::EQ) {\n         p.bump();\n-        link_name = some[str](parse_str_lit_or_env_ident(p));\n+        link_name = some(parse_str_lit_or_env_ident(p));\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n@@ -2113,11 +2069,9 @@ fn parse_item_tag(&parser p) -> @ast::item {\n                 let vec[ast::variant_arg] args = [];\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n-                        auto f = parse_ty;\n-                        auto arg_tys = parse_seq[@ast::ty](token::LPAREN,\n-                                                          token::RPAREN,\n-                                                          some(token::COMMA),\n-                                                          f, p);\n+                        auto arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n+                                                 some(token::COMMA),\n+                                                 parse_ty, p);\n                         for (@ast::ty ty in arg_tys.node) {\n                             args += [rec(ty=ty, id=p.next_def_id())];\n                         }\n@@ -2131,7 +2085,7 @@ fn parse_item_tag(&parser p) -> @ast::item {\n                 auto id = p.next_def_id();\n                 auto vr = rec(name=p.get_str(name), args=args,\n                               id=id, ann=p.get_ann());\n-                variants += [spanned[ast::variant_](vlo, vhi, vr)];\n+                variants += [spanned(vlo, vhi, vr)];\n             }\n             case (token::RBRACE) { /* empty */ }\n             case (_) {\n@@ -2225,9 +2179,8 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n }\n \n fn parse_meta(&parser p) -> vec[@ast::meta_item] {\n-    auto pf = parse_meta_item;\n-    ret parse_seq[@ast::meta_item](token::LPAREN, token::RPAREN,\n-                                   some(token::COMMA), pf, p).node;\n+    ret parse_seq(token::LPAREN, token::RPAREN,\n+                  some(token::COMMA), parse_meta_item, p).node;\n }\n \n fn parse_optional_meta(&parser p) -> vec[@ast::meta_item] {\n@@ -2299,7 +2252,7 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n                 import_decl = ast::view_item_import_glob(identifiers,\n                                                          p.next_def_id());\n             } else {\n-                auto len = vec::len[ast::ident](identifiers);\n+                auto len = vec::len(identifiers);\n                 import_decl = ast::view_item_import(identifiers.(len - 1u), \n                                                     identifiers, \n                                                     p.next_def_id());\n@@ -2333,8 +2286,7 @@ fn parse_import(&parser p) -> @ast::view_item {\n                     ret parse_full_import_name(p, p.get_str(i));\n                 }\n                 case (_) {\n-                    ret parse_rest_import_name(p, p.get_str(i),\n-                                               none[ast::ident]);\n+                    ret parse_rest_import_name(p, p.get_str(i), none);\n                 }\n             }\n         }\n@@ -2429,16 +2381,14 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive\n         ret spanned(lo, hi, ast::cdir_meta(mv, mis));\n     } else if (eat_word(p, \"mod\")) {\n         auto id = parse_ident(p);\n-        auto file_opt = none[filename];\n-        alt (p.peek()) {\n+        auto file_opt = alt (p.peek()) {\n             case (token::EQ) {\n                 p.bump();\n                 // FIXME: turn this into parse+eval expr\n-                file_opt = some[filename](parse_str_lit_or_env_ident(p));\n+                some(parse_str_lit_or_env_ident(p))\n             }\n-            case (_) {}\n-        }\n-\n+            case (_) { none }\n+        };\n \n         alt (p.peek()) {\n \n@@ -2500,7 +2450,7 @@ fn parse_crate_directives(&parser p, token::token term)\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n-        vec::push[@ast::crate_directive](cdirs, cdir);\n+        vec::push(cdirs, cdir);\n     }\n \n     ret cdirs;"}]}