{"sha": "7c86a9c05c576211932da47c1c3d89ccc925b3da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjODZhOWMwNWM1NzYyMTE5MzJkYTQ3YzFjM2Q4OWNjYzkyNWIzZGE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-02T07:58:00Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-02T07:58:00Z"}, "message": "Merge #3387\n\n3387: Replace big if/else expression with match r=flip1995 a=mikerite\n\n\n\nCo-authored-by: Michael Wright <mikerite@lavabit.com>", "tree": {"sha": "7811281b6e85bb0827a3ea51df3a5a3afba8d236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7811281b6e85bb0827a3ea51df3a5a3afba8d236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c86a9c05c576211932da47c1c3d89ccc925b3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c86a9c05c576211932da47c1c3d89ccc925b3da", "html_url": "https://github.com/rust-lang/rust/commit/7c86a9c05c576211932da47c1c3d89ccc925b3da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c86a9c05c576211932da47c1c3d89ccc925b3da/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ae137d526c04cd9d409a5abeefe21503ec535e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae137d526c04cd9d409a5abeefe21503ec535e8a", "html_url": "https://github.com/rust-lang/rust/commit/ae137d526c04cd9d409a5abeefe21503ec535e8a"}, {"sha": "0a41dfd94630057713e0e55b28accb9455ae2183", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a41dfd94630057713e0e55b28accb9455ae2183", "html_url": "https://github.com/rust-lang/rust/commit/0a41dfd94630057713e0e55b28accb9455ae2183"}], "stats": {"total": 117, "additions": 60, "deletions": 57}, "files": [{"sha": "539d95fd076ebf41bf47ecf292cc8946d8891cbb", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 36, "deletions": 56, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7c86a9c05c576211932da47c1c3d89ccc925b3da/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c86a9c05c576211932da47c1c3d89ccc925b3da/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7c86a9c05c576211932da47c1c3d89ccc925b3da", "patch": "@@ -16,12 +16,13 @@ use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n use crate::syntax::source_map::{BytePos, Span};\n+use crate::syntax::symbol::LocalInternedString;\n use crate::utils::paths;\n use crate::utils::sugg;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n-    match_var, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_macro_callsite, span_lint,\n+    match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_macro_callsite, span_lint,\n     span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n@@ -790,63 +791,42 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n \n+        let (method_names, arg_lists) = method_calls(expr, 2);\n+        let method_names: Vec<LocalInternedString> = method_names.iter().map(|s| s.as_str()).collect();\n+        let method_names: Vec<&str> = method_names.iter().map(|s| s.as_ref()).collect();\n+\n+        match method_names.as_slice() {\n+            [\"unwrap\", \"get\"] => lint_get_unwrap(cx, expr, arg_lists[1], false),\n+            [\"unwrap\", \"get_mut\"] => lint_get_unwrap(cx, expr, arg_lists[1], true),\n+            [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n+            [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n+            [\"unwrap_or\", \"map\"] => lint_map_unwrap_or(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n+            [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n+            [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"flat_map\", \"filter\"] => lint_filter_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"flat_map\", \"filter_map\"] => lint_filter_map_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"flatten\", \"map\"] => lint_map_flatten(cx, expr, arg_lists[1]),\n+            [\"is_some\", \"find\"] => lint_search_is_some(cx, expr, \"find\", arg_lists[1], arg_lists[0]),\n+            [\"is_some\", \"position\"] => lint_search_is_some(cx, expr, \"position\", arg_lists[1], arg_lists[0]),\n+            [\"is_some\", \"rposition\"] => lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0]),\n+            [\"extend\", ..] => lint_extend(cx, expr, arg_lists[0]),\n+            [\"as_ptr\", \"unwrap\"] => lint_cstring_as_ptr(cx, expr, &arg_lists[1][0], &arg_lists[0][0]),\n+            [\"nth\", \"iter\"] => lint_iter_nth(cx, expr, arg_lists[1], false),\n+            [\"nth\", \"iter_mut\"] => lint_iter_nth(cx, expr, arg_lists[1], true),\n+            [\"next\", \"skip\"] => lint_iter_skip_next(cx, expr),\n+            [\"collect\", \"cloned\"] => lint_iter_cloned_collect(cx, expr, arg_lists[1]),\n+            [\"as_ref\", ..] => lint_asref(cx, expr, \"as_ref\", arg_lists[0]),\n+            [\"as_mut\", ..] => lint_asref(cx, expr, \"as_mut\", arg_lists[0]),\n+            [\"fold\", ..] => lint_unnecessary_fold(cx, expr, arg_lists[0]),\n+            [\"filter_map\", ..] => unnecessary_filter_map::lint(cx, expr, arg_lists[0]),\n+            _ => {}\n+        }\n+\n         match expr.node {\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n-                // Chain calls\n-                // GET_UNWRAP needs to be checked before general `UNWRAP` lints\n-                if let Some(arglists) = method_chain_args(expr, &[\"get\", \"unwrap\"]) {\n-                    lint_get_unwrap(cx, expr, arglists[0], false);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"get_mut\", \"unwrap\"]) {\n-                    lint_get_unwrap(cx, expr, arglists[0], true);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                    lint_unwrap(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n-                    lint_ok_expect(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n-                    lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n-                    lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"map_or\"]) {\n-                    lint_map_or_none(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n-                    lint_filter_next(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"map\"]) {\n-                    lint_filter_map(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\", \"map\"]) {\n-                    lint_filter_map_map(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"flat_map\"]) {\n-                    lint_filter_flat_map(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\", \"flat_map\"]) {\n-                    lint_filter_map_flat_map(cx, expr, arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"flatten\"]) {\n-                    lint_map_flatten(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n-                    lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n-                    lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n-                    lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"extend\"]) {\n-                    lint_extend(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"unwrap\", \"as_ptr\"]) {\n-                    lint_cstring_as_ptr(cx, expr, &arglists[0][0], &arglists[1][0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"iter\", \"nth\"]) {\n-                    lint_iter_nth(cx, expr, arglists[0], false);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"iter_mut\", \"nth\"]) {\n-                    lint_iter_nth(cx, expr, arglists[0], true);\n-                } else if method_chain_args(expr, &[\"skip\", \"next\"]).is_some() {\n-                    lint_iter_skip_next(cx, expr);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"cloned\", \"collect\"]) {\n-                    lint_iter_cloned_collect(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"as_ref\"]) {\n-                    lint_asref(cx, expr, \"as_ref\", arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"as_mut\"]) {\n-                    lint_asref(cx, expr, \"as_mut\", arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"fold\"]) {\n-                    lint_unnecessary_fold(cx, expr, arglists[0]);\n-                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\"]) {\n-                    unnecessary_filter_map::lint(cx, expr, arglists[0]);\n-                }\n \n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);"}, {"sha": "1cd20b684210c77a57ccd0fcb8016c56bcde0aa5", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c86a9c05c576211932da47c1c3d89ccc925b3da/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c86a9c05c576211932da47c1c3d89ccc925b3da/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7c86a9c05c576211932da47c1c3d89ccc925b3da", "patch": "@@ -31,7 +31,7 @@ use crate::syntax::ast::{self, LitKind};\n use crate::syntax::attr;\n use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::errors::DiagnosticBuilder;\n-use crate::syntax::symbol::keywords;\n+use crate::syntax::symbol::{keywords, Symbol};\n \n pub mod camel_case;\n \n@@ -274,6 +274,29 @@ pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::\n     cx.tables.qpath_def(qpath, id)\n }\n \n+/// Return the method names and argument list of nested method call expressions that make up\n+/// `expr`.\n+pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&'a [Expr]>) {\n+    let mut method_names = Vec::with_capacity(max_depth);\n+    let mut arg_lists = Vec::with_capacity(max_depth);\n+\n+    let mut current = expr;\n+    for _ in 0..max_depth {\n+        if let ExprKind::MethodCall(path, _, args) = &current.node {\n+            if args.iter().any(|e| in_macro(e.span)) {\n+                break;\n+            }\n+            method_names.push(path.ident.name);\n+            arg_lists.push(&**args);\n+            current = &args[0];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    (method_names, arg_lists)\n+}\n+\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,"}]}