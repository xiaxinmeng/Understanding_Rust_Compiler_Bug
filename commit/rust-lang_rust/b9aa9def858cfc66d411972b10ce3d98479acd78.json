{"sha": "b9aa9def858cfc66d411972b10ce3d98479acd78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YWE5ZGVmODU4Y2ZjNjZkNDExOTcyYjEwY2UzZDk4NDc5YWNkNzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-11T17:28:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-11T21:41:41Z"}, "message": "infer when types are region parameterized rather than requiring /&\n\n- removes various fields from various variants in the AST\n- also update tests not to use this notation", "tree": {"sha": "c65223b2926112a34427574cdd9c2feee6d06430", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c65223b2926112a34427574cdd9c2feee6d06430"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9aa9def858cfc66d411972b10ce3d98479acd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9aa9def858cfc66d411972b10ce3d98479acd78", "html_url": "https://github.com/rust-lang/rust/commit/b9aa9def858cfc66d411972b10ce3d98479acd78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9aa9def858cfc66d411972b10ce3d98479acd78/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b094c0baf4fa758c80fb9db8cc172f03789adbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b094c0baf4fa758c80fb9db8cc172f03789adbb", "html_url": "https://github.com/rust-lang/rust/commit/9b094c0baf4fa758c80fb9db8cc172f03789adbb"}], "stats": {"total": 989, "additions": 602, "deletions": 387}, "files": [{"sha": "f7e990b1025b59609e3a76439a6e6b990dfd79df", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -678,31 +678,24 @@ type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n-#[auto_serialize]\n-enum region_param {\n-    rp_none,\n-    rp_self\n-}\n-\n #[auto_serialize]\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, ~[ty_param], blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@ty, ~[ty_param], region_param),\n-    item_enum(~[variant], ~[ty_param], region_param),\n+    item_ty(@ty, ~[ty_param]),\n+    item_enum(~[variant], ~[ty_param]),\n     item_class(~[ty_param], /* ty params for class */\n                ~[@trait_ref],   /* traits this class implements */\n                ~[@class_member], /* methods, etc. */\n                                /* (not including ctor or dtor) */\n                class_ctor,\n                /* dtor is optional */\n-               option<class_dtor>,\n-               region_param\n+               option<class_dtor>\n                ),\n-    item_trait(~[ty_param], region_param, ~[ty_method]),\n-    item_impl(~[ty_param], region_param, option<@trait_ref> /* trait */,\n+    item_trait(~[ty_param], ~[ty_method]),\n+    item_impl(~[ty_param], option<@trait_ref> /* trait */,\n               @ty /* self */, ~[@method]),\n     item_mac(mac),\n }"}, {"sha": "129a03f71aa020e9533886bcae68d7860d04fcc5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -188,14 +188,14 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n-      item_impl(_, _, _, _, ms) {\n+      item_impl(_, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each |m| {\n             map_method(impl_did, extend(cx, i.ident), m,\n                        cx);\n         }\n       }\n-      item_enum(vs, _, _) {\n+      item_enum(vs, _) {\n         for vs.each |v| {\n             cx.map.insert(v.node.id, node_variant(\n                 /* FIXME (#2543) */ copy v, i,\n@@ -214,7 +214,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                                            extend(cx, i.ident)));\n         }\n       }\n-      item_class(tps, traits, items, ctor, dtor, _) {\n+      item_class(tps, traits, items, ctor, dtor) {\n           let (_, ms) = ast_util::split_class_items(items);\n           // Map trait refs to their parent classes. This is\n           // so we can find the self_ty"}, {"sha": "806f6c35ed04aa3456b399bc765800c743c43eac", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -155,7 +155,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n         alt it.node {\n-          item_enum(variants, _, _) {\n+          item_enum(variants, _) {\n             for variants.each |v| {\n                 if v.node.name == i {\n                    local = true;\n@@ -428,7 +428,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n             alt i.node {\n-              item_enum(vs, _, _) { for vs.each |v| { vfn(v.node.id); } }\n+              item_enum(vs, _) { for vs.each |v| { vfn(v.node.id); } }\n               _ {}\n             }\n         },\n@@ -519,6 +519,9 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n+        visit_ty_method: fn@(_ty_m: ty_method) {\n+        },\n+\n         visit_class_item: fn@(c: @class_member) {\n             alt c.node {\n               instance_var(_, _, _, id,_) {"}, {"sha": "6bbce757a92601a8e7b7d72d45f6ba6be300ee48", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -102,12 +102,12 @@ fn expand(cx: ext_ctxt,\n \n     do vec::flat_map(in_items) |in_item| {\n         alt in_item.node {\n-          ast::item_ty(ty, tps, _) {\n+          ast::item_ty(ty, tps) {\n             vec::append(~[filter_attrs(in_item)],\n                         ty_fns(cx, in_item.ident, ty, tps))\n           }\n \n-          ast::item_enum(variants, tps, _) {\n+          ast::item_enum(variants, tps) {\n             vec::append(~[filter_attrs(in_item)],\n                         enum_fns(cx, in_item.ident,\n                                  in_item.span, variants, tps))"}, {"sha": "ac0d507e61e038bfc3ebe0ca0ca722585d9be72b", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -128,8 +128,7 @@ impl ast_builder for ext_ctxt {\n                       +ty_params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name,\n                   ast::item_enum(variants,\n-                                 ty_params,\n-                                 ast::rp_none))\n+                                 ty_params))\n     }\n \n     fn item_enum(name: ident,\n@@ -167,12 +166,10 @@ impl ast_builder for ext_ctxt {\n     fn item_ty_poly(name: ident,\n                     ty: @ast::ty,\n                     +params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name,\n-                  ast::item_ty(ty, params, ast::rp_none))\n+        self.item(name, ast::item_ty(ty, params))\n     }\n \n-    fn item_ty(name: ident,\n-               ty: @ast::ty) -> @ast::item {\n+    fn item_ty(name: ident, ty: @ast::ty) -> @ast::item {\n         self.item_ty_poly(name, ty, ~[])\n     }\n "}, {"sha": "a78148b37c6e94b68d4b5e5480d3d3c0c7c7e68f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -244,15 +244,13 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_mod(m) { item_mod(fld.fold_mod(m)) }\n           item_foreign_mod(nm) { item_foreign_mod(fld.fold_foreign_mod(nm)) }\n-          item_ty(t, typms, rp) { item_ty(fld.fold_ty(t),\n-                                          fold_ty_params(typms, fld),\n-                                          rp) }\n-          item_enum(variants, typms, r) {\n+          item_ty(t, typms) { item_ty(fld.fold_ty(t),\n+                                      fold_ty_params(typms, fld)) }\n+          item_enum(variants, typms) {\n             item_enum(vec::map(variants, |x| fld.fold_variant(x)),\n-                      fold_ty_params(typms, fld),\n-                      r)\n+                      fold_ty_params(typms, fld))\n           }\n-          item_class(typms, traits, items, ctor, m_dtor, rp) {\n+          item_class(typms, traits, items, ctor, m_dtor) {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n@@ -269,18 +267,16 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                   {node: {body: ctor_body,\n                           dec: ctor_decl,\n                           id: ctor_id with ctor.node}\n-                      with ctor}, dtor, rp)\n+                      with ctor}, dtor)\n           }\n-          item_impl(tps, rp, ifce, ty, methods) {\n+          item_impl(tps, ifce, ty, methods) {\n               item_impl(fold_ty_params(tps, fld),\n-                        rp,\n                         ifce.map(|p| fold_trait_ref(p, fld)),\n                         fld.fold_ty(ty),\n                         vec::map(methods, |x| fld.fold_method(x)))\n           }\n-          item_trait(tps, rp, methods) {\n+          item_trait(tps, methods) {\n             item_trait(fold_ty_params(tps, fld),\n-                       rp,\n                        /* FIXME (#2543) */ copy methods)\n           }\n       item_mac(m) {"}, {"sha": "f4681ba26191935e7b0ce55dc2883fa43559ef22", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -41,8 +41,8 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              pat_box, pat_enum, pat_ident, pat_lit, pat_range, pat_rec,\n              pat_tup, pat_uniq, pat_wild, path, private, proto, proto_any,\n              proto_bare, proto_block, proto_box, proto_uniq, public, pure_fn,\n-             purity, re_anon, re_named, region, region_param, rem, ret_style,\n-             return_val, rp_none, rp_self, shl, shr, stmt, stmt_decl,\n+             purity, re_anon, re_named, region, rem, ret_style,\n+             return_val, shl, shr, stmt, stmt_decl,\n              stmt_expr, stmt_semi, subtract, token_tree, trait_ref, tt_delim,\n              tt_dotdotdot, tt_flat, tt_interpolate, ty, ty_, ty_bot, ty_box,\n              ty_constr, ty_constr_, ty_constr_arg, ty_field, ty_fn, ty_infer,\n@@ -2133,10 +2133,10 @@ class parser {\n \n     fn parse_item_trait() -> item_info {\n         let ident = self.parse_ident();\n-        let rp = self.parse_region_param();\n+        self.parse_region_param();\n         let tps = self.parse_ty_params();\n         let meths = self.parse_ty_methods();\n-        (ident, item_trait(tps, rp, meths), none)\n+        (ident, item_trait(tps, meths), none)\n     }\n \n     // Parses three variants (with the region/type params always optional):\n@@ -2147,18 +2147,19 @@ class parser {\n         fn wrap_path(p: parser, pt: @path) -> @ty {\n             @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n         }\n-        let mut (ident, rp, tps) = {\n+        let mut (ident, tps) = {\n             if self.token == token::LT {\n-                (none, rp_none, self.parse_ty_params())\n+                (none, self.parse_ty_params())\n             } else if self.token == token::BINOP(token::SLASH) {\n-                (none, self.parse_region_param(), self.parse_ty_params())\n+                self.parse_region_param();\n+                (none, self.parse_ty_params())\n             }\n             else if self.is_keyword(\"of\") {\n-                (none, rp_none, ~[])\n+                (none, ~[])\n             } else {\n                 let id = self.parse_ident();\n-                let rp = self.parse_region_param();\n-                (some(id), rp, self.parse_ty_params())\n+                self.parse_region_param();\n+                (some(id), self.parse_ty_params())\n             }\n         };\n         let ifce = if self.eat_keyword(\"of\") {\n@@ -2179,25 +2180,18 @@ class parser {\n         while !self.eat(token::RBRACE) {\n             vec::push(meths, self.parse_method(public));\n         }\n-        (ident, item_impl(tps, rp, ifce, ty, meths), none)\n+        (ident, item_impl(tps, ifce, ty, meths), none)\n     }\n \n     // Instantiates ident <i> with references to <typarams> as arguments.\n     // Used to create a path that refers to a class which will be defined as\n     // the return type of the ctor function.\n     fn ident_to_path_tys(i: ident,\n-                         rp: region_param,\n                          typarams: ~[ty_param]) -> @path {\n         let s = self.last_span;\n \n-        // Hack.  But then, this whole function is in service of a hack.\n-        let a_r = alt rp {\n-          rp_none { none }\n-          rp_self { some(self.region_from_name(some(@\"self\"))) }\n-        };\n-\n         @{span: s, global: false, idents: ~[i],\n-          rp: a_r,\n+          rp: none,\n           types: vec::map(typarams, |tp| {\n               @{id: self.get_id(),\n                 node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n@@ -2218,9 +2212,9 @@ class parser {\n \n     fn parse_item_class() -> item_info {\n         let class_name = self.parse_value_ident();\n-        let rp = self.parse_region_param();\n+        self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n-        let class_path = self.ident_to_path_tys(class_name, rp, ty_params);\n+        let class_path = self.ident_to_path_tys(class_name, ty_params);\n         let traits : ~[@trait_ref] = if self.eat(token::COLON)\n             { self.parse_trait_ref_list() }\n         else { ~[] };\n@@ -2255,7 +2249,7 @@ class parser {\n                         self_id: self.get_id(),\n                         dec: ct_d,\n                         body: ct_b},\n-                 span: ct_s}, actual_dtor, rp),\n+                 span: ct_s}, actual_dtor),\n              none)\n           }\n           /*\n@@ -2447,26 +2441,23 @@ class parser {\n \n     fn parse_item_type() -> item_info {\n         let t = self.parse_type_decl();\n-        let rp = self.parse_region_param();\n+        self.parse_region_param();\n         let tps = self.parse_ty_params();\n         self.expect(token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(token::SEMI);\n-        (t.ident, item_ty(ty, tps, rp), none)\n+        (t.ident, item_ty(ty, tps), none)\n     }\n \n-    fn parse_region_param() -> region_param {\n+    fn parse_region_param() {\n         if self.eat(token::BINOP(token::SLASH)) {\n             self.expect(token::BINOP(token::AND));\n-            rp_self\n-        } else {\n-            rp_none\n         }\n     }\n \n     fn parse_item_enum(default_vis: visibility) -> item_info {\n         let id = self.parse_ident();\n-        let rp = self.parse_region_param();\n+        self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         let mut variants: ~[variant] = ~[];\n         // Newtype syntax\n@@ -2483,7 +2474,7 @@ class parser {\n                          id: self.get_id(),\n                          disr_expr: none,\n                          vis: public});\n-            ret (id, item_enum(~[variant], ty_params, rp), none);\n+            ret (id, item_enum(~[variant], ty_params), none);\n         }\n         self.expect(token::LBRACE);\n \n@@ -2521,7 +2512,7 @@ class parser {\n             self.fatal(\"discriminator values can only be used with a c-like \\\n                         enum\");\n         }\n-        (id, item_enum(variants, ty_params, rp), none)\n+        (id, item_enum(variants, ty_params), none)\n     }\n \n     fn parse_fn_ty_proto() -> proto {"}, {"sha": "7e7dff4de12998583596abfc104a7d0f58db363f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -458,12 +458,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, params, rp) {\n+      ast::item_ty(ty, params) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n         word(s.s, *item.ident);\n-        print_region_param(s, rp);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n@@ -473,7 +472,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, \";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(variants, params, rp) {\n+      ast::item_enum(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n                 str::eq(*item.ident, *variants[0].node.name) &&\n@@ -483,7 +482,6 @@ fn print_item(s: ps, &&item: @ast::item) {\n             word_space(s, \"enum\");\n         } else { head(s, \"enum\"); }\n         word(s.s, *item.ident);\n-        print_region_param(s, rp);\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n@@ -506,10 +504,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps, traits, items, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, items, ctor, m_dtor) {\n           head(s, \"class\");\n           word_nbsp(s, *item.ident);\n-          print_region_param(s, rp);\n           print_type_params(s, tps);\n           if vec::len(traits) != 0u {\n               word_space(s, \":\");\n@@ -571,10 +568,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n           }\n           bclose(s, item.span);\n        }\n-      ast::item_impl(tps, rp, ifce, ty, methods) {\n+      ast::item_impl(tps, ifce, ty, methods) {\n         head(s, \"impl\");\n         word(s.s, *item.ident);\n-        print_region_param(s, rp);\n         print_type_params(s, tps);\n         space(s.s);\n         option::iter(ifce, |p| {\n@@ -591,10 +587,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_trait(tps, rp, methods) {\n+      ast::item_trait(tps, methods) {\n         head(s, \"iface\");\n         word(s.s, *item.ident);\n-        print_region_param(s, rp);\n         print_type_params(s, tps);\n         word(s.s, \" \");\n         bopen(s);\n@@ -1406,13 +1401,6 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     }\n }\n \n-fn print_region_param(s: ps, rp: ast::region_param) {\n-    alt rp {\n-      ast::rp_self { word(s.s, \"/&\") }\n-      ast::rp_none { }\n-    }\n-}\n-\n fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");"}, {"sha": "5dc42fd4823e112f4e32639d04ec53d28e14006c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -61,6 +61,7 @@ type visitor<E> =\n       visit_ty_params: fn@(~[ty_param], E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n+      visit_ty_method: fn@(ty_method, E, vt<E>),\n       visit_class_item: fn@(@class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n@@ -79,6 +80,7 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n           visit_constr: |a,b,c,d,e|visit_constr::<E>(a, b, c, d, e),\n           visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n+          visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n           visit_class_item: |a,b,c|visit_class_item::<E>(a, b, c)};\n }\n \n@@ -125,25 +127,25 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         for nm.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n         for nm.items.each |ni| { v.visit_foreign_item(ni, e, v); }\n       }\n-      item_ty(t, tps, rp) {\n+      item_ty(t, tps) {\n         v.visit_ty(t, e, v);\n         v.visit_ty_params(tps, e, v);\n       }\n-      item_enum(variants, tps, _) {\n+      item_enum(variants, tps) {\n         v.visit_ty_params(tps, e, v);\n         for variants.each |vr| {\n             for vr.node.args.each |va| { v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_impl(tps, _rp, ifce, ty, methods) {\n+      item_impl(tps, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n         option::iter(ifce, |p| visit_path(p.path, e, v));\n         v.visit_ty(ty, e, v);\n         for methods.each |m| {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, traits, members, ctor, m_dtor, _) {\n+      item_class(tps, traits, members, ctor, m_dtor) {\n           v.visit_ty_params(tps, e, v);\n           for members.each |m| {\n              v.visit_class_item(m, e, v);\n@@ -155,12 +157,10 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                   visit_class_dtor_helper(dtor, tps,\n                      ast_util::local_def(i.id), e, v)};\n       }\n-      item_trait(tps, _rp, methods) {\n+      item_trait(tps, methods) {\n         v.visit_ty_params(tps, e, v);\n         for methods.each |m| {\n-            for m.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n-            v.visit_ty_params(m.tps, e, v);\n-            v.visit_ty(m.decl.output, e, v);\n+            v.visit_ty_method(m, e, v);\n         }\n       }\n       item_mac(m) { visit_mac(m, e, v) }\n@@ -311,6 +311,12 @@ fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n     v.visit_block(body, e, v);\n }\n \n+fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n+    for m.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n+    v.visit_ty_params(m.tps, e, v);\n+    v.visit_ty(m.decl.output, e, v);\n+}\n+\n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n     for b.node.stmts.each |s| { v.visit_stmt(s, e, v); }\n@@ -458,6 +464,7 @@ type simple_visitor =\n       visit_ty_params: fn@(~[ty_param]),\n       visit_constr: fn@(@path, span, node_id),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n+      visit_ty_method: fn@(ty_method),\n       visit_class_item: fn@(@class_member)};\n \n fn simple_ignore_ty(_t: @ty) {}\n@@ -479,6 +486,7 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_constr: fn@(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                         _id: node_id) { },\n+          visit_ty_method: fn@(_m: ty_method) { },\n           visit_class_item: fn@(_c: @class_member) {}\n          };\n }\n@@ -534,6 +542,10 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n+    fn v_ty_method(f: fn@(ty_method), ty: ty_method, &&e: (), v: vt<()>) {\n+        f(ty);\n+        visit_ty_method(ty, e, v);\n+    }\n     fn v_ty_params(f: fn@(~[ty_param]),\n                    ps: ~[ty_param],\n                    &&e: (), v: vt<()>) {\n@@ -582,6 +594,8 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                     v_constr(v.visit_constr, a, b, c, d, e),\n                 visit_fn: |a,b,c,d,e,f,g|\n                     v_fn(v.visit_fn, a, b, c, d, e, f, g),\n+                visit_ty_method: |a,b,c|\n+                    v_ty_method(v.visit_ty_method, a, b, c),\n                 visit_class_item: |a,b,c|\n                     v_class_item(v.visit_class_item, a, b, c)\n                });"}, {"sha": "cec72045bcafab0e7bc1a5b12605a9254c1ecdde", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -178,7 +178,11 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let region_map = time(time_passes, \"region resolution\", ||\n         middle::region::resolve_crate(sess, def_map, crate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars, region_map);\n+    let rp_set = time(time_passes, \"region paramerization inference\", ||\n+        middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set);\n \n     let (method_map, vtable_map) = time(time_passes, \"typechecking\", ||\n                                         typeck::check_crate(ty_cx,"}, {"sha": "be21555a1d7390dd7fb1e46b10c08b15d404a920", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -38,6 +38,7 @@ const no_rt: uint = 256u;\n const coherence: uint = 512u;\n const borrowck_stats: uint = 1024u;\n const borrowck_note_pure: uint = 2048;\n+const borrowck_note_loan: uint = 4096;\n \n fn debugging_opts_map() -> ~[(str, str, uint)] {\n     ~[(\"ppregions\", \"prettyprint regions with \\\n@@ -46,15 +47,17 @@ fn debugging_opts_map() -> ~[(str, str, uint)] {\n      (\"count-llvm-insns\", \"count where LLVM \\\n                            instrs originate\", count_llvm_insns),\n      (\"time-llvm-passes\", \"measure time of each LLVM pass\", time_llvm_passes),\n-     (\"stats\", \"gather trans statistics\", stats),\n+     (\"trans-stats\", \"gather trans statistics\", trans_stats),\n      (\"no-asm-comments\", \"omit comments when using -S\", no_asm_comments),\n      (\"no-verify\", \"skip LLVM verification\", no_verify),\n      (\"trace\", \"emit trace logs\", trace),\n      (\"no-rt\", \"do not link to the runtime\", no_rt),\n      (\"coherence\", \"perform coherence checking\", coherence),\n      (\"borrowck-stats\", \"gather borrowck statistics\",  borrowck_stats),\n      (\"borrowck-note-pure\", \"note where purity is req'd\",\n-      borrowck_note_pure)\n+      borrowck_note_pure),\n+     (\"borrowck-note-loan\", \"note where loans are req'd\",\n+      borrowck_note_loan)\n     ]\n }\n \n@@ -172,6 +175,7 @@ impl session for session {\n     fn coherence() -> bool { self.debugging_opt(coherence) }\n     fn borrowck_stats() -> bool { self.debugging_opt(borrowck_stats) }\n     fn borrowck_note_pure() -> bool { self.debugging_opt(borrowck_note_pure) }\n+    fn borrowck_note_loan() -> bool { self.debugging_opt(borrowck_note_loan) }\n }\n \n /// Some reasonable defaults"}, {"sha": "16b2481edd9b272d43f543015a25cffdacb614c3", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -17,6 +17,7 @@ export get_class_fields;\n export get_class_method;\n export get_field_type;\n export get_type_param_count;\n+export get_region_param;\n export lookup_defs;\n export lookup_method_purity;\n export get_enum_variants;\n@@ -151,6 +152,12 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n+fn get_region_param(cstore: metadata::cstore::cstore,\n+                    def: ast::def_id) -> bool {\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    ret decoder::get_region_param(cdata, def.node);\n+}\n+\n fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n@@ -168,7 +175,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def) );\n     #debug(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    ret {bounds: @~[], rp: ast::rp_none, ty: ty};\n+    ret {bounds: @~[], rp: false, ty: ty};\n }\n \n // Given a def_id for an impl or class, return the trait it implements,"}, {"sha": "fd2eb10d8d51dbef8becadcd0f533d6cd761cfcd", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -21,6 +21,7 @@ export get_class_fields;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n+export get_region_param;\n export get_type_param_count;\n export get_impl_trait;\n export get_class_method;\n@@ -185,15 +186,10 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::doc) -> ast::region_param {\n+fn item_ty_region_param(item: ebml::doc) -> bool {\n     alt ebml::maybe_get_doc(item, tag_region_param) {\n-      some(rp_doc) {\n-        let dsr = ebml::ebml_deserializer(rp_doc);\n-        ast::deserialize_region_param(dsr)\n-      }\n-      none { // not all families of items have region params\n-        ast::rp_none\n-      }\n+      some(_) { true }\n+      none { false }\n     }\n }\n \n@@ -325,6 +321,11 @@ fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     ret {bounds: tp_bounds, rp: rp, ty: t};\n }\n \n+fn get_region_param(cdata: cmd, id: ast::node_id) -> bool {\n+    let item = lookup_item(id, cdata.data);\n+    ret item_ty_region_param(item);\n+}\n+\n fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }"}, {"sha": "7539d2be00bf82d47443402cda07793bd24beaae", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -86,10 +86,10 @@ fn encode_name_and_def_id(ebml_w: ebml::writer, nm: ident,\n     encode_def_id(ebml_w, local_def(id));\n }\n \n-fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n-    do ebml_w.wr_tag(tag_region_param) {\n-        serialize_region_param(ebml_w, rp)\n-    }\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                       it: @ast::item) {\n+    let rp = ecx.tcx.region_paramd_items.contains_key(it.id);\n+    if rp { do ebml_w.wr_tag(tag_region_param) { } }\n }\n \n fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n@@ -188,12 +188,12 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                   vec::append_one(path, it.ident), index);\n             }\n           }\n-          item_ty(_, tps, _) {\n+          item_ty(_, tps) {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n-          item_class(_, _, items, ctor, m_dtor, _) {\n+          item_class(_, _, items, ctor, m_dtor) {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n@@ -208,7 +208,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                                         index);\n             }\n           }\n-          item_enum(variants, _, _) {\n+          item_enum(variants, _) {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n@@ -406,7 +406,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n             ref, we need to map it to its parent class */\n                 ebml_w.wr_str(def_to_str(local_def(it.id)));\n               }\n-              some(ast_map::node_item(@{node: item_impl(_,_,\n+              some(ast_map::node_item(@{node: item_impl(_,\n                                                    some(ifce),_,_),_},_)) {\n                 ebml_w.wr_str(def_to_str(did));\n               }\n@@ -550,7 +550,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n     let tcx = ecx.tcx;\n     let must_write =\n-        alt item.node { item_enum(_, _, _) { true } _ { false } };\n+        alt item.node { item_enum(_, _) { true } _ { false } };\n     if !must_write && !reachable(ecx, item.id) { ret; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n@@ -598,7 +598,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_ty(_, tps, rp) {\n+      item_ty(_, tps) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -607,10 +607,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ebml_w, rp);\n+        encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(variants, tps, rp) {\n+      item_enum(variants, tps) {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n@@ -623,12 +623,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             }\n             ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n             encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-            encode_region_param(ebml_w, rp);\n+            encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, traits, items, ctor, m_dtor, rp) {\n+      item_class(tps, traits, items, ctor, m_dtor) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -655,7 +655,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ebml_w, rp);\n+        encode_region_param(ecx, ebml_w, item);\n         for traits.each |t| {\n            encode_trait_ref(ebml_w, ecx, t);\n         }\n@@ -704,12 +704,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, rp, ifce, _, methods) {\n+      item_impl(tps, ifce, _, methods) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n-        encode_region_param(ebml_w, rp);\n+        encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -733,12 +733,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                    vec::append(tps, m.tps));\n         }\n       }\n-      item_trait(tps, rp, ms) {\n+      item_trait(tps, ms) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n-        encode_region_param(ebml_w, rp);\n+        encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -801,7 +801,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                   item_class(tps, _, _, ctor, m_dtor, _) {\n+                   item_class(tps, _, _, ctor, m_dtor) {\n                    #debug(\"encoding info for ctor %s %d\", *i.ident,\n                           ctor.node.id);\n                    vec::push(*index,"}, {"sha": "a4810e77b56da7344e4c917284eeb0dfa4b0de21", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -554,11 +554,11 @@ impl helpers for ebml::writer {\n         do self.emit_rec {\n             do self.emit_rec_field(\"bounds\", 0u) {\n                 do self.emit_from_vec(*tpbt.bounds) |bs| {\n-                    self.emit_bounds(ecx, bs)\n+                    self.emit_bounds(ecx, bs);\n                 }\n             }\n             do self.emit_rec_field(\"rp\", 1u) {\n-                ast::serialize_region_param(self, tpbt.rp)\n+                self.emit_bool(tpbt.rp);\n             }\n             do self.emit_rec_field(\"ty\", 2u) {\n                 self.emit_ty(ecx, tpbt.ty);\n@@ -759,7 +759,7 @@ impl decoder for ebml::ebml_deserializer {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n                 rp: self.read_rec_field(\"rp\", 1u, || {\n-                    ast::deserialize_region_param(self)\n+                    self.read_bool()\n                 }),\n                 ty: self.read_rec_field(\"ty\", 2u, || {\n                     self.read_ty(xcx)"}, {"sha": "ddbd78b631c55a940ea9cc3107d8936743981b70", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -199,6 +199,12 @@ impl methods for gather_loan_ctxt {\n \n                 if req_mutbl == m_imm && cmt.mutbl != m_imm {\n                     self.bccx.loaned_paths_imm += 1;\n+\n+                    if self.tcx().sess.borrowck_note_loan() {\n+                        self.bccx.span_note(\n+                            cmt.span,\n+                            #fmt[\"immutable loan required\"]);\n+                    }\n                 } else {\n                     self.bccx.loaned_paths_same += 1;\n                 }"}, {"sha": "54b10d5566d7fa72533e36759bc0d8633c61dcd3", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -24,7 +24,7 @@ fn check_item(sess: session, ast_map: ast_map::map, def_map: resolve::def_map,\n         v.visit_expr(ex, true, v);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n-      item_enum(vs, _, _) {\n+      item_enum(vs, _) {\n         for vs.each |var| {\n             do option::iter(var.node.disr_expr) |ex| {\n                 v.visit_expr(ex, true, v);"}, {"sha": "ff8377fa374692209cd348f75618375a23ca51f3", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 210, "deletions": 3, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -138,11 +138,13 @@ import syntax::{ast, visit};\n import syntax::codemap::span;\n import syntax::print::pprust;\n import syntax::ast_util::new_def_hash;\n+import syntax::ast_map;\n+import dvec::{dvec, extensions};\n+import metadata::csearch;\n \n import std::list;\n import std::list::list;\n-import std::map;\n-import std::map::hashmap;\n+import std::map::{hashmap, int_hash};\n \n type parent = option<ast::node_id>;\n \n@@ -386,7 +388,7 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n         -> region_map {\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n-                    region_map: map::int_hash(),\n+                    region_map: int_hash(),\n                     parent: none};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n@@ -402,3 +404,208 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n     ret cx.region_map;\n }\n \n+// ___________________________________________________________________________\n+// Determining region parameterization\n+//\n+// Infers which type defns must be region parameterized---this is done\n+// by scanning their contents to see whether they reference a region\n+// type, directly or indirectly.  This is a fixed-point computation.\n+//\n+// We do it in two passes.  First we walk the AST and construct a map\n+// from each type defn T1 to other defns which make use of it.  For example,\n+// if we have a type like:\n+//\n+//    type S = *int;\n+//    type T = S;\n+//\n+// Then there would be a map entry from S to T.  During the same walk,\n+// we also construct add any types that reference regions to a set and\n+// a worklist.  We can then process the worklist, propagating indirect\n+// dependencies until a fixed point is reached.\n+\n+type region_paramd_items = hashmap<ast::node_id, ()>;\n+type dep_map = hashmap<ast::node_id, @dvec<ast::node_id>>;\n+\n+type determine_rp_ctxt = @{\n+    sess: session,\n+    ast_map: ast_map::map,\n+    def_map: resolve::def_map,\n+    region_paramd_items: region_paramd_items,\n+    dep_map: dep_map,\n+    worklist: dvec<ast::node_id>,\n+\n+    mut item_id: ast::node_id,\n+    mut anon_implies_rp: bool\n+};\n+\n+impl methods for determine_rp_ctxt {\n+    fn add_rp(id: ast::node_id) {\n+        assert id != 0;\n+        if self.region_paramd_items.insert(id, ()) {\n+            #debug[\"add region-parameterized item: %d (%s)\",\n+                   id, ast_map::node_id_to_str(self.ast_map, id)];\n+            self.worklist.push(id);\n+        } else {\n+            #debug[\"item %d already region-parameterized\", id];\n+        }\n+    }\n+\n+    fn add_dep(from: ast::node_id, to: ast::node_id) {\n+        #debug[\"add dependency from %d -> %d (%s -> %s)\",\n+               from, to,\n+               ast_map::node_id_to_str(self.ast_map, from),\n+               ast_map::node_id_to_str(self.ast_map, to)];\n+        let vec = alt self.dep_map.find(from) {\n+            some(vec) => {vec}\n+            none => {\n+                let vec = @dvec();\n+                self.dep_map.insert(from, vec);\n+                vec\n+            }\n+        };\n+        if !vec.contains(to) { vec.push(to); }\n+    }\n+\n+    fn region_is_relevant(r: @ast::region) -> bool {\n+        alt r.node {\n+          ast::re_anon {self.anon_implies_rp}\n+          ast::re_named(@\"self\") {true}\n+          ast::re_named(_) {false}\n+        }\n+    }\n+\n+    fn with(item_id: ast::node_id, anon_implies_rp: bool, f: fn()) {\n+        let old_item_id = self.item_id;\n+        let old_anon_implies_rp = self.anon_implies_rp;\n+        self.item_id = item_id;\n+        self.anon_implies_rp = anon_implies_rp;\n+        #debug[\"with_item_id(%d, %b)\", item_id, anon_implies_rp];\n+        let _i = util::common::indenter();\n+        f();\n+        self.item_id = old_item_id;\n+        self.anon_implies_rp = old_anon_implies_rp;\n+    }\n+}\n+\n+fn determine_rp_in_item(item: @ast::item,\n+                        &&cx: determine_rp_ctxt,\n+                        visitor: visit::vt<determine_rp_ctxt>) {\n+    do cx.with(item.id, true) {\n+        visit::visit_item(item, cx, visitor);\n+    }\n+}\n+\n+fn determine_rp_in_fn(fk: visit::fn_kind,\n+                      decl: ast::fn_decl,\n+                      body: ast::blk,\n+                      sp: span,\n+                      id: ast::node_id,\n+                      &&cx: determine_rp_ctxt,\n+                      visitor: visit::vt<determine_rp_ctxt>) {\n+    do cx.with(cx.item_id, false) {\n+        visit::visit_fn(fk, decl, body, sp, id, cx, visitor);\n+    }\n+}\n+\n+fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n+                             &&cx: determine_rp_ctxt,\n+                             visitor: visit::vt<determine_rp_ctxt>) {\n+    do cx.with(cx.item_id, false) {\n+        visit::visit_ty_method(ty_m, cx, visitor);\n+    }\n+}\n+\n+fn determine_rp_in_ty(ty: @ast::ty,\n+                      &&cx: determine_rp_ctxt,\n+                      visitor: visit::vt<determine_rp_ctxt>) {\n+\n+    // we are only interesting in types that will require an item to\n+    // be region-parameterized.  if cx.item_id is zero, then this type\n+    // is not a member of a type defn nor is it a constitutent of an\n+    // impl etc.  So we can ignore it and its components.\n+    if cx.item_id == 0 { ret; }\n+\n+    // if this type directly references a region, either via a\n+    // region pointer like &r.ty or a region-parameterized path\n+    // like path/r, add to the worklist/set\n+    alt ty.node {\n+      ast::ty_rptr(r, _) |\n+      ast::ty_path(@{rp: some(r), _}, _) |\n+      ast::ty_vstore(_, ast::vstore_slice(r)) => {\n+        #debug[\"referenced type with regions %s\", pprust::ty_to_str(ty)];\n+        if cx.region_is_relevant(r) {\n+            cx.add_rp(cx.item_id);\n+        }\n+      }\n+\n+      _ => {}\n+    }\n+\n+    // if this references another named type, add the dependency\n+    // to the dep_map.  If the type is not defined in this crate,\n+    // then check whether it is region-parameterized and consider\n+    // that as a direct dependency.\n+    alt ty.node {\n+      ast::ty_path(_, id) {\n+        alt cx.def_map.get(id) {\n+          ast::def_ty(did) | ast::def_class(did) {\n+            if did.crate == ast::local_crate {\n+                cx.add_dep(did.node, cx.item_id);\n+            } else {\n+                let cstore = cx.sess.cstore;\n+                if csearch::get_region_param(cstore, did) {\n+                    #debug[\"reference to external, rp'd type %s\",\n+                           pprust::ty_to_str(ty)];\n+                    cx.add_rp(cx.item_id);\n+                }\n+            }\n+          }\n+          _ {}\n+        }\n+      }\n+      _ {}\n+    }\n+\n+    visit::visit_ty(ty, cx, visitor);\n+}\n+\n+fn determine_rp_in_crate(sess: session,\n+                         ast_map: ast_map::map,\n+                         def_map: resolve::def_map,\n+                         crate: @ast::crate) -> region_paramd_items {\n+    let cx = @{sess: sess,\n+               ast_map: ast_map,\n+               def_map: def_map,\n+               region_paramd_items: int_hash(),\n+               dep_map: int_hash(),\n+               worklist: dvec(),\n+               mut item_id: 0,\n+               mut anon_implies_rp: false};\n+\n+    // gather up the base set, worklist and dep_map:\n+    let visitor = visit::mk_vt(@{\n+        visit_fn: determine_rp_in_fn,\n+        visit_item: determine_rp_in_item,\n+        visit_ty: determine_rp_in_ty,\n+        visit_ty_method: determine_rp_in_ty_method,\n+        with *visit::default_visitor()\n+    });\n+    visit::visit_crate(*crate, cx, visitor);\n+\n+    // propagate indirect dependencies\n+    while cx.worklist.len() != 0 {\n+        let id = cx.worklist.pop();\n+        #debug[\"popped %d from worklist\", id];\n+        alt cx.dep_map.find(id) {\n+          none {}\n+          some(vec) {\n+            for vec.each |to_id| {\n+                cx.add_rp(to_id);\n+            }\n+          }\n+        }\n+    }\n+\n+    // return final set\n+    ret cx.region_paramd_items;\n+}\n\\ No newline at end of file"}, {"sha": "f2eea665522c4860955610e10b2471f936fe8bf5", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -439,10 +439,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           /* At this point, the code knows what traits the trait refs\n              refer to, so it's possible to resolve them.\n            */\n-          ast::item_impl(_, _, ifce, _, _) {\n+          ast::item_impl(_, ifce, _, _) {\n             ifce.iter(|p| resolve_trait_ref(p, sc, e))\n           }\n-          ast::item_class(_, traits, _, _, _, _) {\n+          ast::item_class(_, traits, _, _, _) {\n             for traits.each |p| {\n                resolve_trait_ref(p, sc, e);\n             }\n@@ -552,7 +552,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n \n     let sc = @cons(scope_item(i), sc);\n     alt i.node {\n-      ast::item_impl(tps, _, ifce, sty, methods) {\n+      ast::item_impl(tps, ifce, sty, methods) {\n         v.visit_ty_params(tps, sc, v);\n         option::iter(ifce, |p| visit::visit_path(p.path, sc, v));\n         v.visit_ty(sty, sc, v);\n@@ -564,7 +564,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n                        m.decl, m.body, m.span, m.id, msc, v);\n         }\n       }\n-      ast::item_trait(tps, _, methods) {\n+      ast::item_trait(tps, methods) {\n         v.visit_ty_params(tps, sc, v);\n         let isc = @cons(scope_method(i.id, tps), sc);\n         for methods.each |m| {\n@@ -574,7 +574,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n-      ast::item_class(tps, traits, members, ctor, m_dtor, _) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor) {\n         v.visit_ty_params(tps, sc, v);\n         let class_scope = @cons(scope_item(i), sc);\n         /* visit the constructor... */\n@@ -1042,13 +1042,13 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n           }\n           scope_item(it) {\n             alt it.node {\n-              ast::item_impl(tps, _, _, _, _) {\n+              ast::item_impl(tps, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_enum(_, tps, _) | ast::item_ty(_, tps, _) {\n+              ast::item_enum(_, tps) | ast::item_ty(_, tps) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_trait(tps, _, _) {\n+              ast::item_trait(tps, _) {\n                 if ns == ns_type {\n                     if *name == \"self\" {\n                         ret some(def_self(it.id));\n@@ -1062,7 +1062,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n               ast::item_foreign_mod(m) {\n                 ret lookup_in_local_foreign_mod(e, it.id, sp, name, ns);\n               }\n-              ast::item_class(tps, _, members, ctor, _, _) {\n+              ast::item_class(tps, _, members, ctor, _) {\n                   if ns == ns_type {\n                       ret lookup_in_ty_params(e, name, tps);\n                   }\n@@ -1234,7 +1234,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_enum(variants, _, _) {\n+                  ast::item_enum(variants, _) {\n                     if ns == ns_type {\n                         if str::eq(*it.ident, *name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n@@ -1339,7 +1339,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       ast::item_ty(*) | item_trait(*) | item_enum(*) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n-      ast::item_class(_, _, _members, ct, _, _) {\n+      ast::item_class(_, _, _members, ct, _) {\n           alt ns {\n              ns_type {\n                ret some(ast::def_class(local_def(i.id)));\n@@ -1641,11 +1641,11 @@ fn index_mod(md: ast::_mod) -> mod_index {\n     for md.items.each |it| {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n-          ast::item_foreign_mod(_) | ast::item_ty(_, _, _) |\n+          ast::item_foreign_mod(_) | ast::item_ty(_, _) |\n           ast::item_impl(*) | ast::item_trait(*) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n-          ast::item_enum(variants, _, _) {\n+          ast::item_enum(variants, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let mut variant_idx: uint = 0u;\n             for variants.each |v| {\n@@ -1655,7 +1655,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                 variant_idx += 1u;\n             }\n           }\n-          ast::item_class(tps, _, items, ctor, _, _) {\n+          ast::item_class(tps, _, items, ctor, _) {\n               // add the class name itself\n               add_to_index(index, it.ident, mie_item(it));\n           }\n@@ -1780,15 +1780,15 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n                       \"type parameter\");\n       }\n-      ast::item_enum(_, ty_params, _) {\n+      ast::item_enum(_, ty_params) {\n         ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n                       \"type parameter\");\n       }\n-      ast::item_trait(_, _, methods) {\n+      ast::item_trait(_, methods) {\n         ensure_unique(*e, i.span, methods, |m| m.ident,\n                       \"method\");\n       }\n-      ast::item_impl(_, _, _, _, methods) {\n+      ast::item_impl(_, _, _, methods) {\n         ensure_unique(*e, i.span, methods, |m| m.ident,\n                       \"method\");\n       }\n@@ -1854,7 +1854,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_enum(variants, _, _) {\n+                  ast::item_enum(variants, _) {\n                     add_name(types, it.span, it.ident);\n                     for variants.each |v| {\n                         add_name(values, v.span, v.node.name);\n@@ -2051,7 +2051,7 @@ fn check_exports(e: @env) {\n           some(ms) {\n             let maybe_id = do list_search(ms) |m| {\n                 alt m {\n-                  mie_item(@{node: item_enum(_, _, _), id, _}) { some(id) }\n+                  mie_item(@{node: item_enum(_, _), id, _}) { some(id) }\n                   _ { none }\n                 }\n             };\n@@ -2242,7 +2242,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n                       name: option<ident>,\n                       ck_exports: option<@indexed_mod>) {\n     alt i.node {\n-      ast::item_impl(_, _, ifce, _, mthds) {\n+      ast::item_impl(_, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports {\n              some(m) { is_exported(e, i.ident, m) }\n@@ -2257,7 +2257,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n                         })});\n         }\n       }\n-      ast::item_class(tps, ifces, items, _, _, _) {\n+      ast::item_class(tps, ifces, items, _, _) {\n           let (_, mthds) = ast_util::split_class_items(items);\n           let n_tps = tps.len();\n         do vec::iter(ifces) |p| {"}, {"sha": "9c129dd673be1e90a2476936ddf64820572f7ad5", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -847,7 +847,7 @@ class Resolver {\n             }\n \n             // These items live in both the type and value namespaces.\n-            item_enum(variants, _, _) {\n+            item_enum(variants, _) {\n                 (*name_bindings).define_type(def_ty(local_def(item.id)));\n \n                 for variants.each |variant| {\n@@ -857,7 +857,7 @@ class Resolver {\n                                                          visitor);\n                 }\n             }\n-            item_class(_, _, class_members, ctor, _, _) {\n+            item_class(_, _, class_members, ctor, _) {\n                 (*name_bindings).define_type(def_ty(local_def(item.id)));\n \n                 let purity = ctor.node.dec.purity;\n@@ -899,7 +899,7 @@ class Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(_, _, _, _, methods) {\n+            item_impl(_, _, _, methods) {\n                 // Create the set of implementation information that the\n                 // implementation scopes (ImplScopes) need and write it into\n                 // the implementation definition list for this set of name\n@@ -2884,8 +2884,8 @@ class Resolver {\n         }\n \n         alt item.node {\n-            item_enum(_, type_parameters, _) |\n-            item_ty(_, type_parameters, _) {\n+            item_enum(_, type_parameters) |\n+            item_ty(_, type_parameters) {\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters, item.id, 0u,\n                                            NormalRibKind))\n@@ -2895,7 +2895,7 @@ class Resolver {\n                 }\n             }\n \n-            item_impl(type_parameters, _, interface_reference, self_type,\n+            item_impl(type_parameters, interface_reference, self_type,\n                       methods) {\n                 self.resolve_implementation(item.id,\n                                             item.span,\n@@ -2906,7 +2906,7 @@ class Resolver {\n                                             visitor);\n             }\n \n-            item_trait(type_parameters, _, methods) {\n+            item_trait(type_parameters, methods) {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -2948,7 +2948,7 @@ class Resolver {\n             }\n \n             item_class(ty_params, interfaces, class_members, constructor,\n-                       optional_destructor, _) {\n+                       optional_destructor) {\n \n                 self.resolve_class(item.id,\n                                    @copy ty_params,"}, {"sha": "b96186126f57ee0d40c414f100aa747510027b56", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -2291,7 +2291,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             ccx.external.insert(parent_id, some(item.id));\n             let mut my_id = 0;\n             alt check item.node {\n-              ast::item_enum(_, _, _) {\n+              ast::item_enum(_, _) {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n                 do vec::iter2(*vs_here, *vs_there) |here, there| {\n@@ -4886,13 +4886,13 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _rp, _, _, ms) {\n+      ast::item_impl(tps, _, _, ms) {\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       ast::item_mod(m) {\n         trans_mod(ccx, m);\n       }\n-      ast::item_enum(variants, tps, _) {\n+      ast::item_enum(variants, tps) {\n         if tps.len() == 0u {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n@@ -4916,7 +4916,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n-      ast::item_class(tps, _traits, items, ctor, m_dtor, _) {\n+      ast::item_class(tps, _traits, items, ctor, m_dtor) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                          vtables: none,\n@@ -5199,7 +5199,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                                   ~[path_name(enm.ident),\n                                    path_name(v.node.name)]);\n             let llfn = alt check enm.node {\n-              ast::item_enum(_, _, _) {\n+              ast::item_enum(_, _) {\n                 register_fn(ccx, v.span, pth, id)\n               }\n             };\n@@ -5220,7 +5220,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     alt it.node {\n-      ast::item_enum(variants, _, _) {\n+      ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                              node: it.id});\n         let mut i = 0;"}, {"sha": "2ebddb0038f7ed39b2b0e29822ddb99d852c3dc1", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -84,11 +84,11 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         alt check ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, _, ms), _}, _) {\n+          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) {\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:\n-              ast::item_class(_, _, items, _, _, _), _}, _) {\n+              ast::item_class(_, _, items, _, _), _}, _) {\n             let (_,ms) = split_class_items(items);\n             method_from_methods(ms, name)\n           }"}, {"sha": "51dc20d1c87ef60e44f7dbbf4b0dacad4f94483e", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -112,7 +112,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             traverse_inline_body(cx, blk);\n         }\n       }\n-      item_impl(tps, _, _, _, ms) {\n+      item_impl(tps, _, _, ms) {\n         for vec::each(ms) |m| {\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n@@ -121,7 +121,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(tps, _traits, items, ctor, m_dtor, _) {\n+      item_class(tps, _traits, items, ctor, m_dtor) {\n         cx.rmap.insert(ctor.node.id, ());\n         do option::iter(m_dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n@@ -143,7 +143,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_ty(t, _, _) {\n+      item_ty(t, _) {\n         traverse_ty(t, cx, mk_ty_visitor());\n       }\n       item_const(*) |\n@@ -218,7 +218,7 @@ fn traverse_all_resources(cx: ctx, crate_mod: _mod) {\n         visit_item: |i, cx, v| {\n             visit::visit_item(i, cx, v);\n             alt i.node {\n-              item_class(_, _, _, _, some(_), _) {\n+              item_class(_, _, _, _, some(_)) {\n                 traverse_public_item(cx, i);\n               }\n               _ {}"}, {"sha": "fe502e184761ae0121846c86c6a4abe481a7e047", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -52,7 +52,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       item_class(*) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }\n-      item_impl(_, _, _, _, ms) {\n+      item_impl(_, _, _, ms) {\n         for ms.each |m| { find_pre_post_method(ccx, m); }\n       }\n       item_mac(*) { fail \"item macros unimplemented\" }"}, {"sha": "8aebe510966fe751d7c7532c651ca97deb43a15d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -233,7 +233,9 @@ type ctxt =\n       cstore: metadata::cstore::cstore,\n       sess: session::session,\n       def_map: resolve::def_map,\n+\n       region_map: middle::region::region_map,\n+      region_paramd_items: middle::region::region_paramd_items,\n \n       // Stores the types for various nodes in the AST.  Note that this table\n       // is not guaranteed to be populated until after typeck.  See\n@@ -482,7 +484,7 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n }\n \n type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n-                               rp: ast::region_param,\n+                               rp: bool,\n                                ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n@@ -505,9 +507,12 @@ fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n                  |&&a: t, &&b: t| type_id(a) == type_id(b))\n }\n \n-fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n+fn mk_ctxt(s: session::session,\n+           dm: resolve::def_map,\n+           amap: ast_map::map,\n            freevars: freevars::freevar_map,\n-           region_map: middle::region::region_map) -> ctxt {\n+           region_map: middle::region::region_map,\n+           region_paramd_items: middle::region::region_paramd_items) -> ctxt {\n     let interner = map::hashmap(|&&k: intern_key| {\n         hash_type_structure(k.struct) +\n             option::map_default(k.o_def_id, 0u, ast_util::hash_def)\n@@ -523,6 +528,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       sess: s,\n       def_map: dm,\n       region_map: region_map,\n+      region_paramd_items: region_paramd_items,\n       node_types: @smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n       items: amap,\n@@ -2543,10 +2549,10 @@ fn impl_trait(cx: ctxt, id: ast::def_id) -> option<t> {\n         #debug(\"(impl_trait) searching for trait impl %?\", id);\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{node: ast::item_impl(\n-              _, _, some(@{id: id, _}), _, _), _}, _)) {\n+               _, some(@{id: id, _}), _, _), _}, _)) {\n               some(node_id_to_type(cx, id))\n            }\n-           some(ast_map::node_item(@{node: ast::item_class(_, _, _, _, _, _),\n+           some(ast_map::node_item(@{node: ast::item_class(*),\n                            _},_)) {\n              alt cx.def_map.find(id.node) {\n                some(def_ty(trait_id)) {\n@@ -2606,7 +2612,7 @@ fn ty_dtor(cx: ctxt, class_id: def_id) -> option<def_id> {\n     if is_local(class_id) {\n        alt cx.items.find(class_id.node) {\n          some(ast_map::node_item(@{node: ast::item_class(_, _, _, _,\n-                                     some(dtor), _), _}, _))\n+                                     some(dtor)), _}, _))\n              { some(local_def(dtor.node.id))  }\n          _  { none }\n        }\n@@ -2687,7 +2693,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         alt cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_enum(variants, _, _), _}, _) {\n+          ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) {\n             let mut disr_val = -1;\n             @vec::map(variants, |variant| {\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n@@ -2780,7 +2786,7 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) {\n          alt i.node {\n-                 ast::item_class(_, _, items, _, _, _) {\n+                 ast::item_class(_, _, items, _, _) {\n                class_field_tys(items)\n            }\n            _ { cx.sess.bug(\"class ID bound to non-class\"); }\n@@ -2822,7 +2828,7 @@ pure fn is_public(f: field_ty) -> bool {\n fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n     : is_local(did) -> ~[{name: ident, id: node_id, vis: visibility}] {\n     alt cx.items.find(did.node) {\n-       some(ast_map::node_item(@{node: item_class(_,_,items,_,_,_), _}, _)) {\n+       some(ast_map::node_item(@{node: item_class(_,_,items,_,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n          vec::map(ms, |m| {name: m.ident, id: m.id,\n                             vis: m.vis})"}, {"sha": "2f3fcb498be3ef2685be27146573895f3fc53d0b", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -185,7 +185,7 @@ fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n }\n \n fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n-    {bounds: @~[], rp: ast::rp_none, ty: t}\n+    {bounds: @~[], rp: false, ty: t}\n }\n \n fn require_same_types("}, {"sha": "fe9a8b4aadf0bfe33ac61bf06988bc31559c9ef3", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -87,27 +87,30 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n     let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n         self.get_item_ty(did);\n \n+    #debug[\"ast_path_to_substs_and_ty: did=%? decl_rp=%b\",\n+           did, decl_rp];\n+\n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let self_r = alt (decl_rp, path.rp) {\n-      (ast::rp_none, none) {\n+      (false, none) {\n         none\n       }\n-      (ast::rp_none, some(_)) {\n+      (false, some(_)) {\n         tcx.sess.span_err(\n             path.span,\n             #fmt[\"no region bound is permitted on %s, \\\n                   which is not declared as containing region pointers\",\n                  ty::item_path_str(tcx, did)]);\n         none\n       }\n-      (ast::rp_self, none) {\n+      (true, none) {\n         let res = rscope.anon_region();\n         let r = get_region_reporting_err(self.tcx(), path.span, res);\n         some(r)\n       }\n-      (ast::rp_self, some(r)) {\n+      (true, some(r)) {\n         some(ast_region_to_region(self, rscope, path.span, r))\n       }\n     };"}, {"sha": "74aaca06a7cf05d712a008597ceb861640a21e42", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -66,7 +66,7 @@ type parameter).\n \n */\n \n-import astconv::{ast_conv, ast_ty_to_ty};\n+import astconv::{ast_conv, ast_ty_to_ty, ast_region_to_region};\n import collect::{methods}; // ccx.to_ty()\n import middle::ty::{tv_vid, vid};\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n@@ -348,17 +348,20 @@ fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_enum(vs, _, _) {\n+      ast::item_enum(vs, _) {\n         check_enum_variants(ccx, it.span, vs, it.id);\n       }\n       ast::item_fn(decl, tps, body) {\n         check_bare_fn(ccx, decl, body, it.id, none);\n       }\n-      ast::item_impl(tps, rp, _, ty, ms) {\n+      ast::item_impl(tps, _, ty, ms) {\n+        let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n+        #debug[\"item_impl %s with id %d rp %b\",\n+               *it.ident, it.id, rp];\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| { check_method(ccx, m, self_ty);}\n       }\n-      ast::item_class(tps, traits, members, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor) {\n           let tcx = ccx.tcx;\n           let class_t = ty::node_id_to_type(tcx, it.id);\n           // typecheck the ctor\n@@ -387,9 +390,9 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // Check that the class is instantiable\n           check_instantiable(ccx.tcx, it.span, it.id);\n       }\n-      ast::item_ty(t, tps, rp) {\n+      ast::item_ty(t, tps) {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n-        check_bounds_are_used(ccx, t.span, tps, rp, tpt_ty);\n+        check_bounds_are_used(ccx, t.span, tps, tpt_ty);\n       }\n       ast::item_foreign_mod(m) {\n         if syntax::attr::foreign_abi(it.attrs) ==\n@@ -647,25 +650,25 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n     let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n+        let rp = fcx.tcx().region_paramd_items.contains_key(did.node);\n         alt check tcx.items.find(did.node) {\n-          some(ast_map::node_item(@{node: ast::item_impl(ts, rp, _, st, _),\n+          some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                   _}, _)) {\n             {n_tps: ts.len(),\n              rp: rp,\n              raw_ty: fcx.ccx.to_ty(rscope::type_rscope(rp), st)}\n           }\n           some(ast_map::node_item(@{node: ast::item_class(ts,\n-                                 _,_,_,_,rp), id: class_id, _},_)) {\n+                                 _,_,_,_), id: class_id, _},_)) {\n               /* If the impl is a class, the self ty is just the class ty\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n               {n_tps: ts.len(),\n                rp: rp,\n                raw_ty: ty::mk_class(tcx, local_def(class_id),\n-                      {self_r: alt rp {\n-                          ast::rp_self { some(fcx.infcx.next_region_var()) }\n-                          ast::rp_none { none }},\n+                      {self_r: if rp {some(ty::re_bound(ty::br_self))}\n+                               else {none},\n                        self_ty: none,\n                        tps: ty::ty_params_to_tys(tcx, ts)})}\n           }\n@@ -679,10 +682,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n          raw_ty: ity.ty}\n     };\n \n-    let self_r = alt rp {\n-      ast::rp_none { none }\n-      ast::rp_self { some(fcx.infcx.next_region_var()) }\n-    };\n+    let self_r = if rp {some(fcx.infcx.next_region_var())} else {none};\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n@@ -2053,7 +2053,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         // extern functions are just u8 pointers\n         ret {\n             bounds: @~[],\n-            rp: ast::rp_none,\n+            rp: false,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 {\n@@ -2109,13 +2109,27 @@ fn instantiate_path(fcx: @fn_ctxt,\n     let ty_param_count = vec::len(*tpt.bounds);\n     let ty_substs_len = vec::len(pth.types);\n \n-    // For now, there is no way to explicitly specify the region bound.\n-    // This will have to change eventually.\n-    let self_r = alt tpt.rp {\n-      ast::rp_self { some(fcx.infcx.next_region_var()) }\n-      ast::rp_none { none }\n+    // determine the region bound, using the value given by the user\n+    // (if any) and otherwise using a fresh region variable\n+    let self_r = alt pth.rp {\n+      some(r) if !tpt.rp => {\n+        fcx.ccx.tcx.sess.span_err\n+            (sp, \"this item is not region-parameterized\");\n+        none\n+      }\n+      some(r) => {\n+        some(ast_region_to_region(fcx, fcx, sp, r))\n+      }\n+      none if tpt.rp => {\n+        some(fcx.infcx.next_region_var())\n+      }\n+      none => {\n+        none\n+      }\n     };\n \n+    // determine values for type parameters, using the values given by\n+    // the user (if any) and otherwise using fresh type variables\n     let tps = if ty_substs_len == 0u {\n         fcx.infcx.next_ty_vars(ty_param_count)\n     } else if ty_param_count == 0u {\n@@ -2203,24 +2217,14 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n fn check_bounds_are_used(ccx: @crate_ctxt,\n                          span: span,\n                          tps: ~[ast::ty_param],\n-                         rp: ast::region_param,\n                          ty: ty::t) {\n-    let mut r_used = alt rp {\n-      ast::rp_self { false }\n-      ast::rp_none { true }\n-    };\n-\n-    if tps.len() == 0u && r_used { ret; }\n+    // make a vector of booleans initially false, set to true when used\n+    if tps.len() == 0u { ret; }\n     let tps_used = vec::to_mut(vec::from_elem(tps.len(), false));\n \n     ty::walk_regions_and_ty(\n         ccx.tcx, ty,\n-        |r| {\n-            alt r {\n-              ty::re_bound(_) { r_used = true; }\n-              _ { }\n-            }\n-        },\n+        |_r| {},\n         |t| {\n             alt ty::get(t).struct {\n               ty::ty_param(idx, _) { tps_used[idx] = true; }\n@@ -2229,12 +2233,6 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n             true\n         });\n \n-    if !r_used {\n-        ccx.tcx.sess.span_err(\n-            span, \"lifetime `self` unused inside \\\n-                   reference-parameterized type\");\n-    }\n-\n     for tps_used.eachi |i, b| {\n         if !b {\n             ccx.tcx.sess.span_err("}, {"sha": "ad121772bd749cc30197b037fac83678ab569ced", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -15,7 +15,7 @@ import middle::typeck::infer::{infer_ctxt, mk_subty, new_infer_ctxt};\n import syntax::ast::{crate, def_id, item, item_class, item_const, item_enum};\n import syntax::ast::{item_fn, item_foreign_mod, item_impl, item_mac};\n import syntax::ast::{item_mod, item_trait, item_ty, local_crate, method};\n-import syntax::ast::{node_id, region_param, rp_none, rp_self, trait_ref};\n+import syntax::ast::{node_id, trait_ref};\n import syntax::ast_util::{def_id_of_def, new_def_hash};\n import syntax::visit::{default_simple_visitor, default_visitor};\n import syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n@@ -76,7 +76,7 @@ class CoherenceChecker {\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n                 alt item.node {\n-                    item_impl(_, _, associated_trait, self_type, _) {\n+                    item_impl(_, associated_trait, self_type, _) {\n                         self.check_implementation(item, associated_trait);\n                     }\n                     _ {\n@@ -239,15 +239,9 @@ class CoherenceChecker {\n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables.\n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n-        let self_region;\n-        alt polytype.rp {\n-            rp_none {\n-                self_region = none;\n-            }\n-            rp_self {\n-                self_region = some(self.inference_context.next_region_var())\n-            }\n-        };\n+        let self_region =\n+            if polytype.rp {none}\n+            else {some(self.inference_context.next_region_var())};\n \n         let bounds_count = polytype.bounds.len();\n         let type_parameters =\n@@ -304,7 +298,7 @@ class CoherenceChecker {\n                             self.privileged_types.remove(privileged_type);\n                         }\n                     }\n-                    item_impl(_, _, optional_trait_ref, _, _) {\n+                    item_impl(_, optional_trait_ref, _, _) {\n                         alt self.base_type_def_ids.find(item.id) {\n                             none {\n                                 // Nothing to do."}, {"sha": "fa5ffc61baed399ec4ff1c55ebd3c7ead06effd7", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -39,13 +39,13 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n                     alt intrinsic_item.node {\n \n-                      ast::item_trait(_, _, _) {\n+                      ast::item_trait(_, _) {\n                         let ty = ty::mk_trait(ccx.tcx, def_id, substs);\n                         ccx.tcx.intrinsic_defs.insert\n                             (intrinsic_item.ident, (def_id, ty));\n                       }\n \n-                      ast::item_enum(_, _, _) {\n+                      ast::item_enum(_, _) {\n                         let ty = ty::mk_enum(ccx.tcx, def_id, substs);\n                         ccx.tcx.intrinsic_defs.insert\n                             (intrinsic_item.ident, (def_id, ty));\n@@ -107,7 +107,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                           enum_ty: ty::t,\n                           variants: ~[ast::variant],\n                           ty_params: ~[ast::ty_param],\n-                          rp: ast::region_param) {\n+                          rp: bool) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -144,13 +144,14 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     }\n \n     let tcx = ccx.tcx;\n+    let rp = tcx.region_paramd_items.contains_key(id);\n     alt check tcx.items.get(id) {\n-      ast_map::node_item(@{node: ast::item_trait(_, rp, ms), _}, _) {\n+      ast_map::node_item(@{node: ast::item_trait(_, ms), _}, _) {\n         store_methods::<ast::ty_method>(ccx, id, ms, |m| {\n             ty_of_ty_method(ccx, m, rp)\n         });\n       }\n-      ast_map::node_item(@{node: ast::item_class(_,_,its,_,_,rp), _}, _) {\n+      ast_map::node_item(@{node: ast::item_class(_,_,its,_,_), _}, _) {\n         let (_,ms) = split_class_items(its);\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n@@ -234,7 +235,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n \n fn check_methods_against_trait(ccx: @crate_ctxt,\n                                tps: ~[ast::ty_param],\n-                               rp: ast::region_param,\n+                               rp: bool,\n                                selfty: ty::t,\n                                a_trait_ty: @ast::trait_ref,\n                                ms: ~[converted_method]) {\n@@ -267,7 +268,7 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n } // fn\n \n fn convert_class_item(ccx: @crate_ctxt,\n-                      rp: ast::region_param,\n+                      rp: bool,\n                       bounds: @~[ty::param_bounds],\n                       v: ast_util::ivar) {\n     let tt = ccx.to_ty(type_rscope(rp), v.ty);\n@@ -280,7 +281,7 @@ type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n \n fn convert_methods(ccx: @crate_ctxt,\n                    ms: ~[@ast::method],\n-                   rp: ast::region_param,\n+                   rp: bool,\n                    rcvr_bounds: @~[ty::param_bounds],\n                    self_ty: ty::t) -> ~[converted_method] {\n \n@@ -303,16 +304,17 @@ fn convert_methods(ccx: @crate_ctxt,\n \n fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n+    let rp = tcx.region_paramd_items.contains_key(it.id);\n+    #debug[\"convert: item %s with id %d rp %b\", *it.ident, it.id, rp];\n     alt it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) {}\n-      ast::item_enum(variants, ty_params, rp) {\n+      ast::item_enum(variants, ty_params) {\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx, tpt.ty, variants,\n-                               ty_params, rp);\n+        get_enum_variant_types(ccx, tpt.ty, variants, ty_params, rp);\n       }\n-      ast::item_impl(tps, rp, ifce, selfty, ms) {\n+      ast::item_impl(tps, ifce, selfty, ms) {\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -333,28 +335,27 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id);\n       }\n-      ast::item_class(tps, traits, members, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor) {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         // Write the ctor type\n         let t_args = ctor.node.dec.inputs.map(\n             |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n-        let t_res = ty::mk_class(tcx, local_def(it.id),\n-                                 {self_r: alt rp {\n-                       ast::rp_none { none }\n-                       ast::rp_self { some(ty::re_bound(ty::br_self)) }\n-                                     },\n-                                  self_ty: none,\n-                                  tps: ty::ty_params_to_tys(tcx, tps)});\n-        let t_ctor = ty::mk_fn(tcx, {purity: ast::impure_fn,\n-              proto: ast::proto_any,\n-              inputs: t_args,\n-              output: t_res,\n-              ret_style: ast::return_val,\n-              constraints: ~[]}); // FIXME (#2813): allow ctors to have\n-         // constraints, or remove constraints from the language\n+        let t_res = ty::mk_class(\n+            tcx, local_def(it.id),\n+            {self_r: if rp {some(ty::re_bound(ty::br_self))} else {none},\n+             self_ty: none,\n+             tps: ty::ty_params_to_tys(tcx, tps)});\n+        let t_ctor = ty::mk_fn(\n+            tcx, {purity: ast::impure_fn,\n+                  proto: ast::proto_any,\n+                  inputs: t_args,\n+                  output: t_res,\n+                  ret_style: ast::return_val,\n+                  constraints: ~[]}); // FIXME (#2813): allow ctors to have\n+        // constraints, or remove constraints from the language\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n                           {bounds: tpt.bounds,\n@@ -421,18 +422,18 @@ fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n \n fn ty_of_method(ccx: @crate_ctxt,\n                 m: @ast::method,\n-                rp: ast::region_param) -> ty::method {\n+                rp: bool) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n-                                 m.decl, none),\n+                        m.decl, none),\n      purity: m.decl.purity,\n      vis: m.vis}\n }\n \n fn ty_of_ty_method(self: @crate_ctxt,\n                    m: ast::ty_method,\n-                   rp: ast::region_param) -> ty::method {\n+                   rp: bool) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n@@ -446,8 +447,7 @@ fn ty_of_ty_method(self: @crate_ctxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n-                         rp: ast::region_param)\n+fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref, rp: bool)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n     let sp = t.path.span, err = \"can only implement interface types\",\n@@ -480,6 +480,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       some(tpt) { ret tpt; }\n       _ {}\n     }\n+    let rp = tcx.region_paramd_items.contains_key(it.id);\n     alt it.node {\n       ast::item_const(t, _) {\n         let typ = ccx.to_ty(empty_rscope, t);\n@@ -492,19 +493,20 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n                                           decl, none);\n         let tpt = {bounds: bounds,\n-                   rp: ast::rp_none, // functions do not have a self\n+                   rp: false, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n         #debug[\"type of %s (id %d) is %s\",\n                *it.ident, it.id, ty_to_str(tcx, tpt.ty)];\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_ty(t, tps, rp) {\n+      ast::item_ty(t, tps) {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n           none { }\n         }\n \n+        let rp = tcx.region_paramd_items.contains_key(it.id);\n         let tpt = {\n             let ty = {\n                 let t0 = ccx.to_ty(type_rscope(rp), t);\n@@ -522,22 +524,22 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_enum(_, tps, rp) {\n+      ast::item_enum(_, tps) {\n         // Create a new generic polytype.\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_trait(tps, rp, ms) {\n+      ast::item_trait(tps, ms) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs);\n         let tpt = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_class(tps, _, _, _, _, rp) {\n+      ast::item_class(tps, _, _, _, _) {\n           let {bounds,substs} = mk_substs(ccx, tps, rp);\n           let t = ty::mk_class(tcx, local_def(it.id), substs);\n           let tpt = {bounds: bounds, rp: rp, ty: t};\n@@ -555,7 +557,7 @@ fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n     alt it.node {\n       ast::foreign_item_fn(fn_decl, params) {\n         ret ty_of_foreign_fn_decl(ccx, fn_decl, params,\n-                                 local_def(it.id));\n+                                  local_def(it.id));\n       }\n     }\n }\n@@ -615,7 +617,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n                                    output: output_ty,\n                                    ret_style: ast::return_val,\n                                    constraints: ~[]});\n-    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n+    let tpt = {bounds: bounds, rp: false, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -633,13 +635,10 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n      })}\n }\n \n-fn mk_substs(ccx: @crate_ctxt, atps: ~[ast::ty_param], rp: ast::region_param)\n+fn mk_substs(ccx: @crate_ctxt, atps: ~[ast::ty_param], rp: bool)\n     -> {bounds: @~[ty::param_bounds], substs: ty::substs} {\n \n     let {bounds, params} = mk_ty_params(ccx, atps);\n-    let self_r = alt rp {\n-      ast::rp_self { some(ty::re_bound(ty::br_self)) }\n-      ast::rp_none { none }\n-    };\n+    let self_r = if rp {some(ty::re_bound(ty::br_self))} else {none};\n     {bounds: bounds, substs: {self_r: self_r, self_ty: none, tps: params}}\n }"}, {"sha": "ec0dbe7ea8e02edf1019daefe971e28d656848f4", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -16,15 +16,14 @@ impl of region_scope for empty_rscope {\n     }\n }\n \n-enum type_rscope = ast::region_param;\n+enum type_rscope = bool;\n impl of region_scope for type_rscope {\n     fn anon_region() -> result<ty::region, str> {\n-        alt *self {\n-          ast::rp_self { result::ok(ty::re_bound(ty::br_self)) }\n-          ast::rp_none {\n+        if *self {\n+            result::ok(ty::re_bound(ty::br_self))\n+        } else {\n             result::err(\"to use region types here, the containing type \\\n                          must be declared with a region bound\")\n-          }\n         }\n     }\n     fn named_region(id: ast::ident) -> result<ty::region, str> {"}, {"sha": "cf2077bfb5ee27cbd9db9187f4e9e228b1a0aeeb", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -147,7 +147,7 @@ fn fold_enum(\n             let desc = do astsrv::exec(srv) |ctxt| {\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n-                    node: ast::item_enum(ast_variants, _, _), _\n+                    node: ast::item_enum(ast_variants, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants, |v| {\n@@ -204,14 +204,14 @@ fn merge_method_attrs(\n     let attrs: ~[(str, option<str>)] = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_trait(_, _, methods), _\n+            node: ast::item_trait(_, methods), _\n           }, _) {\n             par::seqmap(methods, |method| {\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n             })\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, _, methods), _\n+            node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n             par::seqmap(methods, |method| {\n                 (*method.ident, attr_parser::parse_desc(method.attrs))"}, {"sha": "955c0976c23f7a2e17518e3598a806e8c50c2a0f", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -78,22 +78,22 @@ fn moddoc_from_mod(\n                     constdoc_from_const(itemdoc)\n                 ))\n               }\n-              ast::item_enum(variants, _, _) {\n+              ast::item_enum(variants, _) {\n                 some(doc::enumtag(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_trait(_, _, methods) {\n+              ast::item_trait(_, methods) {\n                 some(doc::traittag(\n                     traitdoc_from_trait(itemdoc, methods)\n                 ))\n               }\n-              ast::item_impl(_, _, _, _, methods) {\n+              ast::item_impl(_, _, _, methods) {\n                 some(doc::impltag(\n                     impldoc_from_impl(itemdoc, methods)\n                 ))\n               }\n-              ast::item_ty(_, _, _) {\n+              ast::item_ty(_, _) {\n                 some(doc::tytag(\n                     tydoc_from_ty(itemdoc)\n                 ))"}, {"sha": "6a5d2b326b95d4a322761eb3de732e625b033a3d", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -291,7 +291,7 @@ fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n     let all_impls = ast_util::new_def_hash();\n     for m.items.each |item| {\n         alt item.node {\n-          ast::item_impl(_, _, _, _, _) {\n+          ast::item_impl(_, _, _, _) {\n             all_impls.insert(ast_util::local_def(item.id), ());\n           }\n           _ { }"}, {"sha": "ba5abf9f66dbe6440dede7815619a6aaf2312325", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -110,7 +110,7 @@ fn fold_enum(\n             let sig = do astsrv::exec(srv) |ctxt| {\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n-                    node: ast::item_enum(ast_variants, _, _), _\n+                    node: ast::item_enum(ast_variants, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n                         do vec::find(ast_variants) |v| {\n@@ -168,7 +168,7 @@ fn get_method_sig(\n     do astsrv::exec(srv) |ctxt| {\n         alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_trait(_, _, methods), _\n+            node: ast::item_trait(_, methods), _\n           }, _) {\n             alt check vec::find(methods, |method| {\n                 *method.ident == method_name\n@@ -183,7 +183,7 @@ fn get_method_sig(\n             }\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, _, methods), _\n+            node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n             alt check vec::find(methods, |method| {\n                 *method.ident == method_name\n@@ -218,7 +218,7 @@ fn fold_impl(\n     let (trait_ty, self_ty) = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, trait_ty, self_ty, _), _\n+            node: ast::item_impl(_, trait_ty, self_ty, _), _\n           }, _) {\n             let trait_ty = option::map(trait_ty, |p| {\n                 pprust::path_to_str(p.path)\n@@ -274,7 +274,7 @@ fn fold_type(\n             alt ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 ident: ident,\n-                node: ast::item_ty(ty, params, ast::rp_none), _\n+                node: ast::item_ty(ty, params), _\n               }, _) {\n                 some(#fmt(\n                     \"type %s%s = %s\","}, {"sha": "bf48e3f0da2a8aedf76190749fd484f8fe47dc48", "filename": "src/test/compile-fail/region-unused.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b094c0baf4fa758c80fb9db8cc172f03789adbb/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b094c0baf4fa758c80fb9db8cc172f03789adbb/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-unused.rs?ref=9b094c0baf4fa758c80fb9db8cc172f03789adbb", "patch": "@@ -1,3 +0,0 @@\n-type foo/& = {f: int}; //~ ERROR lifetime `self` unused\n-\n-fn main() {}\n\\ No newline at end of file"}, {"sha": "d19a0c8390582a0f30454082367bdc05e2f41cde", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -2,9 +2,9 @@\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-enum an_enum/& { }\n-iface an_iface/& { }\n-class a_class/& { let x:int; new(x:int) { self.x = x; } }\n+enum an_enum = &int;\n+iface an_iface { fn foo() -> &self.int; }\n+class a_class { let x:&self.int; new(x:&self.int) { self.x = x; } }\n \n fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n     ret e; //~ ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`"}, {"sha": "16d0bd6afdea1ac2628c49021e20bfb2bec3ffea", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-enum ast/& {\n+enum ast {\n     num(uint),\n     add(&ast, &ast)\n }"}, {"sha": "3478742c2ecfec9f529df157e3c2a48cac98f1d9", "filename": "src/test/compile-fail/regions-iface-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,13 +1,13 @@\n type ctxt = { v: uint };\n \n-iface get_ctxt/& {\n+iface get_ctxt {\n     // Here the `&` is bound in the method definition:\n     fn get_ctxt() -> &ctxt;\n }\n \n-type has_ctxt/& = { c: &ctxt };\n+type has_ctxt = { c: &ctxt };\n \n-impl/& of get_ctxt for has_ctxt {\n+impl of get_ctxt for has_ctxt {\n \n     // Here an error occurs because we used `&self` but\n     // the definition used `&`:"}, {"sha": "413e17c354f6598ab3cc82652fa0762ddfc2ca9c", "filename": "src/test/compile-fail/regions-iface-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,12 +1,12 @@\n type ctxt = { v: uint };\n \n-iface get_ctxt/& {\n+iface get_ctxt {\n     fn get_ctxt() -> &self.ctxt;\n }\n \n-type has_ctxt/& = { c: &ctxt };\n+type has_ctxt = { c: &ctxt };\n \n-impl/& of get_ctxt for has_ctxt {\n+impl of get_ctxt for has_ctxt {\n     fn get_ctxt() -> &self.ctxt { self.c }\n }\n "}, {"sha": "6268846c3ecf01d12d5af0ada9d05c0424d824df", "filename": "src/test/compile-fail/regions-iface-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-iface get_ctxt/& {\n+iface get_ctxt {\n     fn get_ctxt() -> &self.uint;\n }\n "}, {"sha": "3a9f34892f6505b7cae90d73582a10b02eaa8b3b", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,24 +1,12 @@\n-enum no0 {\n-    x0(&uint) //~ ERROR to use region types here, the containing type must be declared with a region bound\n-}\n-\n-enum no1 {\n-    x1(&self.uint) //~ ERROR to use region types here, the containing type must be declared with a region bound\n-}\n-\n-enum no2 {\n-    x2(&foo.uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n-}\n-\n-enum yes0/& {\n+enum yes0 {\n     x3(&uint)\n }\n \n-enum yes1/& {\n+enum yes1 {\n     x4(&self.uint)\n }\n \n-enum yes2/& {\n+enum yes2 {\n     x5(&foo.uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n }\n "}, {"sha": "297ff98ad4e5c15ca1a726c60f5cbb4e44b19b53", "filename": "src/test/compile-fail/regions-in-rsrcs.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,34 +1,16 @@\n-class no0 {\n-  let x: &uint; //~ ERROR to use region types here, the containing type must be declared with a region bound\n-  new(x: &uint) { self.x = x; } //~ ERROR to use region types here, the containing type must be declared with a region bound\n-  drop {}\n-}\n-\n-class no1 {\n-  let x: &self.uint; //~ ERROR to use region types here, the containing type must be declared with a region bound\n-  new(x: &self.uint) { self.x = x; } //~ ERROR to use region types here, the containing type must be declared with a region bound\n-  drop {}\n-}\n-\n-class no2 {\n-  let x: &foo.uint; //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n-  new(x: &foo.uint) { self.x = x; } //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n-  drop {}\n-}\n-\n-class yes0/& {\n+class yes0 {\n   let x: &uint;\n   new(x: &uint) { self.x = x; }\n   drop {}\n }\n \n-class yes1/& {\n+class yes1 {\n   let x: &self.uint;\n   new(x: &self.uint) { self.x = x; }\n   drop {}\n }\n \n-class yes2/& {\n+class yes2 {\n   let x: &foo.uint; //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n   new(x: &foo.uint) { self.x = x; } //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n   drop {}"}, {"sha": "3ccae7886519865d7bff1b9cb5004f5fd79d5eb8", "filename": "src/test/compile-fail/regions-in-type-items.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,24 +1,12 @@\n-type item_ty_no0 = {\n-    x: &uint //~ ERROR to use region types here, the containing type must be declared with a region bound\n-};\n-\n-type item_ty_no1 = {\n-    x: &self.uint //~ ERROR to use region types here, the containing type must be declared with a region bound\n-};\n-\n-type item_ty_no2 = {\n-    x: &foo.uint //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n-};\n-\n-type item_ty_yes0/& = {\n+type item_ty_yes0 = {\n     x: &uint\n };\n \n-type item_ty_yes1/& = {\n+type item_ty_yes1 = {\n     x: &self.uint\n };\n \n-type item_ty_yes2/& = { //~ ERROR lifetime `self` unused inside reference-parameterized type\n+type item_ty_yes2 = {\n     x: &foo.uint //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n };\n "}, {"sha": "907f8e5e69dc4b4f3fff5da108cc4f70b7cedc96", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -0,0 +1,18 @@\n+// Check that we correctly infer that b and c must be region\n+// parameterized because they reference a which requires a region.\n+\n+type a = &int;\n+type b = @a;\n+type c = {f: @b};\n+\n+impl methods for c {\n+    fn set_f_ok(b: @b/&self) {\n+        self.f = b;\n+    }\n+\n+    fn set_f_bad(b: @b) {\n+        self.f = b; //~ ERROR mismatched types: expected `@@&self.int` but found `@@&int`\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "bea901071a2dcc6502163ed3eb5772aef23f568a", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -0,0 +1,32 @@\n+// Here: foo is parameterized because it contains a method that\n+// refers to self.\n+\n+iface foo {\n+    fn self_int() -> &self.int;\n+\n+    fn any_int() -> &int;\n+}\n+\n+type with_foo = {mut f: foo};\n+\n+impl methods for with_foo {\n+    fn set_foo(f: foo) {\n+        self.f = f; //~ ERROR mismatched types: expected `foo/&self` but found `foo/&`\n+    }\n+}\n+\n+// Bar is not region parameterized.\n+\n+iface bar {\n+    fn any_int() -> &int;\n+}\n+\n+type with_bar = {mut f: bar};\n+\n+impl methods for with_bar {\n+    fn set_foo(f: bar) {\n+        self.f = f;\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "f65b06fcfe0284cea0fc09a3e6ffac27ec0853f0", "filename": "src/test/run-pass/assignability-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-iface.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -6,7 +6,7 @@ iface iterable<A> {\n     fn iterate(blk: fn(A) -> bool);\n }\n \n-impl vec/&<A> of iterable<A> for &[const A] {\n+impl vec<A> of iterable<A> for &[const A] {\n     fn iterate(f: fn(A) -> bool) {\n         vec::each(self, f);\n     }"}, {"sha": "5df083a94022f8f99fc3e9c98cd5b5f180798367", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-class font/& {\n+class font {\n     let fontbuf: &self.~[u8];\n \n     new(fontbuf: &self.~[u8]) {"}, {"sha": "bf027bdd0600fca4a5a83dbac84bc9028ef0b5f8", "filename": "src/test/run-pass/issue-2748-a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,7 +1,7 @@\n-class CMap/& {\n-    let buf: [u8]/&;\n+class CMap {\n+    let buf: &[u8];\n \n-    new(buf: [u8]/&) {\n+    new(buf: &self.[u8]) {\n         self.buf = buf;\n     }\n }"}, {"sha": "ddf7081060db83ac0596269557fe1a59635f2d5b", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,5 +1,5 @@\n // Note: impl on a slice\n-impl foo/& for &int {\n+impl foo for &int {\n     fn get() -> int {\n         ret *self;\n     }"}, {"sha": "09de19cae450d04c31bce3393e192efdf3ba3b6d", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,5 +1,5 @@\n // Note: impl on a slice\n-impl foo/& for &[int] {\n+impl foo for &[int] {\n     fn sum() -> int {\n         let mut sum = 0;\n         for vec::each(self) |e| { sum += e; }"}, {"sha": "b03205e159661c60d5afa8a4850429e8a9cb3e64", "filename": "src/test/run-pass/regions-creating-enums2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-enum ast/& {\n+enum ast {\n     num(uint),\n     add(&ast, &ast)\n }"}, {"sha": "0ca55e99e12196c23d07b1fbf848e1cd0fb7cb7d", "filename": "src/test/run-pass/regions-creating-enums5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-enum ast/& {\n+enum ast {\n     num(uint),\n     add(&ast, &ast)\n }"}, {"sha": "3f8301cd26c0fad878f8ed707d5a881e2f92fa03", "filename": "src/test/run-pass/regions-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-iface.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,12 +1,12 @@\n type ctxt = { v: uint };\n \n-iface get_ctxt/& {\n+iface get_ctxt {\n     fn get_ctxt() -> &self.ctxt;\n }\n \n-type has_ctxt/& = { c: &ctxt };\n+type has_ctxt = { c: &ctxt };\n \n-impl/& of get_ctxt for has_ctxt {\n+impl of get_ctxt for has_ctxt {\n     fn get_ctxt() -> &self.ctxt {\n         self.c\n     }"}, {"sha": "b579d1e578c724524a9eae32f1fa345db4642000", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -2,11 +2,11 @@ import libc, sys, unsafe;\n \n enum arena = ();\n \n-type bcx/& = {\n+type bcx = {\n     fcx: &fcx\n };\n \n-type fcx/& = {\n+type fcx = {\n     arena: &arena,\n     ccx: &ccx\n };"}, {"sha": "a82fa6eead6597878cc8943350da114a868f2a3b", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -2,11 +2,11 @@ import libc, sys, unsafe;\n \n enum arena = ();\n \n-type bcx/& = {\n+type bcx = {\n     fcx: &fcx\n };\n \n-type fcx/& = {\n+type fcx = {\n     arena: &arena,\n     ccx: &ccx\n };"}, {"sha": "6d6d7b65a3f84fb04f4ee978c6e26847aa344b5e", "filename": "src/test/run-pass/regions-nullary-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-enum roption/& {\n+enum roption {\n     a, b(&uint)\n }\n "}, {"sha": "4e0cd5b1aee1fc907cd572f09b0ec79031be0a54", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,6 +1,6 @@\n-type clam/& = { chowder: &int };\n+type clam = { chowder: &int };\n \n-impl clam/& for clam {\n+impl clam for clam {\n     fn get_chowder() -> &self.int { ret self.chowder; }\n }\n "}, {"sha": "ef7a8ae1ed7aebae17da206e21483b665f879ffb", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9aa9def858cfc66d411972b10ce3d98479acd78/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=b9aa9def858cfc66d411972b10ce3d98479acd78", "patch": "@@ -1,4 +1,4 @@\n-enum int_wrapper/& {\n+enum int_wrapper {\n     int_wrapper_ctor(&int)\n }\n "}]}