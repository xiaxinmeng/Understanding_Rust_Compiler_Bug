{"sha": "4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjM1ZmRmNjNmMWJhMzQ4MGMzMGE2ZWExZTZmM2U0OWEzOWI3Mzg=", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-03-31T04:06:01Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-25T21:49:28Z"}, "message": "use undef for uninitialized bytes in constants", "tree": {"sha": "07f78389c7139ade9b6363565cddc3ff1fcfcaa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07f78389c7139ade9b6363565cddc3ff1fcfcaa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "html_url": "https://github.com/rust-lang/rust/commit/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b0e554ee2c94e9b3865a8c2d24d720224512dec", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0e554ee2c94e9b3865a8c2d24d720224512dec", "html_url": "https://github.com/rust-lang/rust/commit/7b0e554ee2c94e9b3865a8c2d24d720224512dec"}], "stats": {"total": 223, "additions": 202, "deletions": 21}, "files": [{"sha": "901fa9fb04749ded31bc0be60063b338bc891e12", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -11,21 +11,70 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer, Scalar as InterpScalar,\n+    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n+    Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_target::abi::{\n     AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size, WrappingRange,\n };\n+use std::ops::Range;\n use tracing::debug;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n+    // Note: this function may call `inspect_with_uninit_and_ptr_outside_interpreter`,\n+    // so `range` must be within the bounds of `alloc` and not within a relocation.\n+    fn append_chunks_of_init_and_uninit_bytes<'ll, 'a, 'b>(\n+        llvals: &mut Vec<&'ll Value>,\n+        cx: &'a CodegenCx<'ll, 'b>,\n+        alloc: &'a Allocation,\n+        range: Range<usize>,\n+    ) {\n+        /// Allocations larger than this will only be codegen'd as entirely initialized or entirely undef.\n+        /// This avoids compile time regressions when an alloc would have many chunks,\n+        /// e.g. for `[(u64, u8); N]`, which has undef padding in each element.\n+        const MAX_PARTIALLY_UNDEF_SIZE: usize = 1024;\n+\n+        let mut chunks = alloc\n+            .init_mask()\n+            .range_as_init_chunks(Size::from_bytes(range.start), Size::from_bytes(range.end));\n+\n+        let chunk_to_llval = move |chunk| match chunk {\n+            InitChunk::Init(range) => {\n+                let range = (range.start.bytes() as usize)..(range.end.bytes() as usize);\n+                let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n+                cx.const_bytes(bytes)\n+            }\n+            InitChunk::Uninit(range) => {\n+                let len = range.end.bytes() - range.start.bytes();\n+                cx.const_undef(cx.type_array(cx.type_i8(), len))\n+            }\n+        };\n+\n+        if range.len() > MAX_PARTIALLY_UNDEF_SIZE {\n+            let llval = match (chunks.next(), chunks.next()) {\n+                (Some(chunk), None) => {\n+                    // exactly one chunk, either fully init or fully uninit\n+                    chunk_to_llval(chunk)\n+                }\n+                _ => {\n+                    // partially uninit\n+                    let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n+                    cx.const_bytes(bytes)\n+                }\n+            };\n+            llvals.push(llval);\n+        } else {\n+            llvals.extend(chunks.map(chunk_to_llval));\n+        }\n+    }\n+\n     let mut next_offset = 0;\n     for &(offset, alloc_id) in alloc.relocations().iter() {\n         let offset = offset.bytes();\n@@ -34,12 +83,8 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         if offset > next_offset {\n             // This `inspect` is okay since we have checked that it is not within a relocation, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n-            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n-            // some arbitrary byte value.\n-            //\n-            // FIXME: relay undef bytes to codegen as undef const bytes\n-            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n-            llvals.push(cx.const_bytes(bytes));\n+            // (we inspect the result after interpreter execution).\n+            append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, next_offset..offset);\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n@@ -70,12 +115,8 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         let range = next_offset..alloc.len();\n         // This `inspect` is okay since we have check that it is after all relocations, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n-        // inspect the result after interpreter execution). Any undef byte is replaced with some\n-        // arbitrary byte value.\n-        //\n-        // FIXME: relay undef bytes to codegen as undef const bytes\n-        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n-        llvals.push(cx.const_bytes(bytes));\n+        // inspect the result after interpreter execution).\n+        append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, range);\n     }\n \n     cx.const_struct(&llvals, true)"}, {"sha": "71580bcc06df17c451a6c9ad7a6702bc2d823c3c", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -721,20 +721,24 @@ impl InitMask {\n         }\n \n         // FIXME(oli-obk): optimize this for allocations larger than a block.\n-        let idx = (start.bytes()..end.bytes()).map(Size::from_bytes).find(|&i| !self.get(i));\n+        let idx = (start..end).find(|&i| !self.get(i));\n \n         match idx {\n             Some(idx) => {\n-                let uninit_end = (idx.bytes()..end.bytes())\n-                    .map(Size::from_bytes)\n-                    .find(|&i| self.get(i))\n-                    .unwrap_or(end);\n+                let uninit_end = (idx..end).find(|&i| self.get(i)).unwrap_or(end);\n                 Err(idx..uninit_end)\n             }\n             None => Ok(()),\n         }\n     }\n \n+    /// Returns an iterator, yielding a range of byte indexes for each contiguous region\n+    /// of initialized or uninitialized bytes inside the range `start..end` (end-exclusive).\n+    #[inline]\n+    pub fn range_as_init_chunks(&self, start: Size, end: Size) -> InitChunkIter<'_> {\n+        InitChunkIter::new(self, start, end)\n+    }\n+\n     pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {\n         let len = self.len;\n         if end > len {\n@@ -827,6 +831,49 @@ impl InitMask {\n     }\n }\n \n+/// Yields [`InitChunk`]s. See [`InitMask::range_as_init_chunks`].\n+pub struct InitChunkIter<'a> {\n+    init_mask: &'a InitMask,\n+    /// The current byte index into `init_mask`.\n+    start: Size,\n+    /// The end byte index into `init_mask`.\n+    end: Size,\n+}\n+\n+/// A contiguous chunk of initialized or uninitialized memory.\n+pub enum InitChunk {\n+    Init(Range<Size>),\n+    Uninit(Range<Size>),\n+}\n+\n+impl<'a> InitChunkIter<'a> {\n+    fn new(init_mask: &'a InitMask, start: Size, end: Size) -> Self {\n+        assert!(start <= end);\n+        assert!(end <= init_mask.len);\n+        Self { init_mask, start, end }\n+    }\n+}\n+\n+impl<'a> Iterator for InitChunkIter<'a> {\n+    type Item = InitChunk;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.start >= self.end {\n+            return None;\n+        }\n+\n+        let is_init = self.init_mask.get(self.start);\n+        // FIXME(oli-obk): optimize this for allocations larger than a block.\n+        let end_of_chunk =\n+            (self.start..self.end).find(|&i| self.init_mask.get(i) != is_init).unwrap_or(self.end);\n+        let range = self.start..end_of_chunk;\n+\n+        self.start = end_of_chunk;\n+\n+        Some(if is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) })\n+    }\n+}\n+\n #[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();"}, {"sha": "4628c24292f02a168454b25f54a5ce3ccce306ea", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -125,7 +125,9 @@ pub use self::error::{\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};\n \n-pub use self::allocation::{alloc_range, AllocRange, Allocation, InitMask, Relocations};\n+pub use self::allocation::{\n+    alloc_range, AllocRange, Allocation, InitChunk, InitChunkIter, InitMask, Relocations,\n+};\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};\n "}, {"sha": "88f1b1c320c1e3137722f2cc318ddd5a6b280df4", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -5,6 +5,7 @@ use crate::spec::Target;\n \n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n+use std::iter::Step;\n use std::num::NonZeroUsize;\n use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n use std::str::FromStr;\n@@ -440,6 +441,43 @@ impl AddAssign for Size {\n     }\n }\n \n+impl Step for Size {\n+    #[inline]\n+    fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+        u64::steps_between(&start.bytes(), &end.bytes())\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::forward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward_unchecked(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::backward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward_unchecked(start.bytes(), count))\n+    }\n+}\n+\n /// Alignment of a type in bytes (always a power of two).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]"}, {"sha": "e75c52555b90347418bdb8255f7b7fe1d3b2bf72", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -14,6 +14,8 @@\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n #![feature(min_specialization)]\n+#![feature(step_trait)]\n+#![feature(unchecked_math)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "e47a9f9ee20118ed486df937ae375fe154cff5b7", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -43,14 +43,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 2 %1, i8* align 2 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 2 %1, i8* align 2 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }"}, {"sha": "518bf7f451f2653877c485b35537f47f614e34ab", "filename": "src/test/codegen/uninit-consts.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funinit-consts.rs?ref=4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "patch": "@@ -0,0 +1,51 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+// Check that we use undef (and not zero) for uninitialized bytes in constants.\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::MaybeUninit;\n+\n+pub struct PartiallyUninit {\n+    x: u32,\n+    y: MaybeUninit<[u8; 10]>\n+}\n+\n+// CHECK: [[FULLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [10 x i8] }> undef\n+// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [4 x i8], [12 x i8] }> <{ [4 x i8] c\"\\EF\\BE\\AD\\DE\", [12 x i8] undef }>, align 4\n+// CHECK: [[FULLY_UNINIT_HUGE:@[0-9]+]] = private unnamed_addr constant <{ [16384 x i8] }> undef\n+\n+// This shouldn't contain undef, since generating huge partially undef constants is expensive.\n+// CHECK: [[UNINIT_PADDING_HUGE:@[0-9]+]] = private unnamed_addr constant <{ [32768 x i8] }> <{ [32768 x i8] c\"{{.+}}\" }>, align 4\n+\n+// CHECK-LABEL: @fully_uninit\n+#[no_mangle]\n+pub const fn fully_uninit() -> MaybeUninit<[u8; 10]> {\n+    const M: MaybeUninit<[u8; 10]> = MaybeUninit::uninit();\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 1 %1, i8* align 1 getelementptr inbounds (<{ [10 x i8] }>, <{ [10 x i8] }>* [[FULLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 10, i1 false)\n+    M\n+}\n+\n+// CHECK-LABEL: @partially_uninit\n+#[no_mangle]\n+pub const fn partially_uninit() -> PartiallyUninit {\n+    const X: PartiallyUninit = PartiallyUninit { x: 0xdeadbeef, y: MaybeUninit::uninit() };\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [12 x i8] }>, <{ [4 x i8], [12 x i8] }>* [[PARTIALLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 16, i1 false)\n+    X\n+}\n+\n+// CHECK-LABEL: @fully_uninit_huge\n+#[no_mangle]\n+pub const fn fully_uninit_huge() -> MaybeUninit<[u32; 4096]> {\n+    const F: MaybeUninit<[u32; 4096]> = MaybeUninit::uninit();\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [16384 x i8] }>, <{ [16384 x i8] }>* [[FULLY_UNINIT_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 16384, i1 false)\n+    F\n+}\n+\n+// CHECK-LABEL: @uninit_padding_huge\n+#[no_mangle]\n+pub const fn uninit_padding_huge() -> [(u32, u8); 4096] {\n+    const X: [(u32, u8); 4096] = [(123, 45); 4096];\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [32768 x i8] }>, <{ [32768 x i8] }>* [[UNINIT_PADDING_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 32768, i1 false)\n+    X\n+}"}]}