{"sha": "b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMDY5MjBkOWQ4YzQ2ZWUzOGQzZDM5MzBhZmM1N2QyYTBjZmIzZjc=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-14T21:54:59Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-16T23:46:19Z"}, "message": "Updating the communication portion of the tutorial in terms of pipes", "tree": {"sha": "e2b32f2d782c001f4f9becb29e56a9c9374a2951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2b32f2d782c001f4f9becb29e56a9c9374a2951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7", "html_url": "https://github.com/rust-lang/rust/commit/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "924e787119969c740911d0d1aaf28ab19b77c1a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/924e787119969c740911d0d1aaf28ab19b77c1a2", "html_url": "https://github.com/rust-lang/rust/commit/924e787119969c740911d0d1aaf28ab19b77c1a2"}], "stats": {"total": 106, "additions": 47, "deletions": 59}, "files": [{"sha": "e6c414c186dfce10108245e38af43f7cf9557c46", "filename": "doc/tutorial.md", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b206920d9d8c46ee38d3d3930afc57d2a0cfb3f7", "patch": "@@ -2882,21 +2882,20 @@ arguments and generates no return value. The effect of `task::spawn()`\n is to fire up a child task that will execute the closure in parallel\n with the creator.\n \n-## Ports and channels\n+## Communication\n \n Now that we have spawned a child task, it would be nice if we could\n-communicate with it.  This is done by creating a *port* with an\n-associated *channel*.  A port is simply a location to receive messages\n-of a particular type.  A channel is used to send messages to a port.\n-For example, imagine we wish to perform two expensive computations\n-in parallel.  We might write something like:\n+communicate with it. This is done using *pipes*. Pipes are simply a\n+pair of endpoints, with one for sending messages and another for\n+receiving messages. The easiest way to create a pipe is to use\n+`pipes::stream`.  Imagine we wish to perform two expensive\n+computations in parallel.  We might write something like:\n \n ~~~~\n import task::spawn;\n-import comm::{port, chan};\n+import pipes::{stream, port, chan};\n \n-let port = port();\n-let chan = port.chan();\n+let (chan, port) = stream();\n \n do spawn {\n     let result = some_expensive_computation();\n@@ -2911,25 +2910,16 @@ let result = port.recv();\n ~~~~\n \n Let's walk through this code line-by-line.  The first line creates a\n-port for receiving integers:\n+stream for sending and receiving integers:\n \n ~~~~ {.ignore}\n-# import comm::port;\n-let port = port();\n+# import pipes::stream;\n+let (chan, port) = stream();\n ~~~~\n \n This port is where we will receive the message from the child task\n-once it is complete.  The second line creates a channel for sending\n-integers to the port `port`:\n-\n-~~~~\n-# import comm::{port, chan};\n-# let port = port::<int>();\n-let chan = port.chan();\n-~~~~\n-\n-The channel will be used by the child to send a message to the port.\n-The next statement actually spawns the child:\n+once it is complete.  The channel will be used by the child to send a\n+message to the port.  The next statement actually spawns the child:\n \n ~~~~\n # import task::{spawn};\n@@ -2953,10 +2943,9 @@ some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n ~~~~\n-# import comm::{port, chan};\n+# import pipes::{stream, port, chan};\n # fn some_other_expensive_computation() {}\n-# let port = port::<int>();\n-# let chan = chan::<int>(port);\n+# let (chan, port) = stream::<int>();\n # chan.send(0);\n some_other_expensive_computation();\n let result = port.recv();\n@@ -2965,74 +2954,73 @@ let result = port.recv();\n ## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n-and child both need to exchange messages with each\n-other. The function `task::spawn_conversation()` supports this pattern.\n-We'll look briefly at how it is used.\n+and child both need to exchange messages with each other. There\n+function `std::comm::DuplexStream()` supports this pattern.  We'll\n+look briefly at how it is used.\n \n To see how `spawn_conversation()` works, we will create a child task\n that receives `uint` messages, converts them to a string, and sends\n the string in response.  The child terminates when `0` is received.\n Here is the function that implements the child task:\n \n ~~~~\n-# import comm::{Port, port, Chan, chan};\n-fn stringifier(from_parent: Port<uint>,\n-               to_parent: Chan<~str>) {\n+# import std::comm::DuplexStream;\n+# import pipes::{port, chan};\n+fn stringifier(channel: DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n-        value = from_parent.recv();\n-        to_parent.send(uint::to_str(value, 10u));\n+        value = channel.recv();\n+        channel.send(uint::to_str(value, 10u));\n         if value == 0u { break; }\n     }\n }\n ~~~~\n \n-You can see that the function takes two parameters.  The first is a\n-port used to receive messages from the parent, and the second is a\n-channel used to send messages to the parent.  The body itself simply\n-loops, reading from the `from_parent` port and then sending its\n-response to the `to_parent` channel.  The actual response itself is\n-simply the strified version of the received value,\n+The implementation of `DuplexStream` supports both sending and\n+receiving. The `stringifier` function takes a `DuplexStream` that can\n+send strings (the first type parameter) and receive `uint` messages\n+(the second type parameter). The body itself simply loops, reading\n+from the channel and then sending its response back.  The actual\n+response itself is simply the strified version of the received value,\n `uint::to_str(value)`.\n \n Here is the code for the parent task:\n \n ~~~~\n-# import task::{spawn_conversation};\n-# import comm::{Chan, chan, Port, port};\n-# fn stringifier(from_parent: comm::Port<uint>,\n-#                to_parent: comm::Chan<~str>) {\n-#     comm::send(to_parent, ~\"22\");\n-#     comm::send(to_parent, ~\"23\");\n-#     comm::send(to_parent, ~\"0\");\n+# import std::comm::DuplexStream;\n+# import pipes::{port, chan};\n+# import task::spawn;\n+# fn stringifier(channel: DuplexStream<~str, uint>) {\n+#     let mut value: uint;\n+#     loop {\n+#         value = channel.recv();\n+#         channel.send(uint::to_str(value, 10u));\n+#         if value == 0u { break; }\n+#     }\n # }\n # fn main() {\n \n-let (from_child, to_child) = do spawn_conversation |from_parent, to_parent| {\n-    stringifier(from_parent, to_parent);\n+let (from_child, to_child) = DuplexStream();\n+\n+do spawn |to_child| {\n+    stringifier();\n };\n \n-to_child.send(22u);\n+from_child.send(22u);\n assert from_child.recv() == ~\"22\";\n \n-to_child.send(23u);\n-to_child.send(0u);\n+from_child.send(23u);\n+from_child.send(0u);\n \n assert from_child.recv() == ~\"23\";\n assert from_child.recv() == ~\"0\";\n \n # }\n ~~~~\n \n-The parent task calls `spawn_conversation` with a function that takes\n-a `from_parent` port and a `to_parent` channel.  In return, it gets a\n-`from_child` channel and a `to_child` port.  As a result, both parent\n+The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n and child can send and receive data to and from the other.\n \n-`spawn_conversation`\n-will create two port/channel pairs, passing one set to the child task\n-and returning the other set to the caller.\n-\n # Testing\n \n The Rust language has a facility for testing built into the language."}]}