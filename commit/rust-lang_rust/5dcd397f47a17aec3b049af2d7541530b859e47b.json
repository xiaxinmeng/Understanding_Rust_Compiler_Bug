{"sha": "5dcd397f47a17aec3b049af2d7541530b859e47b", "node_id": "C_kwDOAAsO6NoAKDVkY2QzOTdmNDdhMTdhZWMzYjA0OWFmMmQ3NTQxNTMwYjg1OWU0N2I", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-09T02:42:06Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-09T21:23:45Z"}, "message": "Finish refactoring ints in ops.rs\n\nThis should perform a SIMD check for whether or not we can div/rem,\nso that we can panic several times faster!", "tree": {"sha": "57401164ef99af0566f2daed4c8c1e1a90010361", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57401164ef99af0566f2daed4c8c1e1a90010361"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dcd397f47a17aec3b049af2d7541530b859e47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd397f47a17aec3b049af2d7541530b859e47b", "html_url": "https://github.com/rust-lang/rust/commit/5dcd397f47a17aec3b049af2d7541530b859e47b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dcd397f47a17aec3b049af2d7541530b859e47b/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "049e8ca7f7fc42501b98afcb9c32fd51080bd75a", "url": "https://api.github.com/repos/rust-lang/rust/commits/049e8ca7f7fc42501b98afcb9c32fd51080bd75a", "html_url": "https://github.com/rust-lang/rust/commit/049e8ca7f7fc42501b98afcb9c32fd51080bd75a"}], "stats": {"total": 271, "additions": 147, "deletions": 124}, "files": [{"sha": "e6d7e695391cf142419f9fc7e80b207c968c9a8b", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 147, "deletions": 124, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/5dcd397f47a17aec3b049af2d7541530b859e47b/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dcd397f47a17aec3b049af2d7541530b859e47b/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=5dcd397f47a17aec3b049af2d7541530b859e47b", "patch": "@@ -1,5 +1,4 @@\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n use core::ops::{Add, Mul};\n use core::ops::{BitAnd, BitOr, BitXor};\n use core::ops::{Div, Rem, Sub};\n@@ -284,145 +283,169 @@ float_arith! {\n     }\n }\n \n-/// Automatically implements operators over references in addition to the provided operator.\n-macro_rules! impl_ref_ops {\n-    // binary op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            type Output = $output:ty;\n-\n-            $(#[$attrs:meta])*\n-            fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n+// Division by zero is poison, according to LLVM.\n+// So is dividing the MIN value of a signed integer by -1,\n+// since that would return MAX + 1.\n+// FIXME: Rust allows <SInt>::MIN / -1,\n+// so we should probably figure out how to make that safe.\n+macro_rules! int_divrem_guard {\n+    ($(impl<const LANES: usize> $op:ident for Simd<$sint:ty, LANES> {\n+        const PANIC_ZERO: &'static str = $zero:literal;\n+        const PANIC_OVERFLOW: &'static str = $overflow:literal;\n+        fn $call:ident {\n+            unsafe { $simd_call:ident }\n         }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n+    })*) => {\n+        $(impl<const LANES: usize> $op for Simd<$sint, LANES>\n         where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n+            $sint: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n-            type Output = $output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n-        }\n+            type Output = Self;\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: Self) -> Self::Output {\n+                if rhs.lanes_eq(Simd::splat(0)).any() {\n+                    panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                } else if <$sint>::MIN != 0 && self.lanes_eq(Simd::splat(<$sint>::MIN)) & rhs.lanes_eq(Simd::splat(-1 as _))\n+                    != Mask::splat(false)\n+                 {\n+                    panic!(\"attempt to calculate the remainder with overflow\");\n+                } else {\n+                    unsafe { $crate::intrinsics::$simd_call(self, rhs) }\n+                 }\n+             }\n+        })*\n     };\n }\n \n-/// Automatically implements operators over vectors and scalars for a particular vector.\n-macro_rules! impl_op {\n-    { impl Add for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Add::add, simd_add }\n-    };\n-    { impl Sub for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Sub::sub, simd_sub }\n-    };\n-    { impl Mul for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Mul::mul, simd_mul }\n-    };\n-    { impl Div for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Div::div, simd_div }\n-    };\n-    { impl Rem for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Rem::rem, simd_rem }\n-    };\n+macro_rules! int_arith {\n+    ($(impl<const LANES: usize> IntArith for Simd<$sint:ty, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    })*) => {\n+        $(\n+        unsafe_base_op!{\n+            impl<const LANES: usize> Add for Simd<$sint, LANES> {\n+                fn add(self, rhs: Self) -> Self::Output {\n+                    unsafe { simd_add }\n+                }\n+            }\n \n-    // generic binary op with assignment when output is `Self`\n-    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $intrinsic:ident } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n+            impl<const LANES: usize> Mul for Simd<$sint, LANES> {\n+                fn mul(self, rhs: Self) -> Self::Output {\n+                    unsafe { simd_mul }\n+                }\n+            }\n \n-                #[inline]\n-                fn $trait_fn(self, rhs: Self) -> Self::Output {\n-                    unsafe {\n-                        intrinsics::$intrinsic(self, rhs)\n-                    }\n+            impl<const LANES: usize> Sub for Simd<$sint, LANES> {\n+                fn sub(self, rhs: Self) -> Self::Output {\n+                    unsafe { simd_sub }\n                 }\n             }\n         }\n-    };\n-}\n \n-/// Implements unsigned integer operators for the provided types.\n-macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty),* } => {\n-        $(\n-            impl_op! { impl Add for $scalar }\n-            impl_op! { impl Sub for $scalar }\n-            impl_op! { impl Mul for $scalar }\n-\n-            // Integers panic on divide by 0\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn div(self, rhs: Self) -> Self::Output {\n-                        if rhs.as_array()\n-                            .iter()\n-                            .any(|x| *x == 0)\n-                        {\n-                            panic!(\"attempt to divide by zero\");\n-                        }\n-\n-                        // Guards for div(MIN, -1),\n-                        // this check only applies to signed ints\n-                        if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                .zip(rhs.as_array().iter())\n-                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                            panic!(\"attempt to divide with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_div(self, rhs) }\n-                    }\n+        int_divrem_guard!{\n+            impl<const LANES: usize> Div for Simd<$sint, LANES> {\n+                const PANIC_ZERO: &'static str = \"attempt to divide by zero\";\n+                const PANIC_OVERFLOW: &'static str = \"attempt to divide with overflow\";\n+                fn div {\n+                    unsafe { simd_div }\n                 }\n             }\n \n-            // remainder panics on zero divisor\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: Self) -> Self::Output {\n-                        if rhs.as_array()\n-                            .iter()\n-                            .any(|x| *x == 0)\n-                        {\n-                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                        }\n-\n-                        // Guards for rem(MIN, -1)\n-                        // this branch applies the check only to signed ints\n-                        if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                .zip(rhs.as_array().iter())\n-                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                            panic!(\"attempt to calculate the remainder with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_rem(self, rhs) }\n-                    }\n+            impl<const LANES: usize> Rem for Simd<$sint, LANES> {\n+                const PANIC_ZERO: &'static str = \"attempt to calculate the remainder with a divisor of zero\";\n+                const PANIC_OVERFLOW: &'static str = \"attempt to calculate the remainder with overflow\";\n+                fn rem {\n+                    unsafe { simd_rem }\n                 }\n             }\n-        )*\n-    };\n+        })*\n+    }\n }\n \n-/// Implements unsigned integer operators for the provided types.\n-macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty),* } => {\n-        impl_unsigned_int_ops! { $($scalar),* }\n-    };\n-}\n+int_arith! {\n+    impl<const LANES: usize> IntArith for Simd<i8, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n \n-impl_unsigned_int_ops! { u8, u16, u32, u64, usize }\n-impl_signed_int_ops! { i8, i16, i32, i64, isize }\n+    impl<const LANES: usize> IntArith for Simd<i16, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<i32, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<i64, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<isize, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<u8, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<u16, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<u32, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<u64, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+\n+    impl<const LANES: usize> IntArith for Simd<usize, LANES> {\n+        fn add(self, rhs: Self) -> Self::Output;\n+        fn mul(self, rhs: Self) -> Self::Output;\n+        fn sub(self, rhs: Self) -> Self::Output;\n+        fn div(self, rhs: Self) -> Self::Output;\n+        fn rem(self, rhs: Self) -> Self::Output;\n+    }\n+}"}]}