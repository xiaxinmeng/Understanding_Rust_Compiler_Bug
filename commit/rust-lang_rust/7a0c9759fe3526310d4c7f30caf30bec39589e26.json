{"sha": "7a0c9759fe3526310d4c7f30caf30bec39589e26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMGM5NzU5ZmUzNTI2MzEwZDRjN2YzMGNhZjMwYmVjMzk1ODllMjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-07T19:10:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-08T08:24:14Z"}, "message": "rustc: Make unique pointers no longer immediates.", "tree": {"sha": "8302bde3de2ecf921bc421d6e57dc110ca3fb90a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8302bde3de2ecf921bc421d6e57dc110ca3fb90a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0c9759fe3526310d4c7f30caf30bec39589e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0c9759fe3526310d4c7f30caf30bec39589e26", "html_url": "https://github.com/rust-lang/rust/commit/7a0c9759fe3526310d4c7f30caf30bec39589e26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0c9759fe3526310d4c7f30caf30bec39589e26/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9946e467ff682820826fe14eae24b64418269b1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9946e467ff682820826fe14eae24b64418269b1f", "html_url": "https://github.com/rust-lang/rust/commit/9946e467ff682820826fe14eae24b64418269b1f"}], "stats": {"total": 158, "additions": 88, "deletions": 70}, "files": [{"sha": "572ce71f75c0c059d33072f02a0890b4481ecdac", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7a0c9759fe3526310d4c7f30caf30bec39589e26", "patch": "@@ -2088,12 +2088,13 @@ fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n             let sp = cx.sp;\n             let llsz = llsize_of(type_of(ccx, sp, t));\n             ret call_memmove(cx, dst, src, llsz);\n-        } else { ret rslt(cx, Store(cx, Load(cx, src), dst)); }\n-    }\n-    else {\n-        let llsz = size_of(cx, t);\n-        ret call_memmove(llsz.bcx, dst, src, llsz.val);\n+        }\n+\n+        ret rslt(cx, Store(cx, Load(cx, src), dst));\n     }\n+\n+    let llsz = size_of(cx, t);\n+    ret call_memmove(llsz.bcx, dst, src, llsz.val);\n }\n \n tag copy_action { INIT; DROP_EXISTING; }\n@@ -2136,17 +2137,18 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n         Store(cx, src, dst);\n         ret cx;\n-    } else if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) {\n-        ret cx;\n-    } else if ty::type_is_boxed(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t) {\n-        let bcx =\n-            if action == DROP_EXISTING { drop_ty(cx, dst, t) } else { cx };\n+    }\n+    if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) { ret cx; }\n+    if ty::type_is_boxed(ccx.tcx, t) {\n+        let bcx = cx;\n+        if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n         Store(bcx, src, dst);\n-        bcx = take_ty(bcx, dst, t);\n-        ret bcx;\n-    } else if type_is_structural_or_param(ccx.tcx, t) {\n-        let bcx =\n-            if action == DROP_EXISTING { drop_ty(cx, dst, t) } else { cx };\n+        ret take_ty(bcx, dst, t);\n+    }\n+    if type_is_structural_or_param(ccx.tcx, t) ||\n+            ty::type_is_vec(ccx.tcx, t) {\n+        let bcx = cx;\n+        if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n         bcx = memmove_ty(bcx, dst, src, t).bcx;\n         ret take_ty(bcx, dst, t);\n     }\n@@ -2170,7 +2172,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n-    } else if ty::type_is_unique(tcx, t) || ty::type_is_boxed(tcx, t) {\n+    } else if ty::type_is_boxed(tcx, t) {\n         if src.is_mem { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n@@ -2179,7 +2181,8 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n-    } else if type_is_structural_or_param(tcx, t) {\n+    } else if ty::type_is_unique(tcx, t) ||\n+            type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t).bcx;\n         if src.is_mem {\n@@ -3496,7 +3499,8 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n                     if is_val { T_ptr(llout_arg_ty) } else { llout_arg_ty };\n                 val = PointerCast(bcx, val, ty);\n             }\n-            if is_val && type_is_immediate(cx.ccx, e_ty) {\n+            if is_val && (type_is_immediate(cx.ccx, e_ty) ||\n+                          ty::type_is_unique(cx.ccx.tcx, e_ty)) {\n                 val = Load(bcx, val);\n             }\n             llargs += [val];\n@@ -3529,6 +3533,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n         type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(T_ptr(lltargetty)));\n     lltargetfn = Load(bcx, lltargetfn);\n+\n     FastCall(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -3629,25 +3634,25 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if arg.mode == ty::mo_val {\n-        if !lv.is_mem {\n-            // Do nothing for temporaries, just give them to callee\n+        if ty::type_is_vec(ccx.tcx, e_ty) {\n+            let r = do_spill(bcx, Load(bcx, val), e_ty);\n+            bcx = r.bcx;\n+            let arg_copy = r.val;\n+\n+            bcx = take_ty(bcx, arg_copy, e_ty);\n+            val = Load(bcx, arg_copy);\n+            add_clean_temp(bcx, arg_copy, e_ty);\n+        } else if !lv.is_mem {\n+            // Do nothing for non-vector temporaries; just give them to the\n+            // callee.\n         } else if type_is_structural_or_param(ccx.tcx, e_ty) {\n             let dst = alloc_ty(bcx, e_ty);\n             bcx = copy_val(dst.bcx, INIT, dst.val, val, e_ty);\n             val = dst.val;\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n-            if ty::type_is_vec(ccx.tcx, e_ty) {\n-                let r = do_spill(bcx, Load(bcx, val), e_ty);\n-                bcx = r.bcx;\n-                let arg_copy = r.val;\n-\n-                bcx = take_ty(bcx, arg_copy, e_ty);\n-                val = Load(bcx, arg_copy);\n-            } else {\n-                bcx = take_ty(bcx, val, e_ty);\n-                val = load_if_immediate(bcx, val, e_ty);\n-            }\n+            bcx = take_ty(bcx, val, e_ty);\n+            val = load_if_immediate(bcx, val, e_ty);\n             add_clean_temp(bcx, val, e_ty);\n         }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n@@ -4185,7 +4190,7 @@ fn with_out_method(work: fn(&out_method) -> result, cx: @block_ctxt,\n // immediate-ness of the type.\n fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n     ret ty::type_is_scalar(ccx.tcx, t) || ty::type_is_boxed(ccx.tcx, t) ||\n-            ty::type_is_native(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t);\n+            ty::type_is_native(ccx.tcx, t);\n }\n \n fn do_spill(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n@@ -5305,9 +5310,12 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         let arg_ty = arg_tys[i].ty;\n         let llargval;\n         if ty::type_is_structural(cx.ccx.tcx, arg_ty) ||\n-               ty::type_has_dynamic_size(cx.ccx.tcx, arg_ty) {\n+               ty::type_has_dynamic_size(cx.ccx.tcx, arg_ty) ||\n+               ty::type_is_unique(cx.ccx.tcx, arg_ty) {\n             llargval = llargptr;\n-        } else { llargval = Load(bcx, llargptr); }\n+        } else {\n+            llargval = Load(bcx, llargptr);\n+        }\n         bcx = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n         i += 1u;\n     }"}, {"sha": "f8e844cc2d65c3ede4cf3e6016cc2faaf9aad1e0", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=7a0c9759fe3526310d4c7f30caf30bec39589e26", "patch": "@@ -407,8 +407,10 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             }\n           }\n           lit(l) {\n-            test_val = Load(bcx, val);\n-            kind = alt l.node { ast::lit_str(_) { compare } _ { switch } };\n+            kind = alt l.node {\n+              ast::lit_str(_) { compare }\n+              _ { test_val = Load(bcx, val); switch }\n+            };\n           }\n         }\n     }"}, {"sha": "da568b7e0e4a8607e8ec77030de4fa56077bc2d6", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0c9759fe3526310d4c7f30caf30bec39589e26/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=7a0c9759fe3526310d4c7f30caf30bec39589e26", "patch": "@@ -7,19 +7,20 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n                incr_ptr, INIT, copy_val, load_if_immediate, alloca, size_of,\n                llderivedtydescs_block_ctxt, lazily_emit_tydesc_glue,\n                get_tydesc, load_inbounds, move_val_if_temp, trans_lval,\n-               node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot};\n+               node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot,\n+               GEPi, alloc_ty};\n import trans_build::*;\n import trans_common::*;\n \n-fn get_fill(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::vec_elt_fill)]))\n+fn get_fill(bcx: &@block_ctxt, vptrptr: ValueRef) -> ValueRef {\n+    Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_fill as int]))\n }\n-fn get_alloc(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::vec_elt_alloc)]))\n+fn get_alloc(bcx: &@block_ctxt, vptrptr: ValueRef) -> ValueRef {\n+    Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_alloc as int]))\n }\n-fn get_dataptr(bcx: &@block_ctxt, vpt: ValueRef, unit_ty: TypeRef) ->\n+fn get_dataptr(bcx: &@block_ctxt, vptrptr: ValueRef, unit_ty: TypeRef) ->\n    ValueRef {\n-    let ptr = InBoundsGEP(bcx, vpt, [C_int(0), C_uint(abi::vec_elt_elems)]);\n+    let ptr = GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_elems as int]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n@@ -59,17 +60,22 @@ fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n     let alloc = if elts < 4u { Mul(bcx, C_int(4), unit_sz) } else { fill };\n     let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n-    add_clean_temp(bcx, vptr, vec_ty);\n+\n+    let r = alloc_ty(bcx, vec_ty);\n+    let vptrptr = r.val; bcx = r.bcx;\n+\n+    Store(bcx, vptr, vptrptr);\n+    add_clean_temp(bcx, vptrptr, vec_ty);\n     ret {bcx: bcx,\n-         val: vptr,\n+         val: vptrptr,\n          unit_ty: unit_ty,\n          llunitsz: unit_sz,\n          llunitty: llunitty};\n }\n \n fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n+    let fill = get_fill(bcx, vptrptr);\n     let vptr = Load(bcx, vptrptr);\n-    let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n     let {bcx: bcx, val: newptr} =\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n@@ -135,13 +141,13 @@ fn trans_str(bcx: &@block_ctxt, s: str) -> result {\n }\n \n fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-                rhs: ValueRef) -> result {\n+                rhsptr: ValueRef) -> result {\n     // Cast to opaque interior vector types if necessary.\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n     if dynamic {\n         lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n-        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_vec()));\n+        rhsptr = PointerCast(cx, rhsptr, T_ptr(T_ptr(T_opaque_vec())));\n     }\n     let strings =\n         alt ty::struct(bcx_tcx(cx), vec_ty) {\n@@ -152,26 +158,26 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n     let llunitty = type_of_or_i8(cx, unit_ty);\n \n+    let rhs = Load(bcx, rhsptr);\n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::LLVMIntEQ, lhs, rhs);\n-    let lfill = get_fill(bcx, lhs);\n-    let rfill = get_fill(bcx, rhs);\n+    let lfill = get_fill(bcx, lhsptr);\n+    let rfill = get_fill(bcx, rhsptr);\n     let new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n     Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n          [cx.fcx.lltaskptr, opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n-    let lhs = Load(bcx, lhsptr);\n-    let rhs = Select(bcx, self_append, lhs, rhs);\n+    rhsptr = Select(bcx, self_append, lhsptr, rhsptr);\n \n-    let lhs_data = get_dataptr(bcx, lhs, llunitty);\n+    let lhs_data = get_dataptr(bcx, lhsptr, llunitty);\n     let lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n     let bcx =\n-        iter_vec_raw(bcx, rhs, vec_ty, rfill,\n+        iter_vec_raw(bcx, rhsptr, vec_ty, rfill,\n                      // We have to increment by the dynamically-computed size.\n                      {|&bcx, addr, _ty|\n                          let write_ptr = Load(bcx, write_ptr_ptr);\n@@ -211,7 +217,8 @@ fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret bcx;\n }\n \n-fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef, rhs: ValueRef)\n+fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n+             rhsptr: ValueRef)\n    -> result {\n     let strings =\n         alt ty::struct(bcx_tcx(bcx), vec_ty) {\n@@ -222,16 +229,18 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef, rhs: ValueRef)\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n-    let lhs_fill = get_fill(bcx, lhs);\n+    let lhs_fill = get_fill(bcx, lhsptr);\n     if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n-    let rhs_fill = get_fill(bcx, rhs);\n+    let rhs_fill = get_fill(bcx, rhsptr);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n-    let {bcx: bcx, val: new_vec} = alloc_raw(bcx, new_fill, new_fill);\n-    let new_vec = PointerCast(bcx, new_vec, T_ptr(T_vec(llunitty)));\n-    add_clean_temp(bcx, new_vec, vec_ty);\n+    let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n+    new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(llunitty)));\n+    let {bcx: bcx, val: new_vec_ptr_ptr} = alloc_ty(bcx, vec_ty);\n+    Store(bcx, new_vec_ptr, new_vec_ptr_ptr);\n+    add_clean_temp(bcx, new_vec_ptr_ptr, vec_ty);\n \n     let write_ptr_ptr =\n-        do_spill_noroot(bcx, get_dataptr(bcx, new_vec, llunitty));\n+        do_spill_noroot(bcx, get_dataptr(bcx, new_vec_ptr_ptr, llunitty));\n     let copy_fn =\n         bind fn (bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n                  write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n@@ -247,22 +256,22 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef, rhs: ValueRef)\n                  ret bcx;\n              }(_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n-    let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n-    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n-    ret rslt(bcx, new_vec);\n+    let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n+    let bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n+    ret rslt(bcx, new_vec_ptr_ptr);\n }\n \n type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n \n type iter_vec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n-fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n+fn iter_vec_raw(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: &iter_vec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(llunitty)));\n-    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n+    vptrptr = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_vec(llunitty))));\n+    let data_ptr = get_dataptr(bcx, vptrptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n     // TODO: Optimize this when the size of the unit type is statically\n@@ -292,9 +301,8 @@ fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n             f: &iter_vec_block) -> @block_ctxt {\n-    let vptr =\n-        Load(bcx, PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec()))));\n-    ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+    vptrptr = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n+    ret iter_vec_raw(bcx, vptrptr, vec_ty, get_fill(bcx, vptrptr), f);\n }\n \n //"}]}