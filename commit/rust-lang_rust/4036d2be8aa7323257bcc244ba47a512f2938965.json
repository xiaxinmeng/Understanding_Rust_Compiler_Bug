{"sha": "4036d2be8aa7323257bcc244ba47a512f2938965", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMzZkMmJlOGFhNzMyMzI1N2JjYzI0NGJhNDdhNTEyZjI5Mzg5NjU=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-18T02:35:40Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-27T10:09:58Z"}, "message": "Create a job immediately when looking in the query map and start it later", "tree": {"sha": "a8e7bdbfba8150d9ad2d42e9f7a86c6b42355377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8e7bdbfba8150d9ad2d42e9f7a86c6b42355377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4036d2be8aa7323257bcc244ba47a512f2938965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4036d2be8aa7323257bcc244ba47a512f2938965", "html_url": "https://github.com/rust-lang/rust/commit/4036d2be8aa7323257bcc244ba47a512f2938965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4036d2be8aa7323257bcc244ba47a512f2938965/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9822b5709ca78d6398e9ae609de0181116e8b0db", "url": "https://api.github.com/repos/rust-lang/rust/commits/9822b5709ca78d6398e9ae609de0181116e8b0db", "html_url": "https://github.com/rust-lang/rust/commit/9822b5709ca78d6398e9ae609de0181116e8b0db"}], "stats": {"total": 463, "additions": 217, "deletions": 246}, "files": [{"sha": "a4c500510ae5f85f1f6329fbbbfa818bd54032c3", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=4036d2be8aa7323257bcc244ba47a512f2938965", "patch": "@@ -15,18 +15,24 @@ use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTy\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n+use ty::maps::Query;\n+use ty::maps::QueryMap;\n \n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::sync::Lock;\n \n /// Query configuration and description traits.\n \n-pub trait QueryConfig {\n+pub trait QueryConfig<'tcx> {\n     type Key: Eq + Hash + Clone;\n-    type Value;\n+    type Value: Clone;\n+\n+    fn query(key: Self::Key) -> Query<'tcx>;\n+    fn query_map<'a>(tcx: TyCtxt<'a, 'tcx, '_>) -> &'a Lock<QueryMap<'tcx, Self>>;\n }\n \n-pub(super) trait QueryDescription<'tcx>: QueryConfig {\n+pub(super) trait QueryDescription<'tcx>: QueryConfig<'tcx> {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n \n     #[inline]\n@@ -41,7 +47,7 @@ pub(super) trait QueryDescription<'tcx>: QueryConfig {\n     }\n }\n \n-impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryConfig<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.item_path_str(def_id))"}, {"sha": "c931f79e9517d7c08a7032344556c21b5d9f3b23", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=4036d2be8aa7323257bcc244ba47a512f2938965", "patch": "@@ -68,7 +68,6 @@ pub use self::plumbing::force_from_dep_node;\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n-use self::job::QueryResult;\n \n mod keys;\n pub use self::keys::Key;"}, {"sha": "6dfa72a3cf3f33ff622b1cabc466f0136bcc8c6c", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=4036d2be8aa7323257bcc244ba47a512f2938965", "patch": "@@ -239,8 +239,8 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<specialization_graph_of, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants\n-                use ty::maps::plumbing::GetCacheInternal;\n-                for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n+                use ty::maps::QueryConfig;\n+                for (key, entry) in const_eval::query_map(tcx).borrow().map.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n                         let entry = match *entry {\n@@ -1124,7 +1124,7 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n                                               query_result_index: &mut EncodedQueryResultIndex)\n                                               -> Result<(), E::Error>\n-    where Q: super::plumbing::GetCacheInternal<'tcx>,\n+    where Q: super::config::QueryDescription<'tcx>,\n           E: 'enc + TyEncoder,\n           Q::Value: Encodable,\n {\n@@ -1133,7 +1133,7 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(tcx.sess, desc, || {\n \n-    for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n+    for (key, entry) in Q::query_map(tcx).borrow().map.iter() {\n         if Q::cache_on_disk(key.clone()) {\n             let entry = match *entry {\n                 QueryResult::Complete(ref v) => v,"}, {"sha": "4fb12be6fb14ce7923e8cbb714d1a13e94616e27", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 202, "deletions": 236, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=4036d2be8aa7323257bcc244ba47a512f2938965", "patch": "@@ -15,20 +15,26 @@\n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use errors::Level;\n+use errors::Diagnostic;\n+use errors::FatalError;\n use ty::tls;\n use ty::{TyCtxt};\n use ty::maps::Query;\n+use ty::maps::config::QueryConfig;\n use ty::maps::config::QueryDescription;\n-use ty::maps::job::{QueryResult, QueryInfo};\n+use ty::maps::job::{QueryJob, QueryResult, QueryInfo};\n use ty::item_path;\n \n+use util::common::{profq_msg, ProfileQueriesMsg};\n+\n use rustc_data_structures::fx::{FxHashMap};\n-use rustc_data_structures::sync::LockGuard;\n-use std::marker::PhantomData;\n+use rustc_data_structures::sync::{Lrc, Lock};\n+use std::mem;\n+use std::ptr;\n+use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n \n-pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n-    phantom: PhantomData<(D, &'tcx ())>,\n+pub struct QueryMap<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n     pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n }\n \n@@ -48,18 +54,157 @@ impl<T> QueryValue<T> {\n     }\n }\n \n-impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n+impl<'tcx, M: QueryConfig<'tcx>> QueryMap<'tcx, M> {\n     pub(super) fn new() -> QueryMap<'tcx, M> {\n         QueryMap {\n-            phantom: PhantomData,\n             map: FxHashMap(),\n         }\n     }\n }\n \n-pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n-    fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> LockGuard<'a, QueryMap<'tcx, Self>>;\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries() {\n+                profq_msg($tcx.sess, $msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n+/// A type representing the responsibility to execute the job in the `job` field.\n+/// This will poison the relevant query if dropped.\n+pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n+    map: &'a Lock<QueryMap<'tcx, Q>>,\n+    key: Q::Key,\n+    job: Lrc<QueryJob<'tcx>>,\n+}\n+\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n+    /// Either gets a JobOwner corresponding the the query, allowing us to\n+    /// start executing the query, or it returns with the result of the query.\n+    /// If the query is executing elsewhere, this will wait for it.\n+    /// If the query panicked, this will silently panic.\n+    pub(super) fn try_get(\n+        tcx: TyCtxt<'a, 'tcx, '_>,\n+        span: Span,\n+        key: &Q::Key,\n+    ) -> TryGetJob<'a, 'tcx, Q> {\n+        let map = Q::query_map(tcx);\n+        loop {\n+            let mut lock = map.borrow_mut();\n+            let job = match lock.map.entry((*key).clone()) {\n+                Entry::Occupied(entry) => {\n+                    match *entry.get() {\n+                        QueryResult::Started(ref job) => job.clone(),\n+                        QueryResult::Complete(ref value) => {\n+                            profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                            let result = Ok((value.value.clone(), value.index));\n+                            return TryGetJob::JobCompleted(result);\n+                        },\n+                        QueryResult::Poisoned => FatalError.raise(),\n+                    }\n+                }\n+                Entry::Vacant(entry) => {\n+                    // No job entry for this query. Return a new one to be started later\n+                    return tls::with_related_context(tcx, |icx| {\n+                        let info = QueryInfo {\n+                            span,\n+                            query: Q::query(key.clone()),\n+                        };\n+                        let job = Lrc::new(QueryJob::new(info, icx.query.clone()));\n+                        let owner = JobOwner {\n+                            map,\n+                            job: job.clone(),\n+                            key: (*key).clone(),\n+                        };\n+                        entry.insert(QueryResult::Started(job));\n+                        TryGetJob::NotYetStarted(owner)\n+                    })\n+                }\n+            };\n+            mem::drop(lock);\n+\n+            if let Err(cycle) = job.await(tcx, span) {\n+                return TryGetJob::JobCompleted(Err(cycle));\n+            }\n+        }\n+    }\n+\n+    /// Completes the query by updating the query map with the `result`,\n+    /// signals the waiter and forgets the JobOwner, so it won't poison the query\n+    pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n+        // We can move out of `self` here because we `mem::forget` it below\n+        let key = unsafe { ptr::read(&self.key) };\n+        let job = unsafe { ptr::read(&self.job) };\n+        let map = self.map;\n+\n+        // Forget ourself so our destructor won't poison the query\n+        mem::forget(self);\n+\n+        let value = QueryValue::new(result.clone(), dep_node_index);\n+        map.borrow_mut().map.insert(key, QueryResult::Complete(value));\n+\n+        job.signal_complete();\n+    }\n+\n+    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    pub(super) fn start<'lcx, F, R>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        compute: F)\n+    -> (R, Vec<Diagnostic>)\n+    where\n+        F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n+    {\n+        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n+        // when accessing the ImplicitCtxt\n+        let r = tls::with_related_context(tcx, move |icx| {\n+            // Update the ImplicitCtxt to point to our new query job\n+            let icx = tls::ImplicitCtxt {\n+                tcx,\n+                query: Some(self.job.clone()),\n+                layout_depth: icx.layout_depth,\n+                task: icx.task,\n+            };\n+\n+            // Use the ImplicitCtxt while we execute the query\n+            tls::enter_context(&icx, |icx| {\n+                compute(icx.tcx)\n+            })\n+        });\n+\n+        // Extract the diagnostic from the job\n+        let diagnostics = mem::replace(&mut *self.job.diagnostics.lock(), Vec::new());\n+\n+        (r, diagnostics)\n+    }\n+}\n+\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+    fn drop(&mut self) {\n+        // Poison the query so jobs waiting on it panic\n+        self.map.borrow_mut().map.insert(self.key.clone(), QueryResult::Poisoned);\n+        // Also signal the completion of the job, so waiters\n+        // will continue execution\n+        self.job.signal_complete();\n+    }\n }\n \n #[derive(Clone)]\n@@ -70,14 +215,14 @@ pub(super) struct CycleError<'tcx> {\n }\n \n /// The result of `try_get_lock`\n-pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n+pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query is not yet started. Contains a guard to the map eventually used to start it.\n-    NotYetStarted(LockGuard<'a, QueryMap<'tcx, D>>),\n+    NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(T, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -182,29 +327,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-// If enabled, send a message to the profile-queries thread\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, format a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None }\n-    }\n-}\n-\n macro_rules! handle_cycle_error {\n     ([][$this: expr]) => {{\n         Value::from_cycle_error($this.global_tcx())\n@@ -224,11 +346,7 @@ macro_rules! define_maps {\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use dep_graph::DepNodeIndex;\n-        use std::mem;\n-        use errors::Diagnostic;\n-        use errors::FatalError;\n-        use rustc_data_structures::sync::{Lock, LockGuard};\n-        use rustc_data_structures::OnDrop;\n+        use rustc_data_structures::sync::Lock;\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -303,15 +421,16 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-        }\n \n-        impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n-            fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n-                                      -> LockGuard<'a, QueryMap<$tcx, Self>> {\n-                tcx.maps.$name.borrow()\n+            fn query(key: Self::Key) -> Query<'tcx> {\n+                Query::$name(key)\n+            }\n+\n+            fn query_map<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryMap<$tcx, Self>> {\n+                &tcx.maps.$name\n             }\n         }\n \n@@ -324,43 +443,6 @@ macro_rules! define_maps {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            /// Either get the lock of the query map, allowing us to\n-            /// start executing the query, or it returns with the result of the query.\n-            /// If the query already executed and panicked, this will fatal error / silently panic\n-            fn try_get_lock(\n-                tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                span: Span,\n-                key: &$K\n-            ) -> TryGetLock<'a, $tcx, $V, Self>\n-            {\n-                loop {\n-                    let lock = tcx.maps.$name.borrow_mut();\n-                    let job = if let Some(value) = lock.map.get(key) {\n-                        match *value {\n-                            QueryResult::Started(ref job) => Some(job.clone()),\n-                            QueryResult::Complete(ref value) => {\n-                                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                                let result = Ok(((&value.value).clone(), value.index));\n-                                return TryGetLock::JobCompleted(result);\n-                            },\n-                            QueryResult::Poisoned => FatalError.raise(),\n-                        }\n-                    } else {\n-                        None\n-                    };\n-                    let job = if let Some(job) = job {\n-                        job\n-                    } else {\n-                        return TryGetLock::NotYetStarted(lock);\n-                    };\n-                    mem::drop(lock);\n-\n-                    if let Err(cycle) = job.await(tcx, span) {\n-                        return TryGetLock::JobCompleted(Err(cycle));\n-                    }\n-                }\n-            }\n-\n             fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                             span: Span,\n                             key: $K)\n@@ -378,29 +460,21 @@ macro_rules! define_maps {\n                     )\n                 );\n \n-                /// Get the lock used to start the query or\n-                /// return the result of the completed query\n-                macro_rules! get_lock_or_return {\n-                    () => {{\n-                        match Self::try_get_lock(tcx, span, &key) {\n-                            TryGetLock::NotYetStarted(lock) => lock,\n-                            TryGetLock::JobCompleted(result) => {\n-                                return result.map(|(v, index)| {\n-                                    tcx.dep_graph.read_index(index);\n-                                    v\n-                                })\n-                            }\n-                        }\n-                    }}\n-                }\n-\n-                let mut lock = get_lock_or_return!();\n+                let job = match JobOwner::try_get(tcx, span, &key) {\n+                    TryGetJob::NotYetStarted(job) => job,\n+                    TryGetJob::JobCompleted(result) => {\n+                        return result.map(|(v, index)| {\n+                            tcx.dep_graph.read_index(index);\n+                            v\n+                        })\n+                    }\n+                };\n \n                 // Fast path for when incr. comp. is off. `to_dep_node` is\n                 // expensive for some DepKinds.\n                 if !tcx.dep_graph.is_fully_enabled() {\n                     let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force_with_lock(tcx, key, span, lock, null_dep_node)\n+                    return Self::force_with_job(tcx, key, job, null_dep_node)\n                                 .map(|(v, _)| v);\n                 }\n \n@@ -409,48 +483,37 @@ macro_rules! define_maps {\n                 if dep_node.kind.is_anon() {\n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n-                    let res = Self::start_job(tcx, span, key, lock, |tcx| {\n+                    let res = job.start(tcx, |tcx| {\n                         tcx.dep_graph.with_anon_task(dep_node.kind, || {\n                             Self::compute_result(tcx.global_tcx(), key)\n                         })\n-                    })?;\n+                    });\n \n                     profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let (((result, dep_node_index), diagnostics), job) = res;\n+                    let ((result, dep_node_index), diagnostics) = res;\n \n                     tcx.dep_graph.read_index(dep_node_index);\n \n                     tcx.on_disk_query_result_cache\n                        .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n \n-                    let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                    tcx.maps\n-                       .$name\n-                       .borrow_mut()\n-                       .map\n-                       .insert(key, QueryResult::Complete(value));\n-\n-                    job.signal_complete();\n+                    job.complete(&result, dep_node_index);\n \n                     return Ok(result);\n                 }\n \n                 if !dep_node.kind.is_input() {\n-                    // try_mark_green_and_read may force queries. So we must drop our lock here\n-                    mem::drop(lock);\n                     if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n-                                                                        span,\n+                                                                        job,\n                                                                         dep_node_index,\n                                                                         &dep_node)\n                     }\n-                    lock = get_lock_or_return!();\n                 }\n \n-                match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n+                match Self::force_with_job(tcx, key, job, dep_node) {\n                     Ok((result, dep_node_index)) => {\n                         tcx.dep_graph.read_index(dep_node_index);\n                         Ok(result)\n@@ -483,83 +546,14 @@ macro_rules! define_maps {\n                 }\n             }\n \n-            /// Creates a job for the query and updates the query map indicating that it started.\n-            /// Then it changes ImplicitCtxt to point to the new query job while it executes.\n-            /// If the query panics, this updates the query map to indicate so.\n-            fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n-                               span: Span,\n-                               key: $K,\n-                               mut map: LockGuard<'_, QueryMap<$tcx, Self>>,\n-                               compute: F)\n-                -> Result<((R, Vec<Diagnostic>), Lrc<QueryJob<$tcx>>), CycleError<$tcx>>\n-                where F: for<'b> FnOnce(TyCtxt<'b, $tcx, 'lcx>) -> R\n-            {\n-                let query = Query::$name(Clone::clone(&key));\n-\n-                let entry = QueryInfo {\n-                    span,\n-                    query,\n-                };\n-\n-                // The TyCtxt stored in TLS has the same global interner lifetime\n-                // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n-                // when accessing the ImplicitCtxt\n-                let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n-                    let job = Lrc::new(QueryJob::new(entry, icx.query.clone()));\n-\n-                    // Store the job in the query map and drop the lock to allow\n-                    // others to wait it\n-                    map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n-                    mem::drop(map);\n-\n-                    let r = {\n-                        let on_drop = OnDrop(|| {\n-                            // Poison the query so jobs waiting on it panic\n-                            tcx.maps\n-                            .$name\n-                            .borrow_mut()\n-                            .map\n-                            .insert(key, QueryResult::Poisoned);\n-                            // Also signal the completion of the job, so waiters\n-                            // will continue execution\n-                            job.signal_complete();\n-                        });\n-\n-                        // Update the ImplicitCtxt to point to our new query job\n-                        let icx = ty::tls::ImplicitCtxt {\n-                            tcx,\n-                            query: Some(job.clone()),\n-                            layout_depth: icx.layout_depth,\n-                            task: icx.task,\n-                        };\n-\n-                        // Use the ImplicitCtxt while we execute the query\n-                        let r = ty::tls::enter_context(&icx, |icx| {\n-                            compute(icx.tcx)\n-                        });\n-\n-                        mem::forget(on_drop);\n-\n-                        r\n-                    };\n-\n-                    (r, job)\n-                });\n-\n-                // Extract the diagnostic from the job\n-                let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n-\n-                Ok(((r, diagnostics), job))\n-            }\n-\n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n             }\n \n             fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                                                   key: $K,\n-                                                  span: Span,\n+                                                  job: JobOwner<'a, $tcx, Self>,\n                                                   dep_node_index: DepNodeIndex,\n                                                   dep_node: &DepNode)\n                                                   -> Result<$V, CycleError<$tcx>>\n@@ -589,27 +583,23 @@ macro_rules! define_maps {\n                     None\n                 };\n \n-                let (result, job) = if let Some(result) = result {\n-                    (result, None)\n+                let result = if let Some(result) = result {\n+                    result\n                 } else {\n                     // We could not load a result from the on-disk cache, so\n                     // recompute.\n \n                     // The diagnostics for this query have already been\n                     // promoted to the current session during\n                     // try_mark_green(), so we can ignore them here.\n-                    let ((result, _), job) = Self::start_job(tcx,\n-                                                             span,\n-                                                             key,\n-                                                             tcx.maps.$name.borrow_mut(),\n-                                                             |tcx| {\n+                    let (result, _) = job.start(tcx, |tcx| {\n                         // The dep-graph for this computation is already in\n                         // place\n                         tcx.dep_graph.with_ignore(|| {\n                             Self::compute_result(tcx, key)\n                         })\n-                    })?;\n-                    (result, Some(job))\n+                    });\n+                    result\n                 };\n \n                 // If -Zincremental-verify-ich is specified, re-hash results from\n@@ -642,15 +632,7 @@ macro_rules! define_maps {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                 }\n \n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                job.map(|j| j.signal_complete());\n+                job.complete(&result, dep_node_index);\n \n                 Ok(result)\n             }\n@@ -663,21 +645,19 @@ macro_rules! define_maps {\n                      -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n                 // We may be concurrently trying both execute and force a query\n                 // Ensure that only one of them runs the query\n-                let lock = match Self::try_get_lock(tcx, span, &key) {\n-                    TryGetLock::NotYetStarted(lock) => lock,\n-                    TryGetLock::JobCompleted(result) => return result,\n+                let job = match JobOwner::try_get(tcx, span, &key) {\n+                    TryGetJob::NotYetStarted(job) => job,\n+                    TryGetJob::JobCompleted(result) => return result,\n                 };\n-                Self::force_with_lock(tcx,\n-                                      key,\n-                                      span,\n-                                      lock,\n-                                      dep_node)\n+                Self::force_with_job(tcx,\n+                                     key,\n+                                     job,\n+                                     dep_node)\n             }\n \n-            fn force_with_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+            fn force_with_job(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                                key: $K,\n-                               span: Span,\n-                               map: LockGuard<'_, QueryMap<$tcx, Self>>,\n+                               job: JobOwner<'_, $tcx, Self>,\n                                dep_node: DepNode)\n                                -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n                 // If the following assertion triggers, it can have two reasons:\n@@ -692,11 +672,7 @@ macro_rules! define_maps {\n                         key, dep_node);\n \n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = Self::start_job(tcx,\n-                                          span,\n-                                          key,\n-                                          map,\n-                                          |tcx| {\n+                let res = job.start(tcx, |tcx| {\n                     if dep_node.kind.is_eval_always() {\n                         tcx.dep_graph.with_eval_always_task(dep_node,\n                                                             tcx,\n@@ -708,10 +684,10 @@ macro_rules! define_maps {\n                                                 key,\n                                                 Self::compute_result)\n                     }\n-                })?;\n+                });\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n-                let (((result, dep_node_index), diagnostics), job) = res;\n+                let ((result, dep_node_index), diagnostics) = res;\n \n                 if tcx.sess.opts.debugging_opts.query_dep_graph {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n@@ -722,17 +698,7 @@ macro_rules! define_maps {\n                        .store_diagnostics(dep_node_index, diagnostics);\n                 }\n \n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                let job: Lrc<QueryJob> = job;\n-\n-                job.signal_complete();\n+                job.complete(&result, dep_node_index);\n \n                 Ok((result, dep_node_index))\n             }"}, {"sha": "81812f9a1f37215a439db6d5f692bfc1dc6c22ee", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4036d2be8aa7323257bcc244ba47a512f2938965/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4036d2be8aa7323257bcc244ba47a512f2938965", "patch": "@@ -51,7 +51,7 @@ macro_rules! provide {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n-                                        QueryConfig>::Value\n+                                        QueryConfig<$lt>>::Value\n                 where T: IntoArgs,\n             {\n                 #[allow(unused_variables)]"}]}