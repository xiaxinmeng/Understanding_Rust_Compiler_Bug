{"sha": "c2d43e132975126dda1364346db8498fbc3917b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDQzZTEzMjk3NTEyNmRkYTEzNjQzNDZkYjg0OThmYmMzOTE3YjA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-27T08:03:10Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-15T17:31:47Z"}, "message": "Simplify metadata decoding.", "tree": {"sha": "ce38defbeccefe86668a5812808606c4b386d730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce38defbeccefe86668a5812808606c4b386d730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d43e132975126dda1364346db8498fbc3917b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d43e132975126dda1364346db8498fbc3917b0", "html_url": "https://github.com/rust-lang/rust/commit/c2d43e132975126dda1364346db8498fbc3917b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d43e132975126dda1364346db8498fbc3917b0/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea2ae933f4fda8e069a77f36cb6d8b21d93997", "html_url": "https://github.com/rust-lang/rust/commit/47ea2ae933f4fda8e069a77f36cb6d8b21d93997"}], "stats": {"total": 56, "additions": 12, "deletions": 44}, "files": [{"sha": "e2203fffd45ab6fd81b91cac6bf8e507efe7d7b5", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2d43e132975126dda1364346db8498fbc3917b0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d43e132975126dda1364346db8498fbc3917b0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=c2d43e132975126dda1364346db8498fbc3917b0", "patch": "@@ -35,7 +35,6 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, hygiene::MacroKind, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n-use std::cell::Cell;\n use std::io;\n use std::mem;\n use std::num::NonZeroUsize;\n@@ -370,21 +369,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnId, String> {\n         let local_cdata = decoder.cdata();\n         let sess = decoder.sess.unwrap();\n-        let expn_cnum = Cell::new(None);\n-        let get_ctxt = |cnum| {\n-            expn_cnum.set(Some(cnum));\n-            if cnum == LOCAL_CRATE {\n-                &local_cdata.hygiene_context\n-            } else {\n-                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n-            }\n-        };\n \n-        rustc_span::hygiene::decode_expn_id(decoder, get_ctxt, |_this, index| {\n-            let cnum = expn_cnum.get().unwrap();\n+        rustc_span::hygiene::decode_expn_id(decoder, |cnum, index| {\n             // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n             // are stored in the owning crate, to avoid duplication.\n-            let crate_data = if cnum == LOCAL_CRATE {\n+            debug_assert_ne!(cnum, LOCAL_CRATE);\n+            let crate_data = if cnum == local_cdata.cnum {\n                 local_cdata\n             } else {\n                 local_cdata.cstore.get_crate_data(cnum)\n@@ -401,7 +391,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n                 .get(&crate_data, index)\n                 .unwrap()\n                 .decode((&crate_data, sess));\n-            Ok((expn_data, expn_hash))\n+            (expn_data, expn_hash)\n         })\n     }\n }"}, {"sha": "e3174b47f8d0cd9364a7d8a39b33ab378a14e793", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c2d43e132975126dda1364346db8498fbc3917b0/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d43e132975126dda1364346db8498fbc3917b0/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=c2d43e132975126dda1364346db8498fbc3917b0", "patch": "@@ -1136,14 +1136,12 @@ pub fn decode_expn_id_incrcomp<D: Decoder>(\n     Ok(expn_id)\n }\n \n-pub fn decode_expn_id<'a, D: Decoder>(\n+pub fn decode_expn_id<D: Decoder>(\n     d: &mut D,\n-    get_context: impl FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n-    decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n+    decode_data: impl FnOnce(CrateNum, u32) -> (ExpnData, ExpnHash),\n ) -> Result<ExpnId, D::Error> {\n     let index = u32::decode(d)?;\n     let krate = CrateNum::decode(d)?;\n-    let context = get_context(krate);\n \n     // Do this after decoding, so that we decode a `CrateNum`\n     // if necessary\n@@ -1152,49 +1150,29 @@ pub fn decode_expn_id<'a, D: Decoder>(\n         return Ok(ExpnId::root());\n     }\n \n-    let outer_expns = &context.remapped_expns;\n-\n-    // Ensure that the lock() temporary is dropped early\n-    {\n-        if let Some(expn_id) = outer_expns.lock().get(index as usize).copied().flatten() {\n-            return Ok(expn_id);\n-        }\n-    }\n+    // This function is used to decode metadata, so it cannot decode information about LOCAL_CRATE.\n+    debug_assert_ne!(krate, LOCAL_CRATE);\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n-    let (mut expn_data, hash) = decode_data(d, index)?;\n+    let (expn_data, hash) = decode_data(krate, index);\n+    debug_assert_eq!(krate, expn_data.krate);\n+    debug_assert_eq!(expn_data.orig_id, Some(index));\n \n     let expn_id = HygieneData::with(|hygiene_data| {\n         if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n             return expn_id;\n         }\n \n         let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n-\n-        // If we just deserialized an `ExpnData` owned by\n-        // the local crate, its `orig_id` will be stale,\n-        // so we need to update it to its own value.\n-        // This only happens when we deserialize the incremental cache,\n-        // since a crate will never decode its own metadata.\n-        if expn_data.krate == LOCAL_CRATE {\n-            expn_data.orig_id = Some(expn_id.0);\n-        }\n-\n         hygiene_data.expn_data.push(Some(expn_data));\n         hygiene_data.expn_hashes.push(hash);\n         let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n         debug_assert!(_old_id.is_none());\n \n-        let mut expns = outer_expns.lock();\n-        let new_len = index as usize + 1;\n-        if expns.len() < new_len {\n-            expns.resize(new_len, None);\n-        }\n-        expns[index as usize] = Some(expn_id);\n-        drop(expns);\n         expn_id\n     });\n+\n     Ok(expn_id)\n }\n "}]}