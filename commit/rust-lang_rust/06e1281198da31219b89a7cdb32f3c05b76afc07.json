{"sha": "06e1281198da31219b89a7cdb32f3c05b76afc07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZTEyODExOThkYTMxMjE5Yjg5YTdjZGIzMmYzYzA1Yjc2YWZjMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-20T15:06:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-20T15:06:49Z"}, "message": "auto merge of #12403 : eddyb/rust/generic-dtors-with-bounds, r=nikomatsakis\n\nFix generic Drop impls with trait bounds.\r\nFixes #4252.", "tree": {"sha": "5974971af966a77efed81e1a788b5a3fc7dd1620", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5974971af966a77efed81e1a788b5a3fc7dd1620"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06e1281198da31219b89a7cdb32f3c05b76afc07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06e1281198da31219b89a7cdb32f3c05b76afc07", "html_url": "https://github.com/rust-lang/rust/commit/06e1281198da31219b89a7cdb32f3c05b76afc07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06e1281198da31219b89a7cdb32f3c05b76afc07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f324aaf203a9611e9c3ead934d64f92f136ee00", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f324aaf203a9611e9c3ead934d64f92f136ee00", "html_url": "https://github.com/rust-lang/rust/commit/5f324aaf203a9611e9c3ead934d64f92f136ee00"}, {"sha": "efaa1ea979c60dcb6884be12dcb12ceb09dbc5bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/efaa1ea979c60dcb6884be12dcb12ceb09dbc5bd", "html_url": "https://github.com/rust-lang/rust/commit/efaa1ea979c60dcb6884be12dcb12ceb09dbc5bd"}], "stats": {"total": 283, "additions": 122, "deletions": 161}, "files": [{"sha": "04009fba7f081f257c77940ba8e947ba1dc4132d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -20,7 +20,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n-use middle::typeck::{method_origin, method_map_entry};\n+use middle::typeck::method_origin;\n use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n@@ -573,35 +573,7 @@ impl tr for moves::CaptureVar {\n }\n \n // ______________________________________________________________________\n-// Encoding and decoding of method_map_entry\n-\n-trait read_method_map_entry_helper {\n-    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n-                             -> method_map_entry;\n-}\n-\n-fn encode_method_map_entry(ebml_w: &mut writer::Encoder, mme: method_map_entry) {\n-    ebml_w.emit_struct(\"method_map_entry\", 3, |ebml_w| {\n-        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n-            mme.origin.encode(ebml_w);\n-        });\n-    })\n-}\n-\n-impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n-    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n-                             -> method_map_entry {\n-        self.read_struct(\"method_map_entry\", 3, |this| {\n-            method_map_entry {\n-                origin: this.read_struct_field(\"origin\", 1, |this| {\n-                    let method_origin: method_origin =\n-                        Decodable::decode(this);\n-                    method_origin.tr(xcx)\n-                })\n-            }\n-        })\n-    }\n-}\n+// Encoding and decoding of method_origin\n \n impl tr for method_origin {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> method_origin {\n@@ -1023,11 +995,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     {\n         let method_map = maps.method_map.borrow();\n         let r = method_map.get().find(&id);\n-        for &mme in r.iter() {\n+        for &origin in r.iter() {\n             ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    encode_method_map_entry(ebml_w, *mme)\n+                    origin.encode(ebml_w);\n                 })\n             })\n         }\n@@ -1364,9 +1336,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                         ty_param_defs.get().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let entry = val_dsr.read_method_map_entry(xcx);\n+                        let origin: method_origin = Decodable::decode(val_dsr);\n                         let mut method_map = dcx.maps.method_map.borrow_mut();\n-                        method_map.get().insert(id, entry);\n+                        method_map.get().insert(id, origin.tr(xcx));\n                     }\n                     c::tag_table_vtable_map => {\n                         let vtable_res ="}, {"sha": "39b232eed33b7383ca5bc3d79e3b2020a23cc8fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -94,7 +94,7 @@ impl MarkSymbolVisitor {\n                                 span: codemap::Span) {\n         let method_map = self.method_map.borrow();\n         match method_map.get().find(id) {\n-            Some(&typeck::method_map_entry { origin, .. }) => {\n+            Some(&origin) => {\n                 match origin {\n                     typeck::method_static(def_id) => {\n                         match ty::provided_source(self.tcx, def_id) {"}, {"sha": "9be0a1b0fd3405018a1adcf655efc61484a85f64", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -285,8 +285,15 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n \n                 // Even though the callee_id may have been the id with\n                 // node_type_substs, e.id is correct here.\n-                ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n-                    \"non path/method call expr has type substs??\")\n+                match cx.method_map.borrow().get().find(&e.id) {\n+                    Some(origin) => {\n+                        ty::method_call_type_param_defs(cx.tcx, *origin)\n+                    }\n+                    None => {\n+                        cx.tcx.sess.span_bug(e.span,\n+                            \"non path/method call expr has type substs??\");\n+                    }\n+                }\n               }\n             };\n             let type_param_defs = type_param_defs.borrow();"}, {"sha": "37784116289f659020b9972601fc8f5626d6b6aa", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -1400,7 +1400,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         ast::ExprMethodCall(..) => {\n             let method_map = cx.method_map.borrow();\n             match method_map.get().find(&e.id) {\n-                Some(&typeck::method_map_entry { origin, .. }) => {\n+                Some(&origin) => {\n                     match origin {\n                         typeck::method_static(def_id) => {\n                             // If this implements a trait method, get def_id"}, {"sha": "7578636b2b6812b1485556d9fb6aa16579c36bf5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -790,17 +790,17 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n-                        let method_map = self.method_map.borrow();\n-                        let entry = match method_map.get().find(&expr.id) {\n+                        match self.method_map.borrow().get().find(&expr.id) {\n                             None => {\n                                 self.tcx.sess.span_bug(expr.span,\n                                                        \"method call not in \\\n                                                         method map\");\n                             }\n-                            Some(entry) => entry\n-                        };\n-                        debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &entry.origin, ident);\n+                            Some(origin) => {\n+                                debug!(\"(privacy checking) checking impl method\");\n+                                self.check_method(expr.span, origin, ident);\n+                            }\n+                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "ee948f5453babad20abefd24804bbd2f50ae7f28", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -149,10 +149,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n             ast::ExprMethodCall(..) => {\n                 let method_map = self.method_map.borrow();\n                 match method_map.get().find(&expr.id) {\n-                    Some(&typeck::method_map_entry {\n-                        origin: typeck::method_static(def_id),\n-                        ..\n-                    }) => {\n+                    Some(&typeck::method_static(def_id)) => {\n                         if is_local(def_id) {\n                             if ReachableContext::\n                                 def_id_represents_local_inlined_item(\n@@ -174,8 +171,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n                     Some(_) => {}\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n-                        \"method call expression \\\n-                                                   not in method map?!\")\n+                            \"method call expression not in method map?!\")\n                     }\n                 }\n             }"}, {"sha": "e76b2a81490e031f09e5aa9f8431bb6bc60015e3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -65,6 +65,7 @@ use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::trans::value::Value;\n use middle::ty;\n+use middle::typeck;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n use util::sha2::Sha256;\n@@ -535,22 +536,14 @@ pub fn get_res_dtor(ccx: @CrateContext,\n     };\n     if !substs.is_empty() {\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n-        let tsubsts = ty::substs {regions: ty::ErasedRegions,\n-                                  self_ty: None,\n-                                  tps: /*bad*/ substs.to_owned() };\n-\n-        // FIXME: #4252: Generic destructors with type bounds are broken.\n-        //\n-        // Since the vtables aren't passed to `monomorphic_fn` here, generic destructors with type\n-        // bounds are broken. Sadly, the `typeck` pass isn't outputting the necessary metadata\n-        // because it does so based on method calls present in the AST. Destructor calls are not yet\n-        // known about at that stage of compilation, since `trans` handles cleanups.\n-        let (val, _) = monomorphize::monomorphic_fn(ccx,\n-                                                    did,\n-                                                    &tsubsts,\n-                                                    None,\n-                                                    None,\n-                                                    None);\n+        let tsubsts = ty::substs {\n+            regions: ty::ErasedRegions,\n+            self_ty: None,\n+            tps: substs.to_owned()\n+        };\n+\n+        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx, did.node, &tsubsts);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, &tsubsts, vtables, None, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {"}, {"sha": "7fa116cafd0942ab8063475d5ea76a73db5b785b", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -95,16 +95,15 @@ pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n                            callee_id: ast::NodeId,\n                            this: &ast::Expr,\n-                           mentry: typeck::method_map_entry,\n+                           origin: typeck::method_origin,\n                            arg_cleanup_scope: cleanup::ScopeId)\n                            -> Callee<'a> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    debug!(\"trans_method_callee(callee_id={:?}, mentry={})\",\n-           callee_id,\n-           mentry.repr(bcx.tcx()));\n+    debug!(\"trans_method_callee(callee_id={:?}, origin={})\",\n+           callee_id, origin.repr(bcx.tcx()));\n \n-    match mentry.origin {\n+    match origin {\n         typeck::method_static(did) => {\n             Callee {\n                 bcx: bcx,"}, {"sha": "e19b6eb1634018d5c4962e3af33c019f52f81f74", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -3242,25 +3242,21 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-pub fn method_call_type_param_defs(tcx: ctxt,\n-                                   method_map: typeck::method_map,\n-                                   id: ast::NodeId)\n-                                   -> Option<Rc<~[TypeParameterDef]>> {\n-    let method_map = method_map.borrow();\n-    method_map.get().find(&id).map(|method| {\n-        match method.origin {\n-          typeck::method_static(did) => {\n+pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::method_origin)\n+                                   -> Rc<~[TypeParameterDef]> {\n+    match origin {\n+        typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n             // that we encode include both the impl bounds\n             // and then the method bounds themselves...\n             ty::lookup_item_type(tcx, did).generics.type_param_defs\n-          }\n-          typeck::method_param(typeck::method_param {\n-              trait_id: trt_id,\n-              method_num: n_mth, ..}) |\n-          typeck::method_object(typeck::method_object {\n-              trait_id: trt_id,\n-              method_num: n_mth, ..}) => {\n+        }\n+        typeck::method_param(typeck::method_param {\n+            trait_id: trt_id,\n+            method_num: n_mth, ..}) |\n+        typeck::method_object(typeck::method_object {\n+            trait_id: trt_id,\n+            method_num: n_mth, ..}) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -3271,9 +3267,8 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                 ty::trait_method(tcx,\n                                  trt_id,\n                                  n_mth).generics.type_param_defs()))\n-          }\n         }\n-    })\n+    }\n }\n \n pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {"}, {"sha": "1c7ad292877be9d1ddc9c82b7c06c5e79efb2e8d", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -20,17 +20,17 @@ use syntax::codemap::Span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn subtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: @FnCtxt,\n+pub fn suptype_with_fn(fcx: &FnCtxt,\n                        sp: Span,\n                        b_is_expected: bool,\n                        ty_a: ty::t,"}, {"sha": "fca89f3f91ca85929828446c60bc22f8ed10f3c7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -90,7 +90,7 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n-use middle::typeck::{method_map_entry, method_origin, method_param};\n+use middle::typeck::{method_origin, method_param};\n use middle::typeck::{method_static, method_object};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n@@ -133,7 +133,7 @@ pub fn lookup(\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n-     -> Option<method_map_entry> {\n+     -> Option<method_origin> {\n     let impl_dups = @RefCell::new(HashSet::new());\n     let lcx = LookupContext {\n         fcx: fcx,\n@@ -211,7 +211,7 @@ enum RcvrMatchCondition {\n }\n \n impl<'a> LookupContext<'a> {\n-    fn search(&self, self_ty: ty::t) -> Option<method_map_entry> {\n+    fn search(&self, self_ty: ty::t) -> Option<method_origin> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -592,7 +592,7 @@ impl<'a> LookupContext<'a> {\n     fn search_for_autoderefd_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n-                                        -> Option<method_map_entry> {\n+                                        -> Option<method_origin> {\n         let (self_ty, autoadjust) =\n             self.consider_reborrow(self_ty, autoderefs);\n         match self.search_for_method(self_ty) {\n@@ -686,9 +686,9 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_autosliced_method(&self,\n-                                        self_ty: ty::t,\n-                                        autoderefs: uint)\n-                                        -> Option<method_map_entry> {\n+                                    self_ty: ty::t,\n+                                    autoderefs: uint)\n+                                    -> Option<method_origin> {\n         /*!\n          *\n          * Searches for a candidate by converting things like\n@@ -763,7 +763,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n-                                      -> Option<method_map_entry> {\n+                                  -> Option<method_origin> {\n         /*!\n          *\n          * Converts any type `T` to `&M T` where `M` is an\n@@ -799,7 +799,7 @@ impl<'a> LookupContext<'a> {\n             autoderefs: uint,\n             mutbls: &[ast::Mutability],\n             mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-            -> Option<method_map_entry> {\n+            -> Option<method_origin> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region =\n@@ -823,7 +823,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn search_for_method(&self, rcvr_ty: ty::t)\n-                             -> Option<method_map_entry> {\n+                         -> Option<method_origin> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -855,7 +855,7 @@ impl<'a> LookupContext<'a> {\n     fn consider_candidates(&self,\n                            rcvr_ty: ty::t,\n                            candidates: &mut ~[Candidate])\n-                           -> Option<method_map_entry> {\n+                           -> Option<method_origin> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: ~[Candidate] =\n             candidates.iter().map(|c| (*c).clone()).\n@@ -926,7 +926,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n-                             -> method_map_entry {\n+                         -> method_origin {\n         // This method performs two sets of substitutions, one after the other:\n         // 1. Substitute values for any type/lifetime parameters from the impl and\n         //    method declaration into the method type. This is the function type\n@@ -1037,9 +1037,7 @@ impl<'a> LookupContext<'a> {\n \n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n-        method_map_entry {\n-            origin: candidate.origin\n-        }\n+        candidate.origin\n     }\n \n     fn construct_transformed_self_ty_for_object("}, {"sha": "f9bf52260d551e431ff45b939fc85c56157056e5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -590,8 +590,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n                                              ast_trait_ref,\n                                              impl_trait_ref,\n                                              *ms);\n-                vtable::resolve_impl(ccx, it, &impl_tpt.generics,\n-                                     impl_trait_ref);\n+                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -3831,8 +3830,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: @FnCtxt, sp: Span, tp: ty::t)\n-                               -> ty::t {\n+pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n         _ => {"}, {"sha": "ba4300b58a11a27af1abc6d79da640abef52d7b1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -18,7 +18,7 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{CrateCtxt, vtable_origin, vtable_res, vtable_param_res};\n+use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n use middle::typeck::{vtable_static, vtable_param, impl_res};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::subst::Subst;\n@@ -537,9 +537,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n     relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n-fn insert_vtables(fcx: @FnCtxt,\n-                  callee_id: ast::NodeId,\n-                  vtables: vtable_res) {\n+fn insert_vtables(fcx: &FnCtxt, callee_id: ast::NodeId, vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id={}, vtables={:?})\",\n            callee_id, vtables.repr(fcx.tcx()));\n     let mut vtable_map = fcx.inh.vtable_map.borrow_mut();\n@@ -559,7 +557,7 @@ pub fn location_info_for_item(item: &ast::Item) -> LocationInfo {\n     }\n }\n \n-pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n+pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex));\n     let _indent = indenter();\n@@ -693,20 +691,17 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n         });\n       }\n \n-      ast::ExprParen(e) => {\n-          early_resolve_expr(e, fcx, is_early);\n-      }\n-\n       // Must resolve bounds on methods with bounded params\n       ast::ExprBinary(callee_id, _, _, _) |\n       ast::ExprUnary(callee_id, _, _) |\n       ast::ExprAssignOp(callee_id, _, _, _) |\n       ast::ExprIndex(callee_id, _, _) |\n       ast::ExprMethodCall(callee_id, _, _, _) => {\n-        match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n-          Some(type_param_defs) => {\n+        match fcx.inh.method_map.borrow().get().find(&ex.id) {\n+          Some(origin) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n+            let type_param_defs = ty::method_call_type_param_defs(cx.tcx, *origin);\n             if has_trait_bounds(*type_param_defs.borrow()) {\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = fcx.vtable_context();\n@@ -717,7 +712,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n                 }\n             }\n           }\n-          None => ()\n+          None => {}\n         }\n       }\n       ast::ExprCast(src, _) => {\n@@ -761,33 +756,27 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n     }\n }\n \n-fn resolve_expr(fcx: @FnCtxt, ex: &ast::Expr) {\n-    let mut fcx = fcx;\n-    early_resolve_expr(ex, fcx, false);\n-    visit::walk_expr(&mut fcx, ex, ());\n-}\n-\n-pub fn resolve_impl(ccx: @CrateCtxt,\n+pub fn resolve_impl(tcx: ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n     let param_env = ty::construct_parameter_environment(\n-        ccx.tcx,\n+        tcx,\n         None,\n         impl_generics.type_param_defs(),\n         [],\n         impl_generics.region_param_defs(),\n         impl_item.id);\n \n-    let impl_trait_ref = @impl_trait_ref.subst(ccx.tcx, &param_env.free_substs);\n+    let impl_trait_ref = @impl_trait_ref.subst(tcx, &param_env.free_substs);\n \n-    let infcx = &infer::new_infer_ctxt(ccx.tcx);\n+    let infcx = &infer::new_infer_ctxt(tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n     let loc_info = location_info_for_item(impl_item);\n \n     // First, check that the impl implements any trait bounds\n     // on the trait.\n-    let trait_def = ty::lookup_trait_def(ccx.tcx, impl_trait_ref.def_id);\n+    let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);\n     let vtbls = lookup_vtables(&vcx,\n                                &loc_info,\n                                trait_def.generics.type_param_defs(),\n@@ -801,8 +790,8 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n         trait_bounds: ~[impl_trait_ref]\n     };\n-    let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-    let t = t.subst(ccx.tcx, &param_env.free_substs);\n+    let t = ty::node_id_to_type(tcx, impl_item.id);\n+    let t = t.subst(tcx, &param_env.free_substs);\n     debug!(\"=== Doing a self lookup now.\");\n \n     // Right now, we don't have any place to store this.\n@@ -819,13 +808,36 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n     };\n     let impl_def_id = ast_util::local_def(impl_item.id);\n \n-    let mut impl_vtables = ccx.tcx.impl_vtables.borrow_mut();\n+    let mut impl_vtables = tcx.impl_vtables.borrow_mut();\n     impl_vtables.get().insert(impl_def_id, res);\n }\n \n-impl visit::Visitor<()> for @FnCtxt {\n+/// Resolve vtables for a method call after typeck has finished.\n+/// Used by trans to monomorphize artificial method callees (e.g. drop).\n+pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n+                            substs: &ty::substs) -> Option<vtable_res> {\n+    let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n+    let type_param_defs = generics.type_param_defs.borrow();\n+    if has_trait_bounds(*type_param_defs) {\n+        let vcx = VtableContext {\n+            infcx: &infer::new_infer_ctxt(tcx),\n+            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], id)\n+        };\n+        let loc_info = LocationInfo {\n+            id: id,\n+            span: tcx.map.span(id)\n+        };\n+\n+        Some(lookup_vtables(&vcx, &loc_info, *type_param_defs, substs, false))\n+    } else {\n+        None\n+    }\n+}\n+\n+impl<'a> visit::Visitor<()> for &'a FnCtxt {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n-        resolve_expr(*self, ex);\n+        early_resolve_expr(ex, *self, false);\n+        visit::walk_expr(self, ex, ());\n     }\n     fn visit_item(&mut self, _: &ast::Item, _: ()) {\n         // no-op\n@@ -834,6 +846,6 @@ impl visit::Visitor<()> for @FnCtxt {\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(mut fcx: @FnCtxt, bl: &ast::Block) {\n+pub fn resolve_in_block(mut fcx: &FnCtxt, bl: &ast::Block) {\n     visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "3741fd1c17360c50a730641c85488ddb4da2319d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -141,16 +141,9 @@ pub struct method_object {\n     real_index: uint,\n }\n \n-\n-#[deriving(Clone)]\n-pub struct method_map_entry {\n-    // method details being invoked\n-    origin: method_origin,\n-}\n-\n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type method_map = @RefCell<HashMap<ast::NodeId, method_map_entry>>;\n+pub type method_map = @RefCell<HashMap<ast::NodeId, method_origin>>;\n \n pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path."}, {"sha": "14d12b7f648dda4d8d1c00375fc572af5b852a11", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -870,12 +870,6 @@ impl Repr for ty::FnSig {\n     }\n }\n \n-impl Repr for typeck::method_map_entry {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"method_map_entry \\\\{origin: {}\\\\}\", self.origin.repr(tcx))\n-    }\n-}\n-\n impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {"}, {"sha": "ba080e9818302f7d9c8af3249de5a87ce82d7492", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e1281198da31219b89a7cdb32f3c05b76afc07/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=06e1281198da31219b89a7cdb32f3c05b76afc07", "patch": "@@ -8,30 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n-\n trait X {\n-    fn call(&self);\n+    fn call<T>(&self, x: &T);\n+    fn default_method<T>(&self, x: &T) {\n+        println!(\"X::default_method {:?} {:?}\", self, x);\n+    }\n }\n \n-struct Y;\n+struct Y(int);\n \n struct Z<T> {\n     x: T\n }\n \n impl X for Y {\n-    fn call(&self) {\n+    fn call<T>(&self, x: &T) {\n+        println!(\"X::call {:?} {:?}\", self, x);\n     }\n }\n \n+#[unsafe_destructor]\n impl<T: X> Drop for Z<T> {\n     fn drop(&mut self) {\n-        self.x.call(); // Adding this statement causes an ICE.\n+        // These statements used to cause an ICE.\n+        self.x.call(self);\n+        self.x.default_method(self);\n     }\n }\n \n pub fn main() {\n-    let y = Y;\n-    let _z = Z{x: y};\n+    let _z = Z {x: Y(42)};\n }"}]}