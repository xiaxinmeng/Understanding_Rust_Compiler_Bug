{"sha": "6c88aeda5809b570da7f92a82113fa8bd6184c4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODhhZWRhNTgwOWI1NzBkYTdmOTJhODIxMTNmYThiZDYxODRjNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-20T07:07:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-20T07:07:25Z"}, "message": "Auto merge of #27044 - nrc:graphviz-style, r=@pnkfelix\n\nr? @pnkfelix", "tree": {"sha": "46bcf0c9c1a56f2b2bb78ded08728c822adbb22f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46bcf0c9c1a56f2b2bb78ded08728c822adbb22f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c88aeda5809b570da7f92a82113fa8bd6184c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c88aeda5809b570da7f92a82113fa8bd6184c4b", "html_url": "https://github.com/rust-lang/rust/commit/6c88aeda5809b570da7f92a82113fa8bd6184c4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c88aeda5809b570da7f92a82113fa8bd6184c4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e3b756f28a20969b30494d2289db4a40b6eb805", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3b756f28a20969b30494d2289db4a40b6eb805", "html_url": "https://github.com/rust-lang/rust/commit/5e3b756f28a20969b30494d2289db4a40b6eb805"}, {"sha": "75f8f966f05c0ec98fbc1755691a8d2921c3b566", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f8f966f05c0ec98fbc1755691a8d2921c3b566", "html_url": "https://github.com/rust-lang/rust/commit/75f8f966f05c0ec98fbc1755691a8d2921c3b566"}], "stats": {"total": 189, "additions": 157, "deletions": 32}, "files": [{"sha": "4d07573268a68fbd0e691f5b53adbe60945944c2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 157, "deletions": 32, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/6c88aeda5809b570da7f92a82113fa8bd6184c4b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c88aeda5809b570da7f92a82113fa8bd6184c4b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=6c88aeda5809b570da7f92a82113fa8bd6184c4b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -312,6 +312,40 @@ pub enum LabelText<'a> {\n     EscStr(Cow<'a, str>),\n }\n \n+/// The style for a node or edge.\n+/// See http://www.graphviz.org/doc/info/attrs.html#k:style for descriptions.\n+/// Note that some of these are not valid for edges.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Style {\n+    None,\n+    Solid,\n+    Dashed,\n+    Dotted,\n+    Bold,\n+    Rounded,\n+    Diagonals,\n+    Filled,\n+    Striped,\n+    Wedged,\n+}\n+\n+impl Style {\n+    pub fn as_slice(self) -> &'static str {\n+        match self {\n+            Style::None => \"\",\n+            Style::Solid => \"solid\",\n+            Style::Dashed => \"dashed\",\n+            Style::Dotted => \"dotted\",\n+            Style::Bold => \"bold\",\n+            Style::Rounded => \"rounded\",\n+            Style::Diagonals => \"diagonals\",\n+            Style::Filled => \"filled\",\n+            Style::Striped => \"striped\",\n+            Style::Wedged => \"wedged\",\n+        }\n+    }\n+}\n+\n // There is a tension in the design of the labelling API.\n //\n // For example, I considered making a `Labeller<T>` trait that\n@@ -430,6 +464,16 @@ pub trait Labeller<'a,N,E> {\n         let _ignored = e;\n         LabelStr(\"\".into_cow())\n     }\n+\n+    /// Maps `n` to a style that will be used in the rendered output.\n+    fn node_style(&'a self, _n: &N) -> Style {\n+        Style::None\n+    }\n+\n+    /// Maps `e` to a style that will be used in the rendered output.\n+    fn edge_style(&'a self, _e: &E) -> Style {\n+        Style::None\n+    }\n }\n \n impl<'a> LabelText<'a> {\n@@ -529,6 +573,8 @@ pub trait GraphWalk<'a, N, E> {\n pub enum RenderOption {\n     NoEdgeLabels,\n     NoNodeLabels,\n+    NoEdgeStyles,\n+    NoNodeStyles,\n }\n \n /// Returns vec holding all the default render options.\n@@ -562,30 +608,53 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n     for n in g.nodes().iter() {\n         try!(indent(w));\n         let id = g.node_id(n);\n-        if options.contains(&RenderOption::NoNodeLabels) {\n-            try!(writeln(w, &[id.as_slice(), \";\"]));\n-        } else {\n-            let escaped = g.node_label(n).escape();\n-            try!(writeln(w, &[id.as_slice(),\n-                              \"[label=\\\"\", &escaped, \"\\\"];\"]));\n+\n+        let escaped = &g.node_label(n).escape();\n+\n+        let mut text = vec![id.as_slice()];\n+\n+        if !options.contains(&RenderOption::NoNodeLabels) {\n+            text.push(\"[label=\\\"\");\n+            text.push(escaped);\n+            text.push(\"\\\"]\");\n+        }\n+\n+        let style = g.node_style(n);\n+        if !options.contains(&RenderOption::NoNodeStyles) && style != Style::None {\n+            text.push(\"[style=\\\"\");\n+            text.push(style.as_slice());\n+            text.push(\"\\\"]\");\n         }\n+\n+        text.push(\";\");\n+        try!(writeln(w, &text));\n     }\n \n     for e in g.edges().iter() {\n-        let escaped_label = g.edge_label(e).escape();\n+        let escaped_label = &g.edge_label(e).escape();\n         try!(indent(w));\n         let source = g.source(e);\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n         let target_id = g.node_id(&target);\n-        if options.contains(&RenderOption::NoEdgeLabels) {\n-            try!(writeln(w, &[source_id.as_slice(),\n-                              \" -> \", target_id.as_slice(), \";\"]));\n-        } else {\n-            try!(writeln(w, &[source_id.as_slice(),\n-                              \" -> \", target_id.as_slice(),\n-                              \"[label=\\\"\", &escaped_label, \"\\\"];\"]));\n+\n+        let mut text = vec![source_id.as_slice(), \" -> \", target_id.as_slice()];\n+\n+        if !options.contains(&RenderOption::NoEdgeLabels) {\n+            text.push(\"[label=\\\"\");\n+            text.push(escaped_label);\n+            text.push(\"\\\"]\");\n+        }\n+\n+        let style = g.edge_style(e);\n+        if !options.contains(&RenderOption::NoEdgeStyles) && style != Style::None {\n+            text.push(\"[style=\\\"\");\n+            text.push(style.as_slice());\n+            text.push(\"\\\"]\");\n         }\n+\n+        text.push(\";\");\n+        try!(writeln(w, &text));\n     }\n \n     writeln(w, &[\"}\"])\n@@ -594,7 +663,7 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n #[cfg(test)]\n mod tests {\n     use self::NodeLabels::*;\n-    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render};\n+    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n     use super::LabelText::{self, LabelStr, EscStr};\n     use std::io;\n     use std::io::prelude::*;\n@@ -603,11 +672,14 @@ mod tests {\n     /// each node is an index in a vector in the graph.\n     type Node = usize;\n     struct Edge {\n-        from: usize, to: usize, label: &'static str\n+        from: usize,\n+        to: usize,\n+        label: &'static str,\n+        style: Style,\n     }\n \n-    fn edge(from: usize, to: usize, label: &'static str) -> Edge {\n-        Edge { from: from, to: to, label: label }\n+    fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n+        Edge { from: from, to: to, label: label, style: style }\n     }\n \n     struct LabelledGraph {\n@@ -623,6 +695,8 @@ mod tests {\n         /// text.\n         node_labels: Vec<Option<&'static str>>,\n \n+        node_styles: Vec<Style>,\n+\n         /// Each edge relates a from-index to a to-index along with a\n         /// label; `edges` collects them.\n         edges: Vec<Edge>,\n@@ -654,16 +728,30 @@ mod tests {\n                     => lbls.into_iter().collect(),\n             }\n         }\n+\n+        fn len(&self) -> usize {\n+            match self {\n+                &UnlabelledNodes(len) => len,\n+                &AllNodesLabelled(ref lbls) => lbls.len(),\n+                &SomeNodesLabelled(ref lbls) => lbls.len(),\n+            }\n+        }\n     }\n \n     impl LabelledGraph {\n         fn new(name: &'static str,\n                node_labels: Trivial,\n-               edges: Vec<Edge>) -> LabelledGraph {\n+               edges: Vec<Edge>,\n+               node_styles: Option<Vec<Style>>) -> LabelledGraph {\n+            let count = node_labels.len();\n             LabelledGraph {\n                 name: name,\n                 node_labels: node_labels.to_opt_strs(),\n-                edges: edges\n+                edges: edges,\n+                node_styles: match node_styles {\n+                    Some(nodes) => nodes,\n+                    None => vec![Style::None; count],\n+                }\n             }\n         }\n     }\n@@ -673,7 +761,10 @@ mod tests {\n                node_labels: Trivial,\n                edges: Vec<Edge>) -> LabelledGraphWithEscStrs {\n             LabelledGraphWithEscStrs {\n-                graph: LabelledGraph::new(name, node_labels, edges)\n+                graph: LabelledGraph::new(name,\n+                                          node_labels,\n+                                          edges,\n+                                          None)\n             }\n         }\n     }\n@@ -698,6 +789,12 @@ mod tests {\n         fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n             LabelStr(e.label.into_cow())\n         }\n+        fn node_style(&'a self, n: &Node) -> Style {\n+            self.node_styles[*n]\n+        }\n+        fn edge_style(&'a self, e: & &'a Edge) -> Style {\n+            e.style\n+        }\n     }\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n@@ -760,7 +857,7 @@ mod tests {\n     #[test]\n     fn empty_graph() {\n         let labels : Trivial = UnlabelledNodes(0);\n-        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec!()));\n+        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph empty_graph {\n }\n@@ -770,19 +867,31 @@ r#\"digraph empty_graph {\n     #[test]\n     fn single_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec!()));\n+        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_node {\n     N0[label=\"N0\"];\n }\n \"#);\n     }\n \n+    #[test]\n+    fn single_node_with_style() {\n+        let labels : Trivial = UnlabelledNodes(1);\n+        let styles = Some(vec![Style::Dashed]);\n+        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n+        assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"][style=\"dashed\"];\n+}\n+\"#);\n+    }\n+\n     #[test]\n     fn single_edge() {\n         let labels : Trivial = UnlabelledNodes(2);\n         let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n-                                                   vec!(edge(0, 1, \"E\"))));\n+                                                   vec![edge(0, 1, \"E\", Style::None)], None));\n         assert_eq!(result.unwrap(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n@@ -792,15 +901,30 @@ r#\"digraph single_edge {\n \"#);\n     }\n \n+    #[test]\n+    fn single_edge_with_style() {\n+        let labels : Trivial = UnlabelledNodes(2);\n+        let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n+                                                   vec![edge(0, 1, \"E\", Style::Bold)], None));\n+        assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"][style=\"bold\"];\n+}\n+\"#);\n+    }\n+\n     #[test]\n     fn test_some_labelled() {\n         let labels : Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+        let styles = Some(vec![Style::None, Style::Dotted]);\n         let result = test_input(LabelledGraph::new(\"test_some_labelled\", labels,\n-                                                   vec![edge(0, 1, \"A-1\")]));\n+                                                   vec![edge(0, 1, \"A-1\", Style::None)], styles));\n         assert_eq!(result.unwrap(),\n r#\"digraph test_some_labelled {\n     N0[label=\"A\"];\n-    N1[label=\"N1\"];\n+    N1[label=\"N1\"][style=\"dotted\"];\n     N0 -> N1[label=\"A-1\"];\n }\n \"#);\n@@ -810,7 +934,7 @@ r#\"digraph test_some_labelled {\n     fn single_cyclic_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n-                                              vec!(edge(0, 0, \"E\"))));\n+                                              vec![edge(0, 0, \"E\", Style::None)], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_cyclic_node {\n     N0[label=\"N0\"];\n@@ -824,8 +948,9 @@ r#\"digraph single_cyclic_node {\n         let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n         let r = test_input(LabelledGraph::new(\n             \"hasse_diagram\", labels,\n-            vec!(edge(0, 1, \"\"), edge(0, 2, \"\"),\n-                 edge(1, 3, \"\"), edge(2, 3, \"\"))));\n+            vec![edge(0, 1, \"\", Style::None), edge(0, 2, \"\", Style::None),\n+                 edge(1, 3, \"\", Style::None), edge(2, 3, \"\", Style::None)],\n+            None));\n         assert_eq!(r.unwrap(),\n r#\"digraph hasse_diagram {\n     N0[label=\"{x,y}\"];\n@@ -858,8 +983,8 @@ r#\"digraph hasse_diagram {\n \n         let g = LabelledGraphWithEscStrs::new(\n             \"syntax_tree\", labels,\n-            vec!(edge(0, 1, \"then\"), edge(0, 2, \"else\"),\n-                 edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n+            vec![edge(0, 1, \"then\", Style::None), edge(0, 2, \"else\", Style::None),\n+                 edge(1, 3, \";\", Style::None),    edge(2, 3, \";\", Style::None)]);\n \n         render(&g, &mut writer).unwrap();\n         let mut r = String::new();"}]}