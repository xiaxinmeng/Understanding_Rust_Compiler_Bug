{"sha": "feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "node_id": "C_kwDOAAsO6NoAKGZlYjQyNDRmNTRjNGVjZjgyOGJhOGUwYWUzZDhjMjNkODBiNjQ2NDY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-14T23:28:14Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-14T04:43:56Z"}, "message": "Allow dyn* upcasting", "tree": {"sha": "7359d92923722416d1e91cf4984fb9d5ed5bf4c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7359d92923722416d1e91cf4984fb9d5ed5bf4c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "html_url": "https://github.com/rust-lang/rust/commit/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76386bd65e650b5289b142daa310a4b98230c3db", "url": "https://api.github.com/repos/rust-lang/rust/commits/76386bd65e650b5289b142daa310a4b98230c3db", "html_url": "https://github.com/rust-lang/rust/commit/76386bd65e650b5289b142daa310a4b98230c3db"}], "stats": {"total": 133, "additions": 97, "deletions": 36}, "files": [{"sha": "70e1fe62e472430f901d4051ccbacbf965028b47", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "patch": "@@ -38,7 +38,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, Size, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::convert::TryFrom;\n@@ -150,7 +150,12 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n-        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+        (\n+            &ty::Dynamic(ref data_a, _, src_dyn_kind),\n+            &ty::Dynamic(ref data_b, _, target_dyn_kind),\n+        ) => {\n+            assert_eq!(src_dyn_kind, target_dyn_kind);\n+\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -166,11 +171,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             if let Some(entry_idx) = vptr_entry_idx {\n                 let ptr_ty = cx.type_i8p();\n                 let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n-                let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                    cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                    1,\n-                    true,\n-                );\n+                let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n                 let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n                 let gep = bx.inbounds_gep(\n                     ptr_ty,\n@@ -186,18 +187,32 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                1,\n-                true,\n-            );\n+        (_, &ty::Dynamic(ref data, _, target_dyn_kind)) => {\n+            let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n             cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()), vtable_ptr_ty)\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n+// Returns the vtable pointer type of a `dyn` or `dyn*` type\n+fn vtable_ptr_ty<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    target: Ty<'tcx>,\n+    kind: ty::DynKind,\n+) -> <Cx as BackendTypes>::Type {\n+    cx.scalar_pair_element_backend_type(\n+        cx.layout_of(match kind {\n+            // vtable is the second field of `*mut dyn Trait`\n+            ty::Dyn => cx.tcx().mk_mut_ptr(target),\n+            // vtable is the second field of `dyn* Trait`\n+            ty::DynStar => target,\n+        }),\n+        1,\n+        true,\n+    )\n+}\n+\n /// Coerces `src` to `dst_ty`. `src_ty` must be a pointer.\n pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n@@ -247,6 +262,26 @@ pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n+/// Coerces `src` to `dst_ty` which is guaranteed to be a `dyn*` type.\n+pub fn cast_to_dyn_star<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    src: Bx::Value,\n+    src_ty_and_layout: TyAndLayout<'tcx>,\n+    dst_ty: Ty<'tcx>,\n+    old_info: Option<Bx::Value>,\n+) -> (Bx::Value, Bx::Value) {\n+    debug!(\"unsize_ptr: {:?} => {:?}\", src_ty_and_layout.ty, dst_ty);\n+    assert!(matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)));\n+    // FIXME(dyn-star): this is probably not the best way to check if this is\n+    // a pointer, and really we should ensure that the value is a suitable\n+    // pointer earlier in the compilation process.\n+    let src = match src_ty_and_layout.pointee_info_at(bx.cx(), Size::ZERO) {\n+        Some(_) => bx.ptrtoint(src, bx.cx().type_isize()),\n+        None => bx.bitcast(src, bx.type_isize()),\n+    };\n+    (src, unsized_info(bx, src_ty_and_layout.ty, dst_ty, old_info))\n+}\n+\n /// Coerces `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty`, and stores the result in `dst`.\n pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>("}, {"sha": "4aab31fbfe7da71ba31369cb0658b2aaf93cc323", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "patch": "@@ -4,7 +4,6 @@ use super::{FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n-use crate::meth::get_vtable;\n use crate::traits::*;\n use crate::MemFlags;\n \n@@ -14,7 +13,6 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::Size;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -274,27 +272,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::DynStar => {\n-                        let data = match operand.val {\n+                        let (lldata, llextra) = match operand.val {\n                             OperandValue::Ref(_, _, _) => todo!(),\n-                            OperandValue::Immediate(v) => v,\n-                            OperandValue::Pair(_, _) => todo!(),\n-                        };\n-                        let trait_ref =\n-                            if let ty::Dynamic(data, _, ty::DynStar) = cast.ty.kind() {\n-                                data.principal()\n-                            } else {\n-                                bug!(\"Only valid to do a DynStar cast into a DynStar type\")\n-                            };\n-                        let vtable = get_vtable(bx.cx(), source.ty(self.mir, bx.tcx()), trait_ref);\n-                        let vtable = bx.pointercast(vtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n-                        // FIXME(dyn-star): this is probably not the best way to check if this is\n-                        // a pointer, and really we should ensure that the value is a suitable\n-                        // pointer earlier in the compilation process.\n-                        let data = match operand.layout.pointee_info_at(bx.cx(), Size::ZERO) {\n-                            Some(_) => bx.ptrtoint(data, bx.cx().type_isize()),\n-                            None => data,\n+                            OperandValue::Immediate(v) => (v, None),\n+                            OperandValue::Pair(v, l) => (v, Some(l)),\n                         };\n-                        OperandValue::Pair(data, vtable)\n+                        let (lldata, llextra) =\n+                            base::cast_to_dyn_star(&mut bx, lldata, operand.layout, cast.ty, llextra);\n+                        OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(\n                         PointerCast::MutToConstPointer | PointerCast::ArrayToPointer,"}, {"sha": "a2bb249ba6e28c4ec20b16f92b4e34ac5401d1ee", "filename": "compiler/rustc_hir_analysis/src/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs?ref=feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "patch": "@@ -764,8 +764,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         {\n             if a_data.principal_def_id() == b_data.principal_def_id() {\n                 return self.unify_and(a, b, |_| vec![]);\n-            } else {\n-                bug!(\"dyn* trait upcasting is not supported\");\n+            } else if !self.tcx().features().trait_upcasting {\n+                let mut err = feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::trait_upcasting,\n+                    self.cause.span,\n+                    &format!(\n+                        \"cannot cast `{a}` to `{b}`, trait upcasting coercion is experimental\"\n+                    ),\n+                );\n+                err.emit();\n             }\n         }\n "}, {"sha": "cee76ada7df3bb445047eb343d00d4814b4808a7", "filename": "src/test/ui/dyn-star/upcast.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb4244f54c4ecf828ba8e0ae3d8c23d80b64646/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fupcast.rs?ref=feb4244f54c4ecf828ba8e0ae3d8c23d80b64646", "patch": "@@ -0,0 +1,33 @@\n+// run-pass\n+\n+#![feature(dyn_star, trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: Bar {\n+    fn hello(&self);\n+}\n+\n+trait Bar {\n+    fn world(&self);\n+}\n+\n+struct W(usize);\n+\n+impl Foo for W {\n+    fn hello(&self) {\n+        println!(\"hello!\");\n+    }\n+}\n+\n+impl Bar for W {\n+    fn world(&self) {\n+        println!(\"world!\");\n+    }\n+}\n+\n+fn main() {\n+    let w: dyn* Foo = W(0);\n+    w.hello();\n+    let w: dyn* Bar = w;\n+    w.world();\n+}"}]}