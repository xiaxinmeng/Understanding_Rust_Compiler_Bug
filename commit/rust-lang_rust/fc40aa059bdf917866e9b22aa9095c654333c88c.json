{"sha": "fc40aa059bdf917866e9b22aa9095c654333c88c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNDBhYTA1OWJkZjkxNzg2NmU5YjIyYWE5MDk1YzY1NDMzM2M4OGM=", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-05-06T03:04:19Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-05-06T03:04:19Z"}, "message": "Use the proper import library names", "tree": {"sha": "96c40268c73c180ab1d653dc8c09df1d9ef86d52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96c40268c73c180ab1d653dc8c09df1d9ef86d52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc40aa059bdf917866e9b22aa9095c654333c88c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmCTXLMACgkQcTRy8vRW\nJ97/JRAAk7vSow26I63ZA3lCB5g9D2FcgCWHO4kU2c4cQmye0mv2L3BN/TQdwGRN\nyade8+/ljpKPzlvfLtBfK7m2/2qUIJAMyT0oKSAX2DGO/DNESduoLScfyCo1EEqt\ngUsb+pfsX2DeCKDRSNm43cc8rajDJa74alYTcxOHAqTphMJdHrwyzFebYeWeil6x\n5c/ZlzVyi9z+/QvTdiLgcrbbB6mx8VbwJbSET6yf19WF43AggXtcCKRPCLFeqvh1\nPWb9jWdIeBoMyWKetG4I1K91QCOicIbbNdEO1XIWOSrGt0fV0ZYMJEEDbsCvVlKk\ndmikUTkiaxaIu65/7F79QN2qoAIQqpIsLtrkuC6db8ntc7mGK39qaNImtLSpty+S\nJZtpce+WOJqvjPCoGnzJhjIzJfjkP4ypxCBEzlqG8+eqkulB+PRFAEemwUjdtG7l\n9/qvDq4WN35ph/kI9uFlTUn9TeKuPl0b+jq18ER2e5A4zlu3aCsri3aKNKzjlxl2\n05yIanMawebPxiYcABjN5aNmJxgW1H/5GMnR78E+3EkKHXJoxETuLpHIvU3r/Q2+\n3JzouAlJAIdOnoj/8++eIuYZf4E5xn3W+D40wp+ZDX0gZTHPRdBoAvkG2jeC044f\n0MrxpTKqHlE+/5lRCWeUOC6VIvOlNN1hSxAVww/jbxT7Z028y/I=\n=XYdJ\n-----END PGP SIGNATURE-----", "payload": "tree 96c40268c73c180ab1d653dc8c09df1d9ef86d52\nparent 25712afd94404a6204845f9fbb38dcbf1ba4b882\nauthor Chris Denton <christophersdenton@gmail.com> 1620270259 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1620270259 +0100\n\nUse the proper import library names\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc40aa059bdf917866e9b22aa9095c654333c88c", "html_url": "https://github.com/rust-lang/rust/commit/fc40aa059bdf917866e9b22aa9095c654333c88c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc40aa059bdf917866e9b22aa9095c654333c88c/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25712afd94404a6204845f9fbb38dcbf1ba4b882", "url": "https://api.github.com/repos/rust-lang/rust/commits/25712afd94404a6204845f9fbb38dcbf1ba4b882", "html_url": "https://github.com/rust-lang/rust/commit/25712afd94404a6204845f9fbb38dcbf1ba4b882"}], "stats": {"total": 335, "additions": 167, "deletions": 168}, "files": [{"sha": "6244101bdb12dee26c26703f2c7705aaa7191d12", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 167, "deletions": 154, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/fc40aa059bdf917866e9b22aa9095c654333c88c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc40aa059bdf917866e9b22aa9095c654333c88c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=fc40aa059bdf917866e9b22aa9095c654333c88c", "patch": "@@ -628,7 +628,7 @@ pub struct timeval {\n     pub tv_usec: c_long,\n }\n \n-// Functions forbidden when targeting UWP\n+// Desktop specific functions & types\n cfg_if::cfg_if! {\n if #[cfg(not(target_vendor = \"uwp\"))] {\n     pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n@@ -642,7 +642,7 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n         pub ExceptionRecord: *mut EXCEPTION_RECORD,\n         pub ExceptionAddress: LPVOID,\n         pub NumberParameters: DWORD,\n-        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n     }\n \n     pub enum CONTEXT {}\n@@ -653,8 +653,8 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n         pub ContextRecord: *mut CONTEXT,\n     }\n \n-    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+    pub type PVECTORED_EXCEPTION_HANDLER =\n+        extern \"system\" fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n \n     #[repr(C)]\n     #[derive(Copy, Clone)]\n@@ -688,45 +688,66 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n \n     pub const TOKEN_READ: DWORD = 0x20008;\n \n-    #[link(name=\"kernel32\")]\n+    #[link(name = \"advapi32\")]\n     extern \"system\" {\n+        // Forbidden when targeting UWP\n         #[link_name = \"SystemFunction036\"]\n         pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n \n-        pub fn ReadConsoleW(hConsoleInput: HANDLE,\n-                            lpBuffer: LPVOID,\n-                            nNumberOfCharsToRead: DWORD,\n-                            lpNumberOfCharsRead: LPDWORD,\n-                            pInputControl: PCONSOLE_READCONSOLE_CONTROL) -> BOOL;\n+        // Allowed but unused by UWP\n+        pub fn OpenProcessToken(\n+            ProcessHandle: HANDLE,\n+            DesiredAccess: DWORD,\n+            TokenHandle: *mut HANDLE,\n+        ) -> BOOL;\n+    }\n \n-        pub fn WriteConsoleW(hConsoleOutput: HANDLE,\n-                             lpBuffer: LPCVOID,\n-                             nNumberOfCharsToWrite: DWORD,\n-                             lpNumberOfCharsWritten: LPDWORD,\n-                             lpReserved: LPVOID) -> BOOL;\n+    #[link(name = \"userenv\")]\n+    extern \"system\" {\n+        // Allowed but unused by UWP\n+        pub fn GetUserProfileDirectoryW(\n+            hToken: HANDLE,\n+            lpProfileDir: LPWSTR,\n+            lpcchSize: *mut DWORD,\n+        ) -> BOOL;\n+    }\n \n-        pub fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                              lpMode: LPDWORD) -> BOOL;\n+    #[link(name = \"kernel32\")]\n+    extern \"system\" {\n+        // Functions forbidden when targeting UWP\n+        pub fn ReadConsoleW(\n+            hConsoleInput: HANDLE,\n+            lpBuffer: LPVOID,\n+            nNumberOfCharsToRead: DWORD,\n+            lpNumberOfCharsRead: LPDWORD,\n+            pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n+        ) -> BOOL;\n+\n+        pub fn WriteConsoleW(\n+            hConsoleOutput: HANDLE,\n+            lpBuffer: LPCVOID,\n+            nNumberOfCharsToWrite: DWORD,\n+            lpNumberOfCharsWritten: LPDWORD,\n+            lpReserved: LPVOID,\n+        ) -> BOOL;\n+\n+        pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n         // Allowed but unused by UWP\n-        pub fn OpenProcessToken(ProcessHandle: HANDLE,\n-                                DesiredAccess: DWORD,\n-                                TokenHandle: *mut HANDLE) -> BOOL;\n-        pub fn GetUserProfileDirectoryW(hToken: HANDLE,\n-                                        lpProfileDir: LPWSTR,\n-                                        lpcchSize: *mut DWORD) -> BOOL;\n-        pub fn GetFileInformationByHandle(hFile: HANDLE,\n-                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n-                            -> BOOL;\n-        pub fn SetHandleInformation(hObject: HANDLE,\n-                                    dwMask: DWORD,\n-                                    dwFlags: DWORD) -> BOOL;\n-        pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                           VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                           -> LPVOID;\n-        pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n-                               lpTargetFileName: LPCWSTR,\n-                               lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n-                               -> BOOL;\n+        pub fn GetFileInformationByHandle(\n+            hFile: HANDLE,\n+            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,\n+        ) -> BOOL;\n+        pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;\n+        pub fn AddVectoredExceptionHandler(\n+            FirstHandler: ULONG,\n+            VectoredHandler: PVECTORED_EXCEPTION_HANDLER,\n+        ) -> LPVOID;\n+        pub fn CreateHardLinkW(\n+            lpSymlinkFileName: LPCWSTR,\n+            lpTargetFileName: LPCWSTR,\n+            lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+        ) -> BOOL;\n+        pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n     }\n }\n }\n@@ -745,57 +766,32 @@ if #[cfg(target_vendor = \"uwp\")] {\n         pub Directory: BOOLEAN,\n     }\n \n-    #[link(name=\"kernel32\")]\n+    #[link(name = \"bcrypt\")]\n     extern \"system\" {\n-        pub fn GetFileInformationByHandleEx(hFile: HANDLE,\n-                                            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-                                            lpFileInformation: LPVOID,\n-                                            dwBufferSize: DWORD) -> BOOL;\n-        pub fn BCryptGenRandom(hAlgorithm: LPVOID, pBuffer: *mut u8,\n-                               cbBuffer: ULONG, dwFlags: ULONG) -> LONG;\n+        pub fn BCryptGenRandom(\n+            hAlgorithm: LPVOID,\n+            pBuffer: *mut u8,\n+            cbBuffer: ULONG,\n+            dwFlags: ULONG,\n+        ) -> LONG;\n+    }\n+    #[link(name = \"kernel32\")]\n+    extern \"system\" {\n+        pub fn GetFileInformationByHandleEx(\n+            hFile: HANDLE,\n+            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+            lpFileInformation: LPVOID,\n+            dwBufferSize: DWORD,\n+        ) -> BOOL;\n     }\n }\n }\n \n // Shared between Desktop & UWP\n+\n #[link(name = \"kernel32\")]\n extern \"system\" {\n-    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n-    pub fn WSACleanup() -> c_int;\n-    pub fn WSAGetLastError() -> c_int;\n-    pub fn WSADuplicateSocketW(\n-        s: SOCKET,\n-        dwProcessId: DWORD,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-    ) -> c_int;\n-    pub fn WSASend(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesSent: LPDWORD,\n-        dwFlags: DWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n-    pub fn WSARecv(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesRecvd: LPDWORD,\n-        lpFlags: LPDWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n     pub fn GetCurrentProcessId() -> DWORD;\n-    pub fn WSASocketW(\n-        af: c_int,\n-        kind: c_int,\n-        protocol: c_int,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-        g: GROUP,\n-        dwFlags: DWORD,\n-    ) -> SOCKET;\n-    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOL;\n@@ -882,28 +878,6 @@ extern \"system\" {\n     pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n     pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-\n-    pub fn closesocket(socket: SOCKET) -> c_int;\n-    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn recvfrom(\n-        socket: SOCKET,\n-        buf: *mut c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *mut SOCKADDR,\n-        addrlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn sendto(\n-        socket: SOCKET,\n-        buf: *const c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *const SOCKADDR,\n-        addrlen: c_int,\n-    ) -> c_int;\n-    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n-    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n     pub fn DuplicateHandle(\n         hSourceProcessHandle: HANDLE,\n         hSourceHandle: HANDLE,\n@@ -950,32 +924,6 @@ extern \"system\" {\n     pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;\n     pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;\n     pub fn FindClose(findFile: HANDLE) -> BOOL;\n-    pub fn getsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *mut c_char,\n-        optlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn setsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *const c_void,\n-        optlen: c_int,\n-    ) -> c_int;\n-    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n-    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n-    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n-    pub fn getaddrinfo(\n-        node: *const c_char,\n-        service: *const c_char,\n-        hints: *const ADDRINFOA,\n-        res: *mut *mut ADDRINFOA,\n-    ) -> c_int;\n-    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n \n     pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n     pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n@@ -1012,61 +960,33 @@ extern \"system\" {\n         lpNumberOfBytesTransferred: LPDWORD,\n         bWait: BOOL,\n     ) -> BOOL;\n-    pub fn select(\n-        nfds: c_int,\n-        readfds: *mut fd_set,\n-        writefds: *mut fd_set,\n-        exceptfds: *mut fd_set,\n-        timeout: *const timeval,\n-    ) -> c_int;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinkw\n     pub fn CreateSymbolicLinkW(\n         lpSymlinkFileName: LPCWSTR,\n         lpTargetFileName: LPCWSTR,\n         dwFlags: DWORD,\n     ) -> BOOLEAN;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlew\n     pub fn GetFinalPathNameByHandleW(\n         hFile: HANDLE,\n         lpszFilePath: LPCWSTR,\n         cchFilePath: DWORD,\n         dwFlags: DWORD,\n     ) -> DWORD;\n-\n-    // >= Vista / Server 2003\n-    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle\n     pub fn SetFileInformationByHandle(\n         hFile: HANDLE,\n         FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n         lpFileInformation: LPVOID,\n         dwBufferSize: DWORD,\n     ) -> BOOL;\n-\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablesrw\n     pub fn SleepConditionVariableSRW(\n         ConditionVariable: PCONDITION_VARIABLE,\n         SRWLock: PSRWLOCK,\n         dwMilliseconds: DWORD,\n         Flags: ULONG,\n     ) -> BOOL;\n \n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable\n     pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n     pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n \n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-acquiresrwlockexclusive\n     pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n     pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n     pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n@@ -1075,6 +995,99 @@ extern \"system\" {\n     pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n }\n \n+#[link(name = \"ws2_32\")]\n+extern \"system\" {\n+    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n+    pub fn WSACleanup() -> c_int;\n+    pub fn WSAGetLastError() -> c_int;\n+    pub fn WSADuplicateSocketW(\n+        s: SOCKET,\n+        dwProcessId: DWORD,\n+        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n+    ) -> c_int;\n+    pub fn WSASend(\n+        s: SOCKET,\n+        lpBuffers: LPWSABUF,\n+        dwBufferCount: DWORD,\n+        lpNumberOfBytesSent: LPDWORD,\n+        dwFlags: DWORD,\n+        lpOverlapped: LPWSAOVERLAPPED,\n+        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> c_int;\n+    pub fn WSARecv(\n+        s: SOCKET,\n+        lpBuffers: LPWSABUF,\n+        dwBufferCount: DWORD,\n+        lpNumberOfBytesRecvd: LPDWORD,\n+        lpFlags: LPDWORD,\n+        lpOverlapped: LPWSAOVERLAPPED,\n+        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> c_int;\n+    pub fn WSASocketW(\n+        af: c_int,\n+        kind: c_int,\n+        protocol: c_int,\n+        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n+        g: GROUP,\n+        dwFlags: DWORD,\n+    ) -> SOCKET;\n+    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n+    pub fn closesocket(socket: SOCKET) -> c_int;\n+    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n+    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n+    pub fn recvfrom(\n+        socket: SOCKET,\n+        buf: *mut c_void,\n+        len: c_int,\n+        flags: c_int,\n+        addr: *mut SOCKADDR,\n+        addrlen: *mut c_int,\n+    ) -> c_int;\n+    pub fn sendto(\n+        socket: SOCKET,\n+        buf: *const c_void,\n+        len: c_int,\n+        flags: c_int,\n+        addr: *const SOCKADDR,\n+        addrlen: c_int,\n+    ) -> c_int;\n+    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n+    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n+    pub fn getsockopt(\n+        s: SOCKET,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *mut c_char,\n+        optlen: *mut c_int,\n+    ) -> c_int;\n+    pub fn setsockopt(\n+        s: SOCKET,\n+        level: c_int,\n+        optname: c_int,\n+        optval: *const c_void,\n+        optlen: c_int,\n+    ) -> c_int;\n+    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n+    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n+    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n+    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n+    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n+    pub fn getaddrinfo(\n+        node: *const c_char,\n+        service: *const c_char,\n+        hints: *const ADDRINFOA,\n+        res: *mut *mut ADDRINFOA,\n+    ) -> c_int;\n+    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n+    pub fn select(\n+        nfds: c_int,\n+        readfds: *mut fd_set,\n+        writefds: *mut fd_set,\n+        exceptfds: *mut fd_set,\n+        timeout: *const timeval,\n+    ) -> c_int;\n+}\n+\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {"}, {"sha": "f23e874f249054df88c85c792f9ec37704ef9612", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc40aa059bdf917866e9b22aa9095c654333c88c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc40aa059bdf917866e9b22aa9095c654333c88c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=fc40aa059bdf917866e9b22aa9095c654333c88c", "patch": "@@ -281,17 +281,3 @@ pub fn abort_internal() -> ! {\n     }\n     crate::intrinsics::abort();\n }\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(target_vendor = \"uwp\")] {\n-        #[link(name = \"ws2_32\")]\n-        // For BCryptGenRandom\n-        #[link(name = \"bcrypt\")]\n-        extern \"C\" {}\n-    } else {\n-        #[link(name = \"advapi32\")]\n-        #[link(name = \"ws2_32\")]\n-        #[link(name = \"userenv\")]\n-        extern \"C\" {}\n-    }\n-}"}]}