{"sha": "24e7491660845e52240afc36acf332b92547b0a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZTc0OTE2NjA4NDVlNTIyNDBhZmMzNmFjZjMzMmI5MjU0N2IwYTE=", "commit": {"author": {"name": "Ted Mielczarek", "email": "ted@mielczarek.org", "date": "2016-06-09T20:36:20Z"}, "committer": {"name": "Ted Mielczarek", "email": "ted@mielczarek.org", "date": "2016-06-16T17:08:46Z"}, "message": "Add an abs_path member to FileMap, use it when writing debug info.\n\nWhen items are inlined from extern crates, the filename in the debug info\nis taken from the FileMap that's serialized in the rlib metadata.\nCurrently this is just FileMap.name, which is whatever path is passed to rustc.\nSince libcore and libstd are built by invoking rustc with relative paths,\nthey wind up with relative paths in the rlib, and when linked into a binary\nthe debug info uses relative paths for the names, but since the compilation\ndirectory for the final binary, tools trying to read source filenames\nwill wind up with bad paths. We noticed this in Firefox with source\nfilenames from libcore/libstd having bad paths.\n\nThis change stores an absolute path in FileMap.abs_path, and uses that\nif available for writing debug info. This is not going to magically make\ndebuggers able to find the source, but it will at least provide sensible\npaths.", "tree": {"sha": "106c01facc7fbff9a373112707b34eb383a93b89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/106c01facc7fbff9a373112707b34eb383a93b89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24e7491660845e52240afc36acf332b92547b0a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24e7491660845e52240afc36acf332b92547b0a1", "html_url": "https://github.com/rust-lang/rust/commit/24e7491660845e52240afc36acf332b92547b0a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24e7491660845e52240afc36acf332b92547b0a1/comments", "author": {"login": "luser", "id": 286001, "node_id": "MDQ6VXNlcjI4NjAwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/286001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luser", "html_url": "https://github.com/luser", "followers_url": "https://api.github.com/users/luser/followers", "following_url": "https://api.github.com/users/luser/following{/other_user}", "gists_url": "https://api.github.com/users/luser/gists{/gist_id}", "starred_url": "https://api.github.com/users/luser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luser/subscriptions", "organizations_url": "https://api.github.com/users/luser/orgs", "repos_url": "https://api.github.com/users/luser/repos", "events_url": "https://api.github.com/users/luser/events{/privacy}", "received_events_url": "https://api.github.com/users/luser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luser", "id": 286001, "node_id": "MDQ6VXNlcjI4NjAwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/286001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luser", "html_url": "https://github.com/luser", "followers_url": "https://api.github.com/users/luser/followers", "following_url": "https://api.github.com/users/luser/following{/other_user}", "gists_url": "https://api.github.com/users/luser/gists{/gist_id}", "starred_url": "https://api.github.com/users/luser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luser/subscriptions", "organizations_url": "https://api.github.com/users/luser/orgs", "repos_url": "https://api.github.com/users/luser/repos", "events_url": "https://api.github.com/users/luser/events{/privacy}", "received_events_url": "https://api.github.com/users/luser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b", "html_url": "https://github.com/rust-lang/rust/commit/a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b"}], "stats": {"total": 160, "additions": 100, "deletions": 60}, "files": [{"sha": "6c24384cddc57055353960bfb515601bf1291d32", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -1078,6 +1078,7 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n                 // containing the information we need.\n                 let codemap::FileMap {\n                     name,\n+                    abs_path,\n                     start_pos,\n                     end_pos,\n                     lines,\n@@ -1102,6 +1103,7 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n                 }\n \n                 let local_version = local_codemap.new_imported_filemap(name,\n+                                                                       abs_path,\n                                                                        source_length,\n                                                                        lines,\n                                                                        multibyte_chars);"}, {"sha": "4b3975faa80764e94d95d971f42782b13a688fe7", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -81,7 +81,7 @@ impl<'a> SpanUtils<'a> {\n         // are incompatible with spans over other filemaps.\n         let filemap = self.sess\n                           .codemap()\n-                          .new_filemap(String::from(\"<anon-dxr>\"), self.snippet(span));\n+                          .new_filemap(String::from(\"<anon-dxr>\"), None, self.snippet(span));\n         let s = self.sess;\n         lexer::StringReader::new(s.diagnostic(), filemap)\n     }"}, {"sha": "b29ca515f8fc3cc367612cd6094b96b3cf0144e1", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -131,8 +131,8 @@ fn make_mir_scope(ccx: &CrateContext,\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n-    let file_metadata = file_metadata(ccx, &loc.file.name);\n     scopes[scope] = unsafe {\n+    let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n             parent_scope,\n@@ -152,7 +152,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n {\n     // Create a new lexical scope and push it onto the stack\n     let loc = span_start(cx, scope_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n     let scope_metadata = unsafe {\n@@ -268,7 +268,7 @@ fn walk_pattern(cx: &CrateContext,\n             if need_new_scope {\n                 // Create a new lexical scope and push it onto the stack\n                 let loc = span_start(cx, pat.span);\n-                let file_metadata = file_metadata(cx, &loc.file.name);\n+                let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n                 let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                 let scope_metadata = unsafe {"}, {"sha": "c6c28fc9ba6a5f96d6bb0c09dfbe3352c8f473b5", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -563,7 +563,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n@@ -853,17 +853,19 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n+pub fn file_metadata(cx: &CrateContext, path: &str, full_path: &Option<String>) -> DIFile {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let work_dir = cx.sess().working_dir.to_str().unwrap();\n     let file_name =\n-        if full_path.starts_with(work_dir) {\n-            &full_path[work_dir.len() + 1..full_path.len()]\n-        } else {\n-            full_path\n-        };\n+        full_path.as_ref().map(|p| p.as_str()).unwrap_or_else(|| {\n+            if path.starts_with(work_dir) {\n+                &path[work_dir.len() + 1..path.len()]\n+            } else {\n+                path\n+            }\n+        });\n \n-    file_metadata_(cx, full_path, file_name, &work_dir)\n+    file_metadata_(cx, path, file_name, &work_dir)\n }\n \n pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n@@ -1849,7 +1851,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n     } else {\n         (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };"}, {"sha": "92b151c7c4076d46dac5fd88a9af82ee67dbaee1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -247,7 +247,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, sig, abi);\n@@ -476,8 +476,9 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n-    let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[..]);\n+    let file = span_start(cx, span).file;\n+    let filename = file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..], &file.abs_path);\n \n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);"}, {"sha": "a37fbdccc8f0a2111380bc0ae2b394e3d83ab49b", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -72,7 +72,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     let span = ccx.tcx().map.def_id_span(def_id, DUMMY_SP);\n     let (file, line) = if span != DUMMY_SP {\n         let loc = span_start(ccx, span);\n-        (file_metadata(ccx, &loc.file.name), loc.line as c_uint)\n+        (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n     } else {\n         (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };"}, {"sha": "321bc51f9038676250262bba057fa79f1404092c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -35,7 +35,7 @@ use syntax::parse;\n pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n \n     let mut out = Vec::new();\n     write_header(class, id, &mut out).unwrap();\n@@ -55,7 +55,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// an enclosing `<pre>` block.\n pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n     let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n \n     let mut out = Vec::new();\n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess.span_diagnostic, fm),"}, {"sha": "5e1335b45aa0c6b979dbd41b3943b7c4bae7a14b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -21,10 +21,11 @@ pub use self::ExpnFormat::*;\n \n use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n-use std::path::Path;\n+use std::path::{Path,PathBuf};\n use std::rc::Rc;\n use std::cmp;\n \n+use std::env;\n use std::{fmt, fs};\n use std::io::{self, Read};\n \n@@ -508,6 +509,8 @@ pub struct FileMap {\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n+    /// The absolute path of the file that the source came from.\n+    pub abs_path: Option<FileName>,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n@@ -522,11 +525,12 @@ pub struct FileMap {\n \n impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"FileMap\", 5, |s| {\n+        s.emit_struct(\"FileMap\", 6, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 1, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 2, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 3, |s| {\n+            s.emit_struct_field(\"abs_path\", 1, |s| self.abs_path.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 4, |s| {\n                 let lines = self.lines.borrow();\n                 // store the length\n                 s.emit_u32(lines.len() as u32)?;\n@@ -572,7 +576,7 @@ impl Encodable for FileMap {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 4, |s| {\n+            s.emit_struct_field(\"multibyte_chars\", 5, |s| {\n                 (*self.multibyte_chars.borrow()).encode(s)\n             })\n         })\n@@ -582,11 +586,13 @@ impl Encodable for FileMap {\n impl Decodable for FileMap {\n     fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n \n-        d.read_struct(\"FileMap\", 5, |d| {\n+        d.read_struct(\"FileMap\", 6, |d| {\n             let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n-            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 1, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 2, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 3, |d| {\n+            let abs_path: Option<String> =\n+                d.read_struct_field(\"abs_path\", 1, |d| Decodable::decode(d))?;\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -615,9 +621,10 @@ impl Decodable for FileMap {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 4, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name: name,\n+                abs_path: abs_path,\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,\n@@ -703,6 +710,9 @@ pub trait FileLoader {\n     /// Query the existence of a file.\n     fn file_exists(&self, path: &Path) -> bool;\n \n+    /// Return an absolute path to a file, if possible.\n+    fn abs_path(&self, path: &Path) -> Option<PathBuf>;\n+\n     /// Read the contents of an UTF-8 file into memory.\n     fn read_file(&self, path: &Path) -> io::Result<String>;\n }\n@@ -715,6 +725,16 @@ impl FileLoader for RealFileLoader {\n         fs::metadata(path).is_ok()\n     }\n \n+    fn abs_path(&self, path: &Path) -> Option<PathBuf> {\n+        if path.is_absolute() {\n+            Some(path.to_path_buf())\n+        } else {\n+            env::current_dir()\n+                .ok()\n+                .map(|cwd| cwd.join(path))\n+        }\n+    }\n+\n     fn read_file(&self, path: &Path) -> io::Result<String> {\n         let mut src = String::new();\n         fs::File::open(path)?.read_to_string(&mut src)?;\n@@ -755,7 +775,8 @@ impl CodeMap {\n \n     pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n         let src = self.file_loader.read_file(path)?;\n-        Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n+        let abs_path = self.file_loader.abs_path(path).map(|p| p.to_str().unwrap().to_string());\n+        Ok(self.new_filemap(path.to_str().unwrap().to_string(), abs_path, src))\n     }\n \n     fn next_start_pos(&self) -> usize {\n@@ -770,7 +791,8 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n-    pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, abs_path: Option<FileName>,\n+                       mut src: String) -> Rc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n@@ -783,6 +805,7 @@ impl CodeMap {\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n+            abs_path: abs_path,\n             src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n             end_pos: Pos::from_usize(end_pos),\n@@ -796,8 +819,11 @@ impl CodeMap {\n     }\n \n     /// Creates a new filemap and sets its line information.\n-    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n-        let fm = self.new_filemap(filename.to_string(), src.to_owned());\n+    pub fn new_filemap_and_lines(&self, filename: &str, abs_path: Option<&str>,\n+                                 src: &str) -> Rc<FileMap> {\n+        let fm = self.new_filemap(filename.to_string(),\n+                                  abs_path.map(|s| s.to_owned()),\n+                                  src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n@@ -816,6 +842,7 @@ impl CodeMap {\n     /// information for things inlined from other crates.\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n+                                abs_path: Option<FileName>,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -836,6 +863,7 @@ impl CodeMap {\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n+            abs_path: abs_path,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n@@ -1422,6 +1450,7 @@ mod tests {\n     fn t1 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n         // Test we can get lines with partial line info.\n@@ -1438,6 +1467,7 @@ mod tests {\n     fn t2 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n@@ -1448,10 +1478,13 @@ mod tests {\n     fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new();\n         let fm1 = cm.new_filemap(\"blork.rs\".to_string(),\n+                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"empty.rs\".to_string(),\n+                                 None,\n                                  \"\".to_string());\n         let fm3 = cm.new_filemap(\"blork2.rs\".to_string(),\n+                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -1514,8 +1547,10 @@ mod tests {\n         // \u20ac is a three byte utf8 char.\n         let fm1 =\n             cm.new_filemap(\"blork.rs\".to_string(),\n+                           None,\n                            \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"blork2.rs\".to_string(),\n+                                 None,\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -1583,7 +1618,7 @@ mod tests {\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting"}, {"sha": "71a03e846a2b5fe6eb7b4dc053c477565a786645", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -668,7 +668,7 @@ mod test {\n         tolv\n         dreizehn\n         \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n         let start = file.lines.borrow()[10];\n         let end = file.lines.borrow()[11];\n         let sp = mk_sp(start, end);\n@@ -694,7 +694,7 @@ mod test {\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n         let sp = span_from_selection(inputtext, selection);\n         let msp: MultiSpan = sp.into();\n \n@@ -717,7 +717,7 @@ mod test {\n         let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n         let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n         let sp1 = span_from_selection(inputtext, selection1);\n         let sp2 = span_from_selection(inputtext, selection2);\n         let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n@@ -757,7 +757,7 @@ mod test {\n             assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n             sp\n         };\n-        cm.new_filemap_and_lines(\"dummy.txt\", inp);\n+        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n         let sp1 = span(sp1, \"aaaaaa\");\n         let sp2 = span(sp2, \"bbbbbb\");\n         let sp3 = span(sp3, \"ccccc\");\n@@ -802,7 +802,7 @@ mod test {\n                    ddd__eee_\\n\\\n                    elided\\n\\\n                    __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", inp);\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n \n         let span = |lo, hi, (off_lo, off_hi)| {\n             let lines = file.lines.borrow();"}, {"sha": "79e40a091659e106381ec3eacfcd84bdc38a4152", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -88,7 +88,7 @@ fn foo() {\n \";\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n \n     let mut snippet = SnippetData::new(cm, Some(span_bar));\n@@ -113,7 +113,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n     let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n     let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n@@ -173,12 +173,12 @@ fn bar() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", file_text_foo);\n+    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n     let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n     let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n     let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n \n-    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", file_text_bar);\n+    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n     let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n     let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n     let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n@@ -235,7 +235,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n     let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n     let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n@@ -274,7 +274,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n     let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n     let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n@@ -312,7 +312,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n     let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n     let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n@@ -354,7 +354,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n     let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n     let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n \n@@ -393,7 +393,7 @@ fn foo() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut snippet = SnippetData::new(cm.clone(), None);\n     for i in 0..4 {\n@@ -427,7 +427,7 @@ impl SomeTrait for () {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut snippet = SnippetData::new(cm.clone(), None);\n     let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n@@ -456,7 +456,7 @@ fn span_overlap_label() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut snippet = SnippetData::new(cm.clone(), None);\n     let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n@@ -491,7 +491,7 @@ fn span_overlap_label2() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut snippet = SnippetData::new(cm.clone(), None);\n     let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n@@ -529,7 +529,7 @@ fn span_overlap_label3() {\n \"#;\n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut snippet = SnippetData::new(cm.clone(), None);\n \n@@ -578,7 +578,7 @@ fn main() {\n \n \n     let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n \n     let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n     rbrace_span.lo = rbrace_span.hi;"}, {"sha": "fd229d77966b70d178351943d1aee97c47756b2b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -154,7 +154,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n             let interned = token::intern_and_get_ident(&src[..]);\n-            cx.codemap().new_filemap_and_lines(&filename, &src);\n+            cx.codemap().new_filemap_and_lines(&filename, None, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned))\n         }\n@@ -185,7 +185,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, \"\");\n+            cx.codemap().new_filemap_and_lines(&filename, None, \"\");\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n         }"}, {"sha": "06d255d5c0f920f494c779dd7ef9b3419e3d7e6b", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -346,7 +346,7 @@ pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n     srdr.read_to_end(&mut src).unwrap();\n     let src = String::from_utf8(src).unwrap();\n     let cm = CodeMap::new();\n-    let filemap = cm.new_filemap(path, src);\n+    let filemap = cm.new_filemap(path, None, src);\n     let mut rdr = lexer::StringReader::new_raw(span_diagnostic, filemap);\n \n     let mut comments: Vec<Comment> = Vec::new();"}, {"sha": "d78a81dec83db19296986ba8cbe7f3d94f114af9", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -1695,7 +1695,7 @@ mod tests {\n                  span_handler: &'a errors::Handler,\n                  teststr: String)\n                  -> StringReader<'a> {\n-        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), None, teststr);\n         StringReader::new(span_handler, fm)\n     }\n "}, {"sha": "2e4d46bc9831875535a6cfff64277fe21532bb1e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -178,7 +178,7 @@ pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n                                       name: String,\n                                       source: String)\n                                       -> Parser<'a> {\n-    filemap_to_parser(sess, sess.codemap().new_filemap(name, source), cfg)\n+    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source), cfg)\n }\n \n /// Create a new parser, handling errors as appropriate"}, {"sha": "06264196d9e7a84f104d8ce7a1550e6801d25365", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e7491660845e52240afc36acf332b92547b0a1/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=24e7491660845e52240afc36acf332b92547b0a1", "patch": "@@ -19,7 +19,7 @@ use std::iter::Peekable;\n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n     let ps = ParseSess::new();\n-    filemap_to_tts(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), source_str))\n+    filemap_to_tts(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), None, source_str))\n }\n \n /// Map string to parser (via tts)"}]}