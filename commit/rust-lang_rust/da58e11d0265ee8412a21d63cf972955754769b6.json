{"sha": "da58e11d0265ee8412a21d63cf972955754769b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNThlMTFkMDI2NWVlODQxMmEyMWQ2M2NmOTcyOTU1NzU0NzY5YjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-22T22:36:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-22T22:36:34Z"}, "message": "Rollup merge of #64670 - Mark-Simulacrum:ext-build-simplify, r=petrochenkov\n\nCleanup syntax::ext::build\n\nI suspect most of this code could be inlined but I only removed the bits where the inlining didn't really hurt readability (i.e., method call -> function call) or the completely unused code.", "tree": {"sha": "eac074cdba60fb22e32e3053b109c7b3b7257b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eac074cdba60fb22e32e3053b109c7b3b7257b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da58e11d0265ee8412a21d63cf972955754769b6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdh/dzCRBK7hj4Ov3rIwAAdHIIAJPWvX2mXgLcklhTvCC4Iwq3\nP/MXchXZuM9DlwDMjwS+hTfFaB86PCoDUoK6YrYCtPIQNPDJuLK/wWX6TyXxsNwN\nm1c+d63MUvpXHS1yUUNkTgmfnOj0afVIqdY3MKotUt8USwez1MIJlz6AieXxiEUO\nAauTexT/8vEcbgvkjzUI0ZFX3KrEY7ObHLXAw6q0Z6o5p0gQgL38w+0hQnYFe0mS\n4Ul9O8D/ar8pwDGTnpfVV68v7HK+5ibK+OKCT7p0vqMHYk6E/Ec297fFAcO+TJr4\njEtWnOz6pk/e0HZThk332Z+6nIp/G/EAPLkdHQcWpDsXKcyNP1v3BYoxq2l0dow=\n=2HnS\n-----END PGP SIGNATURE-----\n", "payload": "tree eac074cdba60fb22e32e3053b109c7b3b7257b2a\nparent 7894bc82d790c9ef700d0576f2c1e5756a07532d\nparent 8417ac67c3fe979098facad586438ea5244617b3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569191794 +0200\ncommitter GitHub <noreply@github.com> 1569191794 +0200\n\nRollup merge of #64670 - Mark-Simulacrum:ext-build-simplify, r=petrochenkov\n\nCleanup syntax::ext::build\n\nI suspect most of this code could be inlined but I only removed the bits where the inlining didn't really hurt readability (i.e., method call -> function call) or the completely unused code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da58e11d0265ee8412a21d63cf972955754769b6", "html_url": "https://github.com/rust-lang/rust/commit/da58e11d0265ee8412a21d63cf972955754769b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da58e11d0265ee8412a21d63cf972955754769b6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7894bc82d790c9ef700d0576f2c1e5756a07532d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7894bc82d790c9ef700d0576f2c1e5756a07532d", "html_url": "https://github.com/rust-lang/rust/commit/7894bc82d790c9ef700d0576f2c1e5756a07532d"}, {"sha": "8417ac67c3fe979098facad586438ea5244617b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8417ac67c3fe979098facad586438ea5244617b3", "html_url": "https://github.com/rust-lang/rust/commit/8417ac67c3fe979098facad586438ea5244617b3"}], "stats": {"total": 358, "additions": 27, "deletions": 331}, "files": [{"sha": "f903b66e2961d4e2487bd58ae634b195b283b739", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 316, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -1,30 +1,28 @@\n-use crate::ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n+use crate::ast::{self, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n use crate::attr;\n-use crate::source_map::{dummy_spanned, respan, Spanned};\n+use crate::source_map::{respan, Spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Symbol};\n use crate::ThinVec;\n \n-use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, vec![], vec![])\n+        self.path_all(span, false, strs, vec![])\n     }\n     pub fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec![id])\n     }\n     pub fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, vec![], vec![])\n+        self.path_all(span, true, strs, vec![])\n     }\n     pub fn path_all(&self,\n                 span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n-                args: Vec<ast::GenericArg>,\n-                constraints: Vec<ast::AssocTyConstraint> )\n+                args: Vec<ast::GenericArg>)\n                 -> ast::Path {\n         assert!(!idents.is_empty());\n         let add_root = global && !idents[0].is_path_segment_keyword();\n@@ -36,8 +34,8 @@ impl<'a> ExtCtxt<'a> {\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let args = if !args.is_empty() || !constraints.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints, span }.into()\n+        let args = if !args.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints: Vec::new(), span }.into()\n         } else {\n             None\n         };\n@@ -49,42 +47,6 @@ impl<'a> ExtCtxt<'a> {\n         ast::Path { span, segments }\n     }\n \n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident`.\n-    pub fn qpath(&self,\n-             self_type: P<ast::Ty>,\n-             trait_path: ast::Path,\n-             ident: ast::Ident)\n-             -> (ast::QSelf, ast::Path) {\n-        self.qpath_all(self_type, trait_path, ident, vec![], vec![])\n-    }\n-\n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A = Bar>`.\n-    pub fn qpath_all(&self,\n-                 self_type: P<ast::Ty>,\n-                 trait_path: ast::Path,\n-                 ident: ast::Ident,\n-                 args: Vec<ast::GenericArg>,\n-                 constraints: Vec<ast::AssocTyConstraint>)\n-                 -> (ast::QSelf, ast::Path) {\n-        let mut path = trait_path;\n-        let args = if !args.is_empty() || !constraints.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints, span: ident.span }.into()\n-        } else {\n-            None\n-        };\n-        path.segments.push(ast::PathSegment { ident, id: ast::DUMMY_NODE_ID, args });\n-\n-        (ast::QSelf {\n-            ty: self_type,\n-            path_span: path.span,\n-            position: path.segments.len() - 1\n-        }, path)\n-    }\n-\n     pub fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy {\n             ty,\n@@ -146,10 +108,6 @@ impl<'a> ExtCtxt<'a> {\n                 ast::TyKind::Ptr(self.ty_mt(ty, mutbl)))\n     }\n \n-    pub fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n-        self.ty(span, ast::TyKind::Infer)\n-    }\n-\n     pub fn typaram(&self,\n                span: Span,\n                ident: ast::Ident,\n@@ -217,14 +175,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            span: expr.span,\n-            node: ast::StmtKind::Semi(expr),\n-        }\n-    }\n-\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n@@ -248,34 +198,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_let_typed(&self,\n-                      sp: Span,\n-                      mutbl: bool,\n-                      ident: ast::Ident,\n-                      typ: P<ast::Ty>,\n-                      ex: P<ast::Expr>)\n-                      -> ast::Stmt {\n-        let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n-        } else {\n-            self.pat_ident(sp, ident)\n-        };\n-        let local = P(ast::Local {\n-            pat,\n-            ty: Some(typ),\n-            init: Some(ex),\n-            id: ast::DUMMY_NODE_ID,\n-            span: sp,\n-            attrs: ThinVec::new(),\n-        });\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n-            span: sp,\n-        }\n-    }\n-\n     // Generates `let _: Type;`, which is usually used for type assertions.\n     pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n@@ -330,11 +252,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    /// Constructs a `QPath` expression.\n-    pub fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Path(Some(qself), path))\n-    }\n-\n     pub fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n@@ -348,27 +265,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr_unary(sp, UnOp::Deref, e)\n-    }\n-    pub fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Unary(op, e))\n+        self.expr(sp, ast::ExprKind::Unary(UnOp::Deref, e))\n     }\n \n-    pub fn expr_field_access(\n-        &self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident,\n-    ) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n-    }\n-    pub fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let ident = Ident::new(sym::integer(idx), sp);\n-        self.expr(sp, ast::ExprKind::Field(expr, ident))\n-    }\n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n     }\n-    pub fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Mutable, e))\n-    }\n \n     pub fn expr_call(\n         &self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>,\n@@ -424,39 +326,17 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n                                               ast::LitIntType::Unsigned(ast::UintTy::Usize)))\n     }\n-    pub fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n-        if i < 0 {\n-            let i = (-i) as u128;\n-            let lit_ty = ast::LitIntType::Signed(ast::IntTy::Isize);\n-            let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n-            self.expr_unary(sp, ast::UnOp::Neg, lit)\n-        } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n-                                                ast::LitIntType::Signed(ast::IntTy::Isize)))\n-        }\n-    }\n     pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128,\n                                             ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n-    pub fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n-                                            ast::LitIntType::Unsigned(ast::UintTy::U16)))\n-    }\n-    pub fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n-    }\n     pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n     pub fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n-    pub fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr_call_global(sp, self.std_path(&[sym::vec, sym::Vec, sym::new]),\n-                              Vec::new())\n-    }\n     pub fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n@@ -473,16 +353,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n-    pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n-        let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n-        let none = self.path_global(sp, none);\n-        self.expr_path(none)\n-    }\n-\n-    pub fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Break(None, None))\n-    }\n-\n     pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n@@ -511,11 +381,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, ok, vec![expr])\n     }\n \n-    pub fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n-        self.expr_call_global(sp, err, vec![expr])\n-    }\n-\n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let ok_path = self.path_global(sp, ok);\n@@ -632,10 +497,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    pub fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Loop(block, None))\n-    }\n-\n     pub fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n@@ -656,7 +517,7 @@ impl<'a> ExtCtxt<'a> {\n               body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n-            ids.iter().map(|id| self.param(span, *id, self.ty_infer(span))).collect(),\n+            ids.iter().map(|id| self.param(span, *id, self.ty(span, ast::TyKind::Infer))).collect(),\n             ast::FunctionRetTy::Default(span));\n \n         // FIXME -- We are using `span` as the span of the `|...|`\n@@ -679,16 +540,6 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts(&self,\n-                    span: Span,\n-                    ids: Vec<ast::Ident>,\n-                    stmts: Vec<ast::Stmt>)\n-                    -> P<ast::Expr> {\n-        self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n-    }\n-    pub fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.expr_block(self.block(span, stmts)))\n-    }\n     pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n@@ -730,43 +581,6 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn item_fn_poly(&self,\n-                    span: Span,\n-                    name: Ident,\n-                    inputs: Vec<ast::Param> ,\n-                    output: P<ast::Ty>,\n-                    generics: Generics,\n-                    body: P<ast::Block>) -> P<ast::Item> {\n-        self.item(span,\n-                  name,\n-                  Vec::new(),\n-                  ast::ItemKind::Fn(self.fn_decl(inputs, ast::FunctionRetTy::Ty(output)),\n-                              ast::FnHeader {\n-                                  unsafety: ast::Unsafety::Normal,\n-                                  asyncness: dummy_spanned(ast::IsAsync::NotAsync),\n-                                  constness: dummy_spanned(ast::Constness::NotConst),\n-                                  abi: Abi::Rust,\n-                              },\n-                              generics,\n-                              body))\n-    }\n-\n-    pub fn item_fn(&self,\n-               span: Span,\n-               name: Ident,\n-               inputs: Vec<ast::Param> ,\n-               output: P<ast::Ty>,\n-               body: P<ast::Block>\n-              ) -> P<ast::Item> {\n-        self.item_fn_poly(\n-            span,\n-            name,\n-            inputs,\n-            output,\n-            Generics::default(),\n-            body)\n-    }\n-\n     pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n@@ -797,52 +611,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn item_enum_poly(&self, span: Span, name: Ident,\n-                      enum_definition: ast::EnumDef,\n-                      generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n-    }\n-\n-    pub fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> P<ast::Item> {\n-        self.item_enum_poly(span, name, enum_definition,\n-                            Generics::default())\n-    }\n-\n-    pub fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::VariantData) -> P<ast::Item> {\n-        self.item_struct_poly(\n-            span,\n-            name,\n-            struct_def,\n-            Generics::default()\n-        )\n-    }\n-\n-    pub fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n-    }\n-\n-    pub fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute>,\n-                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n-        self.item(\n-            span,\n-            name,\n-            attrs,\n-            ast::ItemKind::Mod(ast::Mod {\n-                inner: inner_span,\n-                items,\n-                inline: true\n-            })\n-        )\n-    }\n-\n-    pub fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::ExternCrate(None))\n-    }\n-\n     pub fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n@@ -862,86 +630,11 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n-    pub fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::TyAlias(ty, generics))\n-    }\n-\n-    pub fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n-        self.item_ty_poly(span, name, ty, Generics::default())\n-    }\n-\n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n         attr::mk_attr_outer(mi)\n     }\n \n     pub fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n         attr::mk_word_item(Ident::new(w, sp))\n     }\n-\n-    pub fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n-        attr::mk_nested_word_item(Ident::new(w, sp))\n-    }\n-\n-    pub fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n-                 -> ast::MetaItem {\n-        attr::mk_list_item(Ident::new(name, sp), mis)\n-    }\n-\n-    pub fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n-                       -> ast::MetaItem {\n-        attr::mk_name_value_item(Ident::new(name, span), lit_kind, span)\n-    }\n-\n-    pub fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n-        P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: Ident::invalid(),\n-            attrs: vec![],\n-            node: ast::ItemKind::Use(vp),\n-            vis,\n-            span: sp,\n-            tokens: None,\n-        })\n-    }\n-\n-    pub fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n-        self.item_use_simple_(sp, vis, None, path)\n-    }\n-\n-    pub fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        rename: Option<ast::Ident>, path: ast::Path) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: path,\n-            kind: ast::UseTreeKind::Simple(rename, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        }))\n-    }\n-\n-    pub fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n-        let imports = imports.iter().map(|id| {\n-            (ast::UseTree {\n-                span: sp,\n-                prefix: self.path(sp, vec![*id]),\n-                kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-            }, ast::DUMMY_NODE_ID)\n-        }).collect();\n-\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Nested(imports),\n-        }))\n-    }\n-\n-    pub fn item_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Glob,\n-        }))\n-    }\n }"}, {"sha": "9a4c540dc6f1f349ea7600e655c24edb145f31d4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -115,7 +115,7 @@ fn cs_clone_shallow(name: &str,\n         let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n-                                        vec![GenericArg::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {"}, {"sha": "c92339dd2fbd5c2141900258d1340a013a063ff4", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -2,7 +2,7 @@ use crate::deriving::path_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n-use syntax::ast::{self, Expr, MetaItem, GenericArg};\n+use syntax::ast::{self, Ident, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n@@ -16,8 +16,8 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n     cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::EQ);\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let hidden = cx.meta_list_item_word(span, sym::hidden);\n-    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n+    let hidden = syntax::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n+    let doc = syntax::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n     let attrs = vec![cx.attribute(inline), cx.attribute(doc)];\n     let trait_def = TraitDef {\n         span,\n@@ -56,7 +56,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n         let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n-                                        vec![GenericArg::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt<'_>,"}, {"sha": "fec035d331dc564ee535990383c9ee1ec0de9149", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -664,16 +664,19 @@ impl<'a> TraitDef<'a> {\n         }).collect();\n \n         // Create the type of `self`.\n-        let path = cx.path_all(self.span, false, vec![type_ident], self_params, vec![]);\n+        let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n-            let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n-            cx.attribute(cx.meta_list(self.span, sym::allow, vec![word]))\n+            let word = syntax::attr::mk_nested_word_item(\n+                Ident::new(Symbol::intern(\"unused_qualifications\"), self.span));\n+            let list = syntax::attr::mk_list_item(\n+                Ident::new(sym::allow, self.span), vec![word]);\n+            cx.attribute(list)\n         };\n \n         let mut a = vec![attr, unused_qual];"}, {"sha": "6ae02a5cab199e8cc857370c6d5d4dd8a527d292", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -82,12 +82,12 @@ impl<'a> Path<'a> {\n                        .collect();\n \n         match self.kind {\n-            PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n-            PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n+            PathKind::Global => cx.path_all(span, true, idents, params),\n+            PathKind::Local => cx.path_all(span, false, idents, params),\n             PathKind::Std => {\n                 let def_site = cx.with_def_site_ctxt(DUMMY_SP);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n-                cx.path_all(span, false, idents, params, Vec::new())\n+                cx.path_all(span, false, idents, params)\n             }\n         }\n \n@@ -183,7 +183,7 @@ impl<'a> Ty<'a> {\n                     }\n                 }).collect();\n \n-                cx.path_all(span, false, vec![self_ty], params, vec![])\n+                cx.path_all(span, false, vec![self_ty], params)\n             }\n             Literal(ref p) => p.to_path(cx, span, self_ty, generics),\n             Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),"}, {"sha": "02757bf6b1689f730aa63aaea8a747f2870093a0", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                                                                  Ident::new(sym::str, sp)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n-                                     vec![]))\n+                                     ))\n         }\n         Ok(s) => {\n             cx.expr_call_global(sp,"}, {"sha": "6c7e3e3eb98759185ab381a10d89eeec1a99c347", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da58e11d0265ee8412a21d63cf972955754769b6/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=da58e11d0265ee8412a21d63cf972955754769b6", "patch": "@@ -145,8 +145,8 @@ pub fn expand_test_or_bench(\n     let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n-            cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n-                cx.meta_list_item_word(attr_sp, sym::test)\n+            cx.attribute(attr::mk_list_item(ast::Ident::new(sym::cfg, attr_sp), vec![\n+                attr::mk_nested_word_item(ast::Ident::new(sym::test, attr_sp))\n             ])),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),"}]}