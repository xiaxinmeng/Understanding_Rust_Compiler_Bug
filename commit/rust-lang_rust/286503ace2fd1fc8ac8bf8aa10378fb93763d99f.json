{"sha": "286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NjUwM2FjZTJmZDFmYzhhYzhiZjhhYTEwMzc4ZmI5Mzc2M2Q5OWY=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-12-16T21:47:37Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-12-20T06:20:17Z"}, "message": "Refactor and add comments to code in receiver_is_valid\n\nalso updated some error messages\n\nremoved the code manually checking for `receiver_ty: Deref<Target=self_ty>`, in favour of using autoderef but only doing one iteration. This will cause error messages to be more consistent. Before, a \"mismatched method receiver\" error would be emitted when `receiver_ty` was valid except for a lifetime parameter, but only when `feature(arbitrary_self_types)` was enabled, and without the feature flag the error would be \"uncoercible receiver\". Now it emits \"mismatched method receiver\" in both cases.", "tree": {"sha": "539f304409b8b03dbf5d56a0b6b0e10ee139f62c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/539f304409b8b03dbf5d56a0b6b0e10ee139f62c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "html_url": "https://github.com/rust-lang/rust/commit/286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d93c6149dd70bf16c45f3238fa74241c336e02d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d93c6149dd70bf16c45f3238fa74241c336e02d", "html_url": "https://github.com/rust-lang/rust/commit/1d93c6149dd70bf16c45f3238fa74241c336e02d"}], "stats": {"total": 115, "additions": 46, "deletions": 69}, "files": [{"sha": "e74b1ae47e39d58eadb488e499630869bd32b9ce", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 34, "deletions": 57, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "patch": "@@ -760,8 +760,8 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n             // report error, arbitrary_self_types was enabled\n             fcx.tcx.sess.diagnostic().mut_span_err(\n-                span, &format!(\"invalid `self` type: {:?}\", receiver_ty)\n-            ).note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n+                span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n+            ).note(\"type of `self` must be `Self` or a type that dereferences to it\")\n             .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n             .code(DiagnosticId::Error(\"E0307\".into()))\n             .emit();\n@@ -785,8 +785,8 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n             } else {\n                 // report error, would not have worked with arbitrary_self_types\n                 fcx.tcx.sess.diagnostic().mut_span_err(\n-                    span, &format!(\"invalid `self` type: {:?}\", receiver_ty)\n-                ).note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n+                    span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n+                ).note(\"type must be `Self` or a type that dereferences to it\")\n                 .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n                 .code(DiagnosticId::Error(\"E0307\".into()))\n                 .emit();\n@@ -800,9 +800,9 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n /// through a `*const/mut T` raw pointer. If the feature is not enabled, the requirements are more\n /// strict: `receiver_ty` must implement `Receiver` and directly implement `Deref<Target=self_ty>`.\n ///\n-/// NB: there are cases this function returns `true` but then causes an error to be raised later,\n+/// NB: there are cases this function returns `true` but causes an error to be emitted,\n /// particularly when `receiver_ty` derefs to a type that is the same as `self_ty` but has the\n-/// wrong lifetime.\n+/// wrong lifetime. Be careful of this if you are calling this function speculatively.\n fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n     fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     span: Span,\n@@ -814,6 +814,7 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let can_eq_self = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n \n+    // `self: Self` is always valid\n     if can_eq_self(receiver_ty) {\n         if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, receiver_ty) {\n             err.emit();\n@@ -823,96 +824,72 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let mut autoderef = fcx.autoderef(span, receiver_ty);\n \n+    // the `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`\n     if arbitrary_self_types_enabled {\n         autoderef = autoderef.include_raw_pointers();\n     }\n \n-    // skip the first type, we know its not equal to `self_ty`\n+    // the first type is `receiver_ty`, which we know its not equal to `self_ty`. skip it.\n     autoderef.next();\n \n-    let potential_self_ty = loop {\n+    // keep dereferencing `receiver_ty` until we get to `self_ty`\n+    loop {\n         if let Some((potential_self_ty, _)) = autoderef.next() {\n             debug!(\"receiver_is_valid: potential self type `{:?}` to match `{:?}`\",\n                 potential_self_ty, self_ty);\n \n             if can_eq_self(potential_self_ty) {\n-                break potential_self_ty\n+                autoderef.finalize(fcx);\n+\n+                if let Some(mut err) = fcx.demand_eqtype_with_origin(\n+                    &cause, self_ty, potential_self_ty\n+                ) {\n+                    err.emit();\n+                }\n+\n+                break\n             }\n         } else {\n             debug!(\"receiver_is_valid: type `{:?}` does not deref to `{:?}`\",\n                 receiver_ty, self_ty);\n             return false\n         }\n-    };\n \n-    if !arbitrary_self_types_enabled {\n-        // check that receiver_ty: Receiver<Target=self_ty>\n+        // without the `arbitrary_self_types` feature, `receiver_ty` must directly deref to\n+        // `self_ty`. Enforce this by only doing one iteration of the loop\n+        if !arbitrary_self_types_enabled {\n+            return false\n+        }\n+    }\n \n-        let receiver_trait_def_id = match fcx.tcx.lang_items().receiver_trait() {\n+    // without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`\n+    if !arbitrary_self_types_enabled {\n+        let trait_def_id = match fcx.tcx.lang_items().receiver_trait() {\n             Some(did) => did,\n             None => {\n                 debug!(\"receiver_is_valid: missing Receiver trait\");\n                 return false\n             }\n         };\n \n-        let receiver_trait_ref = ty::TraitRef{\n-            def_id: receiver_trait_def_id,\n+        let trait_ref = ty::TraitRef{\n+            def_id: trait_def_id,\n             substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n         };\n \n-        let receiver_obligation = traits::Obligation::new(\n+        let obligation = traits::Obligation::new(\n             cause.clone(),\n             fcx.param_env,\n-            receiver_trait_ref.to_predicate()\n+            trait_ref.to_predicate()\n         );\n \n-        if !fcx.predicate_must_hold(&receiver_obligation) {\n+        if !fcx.predicate_must_hold(&obligation) {\n             debug!(\"receiver_is_valid: type `{:?}` does not implement `Receiver` trait\",\n                 receiver_ty);\n             return false\n         }\n-\n-        let deref_trait_def_id = match fcx.tcx.lang_items().deref_trait() {\n-            Some(did) => did,\n-            None => {\n-                debug!(\"receiver_is_valid: missing Deref trait\");\n-                return false\n-            }\n-        };\n-\n-        let deref_trait_ref = ty::TraitRef {\n-            def_id: deref_trait_def_id,\n-            substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n-        };\n-\n-        let projection_ty = ty::ProjectionTy::from_ref_and_name(\n-            fcx.tcx, deref_trait_ref, ast::Ident::from_str(\"Target\")\n-        );\n-\n-        let projection_predicate = ty::Binder::dummy(ty::ProjectionPredicate {\n-            projection_ty, ty: self_ty\n-        }).to_predicate();\n-\n-        let deref_obligation = traits::Obligation::new(\n-            cause.clone(),\n-            fcx.param_env,\n-            projection_predicate,\n-        );\n-\n-        if !fcx.predicate_must_hold(&deref_obligation) {\n-            debug!(\"receiver_is_valid: type `{:?}` does not directly deref to `{:?}`\",\n-                receiver_ty, self_ty);\n-            return false\n-        }\n-    }\n-\n-    if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, potential_self_ty) {\n-        err.emit();\n     }\n \n-    autoderef.finalize(fcx);\n-\n     true\n }\n "}, {"sha": "11c90833e7181aed0075ee8d3f7d2694117e3788", "filename": "src/test/ui/span/issue-27522.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fspan%2Fissue-27522.rs", "raw_url": "https://github.com/rust-lang/rust/raw/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fspan%2Fissue-27522.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-27522.rs?ref=286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "patch": "@@ -13,7 +13,7 @@\n struct SomeType {}\n \n trait Foo {\n-    fn handler(self: &SomeType); //~ ERROR invalid `self` type\n+    fn handler(self: &SomeType); //~ ERROR invalid method receiver type\n }\n \n fn main() {}"}, {"sha": "767b99a92cb2df777ac5228894bf8881a9a8d03f", "filename": "src/test/ui/span/issue-27522.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-27522.stderr?ref=286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "patch": "@@ -1,7 +1,7 @@\n-error[E0307]: invalid `self` type: &SomeType\n+error[E0307]: invalid method receiver type: &SomeType\n   --> $DIR/issue-27522.rs:16:22\n    |\n-LL |     fn handler(self: &SomeType); //~ ERROR invalid `self` type\n+LL |     fn handler(self: &SomeType); //~ ERROR invalid method receiver type\n    |                      ^^^^^^^^^\n    |\n    = note: type must be `Self` or a type that dereferences to it"}, {"sha": "f87541b56acf920f02d9f3afb25e2d5a07ba391b", "filename": "src/test/ui/ufcs/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.rs?ref=286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "patch": "@@ -16,7 +16,7 @@ struct Foo {\n \n impl Foo {\n     fn foo(self: isize, x: isize) -> isize {\n-        //~^ ERROR invalid `self` type\n+        //~^ ERROR invalid method receiver type\n         self.f + x\n     }\n }\n@@ -27,11 +27,11 @@ struct Bar<T> {\n \n impl<T> Bar<T> {\n     fn foo(self: Bar<isize>, x: isize) -> isize {\n-        //~^ ERROR invalid `self` type\n+        //~^ ERROR invalid method receiver type\n         x\n     }\n     fn bar(self: &Bar<usize>, x: isize) -> isize {\n-        //~^ ERROR invalid `self` type\n+        //~^ ERROR invalid method receiver type\n         x\n     }\n }"}, {"sha": "a229dabcce4a4c6e95e90e79f371f8683a6e621f", "filename": "src/test/ui/ufcs/ufcs-explicit-self-bad.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/286503ace2fd1fc8ac8bf8aa10378fb93763d99f/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-explicit-self-bad.stderr?ref=286503ace2fd1fc8ac8bf8aa10378fb93763d99f", "patch": "@@ -1,28 +1,28 @@\n-error[E0307]: invalid `self` type: isize\n+error[E0307]: invalid method receiver type: isize\n   --> $DIR/ufcs-explicit-self-bad.rs:18:18\n    |\n LL |     fn foo(self: isize, x: isize) -> isize {\n    |                  ^^^^^\n    |\n-   = note: type must be `Foo` or a type that dereferences to it\n+   = note: type must be `Self` or a type that dereferences to it\n    = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n \n-error[E0307]: invalid `self` type: Bar<isize>\n+error[E0307]: invalid method receiver type: Bar<isize>\n   --> $DIR/ufcs-explicit-self-bad.rs:29:18\n    |\n LL |     fn foo(self: Bar<isize>, x: isize) -> isize {\n    |                  ^^^^^^^^^^\n    |\n-   = note: type must be `Bar<T>` or a type that dereferences to it\n+   = note: type must be `Self` or a type that dereferences to it\n    = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n \n-error[E0307]: invalid `self` type: &Bar<usize>\n+error[E0307]: invalid method receiver type: &Bar<usize>\n   --> $DIR/ufcs-explicit-self-bad.rs:33:18\n    |\n LL |     fn bar(self: &Bar<usize>, x: isize) -> isize {\n    |                  ^^^^^^^^^^^\n    |\n-   = note: type must be `Bar<T>` or a type that dereferences to it\n+   = note: type must be `Self` or a type that dereferences to it\n    = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n \n error[E0308]: mismatched method receiver"}]}