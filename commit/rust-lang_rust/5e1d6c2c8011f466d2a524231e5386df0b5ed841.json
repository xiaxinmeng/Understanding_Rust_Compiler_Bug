{"sha": "5e1d6c2c8011f466d2a524231e5386df0b5ed841", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMWQ2YzJjODAxMWY0NjZkMmE1MjQyMzFlNTM4NmRmMGI1ZWQ4NDE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:30:42Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:33:54Z"}, "message": "libsyntax: add #[deriving(Rand, ToStr)].\n\nThe former fills each field of a struct or enum variant with a random\nvalue (and picks a random enum variant). The latter makes the .to_str\nmethod have the same output as fmt!(\"%?\", ..).", "tree": {"sha": "a1f29d8aef4fbfb03cb105f759018e9063efb591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f29d8aef4fbfb03cb105f759018e9063efb591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e1d6c2c8011f466d2a524231e5386df0b5ed841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1d6c2c8011f466d2a524231e5386df0b5ed841", "html_url": "https://github.com/rust-lang/rust/commit/5e1d6c2c8011f466d2a524231e5386df0b5ed841", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e1d6c2c8011f466d2a524231e5386df0b5ed841/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf2108a2b09942d6b225700b9d39dc9fa070463", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf2108a2b09942d6b225700b9d39dc9fa070463", "html_url": "https://github.com/rust-lang/rust/commit/1cf2108a2b09942d6b225700b9d39dc9fa070463"}], "stats": {"total": 196, "additions": 196, "deletions": 0}, "files": [{"sha": "d48ff98be06ee873cf3c45daafd0b31dfae5b319", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5e1d6c2c8011f466d2a524231e5386df0b5ed841", "patch": "@@ -23,6 +23,8 @@ pub mod clone;\n pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n+pub mod rand;\n+pub mod to_str;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -86,6 +88,10 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                             ~\"Ord\" => expand!(ord::expand_deriving_ord),\n                             ~\"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n \n+                            ~\"Rand\" => expand!(rand::expand_deriving_rand),\n+\n+                            ~\"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));"}, {"sha": "03202801d206d38f981fb4c11959902bc2f74890", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=5e1d6c2c8011f466d2a524231e5386df0b5ed841", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use ast::{meta_item, item, expr, ident};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_rand(cx: @ext_ctxt,\n+                            span: span,\n+                            mitem: @meta_item,\n+                            in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[~\"core\", ~\"rand\", ~\"Rand\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"rand\",\n+                generics: LifetimeBounds {\n+                    lifetimes: ~[],\n+                    bounds: ~[(~\"R\",\n+                               ~[ Path::new(~[~\"core\", ~\"rand\", ~\"Rng\"]) ])]\n+                },\n+                self_ty: None,\n+                args: ~[\n+                    Ptr(~Literal(Path::new_local(~\"R\")),\n+                        Borrowed(None, ast::m_imm))\n+                ],\n+                ret_ty: Self,\n+                const_nonmatching: false,\n+                combine_substructure: rand_substructure\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n+}\n+\n+fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    let rng = match substr.nonself_args {\n+        [rng] => ~[ rng ],\n+        _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n+    };\n+    let rand_ident = ~[\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"rand\"),\n+        cx.ident_of(~\"Rand\"),\n+        cx.ident_of(~\"rand\")\n+    ];\n+    let rand_call = || {\n+        build::mk_call_global(cx, span,\n+                              copy rand_ident, copy rng)\n+    };\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            rand_thing(cx, span, substr.type_ident, summary, rand_call)\n+        }\n+        StaticEnum(_, ref variants) => {\n+            if variants.is_empty() {\n+                cx.span_fatal(span, \"`Rand` cannot be derived for enums with no variants\");\n+            }\n+\n+            let variant_count = build::mk_uint(cx, span, variants.len());\n+\n+            // need to specify the uint-ness of the random number\n+            let u32_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(~\"uint\")]);\n+            let r_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(~\"R\")]);\n+            let rand_name = build::mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n+            let rand_name = build::mk_path_raw(cx, span, rand_name);\n+\n+            let rv_call = build::mk_call_(cx, span, rand_name, copy rng);\n+\n+            // rand() % variants.len()\n+            let rand_variant = build::mk_binary(cx, span, ast::rem,\n+                                                rv_call, variant_count);\n+\n+            let mut arms = do variants.mapi |i, id_sum| {\n+                let i_expr = build::mk_uint(cx, span, i);\n+                let pat = build::mk_pat_lit(cx, span, i_expr);\n+\n+                match *id_sum {\n+                    (ident, ref summary) => {\n+                        build::mk_arm(cx, span,\n+                                      ~[ pat ],\n+                                      rand_thing(cx, span, ident, summary, rand_call))\n+                    }\n+                }\n+            };\n+\n+            // _ => {} at the end. Should never occur\n+            arms.push(build::mk_unreachable_arm(cx, span));\n+\n+            build::mk_expr(cx, span,\n+                           ast::expr_match(rand_variant, arms))\n+        }\n+        _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n+    };\n+\n+    fn rand_thing(cx: @ext_ctxt, span: span,\n+                  ctor_ident: ident,\n+                  summary: &Either<uint, ~[ident]>,\n+                  rand_call: &fn() -> @expr) -> @expr {\n+        let ctor_ident = ~[ ctor_ident ];\n+        match *summary {\n+            Left(copy count) => {\n+                if count == 0 {\n+                    build::mk_path(cx, span, ctor_ident)\n+                } else {\n+                    let exprs = vec::from_fn(count, |_| rand_call());\n+                    build::mk_call(cx, span, ctor_ident, exprs)\n+                }\n+            }\n+            Right(ref fields) => {\n+                let rand_fields = do fields.map |ident| {\n+                    build::Field {\n+                        ident: *ident,\n+                        ex: rand_call()\n+                    }\n+                };\n+                build::mk_struct_e(cx, span, ctor_ident, rand_fields)\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "2c7d449585f1efa5deb9231fb3e4424f639fde11", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d6c2c8011f466d2a524231e5386df0b5ed841/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=5e1d6c2c8011f466d2a524231e5386df0b5ed841", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_to_str(cx: @ext_ctxt,\n+                              span: span,\n+                              mitem: @meta_item,\n+                              in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[~\"core\", ~\"to_str\", ~\"ToStr\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"to_str\",\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[],\n+                ret_ty: Ptr(~Literal(Path::new_local(~\"str\")), Owned),\n+                const_nonmatching: false,\n+                combine_substructure: to_str_substructure\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n+}\n+\n+fn to_str_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    match substr.self_args {\n+        [self_obj] => {\n+            let self_addr = build::mk_addr_of(cx, span, self_obj);\n+            build::mk_call_global(cx, span,\n+                                  ~[cx.ident_of(~\"core\"),\n+                                    cx.ident_of(~\"sys\"),\n+                                    cx.ident_of(~\"log_str\")],\n+                                  ~[self_addr])\n+        }\n+        _ => cx.span_bug(span, ~\"Invalid number of arguments in `deriving(ToStr)`\")\n+    }\n+}\n\\ No newline at end of file"}]}