{"sha": "56529cd2862bde1771633a2106d87eea0b02d50a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NTI5Y2QyODYyYmRlMTc3MTYzM2EyMTA2ZDg3ZWVhMGIwMmQ1MGE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-25T17:54:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-25T22:45:43Z"}, "message": "Add missing urls and examples to TcpStream", "tree": {"sha": "c3579502892c688aec419f5b6cc9a2d1ff3cb70d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3579502892c688aec419f5b6cc9a2d1ff3cb70d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56529cd2862bde1771633a2106d87eea0b02d50a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56529cd2862bde1771633a2106d87eea0b02d50a", "html_url": "https://github.com/rust-lang/rust/commit/56529cd2862bde1771633a2106d87eea0b02d50a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56529cd2862bde1771633a2106d87eea0b02d50a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c78cc52afd99ec0b3dd7f83cd257f0be767a508a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c78cc52afd99ec0b3dd7f83cd257f0be767a508a", "html_url": "https://github.com/rust-lang/rust/commit/c78cc52afd99ec0b3dd7f83cd257f0be767a508a"}], "stats": {"total": 193, "additions": 185, "deletions": 8}, "files": [{"sha": "a3a248e5b720282a9dc639df5a8bbc575c7c611e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 185, "deletions": 8, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/56529cd2862bde1771633a2106d87eea0b02d50a/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56529cd2862bde1771633a2106d87eea0b02d50a/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=56529cd2862bde1771633a2106d87eea0b02d50a", "patch": "@@ -86,18 +86,52 @@ impl TcpStream {\n     /// documentation for concrete examples.\n     /// In case `ToSocketAddrs::to_socket_addrs()` returns more than one entry,\n     /// then the first valid and reachable address is used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// if let Ok(stream) = TcpStream::connect(\"127.0.0.1:8080\") {\n+    ///     println!(\"Connected to the server!\");\n+    /// } else {\n+    ///     println!(\"Couldn't connect to server...\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpStream};\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// assert_eq!(stream.peer_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         self.0.peer_addr()\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpStream};\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// assert_eq!(stream.local_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n@@ -107,7 +141,19 @@ impl TcpStream {\n     ///\n     /// This function will cause all pending and future I/O on the specified\n     /// portions to return immediately with an appropriate value (see the\n-    /// documentation of `Shutdown`).\n+    /// documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Shutdown, TcpStream};\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.shutdown(Shutdown::Both).expect(\"shutdown call failed\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n@@ -119,62 +165,131 @@ impl TcpStream {\n     /// object references. Both handles will read and write the same stream of\n     /// data, and options set on one stream will be propagated to the other\n     /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// let stream_clone = stream.try_clone().expect(\"clone failed...\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<TcpStream> {\n         self.0.duplicate().map(TcpStream)\n     }\n \n     /// Sets the read timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `read` calls will block\n+    /// If the value specified is [`None`], then [`read()`] calls will block\n     /// indefinitely. It is an error to pass the zero `Duration` to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a read times out as\n     /// a result of setting this option. For example Unix typically returns an\n-    /// error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n     }\n \n     /// Sets the write timeout to the timeout specified.\n     ///\n-    /// If the value specified is `None`, then `write` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the value specified is [`None`], then [`write()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n     /// # Note\n     ///\n     /// Platforms may return a different error code whenever a write times out\n     /// as a result of setting this option. For example Unix typically returns\n-    /// an error of the kind `WouldBlock`, but Windows may return `TimedOut`.\n+    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n+    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)\n     }\n \n     /// Returns the read timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `read` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`read()`] calls will block indefinitely.\n     ///\n     /// # Note\n     ///\n     /// Some platforms do not provide access to the current timeout.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n+    /// assert_eq!(stream.read_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.read_timeout()\n     }\n \n     /// Returns the write timeout of this socket.\n     ///\n-    /// If the timeout is `None`, then `write` calls will block indefinitely.\n+    /// If the timeout is [`None`], then [`write()`] calls will block indefinitely.\n     ///\n     /// # Note\n     ///\n     /// Some platforms do not provide access to the current timeout.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`write()`]: ../../std/io/trait.Write.html#tymethod.write\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n+    /// assert_eq!(stream.write_timeout().unwrap(), None);\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n@@ -187,6 +302,16 @@ impl TcpStream {\n     /// small amount of data. When not set, data is buffered until there is a\n     /// sufficient amount to send out, thereby avoiding the frequent sending of\n     /// small packets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         self.0.set_nodelay(nodelay)\n@@ -197,6 +322,17 @@ impl TcpStream {\n     /// For more information about this option, see [`set_nodelay`][link].\n     ///\n     /// [link]: #method.set_nodelay\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n+    /// assert_eq!(stream.nodelay().unwrap_or(false), true);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn nodelay(&self) -> io::Result<bool> {\n         self.0.nodelay()\n@@ -206,6 +342,16 @@ impl TcpStream {\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n     /// from this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n         self.0.set_ttl(ttl)\n@@ -216,6 +362,17 @@ impl TcpStream {\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n     /// [link]: #method.set_ttl\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n+    /// assert_eq!(stream.ttl().unwrap_or(0), 100);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -226,6 +383,16 @@ impl TcpStream {\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n     /// calls.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.take_error().expect(\"No error was expected...\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -235,6 +402,16 @@ impl TcpStream {\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n     /// corresponds to calling ioctlsocket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)"}]}