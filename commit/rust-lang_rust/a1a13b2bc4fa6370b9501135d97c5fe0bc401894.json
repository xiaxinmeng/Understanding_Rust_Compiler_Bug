{"sha": "a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYTEzYjJiYzRmYTYzNzBiOTUwMTEzNWQ5N2M1ZmUwYmM0MDE4OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T22:46:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T22:46:50Z"}, "message": "Auto merge of #78461 - TimDiekmann:vec-alloc, r=Amanieu\n\nAdd support for custom allocators in `Vec`\n\nThis follows the [roadmap](https://github.com/rust-lang/wg-allocators/issues/7) of the allocator WG to add custom allocators to collections.\n\nr? `@Amanieu`\n\nThis pull request requires a crater run.\n\n### Prior work:\n- #71873: Crater-test to solve rust-lang/wg-allocators#1\n- [`alloc-wg`](https://github.com/TimDiekmann/alloc-wg)-crate", "tree": {"sha": "6b0b0279e069cf0d343040eeb9c917637dd2bd93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b0b0279e069cf0d343040eeb9c917637dd2bd93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "html_url": "https://github.com/rust-lang/rust/commit/a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da384694807172f0ca40eca2e49a11688aba6e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/da384694807172f0ca40eca2e49a11688aba6e93", "html_url": "https://github.com/rust-lang/rust/commit/da384694807172f0ca40eca2e49a11688aba6e93"}, {"sha": "a600410f4f005151b34aca5d3371144943104a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a600410f4f005151b34aca5d3371144943104a5f", "html_url": "https://github.com/rust-lang/rust/commit/a600410f4f005151b34aca5d3371144943104a5f"}], "stats": {"total": 710, "additions": 504, "deletions": 206}, "files": [{"sha": "f56e3af4ff29d4221dfc31cd05519a070c32dcc8", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -1347,9 +1347,10 @@ impl<I> FromIterator<I> for Box<[I]> {\n }\n \n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n-impl<T: Clone> Clone for Box<[T]> {\n+impl<T: Clone, A: AllocRef + Clone> Clone for Box<[T], A> {\n     fn clone(&self) -> Self {\n-        self.to_vec().into_boxed_slice()\n+        let alloc = Box::alloc_ref(self).clone();\n+        self.to_vec_in(alloc).into_boxed_slice()\n     }\n \n     fn clone_from(&mut self, other: &Self) {"}, {"sha": "d079d331fa1a9503a7b0620301c6e799c5d1dd1e", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -233,15 +233,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n-    pub fn alloc(&self) -> &A {\n+    pub fn alloc_ref(&self) -> &A {\n         &self.alloc\n     }\n \n-    /// Returns a mutable reference to the allocator backing this `RawVec`.\n-    pub fn alloc_mut(&mut self) -> &mut A {\n-        &mut self.alloc\n-    }\n-\n     fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n         if mem::size_of::<T>() == 0 || self.cap == 0 {\n             None"}, {"sha": "41ebb1cf654bc6b141dc09d0788a65c95d10e4d9", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -87,6 +87,7 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n \n+use crate::alloc::{AllocRef, Global};\n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n@@ -137,26 +138,28 @@ pub use hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n+    use core::alloc::AllocRef;\n+\n     use crate::boxed::Box;\n     use crate::vec::Vec;\n \n     // We shouldn't add inline attribute to this since this is used in\n     // `vec!` macro mostly and causes perf regression. See #71204 for\n     // discussion and perf results.\n-    pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n+    pub fn into_vec<T, A: AllocRef>(b: Box<[T], A>) -> Vec<T, A> {\n         unsafe {\n             let len = b.len();\n-            let b = Box::into_raw(b);\n-            Vec::from_raw_parts(b as *mut T, len, len)\n+            let (b, alloc) = Box::into_raw_with_alloc(b);\n+            Vec::from_raw_parts_in(b as *mut T, len, len, alloc)\n         }\n     }\n \n     #[inline]\n-    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n+    pub fn to_vec<T, A: AllocRef>(s: &[T], alloc: A) -> Vec<T, A>\n     where\n         T: Clone,\n     {\n-        let mut vec = Vec::with_capacity(s.len());\n+        let mut vec = Vec::with_capacity_in(s.len(), alloc);\n         vec.extend_from_slice(s);\n         vec\n     }\n@@ -388,11 +391,33 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n+    where\n+        T: Clone,\n+    {\n+        self.to_vec_in(Global)\n+    }\n+\n+    /// Copies `self` into a new `Vec` with an allocator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let s = [10, 40, 30];\n+    /// let x = s.to_vec_in(System);\n+    /// // Here, `s` and `x` can be modified independently.\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn to_vec_in<A: AllocRef>(&self, alloc: A) -> Vec<T, A>\n     where\n         T: Clone,\n     {\n         // N.B., see the `hack` module in this file for more details.\n-        hack::to_vec(self)\n+        hack::to_vec(self, alloc)\n     }\n \n     /// Converts `self` into a vector without clones or allocation.\n@@ -411,7 +436,7 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn into_vec(self: Box<Self>) -> Vec<T> {\n+    pub fn into_vec<A: AllocRef>(self: Box<Self, A>) -> Vec<T, A> {\n         // N.B., see the `hack` module in this file for more details.\n         hack::into_vec(self)\n     }\n@@ -730,7 +755,7 @@ impl<T: Clone> ToOwned for [T] {\n \n     #[cfg(test)]\n     fn to_owned(&self) -> Vec<T> {\n-        hack::to_vec(self)\n+        hack::to_vec(self, Global)\n     }\n \n     fn clone_into(&self, target: &mut Vec<T>) {"}, {"sha": "392c16546efb006dd588479315aa3c4f482e327d", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 450, "deletions": 176, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -68,6 +68,7 @@ use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n+use crate::alloc::{AllocRef, Global};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::collections::TryReserveError;\n@@ -297,8 +298,8 @@ use crate::raw_vec::RawVec;\n /// [`&`]: ../../std/primitive.reference.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\n-pub struct Vec<T> {\n-    buf: RawVec<T>,\n+pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n+    buf: RawVec<T, A>,\n     len: usize,\n }\n \n@@ -320,7 +321,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.39.0\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn new() -> Vec<T> {\n+    pub const fn new() -> Self {\n         Vec { buf: RawVec::NEW, len: 0 }\n     }\n \n@@ -359,49 +360,145 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> Vec<T> {\n-        Vec { buf: RawVec::with_capacity(capacity), len: 0 }\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        Self::with_capacity_in(capacity, Global)\n     }\n \n-    /// Decomposes a `Vec<T>` into its raw components.\n+    /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n-    /// Returns the raw pointer to the underlying data, the length of\n-    /// the vector (in elements), and the allocated capacity of the\n-    /// data (in elements). These are the same arguments in the same\n-    /// order as the arguments to [`from_raw_parts`].\n+    /// # Safety\n     ///\n-    /// After calling this function, the caller is responsible for the\n-    /// memory previously managed by the `Vec`. The only way to do\n-    /// this is to convert the raw pointer, length, and capacity back\n-    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n-    /// the destructor to perform the cleanup.\n+    /// This is highly unsafe, due to the number of invariants that aren't\n+    /// checked:\n     ///\n-    /// [`from_raw_parts`]: Vec::from_raw_parts\n+    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n+    ///   (at least, it's highly likely to be incorrect if it wasn't).\n+    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.\n+    ///   (`T` having a less strict alignment is not sufficient, the alignment really\n+    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n+    ///   allocated and deallocated with the same layout.)\n+    /// * `length` needs to be less than or equal to `capacity`.\n+    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n+    ///\n+    /// Violating these may cause problems like corrupting the allocator's\n+    /// internal data structures. For example it is **not** safe\n+    /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n+    /// It's also not safe to build one from a `Vec<u16>` and its length, because\n+    /// the allocator cares about the alignment, and these two types have different\n+    /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n+    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n+    ///\n+    /// The ownership of `ptr` is effectively transferred to the\n+    /// `Vec<T>` which may then deallocate, reallocate or change the\n+    /// contents of memory pointed to by the pointer at will. Ensure\n+    /// that nothing else uses the pointer after calling this\n+    /// function.\n+    ///\n+    /// [`String`]: crate::string::String\n+    /// [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vec_into_raw_parts)]\n-    /// let v: Vec<i32> = vec![-1, 0, 1];\n+    /// use std::ptr;\n+    /// use std::mem;\n     ///\n-    /// let (ptr, len, cap) = v.into_raw_parts();\n+    /// let v = vec![1, 2, 3];\n     ///\n-    /// let rebuilt = unsafe {\n-    ///     // We can now make changes to the components, such as\n-    ///     // transmuting the raw pointer to a compatible type.\n-    ///     let ptr = ptr as *mut u32;\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    /// // Prevent running `v`'s destructor so we are in complete control\n+    /// // of the allocation.\n+    /// let mut v = mem::ManuallyDrop::new(v);\n     ///\n-    ///     Vec::from_raw_parts(ptr, len, cap)\n-    /// };\n-    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// // Pull out the various important pieces of information about `v`\n+    /// let p = v.as_mut_ptr();\n+    /// let len = v.len();\n+    /// let cap = v.capacity();\n+    ///\n+    /// unsafe {\n+    ///     // Overwrite memory with 4, 5, 6\n+    ///     for i in 0..len as isize {\n+    ///         ptr::write(p.offset(i), 4 + i);\n+    ///     }\n+    ///\n+    ///     // Put everything back together into a Vec\n+    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n+    ///     assert_eq!(rebuilt, [4, 5, 6]);\n+    /// }\n     /// ```\n-    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n-    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n-        let mut me = ManuallyDrop::new(self);\n-        (me.as_mut_ptr(), me.len(), me.capacity())\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Self {\n+        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }\n     }\n+}\n \n-    /// Creates a `Vec<T>` directly from the raw components of another vector.\n+impl<T, A: AllocRef> Vec<T, A> {\n+    /// Constructs a new, empty `Vec<T, A>`.\n+    ///\n+    /// The vector will not allocate until elements are pushed onto it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// # #[allow(unused_mut)]\n+    /// let mut vec: Vec<i32, _> = Vec::new_in(System);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn new_in(alloc: A) -> Self {\n+        Vec { buf: RawVec::new_in(alloc), len: 0 }\n+    }\n+\n+    /// Constructs a new, empty `Vec<T, A>` with the specified capacity with the provided\n+    /// allocator.\n+    ///\n+    /// The vector will be able to hold exactly `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    ///\n+    /// It is important to note that although the returned vector has the\n+    /// *capacity* specified, the vector will have a zero *length*. For an\n+    /// explanation of the difference between length and capacity, see\n+    /// *[Capacity and reallocation]*.\n+    ///\n+    /// [Capacity and reallocation]: #capacity-and-reallocation\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let mut vec = Vec::with_capacity_in(10, System);\n+    ///\n+    /// // The vector contains no items, even though it has capacity for more\n+    /// assert_eq!(vec.len(), 0);\n+    /// assert_eq!(vec.capacity(), 10);\n+    ///\n+    /// // These are all done without reallocating...\n+    /// for i in 0..10 {\n+    ///     vec.push(i);\n+    /// }\n+    /// assert_eq!(vec.len(), 10);\n+    /// assert_eq!(vec.capacity(), 10);\n+    ///\n+    /// // ...but this may make the vector reallocate\n+    /// vec.push(11);\n+    /// assert_eq!(vec.len(), 11);\n+    /// assert!(vec.capacity() >= 11);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n+        Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }\n+    }\n+\n+    /// Creates a `Vec<T, A>` directly from the raw components of another vector.\n     ///\n     /// # Safety\n     ///\n@@ -437,10 +534,17 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// let v = vec![1, 2, 3];\n+    /// let mut v = Vec::with_capacity_in(3, System);\n+    /// v.push(1);\n+    /// v.push(2);\n+    /// v.push(3);\n     ///\n     // FIXME Update this when vec_into_raw_parts is stabilized\n     /// // Prevent running `v`'s destructor so we are in complete control\n@@ -451,6 +555,7 @@ impl<T> Vec<T> {\n     /// let p = v.as_mut_ptr();\n     /// let len = v.len();\n     /// let cap = v.capacity();\n+    /// let alloc = v.alloc_ref();\n     ///\n     /// unsafe {\n     ///     // Overwrite memory with 4, 5, 6\n@@ -459,13 +564,100 @@ impl<T> Vec<T> {\n     ///     }\n     ///\n     ///     // Put everything back together into a Vec\n-    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n+    ///     let rebuilt = Vec::from_raw_parts_in(p, len, cap, alloc.clone());\n     ///     assert_eq!(rebuilt, [4, 5, 6]);\n     /// }\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n-        unsafe { Vec { buf: RawVec::from_raw_parts(ptr, capacity), len: length } }\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {\n+        unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }\n+    }\n+\n+    /// Decomposes a `Vec<T>` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the vector (in elements), and the allocated capacity of the\n+    /// data (in elements). These are the same arguments in the same\n+    /// order as the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Vec`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: Vec::from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let v: Vec<i32> = vec![-1, 0, 1];\n+    ///\n+    /// let (ptr, len, cap) = v.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe {\n+    ///     // We can now make changes to the components, such as\n+    ///     // transmuting the raw pointer to a compatible type.\n+    ///     let ptr = ptr as *mut u32;\n+    ///\n+    ///     Vec::from_raw_parts(ptr, len, cap)\n+    /// };\n+    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n+        let mut me = ManuallyDrop::new(self);\n+        (me.as_mut_ptr(), me.len(), me.capacity())\n+    }\n+\n+    /// Decomposes a `Vec<T>` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of the vector (in elements),\n+    /// the allocated capacity of the data (in elements), and the allocator. These are the same\n+    /// arguments in the same order as the arguments to [`from_raw_parts_in`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Vec`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `Vec` with the [`from_raw_parts_in`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts_in`]: Vec::from_raw_parts_in\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, vec_into_raw_parts)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let mut v: Vec<i32, System> = Vec::new_in(System);\n+    /// v.push(-1);\n+    /// v.push(0);\n+    /// v.push(1);\n+    ///\n+    /// let (ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();\n+    ///\n+    /// let rebuilt = unsafe {\n+    ///     // We can now make changes to the components, such as\n+    ///     // transmuting the raw pointer to a compatible type.\n+    ///     let ptr = ptr as *mut u32;\n+    ///\n+    ///     Vec::from_raw_parts_in(ptr, len, cap, alloc)\n+    /// };\n+    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts_with_alloc(self) -> (*mut T, usize, usize, A) {\n+        let mut me = ManuallyDrop::new(self);\n+        let len = me.len();\n+        let capacity = me.capacity();\n+        let ptr = me.as_mut_ptr();\n+        let alloc = unsafe { ptr::read(me.alloc_ref()) };\n+        (ptr, len, capacity, alloc)\n     }\n \n     /// Returns the number of elements the vector can hold without\n@@ -684,7 +876,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(slice.into_vec().capacity(), 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n+    pub fn into_boxed_slice(mut self) -> Box<[T], A> {\n         unsafe {\n             self.shrink_to_fit();\n             let me = ManuallyDrop::new(self);\n@@ -863,6 +1055,13 @@ impl<T> Vec<T> {\n         ptr\n     }\n \n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn alloc_ref(&self) -> &A {\n+        self.buf.alloc_ref()\n+    }\n+\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n@@ -1299,7 +1498,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, &[]);\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>\n     where\n         R: RangeBounds<usize>,\n     {\n@@ -1403,7 +1602,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n+    pub fn split_off(&mut self, at: usize) -> Self\n+    where\n+        A: Clone,\n+    {\n         #[cold]\n         #[inline(never)]\n         fn assert_failed(at: usize, len: usize) -> ! {\n@@ -1416,11 +1618,14 @@ impl<T> Vec<T> {\n \n         if at == 0 {\n             // the new vector can take over the original buffer and avoid the copy\n-            return mem::replace(self, Vec::with_capacity(self.capacity()));\n+            return mem::replace(\n+                self,\n+                Vec::with_capacity_in(self.capacity(), self.alloc_ref().clone()),\n+            );\n         }\n \n         let other_len = self.len - at;\n-        let mut other = Vec::with_capacity(other_len);\n+        let mut other = Vec::with_capacity_in(other_len, self.alloc_ref().clone());\n \n         // Unsafely `set_len` and copy items to `other`.\n         unsafe {\n@@ -1497,7 +1702,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn leak<'a>(self) -> &'a mut [T]\n     where\n-        T: 'a, // Technically not needed, but kept to be explicit.\n+        A: 'a,\n     {\n         Box::leak(self.into_boxed_slice())\n     }\n@@ -1544,7 +1749,7 @@ impl<T> Vec<T> {\n     }\n }\n \n-impl<T: Clone> Vec<T> {\n+impl<T: Clone, A: AllocRef> Vec<T, A> {\n     /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n     ///\n     /// If `new_len` is greater than `len`, the `Vec` is extended by the\n@@ -1639,7 +1844,7 @@ impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n     }\n }\n \n-impl<T> Vec<T> {\n+impl<T, A: AllocRef> Vec<T, A> {\n     /// Extend the vector by `n` values, using the given generator.\n     fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n         self.reserve(n);\n@@ -1699,7 +1904,7 @@ impl Drop for SetLenOnDrop<'_> {\n     }\n }\n \n-impl<T: PartialEq> Vec<T> {\n+impl<T: PartialEq, A: AllocRef> Vec<T, A> {\n     /// Removes consecutive repeated elements in the vector according to the\n     /// [`PartialEq`] trait implementation.\n     ///\n@@ -1721,7 +1926,7 @@ impl<T: PartialEq> Vec<T> {\n     }\n }\n \n-impl<T> Vec<T> {\n+impl<T, A: AllocRef> Vec<T, A> {\n     /// Removes the first instance of `item` from the vector if the item exists.\n     ///\n     /// This method will be removed soon.\n@@ -1749,30 +1954,36 @@ impl<T> Vec<T> {\n #[doc(hidden)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n-    <T as SpecFromElem>::from_elem(elem, n)\n+    <T as SpecFromElem>::from_elem(elem, n, Global)\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub fn from_elem_in<T: Clone, A: AllocRef>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+    <T as SpecFromElem>::from_elem(elem, n, alloc)\n }\n \n // Specialization trait used for Vec::from_elem\n trait SpecFromElem: Sized {\n-    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n+    fn from_elem<A: AllocRef>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n }\n \n impl<T: Clone> SpecFromElem for T {\n-    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n-        let mut v = Vec::with_capacity(n);\n+    default fn from_elem<A: AllocRef>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n+        let mut v = Vec::with_capacity_in(n, alloc);\n         v.extend_with(n, ExtendElement(elem));\n         v\n     }\n }\n \n impl SpecFromElem for i8 {\n     #[inline]\n-    fn from_elem(elem: i8, n: usize) -> Vec<i8> {\n+    fn from_elem<A: AllocRef>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n         if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed(n), len: n };\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n         unsafe {\n-            let mut v = Vec::with_capacity(n);\n+            let mut v = Vec::with_capacity_in(n, alloc);\n             ptr::write_bytes(v.as_mut_ptr(), elem as u8, n);\n             v.set_len(n);\n             v\n@@ -1782,12 +1993,12 @@ impl SpecFromElem for i8 {\n \n impl SpecFromElem for u8 {\n     #[inline]\n-    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n+    fn from_elem<A: AllocRef>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n         if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed(n), len: n };\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n         unsafe {\n-            let mut v = Vec::with_capacity(n);\n+            let mut v = Vec::with_capacity_in(n, alloc);\n             ptr::write_bytes(v.as_mut_ptr(), elem, n);\n             v.set_len(n);\n             v\n@@ -1797,11 +2008,11 @@ impl SpecFromElem for u8 {\n \n impl<T: Clone + IsZero> SpecFromElem for T {\n     #[inline]\n-    fn from_elem(elem: T, n: usize) -> Vec<T> {\n+    fn from_elem<A: AllocRef>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n         if elem.is_zero() {\n-            return Vec { buf: RawVec::with_capacity_zeroed(n), len: n };\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n         }\n-        let mut v = Vec::with_capacity(n);\n+        let mut v = Vec::with_capacity_in(n, alloc);\n         v.extend_with(n, ExtendElement(elem));\n         v\n     }\n@@ -1882,7 +2093,7 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Deref for Vec<T> {\n+impl<T, A: AllocRef> ops::Deref for Vec<T, A> {\n     type Target = [T];\n \n     fn deref(&self) -> &[T] {\n@@ -1891,35 +2102,46 @@ impl<T> ops::Deref for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::DerefMut for Vec<T> {\n+impl<T, A: AllocRef> ops::DerefMut for Vec<T, A> {\n     fn deref_mut(&mut self) -> &mut [T] {\n         unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for Vec<T> {\n+impl<T: Clone, A: AllocRef + Clone> Clone for Vec<T, A> {\n     #[cfg(not(test))]\n-    fn clone(&self) -> Vec<T> {\n-        <[T]>::to_vec(&**self)\n+    fn clone(&self) -> Self {\n+        let alloc = self.alloc_ref().clone();\n+        <[T]>::to_vec_in(&**self, alloc)\n     }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n     // `slice::to_vec`  function which is only available with cfg(test)\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n-    fn clone(&self) -> Vec<T> {\n-        crate::slice::to_vec(&**self)\n+    fn clone(&self) -> Self {\n+        let alloc = self.alloc_ref().clone();\n+        crate::slice::to_vec(&**self, alloc)\n     }\n \n-    fn clone_from(&mut self, other: &Vec<T>) {\n-        other.as_slice().clone_into(self);\n+    fn clone_from(&mut self, other: &Self) {\n+        // drop anything that will not be overwritten\n+        self.truncate(other.len());\n+\n+        // self.len <= other.len due to the truncate above, so the\n+        // slices here are always in-bounds.\n+        let (init, tail) = other.split_at(self.len());\n+\n+        // reuse the contained values' allocations/resources.\n+        self.clone_from_slice(init);\n+        self.extend_from_slice(tail);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Vec<T> {\n+impl<T: Hash, A: AllocRef> Hash for Vec<T, A> {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)\n@@ -1931,7 +2153,7 @@ impl<T: Hash> Hash for Vec<T> {\n     message = \"vector indices are of type `usize` or ranges of `usize`\",\n     label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n-impl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n+impl<T, I: SliceIndex<[T]>, A: AllocRef> Index<I> for Vec<T, A> {\n     type Output = I::Output;\n \n     #[inline]\n@@ -1945,7 +2167,7 @@ impl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n     message = \"vector indices are of type `usize` or ranges of `usize`\",\n     label = \"vector indices are of type `usize` or ranges of `usize`\"\n )]\n-impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n+impl<T, I: SliceIndex<[T]>, A: AllocRef> IndexMut<I> for Vec<T, A> {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1961,9 +2183,9 @@ impl<T> FromIterator<T> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for Vec<T> {\n+impl<T, A: AllocRef> IntoIterator for Vec<T, A> {\n     type Item = T;\n-    type IntoIter = IntoIter<T>;\n+    type IntoIter = IntoIter<T, A>;\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n     /// the vector (from start to end). The vector cannot be used after calling\n@@ -1979,9 +2201,10 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T, A> {\n         unsafe {\n             let mut me = ManuallyDrop::new(self);\n+            let alloc = ptr::read(me.alloc_ref());\n             let begin = me.as_mut_ptr();\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(begin as *const i8, me.len() as isize) as *const T\n@@ -1993,6 +2216,7 @@ impl<T> IntoIterator for Vec<T> {\n                 buf: NonNull::new_unchecked(begin),\n                 phantom: PhantomData,\n                 cap,\n+                alloc,\n                 ptr: begin,\n                 end,\n             }\n@@ -2001,7 +2225,7 @@ impl<T> IntoIterator for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a Vec<T> {\n+impl<'a, T, A: AllocRef> IntoIterator for &'a Vec<T, A> {\n     type Item = &'a T;\n     type IntoIter = slice::Iter<'a, T>;\n \n@@ -2011,7 +2235,7 @@ impl<'a, T> IntoIterator for &'a Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut Vec<T> {\n+impl<'a, T, A: AllocRef> IntoIterator for &'a mut Vec<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;\n \n@@ -2021,7 +2245,7 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Extend<T> for Vec<T> {\n+impl<T, A: AllocRef> Extend<T> for Vec<T, A> {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n@@ -2303,7 +2527,7 @@ trait SpecExtend<T, I> {\n     fn spec_extend(&mut self, iter: I);\n }\n \n-impl<T, I> SpecExtend<T, I> for Vec<T>\n+impl<T, I, A: AllocRef> SpecExtend<T, I> for Vec<T, A>\n where\n     I: Iterator<Item = T>,\n {\n@@ -2312,7 +2536,7 @@ where\n     }\n }\n \n-impl<T, I> SpecExtend<T, I> for Vec<T>\n+impl<T, I, A: AllocRef> SpecExtend<T, I> for Vec<T, A>\n where\n     I: TrustedLen<Item = T>,\n {\n@@ -2345,7 +2569,7 @@ where\n     }\n }\n \n-impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n+impl<T, A: AllocRef> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n     fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n         unsafe {\n             self.append_elements(iterator.as_slice() as _);\n@@ -2354,7 +2578,7 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n     }\n }\n \n-impl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n+impl<'a, T: 'a, I, A: AllocRef + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n where\n     I: Iterator<Item = &'a T>,\n     T: Clone,\n@@ -2364,7 +2588,7 @@ where\n     }\n }\n \n-impl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\n+impl<'a, T: 'a, A: AllocRef + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n where\n     T: Copy,\n {\n@@ -2374,7 +2598,7 @@ where\n     }\n }\n \n-impl<T> Vec<T> {\n+impl<T, A: AllocRef> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply\n     fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n@@ -2434,7 +2658,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter>\n+    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, A>\n     where\n         R: RangeBounds<usize>,\n         I: IntoIterator<Item = T>,\n@@ -2487,7 +2711,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F, A>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n@@ -2509,7 +2733,7 @@ impl<T> Vec<T> {\n ///\n /// [`copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n+impl<'a, T: Copy + 'a, A: AllocRef + 'a> Extend<&'a T> for Vec<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.spec_extend(iter.into_iter())\n     }\n@@ -2528,9 +2752,9 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n macro_rules! __impl_slice_eq1 {\n     ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n         #[$stability]\n-        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n         where\n-            A: PartialEq<B>,\n+            T: PartialEq<U>,\n             $($ty: $bound)?\n         {\n             #[inline]\n@@ -2541,18 +2765,18 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n-__impl_slice_eq1! { [] Vec<A>, Vec<B>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Vec<A>, &[B], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Vec<A>, &mut [B], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] &[A], Vec<B>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [] &mut [A], Vec<B>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [] Vec<A>, [B], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [] [A], Vec<B>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B> where A: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [A]>, &[B] where A: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [A]>, &mut [B] where A: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [const N: usize] Vec<A>, [B; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: AllocRef] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: AllocRef] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: AllocRef] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: AllocRef, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n \n // NOTE: some less important impls are omitted to reduce code bloat\n // FIXME(Centril): Reconsider this?\n@@ -2566,27 +2790,27 @@ __impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], #[stable(feature = \"rust1\"\n \n /// Implements comparison of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for Vec<T> {\n+impl<T: PartialOrd, A: AllocRef> PartialOrd for Vec<T, A> {\n     #[inline]\n-    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for Vec<T> {}\n+impl<T: Eq, A: AllocRef> Eq for Vec<T, A> {}\n \n /// Implements ordering of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for Vec<T> {\n+impl<T: Ord, A: AllocRef> Ord for Vec<T, A> {\n     #[inline]\n-    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+    fn cmp(&self, other: &Self) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T> Drop for Vec<T> {\n+unsafe impl<#[may_dangle] T, A: AllocRef> Drop for Vec<T, A> {\n     fn drop(&mut self) {\n         unsafe {\n             // use drop for [T]\n@@ -2607,35 +2831,35 @@ impl<T> Default for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n+impl<T: fmt::Debug, A: AllocRef> fmt::Debug for Vec<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> AsRef<Vec<T>> for Vec<T> {\n-    fn as_ref(&self) -> &Vec<T> {\n+impl<T, A: AllocRef> AsRef<Vec<T, A>> for Vec<T, A> {\n+    fn as_ref(&self) -> &Vec<T, A> {\n         self\n     }\n }\n \n #[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\n-impl<T> AsMut<Vec<T>> for Vec<T> {\n-    fn as_mut(&mut self) -> &mut Vec<T> {\n+impl<T, A: AllocRef> AsMut<Vec<T, A>> for Vec<T, A> {\n+    fn as_mut(&mut self) -> &mut Vec<T, A> {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> AsRef<[T]> for Vec<T> {\n+impl<T, A: AllocRef> AsRef<[T]> for Vec<T, A> {\n     fn as_ref(&self) -> &[T] {\n         self\n     }\n }\n \n #[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\n-impl<T> AsMut<[T]> for Vec<T> {\n+impl<T, A: AllocRef> AsMut<[T]> for Vec<T, A> {\n     fn as_mut(&mut self) -> &mut [T] {\n         self\n     }\n@@ -2649,7 +2873,7 @@ impl<T: Clone> From<&[T]> for Vec<T> {\n     }\n     #[cfg(test)]\n     fn from(s: &[T]) -> Vec<T> {\n-        crate::slice::to_vec(s)\n+        crate::slice::to_vec(s, Global)\n     }\n }\n \n@@ -2661,7 +2885,7 @@ impl<T: Clone> From<&mut [T]> for Vec<T> {\n     }\n     #[cfg(test)]\n     fn from(s: &mut [T]) -> Vec<T> {\n-        crate::slice::to_vec(s)\n+        crate::slice::to_vec(s, Global)\n     }\n }\n \n@@ -2690,17 +2914,18 @@ where\n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\n-impl<T> From<Box<[T]>> for Vec<T> {\n-    fn from(s: Box<[T]>) -> Vec<T> {\n-        s.into_vec()\n+impl<T, A: AllocRef> From<Box<[T], A>> for Vec<T, A> {\n+    fn from(s: Box<[T], A>) -> Self {\n+        let len = s.len();\n+        Self { buf: RawVec::from_box(s), len }\n     }\n }\n \n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\n-impl<T> From<Vec<T>> for Box<[T]> {\n-    fn from(v: Vec<T>) -> Box<[T]> {\n+impl<T, A: AllocRef> From<Vec<T, A>> for Box<[T], A> {\n+    fn from(v: Vec<T, A>) -> Self {\n         v.into_boxed_slice()\n     }\n }\n@@ -2713,8 +2938,8 @@ impl From<&str> for Vec<u8> {\n }\n \n #[stable(feature = \"array_try_from_vec\", since = \"1.48.0\")]\n-impl<T, const N: usize> TryFrom<Vec<T>> for [T; N] {\n-    type Error = Vec<T>;\n+impl<T, A: AllocRef, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n+    type Error = Vec<T, A>;\n \n     /// Gets the entire contents of the `Vec<T>` as an array,\n     /// if its size exactly matches that of the requested array.\n@@ -2745,7 +2970,7 @@ impl<T, const N: usize> TryFrom<Vec<T>> for [T; N] {\n     /// assert_eq!(a, b' ');\n     /// assert_eq!(b, b'd');\n     /// ```\n-    fn try_from(mut vec: Vec<T>) -> Result<[T; N], Vec<T>> {\n+    fn try_from(mut vec: Vec<T, A>) -> Result<[T; N], Vec<T, A>> {\n         if vec.len() != N {\n             return Err(vec);\n         }\n@@ -2814,22 +3039,24 @@ where\n /// let iter: std::vec::IntoIter<_> = v.into_iter();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n+pub struct IntoIter<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global>\n+{\n     buf: NonNull<T>,\n     phantom: PhantomData<T>,\n     cap: usize,\n+    alloc: A,\n     ptr: *const T,\n     end: *const T,\n }\n \n #[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+impl<T: fmt::Debug, A: AllocRef> fmt::Debug for IntoIter<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n     }\n }\n \n-impl<T> IntoIter<T> {\n+impl<T, A: AllocRef> IntoIter<T, A> {\n     /// Returns the remaining items of this iterator as a slice.\n     ///\n     /// # Examples\n@@ -2864,6 +3091,13 @@ impl<T> IntoIter<T> {\n         unsafe { &mut *self.as_raw_mut_slice() }\n     }\n \n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn alloc_ref(&self) -> &A {\n+        &self.alloc\n+    }\n+\n     fn as_raw_mut_slice(&mut self) -> *mut [T] {\n         ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n     }\n@@ -2886,19 +3120,19 @@ impl<T> IntoIter<T> {\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n-impl<T> AsRef<[T]> for IntoIter<T> {\n+impl<T, A: AllocRef> AsRef<[T]> for IntoIter<T, A> {\n     fn as_ref(&self) -> &[T] {\n         self.as_slice()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IntoIter<T> {}\n+unsafe impl<T: Send, A: AllocRef + Send> Send for IntoIter<T, A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IntoIter<T> {}\n+unsafe impl<T: Sync, A: AllocRef> Sync for IntoIter<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n+impl<T, A: AllocRef> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -2955,7 +3189,7 @@ impl<T> Iterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n+impl<T, A: AllocRef> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         if self.end == self.ptr {\n@@ -2975,23 +3209,23 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n+impl<T, A: AllocRef> ExactSizeIterator for IntoIter<T, A> {\n     fn is_empty(&self) -> bool {\n         self.ptr == self.end\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n+impl<T, A: AllocRef> FusedIterator for IntoIter<T, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for IntoIter<T> {}\n+unsafe impl<T, A: AllocRef> TrustedLen for IntoIter<T, A> {}\n \n #[doc(hidden)]\n #[unstable(issue = \"none\", feature = \"std_internals\")]\n // T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n // and thus we can't implement drop-handling\n-unsafe impl<T> TrustedRandomAccess for IntoIter<T>\n+unsafe impl<T, A: AllocRef> TrustedRandomAccess for IntoIter<T, A>\n where\n     T: Copy,\n {\n@@ -3001,21 +3235,30 @@ where\n }\n \n #[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n-impl<T: Clone> Clone for IntoIter<T> {\n-    fn clone(&self) -> IntoIter<T> {\n-        self.as_slice().to_owned().into_iter()\n+impl<T: Clone, A: AllocRef + Clone> Clone for IntoIter<T, A> {\n+    #[cfg(not(test))]\n+    fn clone(&self) -> Self {\n+        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n+    }\n+    #[cfg(test)]\n+    fn clone(&self) -> Self {\n+        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n+unsafe impl<#[may_dangle] T, A: AllocRef> Drop for IntoIter<T, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, T>(&'a mut IntoIter<T>);\n+        struct DropGuard<'a, T, A: AllocRef>(&'a mut IntoIter<T, A>);\n \n-        impl<T> Drop for DropGuard<'_, T> {\n+        impl<T, A: AllocRef> Drop for DropGuard<'_, T, A> {\n             fn drop(&mut self) {\n-                // RawVec handles deallocation\n-                let _ = unsafe { RawVec::from_raw_parts(self.0.buf.as_ptr(), self.0.cap) };\n+                unsafe {\n+                    // `IntoIter::alloc` is not used anymore after this\n+                    let alloc = ptr::read(&self.0.alloc);\n+                    // RawVec handles deallocation\n+                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n+                }\n             }\n         }\n \n@@ -3029,11 +3272,11 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T> InPlaceIterable for IntoIter<T> {}\n+unsafe impl<T, A: AllocRef> InPlaceIterable for IntoIter<T, A> {}\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T> SourceIter for IntoIter<T> {\n-    type Source = IntoIter<T>;\n+unsafe impl<T, A: AllocRef> SourceIter for IntoIter<T, A> {\n+    type Source = Self;\n \n     #[inline]\n     unsafe fn as_inner(&mut self) -> &mut Self::Source {\n@@ -3068,24 +3311,28 @@ impl<T> AsIntoIter for IntoIter<T> {\n /// let iter: std::vec::Drain<_> = v.drain(..);\n /// ```\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<'a, T: 'a> {\n+pub struct Drain<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef + 'a = Global,\n+> {\n     /// Index of tail to preserve\n     tail_start: usize,\n     /// Length of tail\n     tail_len: usize,\n     /// Current remaining range to remove\n     iter: slice::Iter<'a, T>,\n-    vec: NonNull<Vec<T>>,\n+    vec: NonNull<Vec<T, A>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+impl<T: fmt::Debug, A: AllocRef> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n     }\n }\n \n-impl<'a, T> Drain<'a, T> {\n+impl<'a, T, A: AllocRef> Drain<'a, T, A> {\n     /// Returns the remaining items of this iterator as a slice.\n     ///\n     /// # Examples\n@@ -3101,22 +3348,29 @@ impl<'a, T> Drain<'a, T> {\n     pub fn as_slice(&self) -> &[T] {\n         self.iter.as_slice()\n     }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn alloc_ref(&self) -> &A {\n+        unsafe { self.vec.as_ref().alloc_ref() }\n+    }\n }\n \n #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-impl<'a, T> AsRef<[T]> for Drain<'a, T> {\n+impl<'a, T, A: AllocRef> AsRef<[T]> for Drain<'a, T, A> {\n     fn as_ref(&self) -> &[T] {\n         self.as_slice()\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n+unsafe impl<T: Sync, A: Sync + AllocRef> Sync for Drain<'_, T, A> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send> Send for Drain<'_, T> {}\n+unsafe impl<T: Send, A: Send + AllocRef> Send for Drain<'_, T, A> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Iterator for Drain<'_, T> {\n+impl<T, A: AllocRef> Iterator for Drain<'_, T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -3130,21 +3384,21 @@ impl<T> Iterator for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> DoubleEndedIterator for Drain<'_, T> {\n+impl<T, A: AllocRef> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Drop for Drain<'_, T> {\n+impl<T, A: AllocRef> Drop for Drain<'_, T, A> {\n     fn drop(&mut self) {\n         /// Continues dropping the remaining elements in the `Drain`, then moves back the\n         /// un-`Drain`ed elements to restore the original `Vec`.\n-        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n+        struct DropGuard<'r, 'a, T, A: AllocRef>(&'r mut Drain<'a, T, A>);\n \n-        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+        impl<'r, 'a, T, A: AllocRef> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n                 // Continue the same loop we have below. If the loop already finished, this does\n                 // nothing.\n@@ -3180,17 +3434,17 @@ impl<T> Drop for Drain<'_, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> ExactSizeIterator for Drain<'_, T> {\n+impl<T, A: AllocRef> ExactSizeIterator for Drain<'_, T, A> {\n     fn is_empty(&self) -> bool {\n         self.iter.is_empty()\n     }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Drain<'_, T> {}\n+unsafe impl<T, A: AllocRef> TrustedLen for Drain<'_, T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Drain<'_, T> {}\n+impl<T, A: AllocRef> FusedIterator for Drain<'_, T, A> {}\n \n /// A splicing iterator for `Vec`.\n ///\n@@ -3206,13 +3460,17 @@ impl<T> FusedIterator for Drain<'_, T> {}\n /// ```\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-pub struct Splice<'a, I: Iterator + 'a> {\n-    drain: Drain<'a, I::Item>,\n+pub struct Splice<\n+    'a,\n+    I: Iterator + 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef + 'a = Global,\n+> {\n+    drain: Drain<'a, I::Item, A>,\n     replace_with: I,\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator> Iterator for Splice<'_, I> {\n+impl<I: Iterator, A: AllocRef> Iterator for Splice<'_, I, A> {\n     type Item = I::Item;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -3225,17 +3483,17 @@ impl<I: Iterator> Iterator for Splice<'_, I> {\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator> DoubleEndedIterator for Splice<'_, I> {\n+impl<I: Iterator, A: AllocRef> DoubleEndedIterator for Splice<'_, I, A> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator> ExactSizeIterator for Splice<'_, I> {}\n+impl<I: Iterator, A: AllocRef> ExactSizeIterator for Splice<'_, I, A> {}\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator> Drop for Splice<'_, I> {\n+impl<I: Iterator, A: AllocRef> Drop for Splice<'_, I, A> {\n     fn drop(&mut self) {\n         self.drain.by_ref().for_each(drop);\n \n@@ -3276,7 +3534,7 @@ impl<I: Iterator> Drop for Splice<'_, I> {\n }\n \n /// Private helper methods for `Splice::drop`\n-impl<T> Drain<'_, T> {\n+impl<T, A: AllocRef> Drain<'_, T, A> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n@@ -3331,11 +3589,15 @@ impl<T> Drain<'_, T> {\n /// ```\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]\n-pub struct DrainFilter<'a, T, F>\n-where\n+pub struct DrainFilter<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+> where\n     F: FnMut(&mut T) -> bool,\n {\n-    vec: &'a mut Vec<T>,\n+    vec: &'a mut Vec<T, A>,\n     /// The index of the item that will be inspected by the next call to `next`.\n     idx: usize,\n     /// The number of items that have been drained (removed) thus far.\n@@ -3352,8 +3614,20 @@ where\n     panic_flag: bool,\n }\n \n+impl<T, F, A: AllocRef> DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn alloc_ref(&self) -> &A {\n+        self.vec.alloc_ref()\n+    }\n+}\n+\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F> Iterator for DrainFilter<'_, T, F>\n+impl<T, F, A: AllocRef> Iterator for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n@@ -3391,19 +3665,19 @@ where\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F> Drop for DrainFilter<'_, T, F>\n+impl<T, F, A: AllocRef> Drop for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F>\n+        struct BackshiftOnDrop<'a, 'b, T, F, A: AllocRef>\n         where\n             F: FnMut(&mut T) -> bool,\n         {\n-            drain: &'b mut DrainFilter<'a, T, F>,\n+            drain: &'b mut DrainFilter<'a, T, F, A>,\n         }\n \n-        impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n+        impl<'a, 'b, T, F, A: AllocRef> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n         where\n             F: FnMut(&mut T) -> bool,\n         {"}, {"sha": "6632488171dad9fbab3218dfb65c62307b2e8f26", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -13,7 +13,7 @@\n // gdb-check:$1 = &[i32](len: 4) = {0, 1, 2, 3}\n \n // gdb-command: print vec\n-// gdb-check:$2 = Vec<u64>(len: 4, cap: [...]) = {4, 5, 6, 7}\n+// gdb-check:$2 = Vec<u64, alloc::alloc::Global>(len: 4, cap: [...]) = {4, 5, 6, 7}\n \n // gdb-command: print str_slice\n // gdb-check:$3 = \"IAMA string slice!\"\n@@ -74,7 +74,7 @@\n // NOTE: While slices have a .natvis entry that works in VS & VS Code, it fails in CDB 10.0.18362.1\n \n // cdb-command: dx vec,d\n-// cdb-check:vec,d [...] : { size=4 } [Type: [...]::Vec<u64>]\n+// cdb-check:vec,d [...] : { size=4 } [Type: [...]::Vec<u64, alloc::alloc::Global>]\n // cdb-check:    [size]           : 4 [Type: [...]]\n // cdb-check:    [capacity]       : [...] [Type: [...]]\n // cdb-check:    [0]              : 4 [Type: unsigned __int64]"}, {"sha": "0ab2fa99f877fa3cf7feeff83fa07200a3cbf05e", "filename": "src/test/rustdoc/inline_cross/impl_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -1,10 +1,11 @@\n // aux-build:impl_trait_aux.rs\n // edition:2018\n+// ignore-tidy-linelength\n \n extern crate impl_trait_aux;\n \n // @has impl_trait/fn.func.html\n-// @has - '//pre[@class=\"rust fn\"]' \"pub fn func<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n+// @has - '//pre[@class=\"rust fn\"]' \"pub fn func<'a>(_x: impl Clone + Into<Vec<u8, Global>> + 'a)\"\n // @!has - '//pre[@class=\"rust fn\"]' 'where'\n pub use impl_trait_aux::func;\n \n@@ -31,7 +32,7 @@ pub use impl_trait_aux::func4;\n pub use impl_trait_aux::async_fn;\n \n // @has impl_trait/struct.Foo.html\n-// @has - '//*[@id=\"method.method\"]//code' \"pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n+// @has - '//*[@id=\"method.method\"]//code' \"pub fn method<'a>(_x: impl Clone + Into<Vec<u8, Global>> + 'a)\"\n // @!has - '//*[@id=\"method.method\"]//code' 'where'\n pub use impl_trait_aux::Foo;\n "}, {"sha": "26c852601941a6637d4cef03eb7c64aad4d18b2e", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -6,7 +6,7 @@ LL |     type Ty = Vec<[u8]>;\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`"}, {"sha": "10d12a09b257972ebf6715af913e281cfe2e6afc", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -17,7 +17,7 @@ LL |     let x: Vec<dyn Trait + Sized> = Vec::new();\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `dyn Trait`"}, {"sha": "0bd9cbf4f4708eb547d620190946a5584a895ad8", "filename": "src/test/ui/const-generics/invalid-constant-in-args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -1,4 +1,6 @@\n+use std::cell::Cell;\n+\n fn main() {\n-    let _: Vec<&str, \"a\"> = Vec::new();\n+    let _: Cell<&str, \"a\"> = Cell::new(\"\");\n     //~^ ERROR wrong number of generic arguments\n }"}, {"sha": "9b8a5d1ae4f20f46e5bc82a2423ff834cbea9812", "filename": "src/test/ui/const-generics/invalid-constant-in-args.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -1,8 +1,8 @@\n error[E0107]: wrong number of generic arguments: expected 1, found 2\n-  --> $DIR/invalid-constant-in-args.rs:2:22\n+  --> $DIR/invalid-constant-in-args.rs:4:23\n    |\n-LL |     let _: Vec<&str, \"a\"> = Vec::new();\n-   |                      ^^^ unexpected const argument\n+LL |     let _: Cell<&str, \"a\"> = Cell::new(\"\");\n+   |                       ^^^ unexpected const argument\n \n error: aborting due to previous error\n "}, {"sha": "d40946ae03f50f42947ad7412036f4a185df0462", "filename": "src/test/ui/issues/issue-20433.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -6,7 +6,7 @@ LL |     fn iceman(c: Vec<[i32]>) {}\n    | \n   ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n    |\n-LL | pub struct Vec<T> {\n+LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global> {\n    |                - required by this bound in `Vec`\n    |\n    = help: the trait `Sized` is not implemented for `[i32]`"}, {"sha": "3aad085f0897295c184ff97f76482fa63e0996c0", "filename": "src/test/ui/type/ascription/issue-34255-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -7,7 +7,7 @@ impl Reactor {\n         input_cells: Vec::new()\n         //~^ ERROR cannot find value `input_cells` in this scope\n         //~| ERROR parenthesized type parameters may only be used with a `Fn` trait\n-        //~| ERROR wrong number of type arguments: expected 1, found 0\n+        //~| ERROR wrong number of type arguments: expected at least 1, found 0\n     }\n }\n "}, {"sha": "402e54d2a95ddf9270bb5149dc26da80c316ff46", "filename": "src/test/ui/type/ascription/issue-34255-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1a13b2bc4fa6370b9501135d97c5fe0bc401894/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr?ref=a1a13b2bc4fa6370b9501135d97c5fe0bc401894", "patch": "@@ -10,11 +10,11 @@ error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n LL |         input_cells: Vec::new()\n    |                           ^^^^^ only `Fn` traits may use parentheses\n \n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of type arguments: expected at least 1, found 0\n   --> $DIR/issue-34255-1.rs:7:22\n    |\n LL |         input_cells: Vec::new()\n-   |                      ^^^^^^^^^^ expected 1 type argument\n+   |                      ^^^^^^^^^^ expected at least 1 type argument\n \n error: aborting due to 3 previous errors\n "}]}