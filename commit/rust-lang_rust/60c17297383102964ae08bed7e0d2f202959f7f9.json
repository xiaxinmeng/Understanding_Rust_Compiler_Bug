{"sha": "60c17297383102964ae08bed7e0d2f202959f7f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYzE3Mjk3MzgzMTAyOTY0YWUwOGJlZDdlMGQyZjIwMjk1OWY3Zjk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-14T00:20:42Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-28T03:16:01Z"}, "message": "Move tests into a submodule", "tree": {"sha": "190504086751060c4a37b0ca1576cce06a445623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/190504086751060c4a37b0ca1576cce06a445623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c17297383102964ae08bed7e0d2f202959f7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c17297383102964ae08bed7e0d2f202959f7f9", "html_url": "https://github.com/rust-lang/rust/commit/60c17297383102964ae08bed7e0d2f202959f7f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c17297383102964ae08bed7e0d2f202959f7f9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74b373426a79af2b21b8d266a881753e338cfd2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b373426a79af2b21b8d266a881753e338cfd2e", "html_url": "https://github.com/rust-lang/rust/commit/74b373426a79af2b21b8d266a881753e338cfd2e"}], "stats": {"total": 931, "additions": 470, "deletions": 461}, "files": [{"sha": "8e98441afa64d9fc475baa77d9707036f8325f24", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 470, "deletions": 461, "changes": 931, "blob_url": "https://github.com/rust-lang/rust/blob/60c17297383102964ae08bed7e0d2f202959f7f9/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c17297383102964ae08bed7e0d2f202959f7f9/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=60c17297383102964ae08bed7e0d2f202959f7f9", "patch": "@@ -2,8 +2,6 @@ use super::*;\n use crate::config::{Config, TargetSelection};\n use std::thread;\n \n-use pretty_assertions::assert_eq;\n-\n fn configure(host: &[&str], target: &[&str]) -> Config {\n     let mut config = Config::default_opts();\n     config.stage = Some(2);\n@@ -36,463 +34,474 @@ fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n     v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n }\n \n-#[test]\n-fn dist_baseline() {\n-    let build = Build::new(configure(&[], &[]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n-    assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    // Make sure rustdoc is only built once.\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-}\n-\n-#[test]\n-fn dist_with_targets() {\n-    let build = Build::new(configure(&[], &[\"B\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_with_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_only_cross_host() {\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let mut build = Build::new(configure(&[\"B\"], &[]));\n-    build.config.docs = false;\n-    build.config.extended = true;\n-    build.hosts = vec![b];\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn dist_with_targets_and_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true; // as-if --target=C was passed\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-}\n-\n-#[test]\n-fn dist_with_same_targets_and_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Assemble>()),\n-        &[\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n-            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn build_default() {\n-    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Assemble>()),\n-        &[\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n-            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn test_with_no_doc_stage0() {\n-    let mut config = configure(&[], &[]);\n-    config.stage = Some(0);\n-    config.cmd = Subcommand::Test {\n-        paths: vec![\"library/std\".into()],\n-        test_args: vec![],\n-        rustc_args: vec![],\n-        fail_fast: true,\n-        doc_tests: DocTests::No,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-\n-    let host = TargetSelection::from_user(\"A\");\n-\n-    builder\n-        .run_step_descriptions(&[StepDescription::from::<test::Crate>()], &[\"library/std\".into()]);\n-\n-    // Ensure we don't build any compiler artifacts.\n-    assert!(!builder.cache.contains::<compile::Rustc>());\n-    assert_eq!(\n-        first(builder.cache.all::<test::Crate>()),\n-        &[test::Crate {\n-            compiler: Compiler { host, stage: 0 },\n-            target: host,\n-            mode: Mode::Std,\n-            test_kind: test::TestKind::Test,\n-            krate: INTERNER.intern_str(\"std\"),\n-        },]\n-    );\n-}\n-\n-#[test]\n-fn test_exclude() {\n-    let mut config = configure(&[], &[]);\n-    config.exclude = vec![\"src/tools/tidy\".into()];\n-    config.cmd = Subcommand::Test {\n-        paths: Vec::new(),\n-        test_args: Vec::new(),\n-        rustc_args: Vec::new(),\n-        fail_fast: true,\n-        doc_tests: DocTests::No,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-\n-    let build = Build::new(config);\n-    let builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-    // Ensure we have really excluded tidy\n-    assert!(!builder.cache.contains::<test::Tidy>());\n-\n-    // Ensure other tests are not affected.\n-    assert!(builder.cache.contains::<test::RustdocUi>());\n-}\n-\n-#[test]\n-fn doc_ci() {\n-    let mut config = configure(&[], &[]);\n-    config.compiler_docs = true;\n-    config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n-    // rustdoc tool.\n-    assert_eq!(\n-        first(builder.cache.all::<doc::ErrorIndex>()),\n-        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<tool::ErrorIndex>()),\n-        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n-    );\n-    // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n-    // stage minus 1 if --stage is not 0. Very confusing!\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-}\n-\n-//FIXME(mark-i-m): reinstate this test when things are fixed...\n-//#[test]\n-#[allow(dead_code)]\n-fn test_docs() {\n-    // Behavior of `x.py test` doing various documentation tests.\n-    let mut config = configure(&[], &[]);\n-    config.cmd = Subcommand::Test {\n-        paths: vec![],\n-        test_args: vec![],\n-        rustc_args: vec![],\n-        fail_fast: true,\n-        doc_tests: DocTests::Yes,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n-    // rustdoc tool.\n-    assert_eq!(\n-        first(builder.cache.all::<doc::ErrorIndex>()),\n-        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<tool::ErrorIndex>()),\n-        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n-    );\n-    // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n-    // (and other things), and once from stage0 for std crates. Ideally it\n-    // would only be built once. If someone wants to fix this, it might be\n-    // worth investigating if it would be possible to test std from stage1.\n-    // Note that the stages here are +1 than what they actually are because\n-    // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n-    // not 0.\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[\n-            tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n-            tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n-        ]\n-    );\n+mod dist {\n+    use super::{configure, first};\n+    use crate::builder::*;\n+    use pretty_assertions::assert_eq;\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        // Make sure rustdoc is only built once.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_only_cross_host() {\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let mut build = Build::new(configure(&[\"B\"], &[]));\n+        build.config.docs = false;\n+        build.config.extended = true;\n+        build.hosts = vec![b];\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.skip_only_host_steps = true; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+                compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(\n+            &Builder::get_step_descriptions(Kind::Build),\n+            &[\"src/rustc\".into(), \"src/libstd\".into()],\n+        );\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.skip_only_host_steps = true;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+                compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_with_no_doc_stage0() {\n+        let mut config = configure(&[], &[]);\n+        config.stage = Some(0);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![\"library/std\".into()],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+\n+        let host = TargetSelection::from_user(\"A\");\n+\n+        builder.run_step_descriptions(\n+            &[StepDescription::from::<test::Crate>()],\n+            &[\"library/std\".into()],\n+        );\n+\n+        // Ensure we don't build any compiler artifacts.\n+        assert!(!builder.cache.contains::<compile::Rustc>());\n+        assert_eq!(\n+            first(builder.cache.all::<test::Crate>()),\n+            &[test::Crate {\n+                compiler: Compiler { host, stage: 0 },\n+                target: host,\n+                mode: Mode::Std,\n+                test_kind: test::TestKind::Test,\n+                krate: INTERNER.intern_str(\"std\"),\n+            },]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_exclude() {\n+        let mut config = configure(&[], &[]);\n+        config.exclude = vec![\"src/tools/tidy\".into()];\n+        config.cmd = Subcommand::Test {\n+            paths: Vec::new(),\n+            test_args: Vec::new(),\n+            rustc_args: Vec::new(),\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+\n+        let build = Build::new(config);\n+        let builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+        // Ensure we have really excluded tidy\n+        assert!(!builder.cache.contains::<test::Tidy>());\n+\n+        // Ensure other tests are not affected.\n+        assert!(builder.cache.contains::<test::RustdocUi>());\n+    }\n+\n+    #[test]\n+    fn doc_ci() {\n+        let mut config = configure(&[], &[]);\n+        config.compiler_docs = true;\n+        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+        // rustdoc tool.\n+        assert_eq!(\n+            first(builder.cache.all::<doc::ErrorIndex>()),\n+            &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<tool::ErrorIndex>()),\n+            &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+        );\n+        // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n+        // stage minus 1 if --stage is not 0. Very confusing!\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+    }\n+\n+    //FIXME(mark-i-m): reinstate this test when things are fixed...\n+    //#[test]\n+    #[allow(dead_code)]\n+    fn test_docs() {\n+        // Behavior of `x.py test` doing various documentation tests.\n+        let mut config = configure(&[], &[]);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::Yes,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+        // rustdoc tool.\n+        assert_eq!(\n+            first(builder.cache.all::<doc::ErrorIndex>()),\n+            &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<tool::ErrorIndex>()),\n+            &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+        );\n+        // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n+        // (and other things), and once from stage0 for std crates. Ideally it\n+        // would only be built once. If someone wants to fix this, it might be\n+        // worth investigating if it would be possible to test std from stage1.\n+        // Note that the stages here are +1 than what they actually are because\n+        // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n+        // not 0.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[\n+                tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n+                tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n+            ]\n+        );\n+    }\n }"}]}