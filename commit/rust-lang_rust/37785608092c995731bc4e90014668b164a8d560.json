{"sha": "37785608092c995731bc4e90014668b164a8d560", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Nzg1NjA4MDkyYzk5NTczMWJjNGU5MDAxNDY2OGIxNjRhOGQ1NjA=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-03-05T21:20:59Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-03-05T21:20:59Z"}, "message": "Refactor fn robin_hood", "tree": {"sha": "d727267cf460cc2ad40c01e6eefa34779b245bf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d727267cf460cc2ad40c01e6eefa34779b245bf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37785608092c995731bc4e90014668b164a8d560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37785608092c995731bc4e90014668b164a8d560", "html_url": "https://github.com/rust-lang/rust/commit/37785608092c995731bc4e90014668b164a8d560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37785608092c995731bc4e90014668b164a8d560/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8b8c3ae6b78829d576c70fb056f988a3a37b27c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b8c3ae6b78829d576c70fb056f988a3a37b27c", "html_url": "https://github.com/rust-lang/rust/commit/f8b8c3ae6b78829d576c70fb056f988a3a37b27c"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "c83c432fc95080883ecc7625c181da5ae1e3e3e3", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37785608092c995731bc4e90014668b164a8d560/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37785608092c995731bc4e90014668b164a8d560/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=37785608092c995731bc4e90014668b164a8d560", "patch": "@@ -421,39 +421,41 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n /// to recalculate it.\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n-fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n+fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                         mut ib: usize,\n                         mut hash: SafeHash,\n-                        mut k: K,\n-                        mut v: V)\n+                        mut key: K,\n+                        mut val: V)\n                         -> &'a mut V {\n     let starting_index = bucket.index();\n     let size = {\n         let table = bucket.table(); // FIXME \"lifetime too short\".\n         table.size()\n     };\n+    // Save the *starting point*.\n+    let mut bucket = bucket.stash();\n     // There can be at most `size - dib` buckets to displace, because\n     // in the worst case, there are `size` elements and we already are\n-    // `distance` buckets away from the initial one.\n+    // `displacement` buckets away from the initial one.\n     let idx_end = starting_index + size - bucket.displacement();\n \n     loop {\n-        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n+        let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n+        hash = old_hash;\n+        key = old_key;\n+        val = old_val;\n+\n         loop {\n             let probe = bucket.next();\n             assert!(probe.index() != idx_end);\n \n             let full_bucket = match probe.peek() {\n                 Empty(bucket) => {\n                     // Found a hole!\n-                    let b = bucket.put(old_hash, old_key, old_val);\n+                    let bucket = bucket.put(hash, key, val);\n                     // Now that it's stolen, just read the value's pointer\n-                    // right out of the table!\n-                    return Bucket::at_index(b.into_table(), starting_index)\n-                               .peek()\n-                               .expect_full()\n-                               .into_mut_refs()\n-                               .1;\n+                    // right out of the table! Go back to the *starting point*.\n+                    return bucket.into_table().into_mut_refs().1;\n                 },\n                 Full(bucket) => bucket\n             };\n@@ -465,9 +467,6 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n             // Robin hood! Steal the spot.\n             if ib < probe_ib {\n                 ib = probe_ib;\n-                hash = old_hash;\n-                k = old_key;\n-                v = old_val;\n                 break;\n             }\n         }"}, {"sha": "e3acbc96fdad6f67ab9b9951d529286763887c84", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/37785608092c995731bc4e90014668b164a8d560/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37785608092c995731bc4e90014668b164a8d560/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=37785608092c995731bc4e90014668b164a8d560", "patch": "@@ -220,6 +220,28 @@ impl<K, V, M> Bucket<K, V, M> {\n     }\n }\n \n+impl<K, V, M> Deref for FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n+    type Target = RawTable<K, V>;\n+    fn deref(&self) -> &RawTable<K, V> {\n+        &self.table\n+    }\n+}\n+\n+impl<K, V, M> DerefMut for FullBucket<K, V, M> where M: DerefMut<Target=RawTable<K, V>> {\n+    fn deref_mut(&mut self) -> &mut RawTable<K, V> {\n+        &mut self.table\n+    }\n+}\n+\n+\n+/// `Put` is implemented for types which provide access to a table and cannot be invalidated\n+///  by filling a bucket. A similar implementation for `Take` is possible.\n+pub trait Put {}\n+impl<K, V> Put for RawTable<K, V> {}\n+impl<'t, K, V> Put for &'t mut RawTable<K, V> {}\n+impl<K, V, M: Put> Put for Bucket<K, V, M> {}\n+impl<K, V, M: Put> Put for FullBucket<K, V, M> {}\n+\n impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n@@ -320,7 +342,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> EmptyBucket<K, V, M> {\n+impl<K, V, M> EmptyBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut + Put {\n     /// Puts given key and value pair, along with the key's hash,\n     /// into this bucket in the hashtable. Note how `self` is 'moved' into\n     /// this function, because this slot will no longer be empty when\n@@ -359,6 +381,16 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n         }\n     }\n \n+    /// Duplicates the current position. This can be useful for operations\n+    /// on two or more buckets.\n+    pub fn stash(self) -> FullBucket<K, V, Self> {\n+        FullBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self,\n+        }\n+    }\n+\n     /// Get the distance between this bucket and the 'ideal' location\n     /// as determined by the key's hash stored in it.\n     ///\n@@ -389,12 +421,14 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n+// We don't need a `Take` trait currently. This is why a mutable reference\n+// to the table is required.\n+impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     /// Removes this bucket's key and value from the hashtable.\n     ///\n     /// This works similarly to `put`, building an `EmptyBucket` out of the\n     /// taken bucket.\n-    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) {\n+    pub fn take(mut self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) {\n         self.table.size -= 1;\n \n         unsafe {\n@@ -410,7 +444,9 @@ impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n             )\n         }\n     }\n+}\n \n+impl<K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n@@ -455,16 +491,6 @@ impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + DerefMut + 't> FullBucket<K, V,\n     }\n }\n \n-impl<K, V, M> BucketState<K, V, M> {\n-    // For convenience.\n-    pub fn expect_full(self) -> FullBucket<K, V, M> {\n-        match self {\n-            Full(full) => full,\n-            Empty(..) => panic!(\"Expected full bucket\")\n-        }\n-    }\n-}\n-\n impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     #[inline]\n     pub fn full(&self) -> &FullBucket<K, V, M> {"}]}