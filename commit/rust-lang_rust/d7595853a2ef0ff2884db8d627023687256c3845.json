{"sha": "d7595853a2ef0ff2884db8d627023687256c3845", "node_id": "C_kwDOAAsO6NoAKGQ3NTk1ODUzYTJlZjBmZjI4ODRkYjhkNjI3MDIzNjg3MjU2YzM4NDU", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-11-18T21:35:42Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-07T20:28:12Z"}, "message": "Add `trait_item_def_id` to `AssocItem`\n\nThis allows avoiding some lookups by name", "tree": {"sha": "460f11bb7b22616fd8763be464df256fb6f44ae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/460f11bb7b22616fd8763be464df256fb6f44ae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7595853a2ef0ff2884db8d627023687256c3845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7595853a2ef0ff2884db8d627023687256c3845", "html_url": "https://github.com/rust-lang/rust/commit/d7595853a2ef0ff2884db8d627023687256c3845", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7595853a2ef0ff2884db8d627023687256c3845/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b1ab91d6604cf3277ef562eabd04f107015de58", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1ab91d6604cf3277ef562eabd04f107015de58", "html_url": "https://github.com/rust-lang/rust/commit/0b1ab91d6604cf3277ef562eabd04f107015de58"}], "stats": {"total": 401, "additions": 197, "deletions": 204}, "files": [{"sha": "5c2752795793bb74c58e76e5bddb60985cbfd208", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -1008,6 +1008,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.get_impl_data(id).constness\n     }\n \n+    fn get_trait_item_def_id(&self, id: DefIndex) -> Option<DefId> {\n+        self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n+    }\n+\n     fn get_coerce_unsized_info(&self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n@@ -1289,6 +1293,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n+            trait_item_def_id: self.get_trait_item_def_id(id),\n             container: container.with_def_id(parent),\n             fn_has_self_parameter: has_self,\n         }"}, {"sha": "11a986f0a7c81693ebbd78229bca806bf1fe1bf9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -1294,6 +1294,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_item_type(def_id);\n+        if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n+            record!(self.tables.trait_item_def_id[def_id] <- trait_item_def_id);\n+        }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }"}, {"sha": "fa44cbc2d55e56cb08771b85cfea7dae4c6e4e1b", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -302,6 +302,7 @@ define_tables! {\n     ty: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n     fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n     impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n+    trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n     variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n     generics: Table<DefIndex, Lazy<ty::Generics>>,"}, {"sha": "5af4eef40d4366481088f949b588cda45004e859", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -40,6 +40,7 @@ impl AssocItemContainer {\n     }\n }\n \n+/// Information about an associated item\n #[derive(Copy, Clone, Debug, PartialEq, HashStable, Eq, Hash)]\n pub struct AssocItem {\n     pub def_id: DefId,\n@@ -50,6 +51,10 @@ pub struct AssocItem {\n     pub defaultness: hir::Defaultness,\n     pub container: AssocItemContainer,\n \n+    /// If this is an item in an impl of a trait then this is the `DefId` of\n+    /// the associated item on the trait that this implements.\n+    pub trait_item_def_id: Option<DefId>,\n+\n     /// Whether this is a method with an explicit self\n     /// as its first parameter, allowing method calls.\n     pub fn_has_self_parameter: bool,"}, {"sha": "c136411df2712f970a9b55396e5cdefbfdd71b7a", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -794,19 +794,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     }\n                 }\n \n-                if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n-                    for impl_item_ref in items {\n-                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                        let trait_item_def_id = self\n-                            .tcx\n-                            .associated_items(trait_did)\n-                            .filter_by_name_unhygienic(impl_item.ident.name)\n-                            .next()\n-                            .map(|item| item.def_id);\n-                        if let Some(def_id) = trait_item_def_id {\n-                            // Pass `None` to skip deprecation warnings.\n-                            self.tcx.check_stability(def_id, None, impl_item.span, None);\n-                        }\n+                for impl_item_ref in items {\n+                    let impl_item = self.tcx.associated_item(impl_item_ref.id.def_id);\n+\n+                    if let Some(def_id) = impl_item.trait_item_def_id {\n+                        // Pass `None` to skip deprecation warnings.\n+                        self.tcx.check_stability(def_id, None, impl_item_ref.span, None);\n                     }\n                 }\n             }"}, {"sha": "a83f02308145e57a704b599d001b1d24706d1fee", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -710,13 +710,11 @@ impl<'tcx> SaveContext<'tcx> {\n             }\n             Res::Def(HirDefKind::AssocFn, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n-                    let ti = self.tcx.associated_item(decl_id);\n-\n-                    self.tcx\n-                        .associated_items(ti.container.id())\n-                        .filter_by_name_unhygienic(ti.ident.name)\n-                        .find(|item| item.defaultness.has_value())\n-                        .map(|item| item.def_id)\n+                    if self.tcx.associated_item(decl_id).defaultness.has_value() {\n+                        Some(decl_id)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n                     None\n                 };"}, {"sha": "3f51442277f5940f16c493959088ab8ec224587f", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -436,23 +436,13 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let (impl_id, trait_id) = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => (def_id, def_id),\n-            AssocItemContainer::ImplContainer(def_id) => {\n-                (def_id, self.interner.tcx.impl_trait_ref(def_id).unwrap().def_id)\n-            }\n-        };\n+        let impl_id = assoc_item.container.id();\n         match assoc_item.kind {\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n \n-        let trait_item = self\n-            .interner\n-            .tcx\n-            .associated_items(trait_id)\n-            .find_by_name_and_kind(self.interner.tcx, assoc_item.ident, assoc_item.kind, trait_id)\n-            .unwrap();\n+        let trait_item_id = assoc_item.trait_item_def_id.expect(\"assoc_ty with no trait version\");\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(self.interner, bound_vars);\n         let ty = self\n@@ -464,7 +454,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n-            associated_ty_id: chalk_ir::AssocTypeId(trait_item.def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(trait_item_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n                 chalk_solve::rust_ir::AssociatedTyValueBound { ty },"}, {"sha": "49336abf3c4aaa5ac50447e34d75e91c84e1e15b", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -1,8 +1,11 @@\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits;\n \n@@ -89,6 +92,7 @@ fn associated_item_from_trait_item_ref(\n         vis: tcx.visibility(def_id),\n         defaultness: trait_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n+        trait_item_def_id: Some(def_id.to_def_id()),\n         container: ty::TraitContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n@@ -106,17 +110,119 @@ fn associated_item_from_impl_item_ref(\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n     };\n \n+    let trait_item_def_id = impl_item_base_id(tcx, parent_def_id, impl_item_ref);\n+\n     ty::AssocItem {\n         ident: impl_item_ref.ident,\n         kind,\n         vis: tcx.visibility(def_id),\n         defaultness: impl_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n+        trait_item_def_id,\n         container: ty::ImplContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n \n+fn impl_item_base_id<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    parent_def_id: LocalDefId,\n+    impl_item: &hir::ImplItemRef,\n+) -> Option<DefId> {\n+    let impl_trait_ref = tcx.impl_trait_ref(parent_def_id)?;\n+\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() {\n+        return None;\n+    }\n+\n+    // Locate trait items\n+    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n+\n+    // Match item against trait\n+    let mut items = associated_items.filter_by_name(tcx, impl_item.ident, impl_trait_ref.def_id);\n+\n+    let mut trait_item = items.next()?;\n+\n+    let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n+        (ty::AssocKind::Const, hir::AssocItemKind::Const) => true,\n+        (ty::AssocKind::Fn, hir::AssocItemKind::Fn { .. }) => true,\n+        (ty::AssocKind::Type, hir::AssocItemKind::Type) => true,\n+        _ => false,\n+    };\n+\n+    // If we don't have a compatible item, we'll use the first one whose name matches\n+    // to report an error.\n+    let mut compatible_kind = is_compatible(&trait_item);\n+\n+    if !compatible_kind {\n+        if let Some(ty_trait_item) = items.find(is_compatible) {\n+            compatible_kind = true;\n+            trait_item = ty_trait_item;\n+        }\n+    }\n+\n+    if compatible_kind {\n+        Some(trait_item.def_id)\n+    } else {\n+        report_mismatch_error(tcx, trait_item.def_id, impl_trait_ref, impl_item);\n+        None\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItemRef,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::AssocItemKind::Const => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Fn { .. } => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::AssocItemKind::Type => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n+    }\n+    err.emit();\n+}\n+\n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let parent_id = tcx.hir().get_parent_item(id);"}, {"sha": "6f09dfd56ddf0126645b2bade467e1b63996be7e", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 54, "deletions": 153, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -841,14 +841,8 @@ pub(super) fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItem<'_>,\n+    impl_item: &hir::ImplItemRef,\n ) {\n-    let kind = match impl_item.kind {\n-        hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n-        hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n-        hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n-    };\n-\n     let ancestors = match trait_def.ancestors(tcx, impl_id) {\n         Ok(ancestors) => ancestors,\n         Err(_) => return,\n@@ -857,7 +851,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n         if parent.is_from_trait() {\n             None\n         } else {\n-            Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+            Some((parent, parent.item(tcx, trait_item.def_id)))\n         }\n     });\n \n@@ -894,7 +888,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     }\n }\n \n-pub(super) fn check_impl_items_against_trait<'tcx>(\n+fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     full_impl_span: Span,\n     impl_id: LocalDefId,\n@@ -926,174 +920,81 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n         }\n     }\n \n-    // Locate trait definition and items\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n-    let impl_items = impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n-    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n-\n-    // Check existing impl methods to see if they are both present in trait\n-    // and compatible with trait signature\n-    for impl_item in impl_items {\n-        let ty_impl_item = tcx.associated_item(impl_item.def_id);\n-\n-        let mut items =\n-            associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n-\n-        let (compatible_kind, ty_trait_item) = if let Some(ty_trait_item) = items.next() {\n-            let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n-                (ty::AssocKind::Const, hir::ImplItemKind::Const(..)) => true,\n-                (ty::AssocKind::Fn, hir::ImplItemKind::Fn(..)) => true,\n-                (ty::AssocKind::Type, hir::ImplItemKind::TyAlias(..)) => true,\n-                _ => false,\n-            };\n-\n-            // If we don't have a compatible item, we'll use the first one whose name matches\n-            // to report an error.\n-            let mut compatible_kind = is_compatible(&ty_trait_item);\n-            let mut trait_item = ty_trait_item;\n-\n-            if !compatible_kind {\n-                if let Some(ty_trait_item) = items.find(is_compatible) {\n-                    compatible_kind = true;\n-                    trait_item = ty_trait_item;\n-                }\n-            }\n \n-            (compatible_kind, trait_item)\n+    for impl_item in impl_item_refs {\n+        let ty_impl_item = tcx.associated_item(impl_item.id.def_id);\n+        let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n+            tcx.associated_item(trait_item_id)\n         } else {\n+            // Checked in `associated_item`.\n+            tcx.sess.delay_span_bug(impl_item.span, \"missing associated item in trait\");\n             continue;\n         };\n-\n-        if compatible_kind {\n-            match impl_item.kind {\n-                hir::ImplItemKind::Const(..) => {\n-                    // Find associated const definition.\n-                    compare_const_impl(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_item.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                    );\n-                }\n-                hir::ImplItemKind::Fn(..) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    compare_impl_method(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_item.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                        opt_trait_span,\n-                    );\n-                }\n-                hir::ImplItemKind::TyAlias(impl_ty) => {\n-                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    compare_ty_impl(\n-                        tcx,\n-                        &ty_impl_item,\n-                        impl_ty.span,\n-                        &ty_trait_item,\n-                        impl_trait_ref,\n-                        opt_trait_span,\n-                    );\n-                }\n+        match impl_item.kind {\n+            hir::AssocItemKind::Const => {\n+                // Find associated const definition.\n+                compare_const_impl(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_item.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                );\n+            }\n+            hir::AssocItemKind::Fn { .. } => {\n+                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                compare_impl_method(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_item.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                    opt_trait_span,\n+                );\n+            }\n+            hir::AssocItemKind::Type => {\n+                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                compare_ty_impl(\n+                    tcx,\n+                    &ty_impl_item,\n+                    impl_item.span,\n+                    &ty_trait_item,\n+                    impl_trait_ref,\n+                    opt_trait_span,\n+                );\n             }\n-\n-            check_specialization_validity(\n-                tcx,\n-                trait_def,\n-                &ty_trait_item,\n-                impl_id.to_def_id(),\n-                impl_item,\n-            );\n-        } else {\n-            report_mismatch_error(\n-                tcx,\n-                ty_trait_item.def_id,\n-                impl_trait_ref,\n-                impl_item,\n-                &ty_impl_item,\n-            );\n         }\n+\n+        check_specialization_validity(\n+            tcx,\n+            trait_def,\n+            &ty_trait_item,\n+            impl_id.to_def_id(),\n+            impl_item,\n+        );\n     }\n \n     if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n-        let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-\n         // Check for missing items from trait\n         let mut missing_items = Vec::new();\n-        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n+        for &trait_item_id in tcx.associated_item_def_ids(impl_trait_ref.def_id) {\n             let is_implemented = ancestors\n-                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-                .map(|node_item| !node_item.defining_node.is_from_trait())\n-                .unwrap_or(false);\n+                .leaf_def(tcx, trait_item_id)\n+                .map_or(false, |node_item| node_item.item.defaultness.has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n-                if !trait_item.defaultness.has_value() {\n-                    missing_items.push(*trait_item);\n-                }\n+                missing_items.push(tcx.associated_item(trait_item_id));\n             }\n         }\n \n         if !missing_items.is_empty() {\n+            let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n         }\n     }\n }\n \n-#[inline(never)]\n-#[cold]\n-fn report_mismatch_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item_def_id: DefId,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item: &hir::ImplItem<'_>,\n-    ty_impl_item: &ty::AssocItem,\n-) {\n-    let mut err = match impl_item.kind {\n-        hir::ImplItemKind::Const(..) => {\n-            // Find associated const definition.\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0323,\n-                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::ImplItemKind::Fn(..) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0324,\n-                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::ImplItemKind::TyAlias(_) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0325,\n-                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n-                ty_impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-    };\n-\n-    err.span_label(impl_item.span, \"does not match trait\");\n-    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n-        err.span_label(trait_span, \"item in trait\");\n-    }\n-    err.emit();\n-}\n-\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded."}, {"sha": "d576154ff9073b1952fca17ebcd53108c9104d9a", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -566,7 +566,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n \n fn report_forbidden_specialization(\n     tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItem<'_>,\n+    impl_item: &hir::ImplItemRef,\n     parent_impl: DefId,\n ) {\n     let mut err = struct_span_err!(\n@@ -598,7 +598,7 @@ fn report_forbidden_specialization(\n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n     impl_span: Span,\n-    missing_items: &[ty::AssocItem],\n+    missing_items: &[&ty::AssocItem],\n     full_impl_span: Span,\n ) {\n     let missing_items_msg = missing_items"}, {"sha": "d4d4baa3f71da9c0ee1527eccf3df983451bace6", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7595853a2ef0ff2884db8d627023687256c3845/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d7595853a2ef0ff2884db8d627023687256c3845", "patch": "@@ -3150,21 +3150,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(impl_item) = tcx.opt_associated_item(def_id) {\n-        if let ty::AssocItemContainer::ImplContainer(impl_def_id) = impl_item.container {\n-            if let Some(trait_def_id) = tcx.trait_id_of_impl(impl_def_id) {\n-                if let Some(trait_item) = tcx\n-                    .associated_items(trait_def_id)\n-                    .filter_by_name_unhygienic(impl_item.ident.name)\n-                    .find(move |trait_item| {\n-                        trait_item.kind == ty::AssocKind::Fn\n-                            && tcx.hygienic_eq(impl_item.ident, trait_item.ident, trait_def_id)\n-                    })\n-                {\n-                    return tcx\n-                        .codegen_fn_attrs(trait_item.def_id)\n-                        .flags\n-                        .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-                }\n+        if let ty::AssocItemContainer::ImplContainer(_) = impl_item.container {\n+            if let Some(trait_item) = impl_item.trait_item_def_id {\n+                return tcx\n+                    .codegen_fn_attrs(trait_item)\n+                    .flags\n+                    .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n             }\n         }\n     }"}]}