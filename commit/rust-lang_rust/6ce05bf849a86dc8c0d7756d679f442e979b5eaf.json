{"sha": "6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZTA1YmY4NDlhODZkYzhjMGQ3NzU2ZDY3OWY0NDJlOTc5YjVlYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-20T20:21:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-20T20:21:33Z"}, "message": "Auto merge of #5332 - DevinR528:if-let-else-mutex, r=flip1995\n\nIf let else mutex\n\nchangelog: Adds lint to catch incorrect use of `Mutex::lock` in `if let` expressions with lock calls in any of the blocks.\n\ncloses: #5219", "tree": {"sha": "03755668f90c64ecacd1c8d033abb88076a086af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03755668f90c64ecacd1c8d033abb88076a086af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "html_url": "https://github.com/rust-lang/rust/commit/6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1336558818f763295309a6b0466f982f773cd6f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1336558818f763295309a6b0466f982f773cd6f5", "html_url": "https://github.com/rust-lang/rust/commit/1336558818f763295309a6b0466f982f773cd6f5"}, {"sha": "3fbe32144010a20d048c9ae8e5e8d874d876f9ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbe32144010a20d048c9ae8e5e8d874d876f9ec", "html_url": "https://github.com/rust-lang/rust/commit/3fbe32144010a20d048c9ae8e5e8d874d876f9ec"}], "stats": {"total": 250, "additions": 248, "deletions": 2}, "files": [{"sha": "d244f8aa167b41b611e26cc678b6a3b6ec3c466e", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -1286,6 +1286,7 @@ Released 2018-09-13\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n [`identity_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_conversion\n [`identity_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n+[`if_let_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_mutex\n [`if_let_redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_redundant_pattern_matching\n [`if_let_some_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_some_result\n [`if_not_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_not_else"}, {"sha": "9d5939db8d5d1d72a2668b89d294d0607e93cd44", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 350 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 362 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "b2ece37fdb0a9c126f8f4617c4eca2dd1c150fbc", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -0,0 +1,160 @@\n+use crate::utils::{match_type, paths, span_lint_and_help, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `Mutex::lock` calls in `if let` expression\n+    /// with lock calls in any of the else blocks.\n+    ///\n+    /// **Why is this bad?** The Mutex lock remains held for the whole\n+    /// `if let ... else` block and deadlocks.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// if let Ok(thing) = mutex.lock() {\n+    ///     do_thing();\n+    /// } else {\n+    ///     mutex.lock();\n+    /// }\n+    /// ```\n+    /// Should be written\n+    /// ```rust,ignore\n+    /// let locked = mutex.lock();\n+    /// if let Ok(thing) = locked {\n+    ///     do_thing(thing);\n+    /// } else {\n+    ///     use_locked(locked);\n+    /// }\n+    /// ```\n+    pub IF_LET_MUTEX,\n+    correctness,\n+    \"locking a `Mutex` in an `if let` block can cause deadlocks\"\n+}\n+\n+declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n+\n+impl LateLintPass<'_, '_> for IfLetMutex {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, ex: &'_ Expr<'_>) {\n+        let mut arm_visit = ArmVisitor {\n+            mutex_lock_called: false,\n+            found_mutex: None,\n+            cx,\n+        };\n+        let mut op_visit = OppVisitor {\n+            mutex_lock_called: false,\n+            found_mutex: None,\n+            cx,\n+        };\n+        if let ExprKind::Match(\n+            ref op,\n+            ref arms,\n+            MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            },\n+        ) = ex.kind\n+        {\n+            op_visit.visit_expr(op);\n+            if op_visit.mutex_lock_called {\n+                for arm in *arms {\n+                    arm_visit.visit_arm(arm);\n+                }\n+\n+                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n+                    span_lint_and_help(\n+                        cx,\n+                        IF_LET_MUTEX,\n+                        ex.span,\n+                        \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n+                        None,\n+                        \"move the lock call outside of the `if let ...` expression\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks if `Mutex::lock` is called in the `if let _ = expr.\n+pub struct OppVisitor<'tcx, 'l> {\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n+}\n+\n+impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n+            then {\n+                self.found_mutex = Some(mutex);\n+                self.mutex_lock_called = true;\n+                return;\n+            }\n+        }\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Checks if `Mutex::lock` is called in any of the branches.\n+pub struct ArmVisitor<'tcx, 'l> {\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n+}\n+\n+impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n+            then {\n+                self.found_mutex = Some(mutex);\n+                self.mutex_lock_called = true;\n+                return;\n+            }\n+        }\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n+    fn same_mutex(&self, cx: &LateContext<'_, '_>, op_mutex: &Expr<'_>) -> bool {\n+        if let Some(arm_mutex) = self.found_mutex {\n+            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn is_mutex_lock_call<'a>(cx: &LateContext<'a, '_>, expr: &'a Expr<'_>) -> Option<&'a Expr<'a>> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(path, _span, args) = &expr.kind;\n+        if path.ident.to_string() == \"lock\";\n+        let ty = cx.tables.expr_ty(&args[0]);\n+        if match_type(cx, ty, &paths::MUTEX);\n+        then {\n+            Some(&args[0])\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "f3f73835e848dcaecf75795d7db257374b25b408", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -222,6 +222,7 @@ mod future_not_send;\n mod get_last_with_len;\n mod identity_conversion;\n mod identity_op;\n+mod if_let_mutex;\n mod if_let_some_result;\n mod if_not_else;\n mod implicit_return;\n@@ -573,6 +574,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &get_last_with_len::GET_LAST_WITH_LEN,\n         &identity_conversion::IDENTITY_CONVERSION,\n         &identity_op::IDENTITY_OP,\n+        &if_let_mutex::IF_LET_MUTEX,\n         &if_let_some_result::IF_LET_SOME_RESULT,\n         &if_not_else::IF_NOT_ELSE,\n         &implicit_return::IMPLICIT_RETURN,\n@@ -1054,6 +1056,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box dereference::Dereferencing);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n+    store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1233,6 +1236,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&get_last_with_len::GET_LAST_WITH_LEN),\n         LintId::of(&identity_conversion::IDENTITY_CONVERSION),\n         LintId::of(&identity_op::IDENTITY_OP),\n+        LintId::of(&if_let_mutex::IF_LET_MUTEX),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n         LintId::of(&infinite_iter::INFINITE_ITER),\n@@ -1620,6 +1624,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&erasing_op::ERASING_OP),\n         LintId::of(&formatting::POSSIBLE_MISSING_COMMA),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n+        LintId::of(&if_let_mutex::IF_LET_MUTEX),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n         LintId::of(&infinite_iter::INFINITE_ITER),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY),"}, {"sha": "9ad1315c17521c146f2d396ae38f5a9f7b1d8017", "filename": "doc/adding_lints.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -101,7 +101,9 @@ Once we are satisfied with the output, we need to run\n Please note that, we should run `TESTNAME=foo_functions cargo uitest`\n every time before running `tests/ui/update-all-references.sh`.\n Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n-our lint, we need to commit the generated `.stderr` files, too.\n+our lint, we need to commit the generated `.stderr` files, too. In general, you\n+should only commit files changed by `tests/ui/update-all-references.sh` for the\n+specific lint you are creating/editing.\n \n ## Rustfix tests\n "}, {"sha": "95931be734161ff8da3969b0f91158884238294e", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -731,6 +731,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"identity_op\",\n     },\n+    Lint {\n+        name: \"if_let_mutex\",\n+        group: \"correctness\",\n+        desc: \"locking a `Mutex` in an `if let` block can cause deadlocks\",\n+        deprecation: None,\n+        module: \"if_let_mutex\",\n+    },\n     Lint {\n         name: \"if_let_some_result\",\n         group: \"style\","}, {"sha": "58feae422a3c121f3d89cc14278147037191a99a", "filename": "tests/ui/if_let_mutex.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/tests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/tests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.rs?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -0,0 +1,42 @@\n+#![warn(clippy::if_let_mutex)]\n+\n+use std::ops::Deref;\n+use std::sync::Mutex;\n+\n+fn do_stuff<T>(_: T) {}\n+\n+fn if_let() {\n+    let m = Mutex::new(1_u8);\n+    if let Err(locked) = m.lock() {\n+        do_stuff(locked);\n+    } else {\n+        let lock = m.lock().unwrap();\n+        do_stuff(lock);\n+    };\n+}\n+\n+// This is the most common case as the above case is pretty\n+// contrived.\n+fn if_let_option() {\n+    let m = Mutex::new(Some(0_u8));\n+    if let Some(locked) = m.lock().unwrap().deref() {\n+        do_stuff(locked);\n+    } else {\n+        let lock = m.lock().unwrap();\n+        do_stuff(lock);\n+    };\n+}\n+\n+// When mutexs are different don't warn\n+fn if_let_different_mutex() {\n+    let m = Mutex::new(Some(0_u8));\n+    let other = Mutex::new(None::<u8>);\n+    if let Some(locked) = m.lock().unwrap().deref() {\n+        do_stuff(locked);\n+    } else {\n+        let lock = other.lock().unwrap();\n+        do_stuff(lock);\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "e9c4d9163328f3066e9c67f244a8ce233c35555a", "filename": "tests/ui/if_let_mutex.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/tests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ce05bf849a86dc8c0d7756d679f442e979b5eaf/tests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.stderr?ref=6ce05bf849a86dc8c0d7756d679f442e979b5eaf", "patch": "@@ -0,0 +1,29 @@\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:10:5\n+   |\n+LL | /     if let Err(locked) = m.lock() {\n+LL | |         do_stuff(locked);\n+LL | |     } else {\n+LL | |         let lock = m.lock().unwrap();\n+LL | |         do_stuff(lock);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::if-let-mutex` implied by `-D warnings`\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:22:5\n+   |\n+LL | /     if let Some(locked) = m.lock().unwrap().deref() {\n+LL | |         do_stuff(locked);\n+LL | |     } else {\n+LL | |         let lock = m.lock().unwrap();\n+LL | |         do_stuff(lock);\n+LL | |     };\n+   | |_____^\n+   |\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: aborting due to 2 previous errors\n+"}]}