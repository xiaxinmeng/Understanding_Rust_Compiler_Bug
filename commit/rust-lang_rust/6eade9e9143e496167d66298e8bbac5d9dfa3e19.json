{"sha": "6eade9e9143e496167d66298e8bbac5d9dfa3e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYWRlOWU5MTQzZTQ5NjE2N2Q2NjI5OGU4YmJhYzVkOWRmYTNlMTk=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T06:32:14Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T18:18:06Z"}, "message": "path2: Update for latest master\n\nAlso fix some issues that crept into earlier commits during the conflict\nresoution for the rebase.", "tree": {"sha": "d5cf6690f8ac9f7dfecb73774a1b5f7b5149c196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5cf6690f8ac9f7dfecb73774a1b5f7b5149c196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eade9e9143e496167d66298e8bbac5d9dfa3e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eade9e9143e496167d66298e8bbac5d9dfa3e19", "html_url": "https://github.com/rust-lang/rust/commit/6eade9e9143e496167d66298e8bbac5d9dfa3e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eade9e9143e496167d66298e8bbac5d9dfa3e19/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40b324f0dec364a9fa71f9f8b47b8ab156f6d61e", "url": "https://api.github.com/repos/rust-lang/rust/commits/40b324f0dec364a9fa71f9f8b47b8ab156f6d61e", "html_url": "https://github.com/rust-lang/rust/commit/40b324f0dec364a9fa71f9f8b47b8ab156f6d61e"}], "stats": {"total": 135, "additions": 76, "deletions": 59}, "files": [{"sha": "541aa082f51667b861580ce00c4e05b37e109ba8", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -164,7 +164,7 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.filename().map_move(|s| Path::new(s))\n+            testfile.filename().map(|s| Path::new(s))\n         } else {\n             None\n         }"}, {"sha": "627a80ace691636e4b9d227e76f2ad314470ae12", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -663,7 +663,7 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     if !os::EXE_SUFFIX.is_empty() {\n-        match f.filename().map_move(|s| s + os::EXE_SUFFIX.as_bytes()) {\n+        match f.filename().map(|s| s + os::EXE_SUFFIX.as_bytes()) {\n             Some(v) => f.set_filename(v),\n             None => ()\n         }\n@@ -752,7 +752,7 @@ fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n \n fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    match f.filename().map_move(|s| s + bytes!(\".libaux\")) {\n+    match f.filename().map(|s| s + bytes!(\".libaux\")) {\n         Some(v) => f.set_filename(v),\n         None => ()\n     }"}, {"sha": "031545c1cd203332643c53c7fe3e12add6ac0988", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -98,7 +98,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n         root.push(pat_root.get_ref());\n     }\n \n-    let root_len = pat_root.map_move_default(0u, |p| p.as_vec().len());\n+    let root_len = pat_root.map_default(0u, |p| p.as_vec().len());\n     let dir_patterns = pattern.slice_from(root_len.min(&pattern.len()))\n                        .split_terminator_iter(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n \n@@ -303,7 +303,7 @@ impl Pattern {\n      */\n     pub fn matches_path(&self, path: &Path) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_move_default(false) |s| {\n+        do path.as_str().map_default(false) |s| {\n             self.matches(s)\n         }\n     }\n@@ -321,7 +321,7 @@ impl Pattern {\n      */\n     pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_move_default(false) |s| {\n+        do path.as_str().map_default(false) |s| {\n             self.matches_with(s, options)\n         }\n     }"}, {"sha": "fba6cba911660b06a83e98e047af87273a4ea620", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -104,7 +104,7 @@ impl PkgSrc {\n \n             let mut result = build_dir.join(\"src\");\n             result.push(&id.path.dir_path());\n-            result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n+            result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result.clone());\n             output_names.push(result);\n             let mut other_result = build_dir.join(\"src\");\n@@ -174,17 +174,19 @@ impl PkgSrc {\n                     }\n                     match ok_d {\n                         Some(ref d) => {\n-                            if d.is_parent_of(&id.path)\n-                                || d.is_parent_of(&versionize(&id.path, &id.version)) {\n+                            if d.is_ancestor_of(&id.path)\n+                                || d.is_ancestor_of(&versionize(&id.path, &id.version)) {\n                                 // Strip off the package ID\n                                 source_workspace = d.clone();\n-                                for _ in id.path.components().iter() {\n-                                    source_workspace = source_workspace.pop();\n+                                for _ in id.path.component_iter() {\n+                                    source_workspace.pop();\n                                 }\n                                 // Strip off the src/ part\n-                                source_workspace = source_workspace.pop();\n+                                source_workspace.pop();\n                                 // Strip off the build/<target-triple> part to get the workspace\n-                                destination_workspace = source_workspace.pop().pop();\n+                                destination_workspace = source_workspace.clone();\n+                                destination_workspace.pop();\n+                                destination_workspace.pop();\n                             }\n                             break;\n                         }\n@@ -244,9 +246,10 @@ impl PkgSrc {\n     pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n         use conditions::git_checkout_failed::cond;\n \n+        let cwd = os::getcwd();\n         debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                 pkgid.to_str(), pkgid.path.display(),\n-                os::getcwd().display(),\n+                cwd.display(),\n                 os::path_exists(&pkgid.path));\n \n         match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n@@ -400,7 +403,7 @@ impl PkgSrc {\n                     // into account. I'm not sure if the workcache really likes seeing the\n                     // output as \"Some(\\\"path\\\")\". But I don't know what to do about it.\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let result = result.map(|p|p.as_str().unwrap());\n+                    let result = result.as_ref().map(|p|p.as_str().unwrap());\n                     debug2!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n                     result.to_str()\n                 }"}, {"sha": "f5b2251a2a6ec4b6bab5f97785ce3a7e3152fb3a", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -462,7 +462,7 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n pub fn chmod_read_only(p: &Path) -> bool {\n     #[fixed_stack_segment];\n     unsafe {\n-        do p.to_str().with_c_str |src_buf| {\n+        do p.with_c_str |src_buf| {\n             libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int\n         }\n     }\n@@ -472,7 +472,7 @@ pub fn chmod_read_only(p: &Path) -> bool {\n pub fn chmod_read_only(p: &Path) -> bool {\n     #[fixed_stack_segment];\n     unsafe {\n-        do p.to_str().with_c_str |src_buf| {\n+        do p.with_c_str |src_buf| {\n             libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0\n                 as libc::c_int\n         }"}, {"sha": "985dcd805ce285aa490477dca5318d3fd8bc3c65", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -247,8 +247,9 @@ impl CtxMethods for BuildContext {\n                 dest_ws = determine_destination(os::getcwd(),\n                                                 self.context.use_rust_path_hack,\n                                                 workspace);\n-                let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n-                dest_ws = Some(self.build(&mut pkg_src, what));\n+                let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n+                                              false, pkgid.clone());\n+                self.build(&mut pkg_src, what);\n                 true\n             };\n             // n.b. If this builds multiple packages, it only returns the workspace for\n@@ -430,7 +431,7 @@ impl CtxMethods for BuildContext {\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                _ => cond.raise((pkgid.path.as_str().unwrap(), out_dir.clone()))\n+                _ => cond.raise((pkgid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n             debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n@@ -562,7 +563,7 @@ impl CtxMethods for BuildContext {\n \n         let result = self.install_no_build(pkg_src.build_workspace(),\n                                            &pkg_src.destination_workspace,\n-                                           &id).map(|s| Path::new(*s));\n+                                           &id).map(|s| Path::new(s.as_slice()));\n         debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.map(|p| p.display().to_str()));\n         installed_files = installed_files + result;\n@@ -580,7 +581,7 @@ impl CtxMethods for BuildContext {\n         use conditions::copy_failed::cond;\n \n         debug2!(\"install_no_build: assuming {} comes from {} with target {}\",\n-               id.to_str(), build_workspace.to_str(), target_workspace.to_str());\n+               id.to_str(), build_workspace.display(), target_workspace.display());\n \n         // Now copy stuff into the install dirs\n         let maybe_executable = built_executable_in_workspace(id, build_workspace);\n@@ -631,8 +632,7 @@ impl CtxMethods for BuildContext {\n                     let mut target_lib = sub_target_lib\n                         .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.display()));\n-                    let target_lib = target_lib\n-                        .set_filename(lib.filename().expect(\"weird target lib\"));\n+                    target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n                     if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));"}, {"sha": "3c879af34cf1e9c64042e25e075a29a049ecc084", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -107,7 +107,9 @@ pub fn make_read_only(target: &Path) {\n pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     use conditions::git_checkout_failed::cond;\n \n-    let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n+                                           target.as_str().unwrap().to_owned()]);\n     if outp.status != 0 {\n          debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n          debug2!(\"{}\", str::from_utf8_owned(outp.error));"}, {"sha": "d367399c0bf28a6b4e397912d19aba7e5d575492", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -88,7 +88,7 @@ fn writeFile(file_path: &Path, contents: &str) {\n \n fn mk_emptier_workspace(tag: &str) -> TempDir {\n     let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n-    let package_dir = workspace.path().push(\"src\");\n+    let package_dir = workspace.path().join(\"src\");\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     workspace\n }\n@@ -110,9 +110,10 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n \n fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n     let workspace_dir = mk_empty_workspace(short_name, version, \"temp_workspace\");\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n     let package_dir = workspace_dir.path().join_many([~\"src\",\n                                                       format!(\"{}-{}\",\n-                                                              short_name.to_str(),\n+                                                              short_name.as_str().unwrap(),\n                                                               version.to_str())]);\n \n     debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n@@ -912,7 +913,8 @@ fn rust_path_test() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n                                &cwd,\n-                               Some(~[(~\"RUST_PATH\", dir_for_path.path().as_str().unwrap())]));\n+                               Some(~[(~\"RUST_PATH\",\n+                                       dir_for_path.path().as_str().unwrap().to_owned())]));\n     assert_executable_exists(dir_for_path.path(), \"foo\");\n }\n \n@@ -1078,7 +1080,7 @@ fn do_rebuild_dep_dates_change() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n     let bar_date = datestamp(&bar_lib_name);\n-    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.to_str(), bar_date);\n+    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.display(), bar_date);\n     touch_source_file(workspace, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     let new_bar_date = datestamp(&bar_lib_name);\n@@ -1326,6 +1328,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let workspace = workspace.path();\n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n+   let foo_path = workspace.join_many([\"src\", \"foo-0.1\"]);\n    let rust_path = Some(~[(~\"RUST_PATH\",\n        format!(\"{}:{}\",\n                dest_workspace.as_str().unwrap(),\n@@ -1568,7 +1571,7 @@ fn dash_S() {\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sysroot().as_str().unwrap().to_owned(),\n+    command_line_test([test_sys.as_str().unwrap().to_owned(),\n                        ~\"build\",\n                        ~\"-S\",\n                        ~\"foo\"],\n@@ -1809,7 +1812,7 @@ fn test_recursive_deps() {\n     let c_id = PkgId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n-    writeFile(&b_workspace.join_many([\"src\", \"c-0.1\", \"lib.rs\"])),\n+    writeFile(&b_workspace.join_many([\"src\", \"c-0.1\", \"lib.rs\"]),\n                \"pub fn g() {}\");\n     let a_workspace = create_local_package(&a_id);\n     let a_workspace = a_workspace.path();\n@@ -1879,7 +1882,7 @@ fn test_target_specific_install_dir() {\n                        ~\"install\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&workspace.join_many([\"lib\", host_triple()])));\n+    assert!(os::path_is_dir(&workspace.join_many([~\"lib\", host_triple()])));\n     assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n     assert!(os::list_dir(&workspace.join(\"lib\")).len() == 1);\n     assert!(os::path_is_dir(&workspace.join(\"bin\")));\n@@ -2051,7 +2054,7 @@ fn test_installed_read_only() {\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n     debug2!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.display());\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n@@ -2077,8 +2080,8 @@ fn test_installed_read_only() {\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n-    let src1 = target_build_dir(&ws).join_many_str([\"src\", temp_pkg_id.to_str(), \"main.rs\"]);\n-    let src2 = target_build_dir(&ws).join_many_str([\"src\", temp_pkg_id.to_str(), \"lib.rs\"]);\n+    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n+    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n     assert!(os::path_exists(&src1));\n     assert!(os::path_exists(&src2));\n     assert!(is_read_only(&src1));\n@@ -2091,9 +2094,9 @@ fn test_installed_local_changes() {\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n     debug2!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many_str([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n+    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug2!(\"repo_subdir = {}\", repo_subdir.display());\n-    assert!(os::mkdir_recursive(&repo.join_many_str([\".rust\", \"src\"]), U_RWX));\n+    assert!(os::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), U_RWX));\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -2109,10 +2112,10 @@ fn test_installed_local_changes() {\n     // Now start a new workspace and clone it into it\n     let hacking_workspace = mk_emptier_workspace(\"hacking_workspace\");\n     let hacking_workspace = hacking_workspace.path();\n-    let target_dir = hacking_workspace.join_many_str([\"src\",\n-                                                      \"mockgithub.com\",\n-                                                      \"catamorphism\",\n-                                                      \"test-pkg-0.1\"]);\n+    let target_dir = hacking_workspace.join_many([\"src\",\n+                                                  \"mockgithub.com\",\n+                                                  \"catamorphism\",\n+                                                  \"test-pkg-0.1\"]);\n     debug2!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n     let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n@@ -2159,7 +2162,7 @@ fn test_compile_error() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let main_crate = foo_workspace.join_many_str([\"src\", \"foo-0.1\", \"main.rs\"]);\n+    let main_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]);\n     // Write something bogus\n     writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);"}, {"sha": "66c1aaea1ed649d30cb9f5aa5f80181a7f515868", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -482,9 +482,9 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                      dep.as_str().unwrap(),\n                                                      digest_only_date(dep));\n                             // Also, add an additional search path\n-                            debug2!(\"Installed {} into {}\", dep.display(),\n-                                    dep.dir_path().display());\n-                            (self.save)(dep.dir_path());\n+                            let dep_dir = dep.dir_path();\n+                            debug2!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n+                            (self.save)(dep_dir);\n                         }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {"}, {"sha": "13d70f153329b05caef1e7120e9f38452d9d7851", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -63,7 +63,7 @@ pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n         let srcpath = path.join(\"src\");\n         if srcpath.is_ancestor_of(&cwd) {\n             let rel = cwd.path_relative_from(&srcpath);\n-            let rel_s = rel.and_then_ref(|p|p.as_str());\n+            let rel_s = rel.as_ref().and_then(|p|p.as_str());\n             if rel_s.is_some() {\n                 return Some((path, PkgId::new(rel_s.unwrap())));\n             }"}, {"sha": "348bfd5c61a43cbb6870cf5b3bac4c99cb963325", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -509,11 +509,11 @@ pub fn self_exe_path() -> Option<Path> {\n             use os::win32::fill_utf16_buf_and_decode;\n             do fill_utf16_buf_and_decode() |buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }.map_move(|s| s.into_bytes())\n+            }.map(|s| s.into_bytes())\n         }\n     }\n \n-    load_self().and_then(|path| Path::new_opt(path).map(|p| { p.pop(); p }))\n+    load_self().and_then(|path| Path::new_opt(path).map(|mut p| { p.pop(); p }))\n }\n \n "}, {"sha": "271937dfcf2df7c7da8ce28fd334d48de943ac5c", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -791,7 +791,7 @@ mod tests {\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = Path::new($path);\n-                    let left = path.$op().map(|&x| str::from_utf8_slice(x));\n+                    let left = path.$op().map(|x| str::from_utf8_slice(x));\n                     assert_eq!(left, $exp);\n                 }\n             );\n@@ -1313,7 +1313,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n-                    assert_eq!(res.and_then_ref(|x| x.as_str()), $exp);\n+                    assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n         )"}, {"sha": "0ee0d9c79d1bfe4ee25ffa21651d7fe5b0ddb30e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eade9e9143e496167d66298e8bbac5d9dfa3e19/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=6eade9e9143e496167d66298e8bbac5d9dfa3e19", "patch": "@@ -258,7 +258,7 @@ impl GenericPathUnsafe for Path {\n             // if me is verbatim, we need to pre-normalize the new path\n             let path_ = if is_verbatim(me) { Path::normalize__(path, None) }\n                         else { None };\n-            let pathlen = path_.map_default(path.len(), |p| p.len());\n+            let pathlen = path_.as_ref().map_default(path.len(), |p| p.len());\n             let mut s = str::with_capacity(me.repr.len() + 1 + pathlen);\n             s.push_str(me.repr);\n             let plen = me.prefix_len();\n@@ -368,7 +368,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n-        self.filename_str().map_move(|x| x.as_bytes())\n+        self.filename_str().map(|x| x.as_bytes())\n     }\n \n     /// See `GenericPath::filename_str` for info.\n@@ -388,13 +388,13 @@ impl GenericPath for Path {\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n         // filestem() returns a byte vector that's guaranteed valid UTF-8\n-        self.filestem().map_move(cast::transmute)\n+        self.filestem().map(cast::transmute)\n     }\n \n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n         // extension() returns a byte vector that's guaranteed valid UTF-8\n-        self.extension().map_move(cast::transmute)\n+        self.extension().map(cast::transmute)\n     }\n \n     fn dir_path(&self) -> Path {\n@@ -728,16 +728,25 @@ impl Path {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n                                 let mut s = s.slice_to(len).to_owned();\n-                                s[0] = s[0].to_ascii().to_upper().to_byte();\n+                                unsafe {\n+                                    str::raw::as_owned_vec(&mut s)[0] =\n+                                        s[0].to_ascii().to_upper().to_byte();\n+                                }\n                                 if is_abs {\n-                                    s[2] = sep as u8; // normalize C:/ to C:\\\n+                                    // normalize C:/ to C:\\\n+                                    unsafe {\n+                                        str::raw::as_owned_vec(&mut s)[2] = sep as u8;\n+                                    }\n                                 }\n                                 Some(s)\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n                                 let mut s = s.slice_to(len).to_owned();\n-                                s[4] = s[4].to_ascii().to_upper().to_byte();\n+                                unsafe {\n+                                    str::raw::as_owned_vec(&mut s)[4] =\n+                                        s[4].to_ascii().to_upper().to_byte();\n+                                }\n                                 Some(s)\n                             }\n                             _ => {\n@@ -2204,10 +2213,10 @@ mod tests {\n                     let other = Path::new($other);\n                     let res = path.path_relative_from(&other);\n                     let exp = $exp;\n-                    assert!(res.and_then_ref(|x| x.as_str()) == exp,\n+                    assert!(res.as_ref().and_then(|x| x.as_str()) == exp,\n                             \"`{}`.path_relative_from(`{}`): Expected {:?}, got {:?}\",\n                             path.as_str().unwrap(), other.as_str().unwrap(), exp,\n-                            res.and_then_ref(|x| x.as_str()));\n+                            res.as_ref().and_then(|x| x.as_str()));\n                 }\n             )\n         )"}]}