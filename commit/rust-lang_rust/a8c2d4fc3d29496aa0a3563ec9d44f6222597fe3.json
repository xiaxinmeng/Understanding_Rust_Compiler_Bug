{"sha": "a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YzJkNGZjM2QyOTQ5NmFhMGEzNTYzZWM5ZDQ0ZjYyMjI1OTdmZTM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-30T22:57:46Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T07:47:08Z"}, "message": "Move boxing and mutex checking logic of condvar into sys_common.", "tree": {"sha": "dc82c7cc3e73c3c58f921baba6125ad17320f5f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc82c7cc3e73c3c58f921baba6125ad17320f5f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "html_url": "https://github.com/rust-lang/rust/commit/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f283d3f02cf3ed261a519afe05cde9e23d1d9278", "url": "https://api.github.com/repos/rust-lang/rust/commits/f283d3f02cf3ed261a519afe05cde9e23d1d9278", "html_url": "https://github.com/rust-lang/rust/commit/f283d3f02cf3ed261a519afe05cde9e23d1d9278"}], "stats": {"total": 133, "additions": 55, "deletions": 78}, "files": [{"sha": "ffc1e57f4e03fa539309e54d93e85a28e418d0e0", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "patch": "@@ -2,10 +2,8 @@\n mod tests;\n \n use crate::fmt;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sync::{mutex, MutexGuard, PoisonError};\n use crate::sys_common::condvar as sys;\n-use crate::sys_common::mutex as sys_mutex;\n use crate::sys_common::poison::{self, LockResult};\n use crate::time::{Duration, Instant};\n \n@@ -109,8 +107,7 @@ impl WaitTimeoutResult {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Condvar {\n-    inner: Box<sys::Condvar>,\n-    mutex: AtomicUsize,\n+    inner: sys::Condvar,\n }\n \n impl Condvar {\n@@ -126,11 +123,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n-        let mut c = Condvar { inner: box sys::Condvar::new(), mutex: AtomicUsize::new(0) };\n-        unsafe {\n-            c.inner.init();\n-        }\n-        c\n+        Condvar { inner: sys::Condvar::new() }\n     }\n \n     /// Blocks the current thread until this condition variable receives a\n@@ -192,7 +185,6 @@ impl Condvar {\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> LockResult<MutexGuard<'a, T>> {\n         let poisoned = unsafe {\n             let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n             self.inner.wait(lock);\n             mutex::guard_poison(&guard).get()\n         };\n@@ -389,7 +381,6 @@ impl Condvar {\n     ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n         let (poisoned, result) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n             let success = self.inner.wait_timeout(lock, dur);\n             (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n         };\n@@ -510,7 +501,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_one(&self) {\n-        unsafe { self.inner.notify_one() }\n+        self.inner.notify_one()\n     }\n \n     /// Wakes up all blocked threads on this condvar.\n@@ -550,27 +541,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_all(&self) {\n-        unsafe { self.inner.notify_all() }\n-    }\n-\n-    fn verify(&self, mutex: &sys_mutex::MovableMutex) {\n-        let addr = mutex.raw() as *const _ as usize;\n-        match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n-            // If we got out 0, then we have successfully bound the mutex to\n-            // this cvar.\n-            0 => {}\n-\n-            // If we get out a value that's the same as `addr`, then someone\n-            // already beat us to the punch.\n-            n if n == addr => {}\n-\n-            // Anything else and we're using more than one mutex on this cvar,\n-            // which is currently disallowed.\n-            _ => panic!(\n-                \"attempted to use a condition variable with two \\\n-                         mutexes\"\n-            ),\n-        }\n+        self.inner.notify_all()\n     }\n }\n \n@@ -588,10 +559,3 @@ impl Default for Condvar {\n         Condvar::new()\n     }\n }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Drop for Condvar {\n-    fn drop(&mut self) {\n-        unsafe { self.inner.destroy() }\n-    }\n-}"}, {"sha": "c65f1f81509d26313a876c0546281de9a2eacf8b", "filename": "library/std/src/sys_common/condvar.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "patch": "@@ -1,72 +1,62 @@\n use crate::sys::condvar as imp;\n use crate::sys_common::mutex::MovableMutex;\n use crate::time::Duration;\n+use check::CondvarCheck;\n+\n+mod check;\n \n /// An OS-based condition variable.\n-///\n-/// This structure is the lowest layer possible on top of the OS-provided\n-/// condition variables. It is consequently entirely unsafe to use. It is\n-/// recommended to use the safer types at the top level of this crate instead of\n-/// this type.\n-pub struct Condvar(imp::Condvar);\n+pub struct Condvar {\n+    inner: Box<imp::Condvar>,\n+    check: CondvarCheck,\n+}\n \n impl Condvar {\n     /// Creates a new condition variable for use.\n-    ///\n-    /// Behavior is undefined if the condition variable is moved after it is\n-    /// first used with any of the functions below.\n-    pub const fn new() -> Condvar {\n-        Condvar(imp::Condvar::new())\n-    }\n-\n-    /// Prepares the condition variable for use.\n-    ///\n-    /// This should be called once the condition variable is at a stable memory\n-    /// address.\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.0.init()\n+    pub fn new() -> Self {\n+        let mut c = box imp::Condvar::new();\n+        unsafe { c.init() };\n+        Self { inner: c, check: CondvarCheck::new() }\n     }\n \n     /// Signals one waiter on this condition variable to wake up.\n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        self.0.notify_one()\n+    pub fn notify_one(&self) {\n+        unsafe { self.inner.notify_one() };\n     }\n \n     /// Awakens all current waiters on this condition variable.\n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        self.0.notify_all()\n+    pub fn notify_all(&self) {\n+        unsafe { self.inner.notify_all() };\n     }\n \n     /// Waits for a signal on the specified mutex.\n     ///\n     /// Behavior is undefined if the mutex is not locked by the current thread.\n-    /// Behavior is also undefined if more than one mutex is used concurrently\n-    /// on this condition variable.\n+    ///\n+    /// May panic if used with more than one mutex.\n     #[inline]\n     pub unsafe fn wait(&self, mutex: &MovableMutex) {\n-        self.0.wait(mutex.raw())\n+        self.check.verify(mutex);\n+        self.inner.wait(mutex.raw())\n     }\n \n     /// Waits for a signal on the specified mutex with a timeout duration\n     /// specified by `dur` (a relative time into the future).\n     ///\n     /// Behavior is undefined if the mutex is not locked by the current thread.\n-    /// Behavior is also undefined if more than one mutex is used concurrently\n-    /// on this condition variable.\n+    ///\n+    /// May panic if used with more than one mutex.\n     #[inline]\n     pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n-        self.0.wait_timeout(mutex.raw(), dur)\n+        self.check.verify(mutex);\n+        self.inner.wait_timeout(mutex.raw(), dur)\n     }\n+}\n \n-    /// Deallocates all resources associated with this condition variable.\n-    ///\n-    /// Behavior is undefined if there are current or will be future users of\n-    /// this condition variable.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n+impl Drop for Condvar {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.destroy() };\n     }\n }"}, {"sha": "949b53f30b17c1809d0c4e0acf7f5da91ce78254", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "patch": "@@ -0,0 +1,23 @@\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sys::mutex as mutex_imp;\n+use crate::sys_common::mutex::MovableMutex;\n+\n+/// A `Condvar` will check it's only ever used with the same mutex, based on\n+/// its (stable) address.\n+pub struct CondvarCheck {\n+    addr: AtomicUsize,\n+}\n+\n+impl CondvarCheck {\n+    pub const fn new() -> Self {\n+        Self { addr: AtomicUsize::new(0) }\n+    }\n+    pub fn verify(&self, mutex: &MovableMutex) {\n+        let addr = mutex.raw() as *const mutex_imp::Mutex as usize;\n+        match self.addr.compare_and_swap(0, addr, Ordering::SeqCst) {\n+            0 => {}              // Stored the address\n+            n if n == addr => {} // Lost a race to store the same address\n+            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n+        }\n+    }\n+}"}, {"sha": "e30163b3a89492113a9cb0734b16ba7215b89655", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=a8c2d4fc3d29496aa0a3563ec9d44f6222597fe3", "patch": "@@ -72,7 +72,7 @@ impl MovableMutex {\n         Self(mutex)\n     }\n \n-    pub(crate) fn raw(&self) -> &imp::Mutex {\n+    pub(super) fn raw(&self) -> &imp::Mutex {\n         &self.0\n     }\n "}]}