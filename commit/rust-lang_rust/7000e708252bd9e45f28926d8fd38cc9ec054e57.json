{"sha": "7000e708252bd9e45f28926d8fd38cc9ec054e57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDBlNzA4MjUyYmQ5ZTQ1ZjI4OTI2ZDhmZDM4Y2M5ZWMwNTRlNTc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T23:58:14Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:25:08Z"}, "message": "Replace children and import_resolutions with a single NameResolution-valued map.\n\nRefactor away resolve_name_in_module in resolve_imports.rs\n\nRewrite and improve the core name resolution procedure in NameResolution::result and Module::resolve_name\n\nRefactor the duplicate checking code into NameResolution::try_define", "tree": {"sha": "60c5b439ed0f4bb658a8f0072b17522a93ed9518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c5b439ed0f4bb658a8f0072b17522a93ed9518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7000e708252bd9e45f28926d8fd38cc9ec054e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7000e708252bd9e45f28926d8fd38cc9ec054e57", "html_url": "https://github.com/rust-lang/rust/commit/7000e708252bd9e45f28926d8fd38cc9ec054e57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7000e708252bd9e45f28926d8fd38cc9ec054e57/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d881eee608bcfcd89643cb126c9f3aefc6a80661", "url": "https://api.github.com/repos/rust-lang/rust/commits/d881eee608bcfcd89643cb126c9f3aefc6a80661", "html_url": "https://github.com/rust-lang/rust/commit/d881eee608bcfcd89643cb126c9f3aefc6a80661"}], "stats": {"total": 726, "additions": 224, "deletions": 502}, "files": [{"sha": "a5828067fcafc82587e11339def9d6afaa4de3da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 64, "deletions": 111, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7000e708252bd9e45f28926d8fd38cc9ec054e57", "patch": "@@ -87,7 +87,7 @@ use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::util::walk_pat;\n \n-use std::collections::{hash_map, HashMap, HashSet};\n+use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n@@ -342,11 +342,8 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(sp) = resolver.ast_map.span_if_local(did) {\n                 err.span_note(sp, \"constant defined here\");\n             }\n-            if let Some(directive) = resolver.current_module\n-                                             .import_resolutions\n-                                             .borrow()\n-                                             .get(&(name, ValueNS)) {\n-                if let Some(binding) = directive.binding {\n+            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n+                if binding.is_import() {\n                     err.span_note(binding.span.unwrap(), \"constant imported here\");\n                 }\n             }\n@@ -653,10 +650,10 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     }\n }\n \n-type ErrorMessage = Option<(Span, String)>;\n+pub type ErrorMessage = Option<(Span, String)>;\n \n #[derive(Clone, PartialEq, Eq)]\n-enum ResolveResult<T> {\n+pub enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n     Success(T), // Successfully resolved the import.\n@@ -802,7 +799,7 @@ pub struct ModuleS<'a> {\n     is_public: bool,\n     is_extern_crate: bool,\n \n-    children: RefCell<HashMap<(Name, Namespace), &'a NameBinding<'a>>>,\n+    children: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -821,9 +818,6 @@ pub struct ModuleS<'a> {\n     // entry block for `f`.\n     anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n-    // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n-\n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n \n@@ -854,7 +848,6 @@ impl<'a> ModuleS<'a> {\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n             anonymous_children: RefCell::new(NodeMap()),\n-            import_resolutions: RefCell::new(HashMap::new()),\n             glob_count: Cell::new(0),\n             pub_count: Cell::new(0),\n             pub_glob_count: Cell::new(0),\n@@ -863,39 +856,49 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn get_child(&self, name: Name, ns: Namespace) -> Option<&'a NameBinding<'a>> {\n-        self.children.borrow().get(&(name, ns)).cloned()\n+    fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n+                    -> ResolveResult<&'a NameBinding<'a>> {\n+        let glob_count =\n+            if allow_private_imports { self.glob_count.get() } else { self.pub_glob_count.get() };\n+\n+        self.children.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n+            .and_then(|binding| {\n+                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                if allowed { Success(binding) } else { Failed(None) }\n+            })\n     }\n \n-    // If the name is not yet defined, define the name and return None.\n-    // Otherwise, return the existing definition.\n+    // Define the name or return the existing binding if there is a collision.\n     fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n                         -> Result<(), &'a NameBinding<'a>> {\n-        match self.children.borrow_mut().entry((name, ns)) {\n-            hash_map::Entry::Vacant(entry) => { entry.insert(binding); Ok(()) }\n-            hash_map::Entry::Occupied(entry) => { Err(entry.get()) },\n-        }\n+        self.children.borrow_mut().entry((name, ns)).or_insert_with(Default::default)\n+                                                    .try_define(binding)\n     }\n \n     fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        let mut resolutions = self.import_resolutions.borrow_mut();\n-        resolutions.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n+        let mut children = self.children.borrow_mut();\n+        children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n     }\n \n     fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        match self.import_resolutions.borrow_mut().get_mut(&(name, ns)).unwrap()\n-                                                                       .outstanding_references {\n+        match self.children.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n             0 => panic!(\"No more outstanding references!\"),\n             ref mut outstanding_references => { *outstanding_references -= 1; }\n         }\n     }\n \n+    fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(name, ns), name_resolution) in self.children.borrow().iter() {\n+            name_resolution.binding.map(|binding| f(name, ns, binding));\n+        }\n+    }\n+\n     fn for_each_local_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_binding) in self.children.borrow().iter() {\n-            if !name_binding.is_extern_crate() {\n+        self.for_each_child(|name, ns, name_binding| {\n+            if !name_binding.is_import() && !name_binding.is_extern_crate() {\n                 f(name, ns, name_binding)\n             }\n-        }\n+        })\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n@@ -1240,7 +1243,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     #[inline]\n-    fn record_import_use(&mut self, name: Name, ns: Namespace, binding: &NameBinding<'a>) {\n+    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+        // track extern crates for unused_extern_crate lint\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+            self.used_crates.insert(krate);\n+        }\n+\n         let import_id = match binding.kind {\n             NameBindingKind::Import { id, .. } => id,\n             _ => return,\n@@ -1278,8 +1286,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n         fn search_parent_externals<'a>(needle: Name, module: Module<'a>) -> Option<Module<'a>> {\n-            match module.get_child(needle, TypeNS) {\n-                Some(binding) if binding.is_extern_crate() => Some(module),\n+            match module.resolve_name(needle, TypeNS, false) {\n+                Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n                         search_parent_externals(needle, parent)\n@@ -1591,53 +1599,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// given namespace. If successful, returns the binding corresponding to\n     /// the name.\n     fn resolve_name_in_module(&mut self,\n-                              module_: Module<'a>,\n+                              module: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n                               allow_private_imports: bool,\n                               record_used: bool)\n                               -> ResolveResult<&'a NameBinding<'a>> {\n-        debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               name,\n-               module_to_string(&*module_));\n-\n-        // First, check the direct children of the module.\n-        build_reduced_graph::populate_module_if_necessary(self, module_);\n-\n-        if let Some(binding) = module_.get_child(name, namespace) {\n-            debug!(\"(resolving name in module) found node as child\");\n-            if binding.is_extern_crate() {\n-                // track the extern crate as used.\n-                if let Some(DefId { krate, .. }) = binding.module().unwrap().def_id() {\n-                    self.used_crates.insert(krate);\n-                }\n-            }\n-            return Success(binding);\n-        }\n-\n-        // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().get(&(name, namespace)) {\n-            Some(import_resolution) => {\n-                if let Some(binding) = import_resolution.binding {\n-                    if !allow_private_imports && binding.is_public() { return Failed(None) }\n-                    if binding.is_public() && import_resolution.outstanding_references != 0 {\n-                        debug!(\"(resolving name in module) import unresolved; bailing out\");\n-                        return Indeterminate;\n-                    }\n+        debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n-                    debug!(\"(resolving name in module) resolved to import\");\n-                    if record_used {\n-                        self.record_import_use(name, namespace, binding);\n-                    }\n-                    return Success(binding);\n-                }\n+        build_reduced_graph::populate_module_if_necessary(self, module);\n+        module.resolve_name(name, namespace, allow_private_imports).and_then(|binding| {\n+            if record_used {\n+                self.record_use(name, namespace, binding);\n             }\n-            None => {}\n-        }\n-\n-        // We're out of luck.\n-        debug!(\"(resolving name in module) failed to resolve `{}`\", name);\n-        return Failed(None);\n+            Success(binding)\n+        })\n     }\n \n     fn report_unresolved_imports(&mut self, module_: Module<'a>) {\n@@ -1700,22 +1676,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(name) => {\n                 build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n \n-                match orig_module.get_child(name, TypeNS) {\n-                    None => {\n-                        debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               name,\n-                               module_to_string(&*orig_module));\n-                    }\n-                    Some(name_binding) => {\n-                        match name_binding.module() {\n-                            None => {\n-                                debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n-                                       name,\n-                                       module_to_string(&*orig_module));\n-                            }\n-                            Some(module_) => {\n-                                self.current_module = module_;\n-                            }\n+                if let Success(name_binding) = orig_module.resolve_name(name, TypeNS, false) {\n+                    match name_binding.module() {\n+                        None => {\n+                            debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n+                                   name,\n+                                   module_to_string(orig_module));\n+                        }\n+                        Some(module) => {\n+                            self.current_module = module;\n                         }\n                     }\n                 }\n@@ -3101,7 +3070,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if name_path.len() == 1 {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n-                    None => this.current_module.get_child(*last_name, TypeNS)\n+                    None => this.current_module.resolve_name(*last_name, TypeNS, true).success()\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n@@ -3161,7 +3130,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Some(binding) = module.get_child(name, ValueNS) {\n+            if let Success(binding) = module.resolve_name(name, ValueNS, true) {\n                 if let Some(Def::Method(did)) = binding.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n@@ -3484,34 +3453,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // Look for trait children.\n             build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n-            for (&(_, ns), name_binding) in search_module.children.borrow().iter() {\n-                if ns != TypeNS { continue }\n+            search_module.for_each_child(|_, ns, name_binding| {\n+                if ns != TypeNS { return }\n                 let trait_def_id = match name_binding.def() {\n                     Some(Def::Trait(trait_def_id)) => trait_def_id,\n-                    Some(..) | None => continue,\n+                    Some(..) | None => return,\n                 };\n                 if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                     add_trait_info(&mut found_traits, trait_def_id, name);\n+                    let trait_name = self.get_trait_name(trait_def_id);\n+                    self.record_use(trait_name, TypeNS, name_binding);\n                 }\n-            }\n-\n-            // Look for imports.\n-            for (&(_, ns), import) in search_module.import_resolutions.borrow().iter() {\n-                if ns != TypeNS { continue }\n-                let binding = match import.binding {\n-                    Some(binding) => binding,\n-                    None => continue,\n-                };\n-                let did = match binding.def() {\n-                    Some(Def::Trait(trait_def_id)) => trait_def_id,\n-                    Some(..) | None => continue,\n-                };\n-                if self.trait_item_map.contains_key(&(name, did)) {\n-                    add_trait_info(&mut found_traits, did, name);\n-                    let trait_name = self.get_trait_name(did);\n-                    self.record_import_use(trait_name, TypeNS, binding);\n-                }\n-            }\n+            });\n \n             match search_module.parent_link {\n                 NoParentLink | ModuleParentLink(..) => break,"}, {"sha": "39e689ea3fb083b9bf8ad525e5c07f7e845edf96", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 157, "deletions": 388, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7000e708252bd9e45f28926d8fd38cc9ec054e57", "patch": "@@ -25,7 +25,6 @@ use build_reduced_graph;\n \n use rustc::lint;\n use rustc::middle::def::*;\n-use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::*;\n \n use syntax::ast::{NodeId, Name};\n@@ -100,21 +99,12 @@ impl ImportDirective {\n     }\n }\n \n-#[derive(Debug)]\n-/// An NameResolution records what we know about an imported name in a given namespace.\n-/// More specifically, it records the number of unresolved `use` directives that import the name,\n-/// the `use` directive importing the name in the namespace, and the `NameBinding` to which the\n-/// name in the namespace resolves (if applicable).\n-/// Different `use` directives may import the same name in different namespaces.\n+#[derive(Clone, Copy)]\n+/// Records information about the resolution of a name in a module.\n pub struct NameResolution<'a> {\n-    // When outstanding_references reaches zero, outside modules can count on the targets being\n-    // correct. Before then, all bets are off; future `use` directives could override the name.\n-    // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n-    // is if the name is imported by exactly two `use` directives, one of which resolves to a\n-    // value and the other of which resolves to a type.\n+    /// The number of unresolved single imports that could define the name.\n     pub outstanding_references: usize,\n-\n-    /// Resolution of the name in the namespace\n+    /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n }\n \n@@ -125,13 +115,41 @@ impl<'a> Default for NameResolution<'a> {\n }\n \n impl<'a> NameResolution<'a> {\n-    pub fn shadowable(&self) -> Shadowable {\n-        match self.binding {\n-            Some(binding) if binding.defined_with(DefModifiers::PRELUDE) =>\n-                Shadowable::Always,\n-            Some(_) => Shadowable::Never,\n-            None => Shadowable::Always,\n+    pub fn result(&self, outstanding_globs: usize) -> ResolveResult<&'a NameBinding<'a>> {\n+        // If no unresolved imports (single or glob) can define the name, self.binding is final.\n+        if self.outstanding_references == 0 && outstanding_globs == 0 {\n+            return self.binding.map(Success).unwrap_or(Failed(None));\n+        }\n+\n+        if let Some(binding) = self.binding {\n+            // Single imports will never be shadowable by other single or glob imports.\n+            if !binding.defined_with(DefModifiers::GLOB_IMPORTED) { return Success(binding); }\n+            // Non-PRELUDE glob imports will never be shadowable by other glob imports.\n+            if self.outstanding_references == 0 && !binding.defined_with(DefModifiers::PRELUDE) {\n+                return Success(binding);\n+            }\n         }\n+\n+        Indeterminate\n+    }\n+\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n+        let is_prelude = |binding: &NameBinding| binding.defined_with(DefModifiers::PRELUDE);\n+        let old_binding = match self.binding {\n+            Some(old_binding) if is_prelude(binding) && !is_prelude(old_binding) => return Ok(()),\n+            Some(old_binding) if is_prelude(old_binding) == is_prelude(binding) => old_binding,\n+            _ => { self.binding = Some(binding); return Ok(()); }\n+        };\n+\n+        // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+        if !old_binding.is_import() && binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+            if let NameBindingKind::Import { binding, .. } = binding.kind {\n+                if binding.is_import() { return Ok(()); }\n+            }\n+        }\n+\n+        Err(old_binding)\n     }\n }\n \n@@ -201,27 +219,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport(target, _) = e.import_directive.subclass {\n-            let mut import_resolutions = e.source_module.import_resolutions.borrow_mut();\n-\n-            let resolution = import_resolutions.entry((target, ValueNS)).or_insert_with(|| {\n-                debug!(\"(resolving import error) adding import resolution for `{}`\",\n-                       target);\n-\n-                NameResolution::default()\n+            let dummy_binding = self.resolver.new_name_binding(NameBinding {\n+                modifiers: DefModifiers::PRELUDE,\n+                kind: NameBindingKind::Def(Def::Err),\n+                span: None,\n             });\n \n-            if resolution.binding.is_none() {\n-                debug!(\"(resolving import error) adding fake target to import resolution of `{}`\",\n-                       target);\n-\n-                let dummy_binding = self.resolver.new_name_binding(NameBinding {\n-                    modifiers: DefModifiers::IMPORTABLE,\n-                    kind: NameBindingKind::Def(Def::Err),\n-                    span: None,\n-                });\n-\n-                resolution.binding = Some(dummy_binding);\n-            }\n+            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n+            let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n         }\n \n         let path = import_path_to_string(&e.import_directive.module_path,\n@@ -360,68 +365,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             })\n     }\n \n-    /// Resolves the name in the namespace of the module because it is being imported by\n-    /// importing_module. Returns the name bindings defining the name.\n-    fn resolve_name_in_module(&mut self,\n-                              module: Module<'b>, // Module containing the name\n-                              name: Name,\n-                              ns: Namespace,\n-                              importing_module: Module<'b>) // Module importing the name\n-                              -> ResolveResult<&'b NameBinding<'b>> {\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n-        if let Some(name_binding) = module.get_child(name, ns) {\n-            if name_binding.is_extern_crate() {\n-                // track the extern crate as used.\n-                if let Some(DefId { krate, .. }) = name_binding.module().unwrap().def_id() {\n-                    self.resolver.used_crates.insert(krate);\n-                }\n-            }\n-            return Success(name_binding);\n-        }\n-\n-        // If there is an unresolved glob at this point in the containing module, bail out.\n-        // We don't know enough to be able to resolve the name.\n-        if module.pub_glob_count.get() > 0 {\n-            return Indeterminate;\n-        }\n-\n-        match module.import_resolutions.borrow().get(&(name, ns)) {\n-            // The containing module definitely doesn't have an exported import with the\n-            // name in question. We can therefore accurately report that names are unbound.\n-            None => Failed(None),\n-\n-            // The name is an import which has been fully resolved, so we just follow it.\n-            Some(resolution) if resolution.outstanding_references == 0 => {\n-                if let Some(binding) = resolution.binding {\n-                    // Import resolutions must be declared with \"pub\" in order to be exported.\n-                    if !binding.is_public() {\n-                        return Failed(None);\n-                    }\n-\n-                    self.resolver.record_import_use(name, ns, binding);\n-                    Success(binding)\n-                } else {\n-                    Failed(None)\n-                }\n-            }\n-\n-            // If module is the same module whose import we are resolving and\n-            // it has an unresolved import with the same name as `name`, then the user\n-            // is actually trying to import an item that is declared in the same scope\n-            //\n-            // e.g\n-            // use self::submodule;\n-            // pub mod submodule;\n-            //\n-            // In this case we continue as if we resolved the import and let\n-            // check_for_conflicts_between_imports_and_items handle the conflict\n-            Some(_) => match (importing_module.def_id(), module.def_id()) {\n-                (Some(id1), Some(id2)) if id1 == id2 => Failed(None),\n-                _ => Indeterminate\n-            },\n-        }\n-    }\n-\n     fn resolve_single_import(&mut self,\n                              module_: Module<'b>,\n                              target_module: Module<'b>,\n@@ -448,11 +391,23 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             }\n         };\n \n+        // If this is a circular import, we temporarily count it as determined so that\n+        // it fails (as opposed to being indeterminate) when nothing else can define it.\n+        if target_module.def_id() == module_.def_id() && source == target {\n+            module_.decrement_outstanding_references_for(target, ValueNS);\n+            module_.decrement_outstanding_references_for(target, TypeNS);\n+        }\n+\n         // We need to resolve both namespaces for this to succeed.\n         let value_result =\n-            self.resolve_name_in_module(target_module, source, ValueNS, module_);\n+            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n         let type_result =\n-            self.resolve_name_in_module(target_module, source, TypeNS, module_);\n+            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+\n+        if target_module.def_id() == module_.def_id() && source == target {\n+            module_.increment_outstanding_references_for(target, ValueNS);\n+            module_.increment_outstanding_references_for(target, TypeNS);\n+        }\n \n         match (&value_result, &type_result) {\n             (&Success(name_binding), _) if !name_binding.is_import() &&\n@@ -488,82 +443,32 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n-        let mut lev_suggestion = \"\".to_owned();\n         match (&value_result, &type_result) {\n             (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n             (&Failed(_), &Failed(_)) => {\n                 let children = target_module.children.borrow();\n                 let names = children.keys().map(|&(ref name, _)| name);\n-                if let Some(name) = find_best_match_for_name(names, &source.as_str(), None) {\n-                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n-                } else {\n-                    let resolutions = target_module.import_resolutions.borrow();\n-                    let names = resolutions.keys().map(|&(ref name, _)| name);\n-                    if let Some(name) = find_best_match_for_name(names,\n-                                                                 &source.as_str(),\n-                                                                 None) {\n-                        lev_suggestion =\n-                            format!(\". Did you mean to use the re-exported import `{}`?\", name);\n-                    }\n-                }\n+                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n+                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                    None => \"\".to_owned(),\n+                };\n+                let msg = format!(\"There is no `{}` in `{}`{}\",\n+                                  source,\n+                                  module_to_string(target_module), lev_suggestion);\n+                return Failed(Some((directive.span, msg)));\n             }\n             _ => (),\n         }\n \n-        // We've successfully resolved the import. Write the results in.\n-\n-        {\n-            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            let mut check_and_write_import = |namespace, result| {\n-                let result: &ResolveResult<&NameBinding> = result;\n-\n-                let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n-                let namespace_name = match namespace {\n-                    TypeNS => \"type\",\n-                    ValueNS => \"value\",\n-                };\n-\n-                match *result {\n-                    Success(name_binding) => {\n-                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n-                               namespace_name,\n-                               name_binding.def());\n-                        self.check_for_conflicting_import(&import_resolution,\n-                                                          directive.span,\n-                                                          target,\n-                                                          namespace);\n-\n-                        self.check_that_import_is_importable(&name_binding,\n-                                                             directive.span,\n-                                                             target);\n-\n-                        import_resolution.binding =\n-                            Some(self.resolver.new_name_binding(directive.import(name_binding)));\n-\n-                        self.add_export(module_, target, import_resolution.binding.unwrap());\n-                    }\n-                    Failed(_) => {\n-                        // Continue.\n-                    }\n-                    Indeterminate => {\n-                        panic!(\"{:?} result should be known at this point\", namespace_name);\n-                    }\n+        for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n+            if let Success(binding) = *result {\n+                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                    let msg = format!(\"`{}` is not directly importable\", target);\n+                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                self.check_for_conflicts_between_imports_and_items(module_,\n-                                                                   import_resolution,\n-                                                                   directive.span,\n-                                                                   (target, namespace));\n-            };\n-            check_and_write_import(ValueNS, &value_result);\n-            check_and_write_import(TypeNS, &type_result);\n-        }\n-\n-        if let (&Failed(_), &Failed(_)) = (&value_result, &type_result) {\n-            let msg = format!(\"There is no `{}` in `{}`{}\",\n-                              source,\n-                              module_to_string(target_module), lev_suggestion);\n-            return Failed(Some((directive.span, msg)));\n+                self.define(module_, target, ns, directive.import(binding));\n+            }\n         }\n \n         let value_def_and_priv = {\n@@ -624,74 +529,41 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           import_directive: &ImportDirective,\n+                           directive: &ImportDirective,\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n-        let id = import_directive.id;\n-\n-        // This function works in a highly imperative manner; it eagerly adds\n-        // everything it can to the list of import resolutions of the module\n-        // node.\n-        debug!(\"(resolving glob import) resolving glob import {}\", id);\n-\n-        // We must bail out if the node has unresolved imports of any kind\n-        // (including globs).\n-        if (*target_module).pub_count.get() > 0 {\n+        // We must bail out if the node has unresolved imports of any kind (including globs).\n+        if target_module.pub_count.get() > 0 {\n             debug!(\"(resolving glob import) target module has unresolved pub imports; bailing out\");\n-            return ResolveResult::Indeterminate;\n-        }\n-\n-        // Add all resolved imports from the containing module.\n-        let import_resolutions = target_module.import_resolutions.borrow();\n-\n-        if module_.import_resolutions.borrow_state() != ::std::cell::BorrowState::Unused {\n-            // In this case, target_module == module_\n-            // This means we are trying to glob import a module into itself,\n-            // and it is a no-go\n-            debug!(\"(resolving glob imports) target module is current module; giving up\");\n-            return ResolveResult::Failed(Some((import_directive.span,\n-                                               \"Cannot glob-import a module into itself.\".into())));\n+            return Indeterminate;\n         }\n \n-        for (&(name, ns), target_import_resolution) in import_resolutions.iter() {\n-            debug!(\"(resolving glob import) writing module resolution {} into `{}`\",\n-                   name,\n-                   module_to_string(module_));\n-\n-            // Here we merge two import resolutions.\n-            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            let mut dest_import_resolution =\n-                import_resolutions.entry((name, ns))\n-                                  .or_insert_with(|| NameResolution::default());\n-\n-            match target_import_resolution.binding {\n-                Some(binding) if binding.is_public() => {\n-                    self.check_for_conflicting_import(&dest_import_resolution,\n-                                                      import_directive.span,\n-                                                      name,\n-                                                      ns);\n-                    dest_import_resolution.binding =\n-                        Some(self.resolver.new_name_binding(import_directive.import(binding)));\n-                    self.add_export(module_, name, dest_import_resolution.binding.unwrap());\n-                }\n-                _ => {}\n-            }\n+        if module_.def_id() == target_module.def_id() {\n+            // This means we are trying to glob import a module into itself, and it is a no-go\n+            let msg = \"Cannot glob-import a module into itself.\".into();\n+            return Failed(Some((directive.span, msg)));\n         }\n \n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n-\n-        target_module.for_each_local_child(|name, ns, name_binding| {\n-            self.merge_import_resolution(module_,\n-                                         target_module,\n-                                         import_directive,\n-                                         (name, ns),\n-                                         name_binding);\n+        target_module.for_each_child(|name, ns, binding| {\n+            if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n+            self.define(module_, name, ns, directive.import(binding));\n+\n+            if ns == TypeNS && directive.is_public &&\n+               binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n+                                   E0364), consider declaring its enum as `pub`\", name);\n+                self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               directive.id,\n+                                               directive.span,\n+                                               msg);\n+            }\n         });\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n-            self.resolver.def_map.borrow_mut().insert(id,\n+            self.resolver.def_map.borrow_mut().insert(directive.id,\n                                                       PathResolution {\n                                                           base_def: Def::Mod(did),\n                                                           last_private: lp,\n@@ -700,61 +572,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n-        return ResolveResult::Success(());\n-    }\n-\n-    fn merge_import_resolution(&mut self,\n-                               module_: Module<'b>,\n-                               containing_module: Module<'b>,\n-                               import_directive: &ImportDirective,\n-                               (name, ns): (Name, Namespace),\n-                               name_binding: &'b NameBinding<'b>) {\n-        let is_public = import_directive.is_public;\n-\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry((name, ns)).or_insert_with(|| {\n-            NameResolution::default()\n-        });\n-\n-        debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n-               name,\n-               module_to_string(&*containing_module),\n-               module_to_string(module_));\n-\n-        // Merge the child item into the import resolution.\n-        let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n-\n-        if ns == TypeNS && is_public && name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-            let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n-                               E0364), consider declaring its enum as `pub`\", name);\n-            self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           import_directive.id,\n-                                           import_directive.span,\n-                                           msg);\n-        }\n-\n-        if name_binding.defined_with(modifier) {\n-            let namespace_name = match ns {\n-                TypeNS => \"type\",\n-                ValueNS => \"value\",\n-            };\n-            debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n-            if dest_import_resolution.shadowable() == Shadowable::Never {\n-                let msg = format!(\"a {} named `{}` has already been imported in this module\",\n-                                 namespace_name,\n-                                 name);\n-                span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n-            } else {\n-                dest_import_resolution.binding =\n-                    Some(self.resolver.new_name_binding(import_directive.import(name_binding)));\n-                self.add_export(module_, name, dest_import_resolution.binding.unwrap());\n-            }\n-        }\n-\n-        self.check_for_conflicts_between_imports_and_items(module_,\n-                                                           dest_import_resolution,\n-                                                           import_directive.span,\n-                                                           (name, ns));\n+        return Success(());\n     }\n \n     fn add_export(&mut self, module: Module<'b>, name: Name, binding: &NameBinding<'b>) {\n@@ -770,119 +588,70 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         self.resolver.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n     }\n \n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &NameResolution,\n-                                    import_span: Span,\n-                                    name: Name,\n-                                    namespace: Namespace) {\n-        let binding = &import_resolution.binding;\n-        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               name,\n-               binding.is_some());\n-\n-        match *binding {\n-            Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n-                let ns_word = match namespace {\n-                    TypeNS => {\n-                        match binding.module() {\n-                            Some(ref module) if module.is_normal() => \"module\",\n-                            Some(ref module) if module.is_trait() => \"trait\",\n-                            _ => \"type\",\n-                        }\n-                    }\n-                    ValueNS => \"value\",\n-                };\n-                let mut err = struct_span_err!(self.resolver.session,\n-                                               import_span,\n-                                               E0252,\n-                                               \"a {} named `{}` has already been imported \\\n-                                                in this module\",\n-                                               ns_word,\n-                                               name);\n-                span_note!(&mut err,\n-                           binding.span.unwrap(),\n-                           \"previous import of `{}` here\",\n-                           name);\n-                err.emit();\n-            }\n-            Some(_) | None => {}\n-        }\n-    }\n-\n-    /// Checks that an import is actually importable\n-    fn check_that_import_is_importable(&mut self,\n-                                       name_binding: &NameBinding,\n-                                       import_span: Span,\n-                                       name: Name) {\n-        if !name_binding.defined_with(DefModifiers::IMPORTABLE) {\n-            let msg = format!(\"`{}` is not directly importable\", name);\n-            span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n+    fn define(&mut self,\n+              parent: Module<'b>,\n+              name: Name,\n+              ns: Namespace,\n+              binding: NameBinding<'b>) {\n+        let binding = self.resolver.new_name_binding(binding);\n+        if let Err(old_binding) = parent.try_define_child(name, ns, binding) {\n+            self.report_conflict(name, ns, binding, old_binding);\n+        } else if binding.is_public() {\n+            self.add_export(parent, name, binding);\n         }\n     }\n \n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: Module<'b>,\n-                                                     import: &NameResolution<'b>,\n-                                                     import_span: Span,\n-                                                     (name, ns): (Name, Namespace)) {\n-        // Check for item conflicts.\n-        let name_binding = match module.get_child(name, ns) {\n-            None => {\n-                // There can't be any conflicts.\n-                return;\n-            }\n-            Some(name_binding) => name_binding,\n-        };\n-\n-        if ns == ValueNS {\n-            match import.binding {\n-                Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n-                    let mut err = struct_span_err!(self.resolver.session,\n-                                                   import_span,\n-                                                   E0255,\n-                                                   \"import `{}` conflicts with \\\n-                                                    value in this module\",\n-                                                   name);\n-                    if let Some(span) = name_binding.span {\n-                        err.span_note(span, \"conflicting value here\");\n-                    }\n-                    err.emit();\n-                }\n-                Some(_) | None => {}\n-            }\n-        } else {\n-            match import.binding {\n-                Some(binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n-                    if name_binding.is_extern_crate() {\n-                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n-                                           in this module (maybe you meant `use {0}::*`?)\",\n-                                          name);\n-                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n-                        return;\n-                    }\n-\n-                    let (what, note) = match name_binding.module() {\n-                        Some(ref module) if module.is_normal() =>\n-                            (\"existing submodule\", \"note conflicting module here\"),\n-                        Some(ref module) if module.is_trait() =>\n-                            (\"trait in this module\", \"note conflicting trait here\"),\n-                        _ => (\"type in this module\", \"note conflicting type here\"),\n-                    };\n-                    let mut err = struct_span_err!(self.resolver.session,\n-                                                   import_span,\n-                                                   E0256,\n-                                                   \"import `{}` conflicts with {}\",\n-                                                   name,\n-                                                   what);\n-                    if let Some(span) = name_binding.span {\n-                        err.span_note(span, note);\n-                    }\n-                    err.emit();\n-                }\n-                Some(_) | None => {}\n-            }\n+    fn report_conflict(&mut self,\n+                       name: Name,\n+                       ns: Namespace,\n+                       binding: &'b NameBinding<'b>,\n+                       old_binding: &'b NameBinding<'b>) {\n+        if old_binding.is_extern_crate() {\n+            let msg = format!(\"import `{0}` conflicts with imported crate \\\n+                               in this module (maybe you meant `use {0}::*`?)\",\n+                              name);\n+            span_err!(self.resolver.session, binding.span.unwrap(), E0254, \"{}\", &msg);\n+        } else if old_binding.is_import() {\n+            let ns_word = match (ns, old_binding.module()) {\n+                (ValueNS, _) => \"value\",\n+                (TypeNS, Some(module)) if module.is_normal() => \"module\",\n+                (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n+                (TypeNS, _) => \"type\",\n+            };\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0252,\n+                                           \"a {} named `{}` has already been imported \\\n+                                            in this module\",\n+                                           ns_word,\n+                                           name);\n+            err.span_note(old_binding.span.unwrap(),\n+                          &format!(\"previous import of `{}` here\", name));\n+            err.emit();\n+        } else if ns == ValueNS { // Check for item conflicts in the value namespace\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0255,\n+                                           \"import `{}` conflicts with value in this module\",\n+                                           name);\n+            err.span_note(old_binding.span.unwrap(), \"conflicting value here\");\n+            err.emit();\n+        } else { // Check for item conflicts in the type namespace\n+            let (what, note) = match old_binding.module() {\n+                Some(ref module) if module.is_normal() =>\n+                    (\"existing submodule\", \"note conflicting module here\"),\n+                Some(ref module) if module.is_trait() =>\n+                    (\"trait in this module\", \"note conflicting trait here\"),\n+                _ => (\"type in this module\", \"note conflicting type here\"),\n+            };\n+            let mut err = struct_span_err!(self.resolver.session,\n+                                           binding.span.unwrap(),\n+                                           E0256,\n+                                           \"import `{}` conflicts with {}\",\n+                                           name,\n+                                           what);\n+            err.span_note(old_binding.span.unwrap(), note);\n+            err.emit();\n         }\n     }\n }"}, {"sha": "923f95e69d122bb417f7361c34126658c10ffcc2", "filename": "src/test/compile-fail/double-type-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs?ref=7000e708252bd9e45f28926d8fd38cc9ec054e57", "patch": "@@ -20,5 +20,5 @@ mod foo {\n }\n \n fn main() {\n-    let _ = foo::X; //~ ERROR unresolved name `foo::X`\n+    let _ = foo::X;\n }"}, {"sha": "b60d19fcab4aac6152f28133e3d10ed40bded478", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7000e708252bd9e45f28926d8fd38cc9ec054e57/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=7000e708252bd9e45f28926d8fd38cc9ec054e57", "patch": "@@ -14,9 +14,9 @@ use foo::bar; //~ ERROR unresolved import `foo::bar`. Maybe a missing `extern cr\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz`. There is no `Baz` in `bar`. Did you mean to use `Bar`?\n \n-use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`. Did you mean to use the re-exported import `bag`?\n+use food::baz; //~ ERROR unresolved import `food::baz`. There is no `baz` in `food`. Did you mean to use `bag`?\n \n-use food::{beens as Foo}; //~ ERROR unresolved import `food::beens`. There is no `beens` in `food`. Did you mean to use the re-exported import `beans`?\n+use food::{beens as Foo}; //~ ERROR unresolved import `food::beens`. There is no `beens` in `food`. Did you mean to use `beans`?\n \n mod bar {\n     pub struct Bar;"}]}