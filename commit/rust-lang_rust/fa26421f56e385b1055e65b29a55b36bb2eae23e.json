{"sha": "fa26421f56e385b1055e65b29a55b36bb2eae23e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMjY0MjFmNTZlMzg1YjEwNTVlNjViMjlhNTViMzZiYjJlYWUyM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-15T20:18:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-15T20:18:13Z"}, "message": "Auto merge of #45938 - vramana:fix-ice-45698, r=arielb1\n\nFix End-user description not implemented for field access on `TyClosure\n\n- [x] Add Tests", "tree": {"sha": "8f3349f92be558164753a31ec5d854d9964baf35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f3349f92be558164753a31ec5d854d9964baf35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa26421f56e385b1055e65b29a55b36bb2eae23e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa26421f56e385b1055e65b29a55b36bb2eae23e", "html_url": "https://github.com/rust-lang/rust/commit/fa26421f56e385b1055e65b29a55b36bb2eae23e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa26421f56e385b1055e65b29a55b36bb2eae23e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88a28ff6028cf197ed6b4185d8cd4887f05e3e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/88a28ff6028cf197ed6b4185d8cd4887f05e3e07", "html_url": "https://github.com/rust-lang/rust/commit/88a28ff6028cf197ed6b4185d8cd4887f05e3e07"}, {"sha": "5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "url": "https://api.github.com/repos/rust-lang/rust/commits/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63", "html_url": "https://github.com/rust-lang/rust/commit/5144d3222f76b1f0b7c4bffbff5ebc40a29c3c63"}], "stats": {"total": 111, "additions": 80, "deletions": 31}, "files": [{"sha": "2a7a62cd64b59e937b3dec67f234d73002f29b51", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 56, "deletions": 31, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=fa26421f56e385b1055e65b29a55b36bb2eae23e", "patch": "@@ -1021,7 +1021,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                      access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n                                      flow_state: &InProgress<'b, 'gcx, 'tcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue<'tcx>) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -1248,7 +1248,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: &str,\n-                           (lvalue, span): (&Lvalue, Span),\n+                           (lvalue, span): (&Lvalue<'tcx>, Span),\n                            mpi: MovePathIndex,\n                            curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n \n@@ -1290,8 +1290,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_move_out_while_borrowed(&mut self,\n                                       _context: Context,\n-                                      (lvalue, span): (&Lvalue, Span),\n-                                      borrow: &BorrowData) {\n+                                      (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                      borrow: &BorrowData<'tcx>) {\n         self.tcx.cannot_move_when_borrowed(span,\n                                            &self.describe_lvalue(lvalue),\n                                            Origin::Mir)\n@@ -1305,8 +1305,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Lvalue, Span),\n-                                         borrow : &BorrowData) {\n+                                         (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                         borrow : &BorrowData<'tcx>) {\n \n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n             span, &self.describe_lvalue(lvalue),\n@@ -1382,8 +1382,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_conflicting_borrow(&mut self,\n                                  context: Context,\n-                                 common_prefix: &Lvalue,\n-                                 (lvalue, span): (&Lvalue, Span),\n+                                 common_prefix: &Lvalue<'tcx>,\n+                                 (lvalue, span): (&Lvalue<'tcx>, Span),\n                                  gen_borrow_kind: BorrowKind,\n                                  issued_borrow: &BorrowData,\n                                  end_issued_loan_span: Option<Span>) {\n@@ -1453,7 +1453,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n-                                           (lvalue, span): (&Lvalue, Span),\n+                                           (lvalue, span): (&Lvalue<'tcx>, Span),\n                                            loan: &BorrowData) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span, self.retrieve_borrow_span(loan), &self.describe_lvalue(lvalue), Origin::Mir);\n@@ -1463,7 +1463,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_illegal_reassignment(&mut self,\n                                    _context: Context,\n-                                   (lvalue, span): (&Lvalue, Span),\n+                                   (lvalue, span): (&Lvalue<'tcx>, Span),\n                                    assigned_span: Span) {\n         self.tcx.cannot_reassign_immutable(span,\n                                            &self.describe_lvalue(lvalue),\n@@ -1474,7 +1474,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 .emit();\n     }\n \n-    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+    fn report_assignment_to_static(&mut self,\n+                                   _context: Context,\n+                                   (lvalue, span): (&Lvalue<'tcx>, Span)) {\n         let mut err = self.tcx.cannot_assign_static(\n             span, &self.describe_lvalue(lvalue), Origin::Mir);\n         err.emit();\n@@ -1483,14 +1485,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     // End-user visible description of `lvalue`\n-    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+    fn describe_lvalue(&self, lvalue: &Lvalue<'tcx>) -> String {\n         let mut buf = String::new();\n         self.append_lvalue_to_string(lvalue, &mut buf, None);\n         buf\n     }\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String, autoderef: Option<bool>) {\n+    fn append_lvalue_to_string(&self,\n+                               lvalue: &Lvalue<'tcx>,\n+                               buf: &mut String,\n+                               autoderef: Option<bool>) {\n         match *lvalue {\n             Lvalue::Local(local) => {\n                 self.append_local_to_string(local, buf, \"_\");\n@@ -1500,41 +1505,50 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n             Lvalue::Projection(ref proj) => {\n                 let mut autoderef = autoderef.unwrap_or(false);\n-                let (prefix, suffix, index_operand) = match proj.elem {\n+\n+                match proj.elem {\n                     ProjectionElem::Deref => {\n                         if autoderef {\n-                            (\"\", format!(\"\"), None)\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n                         } else {\n-                            (\"(*\", format!(\")\"), None)\n+                            buf.push_str(&\"(*\");\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                            buf.push_str(&\")\");\n                         }\n                     },\n-                    ProjectionElem::Downcast(..) =>\n-                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Downcast(..) => {\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                    },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n-                        (\"\", format!(\".{}\", self.describe_field(&proj.base, field.index())), None)\n+                        let is_projection_from_ty_closure = proj.base.ty(self.mir, self.tcx)\n+                                .to_ty(self.tcx).is_closure();\n+\n+                        let field_name = self.describe_field(&proj.base, field.index());\n+                        if is_projection_from_ty_closure {\n+                            buf.push_str(&format!(\"{}\", field_name));\n+                        } else {\n+                            self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                            buf.push_str(&format!(\".{}\", field_name));\n+                        }\n                     },\n                     ProjectionElem::Index(index) => {\n                         autoderef = true;\n-                        (\"\",   format!(\"\"), Some(index))\n+\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                        buf.push_str(\"[\");\n+                        self.append_local_to_string(index, buf, \"..\");\n+                        buf.push_str(\"]\");\n                     },\n                     ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n                         autoderef = true;\n                         // Since it isn't possible to borrow an element on a particular index and\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n-                        (\"\",   format!(\"[..]\"), None)\n+                        self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n+                        buf.push_str(&\"[..]\");\n                     },\n                 };\n-                buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n-                if let Some(index) = index_operand {\n-                    buf.push_str(\"[\");\n-                    self.append_local_to_string(index, buf, \"..\");\n-                    buf.push_str(\"]\");\n-                } else {\n-                    buf.push_str(&suffix);\n-                }\n             }\n         }\n     }\n@@ -1549,6 +1563,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         }\n     }\n \n+    // FIXME Instead of passing usize, Field should be passed\n     // End-user visible description of the `field_index`nth field of `base`\n     fn describe_field(&self, base: &Lvalue, field_index: usize) -> String {\n         match *base {\n@@ -1600,7 +1615,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 },\n                 ty::TyArray(ty, _) | ty::TySlice(ty) => {\n                     self.describe_field_from_ty(&ty, field_index)\n-                }\n+                },\n+                ty::TyClosure(closure_def_id, _) => {\n+                    // Convert the def-id into a node-id. node-ids are only valid for\n+                    // the local code in the current crate, so this returns an `Option` in case\n+                    // the closure comes from another crate. But in that case we wouldn't\n+                    // be borrowck'ing it, so we can just unwrap:\n+                    let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n+                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field_index]);\n+\n+                    self.tcx.hir.name(freevar.var_id()).to_string()\n+                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n                     // (https://github.com/rust-lang/rfcs/pull/1546)"}, {"sha": "06d61242ec2f88ef892fd01916c9d174f30aa99b", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=fa26421f56e385b1055e65b29a55b36bb2eae23e", "patch": "@@ -327,4 +327,28 @@ fn main() {\n             _ => panic!(\"other case\")\n         }\n     }\n+    // Field from upvar\n+    {\n+        let mut x = 0;\n+        || {\n+            let y = &mut x;\n+            &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n+                    //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n+                    //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n+            *y = 1;\n+        };\n+    }\n+    // Field from upvar nested\n+    {\n+        let mut x = 0;\n+           || {\n+               || {\n+                let y = &mut x;\n+                &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n+                        //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n+                        //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n+                *y = 1;\n+                }\n+           };\n+    }\n }"}]}