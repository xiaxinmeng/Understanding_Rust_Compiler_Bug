{"sha": "16e4fef9bf195351673ac664cff5ba97c766d0ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTRmZWY5YmYxOTUzNTE2NzNhYzY2NGNmZjViYTk3Yzc2NmQwYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T06:58:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T06:58:35Z"}, "message": "auto merge of #20158 : nikomatsakis/rust/fn-inference-refactor, r=eddyb\n\nVarious refactorings simplifying the mem-categorization and regionck interface. This is working towards an improvement for closure-and-upvar-mode inference.\r\n\r\nr? @eddyb", "tree": {"sha": "f2ff59404589fa3f7a4747e0551344a131fbc60d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2ff59404589fa3f7a4747e0551344a131fbc60d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e4fef9bf195351673ac664cff5ba97c766d0ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e4fef9bf195351673ac664cff5ba97c766d0ad", "html_url": "https://github.com/rust-lang/rust/commit/16e4fef9bf195351673ac664cff5ba97c766d0ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e4fef9bf195351673ac664cff5ba97c766d0ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18842f89f084c52588fe7cffe07f87bf6e90796a", "url": "https://api.github.com/repos/rust-lang/rust/commits/18842f89f084c52588fe7cffe07f87bf6e90796a", "html_url": "https://github.com/rust-lang/rust/commit/18842f89f084c52588fe7cffe07f87bf6e90796a"}, {"sha": "4856456dd7db4ae43bb4fd14c46b5d59e36cc37c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4856456dd7db4ae43bb4fd14c46b5d59e36cc37c", "html_url": "https://github.com/rust-lang/rust/commit/4856456dd7db4ae43bb4fd14c46b5d59e36cc37c"}], "stats": {"total": 473, "additions": 202, "deletions": 271}, "files": [{"sha": "c7dd4dd26469c5b761bf13c65d897017cb8407bf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 49, "deletions": 82, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -302,22 +302,6 @@ pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n     param_env: ParameterEnvironment<'tcx>,\n }\n \n-// If the TYPER results in an error, it's because the type check\n-// failed (or will fail, when the error is uncovered and reported\n-// during writeback). In this case, we just ignore this part of the\n-// code.\n-//\n-// Note that this macro appears similar to try!(), but, unlike try!(),\n-// it does not propagate the error.\n-macro_rules! return_if_err {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => v,\n-            Err(()) => return\n-        }\n-    )\n-}\n-\n /// Whether the elements of an overloaded operation are passed by value or by reference\n enum PassArgs {\n     ByValue,\n@@ -348,7 +332,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n         for arg in decl.inputs.iter() {\n-            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n+            let arg_ty = self.typer.node_ty(arg.pat.id);\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -385,7 +369,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate_consume(expr.id, expr.span, cmt);\n         self.walk_expr(expr);\n     }\n@@ -394,7 +378,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    assignment_expr: &ast::Expr,\n                    expr: &ast::Expr,\n                    mode: MutateMode) {\n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n         self.walk_expr(expr);\n     }\n@@ -407,7 +391,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n                expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n \n         // Note: Unlike consume, we can ignore ExprParen. cat_expr\n@@ -500,7 +484,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n+                let discr_cmt = self.mc.cat_expr(&**discr);\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -559,7 +543,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Fetch the type of the value that the iteration yields to\n                 // produce the pattern's categorized mutable type.\n-                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n+                let pattern_type = self.typer.node_ty(pat.id);\n                 let blk_scope = region::CodeExtent::from_node_id(blk.id);\n                 let pat_cmt = self.mc.cat_rvalue(pat.id,\n                                                  pat.span,\n@@ -647,7 +631,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n-        let callee_ty = ty::expr_ty_adjusted(self.tcx(), callee);\n+        let callee_ty = self.typer.expr_ty_adjusted(callee);\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n@@ -670,22 +654,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.tcx()\n-                              .method_map\n-                              .borrow()\n-                              .get(&MethodCall::expr(call.id)) {\n-                    Some(ref method_callee) => {\n-                        OverloadedCallType::from_method_origin(\n-                            self.tcx(),\n-                            &method_callee.origin)\n-                    }\n-                    None => {\n-                        self.tcx().sess.span_bug(\n-                            callee.span,\n-                            format!(\"unexpected callee type {}\",\n-                                    callee_ty.repr(self.tcx()))[])\n-                    }\n-                };\n+                    match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n+                        Some(method_origin) => {\n+                            OverloadedCallType::from_method_origin(\n+                                self.tcx(),\n+                                &method_origin)\n+                        }\n+                        None => {\n+                            self.tcx().sess.span_bug(\n+                                callee.span,\n+                                format!(\"unexpected callee type {}\",\n+                                        callee_ty.repr(self.tcx())).as_slice())\n+                        }\n+                    };\n                 match overloaded_call_type {\n                     FnMutOverloadedCall => {\n                         self.borrow_expr(callee,\n@@ -747,7 +728,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n+                let init_cmt = self.mc.cat_expr(&**expr);\n                 self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n@@ -781,7 +762,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n+        let with_cmt = self.mc.cat_expr(&*with_expr);\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -836,7 +817,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n-                            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                            self.mc.cat_expr_unadjusted(expr);\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n                     ty::AdjustDerefRef(ty::AutoDerefRef {\n@@ -870,7 +851,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n-                    let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n+                    let cmt = self.mc.cat_expr_autoderefd(expr, i);\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n@@ -900,15 +881,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n                                          AutoRefs, found: {}\", n));\n                 let cmt_unadjusted =\n-                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                    self.mc.cat_expr_unadjusted(expr);\n                 self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 return;\n             }\n             _ => {}\n         }\n \n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, n));\n+        let cmt_derefd = self.mc.cat_expr_autoderefd(expr, n);\n         debug!(\"walk_adjustment: cmt_derefd={}\",\n                cmt_derefd.repr(self.tcx()));\n \n@@ -1001,7 +981,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                mode: &mut TrackMatchMode<Span>) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+        self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.typer.tcx();\n             let def_map = &self.typer.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n@@ -1024,7 +1004,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n-        }));\n+        });\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n@@ -1039,11 +1019,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         let mc = &self.mc;\n         let typer = self.typer;\n-        let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n         let param_env = &mut self.param_env;\n-        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+\n+        mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -1053,17 +1033,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n+                let pat_ty = typer.node_ty(pat.id);\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = def_map.borrow()[pat.id].clone();\n-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n-                    Ok(binding_cmt) => {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n-                    }\n-                    Err(_) => { }\n-                }\n+                let binding_cmt = mc.cat_def(pat.id, pat.span, pat_ty, def);\n+                delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n@@ -1097,15 +1073,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // borrow of the elements of the vector being\n                         // matched.\n \n-                        let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, &**slice_pat) {\n-                                Ok(v) => v,\n-                                Err(()) => {\n-                                    tcx.sess.span_bug(slice_pat.span,\n-                                                      \"Err from mc\")\n-                                }\n-                            }\n-                        };\n+                        let (slice_cmt, slice_mutbl, slice_r) =\n+                            mc.cat_slice_pattern(cmt_pat, &**slice_pat);\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`\n@@ -1135,13 +1104,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     _ => { }\n                 }\n             }\n-        }));\n+        });\n \n         // Do a second pass over the pattern, calling `matched_pat` on\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n             let tcx = typer.tcx();\n \n@@ -1222,7 +1191,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // cases either.\n                 }\n             }\n-        }));\n+        });\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n@@ -1246,15 +1215,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n+            let cmt_var = self.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                freevar.def);\n \n             // Lookup the kind of borrow the callee requires, as\n             // inferred by regionbk\n             let upvar_id = ty::UpvarId { var_id: id_var,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()[upvar_id].clone();\n+            let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n \n             self.delegate.borrow(closure_expr.id,\n                                  closure_expr.span,\n@@ -1269,13 +1238,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                               closure_expr: &ast::Expr,\n                               freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-            let mode = copy_or_move(self.tcx(),\n-                                    cmt_var.ty,\n-                                    &self.param_env,\n-                                    CaptureMove);\n+            let cmt_var = self.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                freevar.def);\n+            let mode = copy_or_move(self.tcx(), cmt_var.ty,\n+                                    &self.param_env, CaptureMove);\n             self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }\n@@ -1284,11 +1251,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::McResult<mc::cmt<'tcx>> {\n+                        -> mc::cmt<'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n-        let var_ty = try!(self.typer.node_ty(var_id));\n+        let var_ty = self.typer.node_ty(var_id);\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "9f7472c2c73482948addab1b290c4320f8baecab", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -264,8 +264,6 @@ pub struct MemCategorizationContext<'t,TYPER:'t> {\n \n impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n \n-pub type McResult<T> = Result<T, ()>;\n-\n /// The `Typer` trait provides the interface for the mem-categorization\n /// module to the results of the type check. It can be used to query\n /// the type assigned to an expression node, to inquire after adjustments,\n@@ -284,8 +282,11 @@ pub type McResult<T> = Result<T, ()>;\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n@@ -374,15 +375,6 @@ impl MutabilityCategory {\n     }\n }\n \n-macro_rules! if_ok {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-}\n-\n impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n         MemCategorizationContext { typer: typer }\n@@ -392,22 +384,22 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = if_ok!(self.expr_ty(expr));\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().get(&expr.id),\n-                         |method_call| self.typer.node_method_ty(method_call)))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        let unadjusted_ty = self.expr_ty(expr);\n+        ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n+                      self.typer.adjustments().borrow().get(&expr.id),\n+                      |method_call| self.typer.node_method_ty(method_call))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> Ty<'tcx> {\n         let tcx = self.typer.tcx();\n         let base_ty = self.typer.node_ty(pat.id);\n         // FIXME (Issue #18207): This code detects whether we are\n@@ -419,11 +411,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                base_ty.map(|t| {\n-                    ty::deref(t, false).unwrap_or_else(|| {\n-                        panic!(\"encountered BindByRef with non &-type\");\n-                    }).ty\n-                })\n+                ty::deref(base_ty, false).unwrap_or_else(|| {\n+                    panic!(\"encountered BindByRef with non &-type\");\n+                }).ty\n             }\n             _ => base_ty,\n         };\n@@ -432,7 +422,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         ret_ty\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt<'tcx> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -446,8 +436,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+                        let expr_ty = self.expr_ty_adjusted(expr);\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -457,8 +447,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+                        let expr_ty = self.expr_ty_adjusted(expr);\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -475,39 +465,39 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> McResult<cmt<'tcx>> {\n-        let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n+                               -> cmt<'tcx> {\n+        let mut cmt = self.cat_expr_unadjusted(expr);\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref, false);\n         }\n-        return Ok(cmt);\n+        return cmt;\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt<'tcx> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n-        let expr_ty = if_ok!(self.expr_ty(expr));\n+        let expr_ty = self.expr_ty(expr);\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**e_base));\n-            Ok(self.cat_deref(expr, base_cmt, 0, false))\n+            let base_cmt = self.cat_expr(&**e_base);\n+            self.cat_deref(expr, base_cmt, 0, false)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**base));\n+            let base_cmt = self.cat_expr(&**base);\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n                    expr.repr(self.tcx()),\n                    base_cmt.repr(self.tcx()));\n-            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n+            self.cat_field(expr, base_cmt, f_name.node.name, expr_ty)\n           }\n \n           ast::ExprTupField(ref base, idx) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**base));\n-            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n+            let base_cmt = self.cat_expr(&**base);\n+            self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n           }\n \n           ast::ExprIndex(ref base, _) => {\n@@ -517,14 +507,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // If this is an index implemented by a method call, then it will\n                     // include an implicit deref of the result.\n                     let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                    Ok(self.cat_deref(expr,\n-                                      self.cat_rvalue_node(expr.id(),\n-                                                           expr.span(),\n-                                                           ret_ty), 1, true))\n+                    self.cat_deref(expr,\n+                                   self.cat_rvalue_node(expr.id(),\n+                                                        expr.span(),\n+                                                        ret_ty), 1, true)\n                 }\n                 None => {\n-                    let base_cmt = if_ok!(self.cat_expr(&**base));\n-                    Ok(self.cat_index(expr, base_cmt))\n+                    let base_cmt = self.cat_expr(&**base);\n+                    self.cat_index(expr, base_cmt)\n                 }\n             }\n           }\n@@ -550,7 +540,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n           ast::ExprForLoop(..) => {\n-            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+            self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n           }\n \n           ast::ExprIfLet(..) => {\n@@ -567,43 +557,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> McResult<cmt<'tcx>> {\n+                   -> cmt<'tcx> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n           def::DefStaticMethod(..) | def::DefConst(..) => {\n-                Ok(self.cat_rvalue_node(id, span, expr_ty))\n+                self.cat_rvalue_node(id, span, expr_ty)\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n-              Ok(Rc::new(cmt_ {\n+              Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           def::DefStatic(_, mutbl) => {\n-              Ok(Rc::new(cmt_ {\n+              Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n-              let ty = if_ok!(self.node_ty(fn_node_id));\n+              let ty = self.node_ty(fn_node_id);\n               match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n@@ -641,14 +631,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           def::DefLocal(vid) => {\n-            Ok(Rc::new(cmt_ {\n+            Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            }))\n+            })\n           }\n         }\n     }\n@@ -663,7 +653,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> McResult<cmt<'tcx>> {\n+                 -> cmt<'tcx> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -685,7 +675,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n-        let var_ty = if_ok!(self.node_ty(var_id));\n+        let var_ty = self.node_ty(var_id);\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n@@ -733,7 +723,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         });\n \n         // First, switch by capture mode\n-        Ok(match mode {\n+        match mode {\n             ast::CaptureByValue => {\n                 let mut base = cmt_ {\n                     id: id,\n@@ -815,7 +805,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteUpvarRef(upvar_id)\n                 })\n             }\n-        })\n+        }\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -1064,13 +1054,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n-        let slice_ty = if_ok!(self.node_ty(slice_pat.id));\n+                             -> (cmt<'tcx>, ast::Mutability, ty::Region) {\n+        let slice_ty = self.node_ty(slice_pat.id);\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n         let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n-        return Ok((cmt_slice, slice_mutbl, slice_r));\n+        return (cmt_slice, slice_mutbl, slice_r);\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n@@ -1130,7 +1120,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n                        op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n-                       -> McResult<()> {\n+    {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -1210,30 +1200,30 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Some(&def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        if_ok!(self.cat_pattern(cmt_field, &**subpat,\n-                                                |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(cmt_field, &**subpat,\n+                                         |x,y,z| op(x,y,z));\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z));\n                     }\n                 }\n                 _ => {\n@@ -1245,7 +1235,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              if_ok!(self.cat_pattern(cmt, &**subpat, op));\n+              self.cat_pattern(cmt, &**subpat, op);\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1255,43 +1245,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = if_ok!(self.pat_ty(&*fp.node.pat)); // see (*2)\n+                let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                if_ok!(self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z)));\n+                self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n+                self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n             let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n+            self.cat_pattern(subcmt, &**subpat, op);\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n-                                          |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(elt_cmt.clone(), &**before_pat,\n+                                   |x,y,z| op(x,y,z));\n               }\n               for slice_pat in slice.iter() {\n-                  let slice_ty = if_ok!(self.pat_ty(&**slice_pat));\n+                  let slice_ty = self.pat_ty(&**slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  if_ok!(self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z));\n               }\n               for after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z));\n               }\n           }\n \n@@ -1303,8 +1293,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               self.tcx().sess.span_bug(pat.span, \"unexpanded macro\");\n           }\n         }\n-\n-        Ok(())\n     }\n \n     pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {"}, {"sha": "5ee6dec7830b299b45f9dea7a31ff4828971df47", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -1228,8 +1228,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .iter()\n                             .map(|freevar| {\n                                 let freevar_def_id = freevar.def.def_id();\n-                                self.typer.node_ty(freevar_def_id.node)\n-                                    .unwrap_or(ty::mk_err()).subst(self.tcx(), substs)\n+                                self.typer.node_ty(freevar_def_id.node).subst(self.tcx(), substs)\n                             })\n                             .collect();\n                         Ok(If(tys))"}, {"sha": "819defdb0caf27e0016f809c20a7b6723ec66006", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -3004,9 +3004,9 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n-                TypeContents::union(upvars[],\n-                                    |f| tc_ty(cx, f.ty, cache)) |\n-                    borrowed_contents(r, MutMutable)\n+                TypeContents::union(upvars.as_slice(),\n+                                    |f| tc_ty(cx, f.ty, cache))\n+                    | borrowed_contents(r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n@@ -6166,14 +6166,24 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(ty::node_id_to_type(self, id))\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        ty::node_id_to_type(self, id)\n     }\n \n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        ty::expr_ty_adjusted(self, expr)\n+    }\n+\n+    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n         self.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n+    }\n+\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.adjustments\n     }"}, {"sha": "b57b76d66f719e176d5daa3eb741b6af1198d56b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -516,12 +516,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n-        match self.mc().cat_expr(expr) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n-            }\n-        }\n+        self.mc().cat_expr(expr)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {"}, {"sha": "ea2a4ef6b2801395584de899c399c40c3346e4ab", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -463,8 +463,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(node_id_type(self, id))\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        node_id_type(self, id)\n+    }\n+\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        expr_ty_adjusted(self, expr)\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n@@ -475,6 +479,16 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n \n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n+\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.tcx().adjustments\n     }\n@@ -752,11 +766,11 @@ pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n+pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n+pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n "}, {"sha": "535a47008541c517e3ff75de9323ee37814a2fa4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -86,7 +86,7 @@ use check::_match::pat_ctxt;\n use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n-use middle::mem_categorization::{mod, McResult};\n+use middle::mem_categorization as mc;\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n@@ -282,16 +282,31 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        Ok(self.node_ty(id))\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        let ty = self.node_ty(id);\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n+    }\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        let ty = self.expr_ty_adjusted(expr);\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n-        self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n+        self.inh.method_map.borrow()\n+                           .get(&method_call)\n+                           .map(|method| method.ty)\n+                           .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n+    }\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.inh.method_map.borrow()\n+                           .get(&method_call)\n+                           .map(|method| method.origin.clone())\n     }\n     fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments"}, {"sha": "429eee87026a70be3c253a5934da5ab4e76724ed", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 25, "deletions": 82, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e4fef9bf195351673ac664cff5ba97c766d0ad/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=16e4fef9bf195351673ac664cff5ba97c766d0ad", "patch": "@@ -126,7 +126,7 @@ use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n use middle::infer;\n use middle::pat_util;\n-use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n+use util::nodemap::{FnvHashMap};\n use util::ppaux::{ty_to_string, Repr};\n \n use syntax::{ast, ast_util};\n@@ -193,19 +193,6 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-// If mem categorization results in an error, it's because the type\n-// check failed (or will fail, when the error is uncovered and\n-// reported during writeback). In this case, we just ignore this part\n-// of the code and don't try to add any more region constraints.\n-macro_rules! ignore_err {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => v,\n-            Err(()) => return\n-        }\n-    )\n-}\n-\n // Stores parameters for a potential call to link_region()\n // to perform if an upvar reference is marked unique/mutable after\n // it has already been processed before.\n@@ -446,47 +433,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n }\n \n-impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.ccx.tcx\n-    }\n-\n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        let t = self.resolve_node_type(id);\n-        if ty::type_is_error(t) {Err(())} else {Ok(t)}\n-    }\n-\n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        self.resolve_method_type(method_call)\n-    }\n-\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.fcx.inh.adjustments\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n-    }\n-\n-    fn temporary_scope(&self, id: ast::NodeId) -> Option<CodeExtent> {\n-        self.tcx().region_maps.temporary_scope(id)\n-    }\n-\n-    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.fcx.inh.upvar_borrow_map.borrow()[id].clone()\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n-    }\n-\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n-        &self.fcx.inh.unboxed_closures\n-    }\n-}\n-\n impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n@@ -767,7 +713,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             constrain_bindings_in_pat(&**pat, rcx);\n \n             {\n-                let mc = mc::MemCategorizationContext::new(rcx);\n+                let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                 let pat_ty = rcx.resolve_node_type(pat.id);\n                 let pat_cmt = mc.cat_rvalue(pat.id,\n                                             pat.span,\n@@ -1080,8 +1026,8 @@ fn constrain_callee(rcx: &mut Rcx,\n                 ty::RegionTraitStore(r, _) => {\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n-                    let mc = mc::MemCategorizationContext::new(rcx);\n-                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+                    let expr_cmt = mc.cat_expr(callee_expr);\n                     link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n                     r\n@@ -1189,8 +1135,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                     method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n-                    let mc = mc::MemCategorizationContext::new(rcx);\n-                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+                    let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -1285,8 +1231,8 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(base=?)\");\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(rcx);\n-        ignore_err!(mc.cat_expr(base))\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        mc.cat_expr(base)\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1300,8 +1246,8 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let discr_cmt = mc.cat_expr(init_expr);\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n@@ -1310,8 +1256,8 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let discr_cmt = mc.cat_expr(discr);\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n         for root_pat in arm.pats.iter() {\n@@ -1325,7 +1271,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     for arg in args.iter() {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n@@ -1340,7 +1286,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<Rcx<'a, 'tcx>>,\n+                          mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={}, root_pat={})\",\n@@ -1357,14 +1303,11 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 ast::PatVec(_, Some(ref slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n-                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                            link_region(rcx, sub_pat.span, slice_r,\n-                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                        slice_cmt);\n-                        }\n-                        Err(()) => {}\n-                    }\n+                    let (slice_cmt, slice_mutbl, slice_r) =\n+                        mc.cat_slice_pattern(sub_cmt, &**slice_pat);\n+                    link_region(rcx, sub_pat.span, slice_r,\n+                                ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                slice_cmt);\n                 }\n                 _ => {}\n             }\n@@ -1379,8 +1322,8 @@ fn link_autoref(rcx: &Rcx,\n                 autoref: &ty::AutoRef) {\n \n     debug!(\"link_autoref(autoref={})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n-    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let expr_cmt = mc.cat_expr_autoderefd(expr, autoderefs);\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n@@ -1401,8 +1344,8 @@ fn link_by_ref(rcx: &Rcx,\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx);\n-    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let expr_cmt = mc.cat_expr(expr);\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n@@ -1669,8 +1612,8 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// assignment expression.\n fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n-    let mc = mc::MemCategorizationContext::new(rcx);\n-    let cmt = ignore_err!(mc.cat_expr(lhs));\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let cmt = mc.cat_expr(lhs);\n     adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }\n "}]}