{"sha": "3d9ebf2916f96c6934a84a5abc2067145e062e75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOWViZjI5MTZmOTZjNjkzNGE4NGE1YWJjMjA2NzE0NWUwNjJlNzU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-06-08T11:51:32Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-06-08T14:53:31Z"}, "message": "Speed up expansion.\n\nThis reduces duplication, thereby increasing expansion speed.", "tree": {"sha": "57b1d6006c0f1b30253fdf995854a17afaaedfc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57b1d6006c0f1b30253fdf995854a17afaaedfc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9ebf2916f96c6934a84a5abc2067145e062e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9ebf2916f96c6934a84a5abc2067145e062e75", "html_url": "https://github.com/rust-lang/rust/commit/3d9ebf2916f96c6934a84a5abc2067145e062e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9ebf2916f96c6934a84a5abc2067145e062e75/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76242aebb9d47558124c991a6faf0eb706d35703", "url": "https://api.github.com/repos/rust-lang/rust/commits/76242aebb9d47558124c991a6faf0eb706d35703", "html_url": "https://github.com/rust-lang/rust/commit/76242aebb9d47558124c991a6faf0eb706d35703"}], "stats": {"total": 63, "additions": 35, "deletions": 28}, "files": [{"sha": "61d8fc2941afb71a425abc1ddd3ee01461d9ebe6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3d9ebf2916f96c6934a84a5abc2067145e062e75", "patch": "@@ -139,13 +139,20 @@ struct MatcherPos {\n     sep: Option<Token>,\n     idx: usize,\n     up: Option<Box<MatcherPos>>,\n-    matches: Vec<Vec<Rc<NamedMatch>>>,\n+    matches: Vec<Rc<Vec<NamedMatch>>>,\n     match_lo: usize,\n     match_cur: usize,\n     match_hi: usize,\n     sp_lo: BytePos,\n }\n \n+impl MatcherPos {\n+    fn push_match(&mut self, idx: usize, m: NamedMatch) {\n+        let matches = Rc::make_mut(&mut self.matches[idx]);\n+        matches.push(m);\n+    }\n+}\n+\n pub type NamedParseResult = ParseResult<HashMap<Ident, Rc<NamedMatch>>>;\n \n pub fn count_names(ms: &[TokenTree]) -> usize {\n@@ -199,14 +206,15 @@ fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n /// only on the nesting depth of `ast::TTSeq`s in the originating\n /// token tree it was derived from.\n \n+#[derive(Debug, Clone)]\n pub enum NamedMatch {\n-    MatchedSeq(Vec<Rc<NamedMatch>>, syntax_pos::Span),\n+    MatchedSeq(Rc<Vec<NamedMatch>>, syntax_pos::Span),\n     MatchedNonterminal(Rc<Nonterminal>)\n }\n \n-fn nameize<I: Iterator<Item=Rc<NamedMatch>>>(sess: &ParseSess, ms: &[TokenTree], mut res: I)\n+fn nameize<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, ms: &[TokenTree], mut res: I)\n                                              -> NamedParseResult {\n-    fn n_rec<I: Iterator<Item=Rc<NamedMatch>>>(sess: &ParseSess, m: &TokenTree, mut res: &mut I,\n+    fn n_rec<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, m: &TokenTree, mut res: &mut I,\n              ret_val: &mut HashMap<Ident, Rc<NamedMatch>>)\n              -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n@@ -228,7 +236,8 @@ fn nameize<I: Iterator<Item=Rc<NamedMatch>>>(sess: &ParseSess, ms: &[TokenTree],\n             TokenTree::MetaVarDecl(sp, bind_name, _) => {\n                 match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n-                        spot.insert(res.next().unwrap());\n+                        // FIXME(simulacrum): Don't construct Rc here\n+                        spot.insert(Rc::new(res.next().unwrap()));\n                     }\n                     Occupied(..) => {\n                         return Err((sp, format!(\"duplicated bind name: {}\", bind_name)))\n@@ -280,8 +289,8 @@ fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-fn create_matches(len: usize) -> Vec<Vec<Rc<NamedMatch>>> {\n-    (0..len).into_iter().map(|_| Vec::new()).collect()\n+fn create_matches(len: usize) -> Vec<Rc<Vec<NamedMatch>>> {\n+    (0..len).into_iter().map(|_| Rc::new(Vec::new())).collect()\n }\n \n fn inner_parse_loop(sess: &ParseSess,\n@@ -320,15 +329,10 @@ fn inner_parse_loop(sess: &ParseSess,\n                     // update matches (the MBE \"parse tree\") by appending\n                     // each tree as a subtree.\n \n-                    // I bet this is a perf problem: we're preemptively\n-                    // doing a lot of array work that will get thrown away\n-                    // most of the time.\n-\n                     // Only touch the binders we have actually bound\n                     for idx in ei.match_lo..ei.match_hi {\n                         let sub = ei.matches[idx].clone();\n-                        new_pos.matches[idx]\n-                            .push(Rc::new(MatchedSeq(sub, Span { lo: ei.sp_lo, ..span })));\n+                        new_pos.push_match(idx, MatchedSeq(sub, Span { lo: ei.sp_lo, ..span }));\n                     }\n \n                     new_pos.match_cur = ei.match_hi;\n@@ -362,7 +366,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                         new_ei.match_cur += seq.num_captures;\n                         new_ei.idx += 1;\n                         for idx in ei.match_cur..ei.match_cur + seq.num_captures {\n-                            new_ei.matches[idx].push(Rc::new(MatchedSeq(vec![], sp)));\n+                            new_ei.push_match(idx, MatchedSeq(Rc::new(vec![]), sp));\n                         }\n                         cur_eis.push(new_ei);\n                     }\n@@ -446,7 +450,9 @@ pub fn parse(sess: &ParseSess,\n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&parser.token, &token::Eof) {\n             if eof_eis.len() == 1 {\n-                let matches = eof_eis[0].matches.iter_mut().map(|mut dv| dv.pop().unwrap());\n+                let matches = eof_eis[0].matches.iter_mut().map(|mut dv| {\n+                    Rc::make_mut(dv).pop().unwrap()\n+                });\n                 return nameize(sess, ms, matches);\n             } else if eof_eis.len() > 1 {\n                 return Error(parser.span, \"ambiguity: multiple successful parses\".to_string());\n@@ -479,8 +485,8 @@ pub fn parse(sess: &ParseSess,\n             let mut ei = bb_eis.pop().unwrap();\n             if let TokenTree::MetaVarDecl(span, _, ident) = ei.top_elts.get_tt(ei.idx) {\n                 let match_cur = ei.match_cur;\n-                ei.matches[match_cur].push(Rc::new(MatchedNonterminal(\n-                            Rc::new(parse_nt(&mut parser, span, &ident.name.as_str())))));\n+                ei.push_match(match_cur,\n+                    MatchedNonterminal(Rc::new(parse_nt(&mut parser, span, &ident.name.as_str()))));\n                 ei.idx += 1;\n                 ei.match_cur += 1;\n             } else {"}, {"sha": "9c728c9f2ebf0cd7146bacb68b3dbc8d9ce048a2", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3d9ebf2916f96c6934a84a5abc2067145e062e75", "patch": "@@ -219,7 +219,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     let lhses = match *argument_map[&lhs_nm] {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| {\n-                if let MatchedNonterminal(ref nt) = **m {\n+                if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &tt);\n@@ -235,7 +235,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     let rhses = match *argument_map[&rhs_nm] {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| {\n-                if let MatchedNonterminal(ref nt) = **m {\n+                if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n                         return quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n                     }"}, {"sha": "78e755e73fa30ace18a116c9642979c94eaea366", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3d9ebf2916f96c6934a84a5abc2067145e062e75", "patch": "@@ -182,15 +182,16 @@ fn lookup_cur_matched(ident: Ident,\n                       repeats: &[(usize, usize)])\n                       -> Option<Rc<NamedMatch>> {\n     interpolations.get(&ident).map(|matched| {\n-        repeats.iter().fold(matched.clone(), |ad, &(idx, _)| {\n-            match *ad {\n-                MatchedNonterminal(_) => {\n-                    // end of the line; duplicate henceforth\n-                    ad.clone()\n-                }\n-                MatchedSeq(ref ads, _) => ads[idx].clone()\n+        let mut matched = matched.clone();\n+        for &(idx, _) in repeats {\n+            let m = matched.clone();\n+            match *m {\n+                MatchedNonterminal(_) => break,\n+                MatchedSeq(ref ads, _) => matched = Rc::new(ads[idx].clone()),\n             }\n-        })\n+        }\n+\n+        matched\n     })\n }\n "}, {"sha": "b5d6ff595afd57e60eb4845048dd2a0359b6f596", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9ebf2916f96c6934a84a5abc2067145e062e75/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=3d9ebf2916f96c6934a84a5abc2067145e062e75", "patch": "@@ -54,7 +54,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n     let mac_expr = match (&*matched_nt, &*map[&Ident::from_str(\"pat\")]) {\n         (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n             let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n-                match **pat_nt {\n+                match *pat_nt {\n                     MatchedNonterminal(ref nt) => match **nt {\n                         NtPat(ref pat) => pat.clone(),\n                         _ => unreachable!(),"}]}