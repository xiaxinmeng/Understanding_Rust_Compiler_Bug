{"sha": "06fe27866920b3eaf6502f321ccb239cc617db10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZmUyNzg2NjkyMGIzZWFmNjUwMmYzMjFjY2IyMzljYzYxN2RiMTA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-10-26T14:01:39Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-10-26T20:34:53Z"}, "message": "Fix unindent behavior between different doc comments", "tree": {"sha": "13c9f46a3a91a3e06d3866e3e7ece84cc544ed48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13c9f46a3a91a3e06d3866e3e7ece84cc544ed48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06fe27866920b3eaf6502f321ccb239cc617db10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06fe27866920b3eaf6502f321ccb239cc617db10", "html_url": "https://github.com/rust-lang/rust/commit/06fe27866920b3eaf6502f321ccb239cc617db10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06fe27866920b3eaf6502f321ccb239cc617db10/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "html_url": "https://github.com/rust-lang/rust/commit/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9"}], "stats": {"total": 131, "additions": 75, "deletions": 56}, "files": [{"sha": "1c856b1da53f1fd1497aa5442bb261680378fe73", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 75, "deletions": 56, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/06fe27866920b3eaf6502f321ccb239cc617db10/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fe27866920b3eaf6502f321ccb239cc617db10/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=06fe27866920b3eaf6502f321ccb239cc617db10", "patch": "@@ -1,7 +1,6 @@\n use std::cmp;\n-use std::string::String;\n \n-use crate::clean::{self, DocFragment, Item};\n+use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n@@ -35,65 +34,85 @@ impl clean::Attributes {\n }\n \n fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    for fragment in docs {\n-        fragment.doc = unindent(&fragment.doc);\n-    }\n-}\n-\n-fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str>>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line && !saw_second_line && !line.chars().all(|c| c.is_whitespace());\n-\n-        let min_indent = if ignore_previous_indents { usize::MAX } else { min_indent };\n-\n-        if saw_first_line {\n-            saw_second_line = true;\n-        }\n \n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n-        } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n+    let add = if !docs.windows(2).all(|arr| arr[0].kind == arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n+\n+    let min_indent = match docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n+                // After we see the first non-whitespace line, look at\n+                // the line we have. If it is not whitespace, and therefore\n+                // part of the first paragraph, then ignore the indentation\n+                // level of the first line\n+                let ignore_previous_indents =\n+                    saw_first_line && !saw_second_line && !line.chars().all(|c| c.is_whitespace());\n+\n+                let min_indent = if ignore_previous_indents { usize::MAX } else { min_indent };\n+\n+                if saw_first_line {\n+                    saw_second_line = true;\n+                }\n+\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n                 } else {\n-                    false\n+                    saw_first_line = true;\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n                 }\n-            });\n-            cmp::min(min_indent, whitespace)\n+            })\n+        })\n+        .min()\n+    {\n+        Some(x) => x,\n+        None => return,\n+    };\n+\n+    let mut first_ignored = false;\n+    for fragment in docs {\n+        let lines: Vec<_> = fragment.doc.lines().collect();\n+\n+        if !lines.is_empty() {\n+            let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+                min_indent - add\n+            } else {\n+                min_indent\n+            };\n+\n+            let mut iter = lines.iter();\n+            let mut result = if !first_ignored {\n+                first_ignored = true;\n+                vec![iter.next().unwrap().trim_start().to_string()]\n+            } else {\n+                Vec::new()\n+            };\n+            result.extend_from_slice(\n+                &iter\n+                    .map(|&line| {\n+                        if line.chars().all(|c| c.is_whitespace()) {\n+                            line.to_string()\n+                        } else {\n+                            assert!(line.len() >= min_indent);\n+                            line[min_indent..].to_string()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>(),\n+            );\n+            fragment.doc = result.join(\"\\n\");\n         }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![lines[0].trim_start().to_string()];\n-        unindented.extend_from_slice(\n-            &lines[1..]\n-                .iter()\n-                .map(|&line| {\n-                    if line.chars().all(|c| c.is_whitespace()) {\n-                        line.to_string()\n-                    } else {\n-                        assert!(line.len() >= min_indent);\n-                        line[min_indent..].to_string()\n-                    }\n-                })\n-                .collect::<Vec<_>>(),\n-        );\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n     }\n }"}]}