{"sha": "71d221f29425bf7c87fbc781fcbc5740b00d1c8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZDIyMWYyOTQyNWJmN2M4N2ZiYzc4MWZjYmM1NzQwYjAwZDFjOGY=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-03-16T09:52:07Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-04-28T08:55:25Z"}, "message": "Determine unused mutable variables based on the 'root' place", "tree": {"sha": "ee5ca5b1c9acf87b8c9732fed8c85f08b99b85ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee5ca5b1c9acf87b8c9732fed8c85f08b99b85ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71d221f29425bf7c87fbc781fcbc5740b00d1c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71d221f29425bf7c87fbc781fcbc5740b00d1c8f", "html_url": "https://github.com/rust-lang/rust/commit/71d221f29425bf7c87fbc781fcbc5740b00d1c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71d221f29425bf7c87fbc781fcbc5740b00d1c8f/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b372f67d9fbfda2818febe3af914d4f4069c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b372f67d9fbfda2818febe3af914d4f4069c6d", "html_url": "https://github.com/rust-lang/rust/commit/e3b372f67d9fbfda2818febe3af914d4f4069c6d"}], "stats": {"total": 197, "additions": 111, "deletions": 86}, "files": [{"sha": "2498162d10fa185a31a31cde8ef6cc3cf54b46cf", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 111, "deletions": 86, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/71d221f29425bf7c87fbc781fcbc5740b00d1c8f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d221f29425bf7c87fbc781fcbc5740b00d1c8f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=71d221f29425bf7c87fbc781fcbc5740b00d1c8f", "patch": "@@ -241,7 +241,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),\n-        nonlexical_regioncx: opt_regioncx,\n+        nonlexical_regioncx: regioncx,\n         used_mut: FxHashSet(),\n         used_mut_upvars: SmallVec::new(),\n         nonlexical_cause_info: None,\n@@ -276,7 +276,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n             tcx.struct_span_lint_node(\n                 UNUSED_MUT,\n-                vsi[source_info.scope].lint_root,\n+                vsi[local_decl.syntactic_scope].lint_root,\n                 source_info.span,\n                 \"variable does not need to be mutable\"\n             )\n@@ -1366,7 +1366,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n+        if let Ok(_) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n         debug!(\n@@ -1679,27 +1679,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => if let Err(place_err) =\n-                self.is_mutable(place, is_local_mutation_allowed)\n-            {\n-                error_reported = true;\n-                let item_msg = self.get_default_err_msg(place);\n-                let mut err = self.tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                err.span_label(span, \"cannot borrow as mutable\");\n-\n-                if place != place_err {\n-                    if let Some(name) = self.describe_place(place_err) {\n-                        err.note(&format!(\"the value which is causing this path not to be mutable \\\n-                                           is...: `{}`\", name));\n-                    }\n-                }\n-\n-                err.emit();\n-            },\n-            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-                match place {\n-                    Place::Local(local) => {\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(Place::Local(local))\n+                        if is_local_mutation_allowed != LocalMutationIsAllowed::Yes =>\n+                    {\n                         // If the local may be initialized, and it is now currently being\n                         // mutated, then it is justified to be annotated with the `mut` keyword,\n                         // since the mutation may be a possible reassignment.\n@@ -1708,77 +1692,118 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             self.used_mut.insert(*local);\n                         }\n                     }\n-                    Place::Projection(ref proj) => {\n+                    Ok(Place::Projection(ref proj)) => {\n                         if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n                             self.used_mut_upvars.push(field);\n                         }\n                     }\n-                    Place::Static(..) => {}\n-                }\n-                if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n-                    error_reported = true;\n-                    let mut err_info = None;\n-                    match *place_err {\n-\n-                        Place::Projection(box Projection {\n-                        ref base, elem:ProjectionElem::Deref}) => {\n-                            match *base {\n-                                Place::Local(local) => {\n-                                    let locations = self.mir.find_assignments(local);\n-                                        if locations.len() > 0 {\n-                                            let item_msg = if error_reported {\n-                                                self.get_secondary_err_msg(base)\n-                                            } else {\n-                                                self.get_default_err_msg(place)\n-                                            };\n-                                            let sp = self.mir.source_info(locations[0]).span;\n-                                            let mut to_suggest_span = String::new();\n-                                            if let Ok(src) =\n-                                                self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                                    to_suggest_span = src[1..].to_string();\n-                                            };\n-                                            err_info = Some((\n-                                                    sp,\n-                                                    \"consider changing this to be a \\\n-                                                    mutable reference\",\n-                                                    to_suggest_span,\n-                                                    item_msg,\n-                                                    self.get_primary_err_msg(base)));\n-                                        }\n-                                },\n-                            _ => {},\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n+                    Ok(Place::Local(_)) |\n+                    Ok(Place::Static(..)) => {}\n+                    Err(place_err) => {\n+                        error_reported = true;\n+                        let item_msg = self.get_default_err_msg(place);\n+                        let mut err = self.tcx\n+                            .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                        err.span_label(span, \"cannot borrow as mutable\");\n \n-                    if let Some((err_help_span,\n-                                 err_help_stmt,\n-                                 to_suggest_span,\n-                                 item_msg,\n-                                 sec_span)) = err_info {\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                        err.span_suggestion(err_help_span,\n-                                            err_help_stmt,\n-                                            format!(\"&mut {}\", to_suggest_span));\n-                        if place != place_err {\n-                            err.span_label(span, sec_span);\n-                        }\n-                        err.emit()\n-                    } else {\n-                        let item_msg_ = self.get_default_err_msg(place);\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg_, Origin::Mir);\n-                        err.span_label(span, \"cannot mutate\");\n                         if place != place_err {\n                             if let Some(name) = self.describe_place(place_err) {\n                                 err.note(&format!(\"the value which is causing this path not to be \\\n-                                                   mutable is...: `{}`\", name));\n+                                    mutable is...: `{}`\", name));\n                             }\n                         }\n+\n                         err.emit();\n                     }\n                 }\n             }\n+            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(Place::Local(local))\n+                        if is_local_mutation_allowed != LocalMutationIsAllowed::Yes =>\n+                    {\n+                        // If the local may be initialized, and it is now currently being\n+                        // mutated, then it is justified to be annotated with the `mut` keyword,\n+                        // since the mutation may be a possible reassignment.\n+                        let mpi = self.move_data.rev_lookup.find_local(*local);\n+                        if flow_state.inits.contains(&mpi) {\n+                            self.used_mut.insert(*local);\n+                        }\n+                    }\n+                    Ok(Place::Projection(ref proj)) => {\n+                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                            self.used_mut_upvars.push(field);\n+                        }\n+                    }\n+                    Ok(Place::Local(_)) |\n+                    Ok(Place::Static(..)) => {}\n+                    Err(place_err) => {\n+                        error_reported = true;\n+\n+                        let err_info = if let Place::Projection(\n+                            box Projection {\n+                                ref base,\n+                                elem: ProjectionElem::Deref\n+                            }\n+                        ) = *place_err {\n+                            if let Place::Local(local) = *base {\n+                                let locations = self.mir.find_assignments(local);\n+                                if locations.len() > 0 {\n+                                    let item_msg = if error_reported {\n+                                        self.get_secondary_err_msg(base)\n+                                    } else {\n+                                        self.get_default_err_msg(place)\n+                                    };\n+                                    let sp = self.mir.source_info(locations[0]).span;\n+                                    let mut to_suggest_span = String::new();\n+                                    if let Ok(src) =\n+                                        self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                            to_suggest_span = src[1..].to_string();\n+                                    };\n+                                    Some((sp,\n+                                          \"consider changing this to be a \\\n+                                          mutable reference\",\n+                                          to_suggest_span,\n+                                          item_msg,\n+                                          self.get_primary_err_msg(base)))\n+                                } else {\n+                                    None\n+                                }\n+                            } else {\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        };\n+\n+                        if let Some((err_help_span,\n+                                     err_help_stmt,\n+                                     to_suggest_span,\n+                                     item_msg,\n+                                     sec_span)) = err_info {\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_suggestion(err_help_span,\n+                                                err_help_stmt,\n+                                                format!(\"&mut {}\", to_suggest_span));\n+                            if place != place_err {\n+                                err.span_label(span, sec_span);\n+                            }\n+                            err.emit()\n+                        } else {\n+                            let item_msg = self.get_default_err_msg(place);\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_label(span, \"cannot mutate\");\n+                            if place != place_err {\n+                                if let Some(name) = self.describe_place(place_err) {\n+                                    err.note(&format!(\"the value which is causing this path not \\\n+                                                       to be mutable is...: `{}`\", name));\n+                                }\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n             Reservation(WriteKind::Move)\n             | Reservation(WriteKind::StorageDeadOrDrop)\n             | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n@@ -1810,25 +1835,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         place: &'d Place<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<(), &'d Place<'tcx>> {\n+    ) -> Result<&'d Place<'tcx>, &'d Place<'tcx>> {\n         match *place {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes | LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok(())\n+                            Ok(place)\n                         }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok(()),\n+                    Mutability::Mut => Ok(place),\n                 }\n             }\n             Place::Static(ref static_) =>\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok(())\n+                    Ok(place)\n                 },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1866,7 +1891,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     hir::MutImmutable => return Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of context\n                                     // The users have to check by themselve.\n-                                    hir::MutMutable => return Ok(()),\n+                                    hir::MutMutable => return Ok(place),\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable"}]}