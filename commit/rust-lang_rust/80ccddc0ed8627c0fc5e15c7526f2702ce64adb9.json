{"sha": "80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwY2NkZGMwZWQ4NjI3YzBmYzVlMTVjNzUyNmYyNzAyY2U2NGFkYjk=", "commit": {"author": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2020-04-13T15:17:34Z"}, "committer": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2020-04-13T15:17:34Z"}, "message": "weak-into-raw: as_raw -> as_ptr + dangling garbage\n\n* Rename Weak::as_raw to Weak::as_ptr for consistency with some other\n  types.\n* The as_ptr for a dangling Weak pointer might return whatever garbage\n  (and takes that advantage to avoid a conditional).\n* Don't guarantee to be able to do `Weak::from_raw(weak.as_ptr())` (even\n  though it'll still work fine).", "tree": {"sha": "959ba36bf6ddcc256d0888f4acdc01de94399749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959ba36bf6ddcc256d0888f4acdc01de94399749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEQ8wy/3jh6tM0kr/e9wDQwBnkxm8FAl6Ug18ACgkQ9wDQwBnk\nxm8JNBAAun46QIEmzOeEPaNRLCESwPW/jHfR4a/UKXBkXmmE77y6TFK/PNO8kEHl\n1Ca8dJbCiqt1z7/HLZ5G+poMuLlH7AnNJerw4NiFJGJ4weiqMuQjCcqNYGA8FjA0\nr80x9+WI1Ikipg8KDRgIzATlapa3kojimUQ3JWBOwM9zXBVdxxS76VJhQim0F04m\n3ZEncZWspTb8mGJN9QhtYqHDtjGikDeek+oHca/ZvX5p73LIZcemr5Nq1rzWin5L\nhRGl9mXa1xHu3AaAso2quLkfFG/HvVZKTPKpHVSC+sJJWS/q9NAE6eI2DdcV/Y1N\nhFH3dlXP3rBrPWJ4MGjR82K0cv/Ew020EljMQs11UFVsVwPtolDpkDVxp6Kpxypm\n4wyuyt5Z4p/WjVEizGD08bRooVBws0Nd6VrWd4PaautyGO7F4YFey1Rrn+JPYXWF\nOCexBzN5eIxZxGffL/DgXIpzQJZgGdBxzS7e7kP4NljAaKfKb4EYw8BwLxi5dGqI\n3eiIb5sE70qFAoxy2ycm7gnghEDABn4faiIu1UROKVD8lq2gazRFbqzkDMSqaQqe\nwacH7TKdv373rKmmbIe8/xZWtKWk426ENT6mZL5Eo9UUnyNo36doqgvgxEXXGpKD\nEsX8goXXfjDBoGTl0UedK2MvQH7iO6uvO+dT6/i5Y660DfmEryE=\n=5SST\n-----END PGP SIGNATURE-----", "payload": "tree 959ba36bf6ddcc256d0888f4acdc01de94399749\nparent 4d1fbaccb822b6d52dc786589de7918d3c5effb1\nauthor Michal 'vorner' Vaner <vorner@vorner.cz> 1586791054 +0200\ncommitter Michal 'vorner' Vaner <vorner@vorner.cz> 1586791054 +0200\n\nweak-into-raw: as_raw -> as_ptr + dangling garbage\n\n* Rename Weak::as_raw to Weak::as_ptr for consistency with some other\n  types.\n* The as_ptr for a dangling Weak pointer might return whatever garbage\n  (and takes that advantage to avoid a conditional).\n* Don't guarantee to be able to do `Weak::from_raw(weak.as_ptr())` (even\n  though it'll still work fine).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "html_url": "https://github.com/rust-lang/rust/commit/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9/comments", "author": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d1fbaccb822b6d52dc786589de7918d3c5effb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1fbaccb822b6d52dc786589de7918d3c5effb1", "html_url": "https://github.com/rust-lang/rust/commit/4d1fbaccb822b6d52dc786589de7918d3c5effb1"}], "stats": {"total": 82, "additions": 30, "deletions": 52}, "files": [{"sha": "59424de42770cbe708b5fc55ff0f100ed82f75a6", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "patch": "@@ -1644,8 +1644,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1658,31 +1658,22 @@ impl<T> Weak<T> {\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const RcBox<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1691,7 +1682,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1712,10 +1703,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1730,9 +1721,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1765,7 +1755,6 @@ impl<T> Weak<T> {\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]"}, {"sha": "203b386ba1d0eda8576dd48006e676a6923363db", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ccddc0ed8627c0fc5e15c7526f2702ce64adb9/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=80ccddc0ed8627c0fc5e15c7526f2702ce64adb9", "patch": "@@ -1340,8 +1340,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1354,31 +1354,22 @@ impl<T> Weak<T> {\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const ArcInner<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1387,7 +1378,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1408,10 +1399,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1427,9 +1418,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1458,7 +1448,6 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade"}]}