{"sha": "91bbc55eedbc0f6947b69a0158a7b6c81264024e", "node_id": "C_kwDOAAsO6NoAKDkxYmJjNTVlZWRiYzBmNjk0N2I2OWEwMTU4YTdiNmM4MTI2NDAyNGU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T18:46:32Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-17T19:46:57Z"}, "message": "Check for derive attributes by item path, not `derive` identifier", "tree": {"sha": "b9e3ec7fc3a4e7d7ccf8e1e6cee10cf2e209dcc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9e3ec7fc3a4e7d7ccf8e1e6cee10cf2e209dcc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91bbc55eedbc0f6947b69a0158a7b6c81264024e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91bbc55eedbc0f6947b69a0158a7b6c81264024e", "html_url": "https://github.com/rust-lang/rust/commit/91bbc55eedbc0f6947b69a0158a7b6c81264024e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91bbc55eedbc0f6947b69a0158a7b6c81264024e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32f425d801ad46c888a3a3639c5e2edbff4f3811", "url": "https://api.github.com/repos/rust-lang/rust/commits/32f425d801ad46c888a3a3639c5e2edbff4f3811", "html_url": "https://github.com/rust-lang/rust/commit/32f425d801ad46c888a3a3639c5e2edbff4f3811"}], "stats": {"total": 379, "additions": 173, "deletions": 206}, "files": [{"sha": "fd45eccf5aaec925d4c0eb65f1954ffb1011012f", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -8,7 +8,7 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n-use mbe::{syntax_node_to_token_tree, DelimiterKind};\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, HasAttrs, IsString},\n@@ -722,41 +722,35 @@ impl Attr {\n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n     /// to derive macros.\n     ///\n-    /// Returns `None` when the attribute is not a well-formed `#[derive]` attribute.\n+    /// Returns `None` when the attribute does not have a well-formed `#[derive]` attribute input.\n     pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath>> {\n-        if self.path.as_ident() != Some(&hir_expand::name![derive]) {\n-            return None;\n-        }\n-\n-        match self.input.as_deref() {\n-            Some(AttrInput::TokenTree(args, _)) => {\n-                let mut counter = 0;\n-                let paths = args\n-                    .token_trees\n-                    .iter()\n-                    .group_by(move |tt| {\n-                        match tt {\n-                            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => {\n-                                counter += 1;\n-                            }\n-                            _ => {}\n-                        }\n-                        counter\n-                    })\n-                    .into_iter()\n-                    .map(|(_, tts)| {\n-                        let segments = tts.filter_map(|tt| match tt {\n-                            tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                            _ => None,\n-                        });\n-                        ModPath::from_segments(PathKind::Plain, segments)\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                Some(paths.into_iter())\n+        if let Some(AttrInput::TokenTree(args, _)) = self.input.as_deref() {\n+            if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+                return None;\n             }\n-            _ => None,\n+            let mut counter = 0;\n+            let paths = args\n+                .token_trees\n+                .iter()\n+                .group_by(move |tt| {\n+                    if let tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })) = tt {\n+                        counter += 1;\n+                    }\n+                    counter\n+                })\n+                .into_iter()\n+                .map(|(_, tts)| {\n+                    let segments = tts.filter_map(|tt| match tt {\n+                        tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                        _ => None,\n+                    });\n+                    ModPath::from_segments(PathKind::Plain, segments)\n+                })\n+                .collect::<Vec<_>>();\n+\n+            return Some(paths.into_iter());\n         }\n+        None\n     }\n \n     pub fn string_value(&self) -> Option<&SmolStr> {"}, {"sha": "8ee33101e4d010a6dc6938c859cbdd24484e3313", "filename": "crates/hir_def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -26,12 +26,16 @@ fn test_copy_expand_in_core() {\n     check(\n         r#\"\n #[rustc_builtin_macro]\n+macro derive {}\n+#[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \"#,\n         expect![[r##\"\n #[rustc_builtin_macro]\n+macro derive {}\n+#[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;"}, {"sha": "901872eddab904b4e86c07323ec621cb42b43cb1", "filename": "crates/hir_def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -31,6 +31,7 @@ fn derive_censoring() {\n     check(\n         r#\"\n //- proc_macros: derive_identity\n+//- minicore:derive\n #[attr1]\n #[derive(Foo)]\n #[derive(proc_macros::DeriveIdentity)]"}, {"sha": "dfce334bc7f79e2683e973daf431fb583f8cbbf8", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 89, "deletions": 61, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -9,7 +9,7 @@ use base_db::{CrateId, Edition, FileId, ProcMacroId};\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::{\n     ast_id_map::FileAstId,\n-    builtin_attr_macro::{find_builtin_attr, is_builtin_test_or_bench_attr},\n+    builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n@@ -781,7 +781,7 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_extern_crate(&self, name: &Name) -> PerNs {\n-        if name == &name!(self) {\n+        if *name == name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n             let root = match self.def_map.block {\n                 Some(_) => {\n@@ -1105,7 +1105,7 @@ impl DefCollector<'_> {\n                                 let mod_dir = self.mod_dirs[&directive.module_id].clone();\n                                 self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n                                 ModCollector {\n-                                    def_collector: &mut *self,\n+                                    def_collector: self,\n                                     macro_depth: directive.depth,\n                                     module_id: directive.module_id,\n                                     tree_id: TreeId::new(file_id, None),\n@@ -1121,6 +1121,65 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n+                    let def = resolver(ast_id.path.clone()).filter(MacroDefId::is_attribute);\n+                    if matches!(\n+                        def,\n+                        Some(MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. })\n+                        if expander.is_derive()\n+                    ) {\n+                        // Resolved to derive\n+                        let file_id = ast_id.ast_id.file_id;\n+                        let item_tree = self.db.file_item_tree(file_id);\n+\n+                        let ast_id: FileAstId<ast::Item> = match *mod_item {\n+                            ModItem::Struct(it) => item_tree[it].ast_id.upcast(),\n+                            ModItem::Union(it) => item_tree[it].ast_id.upcast(),\n+                            ModItem::Enum(it) => item_tree[it].ast_id.upcast(),\n+                            _ => {\n+                                // Cannot use derive on this item.\n+                                // FIXME: diagnose\n+                                res = ReachedFixedPoint::No;\n+                                return false;\n+                            }\n+                        };\n+\n+                        match attr.parse_derive() {\n+                            Some(derive_macros) => {\n+                                for path in derive_macros {\n+                                    let ast_id = AstIdWithPath::new(file_id, ast_id, path);\n+                                    self.unresolved_macros.push(MacroDirective {\n+                                        module_id: directive.module_id,\n+                                        depth: directive.depth + 1,\n+                                        kind: MacroDirectiveKind::Derive {\n+                                            ast_id,\n+                                            derive_attr: attr.id,\n+                                        },\n+                                    });\n+                                }\n+                            }\n+                            None => {\n+                                // FIXME: diagnose\n+                                tracing::debug!(\"malformed derive: {:?}\", attr);\n+                            }\n+                        }\n+\n+                        let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                        self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n+                        ModCollector {\n+                            def_collector: &mut *self,\n+                            macro_depth: directive.depth,\n+                            module_id: directive.module_id,\n+                            tree_id: TreeId::new(file_id, None),\n+                            item_tree: &item_tree,\n+                            mod_dir,\n+                        }\n+                        .collect(&[*mod_item]);\n+\n+                        // Remove the original directive since we resolved it.\n+                        res = ReachedFixedPoint::No;\n+                        return false;\n+                    }\n+\n                     if !self.db.enable_proc_attr_macros() {\n                         return true;\n                     }\n@@ -1138,7 +1197,11 @@ impl DefCollector<'_> {\n \n                             // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n                             // due to duplicating functions into macro expansions\n-                            if is_builtin_test_or_bench_attr(loc.def) {\n+                            if matches!(\n+                                loc.def.kind,\n+                                MacroDefKind::BuiltInAttr(expander, _)\n+                                if expander.is_test() || expander.is_bench()\n+                            ) {\n                                 let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n                                 let mod_dir = self.mod_dirs[&directive.module_id].clone();\n@@ -1281,7 +1344,7 @@ impl DefCollector<'_> {\n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n-                    match macro_call_as_call_id(\n+                    let macro_call_as_call_id = macro_call_as_call_id(\n                         ast_id,\n                         *expand_to,\n                         self.db,\n@@ -1297,15 +1360,13 @@ impl DefCollector<'_> {\n                             resolved_res.resolved_def.take_macros()\n                         },\n                         &mut |_| (),\n-                    ) {\n-                        Ok(_) => (),\n-                        Err(UnresolvedMacro { path }) => {\n-                            self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n-                                directive.module_id,\n-                                ast_id.ast_id,\n-                                path,\n-                            ));\n-                        }\n+                    );\n+                    if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {\n+                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            directive.module_id,\n+                            ast_id.ast_id,\n+                            path,\n+                        ));\n                     }\n                 }\n                 MacroDirectiveKind::Derive { .. } | MacroDirectiveKind::Attr { .. } => {\n@@ -1747,26 +1808,23 @@ impl ModCollector<'_, '_> {\n             });\n \n         for attr in iter {\n-            if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n-                self.collect_derive(attr, mod_item);\n-            } else if self.is_builtin_or_registered_attr(&attr.path) {\n+            if self.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n-            } else {\n-                tracing::debug!(\"non-builtin attribute {}\", attr.path);\n+            }\n+            tracing::debug!(\"non-builtin attribute {}\", attr.path);\n \n-                let ast_id = AstIdWithPath::new(\n-                    self.file_id(),\n-                    mod_item.ast_id(self.item_tree),\n-                    attr.path.as_ref().clone(),\n-                );\n-                self.def_collector.unresolved_macros.push(MacroDirective {\n-                    module_id: self.module_id,\n-                    depth: self.macro_depth + 1,\n-                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.clone(), mod_item },\n-                });\n+            let ast_id = AstIdWithPath::new(\n+                self.file_id(),\n+                mod_item.ast_id(self.item_tree),\n+                attr.path.as_ref().clone(),\n+            );\n+            self.def_collector.unresolved_macros.push(MacroDirective {\n+                module_id: self.module_id,\n+                depth: self.macro_depth + 1,\n+                kind: MacroDirectiveKind::Attr { ast_id, attr: attr.clone(), mod_item },\n+            });\n \n-                return Err(());\n-            }\n+            return Err(());\n         }\n \n         Ok(())\n@@ -1800,36 +1858,6 @@ impl ModCollector<'_, '_> {\n         false\n     }\n \n-    fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n-        let ast_id: FileAstId<ast::Item> = match mod_item {\n-            ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n-            ModItem::Union(it) => self.item_tree[it].ast_id.upcast(),\n-            ModItem::Enum(it) => self.item_tree[it].ast_id.upcast(),\n-            _ => {\n-                // Cannot use derive on this item.\n-                // FIXME: diagnose\n-                return;\n-            }\n-        };\n-\n-        match attr.parse_derive() {\n-            Some(derive_macros) => {\n-                for path in derive_macros {\n-                    let ast_id = AstIdWithPath::new(self.file_id(), ast_id, path);\n-                    self.def_collector.unresolved_macros.push(MacroDirective {\n-                        module_id: self.module_id,\n-                        depth: self.macro_depth + 1,\n-                        kind: MacroDirectiveKind::Derive { ast_id, derive_attr: attr.id },\n-                    });\n-                }\n-            }\n-            None => {\n-                // FIXME: diagnose\n-                tracing::debug!(\"malformed derive: {:?}\", attr);\n-            }\n-        }\n-    }\n-\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere"}, {"sha": "fbb1320d6e8248d21fd81886df23b3c9f14f0ea1", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -669,19 +669,20 @@ pub struct bar;\n fn expand_derive() {\n     let map = compute_crate_def_map(\n         r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::Copy;\n-\n-        #[derive(Copy, core::Clone)]\n-        struct Foo;\n+//- /main.rs crate:main deps:core\n+use core::Copy;\n \n-        //- /core.rs crate:core\n-        #[rustc_builtin_macro]\n-        pub macro Copy {}\n+#[core::derive(Copy, core::Clone)]\n+struct Foo;\n \n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        \"#,\n+//- /core.rs crate:core\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+\"#,\n     );\n     assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n }\n@@ -712,17 +713,19 @@ fn builtin_derive_with_unresolved_attributes_fall_back() {\n     cov_mark::check!(unresolved_attribute_fallback);\n     let map = compute_crate_def_map(\n         r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::Clone;\n+//- /main.rs crate:main deps:core\n+use core::{Clone, derive};\n \n-        #[derive(Clone)]\n-        #[unresolved]\n-        struct Foo;\n+#[derive(Clone)]\n+#[unresolved]\n+struct Foo;\n \n-        //- /core.rs crate:core\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        \"#,\n+//- /core.rs crate:core\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+\"#,\n     );\n     assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n }\n@@ -799,6 +802,9 @@ fn resolves_derive_helper() {\n     check(\n         r#\"\n //- /main.rs crate:main deps:proc\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+\n #[derive(proc::Derive)]\n #[helper]\n #[unresolved]\n@@ -811,6 +817,7 @@ fn derive() {}\n         expect![[r#\"\n             crate\n             S: t v\n+            derive: m\n         \"#]],\n     );\n }"}, {"sha": "8da8c2ee4f2e01f5813df5f7c48370c2f9cbe16e", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -36,6 +36,18 @@ macro_rules! register_builtin {\n     };\n }\n \n+impl BuiltinAttrExpander {\n+    pub fn is_derive(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Derive)\n+    }\n+    pub fn is_test(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Test)\n+    }\n+    pub fn is_bench(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Bench)\n+    }\n+}\n+\n register_builtin! {\n     (bench, Bench) => dummy_attr_expand,\n     (cfg_accessible, CfgAccessible) => dummy_attr_expand,\n@@ -46,16 +58,6 @@ register_builtin! {\n     (test_case, TestCase) => dummy_attr_expand\n }\n \n-pub fn is_builtin_test_or_bench_attr(makro: MacroDefId) -> bool {\n-    match makro.kind {\n-        MacroDefKind::BuiltInAttr(expander, ..) => {\n-            BuiltinAttrExpander::find_by_name(&name!(test)) == Some(expander)\n-                || BuiltinAttrExpander::find_by_name(&name!(bench)) == Some(expander)\n-        }\n-        _ => false,\n-    }\n-}\n-\n pub fn find_builtin_attr(\n     ident: &name::Name,\n     krate: CrateId,"}, {"sha": "a61175f273350b4e291666f9c482768ad5f6062f", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -974,61 +974,12 @@ fn infer_builtin_macros_env() {\n fn infer_derive_clone_simple() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: derive, clone\n #[derive(Clone)]\n struct S;\n fn test() {\n     S.clone();\n } //^^^^^^^^^ S\n-\n-//- /lib.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn infer_derive_clone_in_core() {\n-    check_types(\n-        r#\"\n-//- /lib.rs crate:core\n-#[prelude_import]\n-use prelude::rust_2018::*;\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct S;\n-\n-//- /main.rs crate:main deps:core\n-use core::S;\n-fn test() {\n-    S.clone();\n-} //^^^^^^^^^ S\n \"#,\n     );\n }\n@@ -1037,7 +988,7 @@ fn test() {\n fn infer_derive_clone_with_params() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: clone, derive\n #[derive(Clone)]\n struct S;\n #[derive(Clone)]\n@@ -1048,21 +999,6 @@ fn test() {\n     x;\n   //^ (Wrapper<S>, {unknown})\n }\n-\n-//- /lib.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n \"#,\n     );\n }\n@@ -1072,7 +1008,7 @@ fn infer_custom_derive_simple() {\n     // FIXME: this test current now do nothing\n     check_types(\n         r#\"\n-//- /main.rs crate:main\n+//- minicore: derive\n use foo::Foo;\n \n #[derive(Foo)]"}, {"sha": "57c078ef57df64e4848c66283d12c56bc351171a", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -367,17 +367,15 @@ fn main() {\n         check(\n             r#\"\n //- proc_macros: identity\n-\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n+//- minicore: clone, derive\n \n #[proc_macros::identity]\n #[derive(C$0lone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl< >crate::clone::Clone for Foo< >{}\n+                impl< >core::clone::Clone for Foo< >{}\n \n             \"#]],\n         );\n@@ -387,18 +385,15 @@ struct Foo {}\n     fn macro_expand_derive2() {\n         check(\n             r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-#[rustc_builtin_macro]\n-pub macro Copy {}\n+//- minicore: copy, clone, derive\n \n #[derive(Cop$0y)]\n #[derive(Clone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl< >crate::marker::Copy for Foo< >{}\n+                impl< >core::marker::Copy for Foo< >{}\n \n             \"#]],\n         );\n@@ -408,19 +403,16 @@ struct Foo {}\n     fn macro_expand_derive_multi() {\n         check(\n             r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-#[rustc_builtin_macro]\n-pub macro Copy {}\n+//- minicore: copy, clone, derive\n \n #[derive(Cop$0y, Clone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy, Clone\n-                impl< >crate::marker::Copy for Foo< >{}\n+                impl< >core::marker::Copy for Foo< >{}\n \n-                impl< >crate::clone::Clone for Foo< >{}\n+                impl< >core::clone::Clone for Foo< >{}\n \n             \"#]],\n         );"}, {"sha": "0a62d5ab87331c29001a112c48a1563e29063a2c", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91bbc55eedbc0f6947b69a0158a7b6c81264024e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=91bbc55eedbc0f6947b69a0158a7b6c81264024e", "patch": "@@ -805,6 +805,9 @@ bar = {path = \"../bar\"}\n \n //- /foo/src/main.rs\n use bar::Bar;\n+\n+#[rustc_builtin_macro]\n+macro derive($item:item) {}\n trait Bar {\n   fn bar();\n }"}]}