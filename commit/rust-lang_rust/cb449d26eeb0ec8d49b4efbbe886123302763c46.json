{"sha": "cb449d26eeb0ec8d49b4efbbe886123302763c46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDQ5ZDI2ZWViMGVjOGQ0OWI0ZWZiYmU4ODYxMjMzMDI3NjNjNDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-22T22:36:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-22T22:36:37Z"}, "message": "Rollup merge of #64676 - estebank:assoc-type-bound-in-generic, r=petrochenkov\n\nParse assoc type bounds in generic params and provide custom diagnostic\n\nFix #26271.", "tree": {"sha": "9dd0b25aeaee6fa0e14012f4fe986f9f6680de6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dd0b25aeaee6fa0e14012f4fe986f9f6680de6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb449d26eeb0ec8d49b4efbbe886123302763c46", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdh/d1CRBK7hj4Ov3rIwAAdHIIAE931enXYlhq+KDNIJws3wVb\nMTV5Z61LOxwIQU44+UL612nB120l0RkgXfUEAWbP3seZ9s1Gtpq2VnpBr8D3cX3F\nqTaXS22kV4EB0C5kvFCIxPlbGuk4pMzLis1XZwbdHzxfUeyyA0cAMon6KHdhQLAQ\nAl1aEYEXPhgdBs9Puc7bcJe5ERf9Mt05QOtnQjloC3e/NeX8/EJrunusklgoiCgQ\nqiFG5gelDetNda4+B6J54T8jZpsjKiUliKp5r5PqnAL9gNuN6BubVlQ5uCh/BHbZ\nW623vDj5xQVSJGSYPp2u771xOqbeRYszq0367ACQvDlDu5t4t4bu68FeOkkDXNA=\n=/CY3\n-----END PGP SIGNATURE-----\n", "payload": "tree 9dd0b25aeaee6fa0e14012f4fe986f9f6680de6c\nparent b66e7323e63027a29af213abb031c584bb5c2767\nparent 0f2f16db5364663b4a2f092bba61dc3b056902e3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569191797 +0200\ncommitter GitHub <noreply@github.com> 1569191797 +0200\n\nRollup merge of #64676 - estebank:assoc-type-bound-in-generic, r=petrochenkov\n\nParse assoc type bounds in generic params and provide custom diagnostic\n\nFix #26271.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb449d26eeb0ec8d49b4efbbe886123302763c46", "html_url": "https://github.com/rust-lang/rust/commit/cb449d26eeb0ec8d49b4efbbe886123302763c46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb449d26eeb0ec8d49b4efbbe886123302763c46/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b66e7323e63027a29af213abb031c584bb5c2767", "url": "https://api.github.com/repos/rust-lang/rust/commits/b66e7323e63027a29af213abb031c584bb5c2767", "html_url": "https://github.com/rust-lang/rust/commit/b66e7323e63027a29af213abb031c584bb5c2767"}, {"sha": "0f2f16db5364663b4a2f092bba61dc3b056902e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f2f16db5364663b4a2f092bba61dc3b056902e3", "html_url": "https://github.com/rust-lang/rust/commit/0f2f16db5364663b4a2f092bba61dc3b056902e3"}], "stats": {"total": 118, "additions": 80, "deletions": 38}, "files": [{"sha": "2ecd9cca3c64b532553645e7ca5407652e463f33", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=cb449d26eeb0ec8d49b4efbbe886123302763c46", "patch": "@@ -100,13 +100,31 @@ impl<'a> Parser<'a> {\n             } else if self.check_ident() {\n                 // Parse type parameter.\n                 params.push(self.parse_ty_param(attrs)?);\n+            } else if self.token.can_begin_type() {\n+                // Trying to write an associated type bound? (#26271)\n+                let snapshot = self.clone();\n+                match self.parse_ty_where_predicate() {\n+                    Ok(where_predicate) => {\n+                        self.struct_span_err(\n+                            where_predicate.span(),\n+                            \"bounds on associated types do not belong here\",\n+                        )\n+                        .span_label(where_predicate.span(), \"belongs in `where` clause\")\n+                        .emit();\n+                    }\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        std::mem::replace(self, snapshot);\n+                        break\n+                    }\n+                }\n             } else {\n                 // Check for trailing attributes and stop parsing.\n                 if !attrs.is_empty() {\n                     if !params.is_empty() {\n                         self.struct_span_err(\n                             attrs[0].span,\n-                            &format!(\"trailing attribute after generic parameter\"),\n+                            \"trailing attribute after generic parameter\",\n                         )\n                         .span_label(attrs[0].span, \"attributes must go before parameters\")\n                         .emit();\n@@ -202,43 +220,7 @@ impl<'a> Parser<'a> {\n                     }\n                 ));\n             } else if self.check_type() {\n-                // Parse optional `for<'a, 'b>`.\n-                // This `for` is parsed greedily and applies to the whole predicate,\n-                // the bounded type can have its own `for` applying only to it.\n-                // Examples:\n-                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n-                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n-                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-                // Parse type with mandatory colon and (possibly empty) bounds,\n-                // or with mandatory equality sign and the second type.\n-                let ty = self.parse_ty()?;\n-                if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                        ast::WhereBoundPredicate {\n-                            span: lo.to(self.prev_span),\n-                            bound_generic_params: lifetime_defs,\n-                            bounded_ty: ty,\n-                            bounds,\n-                        }\n-                    ));\n-                // FIXME: Decide what should be used here, `=` or `==`.\n-                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n-                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n-                    let rhs_ty = self.parse_ty()?;\n-                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n-                        ast::WhereEqPredicate {\n-                            span: lo.to(self.prev_span),\n-                            lhs_ty: ty,\n-                            rhs_ty,\n-                            id: ast::DUMMY_NODE_ID,\n-                        }\n-                    ));\n-                } else {\n-                    return self.unexpected();\n-                }\n+                where_clause.predicates.push(self.parse_ty_where_predicate()?);\n             } else {\n                 break\n             }\n@@ -252,6 +234,47 @@ impl<'a> Parser<'a> {\n         Ok(where_clause)\n     }\n \n+    fn parse_ty_where_predicate(&mut self) -> PResult<'a, ast::WherePredicate> {\n+        let lo = self.token.span;\n+        // Parse optional `for<'a, 'b>`.\n+        // This `for` is parsed greedily and applies to the whole predicate,\n+        // the bounded type can have its own `for` applying only to it.\n+        // Examples:\n+        // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+        // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+        // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+        // Parse type with mandatory colon and (possibly empty) bounds,\n+        // or with mandatory equality sign and the second type.\n+        let ty = self.parse_ty()?;\n+        if self.eat(&token::Colon) {\n+            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            Ok(ast::WherePredicate::BoundPredicate(\n+                ast::WhereBoundPredicate {\n+                    span: lo.to(self.prev_span),\n+                    bound_generic_params: lifetime_defs,\n+                    bounded_ty: ty,\n+                    bounds,\n+                }\n+            ))\n+        // FIXME: Decide what should be used here, `=` or `==`.\n+        // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n+        } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+            let rhs_ty = self.parse_ty()?;\n+            Ok(ast::WherePredicate::EqPredicate(\n+                ast::WhereEqPredicate {\n+                    span: lo.to(self.prev_span),\n+                    lhs_ty: ty,\n+                    rhs_ty,\n+                    id: ast::DUMMY_NODE_ID,\n+                }\n+            ))\n+        } else {\n+            self.unexpected()\n+        }\n+    }\n+\n     pub(super) fn choose_generics_over_qpath(&self) -> bool {\n         // There's an ambiguity between generic parameters and qualified paths in impls.\n         // If we see `<` it may start both, so we have to inspect some following tokens."}, {"sha": "000956ea24fadb5c14d1dd352d6756464fcf276f", "filename": "src/test/ui/parser/assoc-type-in-type-arg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs?ref=cb449d26eeb0ec8d49b4efbbe886123302763c46", "patch": "@@ -0,0 +1,11 @@\n+trait Tr {\n+    type TrSubtype;\n+}\n+\n+struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+    //~^ ERROR bounds on associated types do not belong here\n+    item: Item,\n+    item_sub: &'a <Item as Tr>::TrSubtype,\n+}\n+\n+fn main() {}"}, {"sha": "b637702f21e90d3452fc5cf1864df81132747180", "filename": "src/test/ui/parser/assoc-type-in-type-arg.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb449d26eeb0ec8d49b4efbbe886123302763c46/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr?ref=cb449d26eeb0ec8d49b4efbbe886123302763c46", "patch": "@@ -0,0 +1,8 @@\n+error: bounds on associated types do not belong here\n+  --> $DIR/assoc-type-in-type-arg.rs:5:26\n+   |\n+LL | struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ belongs in `where` clause\n+\n+error: aborting due to previous error\n+"}]}