{"sha": "80bf9ae18a133571d694aa866b824dcaea875d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYmY5YWUxOGExMzM1NzFkNjk0YWE4NjZiODI0ZGNhZWE4NzVkMzI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-08T15:05:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-11T11:34:48Z"}, "message": "[breaking-change] don't glob export ast::Expr_ variants", "tree": {"sha": "234647a587e83f07f4a6f3f1b2cf03c6ebdec2aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/234647a587e83f07f4a6f3f1b2cf03c6ebdec2aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80bf9ae18a133571d694aa866b824dcaea875d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80bf9ae18a133571d694aa866b824dcaea875d32", "html_url": "https://github.com/rust-lang/rust/commit/80bf9ae18a133571d694aa866b824dcaea875d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80bf9ae18a133571d694aa866b824dcaea875d32/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4d43715843a5ff5af4657c798b5d5cc85ca523", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4d43715843a5ff5af4657c798b5d5cc85ca523", "html_url": "https://github.com/rust-lang/rust/commit/1c4d43715843a5ff5af4657c798b5d5cc85ca523"}], "stats": {"total": 848, "additions": 420, "deletions": 428}, "files": [{"sha": "0f6ba63d54b67a50e292594df9a88c2b1f43780b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -653,7 +653,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n             let empty_block = expr_to_block(BlockCheckMode::Default, None);\n             let loop_expr = P(ast::Expr {\n-                node: ast::ExprLoop(empty_block, None),\n+                node: ast::ExprKind::Loop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,\n                 attrs: None,"}, {"sha": "fe44ba7a646d2572546f6b62149ee120fc40060b", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -986,12 +986,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n             // }\n             //\n             // But for now there are type-inference issues doing that.\n-            ExprBox(ref e) => {\n+            ExprKind::Box(ref e) => {\n                 hir::ExprBox(lower_expr(lctx, e))\n             }\n \n             // Desugar ExprBox: `in (PLACE) EXPR`\n-            ExprInPlace(ref placer, ref value_expr) => {\n+            ExprKind::InPlace(ref placer, ref value_expr) => {\n                 // to:\n                 //\n                 // let p = PLACE;\n@@ -1099,57 +1099,57 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n             }\n \n-            ExprVec(ref exprs) => {\n+            ExprKind::Vec(ref exprs) => {\n                 hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprRepeat(ref expr, ref count) => {\n+            ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = lower_expr(lctx, expr);\n                 let count = lower_expr(lctx, count);\n                 hir::ExprRepeat(expr, count)\n             }\n-            ExprTup(ref elts) => {\n+            ExprKind::Tup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprCall(ref f, ref args) => {\n+            ExprKind::Call(ref f, ref args) => {\n                 let f = lower_expr(lctx, f);\n                 hir::ExprCall(f, args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprMethodCall(i, ref tps, ref args) => {\n+            ExprKind::MethodCall(i, ref tps, ref args) => {\n                 let tps = tps.iter().map(|x| lower_ty(lctx, x)).collect();\n                 let args = args.iter().map(|x| lower_expr(lctx, x)).collect();\n                 hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n             }\n-            ExprBinary(binop, ref lhs, ref rhs) => {\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = lower_binop(lctx, binop);\n                 let lhs = lower_expr(lctx, lhs);\n                 let rhs = lower_expr(lctx, rhs);\n                 hir::ExprBinary(binop, lhs, rhs)\n             }\n-            ExprUnary(op, ref ohs) => {\n+            ExprKind::Unary(op, ref ohs) => {\n                 let op = lower_unop(lctx, op);\n                 let ohs = lower_expr(lctx, ohs);\n                 hir::ExprUnary(op, ohs)\n             }\n-            ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n-            ExprCast(ref expr, ref ty) => {\n+            ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = lower_expr(lctx, expr);\n                 hir::ExprCast(expr, lower_ty(lctx, ty))\n             }\n-            ExprType(ref expr, ref ty) => {\n+            ExprKind::Type(ref expr, ref ty) => {\n                 let expr = lower_expr(lctx, expr);\n                 hir::ExprType(expr, lower_ty(lctx, ty))\n             }\n-            ExprAddrOf(m, ref ohs) => {\n+            ExprKind::AddrOf(m, ref ohs) => {\n                 let m = lower_mutability(lctx, m);\n                 let ohs = lower_expr(lctx, ohs);\n                 hir::ExprAddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n-            ExprIf(ref cond, ref blk, ref else_opt) => {\n+            ExprKind::If(ref cond, ref blk, ref else_opt) => {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n-                        ExprIfLet(..) => {\n+                        ExprKind::IfLet(..) => {\n                             cache_ids(lctx, e.id, |lctx| {\n                                 // wrap the if-let expr in a block\n                                 let span = els.span;\n@@ -1171,47 +1171,47 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                 hir::ExprIf(lower_expr(lctx, cond), lower_block(lctx, blk), else_opt)\n             }\n-            ExprWhile(ref cond, ref body, opt_ident) => {\n+            ExprKind::While(ref cond, ref body, opt_ident) => {\n                 hir::ExprWhile(lower_expr(lctx, cond), lower_block(lctx, body),\n                                opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n-            ExprLoop(ref body, opt_ident) => {\n+            ExprKind::Loop(ref body, opt_ident) => {\n                 hir::ExprLoop(lower_block(lctx, body),\n                               opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n-            ExprMatch(ref expr, ref arms) => {\n+            ExprKind::Match(ref expr, ref arms) => {\n                 hir::ExprMatch(lower_expr(lctx, expr),\n                                arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n                                hir::MatchSource::Normal)\n             }\n-            ExprClosure(capture_clause, ref decl, ref body) => {\n+            ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n                                  lower_fn_decl(lctx, decl),\n                                  lower_block(lctx, body))\n             }\n-            ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n-            ExprAssign(ref el, ref er) => {\n+            ExprKind::Block(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n+            ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n-            ExprAssignOp(op, ref el, ref er) => {\n+            ExprKind::AssignOp(op, ref el, ref er) => {\n                 hir::ExprAssignOp(lower_binop(lctx, op),\n                                   lower_expr(lctx, el),\n                                   lower_expr(lctx, er))\n             }\n-            ExprField(ref el, ident) => {\n+            ExprKind::Field(ref el, ident) => {\n                 hir::ExprField(lower_expr(lctx, el), respan(ident.span, ident.node.name))\n             }\n-            ExprTupField(ref el, ident) => {\n+            ExprKind::TupField(ref el, ident) => {\n                 hir::ExprTupField(lower_expr(lctx, el), ident)\n             }\n-            ExprIndex(ref el, ref er) => {\n+            ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n-            ExprRange(ref e1, ref e2) => {\n+            ExprKind::Range(ref e1, ref e2) => {\n                 hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n                                e2.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n-            ExprPath(ref qself, ref path) => {\n+            ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n                         ty: lower_ty(lctx, ty),\n@@ -1220,14 +1220,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n                 hir::ExprPath(hir_qself, lower_path_full(lctx, path, qself.is_none()))\n             }\n-            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n+            ExprKind::Break(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n                 respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n             })),\n-            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n+            ExprKind::Again(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n                 respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n             })),\n-            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n-            ExprInlineAsm(InlineAsm {\n+            ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n+            ExprKind::InlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n                     ref asm,\n@@ -1259,12 +1259,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 dialect: dialect,\n                 expn_id: expn_id,\n             }),\n-            ExprStruct(ref path, ref fields, ref maybe_expr) => {\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                 hir::ExprStruct(lower_path(lctx, path),\n                                 fields.iter().map(|x| lower_field(lctx, x)).collect(),\n                                 maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n-            ExprParen(ref ex) => {\n+            ExprKind::Paren(ref ex) => {\n                 // merge attributes into the inner expression.\n                 return lower_expr(lctx, ex).map(|mut ex| {\n                     ex.attrs.update(|attrs| {\n@@ -1276,7 +1276,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+            ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n                 //   match <sub_expr> {\n@@ -1364,7 +1364,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -1410,7 +1410,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprForLoop\n             // From: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_ident) => {\n                 // to:\n                 //\n                 //   {\n@@ -1524,7 +1524,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n             }\n \n-            ExprMac(_) => panic!(\"Shouldn't exist here\"),\n+            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n         attrs: e.attrs.clone(),"}, {"sha": "bbd714fad06bbbb9b78d2e058e4b19abda063b83", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -293,7 +293,7 @@ pub struct UnusedParens;\n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n+        if let ast::ExprKind::Paren(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n@@ -308,26 +308,26 @@ impl UnusedParens {\n         /// y: 1 }) == foo` does not.\n         fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             match value.node {\n-                ast::ExprStruct(..) => true,\n+                ast::ExprKind::Struct(..) => true,\n \n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                ast::ExprKind::Assign(ref lhs, ref rhs) |\n+                ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n                     contains_exterior_struct_lit(&**lhs) ||\n                         contains_exterior_struct_lit(&**rhs)\n                 }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprType(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n+                ast::ExprKind::Unary(_, ref x) |\n+                ast::ExprKind::Cast(ref x, _) |\n+                ast::ExprKind::Type(ref x, _) |\n+                ast::ExprKind::Field(ref x, _) |\n+                ast::ExprKind::TupField(ref x, _) |\n+                ast::ExprKind::Index(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n                     contains_exterior_struct_lit(&**x)\n                 }\n \n-                ast::ExprMethodCall(_, _, ref exprs) => {\n+                ast::ExprKind::MethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n                     contains_exterior_struct_lit(&*exprs[0])\n                 }\n@@ -346,17 +346,18 @@ impl LintPass for UnusedParens {\n \n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+        use syntax::ast::ExprKind::*;\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprIfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n-            ast::ExprWhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n-            ast::ExprForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n-            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n-            ast::ExprInPlace(_, ref value) => (value, \"emplacement value\", false),\n+            If(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            While(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            IfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n+            WhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n+            ForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n+            Match(ref head, _) => (head, \"`match` head expression\", true),\n+            Ret(Some(ref value)) => (value, \"`return` value\", false),\n+            Assign(_, ref value) => (value, \"assigned value\", false),\n+            AssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            InPlace(_, ref value) => (value, \"emplacement value\", false),\n             _ => return\n         };\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);"}, {"sha": "5ec00439df21f7cadb4bfe45dd64cc5ddf3f72c8", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'v> Visitor<'v> for CheckBlock<'a> {\n         CheckConstFn{ sess: self.sess}.visit_block(block);\n     }\n     fn visit_expr(&mut self, e: &'v ast::Expr) {\n-        if let ast::ExprClosure(..) = e.node {\n+        if let ast::ExprKind::Closure(..) = e.node {\n             CheckConstFn{ sess: self.sess}.visit_expr(e);\n         } else {\n             visit::walk_expr(self, e);"}, {"sha": "90f92c25b05ea54d80d768782537336e236fc08a", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -32,8 +32,8 @@ struct CheckNoAsm<'a> {\n impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprInlineAsm(_) => span_err!(self.sess, e.span, E0472,\n-                                               \"asm! is unsupported on this target\"),\n+            ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,\n+                                                     \"asm! is unsupported on this target\"),\n             _ => {},\n         }\n         visit::walk_expr(self, e)"}, {"sha": "e8a0e4a8d42674c9b6c364e8dd4f00f2c66727c8", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -1083,23 +1083,23 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         self.process_macro_use(ex.span, ex.id);\n         match ex.node {\n-            ast::ExprCall(ref _f, ref _args) => {\n+            ast::ExprKind::Call(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprPath(_, ref path) => {\n+            ast::ExprKind::Path(_, ref path) => {\n                 self.process_path(ex.id, path, None);\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprStruct(ref path, ref fields, ref base) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = lower_expr(self.save_ctxt.lcx, ex);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.resolve_expr(&hir_expr);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n-            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, _) => {\n+            ast::ExprKind::MethodCall(_, _, ref args) => self.process_method_call(ex, args),\n+            ast::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -1111,7 +1111,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                      field_data.scope);\n                 }\n             }\n-            ast::ExprTupField(ref sub_ex, idx) => {\n+            ast::ExprKind::TupField(ref sub_ex, idx) => {\n                 self.visit_expr(&**sub_ex);\n \n                 let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n@@ -1131,7 +1131,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                                      ty)),\n                 }\n             }\n-            ast::ExprClosure(_, ref decl, ref body) => {\n+            ast::ExprKind::Closure(_, ref decl, ref body) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n                 self.process_formals(&decl.inputs, &id);\n@@ -1148,14 +1148,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));\n             }\n-            ast::ExprForLoop(ref pattern, ref subexpression, ref block, _) |\n-            ast::ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n+            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n+            ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n                 let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprIfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n+            ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n                 let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);"}, {"sha": "116051f6fe5f49f65767b4775c3812a5d7c208eb", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -487,7 +487,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             return None;\n         }\n         match expr.node {\n-            ast::ExprField(ref sub_ex, ident) => {\n+            ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let hir_node = lowering::lower_expr(self.lcx, sub_ex);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n@@ -507,7 +507,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprStruct(ref path, _, _) => {\n+            ast::ExprKind::Struct(ref path, _, _) => {\n                 let hir_node = lowering::lower_expr(self.lcx, expr);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n@@ -527,7 +527,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprMethodCall(..) => {\n+            ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n@@ -544,7 +544,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     decl_id: decl_id,\n                 }))\n             }\n-            ast::ExprPath(_, ref path) => {\n+            ast::ExprKind::Path(_, ref path) => {\n                 self.get_path_data(expr.id, path)\n             }\n             _ => {"}, {"sha": "36543bd35ca539aa8bd0dc70907b65c220fc8fac", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::Expr_::*;\n pub use self::FloatTy::*;\n pub use self::ForeignItem_::*;\n pub use self::IntTy::*;\n@@ -880,7 +879,7 @@ pub enum UnsafeSource {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: Expr_,\n+    pub node: ExprKind,\n     pub span: Span,\n     pub attrs: ThinAttributes\n }\n@@ -901,18 +900,18 @@ impl fmt::Debug for Expr {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Expr_ {\n+pub enum ExprKind {\n     /// A `box x` expression.\n-    ExprBox(P<Expr>),\n+    Box(P<Expr>),\n     /// First expr is the place; second expr is the value.\n-    ExprInPlace(P<Expr>, P<Expr>),\n+    InPlace(P<Expr>, P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(Vec<P<Expr>>),\n+    Vec(Vec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    Call(P<Expr>, Vec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `SpannedIdent` is the identifier for the method name.\n@@ -924,109 +923,109 @@ pub enum Expr_ {\n     /// and the remaining elements are the rest of the arguments.\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    /// `ExprKind::MethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n+    MethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(Vec<P<Expr>>),\n+    Tup(Vec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n-    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n-    ExprUnary(UnOp, P<Expr>),\n+    Unary(UnOp, P<Expr>),\n     /// A literal (For example: `1u8`, `\"foo\"`)\n-    ExprLit(P<Lit>),\n+    Lit(P<Lit>),\n     /// A cast (`foo as f64`)\n-    ExprCast(P<Expr>, P<Ty>),\n-    ExprType(P<Expr>, P<Ty>),\n+    Cast(P<Expr>, P<Ty>),\n+    Type(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n     ///\n     /// `if expr { block } else { expr }`\n-    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    If(P<Expr>, P<Block>, Option<P<Expr>>),\n     /// An `if let` expression with an optional else block\n     ///\n     /// `if let pat = expr { block } else { expr }`\n     ///\n     /// This is desugared to a `match` expression.\n-    ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n+    IfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n+    While(P<Expr>, P<Block>, Option<Ident>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Ident>),\n+    Loop(P<Block>, Option<Ident>),\n     /// A `match` block.\n-    ExprMatch(P<Expr>, Vec<Arm>),\n+    Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n-    ExprClosure(CaptureBy, P<FnDecl>, P<Block>),\n+    Closure(CaptureBy, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n-    ExprBlock(P<Block>),\n+    Block(P<Block>),\n \n     /// An assignment (`a = foo()`)\n-    ExprAssign(P<Expr>, P<Expr>),\n+    Assign(P<Expr>, P<Expr>),\n     /// An assignment with an operator\n     ///\n     /// For example, `a += 1`.\n-    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    ExprField(P<Expr>, SpannedIdent),\n+    Field(P<Expr>, SpannedIdent),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n-    ExprTupField(P<Expr>, Spanned<usize>),\n+    TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n-    ExprIndex(P<Expr>, P<Expr>),\n+    Index(P<Expr>, P<Expr>),\n     /// A range (`1..2`, `1..`, or `..2`)\n-    ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n+    Range(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>.\n     ///\n     /// Optionally \"qualified\",\n     /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n-    ExprPath(Option<QSelf>, Path),\n+    Path(Option<QSelf>, Path),\n \n     /// A referencing operation (`&a` or `&mut a`)\n-    ExprAddrOf(Mutability, P<Expr>),\n+    AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<SpannedIdent>),\n+    Break(Option<SpannedIdent>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<SpannedIdent>),\n+    Again(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned\n-    ExprRet(Option<P<Expr>>),\n+    Ret(Option<P<Expr>>),\n \n     /// Output of the `asm!()` macro\n-    ExprInlineAsm(InlineAsm),\n+    InlineAsm(InlineAsm),\n \n     /// A macro invocation; pre-expansion\n-    ExprMac(Mac),\n+    Mac(Mac),\n \n     /// A struct literal expression.\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+    Struct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1u8; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, P<Expr>),\n+    Repeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n-    ExprParen(P<Expr>)\n+    Paren(P<Expr>),\n }\n \n /// The explicit Self type in a \"qualified path\". The actual"}, {"sha": "8ccff527b8831a6abcbed2ce6216cfb7f4dfc320", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -27,7 +27,7 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n }\n \n pub fn is_path(e: P<Expr>) -> bool {\n-    match e.node { ExprPath(..) => true, _ => false }\n+    match e.node { ExprKind::Path(..) => true, _ => false }\n }\n \n "}, {"sha": "8d74990fc32c6e316a221b60a8ff3df3a4c898d8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -212,8 +212,8 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n-                ast::ExprMatch(m, arms) => {\n-                    ast::ExprMatch(m, arms.into_iter()\n+                ast::ExprKind::Match(m, arms) => {\n+                    ast::ExprKind::Match(m, arms.into_iter()\n                                         .filter(|a| (cx.in_cfg)(&a.attrs))\n                                         .collect())\n                 }"}, {"sha": "33414a697a70d8b124629d91db17b27fa987a819", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -303,7 +303,7 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprLit(_) = e.node {\n+            if let ast::ExprKind::Lit(_) = e.node {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n@@ -349,7 +349,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n+            node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitBool(false)))),\n             span: sp,\n             attrs: None,\n         })\n@@ -773,7 +773,7 @@ pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n-        ast::ExprLit(ref l) => match l.node {\n+        ast::ExprKind::Lit(ref l) => match l.node {\n             ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },"}, {"sha": "446c90f310d437b9110b841c46acf8a21f3331aa", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -108,7 +108,7 @@ pub trait AstBuilder {\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n+    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n@@ -578,7 +578,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr> {\n+    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n@@ -588,12 +588,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(path.span, ast::ExprPath(None, path))\n+        self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n     /// Constructs a QPath expression.\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprPath(Some(qself), path))\n+        self.expr(span, ast::ExprKind::Path(Some(qself), path))\n     }\n \n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n@@ -605,14 +605,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBinary(Spanned { node: op, span: sp }, lhs, rhs))\n+        self.expr(sp, ast::ExprKind::Binary(Spanned { node: op, span: sp }, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr_unary(sp, UnOp::Deref, e)\n     }\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprUnary(op, e))\n+        self.expr(sp, ast::ExprKind::Unary(op, e))\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n@@ -623,7 +623,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n-        self.expr(sp, ast::ExprField(expr, id))\n+        self.expr(sp, ast::ExprKind::Field(expr, id))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let field_span = Span {\n@@ -633,21 +633,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: idx, span: field_span };\n-        self.expr(sp, ast::ExprTupField(expr, id))\n+        self.expr(sp, ast::ExprKind::TupField(expr, id))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::MutImmutable, e))\n     }\n     fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::MutMutable, e))\n     }\n \n     fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprCall(expr, args))\n+        self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n     fn expr_call_ident(&self, span: Span, id: ast::Ident,\n                        args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n+        self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n                       args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n@@ -660,24 +660,24 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.insert(0, expr);\n-        self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n+        self.expr(span, ast::ExprKind::MethodCall(id, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(b.span, ast::ExprBlock(b))\n+        self.expr(b.span, ast::ExprKind::Block(b))\n     }\n     fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprStruct(path, fields, None))\n+        self.expr(span, ast::ExprKind::Struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n                          id: ast::Ident, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n+        self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs)))\n@@ -697,7 +697,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprVec(exprs))\n+        self.expr(sp, ast::ExprKind::Vec(exprs))\n     }\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n         self.expr_call_global(sp, self.std_path(&[\"vec\", \"Vec\", \"new\"]),\n@@ -711,7 +711,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprCast(expr, ty))\n+        self.expr(sp, ast::ExprKind::Cast(expr, ty))\n     }\n \n \n@@ -728,12 +728,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBreak(None))\n+        self.expr(sp, ast::ExprKind::Break(None))\n     }\n \n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprTup(exprs))\n+        self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n@@ -785,7 +785,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec!(binding_expr.clone()));\n         // return Err(__try_var)\n-        let err_expr = self.expr(sp, ast::ExprRet(Some(err_inner_expr)));\n+        let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n         // Ok(__try_var) => __try_var\n         let ok_arm = self.arm(sp, vec!(ok_pat), binding_expr);\n@@ -868,29 +868,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n-        self.expr(span, ast::ExprMatch(arg, arms))\n+        self.expr(span, ast::ExprKind::Match(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n                then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n-        self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n+        self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n     fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprLoop(block, None))\n+        self.expr(span, ast::ExprKind::Loop(block, None))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprClosure(ast::CaptureBy::Ref, fn_decl, blk))\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprClosure(ast::CaptureBy::Ref, fn_decl, blk))\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)"}, {"sha": "69b932aa72baae1c4ec3685435f5906eded36f60", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -42,7 +42,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        ast::ExprMac(mac) => {\n+        ast::ExprKind::Mac(mac) => {\n \n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n@@ -69,7 +69,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n-        ast::ExprInPlace(placer, value_expr) => {\n+        ast::ExprKind::InPlace(placer, value_expr) => {\n             // Ensure feature-gate is enabled\n             feature_gate::check_for_placement_in(\n                 fld.cx.ecfg.features,\n@@ -78,18 +78,18 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n-            fld.cx.expr(span, ast::ExprInPlace(placer, value_expr))\n+            fld.cx.expr(span, ast::ExprKind::InPlace(placer, value_expr))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprWhile(cond, body, opt_ident) => {\n+        ast::ExprKind::While(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprKind::While(cond, body, opt_ident))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n+        ast::ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n             let expr = fld.fold_expr(expr);\n \n@@ -103,17 +103,17 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             });\n             assert!(rewritten_pats.len() == 1);\n \n-            fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), expr, body, opt_ident);\n+            fld.cx.expr(span, wl).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprLoop(loop_block, opt_ident) => {\n+        ast::ExprKind::Loop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+            fld.cx.expr(span, ast::ExprKind::Loop(loop_block, opt_ident))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprForLoop(pat, head, body, opt_ident) => {\n+        ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n \n             // Hygienic renaming of the for loop body (for loop binds its pattern).\n@@ -127,11 +127,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             let head = fld.fold_expr(head);\n-            fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let fl = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n+            fld.cx.expr(span, fl).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n+        ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n             let pat = fld.fold_pat(pat);\n \n             // Hygienic renaming of the body.\n@@ -146,14 +146,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n-            fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let il = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n+            fld.cx.expr(span, il).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprClosure(capture_clause, fn_decl, block) => {\n+        ast::ExprKind::Closure(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprClosure(capture_clause,\n+            let new_node = ast::ExprKind::Closure(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span),\n@@ -1427,7 +1427,7 @@ mod tests {\n \n     impl<'v> Visitor<'v> for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n-            if let ast::ExprPath(None, ref p) = expr.node {\n+            if let ast::ExprKind::Path(None, ref p) = expr.node {\n                 self.path_accumulator.push(p.clone());\n             }\n             visit::walk_expr(self, expr);\n@@ -1694,7 +1694,7 @@ mod tests {\n             0)\n     }\n \n-    // closure arg hygiene (ExprClosure)\n+    // closure arg hygiene (ExprKind::Closure)\n     // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n     #[test]\n     fn closure_arg_hygiene(){"}, {"sha": "d7a47b4050640cb7db83ea4cdeb177631a7b634f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -240,7 +240,7 @@ pub mod rt {\n             // FIXME: This is wrong\n             P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprLit(P(self.clone())),\n+                node: ast::ExprKind::Lit(P(self.clone())),\n                 span: DUMMY_SP,\n                 attrs: None,\n             }).to_tokens(cx)"}, {"sha": "17eb43e2068a702a65b4c1876b4cd1753953000c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -815,11 +815,11 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // But we keep these checks as a pre-expansion check to catch\n         // uses in e.g. conditionalized code.\n \n-        if let ast::ExprBox(_) = e.node {\n+        if let ast::ExprKind::Box(_) = e.node {\n             self.context.gate_feature(\"box_syntax\", e.span, EXPLAIN_BOX_SYNTAX);\n         }\n \n-        if let ast::ExprInPlace(..) = e.node {\n+        if let ast::ExprKind::InPlace(..) = e.node {\n             self.context.gate_feature(\"placement_in_syntax\", e.span, EXPLAIN_PLACEMENT_IN);\n         }\n \n@@ -988,13 +988,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprBox(_) => {\n+            ast::ExprKind::Box(_) => {\n                 self.gate_feature(\"box_syntax\",\n                                   e.span,\n                                   \"box expression syntax is experimental; \\\n                                    you can call `Box::new` instead.\");\n             }\n-            ast::ExprType(..) => {\n+            ast::ExprKind::Type(..) => {\n                 self.gate_feature(\"type_ascription\", e.span,\n                                   \"type ascription is experimental\");\n             }"}, {"sha": "8cd2d24102f393d6e43a0fd3f71f6220df6ddb42", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -1168,131 +1168,131 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n+            ExprKind::Box(e) => {\n+                ExprKind::Box(folder.fold_expr(e))\n             }\n-            ExprInPlace(p, e) => {\n-                ExprInPlace(folder.fold_expr(p), folder.fold_expr(e))\n+            ExprKind::InPlace(p, e) => {\n+                ExprKind::InPlace(folder.fold_expr(p), folder.fold_expr(e))\n             }\n-            ExprVec(exprs) => {\n-                ExprVec(folder.fold_exprs(exprs))\n+            ExprKind::Vec(exprs) => {\n+                ExprKind::Vec(folder.fold_exprs(exprs))\n             }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n+            ExprKind::Repeat(expr, count) => {\n+                ExprKind::Repeat(folder.fold_expr(expr), folder.fold_expr(count))\n             }\n-            ExprTup(exprs) => ExprTup(folder.fold_exprs(exprs)),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f),\n+            ExprKind::Tup(exprs) => ExprKind::Tup(folder.fold_exprs(exprs)),\n+            ExprKind::Call(f, args) => {\n+                ExprKind::Call(folder.fold_expr(f),\n                          folder.fold_exprs(args))\n             }\n-            ExprMethodCall(i, tps, args) => {\n-                ExprMethodCall(\n+            ExprKind::MethodCall(i, tps, args) => {\n+                ExprKind::MethodCall(\n                     respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n                     folder.fold_exprs(args))\n             }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop,\n+            ExprKind::Binary(binop, lhs, rhs) => {\n+                ExprKind::Binary(binop,\n                         folder.fold_expr(lhs),\n                         folder.fold_expr(rhs))\n             }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n+            ExprKind::Unary(binop, ohs) => {\n+                ExprKind::Unary(binop, folder.fold_expr(ohs))\n             }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n+            ExprKind::Lit(l) => ExprKind::Lit(l),\n+            ExprKind::Cast(expr, ty) => {\n+                ExprKind::Cast(folder.fold_expr(expr), folder.fold_ty(ty))\n             }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n+            ExprKind::Type(expr, ty) => {\n+                ExprKind::Type(folder.fold_expr(expr), folder.fold_ty(ty))\n             }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n+            ExprKind::AddrOf(m, ohs) => ExprKind::AddrOf(m, folder.fold_expr(ohs)),\n+            ExprKind::If(cond, tr, fl) => {\n+                ExprKind::If(folder.fold_expr(cond),\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprIfLet(pat, expr, tr, fl) => {\n-                ExprIfLet(folder.fold_pat(pat),\n+            ExprKind::IfLet(pat, expr, tr, fl) => {\n+                ExprKind::IfLet(folder.fold_pat(pat),\n                           folder.fold_expr(expr),\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprWhile(cond, body, opt_ident) => {\n-                ExprWhile(folder.fold_expr(cond),\n+            ExprKind::While(cond, body, opt_ident) => {\n+                ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n                           opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprWhileLet(pat, expr, body, opt_ident) => {\n-                ExprWhileLet(folder.fold_pat(pat),\n+            ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n+                ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n                              opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprForLoop(pat, iter, body, opt_ident) => {\n-                ExprForLoop(folder.fold_pat(pat),\n+            ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n+                ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n                             opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprLoop(body, opt_ident) => {\n-                ExprLoop(folder.fold_block(body),\n+            ExprKind::Loop(body, opt_ident) => {\n+                ExprKind::Loop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprMatch(expr, arms) => {\n-                ExprMatch(folder.fold_expr(expr),\n+            ExprKind::Match(expr, arms) => {\n+                ExprKind::Match(folder.fold_expr(expr),\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n-            ExprClosure(capture_clause, decl, body) => {\n-                ExprClosure(capture_clause,\n+            ExprKind::Closure(capture_clause, decl, body) => {\n+                ExprKind::Closure(capture_clause,\n                             folder.fold_fn_decl(decl),\n                             folder.fold_block(body))\n             }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n+            ExprKind::Block(blk) => ExprKind::Block(folder.fold_block(blk)),\n+            ExprKind::Assign(el, er) => {\n+                ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op,\n+            ExprKind::AssignOp(op, el, er) => {\n+                ExprKind::AssignOp(op,\n                             folder.fold_expr(el),\n                             folder.fold_expr(er))\n             }\n-            ExprField(el, ident) => {\n-                ExprField(folder.fold_expr(el),\n+            ExprKind::Field(el, ident) => {\n+                ExprKind::Field(folder.fold_expr(el),\n                           respan(folder.new_span(ident.span),\n                                  folder.fold_ident(ident.node)))\n             }\n-            ExprTupField(el, ident) => {\n-                ExprTupField(folder.fold_expr(el),\n+            ExprKind::TupField(el, ident) => {\n+                ExprKind::TupField(folder.fold_expr(el),\n                              respan(folder.new_span(ident.span),\n                                     folder.fold_usize(ident.node)))\n             }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n+            ExprKind::Index(el, er) => {\n+                ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprRange(e1, e2) => {\n-                ExprRange(e1.map(|x| folder.fold_expr(x)),\n+            ExprKind::Range(e1, e2) => {\n+                ExprKind::Range(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n-            ExprPath(qself, path) => {\n+            ExprKind::Path(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {\n                     QSelf {\n                         ty: folder.fold_ty(ty),\n                         position: position\n                     }\n                 });\n-                ExprPath(qself, folder.fold_path(path))\n+                ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label|\n+            ExprKind::Break(opt_ident) => ExprKind::Break(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label|\n+            ExprKind::Again(opt_ident) => ExprKind::Again(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(InlineAsm {\n+            ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n+            ExprKind::InlineAsm(InlineAsm {\n                 inputs,\n                 outputs,\n                 asm,\n@@ -1302,7 +1302,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 alignstack,\n                 dialect,\n                 expn_id,\n-            }) => ExprInlineAsm(InlineAsm {\n+            }) => ExprKind::InlineAsm(InlineAsm {\n                 inputs: inputs.move_map(|(c, input)| {\n                     (c, folder.fold_expr(input))\n                 }),\n@@ -1322,13 +1322,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 dialect: dialect,\n                 expn_id: expn_id,\n             }),\n-            ExprMac(mac) => ExprMac(folder.fold_mac(mac)),\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n+            ExprKind::Mac(mac) => ExprKind::Mac(folder.fold_mac(mac)),\n+            ExprKind::Struct(path, fields, maybe_expr) => {\n+                ExprKind::Struct(folder.fold_path(path),\n                         fields.move_map(|x| folder.fold_field(x)),\n                         maybe_expr.map(|x| folder.fold_expr(x)))\n             },\n-            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n+            ExprKind::Paren(ex) => ExprKind::Paren(folder.fold_expr(ex))\n         },\n         span: folder.new_span(span),\n         attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),"}, {"sha": "325fe64203cc97623469b8e2279bbc2ef7a77af6", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -23,21 +23,21 @@ use ast::{self, BlockCheckMode};\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprIf(..) |\n-        ast::ExprIfLet(..) |\n-        ast::ExprMatch(..) |\n-        ast::ExprBlock(_) |\n-        ast::ExprWhile(..) |\n-        ast::ExprWhileLet(..) |\n-        ast::ExprLoop(..) |\n-        ast::ExprForLoop(..) => false,\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Match(..) |\n+        ast::ExprKind::Block(_) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::ForLoop(..) => false,\n         _ => true,\n     }\n }\n \n pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprBlock(ref block) => block.rules == BlockCheckMode::Default,\n+        ast::ExprKind::Block(ref block) => block.rules == BlockCheckMode::Default,\n         _ => false,\n     }\n }"}, {"sha": "9ad5dafbf8ba5e0d17ce8283be67e6669e1bfee3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -703,7 +703,7 @@ mod tests {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(None, ast::Path {\n+                    node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n                         segments: vec!(\n@@ -722,7 +722,7 @@ mod tests {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(None, ast::Path {\n+                    node: ast::ExprKind::Path(None, ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n                             segments: vec!(\n@@ -852,9 +852,9 @@ mod tests {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(P(ast::Expr{\n+                    node:ast::ExprKind::Ret(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n-                        node:ast::ExprPath(None, ast::Path{\n+                        node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n                             segments: vec!(\n@@ -877,7 +877,7 @@ mod tests {\n                    Some(P(Spanned{\n                        node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n-                           node: ast::ExprPath(None, ast::Path {\n+                           node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n                                segments: vec!(\n@@ -968,7 +968,7 @@ mod tests {\n                                         stmts: vec!(P(Spanned{\n                                             node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n-                                                node: ast::ExprPath(None,\n+                                                node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n@@ -1110,7 +1110,7 @@ mod tests {\n             \"foo!( fn main() { body } )\".to_string(), vec![], &sess);\n \n         let tts = match expr.node {\n-            ast::ExprMac(ref mac) => mac.node.tts.clone(),\n+            ast::ExprKind::Mac(ref mac) => mac.node.tts.clone(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "df73e8815edfe57fde0fd3547cfb24fde5bdc7f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -20,14 +20,8 @@ use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, ConstTraitItem, Crate, CrateConfig};\n use ast::{Decl, DeclKind};\n use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n-use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n-use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n-use ast::{ExprBreak, ExprCall, ExprCast, ExprInPlace};\n-use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n-use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n-use ast::{ExprMethodCall, ExprParen, ExprPath};\n-use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprType, ExprUnary};\n-use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n+use ast::{Expr, ExprKind};\n+use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n@@ -140,7 +134,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), None))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -150,7 +144,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), None))\n                 }\n                 _ => None\n             };\n@@ -508,7 +502,7 @@ impl<'a> Parser<'a> {\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token],\n                        inedible: &[token::Token]) -> PResult<'a, ()> {\n         debug!(\"commit_expr {:?}\", e);\n-        if let ExprPath(..) = e.node {\n+        if let ExprKind::Path(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n             let expected = edible.iter()\n                 .cloned()\n@@ -1529,7 +1523,7 @@ impl<'a> Parser<'a> {\n         match *tok {\n             token::Interpolated(token::NtExpr(ref v)) => {\n                 match v.node {\n-                    ExprLit(ref lit) => { Ok(lit.node.clone()) }\n+                    ExprKind::Lit(ref lit) => { Ok(lit.node.clone()) }\n                     _ => { return self.unexpected_last(tok); }\n                 }\n             }\n@@ -1605,7 +1599,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let literal = P(try!(self.parse_lit()));\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprLit(literal), None);\n+        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), None);\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n@@ -1957,7 +1951,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n-                   node: Expr_, attrs: ThinAttributes) -> P<Expr> {\n+                   node: ExprKind, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n@@ -1966,55 +1960,55 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::Expr_ {\n-        ExprUnary(unop, expr)\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Unary(unop, expr)\n     }\n \n-    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n-        ExprBinary(binop, lhs, rhs)\n+    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Binary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::Expr_ {\n-        ExprCall(f, args)\n+    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind {\n+        ExprKind::Call(f, args)\n     }\n \n     fn mk_method_call(&mut self,\n                       ident: ast::SpannedIdent,\n                       tps: Vec<P<Ty>>,\n                       args: Vec<P<Expr>>)\n-                      -> ast::Expr_ {\n-        ExprMethodCall(ident, tps, args)\n+                      -> ast::ExprKind {\n+        ExprKind::MethodCall(ident, tps, args)\n     }\n \n-    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::Expr_ {\n-        ExprIndex(expr, idx)\n+    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Index(expr, idx)\n     }\n \n     pub fn mk_range(&mut self,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>)\n-                    -> ast::Expr_ {\n-        ExprRange(start, end)\n+                    -> ast::ExprKind {\n+        ExprKind::Range(start, end)\n     }\n \n-    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::Expr_ {\n-        ExprField(expr, ident)\n+    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n+        ExprKind::Field(expr, ident)\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::Expr_ {\n-        ExprTupField(expr, idx)\n+    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n+        ExprKind::TupField(expr, idx)\n     }\n \n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n-                        lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n-        ExprAssignOp(binop, lhs, rhs)\n+                        lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n+        ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n                        m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n             attrs: attrs,\n         })\n@@ -2029,7 +2023,7 @@ impl<'a> Parser<'a> {\n \n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprLit(lv_lit),\n+            node: ExprKind::Lit(lv_lit),\n             span: *span,\n             attrs: attrs,\n         })\n@@ -2066,7 +2060,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n-        let ex: Expr_;\n+        let ex: ExprKind;\n \n         // Note: when adding new syntax here, don't forget to adjust Token::can_begin_expr().\n         match self.token {\n@@ -2098,9 +2092,9 @@ impl<'a> Parser<'a> {\n \n                 hi = self.last_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()), attrs))\n+                    Ok(self.mk_expr(lo, hi, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprTup(es), attrs))\n+                    Ok(self.mk_expr(lo, hi, ExprKind::Tup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n@@ -2116,7 +2110,7 @@ impl<'a> Parser<'a> {\n                          }, token::Plain) => {\n                 self.bump();\n                 let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n-                ex = ExprPath(None, path);\n+                ex = ExprKind::Path(None, path);\n                 hi = self.last_span.hi;\n             }\n             token::OpenDelim(token::Bracket) => {\n@@ -2129,7 +2123,7 @@ impl<'a> Parser<'a> {\n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     self.bump();\n-                    ex = ExprVec(Vec::new());\n+                    ex = ExprKind::Vec(Vec::new());\n                 } else {\n                     // Nonempty vector.\n                     let first_expr = try!(self.parse_expr());\n@@ -2138,7 +2132,7 @@ impl<'a> Parser<'a> {\n                         self.bump();\n                         let count = try!(self.parse_expr());\n                         try!(self.expect(&token::CloseDelim(token::Bracket)));\n-                        ex = ExprRepeat(first_expr, count);\n+                        ex = ExprKind::Repeat(first_expr, count);\n                     } else if self.check(&token::Comma) {\n                         // Vector with two or more elements.\n                         self.bump();\n@@ -2149,11 +2143,11 @@ impl<'a> Parser<'a> {\n                                 ));\n                         let mut exprs = vec!(first_expr);\n                         exprs.extend(remaining_exprs);\n-                        ex = ExprVec(exprs);\n+                        ex = ExprKind::Vec(exprs);\n                     } else {\n                         // Vector with one element.\n                         try!(self.expect(&token::CloseDelim(token::Bracket)));\n-                        ex = ExprVec(vec!(first_expr));\n+                        ex = ExprKind::Vec(vec!(first_expr));\n                     }\n                 }\n                 hi = self.last_span.hi;\n@@ -2163,7 +2157,7 @@ impl<'a> Parser<'a> {\n                     let (qself, path) =\n                         try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n                     hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path), attrs));\n+                    return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n                     let lo = self.last_span.lo;\n@@ -2202,14 +2196,14 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n                     let ex = if self.token.is_lifetime() {\n-                        let ex = ExprAgain(Some(Spanned{\n+                        let ex = ExprKind::Again(Some(Spanned{\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                         ex\n                     } else {\n-                        ExprAgain(None)\n+                        ExprKind::Again(None)\n                     };\n                     let hi = self.last_span.hi;\n                     return Ok(self.mk_expr(lo, hi, ex, attrs));\n@@ -2227,19 +2221,19 @@ impl<'a> Parser<'a> {\n                     if self.token.can_begin_expr() {\n                         let e = try!(self.parse_expr());\n                         hi = e.span.hi;\n-                        ex = ExprRet(Some(e));\n+                        ex = ExprKind::Ret(Some(e));\n                     } else {\n-                        ex = ExprRet(None);\n+                        ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n                     if self.token.is_lifetime() {\n-                        ex = ExprBreak(Some(Spanned {\n+                        ex = ExprKind::Break(Some(Spanned {\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                     } else {\n-                        ex = ExprBreak(None);\n+                        ex = ExprKind::Break(None);\n                     }\n                     hi = self.last_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n@@ -2302,18 +2296,18 @@ impl<'a> Parser<'a> {\n \n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n-                            ex = ExprStruct(pth, fields, base);\n+                            ex = ExprKind::Struct(pth, fields, base);\n                             return Ok(self.mk_expr(lo, hi, ex, attrs));\n                         }\n                     }\n \n                     hi = pth.span.hi;\n-                    ex = ExprPath(None, pth);\n+                    ex = ExprKind::Path(None, pth);\n                 } else {\n                     // other literal expression\n                     let lit = try!(self.parse_lit());\n                     hi = lit.span.hi;\n-                    ex = ExprLit(P(lit));\n+                    ex = ExprKind::Lit(P(lit));\n                 }\n             }\n         }\n@@ -2343,7 +2337,7 @@ impl<'a> Parser<'a> {\n         let attrs = outer_attrs.append(inner_attrs);\n \n         let blk = try!(self.parse_block_tail(lo, blk_mode));\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), attrs));\n+        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n@@ -2370,7 +2364,7 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 expr.attrs.update(|a| a.prepend(attrs));\n                 match expr.node {\n-                    ExprIf(..) | ExprIfLet(..) => {\n+                    ExprKind::If(..) | ExprKind::IfLet(..) => {\n                         if !expr.attrs.as_attr_slice().is_empty() {\n                             // Just point to the first attribute in there...\n                             let span = expr.attrs.as_attr_slice()[0].span;\n@@ -2763,7 +2757,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                ExprAddrOf(m, e)\n+                ExprKind::AddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2774,16 +2768,16 @@ impl<'a> Parser<'a> {\n                 let blk = try!(self.parse_block());\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk),\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprKind::Block(blk),\n                                             None);\n-                ExprInPlace(place, blk_expr)\n+                ExprKind::InPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                ExprBox(e)\n+                ExprKind::Box(e)\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n@@ -2850,12 +2844,12 @@ impl<'a> Parser<'a> {\n             if op == AssocOp::As {\n                 let rhs = try!(self.parse_ty());\n                 lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprCast(lhs, rhs), None);\n+                                   ExprKind::Cast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = try!(self.parse_ty());\n                 lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprType(lhs, rhs), None);\n+                                   ExprKind::Type(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n@@ -2921,9 +2915,9 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::Assign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::InPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -2957,7 +2951,7 @@ impl<'a> Parser<'a> {\n     fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n         debug_assert!(outer_op.is_comparison());\n         match lhs.node {\n-            ExprBinary(op, _, _) if op.node.is_comparison() => {\n+            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n@@ -3024,7 +3018,7 @@ impl<'a> Parser<'a> {\n             hi = elexpr.span.hi;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo, hi, ExprKind::If(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n@@ -3042,7 +3036,7 @@ impl<'a> Parser<'a> {\n         } else {\n             (thn.span.hi, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo, hi, ExprKind::IfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `|args| expr`\n@@ -3075,7 +3069,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(\n             lo,\n             body.span.hi,\n-            ExprClosure(capture_clause, decl, body), attrs))\n+            ExprKind::Closure(capture_clause, decl, body), attrs))\n     }\n \n     // `else` token already eaten\n@@ -3084,7 +3078,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_expr(None);\n         } else {\n             let blk = try!(self.parse_block());\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), None));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), None));\n         }\n     }\n \n@@ -3103,7 +3097,7 @@ impl<'a> Parser<'a> {\n         let hi = self.last_span.hi;\n \n         Ok(self.mk_expr(span_lo, hi,\n-                        ExprForLoop(pat, expr, loop_block, opt_ident),\n+                        ExprKind::ForLoop(pat, expr, loop_block, opt_ident),\n                         attrs))\n     }\n \n@@ -3118,7 +3112,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident),\n+        return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n                                attrs));\n     }\n \n@@ -3133,7 +3127,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n@@ -3143,7 +3137,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n+        Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n@@ -3167,7 +3161,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.span.hi;\n         self.bump();\n-        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n+        return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n@@ -3407,7 +3401,7 @@ impl<'a> Parser<'a> {\n                 (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(qself, path), None))\n+            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3509,7 +3503,7 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path), None);\n+                        let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n                         self.bump();\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);"}, {"sha": "736af70091a53933b84d263dbb4477d2f5793829", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -441,10 +441,10 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n \n fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::ExprAssign(..) | ast::ExprBinary(..) |\n-        ast::ExprClosure(..) |\n-        ast::ExprAssignOp(..) | ast::ExprCast(..) |\n-        ast::ExprInPlace(..) | ast::ExprType(..) => true,\n+        ast::ExprKind::Assign(..) | ast::ExprKind::Binary(..) |\n+        ast::ExprKind::Closure(..) |\n+        ast::ExprKind::AssignOp(..) | ast::ExprKind::Cast(..) |\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::Type(..) => true,\n         _ => false,\n     }\n }\n@@ -1713,7 +1713,7 @@ impl<'a> State<'a> {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    ast::ExprIf(ref i, ref then, ref e) => {\n+                    ast::ExprKind::If(ref i, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n@@ -1723,7 +1723,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n-                    ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n+                    ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n@@ -1736,7 +1736,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    ast::ExprBlock(ref b) => {\n+                    ast::ExprKind::Block(ref b) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n@@ -1803,7 +1803,7 @@ impl<'a> State<'a> {\n     pub fn check_expr_bin_needs_paren(&mut self, sub_expr: &ast::Expr,\n                                       binop: ast::BinOp) -> bool {\n         match sub_expr.node {\n-            ast::ExprBinary(ref sub_op, _, _) => {\n+            ast::ExprKind::Binary(ref sub_op, _, _) => {\n                 if AssocOp::from_ast_binop(sub_op.node).precedence() <\n                     AssocOp::from_ast_binop(binop.node).precedence() {\n                     true\n@@ -1985,45 +1985,45 @@ impl<'a> State<'a> {\n         try!(self.ibox(INDENT_UNIT));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprBox(ref expr) => {\n+            ast::ExprKind::Box(ref expr) => {\n                 try!(self.word_space(\"box\"));\n                 try!(self.print_expr(expr));\n             }\n-            ast::ExprInPlace(ref place, ref expr) => {\n+            ast::ExprKind::InPlace(ref place, ref expr) => {\n                 try!(self.print_expr_in_place(place, expr));\n             }\n-            ast::ExprVec(ref exprs) => {\n+            ast::ExprKind::Vec(ref exprs) => {\n                 try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n-            ast::ExprRepeat(ref element, ref count) => {\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n                 try!(self.print_expr_repeat(&**element, &**count, attrs));\n             }\n-            ast::ExprStruct(ref path, ref fields, ref wth) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n             }\n-            ast::ExprTup(ref exprs) => {\n+            ast::ExprKind::Tup(ref exprs) => {\n                 try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n-            ast::ExprCall(ref func, ref args) => {\n+            ast::ExprKind::Call(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n             }\n-            ast::ExprMethodCall(ident, ref tys, ref args) => {\n+            ast::ExprKind::MethodCall(ident, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n             }\n-            ast::ExprBinary(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr_binary(op, &**lhs, &**rhs));\n             }\n-            ast::ExprUnary(op, ref expr) => {\n+            ast::ExprKind::Unary(op, ref expr) => {\n                 try!(self.print_expr_unary(op, &**expr));\n             }\n-            ast::ExprAddrOf(m, ref expr) => {\n+            ast::ExprKind::AddrOf(m, ref expr) => {\n                 try!(self.print_expr_addr_of(m, &**expr));\n             }\n-            ast::ExprLit(ref lit) => {\n+            ast::ExprKind::Lit(ref lit) => {\n                 try!(self.print_literal(&**lit));\n             }\n-            ast::ExprCast(ref expr, ref ty) => {\n-                if let ast::ExprCast(..) = expr.node {\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n+                if let ast::ExprKind::Cast(..) = expr.node {\n                     try!(self.print_expr(&**expr));\n                 } else {\n                     try!(self.print_expr_maybe_paren(&**expr));\n@@ -2032,18 +2032,18 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"as\"));\n                 try!(self.print_type(&**ty));\n             }\n-            ast::ExprType(ref expr, ref ty) => {\n+            ast::ExprKind::Type(ref expr, ref ty) => {\n                 try!(self.print_expr(&**expr));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n             }\n-            ast::ExprIf(ref test, ref blk, ref elseopt) => {\n+            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n             }\n-            ast::ExprIfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n+            ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n                 try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n             }\n-            ast::ExprWhile(ref test, ref blk, opt_ident) => {\n+            ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2053,7 +2053,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n+            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2066,7 +2066,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2079,7 +2079,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprLoop(ref blk, opt_ident) => {\n+            ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2088,7 +2088,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprMatch(ref expr, ref arms) => {\n+            ast::ExprKind::Match(ref expr, ref arms) => {\n                 try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n@@ -2101,7 +2101,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, INDENT_UNIT));\n             }\n-            ast::ExprClosure(capture_clause, ref decl, ref body) => {\n+            ast::ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n                 try!(self.print_fn_block_args(&**decl));\n@@ -2118,7 +2118,7 @@ impl<'a> State<'a> {\n                     // we extract the block, so as not to create another set of boxes\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n-                        ast::ExprBlock(ref blk) => {\n+                        ast::ExprKind::Block(ref blk) => {\n                             try!(self.print_block_unclosed_with_attrs(\n                                 &**blk,\n                                 i_expr.attrs.as_attr_slice()));\n@@ -2135,43 +2135,43 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprKind::Block(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprAssign(ref lhs, ref rhs) => {\n+            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, op.node.to_string()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprField(ref expr, id) => {\n+            ast::ExprKind::Field(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id.node));\n             }\n-            ast::ExprTupField(ref expr, id) => {\n+            ast::ExprKind::TupField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n-            ast::ExprIndex(ref expr, ref index) => {\n+            ast::ExprKind::Index(ref expr, ref index) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprRange(ref start, ref end) => {\n+            ast::ExprKind::Range(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&**e));\n                 }\n@@ -2180,29 +2180,29 @@ impl<'a> State<'a> {\n                     try!(self.print_expr(&**e));\n                 }\n             }\n-            ast::ExprPath(None, ref path) => {\n+            ast::ExprKind::Path(None, ref path) => {\n                 try!(self.print_path(path, true, 0))\n             }\n-            ast::ExprPath(Some(ref qself), ref path) => {\n+            ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, true))\n             }\n-            ast::ExprBreak(opt_ident) => {\n+            ast::ExprKind::Break(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s));\n                 }\n             }\n-            ast::ExprAgain(opt_ident) => {\n+            ast::ExprKind::Again(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s))\n                 }\n             }\n-            ast::ExprRet(ref result) => {\n+            ast::ExprKind::Ret(ref result) => {\n                 try!(word(&mut self.s, \"return\"));\n                 match *result {\n                     Some(ref expr) => {\n@@ -2212,7 +2212,7 @@ impl<'a> State<'a> {\n                     _ => ()\n                 }\n             }\n-            ast::ExprInlineAsm(ref a) => {\n+            ast::ExprKind::InlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n@@ -2275,8 +2275,8 @@ impl<'a> State<'a> {\n \n                 try!(self.pclose());\n             }\n-            ast::ExprMac(ref m) => try!(self.print_mac(m, token::Paren)),\n-            ast::ExprParen(ref e) => {\n+            ast::ExprKind::Mac(ref m) => try!(self.print_mac(m, token::Paren)),\n+            ast::ExprKind::Paren(ref e) => {\n                 try!(self.popen());\n                 try!(self.print_inner_attributes_inline(attrs));\n                 try!(self.print_expr(&**e));\n@@ -2605,7 +2605,7 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprKind::Block(ref blk) => {\n                 // the block will close the pattern's ibox\n                 try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n "}, {"sha": "6190cf734643597241f33724b8d7e7197cd6a85b", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -17,7 +17,7 @@\n //!\n //! * **Identity**: sharing AST nodes is problematic for the various analysis\n //!   passes (e.g. one may be able to bypass the borrow checker with a shared\n-//!   `ExprAddrOf` node taking a mutable borrow). The only reason `@T` in the\n+//!   `ExprKind::AddrOf` node taking a mutable borrow). The only reason `@T` in the\n //!   AST hasn't caused issues is because of inefficient folding passes which\n //!   would always deduplicate any such shared nodes. Even if the AST were to\n //!   switch to an arena, this would still hold, i.e. it couldn't use `&'a T`,"}, {"sha": "dbdc1bfcbaa1108f57028ccb3419d513e5df044f", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -613,10 +613,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n \n     P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprAddrOf(ast::MutImmutable,\n+        node: ast::ExprKind::AddrOf(ast::MutImmutable,\n             P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprVec(cx.testfns.iter().map(|test| {\n+                node: ast::ExprKind::Vec(cx.testfns.iter().map(|test| {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,"}, {"sha": "90cc403961e36771e7a34e3553d662a1e178c562", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -651,138 +651,138 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n-        ExprBox(ref subexpression) => {\n+        ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprInPlace(ref place, ref subexpression) => {\n+        ExprKind::InPlace(ref place, ref subexpression) => {\n             visitor.visit_expr(place);\n             visitor.visit_expr(subexpression)\n         }\n-        ExprVec(ref subexpressions) => {\n+        ExprKind::Vec(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_expr(count)\n         }\n-        ExprStruct(ref path, ref fields, ref optional_base) => {\n+        ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n                 visitor.visit_ident(field.ident.span, field.ident.node);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n-        ExprTup(ref subexpressions) => {\n+        ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprCall(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(ref callee_expression, ref arguments) => {\n             walk_list!(visitor, visit_expr, arguments);\n             visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(ref ident, ref types, ref arguments) => {\n+        ExprKind::MethodCall(ref ident, ref types, ref arguments) => {\n             visitor.visit_ident(ident.span, ident.node);\n             walk_list!(visitor, visit_expr, arguments);\n             walk_list!(visitor, visit_ty, types);\n         }\n-        ExprBinary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprLit(_) => {}\n-        ExprCast(ref subexpression, ref typ) | ExprType(ref subexpression, ref typ) => {\n+        ExprKind::Lit(_) => {}\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+        ExprKind::While(ref subexpression, ref block, opt_ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+        ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprLoop(ref block, opt_ident) => {\n+        ExprKind::Loop(ref block, opt_ident) => {\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprMatch(ref subexpression, ref arms) => {\n+        ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, ref body) => {\n+        ExprKind::Closure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FnKind::Closure,\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(block),\n-        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+        ExprKind::Block(ref block) => visitor.visit_block(block),\n+        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression);\n             visitor.visit_expr(left_hand_expression)\n         }\n-        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);\n             visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, ref ident) => {\n+        ExprKind::Field(ref subexpression, ref ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident.span, ident.node);\n         }\n-        ExprTupField(ref subexpression, _) => {\n+        ExprKind::TupField(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprIndex(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprRange(ref start, ref end) => {\n+        ExprKind::Range(ref start, ref end) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n-        ExprPath(ref maybe_qself, ref path) => {\n+        ExprKind::Path(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n             for sp_ident in opt_sp_ident {\n                 visitor.visit_ident(sp_ident.span, sp_ident.node);\n             }\n         }\n-        ExprRet(ref optional_expression) => {\n+        ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprMac(ref mac) => visitor.visit_mac(mac),\n-        ExprParen(ref subexpression) => {\n+        ExprKind::Mac(ref mac) => visitor.visit_mac(mac),\n+        ExprKind::Paren(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprInlineAsm(ref ia) => {\n+        ExprKind::InlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(&input)\n             }"}, {"sha": "b9ba1f107ad7aefa8867eb59e13d0d8a1111831f", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -247,7 +247,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprInlineAsm(ast::InlineAsm {\n+        node: ast::ExprKind::InlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(&asm),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,"}, {"sha": "f5c2805c4ca48da6b702b724701d750ce8852da4", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -27,7 +27,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     let mut accumulator = String::new();\n     for e in es {\n         match e.node {\n-            ast::ExprLit(ref lit) => {\n+            ast::ExprKind::Lit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |"}, {"sha": "85453f6dfcbc8baceb1fecbc32530465e909c61a", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -54,7 +54,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(None,\n+        node: ast::ExprKind::Path(None,\n             ast::Path {\n                  span: sp,\n                  global: false,"}, {"sha": "14631659b0b90a0a797fc2b5d96fec1443bd0edf", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -91,7 +91,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, ExprRet, MutMutable};\n+use syntax::ast::{MetaItem, Expr, ExprKind, MutMutable};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt,Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -208,16 +208,15 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let call = if i != last {\n                     cx.expr_try(span, call)\n                 } else {\n-                    cx.expr(span, ExprRet(Some(call)))\n+                    cx.expr(span, ExprKind::Ret(Some(call)))\n                 };\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             // unit structs have no fields and need to return Ok()\n             if stmts.is_empty() {\n-                let ret_ok = cx.expr(trait_span,\n-                                     ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_tuple(trait_span, vec![])))));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n \n@@ -254,14 +253,13 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n                     } else {\n-                        cx.expr(span, ExprRet(Some(call)))\n+                        cx.expr(span, ExprKind::Ret(Some(call)))\n                     };\n                     stmts.push(cx.stmt_expr(call));\n                 }\n             } else {\n-                let ret_ok = cx.expr(trait_span,\n-                                     ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_tuple(trait_span, vec![])))));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n "}, {"sha": "82002b0be29e623f6c21b08e08d66c52638bd73a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -1311,7 +1311,7 @@ impl<'a> MethodDef<'a> {\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n             //Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1389,7 +1389,7 @@ impl<'a> MethodDef<'a> {\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n         }\n     }\n@@ -1509,8 +1509,8 @@ impl<'a> TraitDef<'a> {\n             };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n-            let val = cx.expr(\n-                sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n+            let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)));\n+            let val = cx.expr(sp, ast::ExprKind::Paren(val));\n             ident_expr.push((sp, opt_id, val, &struct_field.node.attrs[..]));\n         }\n "}, {"sha": "986cdef49b2e3b16ffde3e051749c7c0df376beb", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bf9ae18a133571d694aa866b824dcaea875d32/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=80bf9ae18a133571d694aa866b824dcaea875d32", "patch": "@@ -559,7 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n         let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n-        let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n+        let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n         let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n \n         let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);"}]}