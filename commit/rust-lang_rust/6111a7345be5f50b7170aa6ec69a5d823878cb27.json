{"sha": "6111a7345be5f50b7170aa6ec69a5d823878cb27", "node_id": "C_kwDOAAsO6NoAKDYxMTFhNzM0NWJlNWY1MGI3MTcwYWE2ZWM2OWE1ZDgyMzg3OGNiMjc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-09T06:25:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-09T06:25:46Z"}, "message": "Rollup merge of #105443 - compiler-errors:move-more, r=oli-obk\n\nMove some queries and methods\n\nEach commit's title should be self-explanatory. Motivated to break up some large, general files and move queries into leaf crates.", "tree": {"sha": "155cefaad96398339da988a252b67b2b30283ee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155cefaad96398339da988a252b67b2b30283ee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6111a7345be5f50b7170aa6ec69a5d823878cb27", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjktTqCRBK7hj4Ov3rIwAApRYIAJf9jj/twzv77e/V4gGYVZ1L\noZ1Et1Qy4rCW9pQJBrcd8Lud0Jq648oT+iHZDeaq/71jXqaKAW7OY+aImtEybcKx\noJyjWruJcxGPnR1J+sEyN56BzNju9ZYCH8c5uqJbFnwVvouqu1rNOTHhRfNDz2TM\n5xuc/YdFPrxhuVVFY7sMunWZFA/oDXym+hATUsT8a8O2b7j7jImoHwvlNwJTgozA\nR9akzo0c5OoX0VLCkoak38mKZ2ypPgSRGiBGA+Ok9rfQIxnnJ8+dPzsawPOwhsLz\nOOWB3JzPytHBwjn2tT+oZf/ChhEDk9/VrWZa5FaU20eAW+iji4qyEGp2h/f/sMU=\n=BNF0\n-----END PGP SIGNATURE-----\n", "payload": "tree 155cefaad96398339da988a252b67b2b30283ee1\nparent 441669c382298661db59cdf4374dbd40ab75b222\nparent 3b9daac6a27159bbe08e39fbc2722f40e91941d7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670567146 +0100\ncommitter GitHub <noreply@github.com> 1670567146 +0100\n\nRollup merge of #105443 - compiler-errors:move-more, r=oli-obk\n\nMove some queries and methods\n\nEach commit's title should be self-explanatory. Motivated to break up some large, general files and move queries into leaf crates.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6111a7345be5f50b7170aa6ec69a5d823878cb27", "html_url": "https://github.com/rust-lang/rust/commit/6111a7345be5f50b7170aa6ec69a5d823878cb27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6111a7345be5f50b7170aa6ec69a5d823878cb27/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441669c382298661db59cdf4374dbd40ab75b222", "url": "https://api.github.com/repos/rust-lang/rust/commits/441669c382298661db59cdf4374dbd40ab75b222", "html_url": "https://github.com/rust-lang/rust/commit/441669c382298661db59cdf4374dbd40ab75b222"}, {"sha": "3b9daac6a27159bbe08e39fbc2722f40e91941d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b9daac6a27159bbe08e39fbc2722f40e91941d7", "html_url": "https://github.com/rust-lang/rust/commit/3b9daac6a27159bbe08e39fbc2722f40e91941d7"}], "stats": {"total": 2851, "additions": 1756, "deletions": 1095}, "files": [{"sha": "987559d7e47243ead6b12e2762ae7716b0d41010", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 660, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -56,22 +56,17 @@ use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n-use crate::errors::SuggAddLetForLetChains;\n-use hir::intravisit::{walk_expr, walk_stmt};\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n@@ -84,6 +79,7 @@ use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod suggest;\n \n pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n@@ -807,87 +803,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn suggest_remove_semi_or_return_binding(\n-        &self,\n-        err: &mut Diagnostic,\n-        first_id: Option<hir::HirId>,\n-        first_ty: Ty<'tcx>,\n-        first_span: Span,\n-        second_id: Option<hir::HirId>,\n-        second_ty: Ty<'tcx>,\n-        second_span: Span,\n-    ) {\n-        let remove_semicolon = [\n-            (first_id, self.resolve_vars_if_possible(second_ty)),\n-            (second_id, self.resolve_vars_if_possible(first_ty)),\n-        ]\n-        .into_iter()\n-        .find_map(|(id, ty)| {\n-            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n-            self.could_remove_semicolon(blk, ty)\n-        });\n-        match remove_semicolon {\n-            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            None => {\n-                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n-                    if let Some(id) = id\n-                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n-                    {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn suggest_boxing_for_return_impl_trait(\n-        &self,\n-        err: &mut Diagnostic,\n-        return_sp: Span,\n-        arm_spans: impl Iterator<Item = Span>,\n-    ) {\n-        err.multipart_suggestion(\n-            \"you could change the return type to be a boxed trait object\",\n-            vec![\n-                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                (return_sp.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-        let sugg = arm_spans\n-            .flat_map(|sp| {\n-                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n-                    .into_iter()\n-            })\n-            .collect::<Vec<_>>();\n-        err.multipart_suggestion(\n-            \"if you change the return type to expect trait objects, box the returned expressions\",\n-            sugg,\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`.\n@@ -1944,310 +1859,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    fn suggest_tuple_pattern(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n-        // some modifications due to that being in typeck and this being in infer.\n-        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n-            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n-                let compatible_variants: Vec<_> = expected_adt\n-                    .variants()\n-                    .iter()\n-                    .filter(|variant| {\n-                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n-                    })\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n-                            let variant_path =\n-                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n-                            // FIXME #56861: DRYer prelude filtering\n-                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n-                                if let Some((_, path)) = path.split_once(\"::\") {\n-                                    return Some(path.to_string());\n-                                }\n-                            }\n-                            Some(variant_path)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                match &compatible_variants[..] {\n-                    [] => {}\n-                    [variant] => {\n-                        diag.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the pattern in `{}`\", variant),\n-                            vec![\n-                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                (cause.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {\n-                        // More than one matching variant.\n-                        diag.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the pattern in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did())\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```compile_fail,E0308\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    fn suggest_await_on_expect_found(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found,\n-        );\n-\n-        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n-            return;\n-        }\n-\n-        match (\n-            self.get_impl_future_output_ty(exp_found.expected),\n-            self.get_impl_future_output_ty(exp_found.found),\n-        ) {\n-            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n-                .code()\n-            {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    prior_arms,\n-                    ..\n-                }) => {\n-                    if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n-                    }\n-                }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n-            },\n-            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                diag.span_suggestion_verbose(\n-                    exp_span.shrink_to_hi(),\n-                    \"consider `await`ing on the `Future`\",\n-                    \".await\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n-            {\n-                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    ref prior_arms,\n-                    ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_accessing_field_where_appropriate(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n-            cause, exp_found\n-        );\n-        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n-            if expected_def.is_enum() {\n-                return;\n-            }\n-\n-            if let Some((name, ty)) = expected_def\n-                .non_enum_variant()\n-                .fields\n-                .iter()\n-                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n-                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n-            {\n-                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestion = if expected_def.is_struct() {\n-                            format!(\"{}.{}\", snippet, name)\n-                        } else if expected_def.is_union() {\n-                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n-                        } else {\n-                            return;\n-                        };\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"you might have meant to use field `{}` whose type is `{}`\",\n-                                name, ty\n-                            ),\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggests it.\n-    fn suggest_as_ref_where_appropriate(\n-        &self,\n-        span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n-        {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-\n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n-        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (expected.kind(), found.kind())\n-        {\n-            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n-                if exp_def == &found_def {\n-                    let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n-                    ];\n-                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n-                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n-                    }) {\n-                        let mut show_suggestion = true;\n-                        for (exp_ty, found_ty) in\n-                            iter::zip(exp_substs.types(), found_substs.types())\n-                        {\n-                            match *exp_ty.kind() {\n-                                ty::Ref(_, exp_ty, _) => {\n-                                    match (exp_ty.kind(), found_ty.kind()) {\n-                                        (_, ty::Param(_))\n-                                        | (_, ty::Infer(_))\n-                                        | (ty::Param(_), _)\n-                                        | (ty::Infer(_), _) => {}\n-                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n-                                        _ => show_suggestion = false,\n-                                    };\n-                                }\n-                                ty::Param(_) | ty::Infer(_) => {}\n-                                _ => show_suggestion = false,\n-                            }\n-                        }\n-                        if show_suggestion {\n-                            return Some(*msg);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn report_and_explain_type_error(\n         &self,\n         trace: TypeTrace<'tcx>,\n@@ -2361,67 +1972,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag\n     }\n \n-    /// Try to find code with pattern `if Some(..) = expr`\n-    /// use a `visitor` to mark the `if` which its span contains given error span,\n-    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n-    fn suggest_let_for_letchains(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'_>,\n-        span: Span,\n-    ) {\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.get_parent_node(cause.body_id);\n-        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n-            let hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n-                }) = node {\n-        let body = hir.body(*body_id);\n-\n-        /// Find the if expression with given span\n-        struct IfVisitor {\n-            pub result: bool,\n-            pub found_if: bool,\n-            pub err_span: Span,\n-        }\n-\n-        impl<'v> Visitor<'v> for IfVisitor {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                if self.result { return; }\n-                match ex.kind {\n-                    hir::ExprKind::If(cond, _, _) => {\n-                        self.found_if = true;\n-                        walk_expr(self, cond);\n-                        self.found_if = false;\n-                    }\n-                    _ => walk_expr(self, ex),\n-                }\n-            }\n-\n-            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n-                if let hir::StmtKind::Local(hir::Local {\n-                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n-                    }) = &ex.kind\n-                    && self.found_if\n-                    && span.eq(&self.err_span) {\n-                        self.result = true;\n-                }\n-                walk_stmt(self, ex);\n-            }\n-\n-            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n-                hir::intravisit::walk_body(self, body);\n-            }\n-        }\n-\n-        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n-        visitor.visit_body(&body);\n-        if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n-            }\n-        }\n-    }\n-\n     fn emit_tuple_wrap_err(\n         &self,\n         err: &mut Diagnostic,\n@@ -3253,211 +2803,3 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n-    /// is enough to fix the error.\n-    pub fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return None;\n-        }\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            _ if last_expr_ty.references_error() => return None,\n-            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => return None,\n-        };\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n-    /// Suggest returning a local binding with a compatible type if the block\n-    /// has no return expression.\n-    pub fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return false;\n-        }\n-        let mut shadowed = FxIndexSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self\n-                    .typeck_results\n-                    .as_ref()\n-                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.same_type_modulo_infer(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-}"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -0,0 +1,427 @@\n+use crate::errors::RegionOriginNote;\n+use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n+use crate::infer::{self, SubregionOrigin};\n+use rustc_errors::{\n+    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{self, Region};\n+\n+use super::ObligationCauseAsDiagArg;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n+                span: trace.cause.span,\n+                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n+                expected_found: self.values_str(trace.values),\n+            }\n+            .add_to_diagnostic(err),\n+            infer::Reborrow(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reborrow,\n+                    name: &var_name.to_string(),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateObjectBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_data_borrowed,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reference_outlives_referent,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_relate_param_bound,\n+                    name: &self.ty_to_string(ty),\n+                    continues: opt_span.is_some(),\n+                }\n+                .add_to_diagnostic(err);\n+                if let Some(span) = opt_span {\n+                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n+                        .add_to_diagnostic(err);\n+                }\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CompareImplItemObligation { span, .. } => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n+                self.note_region_origin(err, &parent);\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_concrete_failure(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        match origin {\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                let mut err = self.report_and_explain_type_error(trace, terr);\n+                match (*sub, *sup) {\n+                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n+                    (ty::RePlaceholder(_), _) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"\",\n+                            sup,\n+                            \" doesn't meet the lifetime requirements\",\n+                            None,\n+                        );\n+                    }\n+                    (_, ty::RePlaceholder(_)) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"the required lifetime does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                    _ => {\n+                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"...does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0312,\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the reference is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...but the borrowed content is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0313,\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n+                    var_name\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \", var_name),\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0476,\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"object type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"source pointer is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0477,\n+                    \"the type `{}` does not fulfill the required lifetime\",\n+                    self.ty_to_string(ty)\n+                );\n+                match *sub {\n+                    ty::ReStatic => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must satisfy \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                    _ => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must outlive \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                }\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime parameter instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime parameter must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0490,\n+                    \"a value of type `{}` is borrowed for too long\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the borrow lasts for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0491,\n+                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the pointer is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the referenced data is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n+                .report_extra_impl_obligation(\n+                    span,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                    &format!(\"`{}: {}`\", sup, sub),\n+                ),\n+            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n+                let mut err = self.report_concrete_failure(*parent, sub, sup);\n+\n+                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n+                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n+                err.span_label(\n+                    trait_item_span,\n+                    format!(\"definition of `{}` from trait\", item_name),\n+                );\n+\n+                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n+                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n+\n+                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n+                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n+                let clauses: Vec<_> = trait_predicates\n+                    .predicates\n+                    .into_iter()\n+                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n+                    .map(|(pred, _)| format!(\"{}\", pred))\n+                    .collect();\n+\n+                if !clauses.is_empty() {\n+                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n+                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n+\n+                    let suggestion = format!(\n+                        \"{} {}\",\n+                        generics.add_where_or_trailing_comma(),\n+                        clauses.join(\", \"),\n+                    );\n+                    err.span_suggestion(\n+                        where_clause_span,\n+                        &format!(\n+                            \"try copying {} from the trait\",\n+                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n+                        ),\n+                        suggestion,\n+                        rustc_errors::Applicability::MaybeIncorrect,\n+                    );\n+                }\n+\n+                err\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_placeholder_failure(\n+        &self,\n+        placeholder_origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        // I can't think how to do better than this right now. -nikomatsakis\n+        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n+        match placeholder_origin {\n+            infer::Subtype(box ref trace)\n+                if matches!(\n+                    &trace.cause.code().peel_derives(),\n+                    ObligationCauseCode::BindingObligation(..)\n+                        | ObligationCauseCode::ExprBindingObligation(..)\n+                ) =>\n+            {\n+                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n+                    &trace.cause.code().peel_derives()\n+                {\n+                    let span = *span;\n+                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n+                    err.span_note(span, \"the lifetime requirement is introduced here\");\n+                    err\n+                } else {\n+                    unreachable!()\n+                }\n+            }\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsPlaceholderMismatch;\n+                return self.report_and_explain_type_error(trace, terr);\n+            }\n+            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n+        }\n+    }\n+}"}, {"sha": "73b5a2cc4ad233e6ba2c5a1b1750916e3dfc55b0", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -0,0 +1,672 @@\n+use hir::def::CtorKind;\n+use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir as hir;\n+use rustc_middle::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n+};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self as ty, Ty, TypeVisitable};\n+use rustc_span::{sym, BytePos, Span};\n+\n+use crate::errors::SuggAddLetForLetChains;\n+\n+use super::TypeErrCtxt;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let remove_semicolon = [\n+            (first_id, self.resolve_vars_if_possible(second_ty)),\n+            (second_id, self.resolve_vars_if_possible(first_ty)),\n+        ]\n+        .into_iter()\n+        .find_map(|(id, ty)| {\n+            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+            self.could_remove_semicolon(blk, ty)\n+        });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(super) fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut Diagnostic,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        err.multipart_suggestion(\n+            \"you could change the return type to be a boxed trait object\",\n+            vec![\n+                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                (return_sp.shrink_to_hi(), \">\".to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n+                    .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects, box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n+    pub(super) fn suggest_tuple_pattern(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n+        // some modifications due to that being in typeck and this being in infer.\n+        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n+            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n+                let compatible_variants: Vec<_> = expected_adt\n+                    .variants()\n+                    .iter()\n+                    .filter(|variant| {\n+                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n+                    })\n+                    .filter_map(|variant| {\n+                        let sole_field = &variant.fields[0];\n+                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                            let variant_path =\n+                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n+                            // FIXME #56861: DRYer prelude filtering\n+                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n+                                if let Some((_, path)) = path.split_once(\"::\") {\n+                                    return Some(path.to_string());\n+                                }\n+                            }\n+                            Some(variant_path)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect();\n+                match &compatible_variants[..] {\n+                    [] => {}\n+                    [variant] => {\n+                        diag.multipart_suggestion_verbose(\n+                            &format!(\"try wrapping the pattern in `{}`\", variant),\n+                            vec![\n+                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                (cause.span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {\n+                        // More than one matching variant.\n+                        diag.multipart_suggestions(\n+                            &format!(\n+                                \"try wrapping the pattern in a variant of `{}`\",\n+                                self.tcx.def_path_str(expected_adt.did())\n+                            ),\n+                            compatible_variants.into_iter().map(|variant| {\n+                                vec![\n+                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n+                                ]\n+                            }),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```compile_fail,E0308\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    pub(super) fn suggest_await_on_expect_found(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n+            exp_span, exp_found.expected, exp_found.found,\n+        );\n+\n+        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n+            return;\n+        }\n+\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n+                    }\n+                }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n+                diag.span_suggestion_verbose(\n+                    exp_span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    ref prior_arms,\n+                    ..\n+                }) => {\n+                    diag.multipart_suggestion_verbose(\n+                        \"consider `await`ing on the `Future`\",\n+                        prior_arms\n+                            .iter()\n+                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n+                            .collect(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    pub(super) fn suggest_accessing_field_where_appropriate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n+            cause, exp_found\n+        );\n+        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n+            if expected_def.is_enum() {\n+                return;\n+            }\n+\n+            if let Some((name, ty)) = expected_def\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n+                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n+            {\n+                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        let suggestion = if expected_def.is_struct() {\n+                            format!(\"{}.{}\", snippet, name)\n+                        } else if expected_def.is_union() {\n+                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                        } else {\n+                            return;\n+                        };\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"you might have meant to use field `{}` whose type is `{}`\",\n+                                name, ty\n+                            ),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n+    /// suggests it.\n+    pub(super) fn suggest_as_ref_where_appropriate(\n+        &self,\n+        span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+        {\n+            diag.span_suggestion(\n+                span,\n+                msg,\n+                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n+            (expected.kind(), found.kind())\n+        {\n+            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n+                if exp_def == &found_def {\n+                    let have_as_ref = &[\n+                        (\n+                            sym::Option,\n+                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+                        `.as_ref()`\",\n+                        ),\n+                        (\n+                            sym::Result,\n+                            \"you can convert from `&Result<T, E>` to \\\n+                        `Result<&T, &E>` using `.as_ref()`\",\n+                        ),\n+                    ];\n+                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n+                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n+                    }) {\n+                        let mut show_suggestion = true;\n+                        for (exp_ty, found_ty) in\n+                            std::iter::zip(exp_substs.types(), found_substs.types())\n+                        {\n+                            match *exp_ty.kind() {\n+                                ty::Ref(_, exp_ty, _) => {\n+                                    match (exp_ty.kind(), found_ty.kind()) {\n+                                        (_, ty::Param(_))\n+                                        | (_, ty::Infer(_))\n+                                        | (ty::Param(_), _)\n+                                        | (ty::Infer(_), _) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ => show_suggestion = false,\n+                                    };\n+                                }\n+                                ty::Param(_) | ty::Infer(_) => {}\n+                                _ => show_suggestion = false,\n+                            }\n+                        }\n+                        if show_suggestion {\n+                            return Some(*msg);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Try to find code with pattern `if Some(..) = expr`\n+    /// use a `visitor` to mark the `if` which its span contains given error span,\n+    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n+    pub(super) fn suggest_let_for_letchains(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'_>,\n+        span: Span,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let fn_hir_id = hir.get_parent_node(cause.body_id);\n+        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+            let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n+                }) = node {\n+        let body = hir.body(*body_id);\n+\n+        /// Find the if expression with given span\n+        struct IfVisitor {\n+            pub result: bool,\n+            pub found_if: bool,\n+            pub err_span: Span,\n+        }\n+\n+        impl<'v> Visitor<'v> for IfVisitor {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if self.result { return; }\n+                match ex.kind {\n+                    hir::ExprKind::If(cond, _, _) => {\n+                        self.found_if = true;\n+                        walk_expr(self, cond);\n+                        self.found_if = false;\n+                    }\n+                    _ => walk_expr(self, ex),\n+                }\n+            }\n+\n+            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                if let hir::StmtKind::Local(hir::Local {\n+                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n+                    }) = &ex.kind\n+                    && self.found_if\n+                    && span.eq(&self.err_span) {\n+                        self.result = true;\n+                }\n+                walk_stmt(self, ex);\n+            }\n+\n+            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+                hir::intravisit::walk_body(self, body);\n+            }\n+        }\n+\n+        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n+        visitor.visit_body(&body);\n+        if visitor.result {\n+                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if std::iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxIndexSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .typeck_results\n+                    .as_ref()\n+                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -0,0 +1,203 @@\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    fn note_error_origin(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n+        terr: TypeError<'tcx>,\n+    ) {\n+        match *cause.code() {\n+            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n+                let ty = self.resolve_vars_if_possible(root_ty);\n+                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n+                {\n+                    // don't show type `_`\n+                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+                        && let ty::Adt(def, substs) = ty.kind()\n+                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n+                    {\n+                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n+                    } else {\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n+                }\n+                }\n+                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n+                    && ty.is_box() && ty.boxed_ty() == found\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider dereferencing the boxed value\",\n+                        format!(\"*{}\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n+                err.span_label(span, \"expected due to this\");\n+            }\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n+                source,\n+                ref prior_arms,\n+                scrut_hir_id,\n+                opt_suggest_box_span,\n+                scrut_span,\n+                ..\n+            }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n+                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n+                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n+                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n+                            self.typeck_results.as_ref().and_then(|typeck_results| {\n+                                typeck_results.expr_ty_opt(arg_expr)\n+                            })\n+                        } else {\n+                            bug!(\"try desugaring w/out call expr as scrutinee\");\n+                        };\n+\n+                        match scrut_ty {\n+                            Some(ty) if expected == ty => {\n+                                let source_map = self.tcx.sess.source_map();\n+                                err.span_suggestion(\n+                                    source_map.end_point(cause.span),\n+                                    \"try removing this `?`\",\n+                                    \"\",\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n+                    let t = self.resolve_vars_if_possible(match exp_found {\n+                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n+                        _ => prior_arm_ty,\n+                    });\n+                    let source_map = self.tcx.sess.source_map();\n+                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n+                    if prior_arms.len() <= 4 {\n+                        for sp in prior_arms {\n+                            any_multiline_arm |= source_map.is_multiline(*sp);\n+                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n+                        }\n+                    } else if let Some(sp) = prior_arms.last() {\n+                        any_multiline_arm |= source_map.is_multiline(*sp);\n+                        err.span_label(\n+                            *sp,\n+                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n+                        );\n+                    }\n+                    let outer_error_span = if any_multiline_arm {\n+                        // Cover just `match` and the scrutinee expression, not\n+                        // the entire match body, to reduce diagram noise.\n+                        cause.span.shrink_to_lo().to(scrut_span)\n+                    } else {\n+                        cause.span\n+                    };\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(outer_error_span, msg);\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n+                }\n+            },\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n+                opt_suggest_box_span,\n+            }) => {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(else_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n+                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n+                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n+                if let Some(ret_sp) = opt_suggest_box_span {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        [then_span, else_span].into_iter(),\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::LetElse => {\n+                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n+                err.help(\"...or use `match` instead of `let...else`\");\n+            }\n+            _ => {\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n+                = cause.code().peel_derives()\n+                    && let TypeError::RegionsPlaceholderMismatch = terr\n+                {\n+                    err.span_note( * span,\n+                    \"the lifetime requirement is introduced here\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.innermost_block();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+}"}, {"sha": "ea4bf42c515b5fb5a7aa83413b4d3eca80236736", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 366, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -4,7 +4,6 @@\n \n pub mod auto_trait;\n mod chalk_fulfill;\n-pub mod codegen;\n mod coherence;\n pub mod const_evaluatable;\n mod engine;\n@@ -20,25 +19,21 @@ mod select;\n mod specialize;\n mod structural_match;\n mod util;\n+mod vtable;\n pub mod wf;\n \n-use crate::errors::DumpVTableEntries;\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{\n-    self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeSuperVisitable, VtblEntry,\n-};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_span::{sym, Span};\n-use smallvec::SmallVec;\n+use rustc_span::Span;\n \n use std::fmt::Debug;\n use std::ops::ControlFlow;\n@@ -567,369 +562,12 @@ fn is_impossible_method<'tcx>(\n     false\n }\n \n-#[derive(Clone, Debug)]\n-enum VtblSegment<'tcx> {\n-    MetadataDSA,\n-    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n-}\n-\n-/// Prepare the segments for a vtable\n-fn prepare_vtable_segments<'tcx, T>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n-) -> Option<T> {\n-    // The following constraints holds for the final arrangement.\n-    // 1. The whole virtual table of the first direct super trait is included as the\n-    //    the prefix. If this trait doesn't have any super traits, then this step\n-    //    consists of the dsa metadata.\n-    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n-    //    other super traits except those already included as part of the first\n-    //    direct super trait virtual table.\n-    // 3. finally, the own methods of this trait.\n-\n-    // This has the advantage that trait upcasting to the first direct super trait on each level\n-    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n-    // while not using too much extra memory.\n-\n-    // For a single inheritance relationship like this,\n-    //   D --> C --> B --> A\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, D\n-\n-    // For a multiple inheritance relationship like this,\n-    //   D --> C --> A\n-    //           \\-> B\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D\n-\n-    // For a diamond inheritance relationship like this,\n-    //   D --> B --> A\n-    //     \\-> C -/\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, C-vptr, D\n-\n-    // For a more complex inheritance relationship like this:\n-    //   O --> G --> C --> A\n-    //     \\     \\     \\-> B\n-    //     |     |-> F --> D\n-    //     |           \\-> E\n-    //     |-> N --> J --> H\n-    //           \\     \\-> I\n-    //           |-> M --> K\n-    //                 \\-> L\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n-    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n-    //  N, N-vptr, O\n-\n-    // emit dsa segment first.\n-    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n-        return Some(v);\n-    }\n-\n-    let mut emit_vptr_on_new_entry = false;\n-    let mut visited = util::PredicateSet::new(tcx);\n-    let predicate = trait_ref.without_const().to_predicate(tcx);\n-    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n-        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n-    visited.insert(predicate);\n-\n-    // the main traversal loop:\n-    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n-    // that each node is emitted after all its descendents have been emitted.\n-    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n-    // this is done on the fly.\n-    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n-    // stops after it finds a node that has a next-sibling node.\n-    // This next-sibling node will used as the starting point of next slice.\n-\n-    // Example:\n-    // For a diamond inheritance relationship like this,\n-    //   D#1 --> B#0 --> A#0\n-    //     \\-> C#1 -/\n-\n-    // Starting point 0 stack [D]\n-    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n-    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n-    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n-    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n-    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n-    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n-    // Loop run #1: Stack after exiting out is []. Now the function exits.\n-\n-    loop {\n-        // dive deeper into the stack, recording the path\n-        'diving_in: loop {\n-            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n-                let inner_most_trait_ref = *inner_most_trait_ref;\n-                let mut direct_super_traits_iter = tcx\n-                    .super_predicates_of(inner_most_trait_ref.def_id())\n-                    .predicates\n-                    .into_iter()\n-                    .filter_map(move |(pred, _)| {\n-                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n-                    });\n-\n-                'diving_in_skip_visited_traits: loop {\n-                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n-                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n-                            // We're throwing away potential constness of super traits here.\n-                            // FIXME: handle ~const super traits\n-                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n-                            stack.push((\n-                                next_super_trait,\n-                                emit_vptr_on_new_entry,\n-                                Some(direct_super_traits_iter),\n-                            ));\n-                            break 'diving_in_skip_visited_traits;\n-                        } else {\n-                            continue 'diving_in_skip_visited_traits;\n-                        }\n-                    } else {\n-                        break 'diving_in;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Other than the left-most path, vptr should be emitted for each trait.\n-        emit_vptr_on_new_entry = true;\n-\n-        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n-        'exiting_out: loop {\n-            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n-                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n-                    trait_ref: *inner_most_trait_ref,\n-                    emit_vptr: *emit_vptr,\n-                }) {\n-                    return Some(v);\n-                }\n-\n-                'exiting_out_skip_visited_traits: loop {\n-                    if let Some(siblings) = siblings_opt {\n-                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n-                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n-                                // We're throwing away potential constness of super traits here.\n-                                // FIXME: handle ~const super traits\n-                                let next_inner_most_trait_ref =\n-                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n-                                *inner_most_trait_ref = next_inner_most_trait_ref;\n-                                *emit_vptr = emit_vptr_on_new_entry;\n-                                break 'exiting_out;\n-                            } else {\n-                                continue 'exiting_out_skip_visited_traits;\n-                            }\n-                        }\n-                    }\n-                    stack.pop();\n-                    continue 'exiting_out;\n-                }\n-            }\n-            // all done\n-            return None;\n-        }\n-    }\n-}\n-\n-fn dump_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sp: Span,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    entries: &[VtblEntry<'tcx>],\n-) {\n-    tcx.sess.emit_err(DumpVTableEntries {\n-        span: sp,\n-        trait_ref,\n-        entries: format!(\"{:#?}\", entries),\n-    });\n-}\n-\n-fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n-    let trait_methods = tcx\n-        .associated_items(trait_def_id)\n-        .in_definition_order()\n-        .filter(|item| item.kind == ty::AssocKind::Fn);\n-    // Now list each method's DefId (for within its trait).\n-    let own_entries = trait_methods.filter_map(move |trait_method| {\n-        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n-        let def_id = trait_method.def_id;\n-\n-        // Some methods cannot be called on an object; skip those.\n-        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n-            debug!(\"own_existential_vtable_entry: not vtable safe\");\n-            return None;\n-        }\n-\n-        Some(def_id)\n-    });\n-\n-    tcx.arena.alloc_from_iter(own_entries.into_iter())\n-}\n-\n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-fn vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [VtblEntry<'tcx>] {\n-    debug!(\"vtable_entries({:?})\", trait_ref);\n-\n-    let mut entries = vec![];\n-\n-    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n-        match segment {\n-            VtblSegment::MetadataDSA => {\n-                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n-            }\n-            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                let existential_trait_ref = trait_ref\n-                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n-\n-                // Lookup the shape of vtable for the trait.\n-                let own_existential_entries =\n-                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n-\n-                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n-                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n-\n-                    // The method may have some early-bound lifetimes; add regions for those.\n-                    let substs = trait_ref.map_bound(|trait_ref| {\n-                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        })\n-                    });\n-\n-                    // The trait type may have higher-ranked lifetimes in it;\n-                    // erase them if they appear, so that we get the type\n-                    // at some particular call site.\n-                    let substs = tcx\n-                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-                    // It's possible that the method relies on where-clauses that\n-                    // do not hold for this particular set of type parameters.\n-                    // Note that this method could then never be called, so we\n-                    // do not want to try and codegen it, in that case (see #23435).\n-                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                    if impossible_predicates(tcx, predicates.predicates) {\n-                        debug!(\"vtable_entries: predicates do not hold\");\n-                        return VtblEntry::Vacant;\n-                    }\n-\n-                    let instance = ty::Instance::resolve_for_vtable(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        def_id,\n-                        substs,\n-                    )\n-                    .expect(\"resolution failed during building vtable representation\");\n-                    VtblEntry::Method(instance)\n-                });\n-\n-                entries.extend(own_entries);\n-\n-                if emit_vptr {\n-                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n-                }\n-            }\n-        }\n-\n-        ControlFlow::Continue(())\n-    };\n-\n-    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n-\n-    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n-        let sp = tcx.def_span(trait_ref.def_id());\n-        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n-    }\n-\n-    tcx.arena.alloc_from_iter(entries.into_iter())\n-}\n-\n-/// Find slot base for trait methods within vtable entries of another trait\n-fn vtable_trait_first_method_offset<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n-        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n-    ),\n-) -> usize {\n-    let (trait_to_be_found, trait_owning_vtable) = key;\n-\n-    // #90177\n-    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n-\n-    let vtable_segment_callback = {\n-        let mut vtable_base = 0;\n-\n-        move |segment| {\n-            match segment {\n-                VtblSegment::MetadataDSA => {\n-                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n-                }\n-                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n-                        return ControlFlow::Break(vtable_base);\n-                    }\n-                    vtable_base += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if emit_vptr {\n-                        vtable_base += 1;\n-                    }\n-                }\n-            }\n-            ControlFlow::Continue(())\n-        }\n-    };\n-\n-    if let Some(vtable_base) =\n-        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n-    {\n-        vtable_base\n-    } else {\n-        bug!(\"Failed to find info for expected trait in vtable\");\n-    }\n-}\n-\n-/// Find slot offset for trait vptr within vtable entries of another trait\n-pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        Ty<'tcx>, // trait object type whose trait owning vtable\n-        Ty<'tcx>, // trait object for supertrait\n-    ),\n-) -> Option<usize> {\n-    let (source, target) = key;\n-    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n-    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n-\n-    // this has been typecked-before, so diagnostics is not really needed.\n-    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n-\n-    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n-\n-    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n-        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n-            implsrc_traitcasting.vtable_vptr_slot\n-        }\n-        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     object_safety::provide(providers);\n-    structural_match::provide(providers);\n+    vtable::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n-        codegen_select_candidate: codegen::codegen_select_candidate,\n-        own_existential_vtable_entries,\n-        vtable_entries,\n-        vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         is_impossible_method,\n         ..*providers"}, {"sha": "fda415155c469b556c3206ad8223431625388eaa", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -19,14 +19,18 @@ use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::vtable::{\n+    count_own_vtable_entries, prepare_vtable_segments, vtable_trait_first_method_offset,\n+    VtblSegment,\n+};\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n     ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n     ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n     Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n-    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented,\n };\n \n use super::BuiltinImplConditions;\n@@ -583,7 +587,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?nested, \"object nested obligations\");\n \n-        let vtable_base = super::super::vtable_trait_first_method_offset(\n+        let vtable_base = vtable_trait_first_method_offset(\n             tcx,\n             (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),\n         );\n@@ -904,7 +908,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         vptr_offset += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                     }\n                     VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                        vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                        vptr_offset += count_own_vtable_entries(tcx, trait_ref);\n                         if trait_ref == upcast_trait_ref {\n                             if emit_vptr {\n                                 return ControlFlow::Break(Some(vptr_offset));\n@@ -923,8 +927,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let vtable_vptr_slot =\n-            super::super::prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback)\n-                .unwrap();\n+            prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback).unwrap();\n \n         Ok(ImplSourceTraitUpcastingData { upcast_trait_ref, vtable_vptr_slot, nested })\n     }"}, {"sha": "4dc08e0f9dab0da99be2c049b08e755c9f7c5b04", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -1,10 +1,5 @@\n-use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::{ObligationCause, ObligationCtxt};\n-\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::lang_items::LangItem;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::Span;\n use std::ops::ControlFlow;\n@@ -59,41 +54,6 @@ pub fn search_for_adt_const_param_violation<'tcx>(\n         .break_value()\n }\n \n-/// This method returns true if and only if `adt_ty` itself has been marked as\n-/// eligible for structural-match: namely, if it implements both\n-/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n-/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n-///\n-/// Note that this does *not* recursively check if the substructure of `adt_ty`\n-/// implements the traits.\n-fn type_marked_structural<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    adt_ty: Ty<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> bool {\n-    let ocx = ObligationCtxt::new(infcx);\n-    // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id =\n-        infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n-    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n-    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n-    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let structural_teq_def_id =\n-        infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n-    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n-\n-    // We deliberately skip *reporting* fulfillment errors (via\n-    // `report_fulfillment_errors`), for two reasons:\n-    //\n-    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n-    //    (a trait which is solely meant as an implementation detail\n-    //    for now), and\n-    //\n-    // 2. We are sometimes doing future-incompatibility lints for\n-    //    now, so we do not want unconditional errors here.\n-    ocx.select_all_or_error().is_empty()\n-}\n-\n /// This implements the traversal over the structure of a given type to try to\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n@@ -249,11 +209,3 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n         })\n     }\n }\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.has_structural_eq_impls = |tcx, ty| {\n-        let infcx = tcx.infer_ctxt().build();\n-        let cause = ObligationCause::dummy();\n-        type_marked_structural(&infcx, ty, cause)\n-    };\n-}"}, {"sha": "f3ca6a6c779a06b9ca34b584dde18fe5775f0516", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -261,16 +261,6 @@ pub fn upcast_choices<'tcx>(\n     supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n }\n \n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> usize {\n-    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n-}\n-\n /// Given an upcast trait object described by `object`, returns the\n /// index of the method `method_def_id` (which should be part of\n /// `object.upcast_trait_ref`) within the vtable for `object`."}, {"sha": "41ce6cdf789da381d32e3ec2f158faf63045afe9", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -0,0 +1,386 @@\n+use crate::errors::DumpVTableEntries;\n+use crate::traits::{impossible_predicates, is_vtable_safe_method};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_infer::traits::util::PredicateSet;\n+use rustc_infer::traits::ImplSource;\n+use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::InternalSubsts;\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n+use rustc_span::{sym, Span};\n+use smallvec::SmallVec;\n+\n+use std::fmt::Debug;\n+use std::ops::ControlFlow;\n+\n+#[derive(Clone, Debug)]\n+pub(super) enum VtblSegment<'tcx> {\n+    MetadataDSA,\n+    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n+}\n+\n+/// Prepare the segments for a vtable\n+pub(super) fn prepare_vtable_segments<'tcx, T>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n+) -> Option<T> {\n+    // The following constraints holds for the final arrangement.\n+    // 1. The whole virtual table of the first direct super trait is included as the\n+    //    the prefix. If this trait doesn't have any super traits, then this step\n+    //    consists of the dsa metadata.\n+    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n+    //    other super traits except those already included as part of the first\n+    //    direct super trait virtual table.\n+    // 3. finally, the own methods of this trait.\n+\n+    // This has the advantage that trait upcasting to the first direct super trait on each level\n+    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n+    // while not using too much extra memory.\n+\n+    // For a single inheritance relationship like this,\n+    //   D --> C --> B --> A\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, D\n+\n+    // For a multiple inheritance relationship like this,\n+    //   D --> C --> A\n+    //           \\-> B\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D\n+\n+    // For a diamond inheritance relationship like this,\n+    //   D --> B --> A\n+    //     \\-> C -/\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, C-vptr, D\n+\n+    // For a more complex inheritance relationship like this:\n+    //   O --> G --> C --> A\n+    //     \\     \\     \\-> B\n+    //     |     |-> F --> D\n+    //     |           \\-> E\n+    //     |-> N --> J --> H\n+    //           \\     \\-> I\n+    //           |-> M --> K\n+    //                 \\-> L\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n+    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n+    //  N, N-vptr, O\n+\n+    // emit dsa segment first.\n+    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n+        return Some(v);\n+    }\n+\n+    let mut emit_vptr_on_new_entry = false;\n+    let mut visited = PredicateSet::new(tcx);\n+    let predicate = trait_ref.without_const().to_predicate(tcx);\n+    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n+        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n+    visited.insert(predicate);\n+\n+    // the main traversal loop:\n+    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n+    // that each node is emitted after all its descendents have been emitted.\n+    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n+    // this is done on the fly.\n+    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n+    // stops after it finds a node that has a next-sibling node.\n+    // This next-sibling node will used as the starting point of next slice.\n+\n+    // Example:\n+    // For a diamond inheritance relationship like this,\n+    //   D#1 --> B#0 --> A#0\n+    //     \\-> C#1 -/\n+\n+    // Starting point 0 stack [D]\n+    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n+    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n+    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n+    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n+    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n+    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n+    // Loop run #1: Stack after exiting out is []. Now the function exits.\n+\n+    loop {\n+        // dive deeper into the stack, recording the path\n+        'diving_in: loop {\n+            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n+                let inner_most_trait_ref = *inner_most_trait_ref;\n+                let mut direct_super_traits_iter = tcx\n+                    .super_predicates_of(inner_most_trait_ref.def_id())\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(move |(pred, _)| {\n+                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n+                    });\n+\n+                'diving_in_skip_visited_traits: loop {\n+                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n+                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n+                            // We're throwing away potential constness of super traits here.\n+                            // FIXME: handle ~const super traits\n+                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n+                            stack.push((\n+                                next_super_trait,\n+                                emit_vptr_on_new_entry,\n+                                Some(direct_super_traits_iter),\n+                            ));\n+                            break 'diving_in_skip_visited_traits;\n+                        } else {\n+                            continue 'diving_in_skip_visited_traits;\n+                        }\n+                    } else {\n+                        break 'diving_in;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Other than the left-most path, vptr should be emitted for each trait.\n+        emit_vptr_on_new_entry = true;\n+\n+        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n+        'exiting_out: loop {\n+            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n+                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n+                    trait_ref: *inner_most_trait_ref,\n+                    emit_vptr: *emit_vptr,\n+                }) {\n+                    return Some(v);\n+                }\n+\n+                'exiting_out_skip_visited_traits: loop {\n+                    if let Some(siblings) = siblings_opt {\n+                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n+                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n+                                // We're throwing away potential constness of super traits here.\n+                                // FIXME: handle ~const super traits\n+                                let next_inner_most_trait_ref =\n+                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n+                                *inner_most_trait_ref = next_inner_most_trait_ref;\n+                                *emit_vptr = emit_vptr_on_new_entry;\n+                                break 'exiting_out;\n+                            } else {\n+                                continue 'exiting_out_skip_visited_traits;\n+                            }\n+                        }\n+                    }\n+                    stack.pop();\n+                    continue 'exiting_out;\n+                }\n+            }\n+            // all done\n+            return None;\n+        }\n+    }\n+}\n+\n+fn dump_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    entries: &[VtblEntry<'tcx>],\n+) {\n+    tcx.sess.emit_err(DumpVTableEntries {\n+        span: sp,\n+        trait_ref,\n+        entries: format!(\"{:#?}\", entries),\n+    });\n+}\n+\n+fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n+    let trait_methods = tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Fn);\n+    // Now list each method's DefId (for within its trait).\n+    let own_entries = trait_methods.filter_map(move |trait_method| {\n+        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n+        let def_id = trait_method.def_id;\n+\n+        // Some methods cannot be called on an object; skip those.\n+        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n+            debug!(\"own_existential_vtable_entry: not vtable safe\");\n+            return None;\n+        }\n+\n+        Some(def_id)\n+    });\n+\n+    tcx.arena.alloc_from_iter(own_entries.into_iter())\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+fn vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [VtblEntry<'tcx>] {\n+    debug!(\"vtable_entries({:?})\", trait_ref);\n+\n+    let mut entries = vec![];\n+\n+    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n+        match segment {\n+            VtblSegment::MetadataDSA => {\n+                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n+            }\n+            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                let existential_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+\n+                // Lookup the shape of vtable for the trait.\n+                let own_existential_entries =\n+                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n+\n+                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n+\n+                    // The method may have some early-bound lifetimes; add regions for those.\n+                    let substs = trait_ref.map_bound(|trait_ref| {\n+                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                            GenericParamDefKind::Type { .. }\n+                            | GenericParamDefKind::Const { .. } => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        })\n+                    });\n+\n+                    // The trait type may have higher-ranked lifetimes in it;\n+                    // erase them if they appear, so that we get the type\n+                    // at some particular call site.\n+                    let substs = tcx\n+                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                    // It's possible that the method relies on where-clauses that\n+                    // do not hold for this particular set of type parameters.\n+                    // Note that this method could then never be called, so we\n+                    // do not want to try and codegen it, in that case (see #23435).\n+                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                    if impossible_predicates(tcx, predicates.predicates) {\n+                        debug!(\"vtable_entries: predicates do not hold\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    let instance = ty::Instance::resolve_for_vtable(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .expect(\"resolution failed during building vtable representation\");\n+                    VtblEntry::Method(instance)\n+                });\n+\n+                entries.extend(own_entries);\n+\n+                if emit_vptr {\n+                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n+                }\n+            }\n+        }\n+\n+        ControlFlow::Continue(())\n+    };\n+\n+    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n+\n+    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n+        let sp = tcx.def_span(trait_ref.def_id());\n+        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n+    }\n+\n+    tcx.arena.alloc_from_iter(entries.into_iter())\n+}\n+\n+/// Find slot base for trait methods within vtable entries of another trait\n+pub(super) fn vtable_trait_first_method_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> usize {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    // #90177\n+    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n+\n+    let vtable_segment_callback = {\n+        let mut vtable_base = 0;\n+\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n+                        return ControlFlow::Break(vtable_base);\n+                    }\n+                    vtable_base += count_own_vtable_entries(tcx, trait_ref);\n+                    if emit_vptr {\n+                        vtable_base += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n+\n+    if let Some(vtable_base) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vtable_base\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n+}\n+\n+/// Find slot offset for trait vptr within vtable entries of another trait\n+pub(crate) fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        Ty<'tcx>, // trait object type whose trait owning vtable\n+        Ty<'tcx>, // trait object for supertrait\n+    ),\n+) -> Option<usize> {\n+    let (source, target) = key;\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n+\n+    // this has been typecked-before, so diagnostics is not really needed.\n+    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n+\n+    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n+\n+    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n+        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n+            implsrc_traitcasting.vtable_vptr_slot\n+        }\n+        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n+    }\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub(crate) fn count_own_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> usize {\n+    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n+}\n+\n+pub(super) fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers {\n+        own_existential_vtable_entries,\n+        vtable_entries,\n+        vtable_trait_upcasting_coercion_new_vptr_slot,\n+        ..*providers\n+    };\n+}"}, {"sha": "f8f74b732efd3c20c0653b9d742afe596202bbb7", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -3,15 +3,15 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n-use crate::traits::error_reporting::TypeErrCtxtExt;\n-use crate::traits::{\n-    ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n-    Unimplemented,\n-};\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::FulfillmentErrorCode;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::{\n+    ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n+    Unimplemented,\n+};\n \n /// Attempts to resolve an obligation to an `ImplSource`. The result is\n /// a shallow `ImplSource` resolution, meaning that we do not", "previous_filename": "compiler/rustc_trait_selection/src/traits/codegen.rs"}, {"sha": "9aa26667e7bf461ef3059ade70551ccff81ee75e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -12,6 +12,7 @@ extern crate tracing;\n extern crate rustc_middle;\n \n mod chalk;\n+mod codegen;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n@@ -31,4 +32,5 @@ pub fn provide(p: &mut Providers) {\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);\n+    p.codegen_select_candidate = codegen::codegen_select_candidate;\n }"}, {"sha": "7ad5cbc01ccf25293c116f05025bca179b33d0e3", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -29,6 +29,7 @@ mod layout;\n mod layout_sanity_check;\n mod needs_drop;\n pub mod representability;\n+mod structural_match;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {\n@@ -42,4 +43,5 @@ pub fn provide(providers: &mut Providers) {\n     representability::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);\n+    structural_match::provide(providers);\n }"}, {"sha": "a55bb7e7e904d224b8d1f70b492a695f90719509", "filename": "compiler/rustc_ty_utils/src/structural_match.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6111a7345be5f50b7170aa6ec69a5d823878cb27/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs?ref=6111a7345be5f50b7170aa6ec69a5d823878cb27", "patch": "@@ -0,0 +1,44 @@\n+use rustc_hir::lang_items::LangItem;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n+\n+/// This method returns true if and only if `adt_ty` itself has been marked as\n+/// eligible for structural-match: namely, if it implements both\n+/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n+/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n+///\n+/// Note that this does *not* recursively check if the substructure of `adt_ty`\n+/// implements the traits.\n+fn has_structural_eq_impls<'tcx>(tcx: TyCtxt<'tcx>, adt_ty: Ty<'tcx>) -> bool {\n+    let ref infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::dummy();\n+\n+    let ocx = ObligationCtxt::new(infcx);\n+    // require `#[derive(PartialEq)]`\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n+    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n+    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n+    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n+    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n+\n+    // We deliberately skip *reporting* fulfillment errors (via\n+    // `report_fulfillment_errors`), for two reasons:\n+    //\n+    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n+    //    (a trait which is solely meant as an implementation detail\n+    //    for now), and\n+    //\n+    // 2. We are sometimes doing future-incompatibility lints for\n+    //    now, so we do not want unconditional errors here.\n+    ocx.select_all_or_error().is_empty()\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.has_structural_eq_impls = has_structural_eq_impls;\n+}"}]}