{"sha": "9dd27b31bac5a001ab3fe638c8c95f14023bd61c", "node_id": "C_kwDOAAsO6NoAKDlkZDI3YjMxYmFjNWEwMDFhYjNmZTYzOGM4Yzk1ZjE0MDIzYmQ2MWM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-03-23T15:34:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-04-10T12:47:15Z"}, "message": "rustc_metadata: Cleanup `fn encode_info_for_item`", "tree": {"sha": "36ff149ed090f5f5265d82351f81c8d0806ae7bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ff149ed090f5f5265d82351f81c8d0806ae7bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dd27b31bac5a001ab3fe638c8c95f14023bd61c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd27b31bac5a001ab3fe638c8c95f14023bd61c", "html_url": "https://github.com/rust-lang/rust/commit/9dd27b31bac5a001ab3fe638c8c95f14023bd61c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dd27b31bac5a001ab3fe638c8c95f14023bd61c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e", "html_url": "https://github.com/rust-lang/rust/commit/d4be8efc6296bace5b1e165f1b34d3c6da76aa8e"}], "stats": {"total": 95, "additions": 33, "deletions": 62}, "files": [{"sha": "1b2c4b53de5ba6b78a7b16eb7eef79b3aa7dd467", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 33, "deletions": 62, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9dd27b31bac5a001ab3fe638c8c95f14023bd61c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd27b31bac5a001ab3fe638c8c95f14023bd61c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9dd27b31bac5a001ab3fe638c8c95f14023bd61c", "patch": "@@ -1523,23 +1523,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item<'tcx>) {\n+    fn encode_info_for_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-\n+        let def_id = item.owner_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        let record_associated_item_def_ids = |this: &mut Self, def_ids: &[DefId]| {\n+            record_array!(this.tables.children[def_id] <- def_ids.iter().map(|&def_id| {\n+                assert!(def_id.is_local());\n+                def_id.index\n+            }))\n+        };\n+\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.constness.set_some(def_id.index, sig.header.constness);\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+                self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.owner_id.def_id, m);\n+                self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1550,9 +1559,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n                 self.tables.constness.set_some(def_id.index, *constness);\n+                self.tables.impl_polarity.set_some(def_id.index, self.tcx.impl_polarity(def_id));\n+\n+                if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                    record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id);\n-                if let Some(trait_ref) = trait_ref {\n                     let trait_ref = trait_ref.skip_binder();\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n@@ -1570,71 +1581,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set_some(def_id.index, polarity);\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &trait_item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n+                }\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n+\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_trait_item(item_def_id);\n+                }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n-            }\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n-                bug!(\"cannot encode info for item {:?}\", item)\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n             }\n-            hir::ItemKind::Static(..)\n+            hir::ItemKind::ExternCrate(_)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n-        };\n-        // FIXME(eddyb) there should be a nicer way to do this.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n-                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record_array!(self.tables.children[def_id] <-\n-                    associated_item_def_ids.iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    })\n-                );\n-            }\n-            _ => {}\n-        }\n-        if let hir::ItemKind::Fn(..) = item.kind {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n-        }\n-        if let hir::ItemKind::Impl { .. } = item.kind {\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n-            }\n-        }\n-        // In some cases, along with the item itself, we also\n-        // encode some sub-items. Usually we want some info from the item\n-        // so it's easier to do that here then to wait until we would encounter\n-        // normally in the visitor walk.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_impl_item(trait_item_def_id);\n-                }\n-            }\n-            hir::ItemKind::Trait(..) => {\n-                for &item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_trait_item(item_def_id);\n-                }\n-            }\n-            _ => {}\n         }\n     }\n \n@@ -2020,10 +1994,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(item.owner_id.to_def_id(), item),\n-        }\n+        self.encode_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);"}]}