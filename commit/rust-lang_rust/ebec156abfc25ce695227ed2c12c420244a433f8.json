{"sha": "ebec156abfc25ce695227ed2c12c420244a433f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZWMxNTZhYmZjMjVjZTY5NTIyN2VkMmMxMmM0MjAyNDRhNDMzZjg=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-10T15:00:02Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T17:10:25Z"}, "message": "rustc_codegen_llvm: remove more unused functions.", "tree": {"sha": "fe84593e5fed854f5311786eec0e76c741270b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe84593e5fed854f5311786eec0e76c741270b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebec156abfc25ce695227ed2c12c420244a433f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebec156abfc25ce695227ed2c12c420244a433f8", "html_url": "https://github.com/rust-lang/rust/commit/ebec156abfc25ce695227ed2c12c420244a433f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebec156abfc25ce695227ed2c12c420244a433f8/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f224441ed5a6542c496e826088a99944d5963cbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f224441ed5a6542c496e826088a99944d5963cbf", "html_url": "https://github.com/rust-lang/rust/commit/f224441ed5a6542c496e826088a99944d5963cbf"}], "stats": {"total": 422, "additions": 21, "deletions": 401}, "files": [{"sha": "676523b09f77278819b8ac981eb27dcc4d4092dd", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 2, "deletions": 192, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=ebec156abfc25ce695227ed2c12c420244a433f8", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)] // FFI wrappers\n-\n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n+use llvm::{IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{self, BasicBlock};\n use common::*;\n use type_::Type;\n@@ -26,7 +24,6 @@ use std::ffi::CString;\n use std::ops::Range;\n use std::ptr;\n use std::ptr::NonNull;\n-use syntax_pos::Span;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -128,12 +125,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn position_before(&self, insn: &'ll Value) {\n-        unsafe {\n-            llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);\n-        }\n-    }\n-\n     pub fn position_at_end(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n@@ -160,14 +151,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn aggregate_ret(&self, ret_vals: &[&'ll Value]) {\n-        unsafe {\n-            llvm::LLVMBuildAggregateRet(self.llbuilder,\n-                                        ret_vals.as_ptr(),\n-                                        ret_vals.len() as c_uint);\n-        }\n-    }\n-\n     pub fn br(&self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n@@ -188,13 +171,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn indirect_br(&self, addr: &'ll Value, num_dests: usize) {\n-        self.count_insn(\"indirectbr\");\n-        unsafe {\n-            llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n-        }\n-    }\n-\n     pub fn invoke(&self,\n                   llfn: &'ll Value,\n                   args: &[&'ll Value],\n@@ -237,20 +213,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nswadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nswadd\");\n-        unsafe {\n-            llvm::LLVMBuildNSWAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nuwadd\");\n-        unsafe {\n-            llvm::LLVMBuildNUWAdd(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     pub fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n@@ -274,20 +236,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nswsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nswsub\");\n-        unsafe {\n-            llvm::LLVMBuildNSWSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nuwsub\");\n-        unsafe {\n-            llvm::LLVMBuildNUWSub(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     pub fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n@@ -311,20 +259,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nswmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nswmul\");\n-        unsafe {\n-            llvm::LLVMBuildNSWMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n-    pub fn nuwmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nuwmul\");\n-        unsafe {\n-            llvm::LLVMBuildNUWMul(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     pub fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n@@ -458,34 +392,13 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn binop(&self, op: Opcode, lhs: &'ll Value, rhs: &'ll Value)\n-              -> &'ll Value {\n-        self.count_insn(\"binop\");\n-        unsafe {\n-            llvm::LLVMBuildBinOp(self.llbuilder, op, lhs, rhs, noname())\n-        }\n-    }\n-\n     pub fn neg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nswneg(&self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nswneg\");\n-        unsafe {\n-            llvm::LLVMBuildNSWNeg(self.llbuilder, v, noname())\n-        }\n-    }\n-\n-    pub fn nuwneg(&self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"nuwneg\");\n-        unsafe {\n-            llvm::LLVMBuildNUWNeg(self.llbuilder, v, noname())\n-        }\n-    }\n     pub fn fneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n@@ -523,13 +436,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn free(&self, ptr: &'ll Value) {\n-        self.count_insn(\"free\");\n-        unsafe {\n-            llvm::LLVMBuildFree(self.llbuilder, ptr);\n-        }\n-    }\n-\n     pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n@@ -658,20 +564,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn global_string(&self, _str: *const c_char) -> &'ll Value {\n-        self.count_insn(\"globalstring\");\n-        unsafe {\n-            llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n-        }\n-    }\n-\n-    pub fn global_string_ptr(&self, _str: *const c_char) -> &'ll Value {\n-        self.count_insn(\"globalstringptr\");\n-        unsafe {\n-            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n-        }\n-    }\n-\n     /* Casts */\n     pub fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n@@ -757,34 +649,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn zext_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zextorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    pub fn sext_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sextorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    pub fn trunc_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"truncorbitcast\");\n-        unsafe {\n-            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    pub fn cast(&self, op: Opcode, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"cast\");\n-        unsafe {\n-            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty, noname())\n-        }\n-    }\n-\n     pub fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n@@ -799,14 +663,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn fpcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fpcast\");\n-        unsafe {\n-            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-\n     /* Comparisons */\n     pub fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n@@ -842,32 +698,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.cx.sess().asm_comments() {\n-            let s = format!(\"{} ({})\",\n-                            text,\n-                            self.cx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s);\n-            self.add_comment(&s);\n-        }\n-    }\n-\n-    pub fn add_comment(&self, text: &str) {\n-        if self.cx.sess().asm_comments() {\n-            let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = format!(\"{} {}\", \"#\",\n-                                       sanitized.replace(\"\\n\", \"\\n\\t# \"));\n-            self.count_insn(\"inlineasm\");\n-            let comment_text = CString::new(comment_text).unwrap();\n-            let asm = unsafe {\n-                llvm::LLVMConstInlineAsm(Type::func(&[], Type::void(self.cx)),\n-                                         comment_text.as_ptr(), noname(), False,\n-                                         False)\n-            };\n-            self.call(asm, &[], None);\n-        }\n-    }\n-\n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n                          inputs: &[&'ll Value], output: &'ll Type,\n                          volatile: bool, alignstack: bool,\n@@ -936,6 +766,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    #[allow(dead_code)]\n     pub fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n@@ -1102,27 +933,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn is_null(&self, val: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"isnull\");\n-        unsafe {\n-            llvm::LLVMBuildIsNull(self.llbuilder, val, noname())\n-        }\n-    }\n-\n-    pub fn is_not_null(&self, val: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"isnotnull\");\n-        unsafe {\n-            llvm::LLVMBuildIsNotNull(self.llbuilder, val, noname())\n-        }\n-    }\n-\n-    pub fn ptrdiff(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"ptrdiff\");\n-        unsafe {\n-            llvm::LLVMBuildPtrDiff(self.llbuilder, lhs, rhs, noname())\n-        }\n-    }\n-\n     pub fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");"}, {"sha": "d67cc773bbcc8c1a367b4661cd38cfbfd5d8a306", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 19, "deletions": 176, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=ebec156abfc25ce695227ed2c12c420244a433f8", "patch": "@@ -22,20 +22,20 @@ use super::debuginfo::{\n };\n \n use libc::{c_uint, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong, c_void};\n+use libc::{c_ulonglong, c_void};\n \n use std::ptr::NonNull;\n \n use super::RustStringRef;\n \n-pub type Opcode = u32;\n pub type Bool = c_uint;\n \n pub const True: Bool = 1 as Bool;\n pub const False: Bool = 0 as Bool;\n \n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n pub enum LLVMRustResult {\n     Success,\n     Failure,\n@@ -88,22 +88,14 @@ pub enum Visibility {\n     Protected = 2,\n }\n \n-/// LLVMDiagnosticSeverity\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub enum DiagnosticSeverity {\n-    Error = 0,\n-    Warning = 1,\n-    Remark = 2,\n-    Note = 3,\n-}\n-\n /// LLVMDLLStorageClass\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum DLLStorageClass {\n+    #[allow(dead_code)]\n     Default = 0,\n     DllImport = 1, // Function to be imported from DLL.\n+    #[allow(dead_code)]\n     DllExport = 2, // Function to be accessible from DLL.\n }\n \n@@ -220,6 +212,7 @@ pub enum AtomicRmwBinOp {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum AtomicOrdering {\n+    #[allow(dead_code)]\n     NotAtomic = 0,\n     Unordered = 1,\n     Monotonic = 2,\n@@ -234,6 +227,8 @@ pub enum AtomicOrdering {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum SynchronizationScope {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     SingleThread,\n     CrossThread,\n@@ -243,6 +238,8 @@ pub enum SynchronizationScope {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum FileType {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     AssemblyFile,\n     ObjectFile,\n@@ -270,6 +267,8 @@ pub enum MetadataType {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum AsmDialect {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     Att,\n     Intel,\n@@ -279,6 +278,8 @@ pub enum AsmDialect {\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     None,\n     Less,\n@@ -303,6 +304,8 @@ pub enum RelocMode {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum CodeModel {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     Small,\n     Kernel,\n@@ -314,6 +317,7 @@ pub enum CodeModel {\n /// LLVMRustDiagnosticKind\n #[derive(Copy, Clone)]\n #[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n pub enum DiagnosticKind {\n     Other,\n     InlineAsm,\n@@ -334,6 +338,8 @@ pub enum DiagnosticKind {\n #[derive(Copy, Clone)]\n #[repr(C)]\n pub enum ArchiveKind {\n+    // FIXME: figure out if this variant is needed at all.\n+    #[allow(dead_code)]\n     Other,\n     K_GNU,\n     K_BSD,\n@@ -343,6 +349,7 @@ pub enum ArchiveKind {\n /// LLVMRustPassKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n pub enum PassKind {\n     Other,\n     Function,\n@@ -406,8 +413,6 @@ extern { pub type Twine; }\n pub type TwineRef = *mut Twine;\n extern { pub type DiagnosticInfo; }\n pub type DiagnosticInfoRef = *mut DiagnosticInfo;\n-extern { pub type DebugLoc; }\n-pub type DebugLocRef = *mut DebugLoc;\n extern { pub type SMDiagnostic; }\n pub type SMDiagnosticRef = *mut SMDiagnostic;\n extern { pub type RustArchiveMember; }\n@@ -492,9 +497,6 @@ extern \"C\" {\n     pub fn LLVMGetDataLayout(M: &Module) -> *const c_char;\n     pub fn LLVMSetDataLayout(M: &Module, Triple: *const c_char);\n \n-    /// See Module::dump.\n-    pub fn LLVMDumpModule(M: &Module);\n-\n     /// See Module::setModuleInlineAsm.\n     pub fn LLVMSetModuleInlineAsm(M: &Module, Asm: *const c_char);\n     pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char);\n@@ -522,7 +524,6 @@ extern \"C\" {\n                             ParamCount: c_uint,\n                             IsVarArg: Bool)\n                             -> &'a Type;\n-    pub fn LLVMGetReturnType(FunctionTy: &Type) -> &Type;\n     pub fn LLVMCountParamTypes(FunctionTy: &Type) -> c_uint;\n     pub fn LLVMGetParamTypes(FunctionTy: &'a Type, Dest: *mut &'a Type);\n \n@@ -532,7 +533,6 @@ extern \"C\" {\n                                    ElementCount: c_uint,\n                                    Packed: Bool)\n                                    -> &'a Type;\n-    pub fn LLVMIsPackedStruct(StructTy: &Type) -> Bool;\n \n     // Operations on array, pointer, and vector types (sequence types)\n     pub fn LLVMRustArrayType(ElementType: &Type, ElementCount: u64) -> &Type;\n@@ -554,13 +554,8 @@ extern \"C\" {\n     pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n     pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n \n-    // Operations on Users\n-    pub fn LLVMGetOperand(Val: &Value, Index: c_uint) -> &Value;\n-\n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n-    pub fn LLVMConstICmp(Pred: IntPredicate, V1: &'a Value, V2: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: &'a Value, V2: &'a Value) -> &'a Value;\n     pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n@@ -572,7 +567,6 @@ extern \"C\" {\n     pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: &Value) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n     pub fn LLVMConstRealGetDouble (ConstantVal: &Value, losesInfo: *mut Bool) -> f64;\n@@ -597,67 +591,25 @@ extern \"C\" {\n     pub fn LLVMConstVector(ScalarConstantVals: *const &Value, Size: c_uint) -> &Value;\n \n     // Constant expressions\n-    pub fn LLVMSizeOf(Ty: &Type) -> &Value;\n-    pub fn LLVMConstNeg(ConstantVal: &Value) -> &Value;\n-    pub fn LLVMConstFNeg(ConstantVal: &Value) -> &Value;\n-    pub fn LLVMConstNot(ConstantVal: &Value) -> &Value;\n-    pub fn LLVMConstAdd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFAdd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstSub(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFSub(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstMul(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFMul(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstUDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstSDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstURem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstSRem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstFRem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstAnd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstOr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstXor(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstShl(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstLShr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstAShr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n-    pub fn LLVMConstGEP(\n-        ConstantVal: &'a Value,\n-        ConstantIndices: *const &'a Value,\n-        NumIndices: c_uint,\n-    ) -> &'a Value;\n     pub fn LLVMConstInBoundsGEP(\n         ConstantVal: &'a Value,\n         ConstantIndices: *const &'a Value,\n         NumIndices: c_uint,\n     ) -> &'a Value;\n-    pub fn LLVMConstTrunc(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstZExt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstUIToFP(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstSIToFP(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstFPToUI(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstFPToSI(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstPtrToInt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstIntToPtr(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstBitCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstPointerCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n-    pub fn LLVMConstIntCast(ConstantVal: &'a Value, ToType: &'a Type, isSigned: Bool) -> &'a Value;\n-    pub fn LLVMConstFPCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n     pub fn LLVMConstExtractValue(AggConstant: &Value,\n                                  IdxList: *const c_uint,\n                                  NumIdx: c_uint)\n                                  -> &Value;\n-    pub fn LLVMConstInlineAsm(Ty: &Type,\n-                              AsmString: *const c_char,\n-                              Constraints: *const c_char,\n-                              HasSideEffects: Bool,\n-                              IsAlignStack: Bool)\n-                              -> &Value;\n-\n \n     // Operations on global variables, functions, and aliases (globals)\n     pub fn LLVMIsDeclaration(Global: &Value) -> Bool;\n     pub fn LLVMRustGetLinkage(Global: &Value) -> Linkage;\n     pub fn LLVMRustSetLinkage(Global: &Value, RustLinkage: Linkage);\n-    pub fn LLVMGetSection(Global: &Value) -> *const c_char;\n     pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n     pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n     pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n@@ -684,10 +636,6 @@ extern \"C\" {\n     pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n \n     // Operations on functions\n-    pub fn LLVMAddFunction(M: &'a Module, Name: *const c_char, FunctionTy: &'a Type) -> &'a Value;\n-    pub fn LLVMGetNamedFunction(M: &Module, Name: *const c_char) -> &Value;\n-    pub fn LLVMGetFirstFunction(M: &Module) -> &Value;\n-    pub fn LLVMGetNextFunction(Fn: &Value) -> &Value;\n     pub fn LLVMRustGetOrInsertFunction(M: &'a Module,\n                                        Name: *const c_char,\n                                        FunctionTy: &'a Type)\n@@ -708,7 +656,6 @@ extern \"C\" {\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n     // Operations on basic blocks\n-    pub fn LLVMBasicBlockAsValue(BB: &BasicBlock) -> &Value;\n     pub fn LLVMGetBasicBlockParent(BB: &BasicBlock) -> &Value;\n     pub fn LLVMAppendBasicBlockInContext(C: &'a Context,\n                                          Fn: &'a Value,\n@@ -717,10 +664,7 @@ extern \"C\" {\n     pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n-    pub fn LLVMGetInstructionParent(Inst: &Value) -> &BasicBlock;\n     pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n-    pub fn LLVMGetFirstInstruction(BB: &BasicBlock) -> &'a Value;\n-    pub fn LLVMInstructionEraseFromParent(Inst: &Value);\n \n     // Operations on call sites\n     pub fn LLVMSetInstructionCallConv(Instr: &Value, CC: c_uint);\n@@ -742,8 +686,6 @@ extern \"C\" {\n \n     // Instruction builders\n     pub fn LLVMCreateBuilderInContext(C: &Context) -> &Builder;\n-    pub fn LLVMPositionBuilder(Builder: &'a Builder, Block: &'a BasicBlock, Instr: &'a Value);\n-    pub fn LLVMPositionBuilderBefore(Builder: &'a Builder, Instr: &'a Value);\n     pub fn LLVMPositionBuilderAtEnd(Builder: &'a Builder, Block: &'a BasicBlock);\n     pub fn LLVMGetInsertBlock(Builder: &Builder) -> &BasicBlock;\n     pub fn LLVMDisposeBuilder(Builder: &Builder);\n@@ -756,7 +698,6 @@ extern \"C\" {\n     // Terminators\n     pub fn LLVMBuildRetVoid(B: &Builder) -> &Value;\n     pub fn LLVMBuildRet(B: &'a Builder, V: &'a Value) -> &'a Value;\n-    pub fn LLVMBuildAggregateRet(B: &'a Builder, RetVals: *const &'a Value, N: c_uint) -> &'a Value;\n     pub fn LLVMBuildBr(B: &'a Builder, Dest: &'a BasicBlock) -> &'a Value;\n     pub fn LLVMBuildCondBr(B: &'a Builder,\n                            If: &'a Value,\n@@ -768,7 +709,6 @@ extern \"C\" {\n                            Else: &'a BasicBlock,\n                            NumCases: c_uint)\n                            -> &'a Value;\n-    pub fn LLVMBuildIndirectBr(B: &'a Builder, Addr: &'a Value, NumDests: c_uint) -> &'a Value;\n     pub fn LLVMRustBuildInvoke(B: &'a Builder,\n                                Fn: &'a Value,\n                                Args: *const &'a Value,\n@@ -828,16 +768,6 @@ extern \"C\" {\n                         RHS: &'a Value,\n                         Name: *const c_char)\n                         -> &'a Value;\n-    pub fn LLVMBuildNSWAdd(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n-    pub fn LLVMBuildNUWAdd(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n     pub fn LLVMBuildFAdd(B: &'a Builder,\n                          LHS: &'a Value,\n                          RHS: &'a Value,\n@@ -848,16 +778,6 @@ extern \"C\" {\n                         RHS: &'a Value,\n                         Name: *const c_char)\n                         -> &'a Value;\n-    pub fn LLVMBuildNSWSub(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n-    pub fn LLVMBuildNUWSub(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n     pub fn LLVMBuildFSub(B: &'a Builder,\n                          LHS: &'a Value,\n                          RHS: &'a Value,\n@@ -868,16 +788,6 @@ extern \"C\" {\n                         RHS: &'a Value,\n                         Name: *const c_char)\n                         -> &'a Value;\n-    pub fn LLVMBuildNSWMul(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n-    pub fn LLVMBuildNUWMul(B: &'a Builder,\n-                           LHS: &'a Value,\n-                           RHS: &'a Value,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n     pub fn LLVMBuildFMul(B: &'a Builder,\n                          LHS: &'a Value,\n                          RHS: &'a Value,\n@@ -953,22 +863,13 @@ extern \"C\" {\n                         RHS: &'a Value,\n                         Name: *const c_char)\n                         -> &'a Value;\n-    pub fn LLVMBuildBinOp(B: &'a Builder,\n-                          Op: Opcode,\n-                          LHS: &'a Value,\n-                          RHS: &'a Value,\n-                          Name: *const c_char)\n-                          -> &'a Value;\n     pub fn LLVMBuildNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildNSWNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildNUWNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildFNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildNot(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMRustSetHasUnsafeAlgebra(Instr: &Value);\n \n     // Memory\n     pub fn LLVMBuildAlloca(B: &'a Builder, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildFree(B: &'a Builder, PointerVal: &'a Value) -> &'a Value;\n     pub fn LLVMBuildLoad(B: &'a Builder, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n \n     pub fn LLVMBuildStore(B: &'a Builder, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n@@ -990,14 +891,6 @@ extern \"C\" {\n                               Idx: c_uint,\n                               Name: *const c_char)\n                               -> &'a Value;\n-    pub fn LLVMBuildGlobalString(B: &Builder,\n-                                 Str: *const c_char,\n-                                 Name: *const c_char)\n-                                 -> &Value;\n-    pub fn LLVMBuildGlobalStringPtr(B: &Builder,\n-                                    Str: *const c_char,\n-                                    Name: *const c_char)\n-                                    -> &Value;\n \n     // Casts\n     pub fn LLVMBuildTrunc(B: &'a Builder,\n@@ -1060,27 +953,6 @@ extern \"C\" {\n                             DestTy: &'a Type,\n                             Name: *const c_char)\n                             -> &'a Value;\n-    pub fn LLVMBuildZExtOrBitCast(B: &'a Builder,\n-                                  Val: &'a Value,\n-                                  DestTy: &'a Type,\n-                                  Name: *const c_char)\n-                                  -> &'a Value;\n-    pub fn LLVMBuildSExtOrBitCast(B: &'a Builder,\n-                                  Val: &'a Value,\n-                                  DestTy: &'a Type,\n-                                  Name: *const c_char)\n-                                  -> &'a Value;\n-    pub fn LLVMBuildTruncOrBitCast(B: &'a Builder,\n-                                   Val: &'a Value,\n-                                   DestTy: &'a Type,\n-                                   Name: *const c_char)\n-                                   -> &'a Value;\n-    pub fn LLVMBuildCast(B: &'a Builder,\n-                         Op: Opcode,\n-                         Val: &'a Value,\n-                         DestTy: &'a Type,\n-                         Name: *const c_char)\n-                         -> &'a Value;\n     pub fn LLVMBuildPointerCast(B: &'a Builder,\n                                 Val: &'a Value,\n                                 DestTy: &'a Type,\n@@ -1091,11 +963,6 @@ extern \"C\" {\n                                 DestTy: &'a Type,\n                                 IsSized: bool)\n                                 -> &'a Value;\n-    pub fn LLVMBuildFPCast(B: &'a Builder,\n-                           Val: &'a Value,\n-                           DestTy: &'a Type,\n-                           Name: *const c_char)\n-                           -> &'a Value;\n \n     // Comparisons\n     pub fn LLVMBuildICmp(B: &'a Builder,\n@@ -1203,14 +1070,6 @@ extern \"C\" {\n     pub fn LLVMRustBuildMinNum(B: &'a Builder, LHS: &'a Value, LHS: &'a Value) -> Option<&'a Value>;\n     pub fn LLVMRustBuildMaxNum(B: &'a Builder, LHS: &'a Value, LHS: &'a Value) -> Option<&'a Value>;\n \n-    pub fn LLVMBuildIsNull(B: &'a Builder, Val: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildIsNotNull(B: &'a Builder, Val: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMBuildPtrDiff(B: &'a Builder,\n-                            LHS: &'a Value,\n-                            RHS: &'a Value,\n-                            Name: *const c_char)\n-                            -> &'a Value;\n-\n     // Atomic Operations\n     pub fn LLVMRustBuildAtomicLoad(B: &'a Builder,\n                                    PointerVal: &'a Value,\n@@ -1245,11 +1104,6 @@ extern \"C\" {\n                                     Order: AtomicOrdering,\n                                     Scope: SynchronizationScope);\n \n-\n-    // Selected entries from the downcasts.\n-    pub fn LLVMIsATerminatorInst(Inst: &Value) -> &Value;\n-    pub fn LLVMIsAStoreInst(Inst: &Value) -> &Value;\n-\n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n@@ -1472,13 +1326,6 @@ extern \"C\" {\n                                             Subscripts: &'a DIArray)\n                                             -> &'a DIType;\n \n-    pub fn LLVMRustDIBuilderCreateVectorType(Builder: &'a DIBuilder,\n-                                             Size: u64,\n-                                             AlignInBits: u32,\n-                                             Ty: &'a DIType,\n-                                             Subscripts: &'a DIArray)\n-                                             -> &'a DIType;\n-\n     pub fn LLVMRustDIBuilderGetOrCreateSubrange(Builder: &DIBuilder,\n                                                 Lo: i64,\n                                                 Count: i64)\n@@ -1696,9 +1543,6 @@ extern \"C\" {\n \n     pub fn LLVMRustThinLTOAvailable() -> bool;\n     pub fn LLVMRustPGOAvailable() -> bool;\n-    pub fn LLVMRustWriteThinBitcodeToFile(PMR: PassManagerRef,\n-                                          M: &Module,\n-                                          BC: *const c_char) -> bool;\n     pub fn LLVMRustThinLTOBufferCreate(M: &Module) -> *mut ThinLTOBuffer;\n     pub fn LLVMRustThinLTOBufferFree(M: *mut ThinLTOBuffer);\n     pub fn LLVMRustThinLTOBufferPtr(M: *const ThinLTOBuffer) -> *const c_char;\n@@ -1732,7 +1576,6 @@ extern \"C\" {\n         len: usize,\n         Identifier: *const c_char,\n     ) -> Option<&Module>;\n-    pub fn LLVMGetModuleIdentifier(M: &Module, size: *mut usize) -> *const c_char;\n     pub fn LLVMRustThinLTOGetDICompileUnit(M: &Module,\n                                            CU1: *mut *mut c_void,\n                                            CU2: *mut *mut c_void);"}, {"sha": "3f5550bf95fd234e8587590260fc833190d5b9fc", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=ebec156abfc25ce695227ed2c12c420244a433f8", "patch": "@@ -828,23 +828,6 @@ LLVMRustPGOAvailable() {\n // and various online resources about ThinLTO to make heads or tails of all\n // this.\n \n-extern \"C\" bool\n-LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n-                               LLVMModuleRef M,\n-                               const char *BcFile) {\n-  llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n-  std::error_code EC;\n-  llvm::raw_fd_ostream bc(BcFile, EC, llvm::sys::fs::F_None);\n-  if (EC) {\n-    LLVMRustSetLastError(EC.message().c_str());\n-    return false;\n-  }\n-  PM->add(createWriteThinLTOBitcodePass(bc));\n-  PM->run(*unwrap(M));\n-  delete PM;\n-  return true;\n-}\n-\n // This is a shared data structure which *must* be threadsafe to share\n // read-only amongst threads. This also corresponds basically to the arguments\n // of the `ProcessThinLTOModule` function in the LLVM source.\n@@ -1259,13 +1242,6 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n \n #else\n \n-extern \"C\" bool\n-LLVMRustWriteThinBitcodeToFile(LLVMPassManagerRef PMR,\n-                               LLVMModuleRef M,\n-                               const char *BcFile) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n struct LLVMRustThinLTOData {\n };\n "}, {"sha": "f2b5297285ca79623d4ccad6e3b13d69625dda09", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ebec156abfc25ce695227ed2c12c420244a433f8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ebec156abfc25ce695227ed2c12c420244a433f8", "patch": "@@ -750,15 +750,6 @@ LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateVectorType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n-                                  uint32_t AlignInBits, LLVMMetadataRef Ty,\n-                                  LLVMMetadataRef Subscripts) {\n-  return wrap(\n-      Builder->createVectorType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n-                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n-}\n-\n extern \"C\" LLVMMetadataRef\n LLVMRustDIBuilderGetOrCreateSubrange(LLVMRustDIBuilderRef Builder, int64_t Lo,\n                                      int64_t Count) {"}]}