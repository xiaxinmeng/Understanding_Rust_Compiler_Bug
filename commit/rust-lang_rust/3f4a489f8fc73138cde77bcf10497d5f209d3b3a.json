{"sha": "3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNGE0ODlmOGZjNzMxMzhjZGU3N2JjZjEwNDk3ZDVmMjA5ZDNiM2E=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T22:55:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T23:20:18Z"}, "message": "rustc_typeck: rename `LvalueOp` to `PlaceOp`.", "tree": {"sha": "0cd887c7a2e3cf7f97afe0497b241bc61de5fdf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd887c7a2e3cf7f97afe0497b241bc61de5fdf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "html_url": "https://github.com/rust-lang/rust/commit/3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c4a75bf097104e3e08ee307deb34bed0b5531d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a75bf097104e3e08ee307deb34bed0b5531d4", "html_url": "https://github.com/rust-lang/rust/commit/2c4a75bf097104e3e08ee307deb34bed0b5531d4"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "1d7c533178f075b3d9b5bfd25ae2da5e27a2502e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "patch": "@@ -10,7 +10,7 @@\n \n use astconv::AstConv;\n \n-use super::{FnCtxt, LvalueOp, Needs};\n+use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n use rustc::infer::InferOk;\n@@ -239,6 +239,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 base_ty: Ty<'tcx>,\n                                 needs: Needs)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_lvalue_op(span, base_ty, &[], needs, LvalueOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n     }\n }"}, {"sha": "71c1326b41232252f84a73492dce1d2ec6397469", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "patch": "@@ -11,7 +11,7 @@\n use super::{probe, MethodCallee};\n \n use astconv::AstConv;\n-use check::{FnCtxt, LvalueOp, callee, Needs};\n+use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -438,7 +438,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded lvalue ops, and will be fixed by them in order to get\n+            // overloaded place ops, and will be fixed by them in order to get\n             // the correct region.\n             let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n@@ -470,53 +470,53 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n-                    self.convert_lvalue_op_to_mutable(\n-                        LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n-                    self.convert_lvalue_op_to_mutable(\n-                        LvalueOp::Deref, expr, base_expr, &[]);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Deref, expr, base_expr, &[]);\n                 }\n                 _ => {}\n             }\n         }\n     }\n \n-    fn convert_lvalue_op_to_mutable(&self,\n-                                    op: LvalueOp,\n+    fn convert_place_op_to_mutable(&self,\n+                                    op: PlaceOp,\n                                     expr: &hir::Expr,\n                                     base_expr: &hir::Expr,\n                                     arg_tys: &[Ty<'tcx>])\n     {\n-        debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n                op, expr, base_expr, arg_tys);\n         if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n             return\n         }\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n-        // Need to deref because overloaded lvalue ops take self by-reference.\n+        // Need to deref because overloaded place ops take self by-reference.\n         let base_ty = base_ty.builtin_deref(false)\n-            .expect(\"lvalue op takes something that is not a ref\")\n+            .expect(\"place op takes something that is not a ref\")\n             .ty;\n \n-        let method = self.try_overloaded_lvalue_op(\n+        let method = self.try_overloaded_place_op(\n             expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n         let method = match method {\n             Some(ok) => self.register_infer_ok_obligations(ok),\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n-        debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)\n         } else {\n-            span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+            span_bug!(expr.span, \"input to place op is not a ref?\");\n         };\n \n         // Convert the autoref in the base expr to mutable with the correct\n@@ -529,7 +529,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_lvalue_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n                     adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n                     adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n                         ty: source,"}, {"sha": "8a54240c1e774a86a2cd0ab68b7f3b46f70dedce", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4a489f8fc73138cde77bcf10497d5f209d3b3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3f4a489f8fc73138cde77bcf10497d5f209d3b3a", "patch": "@@ -424,7 +424,7 @@ impl UnsafetyState {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub enum LvalueOp {\n+pub enum PlaceOp {\n     Deref,\n     Index\n }\n@@ -2293,8 +2293,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n             let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n-            let method = self.try_overloaded_lvalue_op(\n-                expr.span, self_ty, &[input_ty], needs, LvalueOp::Index);\n+            let method = self.try_overloaded_place_op(\n+                expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n             let result = method.map(|ok| {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n@@ -2329,36 +2329,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n+    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n         let (tr, name) = match (op, is_mut) {\n-            (LvalueOp::Deref, false) =>\n+            (PlaceOp::Deref, false) =>\n                 (self.tcx.lang_items().deref_trait(), \"deref\"),\n-            (LvalueOp::Deref, true) =>\n+            (PlaceOp::Deref, true) =>\n                 (self.tcx.lang_items().deref_mut_trait(), \"deref_mut\"),\n-            (LvalueOp::Index, false) =>\n+            (PlaceOp::Index, false) =>\n                 (self.tcx.lang_items().index_trait(), \"index\"),\n-            (LvalueOp::Index, true) =>\n+            (PlaceOp::Index, true) =>\n                 (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n         (tr, Symbol::intern(name))\n     }\n \n-    fn try_overloaded_lvalue_op(&self,\n+    fn try_overloaded_place_op(&self,\n                                 span: Span,\n                                 base_ty: Ty<'tcx>,\n                                 arg_tys: &[Ty<'tcx>],\n                                 needs: Needs,\n-                                op: LvalueOp)\n+                                op: PlaceOp)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n     {\n-        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\",\n                span,\n                base_ty,\n                needs,\n                op);\n \n         // Try Mut first, if needed.\n-        let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n+        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n         let method = match (needs, mut_tr) {\n             (Needs::MutPlace, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n@@ -2367,7 +2367,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_lvalue_op(op, false);\n+        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n         let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))"}]}