{"sha": "e0f59e835e062d27543ae5085b49effb13294b61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZjU5ZTgzNWUwNjJkMjc1NDNhZTUwODViNDllZmZiMTMyOTRiNjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-23T04:36:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-23T13:30:29Z"}, "message": "modify borrowck to allow arbitrary borrows in pure scopes", "tree": {"sha": "3383addb4de99c4581bdc69b95c29edbccbcf48b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3383addb4de99c4581bdc69b95c29edbccbcf48b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f59e835e062d27543ae5085b49effb13294b61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f59e835e062d27543ae5085b49effb13294b61", "html_url": "https://github.com/rust-lang/rust/commit/e0f59e835e062d27543ae5085b49effb13294b61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f59e835e062d27543ae5085b49effb13294b61/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00849191ceeba124e27f38e27306badc264e48d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/00849191ceeba124e27f38e27306badc264e48d7", "html_url": "https://github.com/rust-lang/rust/commit/00849191ceeba124e27f38e27306badc264e48d7"}], "stats": {"total": 276, "additions": 211, "deletions": 65}, "files": [{"sha": "bb65df934f71fb39c8798e593f12cfe20979c84b", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 127, "deletions": 26, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -38,7 +38,8 @@ fn check_crate(tcx: ty::ctxt,\n     let req_maps = if msg_level > 0u {\n         gather_loans(bccx, crate)\n     } else {\n-        {req_loan_map: int_hash()}\n+        {req_loan_map: int_hash(),\n+         pure_map: int_hash()}\n     };\n     check_loans(bccx, req_maps, crate);\n     ret (bccx.root_map, bccx.mutbl_map);\n@@ -165,14 +166,16 @@ fn root_map() -> root_map {\n // sure that all of these loans are honored.\n \n type req_maps = {\n-    req_loan_map: hashmap<ast::node_id, @mut [@const [loan]]>\n+    req_loan_map: hashmap<ast::node_id, @mut [@const [loan]]>,\n+    pure_map: hashmap<ast::node_id, bckerr>\n };\n \n enum gather_loan_ctxt = @{bccx: borrowck_ctxt, req_maps: req_maps};\n \n fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n     let glcx = gather_loan_ctxt(@{bccx: bccx,\n-                                  req_maps: {req_loan_map: int_hash()}});\n+                                  req_maps: {req_loan_map: int_hash(),\n+                                             pure_map: int_hash()}});\n     let v = visit::mk_vt(@{visit_expr: req_loans_in_expr\n                            with *visit::default_visitor()});\n     visit::visit_crate(*crate, glcx, v);\n@@ -293,15 +296,40 @@ impl methods for gather_loan_ctxt {\n           // it dynamically (or see that it is preserved by virtue of being\n           // rooted in some immutable path)\n           none {\n-            self.bccx.report_if_err(\n-                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n-                    let opt_scope_id = alt scope_r {\n-                      ty::re_scope(scope_id) { some(scope_id) }\n-                      _ { none }\n-                    };\n+            let opt_scope_id = alt scope_r {\n+              ty::re_scope(scope_id) { some(scope_id) }\n+              _ { none }\n+            };\n \n+            let result = {\n+                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n                     self.bccx.preserve(cmt, opt_scope_id)\n-                })\n+                }\n+            };\n+\n+            alt result {\n+              ok(()) {\n+                // we were able guarantee the validity of the ptr,\n+                // perhaps by rooting or because it is immutably\n+                // rooted.  good.\n+              }\n+              err(e) {\n+                // not able to guarantee the validity of the ptr.\n+                // rather than report an error, presuming that the\n+                // borrow is for a limited scope, we'll make one last\n+                // ditch effort and require that the scope where the\n+                // borrow occurs be pure.\n+                alt opt_scope_id {\n+                  some(scope_id) {\n+                    self.req_maps.pure_map.insert(scope_id, e);\n+                  }\n+                  none {\n+                    // otherwise, fine, I give up.\n+                    self.bccx.report(e);\n+                  }\n+                }\n+              }\n+            }\n           }\n         }\n     }\n@@ -475,16 +503,30 @@ enum check_loan_ctxt = @{\n     // we are in a ctor, we track the self id\n     mut in_ctor: bool,\n \n-    mut is_pure: bool\n+    mut is_pure: purity_cause\n };\n \n+// if we are enforcing purity, why are we doing so?\n+enum purity_cause {\n+    // not enforcing purity:\n+    pc_impure,\n+\n+    // enforcing purity because fn was declared pure:\n+    pc_declaration,\n+\n+    // enforce purity because we need to guarantee the\n+    // validity of some alias; `bckerr` describes the\n+    // reason we needed to enforce purity.\n+    pc_cmt(bckerr)\n+}\n+\n fn check_loans(bccx: borrowck_ctxt,\n                req_maps: req_maps,\n                crate: @ast::crate) {\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_maps: req_maps,\n                                  mut in_ctor: false,\n-                                 mut is_pure: false});\n+                                 mut is_pure: pc_impure});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n@@ -595,24 +637,37 @@ impl methods for check_loan_ctxt {\n             };\n \n             alt callee_purity {\n-              ast::crust_fn | ast::pure_fn { /*ok*/ }\n-              ast::impure_fn {\n-                self.bccx.span_err(\n-                    expr.span,\n-                    \"pure function calls function \\\n-                     not known to be pure\");\n+              ast::crust_fn | ast::pure_fn {\n+                /*ok*/\n               }\n-              ast::unsafe_fn {\n+              ast::impure_fn | ast::unsafe_fn {\n                 self.bccx.span_err(\n                     expr.span,\n-                    \"pure function calls unsafe function\");\n+                    \"access to non-pure functions \\\n+                     prohibited in a pure context\");\n+                self.report_why_pure();\n               }\n             }\n           }\n           _ { /* not a fn, ok */ }\n         }\n     }\n \n+    fn check_for_purity_requirement(scope_id: ast::node_id) {\n+        // if we are not already enforcing purity, check whether the\n+        // gather pass thought we needed to enforce purity for this\n+        // scope.\n+        alt self.is_pure {\n+          pc_declaration | pc_cmt(*) { }\n+          pc_impure {\n+            alt self.req_maps.pure_map.find(scope_id) {\n+              none {}\n+              some(e) {self.is_pure = pc_cmt(e)}\n+            }\n+          }\n+        }\n+    }\n+\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n             none { ret; }\n@@ -683,11 +738,12 @@ impl methods for check_loan_ctxt {\n         // if this is a pure function, only loan-able state can be\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n-        if self.is_pure && cmt.lp.is_none() {\n+        if self.is_pure != pc_impure && cmt.lp.is_none() {\n             self.bccx.span_err(\n                 ex.span,\n-                #fmt[\"%s prohibited in pure functions\",\n+                #fmt[\"%s prohibited in a pure context\",\n                      at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+            self.report_why_pure();\n         }\n \n         // check for a conflicting loan as well, except in the case of\n@@ -720,6 +776,23 @@ impl methods for check_loan_ctxt {\n         self.bccx.add_to_mutbl_map(cmt);\n     }\n \n+    fn report_why_pure() {\n+        alt self.is_pure {\n+          pc_impure {\n+            self.tcx().sess.bug(\"report_why_pure() called when impure\");\n+          }\n+          pc_declaration {\n+            // fn was declared pure; no need to report this, I think\n+          }\n+          pc_cmt(e) {\n+            self.tcx().sess.span_note(\n+                e.cmt.span,\n+                #fmt[\"pure context is required due to an illegal borrow: %s\",\n+                     self.bccx.bckerr_code_to_str(e.code)]);\n+          }\n+        }\n+    }\n+\n     fn check_move_out(ex: @ast::expr) {\n         let cmt = self.bccx.cat_expr(ex);\n         self.check_move_out_from_cmt(cmt);\n@@ -788,8 +861,11 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n               _ { self.in_ctor = false; }\n             };\n \n+            // NDM this doesn't seem algother right, what about fn  items\n+            // nested in pure fns? etc?\n+\n             alt decl.purity {\n-              ast::pure_fn { self.is_pure = true; }\n+              ast::pure_fn { self.is_pure = pc_declaration; }\n               _ { }\n             }\n \n@@ -802,6 +878,16 @@ fn check_loans_in_expr(expr: @ast::expr,\n                        &&self: check_loan_ctxt,\n                        vt: visit::vt<check_loan_ctxt>) {\n     self.check_for_conflicting_loans(expr.id);\n+    save_and_restore(self.is_pure) {||\n+        self.check_for_purity_requirement(expr.id);\n+        check_loans_in_expr_1(expr, self, vt);\n+    }\n+}\n+\n+// avoid rightward drift by breaking this out into its own fn\n+fn check_loans_in_expr_1(expr: @ast::expr,\n+                         &&self: check_loan_ctxt,\n+                         vt: visit::vt<check_loan_ctxt>) {\n     alt expr.node {\n       ast::expr_swap(l, r) {\n         self.check_assignment(at_swap, l);\n@@ -844,7 +930,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n         }\n       }\n       ast::expr_call(f, args, _) {\n-        if self.is_pure {\n+        if self.is_pure != pc_impure {\n             self.check_pure(f);\n             for args.each { |arg| self.check_pure(arg) }\n         }\n@@ -873,12 +959,27 @@ fn check_loans_in_block(blk: ast::blk,\n                         vt: visit::vt<check_loan_ctxt>) {\n     save_and_restore(self.is_pure) {||\n         self.check_for_conflicting_loans(blk.node.id);\n+        self.check_for_purity_requirement(blk.node.id);\n \n         alt blk.node.rules {\n           ast::default_blk {\n           }\n-          ast::unchecked_blk |\n-          ast::unsafe_blk { self.is_pure = false; }\n+          ast::unchecked_blk {\n+            alt self.is_pure {\n+              pc_impure | pc_declaration {\n+                self.is_pure = pc_impure;\n+              }\n+              pc_cmt(_) {\n+                // unchecked does not override purity requirements due\n+                // to borrows; unchecked didn't seem strong enough to\n+                // justify potential memory unsafety to me\n+              }\n+            }\n+          }\n+          ast::unsafe_blk {\n+            // unsafe blocks override everything\n+            self.is_pure = pc_impure;\n+          }\n         }\n \n         visit::visit_block(blk, self, vt);"}, {"sha": "c442db5cdc29491295ae2f9954e4a71e9a225590", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -4,11 +4,12 @@\n fn borrow(_v: &int) {}\n \n fn borrow_from_arg_imm_ref(&&v: ~int) {\n-    borrow(v); // ERROR unique value in aliasable, mutable location\n+    borrow(v);\n }\n \n fn borrow_from_arg_mut_ref(&v: ~int) {\n-    borrow(v); //! ERROR unique value in aliasable, mutable location\n+    borrow(v); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn borrow_from_arg_move(-v: ~int) {"}, {"sha": "1a57b2551020c1c2f7e3c71ffdc63d470776dc68", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -9,12 +9,31 @@ fn match_imm_box(v: &const @option<int>) -> int {\n }\n \n fn match_const_box(v: &const @const option<int>) -> int {\n+    alt *v {\n+      @some(i) { i } // ok because this is pure\n+      @none {0}\n+    }\n+}\n+\n+pure fn pure_process(_i: int) {}\n+\n+fn match_const_box_and_do_pure_things(v: &const @const option<int>) {\n     alt *v {\n       @some(i) {\n-        //!^ ERROR enum variant in aliasable, mutable location\n-        i\n+        pure_process(i)\n       }\n-      @none {0}\n+      @none {}\n+    }\n+}\n+\n+fn process(_i: int) {}\n+\n+fn match_const_box_and_do_bad_things(v: &const @const option<int>) {\n+    alt *v {\n+      @some(i) { //! NOTE pure context is required due to an illegal borrow: enum variant in aliasable, mutable location\n+        process(i) //! ERROR access to non-pure functions prohibited in a pure context\n+      }\n+      @none {}\n     }\n }\n "}, {"sha": "fa2ccbedad5144f910e06685e220f947ba2e5d83", "filename": "src/test/compile-fail/borrowck-pat-enum.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -4,7 +4,6 @@\n fn match_ref(&&v: option<int>) -> int {\n     alt v {\n       some(i) {\n-        //^ ERROR enum variant in aliasable, mutable location\n         i\n       }\n       none {0}\n@@ -20,25 +19,33 @@ fn match_ref_unused(&&v: option<int>) {\n \n fn match_const_reg(v: &const option<int>) -> int {\n     alt *v {\n-      some(i) {\n-        //!^ ERROR enum variant in aliasable, mutable location\n-        i\n-      }\n+      some(i) {i} // OK because this is pure\n       none {0}\n     }\n }\n \n+fn impure(_i: int) {\n+}\n+\n fn match_const_reg_unused(v: &const option<int>) {\n     alt *v {\n-      some(_) {}\n+      some(_) {impure(0)} // OK because nothing is captured\n       none {}\n     }\n }\n \n-fn match_imm_reg(v: &option<int>) -> int {\n+fn match_const_reg_impure(v: &const option<int>) {\n     alt *v {\n-      some(i) {i}\n-      none {0}\n+      some(i) {impure(i)} //! ERROR access to non-pure functions prohibited in a pure context\n+      //!^ NOTE pure context is required due to an illegal borrow: enum variant in aliasable, mutable location\n+      none {}\n+    }\n+}\n+\n+fn match_imm_reg(v: &option<int>) {\n+    alt *v {\n+      some(i) {impure(i)} // OK because immutable\n+      none {}\n     }\n }\n "}, {"sha": "261af1870a85bc828f773e1eb1ef02ecdbcaeb0f", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -4,20 +4,23 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: @mut ~int) {\n-    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n-\n+    borrow(*v); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_rec_mut(v: @{mut f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_mut_rec(v: @mut {f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_mut_recs(v: @mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_imm(v: @~int) {\n@@ -33,23 +36,28 @@ fn box_imm_recs(v: @{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: @const ~int) {\n-    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(*v); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_rec_const(v: @{const f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_recs_const(v: @{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_const_rec(v: @const {f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_const_recs(v: @const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn main() {"}, {"sha": "b7e05f91c01c33c72d7cd2546d98f7ce5d6af498", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -3,20 +3,23 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {\n-    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n-\n+    borrow(*v); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_rec_mut(v: &{mut f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_mut_rec(v: &mut {f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_imm(v: &~int) {\n@@ -32,23 +35,28 @@ fn box_imm_recs(v: &{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: &const ~int) {\n-    borrow(*v); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(*v); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_rec_const(v: &{const f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_recs_const(v: &{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_const_rec(v: &const {f: ~int}) {\n-    borrow(v.f); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn box_const_recs(v: &const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //! ERROR illegal borrow: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //! ERROR access to non-pure functions prohibited in a pure context\n+    //!^ NOTE pure context is required due to an illegal borrow: unique value in aliasable, mutable location\n }\n \n fn main() {"}, {"sha": "960dc02269b8194ec98a83b03d641e95d4956793", "filename": "src/test/compile-fail/impure-pred.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -1,9 +1,11 @@\n // -*- rust -*-\n-// error-pattern: pure function calls function not known to be pure\n \n fn g() { }\n \n-pure fn f(q: int) -> bool { g(); ret true; }\n+pure fn f(_q: int) -> bool {\n+    g(); //! ERROR access to non-pure functions prohibited in a pure context\n+    ret true;\n+}\n \n fn main() {\n     let x = 0;"}, {"sha": "08852746d115370a06e84e49af50d50ae54ea6cf", "filename": "src/test/compile-fail/pure-modifies-aliased.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f59e835e062d27543ae5085b49effb13294b61/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs?ref=e0f59e835e062d27543ae5085b49effb13294b61", "patch": "@@ -1,16 +1,16 @@\n // Check that pure functions cannot modify aliased state.\n \n pure fn modify_in_ref(&&sum: {mut f: int}) {\n-    sum.f = 3; //! ERROR assigning to mutable field prohibited in pure functions\n+    sum.f = 3; //! ERROR assigning to mutable field prohibited in a pure context\n }\n \n pure fn modify_in_box(sum: @mut {f: int}) {\n-    sum.f = 3; //! ERROR assigning to mutable field prohibited in pure functions\n+    sum.f = 3; //! ERROR assigning to mutable field prohibited in a pure context\n }\n \n impl foo for int {\n     pure fn modify_in_box_rec(sum: @{mut f: int}) {\n-        sum.f = self; //! ERROR assigning to mutable field prohibited in pure functions\n+        sum.f = self; //! ERROR assigning to mutable field prohibited in a pure context\n     }\n }\n "}]}