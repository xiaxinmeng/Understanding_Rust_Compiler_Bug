{"sha": "080d3e435519e2665502c8bae6c3168ae4232e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MGQzZTQzNTUxOWUyNjY1NTAyYzhiYWU2YzMxNjhhZTQyMzJlMzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-08T15:27:28Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-08T15:27:28Z"}, "message": "properly prevent recursive statics from marking each other", "tree": {"sha": "9f34392711329446229d735f8767284a2b0faf3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f34392711329446229d735f8767284a2b0faf3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/080d3e435519e2665502c8bae6c3168ae4232e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/080d3e435519e2665502c8bae6c3168ae4232e33", "html_url": "https://github.com/rust-lang/rust/commit/080d3e435519e2665502c8bae6c3168ae4232e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/080d3e435519e2665502c8bae6c3168ae4232e33/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e23fc79d257095b1347dab58e369d55063857f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/e23fc79d257095b1347dab58e369d55063857f15", "html_url": "https://github.com/rust-lang/rust/commit/e23fc79d257095b1347dab58e369d55063857f15"}], "stats": {"total": 42, "additions": 30, "deletions": 12}, "files": [{"sha": "dedb8a53b718bf69722062fd14ea006b0e574030", "filename": "src/eval_context.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=080d3e435519e2665502c8bae6c3168ae4232e33", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n-        self.memory.mark_static(ptr.alloc_id, false)?;\n+        self.memory.mark_static_initalized(ptr.alloc_id, false)?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n@@ -194,9 +194,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n+                // FIXME: cache these allocs\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n-                self.memory.mark_static(ptr.alloc_id, false)?;\n+                self.memory.mark_static_initalized(ptr.alloc_id, false)?;\n                 PrimVal::Ptr(ptr)\n             }\n \n@@ -316,16 +317,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let global_value = self.globals.get_mut(&id)\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n-                    Value::ByRef(ptr) => self.memory.mark_static(ptr.alloc_id, mutable)?,\n+                    Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                        self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n@@ -870,10 +871,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n+                        self.memory.mark_static(ptr.alloc_id);\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n-                            self.memory.mark_static(ptr.alloc_id, global_val.mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {"}, {"sha": "6dee7ce49a1df38ee50ae57653b2f1250f8684f1", "filename": "src/memory.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=080d3e435519e2665502c8bae6c3168ae4232e33", "patch": "@@ -38,7 +38,7 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n-    /// Use the `mark_static` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     pub static_kind: StaticKind,\n }\n@@ -152,6 +152,11 @@ impl<'tcx> Function<'tcx> {\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n+    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from stepping\n+    /// out of its own allocations.\n+    /// This set only contains statics backed by an allocation. If they are ByVal or ByValPair they\n+    /// are not here, but will be inserted once they become ByRef.\n+    static_alloc: HashSet<AllocId>,\n     /// Number of virtual bytes allocated\n     memory_usage: u64,\n     /// Maximum number of virtual bytes that may be allocated\n@@ -189,6 +194,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             memory_size: max_memory,\n             memory_usage: 0,\n             packed: BTreeSet::new(),\n+            static_alloc: HashSet::new(),\n         }\n     }\n \n@@ -624,8 +630,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    /// mark an allocation as static, either mutable or not\n-    pub fn mark_static(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+    /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n+    pub fn mark_static(&mut self, alloc_id: AllocId) {\n+        if !self.static_alloc.insert(alloc_id) {\n+            bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n+        }\n+    }\n+\n+    /// mark an allocation as static and initialized, either mutable or not\n+    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n@@ -645,7 +658,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_static(alloc, mutable)?;\n+            // relocations into other statics are not \"inner allocations\"\n+            if !self.static_alloc.contains(&alloc) {\n+                self.mark_static_initalized(alloc, mutable)?;\n+            }\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "bfae608ecbc1013054a797253fd3d372b9f0abf0", "filename": "src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/080d3e435519e2665502c8bae6c3168ae4232e33/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=080d3e435519e2665502c8bae6c3168ae4232e33", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.mark_static(vtable.alloc_id, false)?;\n+        self.memory.mark_static_initalized(vtable.alloc_id, false)?;\n \n         Ok(vtable)\n     }"}]}