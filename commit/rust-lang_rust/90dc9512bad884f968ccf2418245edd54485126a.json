{"sha": "90dc9512bad884f968ccf2418245edd54485126a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZGM5NTEyYmFkODg0Zjk2OGNjZjI0MTgyNDVlZGQ1NDQ4NTEyNmE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-10T22:53:21Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-17T00:47:59Z"}, "message": "std::str: Fix overflow problems in unsafe code\n\nSee issue #8742", "tree": {"sha": "49eed744f769d93d94f353104dd8b0d5caa4a460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49eed744f769d93d94f353104dd8b0d5caa4a460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90dc9512bad884f968ccf2418245edd54485126a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90dc9512bad884f968ccf2418245edd54485126a", "html_url": "https://github.com/rust-lang/rust/commit/90dc9512bad884f968ccf2418245edd54485126a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90dc9512bad884f968ccf2418245edd54485126a/comments", "author": null, "committer": null, "parents": [{"sha": "e34e2032e8ca028fb622b60ad4aa07f9e86bfe35", "url": "https://api.github.com/repos/rust-lang/rust/commits/e34e2032e8ca028fb622b60ad4aa07f9e86bfe35", "html_url": "https://github.com/rust-lang/rust/commit/e34e2032e8ca028fb622b60ad4aa07f9e86bfe35"}], "stats": {"total": 164, "additions": 59, "deletions": 105}, "files": [{"sha": "8c6fdffe4f644bacb680625d4bd32bc6a76f4829", "filename": "src/libstd/str.rs", "status": "modified", "additions": 59, "deletions": 105, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/90dc9512bad884f968ccf2418245edd54485126a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90dc9512bad884f968ccf2418245edd54485126a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=90dc9512bad884f968ccf2418245edd54485126a", "patch": "@@ -22,8 +22,7 @@ use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n-use num::Times;\n-use iter::{Iterator, FromIterator, Extendable};\n+use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Invert, DoubleEndedIterator, ExactSize};\n use libc;\n@@ -33,7 +32,6 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n-use unstable::raw::{Repr, Slice};\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n use default::Default;\n@@ -182,23 +180,15 @@ impl<'self, S: Str> StrVector for &'self [S] {\n     fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n+        // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n-        let mut s = with_capacity(len);\n+        let mut result = with_capacity(len);\n \n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                let mut buf = buf;\n-                for ss in self.iter() {\n-                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                        ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen as int);\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n+        for s in self.iter() {\n+            result.push_str(s.as_slice())\n         }\n-        s\n+        result\n     }\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n@@ -209,34 +199,21 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         if sep.is_empty() { return self.concat(); }\n \n         // this is wrong without the guarantee that `self` is non-empty\n+        // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n             + self.iter().map(|s| s.as_slice().len()).sum();\n-        let mut s = ~\"\";\n+        let mut result = with_capacity(len);\n         let mut first = true;\n \n-        s.reserve(len);\n-\n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                do sep.as_imm_buf |sepbuf, seplen| {\n-                    let mut buf = buf;\n-                    for ss in self.iter() {\n-                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                            if first {\n-                                first = false;\n-                            } else {\n-                                ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen as int);\n-                            }\n-                            ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen as int);\n-                        }\n-                    }\n-                }\n+        for s in self.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                result.push_str(sep);\n             }\n-            raw::set_len(&mut s, len);\n+            result.push_str(s.as_slice());\n         }\n-        s\n+        result\n     }\n }\n \n@@ -959,7 +936,6 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n-    use option::Some;\n     use cast;\n     use libc;\n     use ptr;\n@@ -1062,21 +1038,22 @@ pub mod raw {\n         }\n     }\n \n-    /// Appends a byte to a string. (Not UTF-8 safe).\n+    /// Appends a byte to a string.\n+    /// The caller must preserve the valid UTF-8 property.\n     #[inline]\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        let v: &mut ~[u8] = cast::transmute(s);\n-        v.push(b);\n+        as_owned_vec(s).push(b)\n     }\n \n-    /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n-    unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        let new_len = s.len() + bytes.len();\n-        s.reserve_at_least(new_len);\n-        for byte in bytes.iter() { push_byte(&mut *s, *byte); }\n+    /// Appends a vector of bytes to a string.\n+    /// The caller must preserve the valid UTF-8 property.\n+    #[inline]\n+    pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n+        vec::bytes::push_bytes(as_owned_vec(s), bytes);\n     }\n \n-    /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n+    /// Removes the last byte from a string and returns it.\n+    /// The caller must preserve the valid UTF-8 property.\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = s.len();\n         assert!((len > 0u));\n@@ -1085,7 +1062,8 @@ pub mod raw {\n         return b;\n     }\n \n-    /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n+    /// Removes the first byte from a string and returns it.\n+    /// The caller must preserve the valid UTF-8 property.\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = s.len();\n         assert!((len > 0u));\n@@ -1094,15 +1072,21 @@ pub mod raw {\n         return b;\n     }\n \n+    /// Access the str in its vector representation.\n+    /// The caller must preserve the valid UTF-8 property when modifying.\n+    #[inline]\n+    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n+        cast::transmute(s)\n+    }\n+\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n     /// modifying its buffers, so it is up to the caller to ensure that\n     /// the string is actually the specified size.\n     #[inline]\n     pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n-        let v: &mut ~[u8] = cast::transmute(s);\n-        vec::raw::set_len(v, new_len)\n+        vec::raw::set_len(as_owned_vec(s), new_len)\n     }\n \n     /// Sets the length of a string\n@@ -2053,22 +2037,11 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        do self.as_imm_buf |buf, len| {\n-            let mut ret = with_capacity(nn * len);\n-\n-            unsafe {\n-                do ret.as_mut_buf |rbuf, _len| {\n-                    let mut rbuf = rbuf;\n-\n-                    do nn.times {\n-                        ptr::copy_memory(rbuf, buf, len);\n-                        rbuf = rbuf.offset(len as int);\n-                    }\n-                }\n-                raw::set_len(&mut ret, nn * len);\n-            }\n-            ret\n+        let mut ret = with_capacity(nn * self.len());\n+        for _ in range(0, nn) {\n+            ret.push_str(*self);\n         }\n+        ret\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -2191,54 +2164,35 @@ impl OwnedStr for ~str {\n     /// Appends a string slice to the back of a string, without overallocating\n     #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n-        unsafe {\n-            let llen = self.len();\n-            let rlen = rhs.len();\n-            self.reserve(llen + rlen);\n-            do self.as_imm_buf |lbuf, _llen| {\n-                do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen as int);\n-                    let dst = cast::transmute_mut_unsafe(dst);\n-                    ptr::copy_memory(dst, rbuf, rlen);\n-                }\n-            }\n-            raw::set_len(self, llen + rlen);\n-        }\n+        let new_cap = self.len() + rhs.len();\n+        self.reserve(new_cap);\n+        self.push_str(rhs);\n     }\n \n     /// Appends a string slice to the back of a string\n     #[inline]\n     fn push_str(&mut self, rhs: &str) {\n         unsafe {\n-            let llen = self.len();\n-            let rlen = rhs.len();\n-            self.reserve_at_least(llen + rlen);\n-            do self.as_imm_buf |lbuf, _llen| {\n-                do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen as int);\n-                    let dst = cast::transmute_mut_unsafe(dst);\n-                    ptr::copy_memory(dst, rbuf, rlen);\n-                }\n-            }\n-            raw::set_len(self, llen + rlen);\n+            raw::push_bytes(self, rhs.as_bytes());\n         }\n     }\n \n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n         let cur_len = self.len();\n-        self.reserve_at_least(cur_len + 4); // may use up to 4 bytes\n-\n-        // Attempt to not use an intermediate buffer by just pushing bytes\n-        // directly onto this string.\n+        // may use up to 4 bytes.\n         unsafe {\n-            let v = self.repr();\n-            let len = c.encode_utf8(cast::transmute(Slice {\n-                data: ((&(*v).data) as *u8).offset(cur_len as int),\n-                len: 4,\n-            }));\n-            raw::set_len(self, cur_len + len);\n+            raw::as_owned_vec(self).reserve_additional(4);\n+\n+            // Attempt to not use an intermediate buffer by just pushing bytes\n+            // directly onto this string.\n+            let used = do self.as_mut_buf |buf, _| {\n+                do vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4) |slc| {\n+                    c.encode_utf8(slc)\n+                }\n+            };\n+            raw::set_len(self, cur_len + used);\n         }\n     }\n \n@@ -2298,8 +2252,7 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn reserve(&mut self, n: uint) {\n         unsafe {\n-            let v: &mut ~[u8] = cast::transmute(self);\n-            (*v).reserve(n);\n+            raw::as_owned_vec(self).reserve(n)\n         }\n     }\n \n@@ -2321,7 +2274,7 @@ impl OwnedStr for ~str {\n     /// * n - The number of bytes to reserve space for\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two(n))\n+        self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n))\n     }\n \n     /// Returns the number of single-byte characters the string can hold without\n@@ -2351,8 +2304,9 @@ impl OwnedStr for ~str {\n \n     #[inline]\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n-        let v: &mut ~[u8] = unsafe { cast::transmute(self) };\n-        v.as_mut_buf(f)\n+        unsafe {\n+            raw::as_owned_vec(self).as_mut_buf(f)\n+        }\n     }\n }\n "}]}