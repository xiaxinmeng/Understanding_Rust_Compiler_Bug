{"sha": "f996b6019bd2f388bd9994ea83f25487eb111560", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OTZiNjAxOWJkMmYzODhiZDk5OTRlYTgzZjI1NDg3ZWIxMTE1NjA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-30T10:14:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-30T10:14:18Z"}, "message": "Merge #2126\n\n2126: Move ids to hir_def crate r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4662b1c76bed5e830c1dae9ee5dbf47520f41e1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4662b1c76bed5e830c1dae9ee5dbf47520f41e1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f996b6019bd2f388bd9994ea83f25487eb111560", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJduWJ6CRBK7hj4Ov3rIwAAdHIIABVoDQG7g175yn/vpOehrXD8\nA3e+PLcmfUfkjR5cpJC3GBXEjyXYhcQQlLhELKidj6zql0oWuhw8swK9d9zy4ydV\ndRGhGIGNkdH6k0dbL6pOcZ+nLJVZC6vfNwDwiMcN9/T/1edq4MTnzj6LkJL+k2jt\n/2q4FutNR93tSN+6qfEqYa7TLu12mVwkNTkDKiY9pOw0RWhARn0+tQYs1DchzaMu\n+9XmaPa8t45YUKyXJrkLXfXqF9/Av7YDO3kiOdifdXcmdT9ohkzrDw/7Ez2L6eqA\n3q4ujMDgdghrCulRhGrbOAvAxPI6uto6lKY0njCJoYc23QUeKz7hLQ2WjK6WNMY=\n=fPdM\n-----END PGP SIGNATURE-----\n", "payload": "tree 4662b1c76bed5e830c1dae9ee5dbf47520f41e1e\nparent 8046f5b24a316a50e109fe484cde4c128293fa97\nparent c9cd6aa370667783292de3bc580e0503a409e453\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572430458 +0000\ncommitter GitHub <noreply@github.com> 1572430458 +0000\n\nMerge #2126\n\n2126: Move ids to hir_def crate r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f996b6019bd2f388bd9994ea83f25487eb111560", "html_url": "https://github.com/rust-lang/rust/commit/f996b6019bd2f388bd9994ea83f25487eb111560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f996b6019bd2f388bd9994ea83f25487eb111560/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8046f5b24a316a50e109fe484cde4c128293fa97", "url": "https://api.github.com/repos/rust-lang/rust/commits/8046f5b24a316a50e109fe484cde4c128293fa97", "html_url": "https://github.com/rust-lang/rust/commit/8046f5b24a316a50e109fe484cde4c128293fa97"}, {"sha": "c9cd6aa370667783292de3bc580e0503a409e453", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9cd6aa370667783292de3bc580e0503a409e453", "html_url": "https://github.com/rust-lang/rust/commit/c9cd6aa370667783292de3bc580e0503a409e453"}], "stats": {"total": 765, "additions": 402, "deletions": 363}, "files": [{"sha": "66ff1285a09231c0829f4d2d28fdab9339255620", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -1003,6 +1003,7 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n  \"ra_hir_expand 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -1013,6 +1014,18 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir_expand 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_hir_expand\"\n version = \"0.1.0\""}, {"sha": "5df371bc0f97ee682ae5cb050d438b178ec185b2", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -20,6 +20,7 @@ ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n "}, {"sha": "1a790b2f300287dea0a6a8dbecb9999d7e100703", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -5,6 +5,7 @@ pub(crate) mod docs;\n \n use std::sync::Arc;\n \n+use hir_def::{CrateModuleId, ModuleId};\n use ra_db::{CrateId, Edition, FileId};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n@@ -23,7 +24,7 @@ use crate::{\n         BOOL, CHAR, F32, F64, I128, I16, I32, I64, I8, ISIZE, SELF_TYPE, STR, U128, U16, U32, U64,\n         U8, USIZE,\n     },\n-    nameres::{CrateModuleId, ImportId, ModuleScope, Namespace},\n+    nameres::{ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{\n@@ -67,8 +68,7 @@ impl Crate {\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n         let module_id = db.crate_def_map(self).root();\n-        let module = Module { krate: self, module_id };\n-        Some(module)\n+        Some(Module::new(self, module_id))\n     }\n \n     pub fn edition(self, db: &impl DefDatabase) -> Edition {\n@@ -83,8 +83,7 @@ impl Crate {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n-    pub(crate) krate: Crate,\n-    pub(crate) module_id: CrateModuleId,\n+    pub(crate) id: ModuleId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -175,12 +174,16 @@ impl ModuleSource {\n }\n \n impl Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+        Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n+    }\n+\n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent = def_map[self.id.module_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.module_id {\n+            if *module_id == self.id.module_id {\n                 Some(name.clone())\n             } else {\n                 None\n@@ -200,29 +203,29 @@ impl Module {\n     }\n \n     /// Returns the crate this module is part of.\n-    pub fn krate(self, _db: &impl DefDatabase) -> Option<Crate> {\n-        Some(self.krate)\n+    pub fn krate(self) -> Crate {\n+        Crate { crate_id: self.id.krate }\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate);\n+        let def_map = db.crate_def_map(self.krate());\n         self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let child_id = def_map[self.module_id].children.get(name)?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let children = def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        let children = def_map[self.id.module_id]\n             .children\n             .iter()\n             .map(|(_, module_id)| self.with_module_id(*module_id))\n@@ -232,8 +235,8 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent_id = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent_id = def_map[self.id.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n@@ -249,11 +252,11 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n-        db.crate_def_map(self.krate)[self.module_id].scope.clone()\n+        db.crate_def_map(self.krate())[self.id.module_id].scope.clone()\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n+        db.crate_def_map(self.krate()).add_diagnostics(db, self.id.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -277,13 +280,13 @@ impl Module {\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate);\n-        Resolver::default().push_module_scope(def_map, self.module_id)\n+        let def_map = db.crate_def_map(self.krate());\n+        Resolver::default().push_module_scope(def_map, self.id.module_id)\n     }\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.krate);\n-        def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        def_map[self.id.module_id]\n             .scope\n             .entries()\n             .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n@@ -303,7 +306,7 @@ impl Module {\n     }\n \n     fn with_module_id(self, module_id: CrateModuleId) -> Module {\n-        Module { module_id, krate: self.krate }\n+        Module::new(self.krate(), module_id)\n     }\n }\n \n@@ -340,11 +343,11 @@ pub struct Struct {\n \n impl Struct {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -402,7 +405,7 @@ impl Union {\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n@@ -428,11 +431,11 @@ pub struct Enum {\n \n impl Enum {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -523,12 +526,14 @@ impl Adt {\n     }\n \n     pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            Adt::Struct(s) => s.module(db),\n-            Adt::Union(s) => s.module(db),\n-            Adt::Enum(e) => e.module(db),\n-        }\n-        .krate(db)\n+        Some(\n+            match self {\n+                Adt::Struct(s) => s.module(db),\n+                Adt::Union(s) => s.module(db),\n+                Adt::Enum(e) => e.module(db),\n+            }\n+            .krate(),\n+        )\n     }\n \n     pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n@@ -692,11 +697,11 @@ impl FnData {\n \n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl HirDatabase) -> Name {\n@@ -770,11 +775,11 @@ pub struct Const {\n \n impl Const {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -867,11 +872,11 @@ pub struct Static {\n \n impl Static {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -896,7 +901,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -998,11 +1003,11 @@ pub struct TypeAlias {\n \n impl TypeAlias {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     /// The containing impl block, if this is a method."}, {"sha": "5c7f61eefb46162b9c973d61fbd28d4ff2b55cfd", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -1,9 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n@@ -12,34 +9,21 @@ use crate::{\n     ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub struct Source<T> {\n-    pub file_id: HirFileId,\n-    pub ast: T,\n-}\n+pub use hir_def::Source;\n \n pub trait HasSource {\n     type Ast;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n }\n \n-impl<T> Source<T> {\n-    pub(crate) fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source { file_id: self.file_id, ast: f(self.ast) }\n-    }\n-    pub(crate) fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n-    }\n-}\n-\n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n /// definition and declaration.\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl_id = def_map[self.id.module_id].declaration;\n+        let file_id = def_map[self.id.module_id].definition;\n         let ast = ModuleSource::new(db, file_id, decl_id);\n         let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         Source { file_id, ast }\n@@ -51,8 +35,8 @@ impl Module {\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n     ) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl = def_map[self.id.module_id].declaration?;\n         let ast = decl.to_node(db);\n         Some(Source { file_id: decl.file_id(), ast })\n     }"}, {"sha": "8f6cb2da7d3cd7e89061e631b565e0e72dbc5289", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -2,8 +2,8 @@\n \n use std::sync::Arc;\n \n-use ra_db::{salsa, SourceDatabase};\n-use ra_syntax::{ast, SmolStr};\n+use ra_db::salsa;\n+use ra_syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -23,40 +23,12 @@ use crate::{\n     Static, Struct, StructField, Trait, TypeAlias,\n };\n \n+pub use hir_def::db::{InternDatabase, InternDatabaseStorage};\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n     ParseMacroQuery,\n };\n \n-/// We store all interned things in the single QueryGroup.\n-///\n-/// This is done mainly to allow both \"volatile\" `AstDatabase` and \"stable\"\n-/// `DefDatabase` to access macros, without adding hard dependencies between the\n-/// two.\n-#[salsa::query_group(InternDatabaseStorage)]\n-pub trait InternDatabase: SourceDatabase {\n-    #[salsa::interned]\n-    fn intern_function(&self, loc: ids::ItemLoc<ast::FnDef>) -> ids::FunctionId;\n-    #[salsa::interned]\n-    fn intern_struct(&self, loc: ids::ItemLoc<ast::StructDef>) -> ids::StructId;\n-    #[salsa::interned]\n-    fn intern_enum(&self, loc: ids::ItemLoc<ast::EnumDef>) -> ids::EnumId;\n-    #[salsa::interned]\n-    fn intern_const(&self, loc: ids::ItemLoc<ast::ConstDef>) -> ids::ConstId;\n-    #[salsa::interned]\n-    fn intern_static(&self, loc: ids::ItemLoc<ast::StaticDef>) -> ids::StaticId;\n-    #[salsa::interned]\n-    fn intern_trait(&self, loc: ids::ItemLoc<ast::TraitDef>) -> ids::TraitId;\n-    #[salsa::interned]\n-    fn intern_type_alias(&self, loc: ids::ItemLoc<ast::TypeAliasDef>) -> ids::TypeAliasId;\n-\n-    // Interned IDs for Chalk integration\n-    #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n-    #[salsa::interned]\n-    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n-}\n-\n // This database uses `AstDatabase` internally,\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n@@ -176,6 +148,12 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::traits::trait_solver_query)]\n     fn trait_solver(&self, krate: Crate) -> crate::ty::traits::TraitSolver;\n \n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+\n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n "}, {"sha": "93713bb1424fa5a44c7f6964fc2af30aa7178deb", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -195,7 +195,7 @@ impl Module {\n             .find_map(|krate| {\n                 let def_map = db.crate_def_map(krate);\n                 let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n-                Some(Module { krate, module_id })\n+                Some(Module::new(krate, module_id))\n             })\n     }\n }\n@@ -208,6 +208,6 @@ where\n     let module_src =\n         crate::ModuleSource::from_child_node(db, src.file_id.original_file(db), &src.ast.syntax());\n     let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n-    let ctx = LocationCtx::new(db, module, src.file_id);\n+    let ctx = LocationCtx::new(db, module.id, src.file_id);\n     Some(DEF::from_ast(ctx, &src.ast))\n }"}, {"sha": "fe083c0c65f68841224ab71a673f370e250819fa", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 3, "deletions": 164, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -5,16 +5,12 @@\n //! This module defines a bunch of ids we are using. The most important ones are\n //! probably `HirFileId` and `DefId`.\n \n-use std::hash::{Hash, Hasher};\n-\n use ra_db::salsa;\n-use ra_syntax::{ast, AstNode};\n \n-use crate::{\n-    db::{AstDatabase, InternDatabase},\n-    AstId, FileAstId, Module, Source,\n+pub use hir_def::{\n+    AstItemDef, ConstId, EnumId, FunctionId, ItemLoc, LocationCtx, StaticId, StructId, TraitId,\n+    TypeAliasId,\n };\n-\n pub use hir_expand::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind};\n \n macro_rules! impl_intern_key {\n@@ -30,163 +26,6 @@ macro_rules! impl_intern_key {\n     };\n }\n \n-#[derive(Debug)]\n-pub struct ItemLoc<N: AstNode> {\n-    pub(crate) module: Module,\n-    ast_id: AstId<N>,\n-}\n-\n-impl<N: AstNode> PartialEq for ItemLoc<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.ast_id == other.ast_id\n-    }\n-}\n-impl<N: AstNode> Eq for ItemLoc<N> {}\n-impl<N: AstNode> Hash for ItemLoc<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.module.hash(hasher);\n-        self.ast_id.hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> Clone for ItemLoc<N> {\n-    fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, ast_id: self.ast_id }\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-pub(crate) struct LocationCtx<DB> {\n-    db: DB,\n-    module: Module,\n-    file_id: HirFileId,\n-}\n-\n-impl<'a, DB> LocationCtx<&'a DB> {\n-    pub(crate) fn new(db: &'a DB, module: Module, file_id: HirFileId) -> LocationCtx<&'a DB> {\n-        LocationCtx { db, module, file_id }\n-    }\n-}\n-\n-impl<'a, DB: AstDatabase + InternDatabase> LocationCtx<&'a DB> {\n-    pub(crate) fn to_def<N, DEF>(self, ast: &N) -> DEF\n-    where\n-        N: AstNode,\n-        DEF: AstItemDef<N>,\n-    {\n-        DEF::from_ast(self, ast)\n-    }\n-}\n-\n-pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<N>) -> Self;\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<N>;\n-\n-    fn from_ast(ctx: LocationCtx<&(impl AstDatabase + InternDatabase)>, ast: &N) -> Self {\n-        let items = ctx.db.ast_id_map(ctx.file_id);\n-        let item_id = items.ast_id(ast);\n-        Self::from_ast_id(ctx, item_id)\n-    }\n-    fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n-        let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n-        Self::intern(ctx.db, loc)\n-    }\n-    fn source(self, db: &(impl AstDatabase + InternDatabase)) -> Source<N> {\n-        let loc = self.lookup_intern(db);\n-        let ast = loc.ast_id.to_node(db);\n-        Source { file_id: loc.ast_id.file_id(), ast }\n-    }\n-    fn module(self, db: &impl InternDatabase) -> Module {\n-        let loc = self.lookup_intern(db);\n-        loc.module\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FunctionId(salsa::InternId);\n-impl_intern_key!(FunctionId);\n-\n-impl AstItemDef<ast::FnDef> for FunctionId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n-        db.intern_function(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::FnDef> {\n-        db.lookup_intern_function(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(salsa::InternId);\n-impl_intern_key!(StructId);\n-impl AstItemDef<ast::StructDef> for StructId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_struct(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_struct(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EnumId(salsa::InternId);\n-impl_intern_key!(EnumId);\n-impl AstItemDef<ast::EnumDef> for EnumId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::EnumDef>) -> Self {\n-        db.intern_enum(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::EnumDef> {\n-        db.lookup_intern_enum(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstId(salsa::InternId);\n-impl_intern_key!(ConstId);\n-impl AstItemDef<ast::ConstDef> for ConstId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ConstDef>) -> Self {\n-        db.intern_const(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ConstDef> {\n-        db.lookup_intern_const(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StaticId(salsa::InternId);\n-impl_intern_key!(StaticId);\n-impl AstItemDef<ast::StaticDef> for StaticId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StaticDef>) -> Self {\n-        db.intern_static(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StaticDef> {\n-        db.lookup_intern_static(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TraitId(salsa::InternId);\n-impl_intern_key!(TraitId);\n-impl AstItemDef<ast::TraitDef> for TraitId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TraitDef>) -> Self {\n-        db.intern_trait(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TraitDef> {\n-        db.lookup_intern_trait(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeAliasId(salsa::InternId);\n-impl_intern_key!(TypeAliasId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TypeAliasDef>) -> Self {\n-        db.intern_type_alias(loc)\n-    }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TypeAliasDef> {\n-        db.lookup_intern_type_alias(self)\n-    }\n-}\n-\n /// This exists just for Chalk, because Chalk just has a single `StructId` where\n /// we have different kinds of ADTs, primitive types and special type\n /// constructors like tuples and function pointers."}, {"sha": "06f21fc33eee86edb1a0e08a7f7aa019729feaa1", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -129,7 +129,7 @@ impl ImplData {\n     ) -> Self {\n         let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let ctx = LocationCtx::new(db, module, file_id);\n+        let ctx = LocationCtx::new(db, module.id, file_id);\n         let negative = node.is_negative();\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n@@ -182,7 +182,7 @@ impl ModuleImplBlocks {\n     ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n         let mut source_map = ImplSourceMap::default();\n         let crate_graph = db.crate_graph();\n-        let cfg_options = crate_graph.cfg_options(module.krate.crate_id());\n+        let cfg_options = crate_graph.cfg_options(module.id.krate);\n \n         let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n         (Arc::new(result), Arc::new(source_map))"}, {"sha": "e1780ed388f0b7f5a1739995055ac533924b1dca", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -22,14 +22,14 @@ pub enum LangItemTarget {\n \n impl LangItemTarget {\n     pub(crate) fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            LangItemTarget::Enum(e) => e.module(db).krate(db),\n-            LangItemTarget::Function(f) => f.module(db).krate(db),\n-            LangItemTarget::ImplBlock(i) => i.module().krate(db),\n-            LangItemTarget::Static(s) => s.module(db).krate(db),\n-            LangItemTarget::Struct(s) => s.module(db).krate(db),\n-            LangItemTarget::Trait(t) => t.module(db).krate(db),\n-        }\n+        Some(match self {\n+            LangItemTarget::Enum(e) => e.module(db).krate(),\n+            LangItemTarget::Function(f) => f.module(db).krate(),\n+            LangItemTarget::ImplBlock(i) => i.module().krate(),\n+            LangItemTarget::Static(s) => s.module(db).krate(),\n+            LangItemTarget::Struct(s) => s.module(db).krate(),\n+            LangItemTarget::Trait(t) => t.module(db).krate(),\n+        })\n     }\n }\n "}, {"sha": "b325979f5b6d785b645b9a71eca6096bd9a2e9e9", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -56,8 +56,9 @@ mod tests;\n \n use std::sync::Arc;\n \n+use hir_def::CrateModuleId;\n use once_cell::sync::Lazy;\n-use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_arena::Arena;\n use ra_db::{Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n@@ -115,13 +116,8 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n-/// An ID of a module, **local** to a specific crate\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n-\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleData {\n+pub struct ModuleData {\n     pub(crate) parent: Option<CrateModuleId>,\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n@@ -335,7 +331,7 @@ impl CrateDefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+                    PerNs::types(Module::new(self.krate, self.root).into())\n                 } else {\n                     match krate.root_module(db) {\n                         Some(module) => {\n@@ -346,12 +342,8 @@ impl CrateDefMap {\n                     }\n                 }\n             }\n-            PathKind::Crate => {\n-                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n-            }\n+            PathKind::Crate => PerNs::types(Module::new(self.krate, self.root).into()),\n+            PathKind::Self_ => PerNs::types(Module::new(self.krate, original_module).into()),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -377,7 +369,7 @@ impl CrateDefMap {\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                    PerNs::types(Module::new(self.krate, p).into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -419,12 +411,12 @@ impl CrateDefMap {\n \n             curr_per_ns = match curr {\n                 ModuleDef::Module(module) => {\n-                    if module.krate != self.krate {\n+                    if module.krate() != self.krate {\n                         let path =\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        let defp_map = db.crate_def_map(module.krate());\n+                        let (def, s) = defp_map.resolve_path(db, module.id.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -433,7 +425,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n+                    match self[module.id.module_id].scope.get(&segment.name) {\n                         Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -511,14 +503,14 @@ impl CrateDefMap {\n     fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n-            let def_map = if prelude.krate == self.krate {\n+            let def_map = if prelude.krate() == self.krate {\n                 self\n             } else {\n                 // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n+                keep = db.crate_def_map(prelude.krate());\n                 &keep\n             };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.id.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "a94a0554c84c0738fa7191ce0422539f971388d1", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -212,7 +212,7 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n+            self.import_all_macros_exported(current_module_id, m.krate());\n         }\n     }\n \n@@ -289,11 +289,11 @@ where\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate != self.def_map.krate {\n+                    } else if m.krate() != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate);\n-                        let scope = &item_map[m.module_id].scope;\n+                        let item_map = self.db.crate_def_map(m.krate());\n+                        let scope = &item_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -307,7 +307,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.module_id].scope;\n+                        let scope = &self.def_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -319,7 +319,7 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.module_id)\n+                            .entry(m.id.module_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n@@ -523,9 +523,10 @@ where\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != self.def_collector.def_map.krate {\n+            if prelude_module.krate() != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector\n+                    .import_all_macros_exported(self.module_id, prelude_module.krate());\n             }\n         }\n \n@@ -631,18 +632,16 @@ where\n         modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n-            def: PerNs::types(\n-                Module { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n-            ),\n+            def: PerNs::types(Module::new(self.def_collector.def_map.krate, res).into()),\n             import: None,\n         };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n-        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n+        let module = Module::new(self.def_collector.def_map.krate, self.module_id);\n+        let ctx = LocationCtx::new(self.def_collector.db, module.id, self.file_id);\n \n         macro_rules! def {\n             ($kind:ident, $ast_id:ident) => {"}, {"sha": "8b62694075df07f7d83e426a28a7ef61bbbf326b", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -1,6 +1,7 @@\n //! Name resolution.\n use std::sync::Arc;\n \n+use hir_def::CrateModuleId;\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -13,7 +14,7 @@ use crate::{\n     generics::GenericParams,\n     impl_block::ImplBlock,\n     name::{Name, SELF_PARAM, SELF_TYPE},\n-    nameres::{CrateDefMap, CrateModuleId, PerNs},\n+    nameres::{CrateDefMap, PerNs},\n     path::{Path, PathKind},\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n@@ -330,8 +331,8 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    traits.extend(prelude_def_map[prelude.id.module_id].scope.traits());\n                 }\n                 traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n@@ -444,10 +445,12 @@ impl Scope {\n                     f(name.clone(), ScopeDef::ModuleDef(*def));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), res.def.into());\n-                    });\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    prelude_def_map[prelude.id.module_id].scope.entries().for_each(\n+                        |(name, res)| {\n+                            f(name.clone(), res.def.into());\n+                        },\n+                    );\n                 }\n             }\n             Scope::GenericParams(gp) => {"}, {"sha": "730c3322647e1ef6517fffbe8507c38fb3a6f5eb", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -64,7 +64,7 @@ fn def_with_body_from_child_node(\n ) -> Option<DefWithBody> {\n     let src = crate::ModuleSource::from_child_node(db, file_id, node);\n     let module = Module::from_definition(db, crate::Source { file_id: file_id.into(), ast: src })?;\n-    let ctx = LocationCtx::new(db, module, file_id.into());\n+    let ctx = LocationCtx::new(db, module.id, file_id.into());\n \n     node.ancestors().find_map(|node| {\n         if let Some(def) = ast::FnDef::cast(node.clone()) {"}, {"sha": "22f1880493f9f996b19d7c0476b1b9b80cfa4d07", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -27,7 +27,7 @@ impl TraitData {\n         let src = tr.source(db);\n         let name = src.ast.name().map(|n| n.as_name());\n         let module = tr.module(db);\n-        let ctx = LocationCtx::new(db, module, src.file_id);\n+        let ctx = LocationCtx::new(db, module.id, src.file_id);\n         let auto = src.ast.is_auto();\n         let items = if let Some(item_list) = src.ast.item_list() {\n             item_list"}, {"sha": "50583a1429e6781551fc2eef66e1337cebf317ff", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -5,13 +5,13 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n+use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n use crate::{\n     db::HirDatabase,\n     impl_block::{ImplBlock, ImplId},\n-    nameres::CrateModuleId,\n     resolve::Resolver,\n     ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n     ty::{Ty, TypeCtor},\n@@ -50,7 +50,7 @@ impl CrateImplBlocks {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -62,7 +62,7 @@ impl CrateImplBlocks {\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -71,7 +71,7 @@ impl CrateImplBlocks {\n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -90,14 +90,14 @@ impl CrateImplBlocks {\n                     self.impls_by_trait\n                         .entry(tr.trait_)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             }\n         }"}, {"sha": "ab66515beecffa76fe773009d0f1240a689b2d40", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -162,11 +162,11 @@ impl ToChalk for Trait {\n     type Chalk = chalk_ir::TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        self.id.into()\n+        chalk_ir::TraitId(id_to_chalk(self.id))\n     }\n \n     fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n-        Trait { id: trait_id.into() }\n+        Trait { id: id_from_chalk(trait_id.0) }\n     }\n }\n \n@@ -198,11 +198,11 @@ impl ToChalk for TypeAlias {\n     type Chalk = chalk_ir::TypeId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n-        self.id.into()\n+        chalk_ir::TypeId(id_to_chalk(self.id))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, impl_id: chalk_ir::TypeId) -> TypeAlias {\n-        TypeAlias { id: impl_id.into() }\n+    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAlias {\n+        TypeAlias { id: id_from_chalk(type_alias_id.0) }\n     }\n }\n \n@@ -537,7 +537,7 @@ pub(crate) fn trait_datum_query(\n     let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate(db) != Some(krate),\n+        upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n         // FIXME set these flags correctly\n         marker: false,\n@@ -625,7 +625,7 @@ fn impl_block_datum(\n         .target_trait_ref(db)\n         .expect(\"FIXME handle unresolved impl block trait ref\")\n         .subst(&bound_vars);\n-    let impl_type = if impl_block.module().krate(db) == Some(krate) {\n+    let impl_type = if impl_block.module().krate() == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External\n@@ -775,30 +775,6 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::TraitId> for crate::ids::TraitId {\n-    fn from(trait_id: chalk_ir::TraitId) -> Self {\n-        id_from_chalk(trait_id.0)\n-    }\n-}\n-\n-impl From<crate::ids::TraitId> for chalk_ir::TraitId {\n-    fn from(trait_id: crate::ids::TraitId) -> Self {\n-        chalk_ir::TraitId(id_to_chalk(trait_id))\n-    }\n-}\n-\n-impl From<chalk_ir::TypeId> for crate::ids::TypeAliasId {\n-    fn from(type_id: chalk_ir::TypeId) -> Self {\n-        id_from_chalk(type_id.0)\n-    }\n-}\n-\n-impl From<crate::ids::TypeAliasId> for chalk_ir::TypeId {\n-    fn from(type_id: crate::ids::TypeAliasId) -> Self {\n-        chalk_ir::TypeId(id_to_chalk(type_id))\n-    }\n-}\n-\n impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)"}, {"sha": "75e93f2547bbc73b7ca5832bc832cca3e33a77f8", "filename": "crates/ra_hir_def/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_prof = { path = \"../ra_prof\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }"}, {"sha": "f6f976c860a0a8f255ae7980712616e08e212457", "filename": "crates/ra_hir_def/src/db.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -0,0 +1,22 @@\n+//! Defines database & queries for name resolution.\n+\n+use ra_db::{salsa, SourceDatabase};\n+use ra_syntax::ast;\n+\n+#[salsa::query_group(InternDatabaseStorage)]\n+pub trait InternDatabase: SourceDatabase {\n+    #[salsa::interned]\n+    fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    #[salsa::interned]\n+    fn intern_struct(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::StructId;\n+    #[salsa::interned]\n+    fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n+    #[salsa::interned]\n+    fn intern_const(&self, loc: crate::ItemLoc<ast::ConstDef>) -> crate::ConstId;\n+    #[salsa::interned]\n+    fn intern_static(&self, loc: crate::ItemLoc<ast::StaticDef>) -> crate::StaticId;\n+    #[salsa::interned]\n+    fn intern_trait(&self, loc: crate::ItemLoc<ast::TraitDef>) -> crate::TraitId;\n+    #[salsa::interned]\n+    fn intern_type_alias(&self, loc: crate::ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+}"}, {"sha": "4d6b9db033f9bac20bb53d5c8dcbb32084f50274", "filename": "crates/ra_hir_def/src/lib.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -0,0 +1,216 @@\n+//! `hir_def` crate contains everything between macro expansion and type\n+//! inference.\n+//!\n+//! It defines various items (structs, enums, traits) which comprises Rust code,\n+//! as well as an algorithm for resolving paths to such entities.\n+//!\n+//! Note that `hir_def` is a work in progress, so not all of the above is\n+//! actually true.\n+\n+pub mod db;\n+\n+use std::hash::{Hash, Hasher};\n+\n+use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId};\n+use ra_arena::{impl_arena_id, RawId};\n+use ra_db::{salsa, CrateId};\n+use ra_syntax::{ast, AstNode, SyntaxNode};\n+\n+use crate::db::InternDatabase;\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+impl<T> Source<T> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+    pub fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n+        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ModuleId {\n+    pub krate: CrateId,\n+    pub module_id: CrateModuleId,\n+}\n+\n+/// An ID of a module, **local** to a specific crate\n+// FIXME: rename to `LocalModuleId`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct CrateModuleId(RawId);\n+impl_arena_id!(CrateModuleId);\n+\n+macro_rules! impl_intern_key {\n+    ($name:ident) => {\n+        impl salsa::InternKey for $name {\n+            fn from_intern_id(v: salsa::InternId) -> Self {\n+                $name(v)\n+            }\n+            fn as_intern_id(&self) -> salsa::InternId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemLoc<N: AstNode> {\n+    pub(crate) module: ModuleId,\n+    ast_id: AstId<N>,\n+}\n+\n+impl<N: AstNode> PartialEq for ItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.module == other.module && self.ast_id == other.ast_id\n+    }\n+}\n+impl<N: AstNode> Eq for ItemLoc<N> {}\n+impl<N: AstNode> Hash for ItemLoc<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.module.hash(hasher);\n+        self.ast_id.hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> ItemLoc<N> {\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct LocationCtx<DB> {\n+    db: DB,\n+    module: ModuleId,\n+    file_id: HirFileId,\n+}\n+\n+impl<'a, DB> LocationCtx<&'a DB> {\n+    pub fn new(db: &'a DB, module: ModuleId, file_id: HirFileId) -> LocationCtx<&'a DB> {\n+        LocationCtx { db, module, file_id }\n+    }\n+}\n+\n+impl<'a, DB: AstDatabase + InternDatabase> LocationCtx<&'a DB> {\n+    pub fn to_def<N, DEF>(self, ast: &N) -> DEF\n+    where\n+        N: AstNode,\n+        DEF: AstItemDef<N>,\n+    {\n+        DEF::from_ast(self, ast)\n+    }\n+}\n+\n+pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<N>) -> Self;\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<N>;\n+\n+    fn from_ast(ctx: LocationCtx<&(impl AstDatabase + InternDatabase)>, ast: &N) -> Self {\n+        let items = ctx.db.ast_id_map(ctx.file_id);\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n+    }\n+    fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n+        Self::intern(ctx.db, loc)\n+    }\n+    fn source(self, db: &(impl AstDatabase + InternDatabase)) -> Source<N> {\n+        let loc = self.lookup_intern(db);\n+        let ast = loc.ast_id.to_node(db);\n+        Source { file_id: loc.ast_id.file_id(), ast }\n+    }\n+    fn module(self, db: &impl InternDatabase) -> ModuleId {\n+        let loc = self.lookup_intern(db);\n+        loc.module\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FunctionId(salsa::InternId);\n+impl_intern_key!(FunctionId);\n+\n+impl AstItemDef<ast::FnDef> for FunctionId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n+        db.intern_function(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::FnDef> {\n+        db.lookup_intern_function(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StructId(salsa::InternId);\n+impl_intern_key!(StructId);\n+impl AstItemDef<ast::StructDef> for StructId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n+        db.intern_struct(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n+        db.lookup_intern_struct(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumId(salsa::InternId);\n+impl_intern_key!(EnumId);\n+impl AstItemDef<ast::EnumDef> for EnumId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::EnumDef>) -> Self {\n+        db.intern_enum(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::EnumDef> {\n+        db.lookup_intern_enum(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ConstId(salsa::InternId);\n+impl_intern_key!(ConstId);\n+impl AstItemDef<ast::ConstDef> for ConstId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ConstDef>) -> Self {\n+        db.intern_const(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ConstDef> {\n+        db.lookup_intern_const(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StaticId(salsa::InternId);\n+impl_intern_key!(StaticId);\n+impl AstItemDef<ast::StaticDef> for StaticId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StaticDef>) -> Self {\n+        db.intern_static(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StaticDef> {\n+        db.lookup_intern_static(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TraitId(salsa::InternId);\n+impl_intern_key!(TraitId);\n+impl AstItemDef<ast::TraitDef> for TraitId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TraitDef>) -> Self {\n+        db.intern_trait(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TraitDef> {\n+        db.lookup_intern_trait(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeAliasId(salsa::InternId);\n+impl_intern_key!(TypeAliasId);\n+impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TypeAliasDef>) -> Self {\n+        db.intern_type_alias(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TypeAliasDef> {\n+        db.lookup_intern_type_alias(self)\n+    }\n+}"}, {"sha": "956d8ce49c44c6974bad0c7c0ef372700144f58c", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -50,7 +50,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            let krate = ctx.module.and_then(|m| m.krate(ctx.db));\n+            let krate = ctx.module.map(|m| m.krate());\n             if let Some(krate) = krate {\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     match item {"}, {"sha": "b899ed3a5f78f49b4224061f3fdbbfdbb8a232dc", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -51,7 +51,7 @@ fn impls_for_def(\n         }\n     };\n \n-    let krate = module.krate(db)?;\n+    let krate = module.krate();\n     let impls = db.impls_in_crate(krate);\n \n     Some(\n@@ -72,7 +72,7 @@ fn impls_for_trait(\n     let src = hir::Source { file_id: position.file_id.into(), ast: node.clone() };\n     let tr = hir::Trait::from_source(db, src)?;\n \n-    let krate = module.krate(db)?;\n+    let krate = module.krate();\n     let impls = db.impls_in_crate(krate);\n \n     Some("}, {"sha": "4c57566e2af930b469224082681caab424c2d7b9", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -27,10 +27,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n             Some(it) => it,\n             None => return Vec::new(),\n         };\n-    let krate = match module.krate(db) {\n-        Some(it) => it,\n-        None => return Vec::new(),\n-    };\n+    let krate = module.krate();\n     vec![krate.crate_id()]\n }\n "}, {"sha": "dbd1af597693aabc70ced21bcfce8b3bb2055568", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b6019bd2f388bd9994ea83f25487eb111560/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=f996b6019bd2f388bd9994ea83f25487eb111560", "patch": "@@ -120,7 +120,7 @@ impl NameDefinition {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = self.container.krate(db).unwrap();\n+                let krate = self.container.krate();\n                 let crate_graph = db.crate_graph();\n                 for crate_id in crate_graph.iter() {\n                     let mut crate_deps = crate_graph.dependencies(crate_id);"}]}