{"sha": "ffa187db252a7ee8765025f95d2cae18859258be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYTE4N2RiMjUyYTdlZTg3NjUwMjVmOTVkMmNhZTE4ODU5MjU4YmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T15:49:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T15:49:28Z"}, "message": "adjust auto_serialize to generate fns named serialize_T()\n\nWe used to generate a module T with a serialize() and deserialize() fn,\nbut this was suboptimal for a number of reasons:\n\n- it required moving serialization into core so that uint etc worked\n- it was harder to override the serialization behavior locally\n  (this is now trivial)", "tree": {"sha": "7be54115a961c0681b80f2c36ee3fff791a2fd28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be54115a961c0681b80f2c36ee3fff791a2fd28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffa187db252a7ee8765025f95d2cae18859258be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa187db252a7ee8765025f95d2cae18859258be", "html_url": "https://github.com/rust-lang/rust/commit/ffa187db252a7ee8765025f95d2cae18859258be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffa187db252a7ee8765025f95d2cae18859258be/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6f2594319266c73f9b5a6c69dd482d6fda8dd12", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f2594319266c73f9b5a6c69dd482d6fda8dd12", "html_url": "https://github.com/rust-lang/rust/commit/c6f2594319266c73f9b5a6c69dd482d6fda8dd12"}], "stats": {"total": 443, "additions": 207, "deletions": 236}, "files": [{"sha": "c28ad0a0282a5623cc2ac4fdeb0a619a85400284", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -31,7 +31,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n-export libc, os, io, run, rand, sys, unsafe, logging, serialization;\n+export libc, os, io, run, rand, sys, unsafe, logging;\n export comm, task, future;\n export extfmt;\n export tuple;\n@@ -88,7 +88,6 @@ mod cmath;\n mod sys;\n mod unsafe;\n mod logging;\n-mod serialization;\n \n // Concurrency\n mod comm;"}, {"sha": "187be90c4f55518ee75f20c910953540d6989622", "filename": "src/libcore/serialization.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c6f2594319266c73f9b5a6c69dd482d6fda8dd12/src%2Flibcore%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f2594319266c73f9b5a6c69dd482d6fda8dd12/src%2Flibcore%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fserialization.rs?ref=c6f2594319266c73f9b5a6c69dd482d6fda8dd12", "patch": "@@ -1,116 +0,0 @@\n-export serializer;\n-export serializer_helpers;\n-export deserializer;\n-export deserializer_helpers;\n-\n-/*\n-Core serialization interfaces.\n-*/\n-\n-iface serializer {\n-    // Primitive types:\n-    fn emit_nil();\n-    fn emit_uint(v: uint);\n-    fn emit_u64(v: u64);\n-    fn emit_u32(v: u32);\n-    fn emit_u16(v: u16);\n-    fn emit_u8(v: u8);\n-    fn emit_int(v: int);\n-    fn emit_i64(v: i64);\n-    fn emit_i32(v: i32);\n-    fn emit_i16(v: i16);\n-    fn emit_i8(v: i8);\n-    fn emit_bool(v: bool);\n-    fn emit_float(v: float);\n-    fn emit_f64(v: f64);\n-    fn emit_f32(v: f32);\n-    fn emit_str(v: str);\n-\n-    // Compound types:\n-    fn emit_enum(name: str, f: fn());\n-    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(idx: uint, f: fn());\n-    fn emit_vec(len: uint, f: fn());\n-    fn emit_vec_elt(idx: uint, f: fn());\n-    fn emit_box(f: fn());\n-    fn emit_uniq(f: fn());\n-    fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n-    fn emit_tup(sz: uint, f: fn());\n-    fn emit_tup_elt(idx: uint, f: fn());\n-}\n-\n-iface deserializer {\n-    // Primitive types:\n-    fn read_nil() -> ();\n-\n-    fn read_uint() -> uint;\n-    fn read_u64() -> u64;\n-    fn read_u32() -> u32;\n-    fn read_u16() -> u16;\n-    fn read_u8() -> u8;\n-\n-    fn read_int() -> int;\n-    fn read_i64() -> i64;\n-    fn read_i32() -> i32;\n-    fn read_i16() -> i16;\n-    fn read_i8() -> i8;\n-\n-\n-    fn read_bool() -> bool;\n-\n-    fn read_str() -> str;\n-\n-    fn read_f64() -> f64;\n-    fn read_f32() -> f32;\n-    fn read_float() -> float;\n-\n-    // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T:copy>(f: fn() -> T) -> T;\n-    fn read_uniq<T:copy>(f: fn() -> T) -> T;\n-    fn read_rec<T:copy>(f: fn() -> T) -> T;\n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n-    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// These should eventually be coded as traits.\n-\n-fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n-    s.emit_vec(vec::len(v)) {||\n-        vec::iteri(v) {|i,e|\n-            s.emit_vec_elt(i) {||\n-                f(e)\n-            }\n-        }\n-    }\n-}\n-\n-fn read_to_vec<D: deserializer, T>(d: D, f: fn() -> T) -> [T] {\n-    d.read_vec {|len|\n-        vec::from_fn(len) {|i|\n-            d.read_vec_elt(i) {|| f() }\n-        }\n-    }\n-}\n-\n-impl serializer_helpers<S: serializer> for S {\n-    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n-        emit_from_vec(self, v, f)\n-    }\n-}\n-\n-impl deserializer_helpers<D: deserializer> for D {\n-    fn read_to_vec<T>(f: fn() -> T) -> [T] {\n-        read_to_vec(self, f)\n-    }\n-}\n-"}, {"sha": "88230bea09401f6bff25101e3670740982fb2ac2", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -192,14 +192,6 @@ fn compl(i: uint) -> uint {\n     max_value ^ i\n }\n \n-fn serialize<S: serialization::serializer>(s: S, v: uint) {\n-    s.emit_uint(v);\n-}\n-\n-fn deserialize<D: serialization::deserializer>(d: D) -> uint {\n-    d.read_uint()\n-}\n-\n #[cfg(test)]\n mod tests {\n "}, {"sha": "2e08b51be16bc7c9edb7f0bedc0db5102584fdb6", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -293,7 +293,7 @@ enum ebml_serializer_tag {\n     es_label // Used only when debugging\n }\n \n-impl serializer of core::serialization::serializer for ebml::writer {\n+impl serializer of serialization::serializer for ebml::writer {\n     fn emit_nil() {}\n \n     // used internally to emit things like the vector length and so on\n@@ -371,7 +371,7 @@ fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n     {mutable parent: d, mutable pos: d.start}\n }\n \n-impl deserializer of core::serialization::deserializer for ebml_deserializer {\n+impl deserializer of serialization::deserializer for ebml_deserializer {\n     fn _check_label(lbl: str) {\n         if self.pos < self.parent.end {\n             let {tag: r_tag, doc: r_doc} ="}, {"sha": "64208c0af48e2f30fb51e2d173a9178add18cd03", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 118, "deletions": 8, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -1,12 +1,122 @@\n-#[doc = \"Support code for serialization.\n-\n-Deprecated in favor of core::serialization.\"];\n+#[doc = \"Support code for serialization.\"];\n \n use core;\n-import list::list;\n-import ebml::writer;\n \n-import core::serialization::{serializer,deserializer};\n+/*\n+Core serialization interfaces.\n+*/\n+\n+iface serializer {\n+    // Primitive types:\n+    fn emit_nil();\n+    fn emit_uint(v: uint);\n+    fn emit_u64(v: u64);\n+    fn emit_u32(v: u32);\n+    fn emit_u16(v: u16);\n+    fn emit_u8(v: u8);\n+    fn emit_int(v: int);\n+    fn emit_i64(v: i64);\n+    fn emit_i32(v: i32);\n+    fn emit_i16(v: i16);\n+    fn emit_i8(v: i8);\n+    fn emit_bool(v: bool);\n+    fn emit_float(v: float);\n+    fn emit_f64(v: f64);\n+    fn emit_f32(v: f32);\n+    fn emit_str(v: str);\n+\n+    // Compound types:\n+    fn emit_enum(name: str, f: fn());\n+    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(idx: uint, f: fn());\n+    fn emit_vec(len: uint, f: fn());\n+    fn emit_vec_elt(idx: uint, f: fn());\n+    fn emit_box(f: fn());\n+    fn emit_uniq(f: fn());\n+    fn emit_rec(f: fn());\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n+    fn emit_tup(sz: uint, f: fn());\n+    fn emit_tup_elt(idx: uint, f: fn());\n+}\n+\n+iface deserializer {\n+    // Primitive types:\n+    fn read_nil() -> ();\n+\n+    fn read_uint() -> uint;\n+    fn read_u64() -> u64;\n+    fn read_u32() -> u32;\n+    fn read_u16() -> u16;\n+    fn read_u8() -> u8;\n+\n+    fn read_int() -> int;\n+    fn read_i64() -> i64;\n+    fn read_i32() -> i32;\n+    fn read_i16() -> i16;\n+    fn read_i8() -> i8;\n+\n+\n+    fn read_bool() -> bool;\n+\n+    fn read_str() -> str;\n+\n+    fn read_f64() -> f64;\n+    fn read_f32() -> f32;\n+    fn read_float() -> float;\n+\n+    // Compound types:\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_box<T:copy>(f: fn() -> T) -> T;\n+    fn read_uniq<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n+    s.emit_vec(vec::len(v)) {||\n+        vec::iteri(v) {|i,e|\n+            s.emit_vec_elt(i) {||\n+                f(e)\n+            }\n+        }\n+    }\n+}\n+\n+fn read_to_vec<D: deserializer, T>(d: D, f: fn() -> T) -> [T] {\n+    d.read_vec {|len|\n+        vec::from_fn(len) {|i|\n+            d.read_vec_elt(i) {|| f() }\n+        }\n+    }\n+}\n+\n+impl serializer_helpers<S: serializer> for S {\n+    fn emit_from_vec<T>(v: [T], f: fn(T)) {\n+        emit_from_vec(self, v, f)\n+    }\n+}\n+\n+impl deserializer_helpers<D: deserializer> for D {\n+    fn read_to_vec<T>(f: fn() -> T) -> [T] {\n+        read_to_vec(self, f)\n+    }\n+}\n+\n+fn serialize_uint<S: serializer>(s: S, v: uint) {\n+    s.emit_uint(v);\n+}\n \n-export serializer;\n-export deserializer;\n+fn deserialize_uint<D: deserializer>(d: D) -> uint {\n+    d.read_uint()\n+}"}, {"sha": "aa3fd0766273944739b6f63629289dcbb51e9610", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -9,10 +9,10 @@ import std::ebml::writer;\n import std::ebml::serializer;\n import std::ebml::deserializer;\n import std::map::hashmap;\n-import serialization::serializer;\n-import serialization::deserializer;\n-import serialization::serializer_helpers;\n-import serialization::deserializer_helpers;\n+import std::serialization::serializer;\n+import std::serialization::deserializer;\n+import std::serialization::serializer_helpers;\n+import std::serialization::deserializer_helpers;\n import std::smallintmap::map;\n import middle::trans::common::maps;\n import middle::{ty, typeck, last_use, ast_map};\n@@ -295,13 +295,13 @@ impl of tr for span {\n     }\n }\n \n-impl serializer_helpers<S: serialization::serializer> for S {\n+impl serializer_helpers<S: serializer> for S {\n     fn emit_def_id(did: ast::def_id) {\n         astencode_gen::serialize_syntax_ast_def_id(self, did)\n     }\n }\n \n-impl deserializer_helpers<D: serialization::deserializer> for D {\n+impl deserializer_helpers<D: deserializer> for D {\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n         let did = astencode_gen::deserialize_syntax_ast_def_id(self);\n         did.tr(xcx)"}, {"sha": "698b962eba7d40729d78ec1f934e289045722baa", "filename": "src/rustc/syntax/ext/auto_serialize.rs", "status": "modified", "additions": 64, "deletions": 79, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -9,66 +9,57 @@ For example, a type like:\n \n     type node_id = uint;\n \n-would generate a companion module like:\n-\n-    mod node_id {\n-        use std;\n-        import std::serialization::serializer;\n-        import std::serialization::deserializer;\n-        fn serialize<S: serializer>(s: S, v: node_id) {\n-             s.emit_uint(v);\n-        }\n-        fn deserializer<D: deserializer>(d: D) -> node_id {\n-             d.read_uint()\n-        }\n+would generate two functions like:\n+\n+    fn serialize_node_id<S: serializer>(s: S, v: node_id) {\n+        s.emit_uint(v);\n+    }\n+    fn deserialize_node_id<D: deserializer>(d: D) -> node_id {\n+        d.read_uint()\n     }\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n     type spanned<T> = {node: T, span: span};\n \n-would yield a helper module like:\n-\n-    mod spanned {\n-        use std;\n-        import std::serialization::serializer;\n-        import std::serialization::deserializer;\n-        fn serialize<S: serializer,T>(s: S, t: fn(T), v: spanned<T>) {\n-             s.emit_rec(2u) {||\n-                 s.emit_rec_field(\"node\", 0u) {||\n-                     t(s.node);\n-                 };\n-                 s.emit_rec_field(\"span\", 1u) {||\n-                     span::serialize(s, s.span);\n-                 };\n-             }\n-        }\n-        fn deserializer<D: deserializer>(d: D, t: fn() -> T) -> node_id {\n-             d.read_rec(2u) {||\n-                 {node: d.read_rec_field(\"node\", 0u, t),\n-                  span: d.read_rec_field(\"span\", 1u) {||span::deserialize(d)}}\n-             }\n-        }\n+would yield functions like:\n+\n+    fn serialize_spanned<S: serializer,T>(s: S, v: spanned<T>, t: fn(T)) {\n+         s.emit_rec(2u) {||\n+             s.emit_rec_field(\"node\", 0u) {||\n+                 t(s.node);\n+             };\n+             s.emit_rec_field(\"span\", 1u) {||\n+                 serialize_span(s, s.span);\n+             };\n+         }\n+    }\n+    fn deserialize_spanned<D: deserializer>(d: D, t: fn() -> T) -> node_id {\n+         d.read_rec(2u) {||\n+             {node: d.read_rec_field(\"node\", 0u, t),\n+              span: d.read_rec_field(\"span\", 1u) {||deserialize_span(d)}}\n+         }\n     }\n \n In general, the code to serialize an instance `v` of a non-built-in\n type a::b::c<T0,...,Tn> looks like:\n \n-    a::b::c::serialize(s, {|v| c_T0}, ..., {|v| c_Tn}, v)\n+    a::b::serialize_c(s, {|v| c_T0}, ..., {|v| c_Tn}, v)\n \n where `c_Ti` is the code to serialize an instance `v` of the type\n `Ti`.\n \n Similarly, the code to deserialize an instance of a non-built-in type\n `a::b::c<T0,...,Tn>` using the deserializer `d` looks like:\n \n-    a::b::c::deserialize(d, {|| c_T0}, ..., {|| c_Tn})\n+    a::b::deserialize_c(d, {|| c_T0}, ..., {|| c_Tn})\n \n where `c_Ti` is the code to deserialize an instance of `Ti` using the\n deserializer `d`.\n \n-TODO--Hygiene. Search for \"__\" strings.\n+TODO--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n+standard library.\n \n Misc notes:\n -----------\n@@ -106,13 +97,12 @@ fn expand(cx: ext_ctxt,\n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n           ast::item_ty(ty, tps) {\n-            [filter_attrs(in_item),\n-             ty_module(cx, in_item.ident, ty, tps)]\n+            [filter_attrs(in_item)] + ty_fns(cx, in_item.ident, ty, tps)\n           }\n \n           ast::item_enum(variants, tps) {\n-            [filter_attrs(in_item),\n-             enum_module(cx, in_item.ident, in_item.span, variants, tps)]\n+            [filter_attrs(in_item)] + enum_fns(cx, in_item.ident,\n+                                               in_item.span, variants, tps)\n           }\n \n           _ {\n@@ -128,6 +118,13 @@ fn expand(cx: ext_ctxt,\n impl helpers for ext_ctxt {\n     fn next_id() -> ast::node_id { self.session().next_node_id() }\n \n+    fn helper_path(base_path: @ast::path,\n+                   helper_name: str) -> @ast::path {\n+        let head = vec::init(base_path.node.idents);\n+        let tail = vec::last(base_path.node.idents);\n+        self.path(base_path.span, head + [helper_name + \"_\" + tail])\n+    }\n+\n     fn path(span: span, strs: [str]) -> @ast::path {\n         @{node: {global: false, idents: strs, types: []},\n           span: span}\n@@ -284,7 +281,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n         cx.expr(\n             path.span,\n             ast::expr_path(\n-                cx.path(path.span, path.node.idents + [\"serialize\"])));\n+                cx.helper_path(path, \"serialize\")));\n \n     let ty_args = vec::map(path.node.types) {|ty|\n         let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n@@ -466,13 +463,13 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                             cx.at(ty.span, #ast{ __e })))));\n \n         [#ast(stmt){\n-            core::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n+            std::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n         }]\n       }\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span,\n+fn mk_ser_fn(cx: ext_ctxt, span: span, name: str,\n              -v_ty: @ast::ty, tps: [ast::ty_param],\n              f: fn(ext_ctxt, ser_tps_map, @ast::ty,\n                    -@ast::expr, -@ast::expr) -> [@ast::stmt])\n@@ -514,7 +511,8 @@ fn mk_ser_fn(cx: ext_ctxt, span: span,\n     }\n \n     let ser_bnds = @[ast::bound_iface(cx.ty_path(span,\n-                                                 [\"serialization\",\n+                                                 [\"std\",\n+                                                  \"serialization\",\n                                                   \"serializer\"]))];\n \n     let ser_tps: [ast::ty_param] =\n@@ -530,7 +528,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span,\n     let ser_blk = cx.blk(span,\n                          f(cx, tps_map, v_ty, #ast{ __s }, #ast{ __v }));\n \n-    @{ident: \"serialize\",\n+    @{ident: \"serialize_\" + name,\n       attrs: [],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n@@ -554,7 +552,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n         cx.expr(\n             path.span,\n             ast::expr_path(\n-                cx.path(path.span, path.node.idents + [\"deserialize\"])));\n+                cx.helper_path(path, \"deserialize\")));\n \n     let ty_args = vec::map(path.node.types) {|ty|\n         let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n@@ -667,12 +665,12 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n \n       ast::ty_vec(mt) {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ core::serialization::read_to_vec($(d), $(l)) }\n+        #ast{ std::serialization::read_to_vec($(d), $(l)) }\n       }\n     }\n }\n \n-fn mk_deser_fn(cx: ext_ctxt, span: span,\n+fn mk_deser_fn(cx: ext_ctxt, span: span, name: str,\n                -v_ty: @ast::ty, tps: [ast::ty_param],\n                f: fn(ext_ctxt, deser_tps_map,\n                      @ast::ty, -@ast::expr) -> @ast::expr)\n@@ -709,7 +707,8 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     }\n \n     let deser_bnds = @[ast::bound_iface(cx.ty_path(span,\n-                                                   [\"serialization\",\n+                                                   [\"std\",\n+                                                    \"serialization\",\n                                                     \"deserializer\"]))];\n \n     let deser_tps: [ast::ty_param] =\n@@ -720,7 +719,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, v_ty, #ast(expr){__d}));\n \n-    @{ident: \"deserialize\",\n+    @{ident: \"deserialize_\" + name,\n       attrs: [],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,\n@@ -733,21 +732,14 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n       span: span}\n }\n \n-fn ty_module(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n-    -> @ast::item {\n+fn ty_fns(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n+    -> [@ast::item] {\n \n     let span = ty.span;\n-    let ser_fn = mk_ser_fn(cx, span, cx.clone_ty(ty), tps, ser_ty);\n-    let deser_fn = mk_deser_fn(cx, span, cx.clone_ty(ty), tps, deser_ty);\n-\n-    // Return a module containing the serialization and deserialization\n-    // functions:\n-    @{ident: name,\n-      attrs: [],\n-      id: cx.next_id(),\n-      node: ast::item_mod({view_items: [],\n-                           items: [ser_fn, deser_fn]}),\n-      span: span}\n+    [\n+        mk_ser_fn(cx, span, name, cx.clone_ty(ty), tps, ser_ty),\n+        mk_deser_fn(cx, span, name, cx.clone_ty(ty), tps, deser_ty)\n+    ]\n }\n \n fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n@@ -836,21 +828,14 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n     #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n }\n \n-fn enum_module(cx: ext_ctxt, e_name: str, e_span: span,\n+fn enum_fns(cx: ext_ctxt, e_name: str, e_span: span,\n                variants: [ast::variant], tps: [ast::ty_param])\n-    -> @ast::item {\n+    -> [@ast::item] {\n     let ty = cx.ty_path(e_span, [e_name]);\n-    let ser_fn =\n-        mk_ser_fn(cx, e_span, cx.clone_ty(ty), tps,\n-                  ser_enum(_, _, e_name, e_span, variants, _, _, _));\n-    let deser_fn =\n-        mk_deser_fn(cx, e_span, ty, tps,\n-                    deser_enum(_, _, e_name, e_span, variants, _, _));\n-\n-    @{ident: e_name,\n-      attrs: [],\n-      id: cx.next_id(),\n-      node: ast::item_mod({view_items: [],\n-                           items: [ser_fn, deser_fn]}),\n-      span: e_span}\n+    [\n+        mk_ser_fn(cx, e_span, e_name, cx.clone_ty(ty), tps,\n+                  ser_enum(_, _, e_name, e_span, variants, _, _, _)),\n+        mk_deser_fn(cx, e_span, e_name, ty, tps,\n+                    deser_enum(_, _, e_name, e_span, variants, _, _))\n+    ]\n }"}, {"sha": "72e8cc238c205c779c5acf436c1578dd4f84884a", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ffa187db252a7ee8765025f95d2cae18859258be/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa187db252a7ee8765025f95d2cae18859258be/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=ffa187db252a7ee8765025f95d2cae18859258be", "patch": "@@ -8,6 +8,7 @@ import io::writer;\n import std::prettyprint::serializer;\n import std::ebml::serializer;\n import std::ebml::deserializer;\n+import std::serialization::{serialize_uint, deserialize_uint};\n \n fn test_ser_and_deser<A>(a1: A,\n                          expected: str,\n@@ -68,31 +69,31 @@ fn main() {\n                             @plus(@val(22u), @val(5u))),\n                        \"plus(@minus(@val(3u), @val(10u)), \\\n                         @plus(@val(22u), @val(5u)))\",\n-                       expr::serialize(_, _),\n-                       expr::deserialize(_),\n-                       expr::serialize(_, _));\n+                       serialize_expr(_, _),\n+                       deserialize_expr(_),\n+                       serialize_expr(_, _));\n \n     test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n                        \"{lo: 0u, hi: 5u, node: 22u}\",\n-                       spanned_uint::serialize(_, _),\n-                       spanned_uint::deserialize(_),\n-                       spanned_uint::serialize(_, _));\n+                       serialize_spanned_uint(_, _),\n+                       deserialize_spanned_uint(_),\n+                       serialize_spanned_uint(_, _));\n \n     test_ser_and_deser(an_enum({v: [1u, 2u, 3u]}),\n                        \"an_enum({v: [1u, 2u, 3u]})\",\n-                       an_enum::serialize(_, _),\n-                       an_enum::deserialize(_),\n-                       an_enum::serialize(_, _));\n+                       serialize_an_enum(_, _),\n+                       deserialize_an_enum(_),\n+                       serialize_an_enum(_, _));\n \n     test_ser_and_deser({x: 3u, y: 5u},\n                        \"{x: 3u, y: 5u}\",\n-                       point::serialize(_, _),\n-                       point::deserialize(_),\n-                       point::serialize(_, _));\n+                       serialize_point(_, _),\n+                       deserialize_point(_),\n+                       serialize_point(_, _));\n \n     test_ser_and_deser([1u, 2u, 3u],\n                        \"[1u, 2u, 3u]\",\n-                       uint_vec::serialize(_, _),\n-                       uint_vec::deserialize(_),\n-                       uint_vec::serialize(_, _));\n+                       serialize_uint_vec(_, _),\n+                       deserialize_uint_vec(_),\n+                       serialize_uint_vec(_, _));\n }\n\\ No newline at end of file"}]}