{"sha": "c991c243b704b8895af15e971dd3a2ab5ee2aac1", "node_id": "C_kwDOAAsO6NoAKGM5OTFjMjQzYjcwNGI4ODk1YWYxNWU5NzFkZDNhMmFiNWVlMmFhYzE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-28T13:40:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-28T13:40:01Z"}, "message": "Rollup merge of #106173 - compiler-errors:deduplicate-op-methods, r=jackh726\n\nDeduplicate `op` methods\n\nThere are some operator-checking flavored methods in `FnCtxt` that can be deduplicated.", "tree": {"sha": "98849ca4ebd42c8ba69623ed1c1cf734c28a5d0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98849ca4ebd42c8ba69623ed1c1cf734c28a5d0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c991c243b704b8895af15e971dd3a2ab5ee2aac1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjrEcxCRBK7hj4Ov3rIwAAT1sIAJzoBGuNGW1h4Mnf0h4Jwsu+\nTrpZlSxFyBpkRzw3yCls1jif7pWjzHsf+8pzKwHdnhiXi2SRH2vknCz4VUdNVXrU\nILxvOwMu7DJRqmW4XccaSVUDJLXPFxiWEhZ5Q3PFKav7aGkLNkbNqtxmCLUE+Kex\n51HrCluE2ROkNFYxcON/ZRhKHZJjNXfbTrQgaI+XdNSRHtzRZ2HifaWlXd+b8Ga4\n/uixjvqjHiy3njw9XgXbsvTftnsNd6QIYq9+5ryqUxWU5KnSuKDMi2u9Afa99GAa\nITF8MtOT4b5phMcuo1efGkQcEMoFKPIx7cmLEvciscA0T1RUV+8M+W7BWkRXcwI=\n=ufSC\n-----END PGP SIGNATURE-----\n", "payload": "tree 98849ca4ebd42c8ba69623ed1c1cf734c28a5d0b\nparent 31f5e753fbd0ccc1b176608dbaf1f156a3a31221\nparent 8bf7ec75343cde1c72a5e16b0171e259412b8958\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1672234801 +0100\ncommitter GitHub <noreply@github.com> 1672234801 +0100\n\nRollup merge of #106173 - compiler-errors:deduplicate-op-methods, r=jackh726\n\nDeduplicate `op` methods\n\nThere are some operator-checking flavored methods in `FnCtxt` that can be deduplicated.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c991c243b704b8895af15e971dd3a2ab5ee2aac1", "html_url": "https://github.com/rust-lang/rust/commit/c991c243b704b8895af15e971dd3a2ab5ee2aac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c991c243b704b8895af15e971dd3a2ab5ee2aac1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31f5e753fbd0ccc1b176608dbaf1f156a3a31221", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f5e753fbd0ccc1b176608dbaf1f156a3a31221", "html_url": "https://github.com/rust-lang/rust/commit/31f5e753fbd0ccc1b176608dbaf1f156a3a31221"}, {"sha": "8bf7ec75343cde1c72a5e16b0171e259412b8958", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf7ec75343cde1c72a5e16b0171e259412b8958", "html_url": "https://github.com/rust-lang/rust/commit/8bf7ec75343cde1c72a5e16b0171e259412b8958"}], "stats": {"total": 211, "additions": 52, "deletions": 159}, "files": [{"sha": "829913d278d06233d4c6997da67f003b2f586fb0", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=c991c243b704b8895af15e971dd3a2ab5ee2aac1", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n             if let Some(ok) = self.lookup_method_in_trait(\n-                call_expr.span,\n+                self.misc(call_expr.span),\n                 method_name,\n                 trait_def_id,\n                 adjusted_ty,"}, {"sha": "b9b27e8627aff7024bd75538500b368ee1e93280", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 18, "deletions": 122, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=c991c243b704b8895af15e971dd3a2ab5ee2aac1", "patch": "@@ -11,7 +11,7 @@ pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n use crate::errors::OpMethodGenericParams;\n-use crate::{Expectation, FnCtxt};\n+use crate::FnCtxt;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn obligation_for_method(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n@@ -282,71 +282,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            self.var_for_def(span, param)\n-        });\n-\n-        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n-\n-        // Construct an obligation\n-        let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        (\n-            traits::Obligation::misc(\n-                self.tcx,\n-                span,\n-                self.body_id,\n-                self.param_env,\n-                poly_trait_ref.without_const(),\n-            ),\n-            substs,\n-        )\n-    }\n-\n-    pub(super) fn obligation_for_op_method(\n-        &self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        expected: Expectation<'tcx>,\n-    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n-    {\n-        // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => {}\n-                GenericParamDefKind::Type { .. } => {\n-                    if param.index == 0 {\n-                        return self_ty.into();\n-                    } else if let Some(input_type) = opt_input_type {\n-                        return input_type.into();\n-                    }\n-                }\n-            }\n-            self.var_for_def(span, param)\n+            self.var_for_def(cause.span, param)\n         });\n \n         let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-\n         (\n             traits::Obligation::new(\n                 self.tcx,\n-                traits::ObligationCause::new(\n-                    span,\n-                    self.body_id,\n-                    traits::BinOp {\n-                        rhs_span: opt_input_expr.map(|expr| expr.span),\n-                        is_lit: opt_input_expr\n-                            .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_ty,\n-                    },\n-                ),\n+                cause,\n                 self.param_env,\n-                poly_trait_ref,\n+                poly_trait_ref.without_const(),\n             ),\n             substs,\n         )\n@@ -357,69 +305,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for a particular trait with the given self type and checks\n     /// whether that trait is implemented.\n-    #[instrument(level = \"debug\", skip(self, span))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn lookup_method_in_trait(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         let (obligation, substs) =\n-            self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            None,\n-            false,\n-        )\n-    }\n-\n-    pub(super) fn lookup_op_method_in_trait(\n-        &self,\n-        span: Span,\n-        m_name: Ident,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        expected: Expectation<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let (obligation, substs) = self.obligation_for_op_method(\n-            span,\n-            trait_def_id,\n-            self_ty,\n-            opt_input_type,\n-            opt_input_expr,\n-            expected,\n-        );\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            opt_input_expr,\n-            true,\n-        )\n+            self.obligation_for_method(cause, trait_def_id, self_ty, opt_input_types);\n+        self.construct_obligation_for_trait(m_name, trait_def_id, obligation, substs)\n     }\n \n     // FIXME(#18741): it seems likely that we can consolidate some of this\n     // code with the other method-lookup code. In particular, the second half\n     // of this method is basically the same as confirmation.\n     fn construct_obligation_for_trait(\n         &self,\n-        span: Span,\n         m_name: Ident,\n         trait_def_id: DefId,\n         obligation: traits::PredicateObligation<'tcx>,\n         substs: &'tcx ty::List<ty::subst::GenericArg<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        is_op: bool,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(?obligation);\n \n@@ -435,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let Some(method_item) = self.associated_value(trait_def_id, m_name) else {\n             tcx.sess.delay_span_bug(\n-                span,\n+                obligation.cause.span,\n                 \"operator trait does not have corresponding operator method\",\n             );\n             return None;\n@@ -461,24 +369,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // with bound regions.\n         let fn_sig = tcx.bound_fn_sig(def_id);\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n-\n-        let cause = if is_op {\n-            ObligationCause::new(\n-                span,\n-                self.body_id,\n-                traits::BinOp {\n-                    rhs_span: opt_input_expr.map(|expr| expr.span),\n-                    is_lit: opt_input_expr\n-                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_ty: None,\n-                },\n-            )\n-        } else {\n-            traits::ObligationCause::misc(span, self.body_id)\n-        };\n+        let fn_sig =\n+            self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n \n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(fn_sig);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(fn_sig);\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -494,15 +389,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(bounds);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(bounds);\n         let bounds = {\n             obligations.extend(o);\n             value\n         };\n \n         assert!(!bounds.has_escaping_bound_vars());\n \n-        let predicates_cause = cause.clone();\n+        let predicates_cause = obligation.cause.clone();\n         obligations.extend(traits::predicates_for_generics(\n             move |_, _| predicates_cause.clone(),\n             self.param_env,\n@@ -517,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         obligations.push(traits::Obligation::new(\n             tcx,\n-            cause,\n+            obligation.cause,\n             self.param_env,\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(method_ty.into())),\n         ));"}, {"sha": "34140f3e1fe3e535a0d4d82e5090e9e4e0511821", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=c991c243b704b8895af15e971dd3a2ab5ee2aac1", "patch": "@@ -12,14 +12,16 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::FulfillmentError;\n+use rustc_trait_selection::traits::{self, FulfillmentError};\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -48,8 +50,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if self\n                     .lookup_op_method(\n                         lhs_deref_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs),\n+                        Some((rhs, rhs_ty)),\n                         Op::Binary(op, IsAssign::Yes),\n                         expected,\n                     )\n@@ -60,8 +61,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs),\n+                            Some((rhs, rhs_ty)),\n                             Op::Binary(op, IsAssign::Yes),\n                             expected,\n                         )\n@@ -248,8 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = self.lookup_op_method(\n             lhs_ty,\n-            Some(rhs_ty_var),\n-            Some(rhs_expr),\n+            Some((rhs_expr, rhs_ty_var)),\n             Op::Binary(op, is_assign),\n             expected,\n         );\n@@ -382,8 +381,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_deref_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs_expr),\n+                            Some((rhs_expr, rhs_ty)),\n                             Op::Binary(op, is_assign),\n                             expected,\n                         )\n@@ -410,8 +408,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let is_compatible = |lhs_ty, rhs_ty| {\n                     self.lookup_op_method(\n                         lhs_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs_expr),\n+                        Some((rhs_expr, rhs_ty)),\n                         Op::Binary(op, is_assign),\n                         expected,\n                     )\n@@ -471,8 +468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let errors = self\n                             .lookup_op_method(\n                                 lhs_ty,\n-                                Some(rhs_ty),\n-                                Some(rhs_expr),\n+                                Some((rhs_expr, rhs_ty)),\n                                 Op::Binary(op, is_assign),\n                                 expected,\n                             )\n@@ -492,6 +488,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             if let Some(output_def_id) = output_def_id\n                                                 && let Some(trait_def_id) = trait_def_id\n                                                 && self.tcx.parent(output_def_id) == trait_def_id\n+                                                && output_ty.is_suggestable(self.tcx, false)\n                                             {\n                                                 Some((\"Output\", *output_ty))\n                                             } else {\n@@ -625,7 +622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span), expected) {\n+        match self.lookup_op_method(operand_ty, None, Op::Unary(op, ex.span), expected) {\n             Ok(method) => {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n@@ -712,8 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn lookup_op_method(\n         &self,\n         lhs_ty: Ty<'tcx>,\n-        other_ty: Option<Ty<'tcx>>,\n-        other_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n@@ -742,20 +738,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Op::Unary(..) => 0,\n             },\n         ) {\n+            self.tcx\n+                .sess\n+                .delay_span_bug(span, \"operator didn't have the right number of generic args\");\n             return Err(vec![]);\n         }\n \n         let opname = Ident::with_dummy_span(opname);\n+        let input_types =\n+            opt_rhs.as_ref().map(|(_, ty)| std::slice::from_ref(ty)).unwrap_or_default();\n+        let cause = self.cause(\n+            span,\n+            traits::BinOp {\n+                rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n+                is_lit: opt_rhs\n+                    .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                output_ty: expected.only_has_type(self),\n+            },\n+        );\n+\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_op_method_in_trait(\n-                span,\n-                opname,\n-                trait_did,\n-                lhs_ty,\n-                other_ty,\n-                other_ty_expr,\n-                expected,\n-            )\n+            self.lookup_method_in_trait(cause.clone(), opname, trait_did, lhs_ty, Some(input_types))\n         });\n \n         match (method, trait_did) {\n@@ -766,14 +769,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n-                let (obligation, _) = self.obligation_for_op_method(\n-                    span,\n-                    trait_did,\n-                    lhs_ty,\n-                    other_ty,\n-                    other_ty_expr,\n-                    expected,\n-                );\n+                let (obligation, _) =\n+                    self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n                 Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }"}, {"sha": "a0f048fc09b9b017101fb4f59f7602f2ec4bd09d", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c991c243b704b8895af15e971dd3a2ab5ee2aac1/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=c991c243b704b8895af15e971dd3a2ab5ee2aac1", "patch": "@@ -225,7 +225,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         imm_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(imm_op),\n                 trait_did,\n                 base_ty,\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         mut_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(mut_op),\n                 trait_did,\n                 base_ty,"}]}