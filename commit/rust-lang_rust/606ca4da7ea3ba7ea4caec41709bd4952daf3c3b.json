{"sha": "606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "node_id": "C_kwDOAAsO6NoAKDYwNmNhNGRhN2VhM2JhN2VhNGNhZWM0MTcwOWJkNDk1MmRhZjNjM2I", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-03-12T22:30:33Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-04-16T12:52:00Z"}, "message": "Report a backtrace for memory leaks under Miri", "tree": {"sha": "9d9a04d8d1ede2430f17c89b5d15e18cd8302c03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9a04d8d1ede2430f17c89b5d15e18cd8302c03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "html_url": "https://github.com/rust-lang/rust/commit/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd57c6b407d5f038060d7b94ce9af22ea4b0dcf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd57c6b407d5f038060d7b94ce9af22ea4b0dcf0", "html_url": "https://github.com/rust-lang/rust/commit/fd57c6b407d5f038060d7b94ce9af22ea4b0dcf0"}], "stats": {"total": 205, "additions": 145, "deletions": 60}, "files": [{"sha": "b5b5cc4f1963843a06a5fa99a53f155aced87fe4", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -132,11 +132,10 @@ pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n }\n \n /// What we store about a frame in an interpreter backtrace.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct FrameInfo<'tcx> {\n     pub instance: ty::Instance<'tcx>,\n     pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n@@ -947,10 +946,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n+            frames.push(FrameInfo { span, instance: frame.instance });\n         }\n         trace!(\"generate stacktrace: {:#?}\", frames);\n         frames"}, {"sha": "b448e3a24c68fb71a66b3b6f1c9c14b7f277c091", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -104,7 +104,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     type FrameExtra;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: Debug + Clone + 'static;\n+    type AllocExtra: Debug + Clone + 'tcx;\n \n     /// Type for the bytes of the allocation.\n     type Bytes: AllocBytes + 'static;"}, {"sha": "d5b6a581a79f6ef8f5f6620e498fd8f7b5c4e2ca", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -215,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    /// This can fail only of `alloc` contains provenance.\n+    /// This can fail only if `alloc` contains provenance.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n@@ -807,9 +807,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         DumpAllocs { ecx: self, allocs }\n     }\n \n-    /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n-    /// are not considered leaked. Leaks whose kind `may_leak()` returns true are not reported.\n-    pub fn leak_report(&self, static_roots: &[AllocId]) -> usize {\n+    /// Find leaked allocations. Allocations reachable from `static_roots` or a `Global` allocation\n+    /// are not considered leaked, as well as leaks whose kind's `may_leak()` returns true.\n+    pub fn find_leaked_allocations(\n+        &self,\n+        static_roots: &[AllocId],\n+    ) -> Vec<(AllocId, MemoryKind<M::MemoryKind>, Allocation<M::Provenance, M::AllocExtra, M::Bytes>)>\n+    {\n         // Collect the set of allocations that are *reachable* from `Global` allocations.\n         let reachable = {\n             let mut reachable = FxHashSet::default();\n@@ -833,14 +837,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n-        let leaks: Vec<_> = self.memory.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n-            if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n-        });\n-        let n = leaks.len();\n-        if n > 0 {\n-            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n-        }\n-        n\n+        self.memory.alloc_map.filter_map_collect(|id, (kind, alloc)| {\n+            if kind.may_leak() || reachable.contains(id) {\n+                None\n+            } else {\n+                Some((*id, *kind, alloc.clone()))\n+            }\n+        })\n     }\n }\n "}, {"sha": "d54adb72887a0ba957ea2bf12a280b4b74e6d7d4", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -352,7 +352,7 @@ pub enum AllocState {\n     TreeBorrows(Box<RefCell<tree_borrows::AllocState>>),\n }\n \n-impl machine::AllocExtra {\n+impl machine::AllocExtra<'_> {\n     #[track_caller]\n     pub fn borrow_tracker_sb(&self) -> &RefCell<stacked_borrows::AllocState> {\n         match self.borrow_tracker {"}, {"sha": "7a726be00da4e0222c14074598b09103bde53743", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -105,7 +105,7 @@ pub enum NonHaltingDiagnostic {\n }\n \n /// Level of Miri specific diagnostics\n-enum DiagLevel {\n+pub enum DiagLevel {\n     Error,\n     Warning,\n     Note,\n@@ -114,7 +114,7 @@ enum DiagLevel {\n /// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n /// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n /// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n-fn prune_stacktrace<'tcx>(\n+pub fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n     machine: &MiriMachine<'_, 'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n@@ -338,12 +338,45 @@ pub fn report_error<'tcx, 'mir>(\n     None\n }\n \n+pub fn report_leaks<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+    leaks: Vec<(AllocId, MemoryKind<MiriMemoryKind>, Allocation<Provenance, AllocExtra<'tcx>>)>,\n+) {\n+    let mut any_pruned = false;\n+    for (id, kind, mut alloc) in leaks {\n+        let Some(backtrace) = alloc.extra.backtrace.take() else {\n+            continue;\n+        };\n+        let (backtrace, pruned) = prune_stacktrace(backtrace, &ecx.machine);\n+        any_pruned |= pruned;\n+        report_msg(\n+            DiagLevel::Error,\n+            &format!(\n+                \"memory leaked: {id:?} ({}, size: {:?}, align: {:?}), allocated here:\",\n+                kind,\n+                alloc.size().bytes(),\n+                alloc.align.bytes()\n+            ),\n+            vec![],\n+            vec![],\n+            vec![],\n+            &backtrace,\n+            &ecx.machine,\n+        );\n+    }\n+    if any_pruned {\n+        ecx.tcx.sess.diagnostic().note_without_error(\n+            \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n+        );\n+    }\n+}\n+\n /// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'tcx>(\n+pub fn report_msg<'tcx>(\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,"}, {"sha": "60533687bed573aa089ffeb28569da4e5fcf1faa", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -10,6 +10,7 @@ use std::thread;\n use log::info;\n \n use crate::borrow_tracker::RetagFields;\n+use crate::diagnostics::report_leaks;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -457,10 +458,12 @@ pub fn eval_entry<'tcx>(\n         }\n         // Check for memory leaks.\n         info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n-        let leaks = ecx.leak_report(&ecx.machine.static_roots);\n-        if leaks != 0 {\n-            tcx.sess.err(\"the evaluated program leaked memory\");\n-            tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+        let leaks = ecx.find_leaked_allocations(&ecx.machine.static_roots);\n+        if !leaks.is_empty() {\n+            report_leaks(&ecx, leaks);\n+            tcx.sess.note_without_error(\n+                \"the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\",\n+            );\n             // Ignore the provided return code - let the reported error\n             // determine the return code.\n             return None;"}, {"sha": "a9c1357fcf298a778cfa05dc9b7b5eada2ea557d", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -253,20 +253,24 @@ impl ProvenanceExtra {\n \n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n-pub struct AllocExtra {\n+pub struct AllocExtra<'tcx> {\n     /// Global state of the borrow tracker, if enabled.\n     pub borrow_tracker: Option<borrow_tracker::AllocState>,\n-    /// Data race detection via the use of a vector-clock,\n-    ///  this is only added if it is enabled.\n+    /// Data race detection via the use of a vector-clock.\n+    /// This is only added if it is enabled.\n     pub data_race: Option<data_race::AllocState>,\n-    /// Weak memory emulation via the use of store buffers,\n-    ///  this is only added if it is enabled.\n+    /// Weak memory emulation via the use of store buffers.\n+    /// This is only added if it is enabled.\n     pub weak_memory: Option<weak_memory::AllocState>,\n+    /// A backtrace to where this allocation was allocated.\n+    /// As this is recorded for leak reports, it only exists\n+    /// if this allocation is leakable.\n+    pub backtrace: Option<Vec<FrameInfo<'tcx>>>,\n }\n \n-impl VisitTags for AllocExtra {\n+impl VisitTags for AllocExtra<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n-        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n+        let AllocExtra { borrow_tracker, data_race, weak_memory, backtrace: _ } = self;\n \n         borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n@@ -773,7 +777,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type ExtraFnVal = Dlsym;\n \n     type FrameExtra = FrameExtra<'tcx>;\n-    type AllocExtra = AllocExtra;\n+    type AllocExtra = AllocExtra<'tcx>;\n \n     type Provenance = Provenance;\n     type ProvenanceExtra = ProvenanceExtra;\n@@ -967,9 +971,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             )\n         });\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n+\n+        // If an allocation is leaked, we want to report a backtrace to indicate where it was\n+        // allocated. We don't need to record a backtrace for allocations which are allowed to\n+        // leak.\n+        let backtrace = if kind.may_leak() { None } else { Some(ecx.generate_stacktrace()) };\n+\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n+            AllocExtra {\n+                borrow_tracker,\n+                data_race: race_alloc,\n+                weak_memory: buffer_alloc,\n+                backtrace,\n+            },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -1049,7 +1064,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_read(\n         _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n-        alloc_extra: &AllocExtra,\n+        alloc_extra: &AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1069,7 +1084,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_write(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1089,7 +1104,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_deallocation(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {"}, {"sha": "cefdcc2b5b83d051882ba0b0210952cedc6ccbd9", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -125,7 +125,7 @@ impl VisitTags for Operand<Provenance> {\n     }\n }\n \n-impl VisitTags for Allocation<Provenance, AllocExtra> {\n+impl VisitTags for Allocation<Provenance, AllocExtra<'_>> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);"}, {"sha": "cbeb163b56c317c7f4167b2adba5a0b8810d68aa", "filename": "src/tools/miri/tests/fail/memleak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n \n fn main() {"}, {"sha": "9b23a71f5abb794e8472e32fc116c8cce29ae767", "filename": "src/tools/miri/tests/fail/memleak.stderr", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -1,10 +1,21 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 4, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 4, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak.rs:LL:CC\n+   |\n+LL |     std::mem::forget(Box::new(42));\n+   |                      ^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n-\n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "0eaf84048e0a35bef54c1ac2f06b0ba6e787c284", "filename": "src/tools/miri/tests/fail/memleak_rc.32bit.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -1,10 +1,22 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 16, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 16, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n-\n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "9b7adc00ef5cdb302c104fc367aa1bbd86ef5493", "filename": "src/tools/miri/tests/fail/memleak_rc.64bit.stderr", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -1,11 +1,22 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 32, align: 8) {\n-$stripped$\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 32, align: 8), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n-\n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "cf4671912ada8057c2fbc50f7e7bc3cef265e498", "filename": "src/tools/miri/tests/fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606ca4da7ea3ba7ea4caec41709bd4952daf3c3b/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs?ref=606ca4da7ea3ba7ea4caec41709bd4952daf3c3b", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@stderr-per-bitwidth\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n "}]}