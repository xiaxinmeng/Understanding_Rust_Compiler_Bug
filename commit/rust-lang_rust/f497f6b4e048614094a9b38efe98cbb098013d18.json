{"sha": "f497f6b4e048614094a9b38efe98cbb098013d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OTdmNmI0ZTA0ODYxNDA5NGE5YjM4ZWZlOThjYmIwOTgwMTNkMTg=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-09T08:06:53Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:02:46Z"}, "message": "Tidy up", "tree": {"sha": "120454c00386049308872b0191054360e5fb8246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/120454c00386049308872b0191054360e5fb8246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f497f6b4e048614094a9b38efe98cbb098013d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f497f6b4e048614094a9b38efe98cbb098013d18", "html_url": "https://github.com/rust-lang/rust/commit/f497f6b4e048614094a9b38efe98cbb098013d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f497f6b4e048614094a9b38efe98cbb098013d18/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ee0337622f4025202687ccfac79c04d2046de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ee0337622f4025202687ccfac79c04d2046de8", "html_url": "https://github.com/rust-lang/rust/commit/68ee0337622f4025202687ccfac79c04d2046de8"}], "stats": {"total": 120, "additions": 53, "deletions": 67}, "files": [{"sha": "f703af4340ca62c7b87cd4411da9044579b74329", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 53, "deletions": 67, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f497f6b4e048614094a9b38efe98cbb098013d18/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f497f6b4e048614094a9b38efe98cbb098013d18/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=f497f6b4e048614094a9b38efe98cbb098013d18", "patch": "@@ -1,8 +1,10 @@\n use std::iter::once;\n+use std::path::PathBuf;\n+use std::sync::Arc;\n \n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics, Module, Documentation, AttrDef, Crate\n+    ModuleSource, Semantics, Documentation, AttrDef, Crate\n };\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n@@ -12,8 +14,12 @@ use ra_ide_db::{\n };\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n use ra_project_model::ProjectWorkspace;\n-use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase, ModuleDefId};\n-use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf, Subtree, SmolStr};\n+use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase};\n+use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf};\n+\n+use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n+use comrak::nodes::NodeValue;\n+use url::Url;\n \n use crate::{\n     display::{\n@@ -68,13 +74,6 @@ pub struct HoverGotoTypeData {\n     pub nav: NavigationTarget,\n }\n \n-use std::path::{Path, PathBuf};\n-use std::sync::Arc;\n-use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n-use comrak::nodes::NodeValue;\n-use url::Url;\n-use ra_ide_db::imports_locator::ImportsLocator;\n-\n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n pub struct HoverResult {\n@@ -392,50 +391,42 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n \n /// Rewrite documentation links in markdown to point to local documentation/docs.rs\n fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, workspaces: Arc<Vec<ProjectWorkspace>>) -> Option<String> {\n-    // FIXME: Fail early\n-    if let (Some(name), Some(module)) = (definition.name(db), definition.module(db)) {\n-        let krate_name = module.krate().display_name(db)?;\n-        let arena = Arena::new();\n-        let doc = parse_document(&arena, markdown, &ComrakOptions::default());\n-        let path = module.path_to_root(db);\n-        let mut doc_target_dirs = workspaces\n-            .iter()\n-            .filter_map(|workspace| if let ProjectWorkspace::Cargo{cargo: cargo_workspace, ..} = workspace {Some(cargo_workspace)} else {None})\n-            .map(|workspace| workspace.workspace_root())\n-            // TODO: `target` is configurable in cargo config, we should respect it\n-            .map(|root| root.join(\"target/doc\"));\n-\n-        iter_nodes(doc, &|node| {\n-            match &mut node.data.borrow_mut().value {\n-                &mut NodeValue::Link(ref mut link) => {\n-                    match Url::parse(&String::from_utf8(link.url.clone()).unwrap()) {\n-                        // If this is a valid absolute URL don't touch it\n-                        Ok(_) => (),\n-                        // If contains .html            file-based link to new page\n-                        // If starts with #fragment     file-based link to fragment on current page\n-                        // If contains ::               module-based link\n-                        Err(_) => {\n-                            let link_str = String::from_utf8(link.url.clone()).unwrap();\n-                            let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str, UrlMode::Url)\n-                                .or_else(|| try_resolve_intra(db, &mut doc_target_dirs.clone(), definition, &link_str));\n-\n-                            if let Some(resolved) = resolved {\n-                                link.url = resolved.as_bytes().to_vec();\n-                            }\n-\n+    let arena = Arena::new();\n+    let doc = parse_document(&arena, markdown, &ComrakOptions::default());\n+    let doc_target_dirs = workspaces\n+        .iter()\n+        .filter_map(|workspace| if let ProjectWorkspace::Cargo{cargo: cargo_workspace, ..} = workspace {Some(cargo_workspace)} else {None})\n+        .map(|workspace| workspace.workspace_root())\n+        // TODO: `target` is configurable in cargo config, we should respect it\n+        .map(|root| root.join(\"target/doc\"));\n+\n+    iter_nodes(doc, &|node| {\n+        match &mut node.data.borrow_mut().value {\n+            &mut NodeValue::Link(ref mut link) => {\n+                match Url::parse(&String::from_utf8(link.url.clone()).unwrap()) {\n+                    // If this is a valid absolute URL don't touch it\n+                    Ok(_) => (),\n+                    // If contains .html            file-based link to new page\n+                    // If starts with #fragment     file-based link to fragment on current page\n+                    // If contains ::               module-based link\n+                    Err(_) => {\n+                        let link_str = String::from_utf8(link.url.clone()).unwrap();\n+                        let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str, UrlMode::Url)\n+                            .or_else(|| try_resolve_intra(db, &mut doc_target_dirs.clone(), definition, &link_str));\n+\n+                        if let Some(resolved) = resolved {\n+                            link.url = resolved.as_bytes().to_vec();\n                         }\n+\n                     }\n-                },\n-                _ => ()\n-            }\n-        });\n-        let mut out = Vec::new();\n-        format_commonmark(doc, &ComrakOptions::default(), &mut out);\n-        Some(String::from_utf8(out).unwrap())\n-    } else {\n-        // eprintln!(\"WARN: Unable to determine name or module for hover; link rewriting disabled.\");\n-        None\n-    }\n+                }\n+            },\n+            _ => ()\n+        }\n+    });\n+    let mut out = Vec::new();\n+    format_commonmark(doc, &ComrakOptions::default(), &mut out).ok()?;\n+    Some(String::from_utf8(out).unwrap())\n }\n \n /// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`)\n@@ -467,13 +458,10 @@ fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pat\n         UrlMode::Url => {\n             let root = get_doc_url(db, &krate);\n             let mut base = base.join(\"/\");\n-            if let Some(url) = root {\n-                eprintln!(\"root: {:?} base: {:?} link: {} root&base: {} root&base&link: {}\", url, &base, link, url.join(&base).unwrap(), url.join(&base).unwrap().join(link).unwrap());\n-                if link.starts_with(\"#\") {\n-                    base = base + \"/\"\n-                };\n-                Some(url.join(&base)?.join(link)?.into_string())\n-            } else {None}\n+            if link.starts_with(\"#\") {\n+                base = base + \"/\"\n+            };\n+            root.and_then(|url| url.join(&base).ok()).and_then(|url| url.join(link).ok()).map(|url| url.into_string())\n         },\n         UrlMode::File => {\n             let base = base.collect::<PathBuf>();\n@@ -491,7 +479,7 @@ fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pat\n \n /// Try to get the root URL of the documentation of a crate.\n fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n-    // Look for #![doc(html_root_url = \"https://docs.rs/...\")]\n+    // Look for #![doc(html_root_url = \"...\")]\n     let attrs = db.attrs(AttrDef::from(krate.root_module(db)?).into());\n     let doc_attr_q = attrs.by_key(\"doc\");\n     let doc_url = if doc_attr_q.exists() {\n@@ -500,20 +488,18 @@ fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n                 TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident_text, ..})),\n                 TokenTree::Leaf(Leaf::Punct(Punct{r#char: '=', ..})),\n                 TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))\n-            ] if ident_text == \"html_root_url\" => Some(text),\n+            ] if ident_text == \"html_root_url\" => Some(text.to_string()),\n             _ => {\n                 None\n             }\n         }).next()\n     } else {\n-        None\n+        // Fallback to docs.rs\n+        // TODO: Specify an exact version here (from Cargo.lock)\n+        Some(format!(\"https://docs.rs/{}/*\", krate.display_name(db)?))\n     };\n-    eprintln!(\"url {:?}\", doc_url);\n \n-    // TODO: It should be possible to fallback to `format!(\"https://docs.rs/{}/*\", crate_name, *)`\n-    let url = doc_url.map(|s| s.trim_matches('\"').to_owned() + \"/\").and_then(|s| Url::parse(&s).ok());\n-    eprintln!(\"url {:?}\", url);\n-    url\n+    doc_url.map(|s| s.trim_matches('\"').to_owned() + \"/\").and_then(|s| Url::parse(&s).ok())\n }\n \n fn iter_nodes<'a, F>(node: &'a comrak::nodes::AstNode<'a>, f: &F)"}]}