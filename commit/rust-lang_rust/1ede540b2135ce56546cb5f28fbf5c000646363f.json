{"sha": "1ede540b2135ce56546cb5f28fbf5c000646363f", "node_id": "C_kwDOAAsO6NoAKDFlZGU1NDBiMjEzNWNlNTY1NDZjYjVmMjhmYmY1YzAwMDY0NjM2M2Y", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-10-20T04:13:42Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-10-20T04:13:42Z"}, "message": "Fix false positive in `match_overlapping_arm`\n\nThe bug was dues to the constant bytes being compared instead of their\nvalues. This meant that negative values were being treated as larger\nthan some positive values.\n\nFixes #7829", "tree": {"sha": "530928bba64103bf838d1cab1b4d869a8af595f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/530928bba64103bf838d1cab1b4d869a8af595f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ede540b2135ce56546cb5f28fbf5c000646363f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ede540b2135ce56546cb5f28fbf5c000646363f", "html_url": "https://github.com/rust-lang/rust/commit/1ede540b2135ce56546cb5f28fbf5c000646363f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ede540b2135ce56546cb5f28fbf5c000646363f/comments", "author": null, "committer": null, "parents": [{"sha": "c4d5471a45dbdddccb74bb505864cab284df21fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d5471a45dbdddccb74bb505864cab284df21fd", "html_url": "https://github.com/rust-lang/rust/commit/c4d5471a45dbdddccb74bb505864cab284df21fd"}], "stats": {"total": 51, "additions": 14, "deletions": 37}, "files": [{"sha": "f1289a36e77702435734ad242286dc106f60bd15", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1ede540b2135ce56546cb5f28fbf5c000646363f/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ede540b2135ce56546cb5f28fbf5c000646363f/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1ede540b2135ce56546cb5f28fbf5c000646363f", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant, miri_to_const, Constant};\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n@@ -930,9 +930,8 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n     if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        let type_ranges = type_ranges(&ranges);\n-        if !type_ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&type_ranges) {\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n                 span_lint_and_note(\n                     cx,\n                     MATCH_OVERLAPPING_ARM,\n@@ -1601,7 +1600,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n }\n \n /// Gets all arms that are unbounded `PatRange`s.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n     arms.iter()\n         .filter_map(|arm| {\n             if let Arm { pat, guard: None, .. } = *arm {\n@@ -1614,21 +1613,25 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n-                    let rhs = match range_end {\n-                        RangeEnd::Included => Bound::Included(rhs),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs),\n+\n+                    let lhs_val = lhs.int_value(cx, ty)?;\n+                    let rhs_val = rhs.int_value(cx, ty)?;\n+\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => Bound::Included(rhs_val),\n+                        RangeEnd::Excluded => Bound::Excluded(rhs_val),\n                     };\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (lhs, rhs),\n+                        node: (lhs_val, rhs_bound),\n                     });\n                 }\n \n                 if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant(cx, cx.typeck_results(), value)?.0;\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (value.clone(), Bound::Included(value)),\n+                        node: (value, Bound::Included(value)),\n                     });\n                 }\n             }\n@@ -1643,32 +1646,6 @@ pub struct SpannedRange<T> {\n     pub node: (T, Bound<T>),\n }\n \n-type TypedRanges = Vec<SpannedRange<u128>>;\n-\n-/// Gets all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n-/// and other types than\n-/// `Uint` and `Int` probably don't make sense.\n-fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n-    ranges\n-        .iter()\n-        .filter_map(|range| match range.node {\n-            (Constant::Int(start), Bound::Included(Constant::Int(end))) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Included(end)),\n-            }),\n-            (Constant::Int(start), Bound::Excluded(Constant::Int(end))) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Excluded(end)),\n-            }),\n-            (Constant::Int(start), Bound::Unbounded) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Unbounded),\n-            }),\n-            _ => None,\n-        })\n-        .collect()\n-}\n-\n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))"}]}