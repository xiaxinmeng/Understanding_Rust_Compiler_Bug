{"sha": "27700472b98862978cd0bd291bbb413e30102f38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NzAwNDcyYjk4ODYyOTc4Y2QwYmQyOTFiYmI0MTNlMzAxMDJmMzg=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-01T18:37:30Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-10T16:15:08Z"}, "message": "removed eval.rs: dead code\n\n@brson confirms that eval.rs is now dead code", "tree": {"sha": "17515c00ccf73e999b557161cd6ebd26e50ae5dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17515c00ccf73e999b557161cd6ebd26e50ae5dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27700472b98862978cd0bd291bbb413e30102f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27700472b98862978cd0bd291bbb413e30102f38", "html_url": "https://github.com/rust-lang/rust/commit/27700472b98862978cd0bd291bbb413e30102f38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27700472b98862978cd0bd291bbb413e30102f38/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e7bda8269861df43763b4fb42e68af0eb09b20", "url": "https://api.github.com/repos/rust-lang/rust/commits/48e7bda8269861df43763b4fb42e68af0eb09b20", "html_url": "https://github.com/rust-lang/rust/commit/48e7bda8269861df43763b4fb42e68af0eb09b20"}], "stats": {"total": 174, "additions": 0, "deletions": 174}, "files": [{"sha": "5d44db084d6000182ddd5baaa589cac5a9885ada", "filename": "src/libsyntax/parse/eval.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/48e7bda8269861df43763b4fb42e68af0eb09b20/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e7bda8269861df43763b4fb42e68af0eb09b20/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=48e7bda8269861df43763b4fb42e68af0eb09b20", "patch": "@@ -1,174 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use parser::Parser;\n-use attr::parser_attr;\n-use codemap::{span, mk_sp};\n-\n-type ctx =\n-    @{sess: parse::parse_sess,\n-      cfg: ast::crate_cfg};\n-\n-fn eval_crate_directives(cx: ctx,\n-                         cdirs: ~[@ast::crate_directive],\n-                         prefix: &Path,\n-                         view_items: &mut~[@ast::view_item],\n-                         items: &mut~[@ast::item]) {\n-    for cdirs.each |sub_cdir| {\n-        eval_crate_directive(cx, *sub_cdir, prefix, view_items, items);\n-    }\n-}\n-\n-pub fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                    prefix: &Path, suffix: &Option<Path>)\n-    -> (ast::_mod, ~[ast::attribute]) {\n-    let (cview_items, citems, cattrs)\n-        = parse_companion_mod(cx, prefix, suffix);\n-    let mut view_items: ~[@ast::view_item] = ~[];\n-    let mut items: ~[@ast::item] = ~[];\n-    eval_crate_directives(cx, cdirs, prefix, &mut view_items, &mut items);\n-    return ({view_items: vec::append(view_items, cview_items),\n-          items: vec::append(items, citems)},\n-         cattrs);\n-}\n-\n-/*\n-The 'companion mod'. So .rc crates and directory mod crate directives define\n-modules but not a .rs file to fill those mods with stuff. The companion mod is\n-a convention for location a .rs file to go with them.  For .rc files the\n-companion mod is a .rs file with the same name; for directory mods the\n-companion mod is a .rs file with the same name as the directory.\n-\n-We build the path to the companion mod by combining the prefix and the\n-optional suffix then adding the .rs extension.\n-*/\n-fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n-    -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n-\n-    fn companion_file(prefix: &Path, suffix: &Option<Path>) -> Path {\n-        return match *suffix {\n-          option::Some(s) => prefix.push_many(s.components),\n-          option::None => copy *prefix\n-        }.with_filetype(\"rs\");\n-    }\n-\n-    fn file_exists(path: &Path) -> bool {\n-        // Crude, but there's no lib function for this and I'm not\n-        // up to writing it just now\n-        match io::file_reader(path) {\n-          result::Ok(_) => true,\n-          result::Err(_) => false\n-        }\n-    }\n-\n-    let modpath = &companion_file(prefix, suffix);\n-    if file_exists(modpath) {\n-        debug!(\"found companion mod\");\n-        // XXX: Using a dummy span, but this code will go away soon\n-        let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n-                                          modpath,\n-                                          codemap::dummy_sp());\n-        let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let m0 = p0.parse_mod_items(token::EOF, next);\n-        return (m0.view_items, m0.items, inner);\n-    } else {\n-        return (~[], ~[], ~[]);\n-    }\n-}\n-\n-fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n-    match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-      Some(d) => d,\n-      None => default\n-    }\n-}\n-\n-pub fn eval_src_mod(cx: ctx, prefix: &Path,\n-                    outer_attrs: ~[ast::attribute],\n-                    id: ast::ident, sp: span)\n-                 -> (ast::item_, ~[ast::attribute]) {\n-    let file_path = Path(cdir_path_opt(\n-        cx.sess.interner.get(id) + ~\".rs\", outer_attrs));\n-    eval_src_mod_from_path(cx, prefix, &file_path, outer_attrs, sp)\n-}\n-\n-pub fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n-                              outer_attrs: ~[ast::attribute],\n-                              sp: span)\n-                           -> (ast::item_, ~[ast::attribute]) {\n-    let full_path = if path.is_absolute {\n-        copy *path\n-    } else {\n-        prefix.push_many(path.components)\n-    };\n-    let p0 =\n-        new_sub_parser_from_file(cx.sess, cx.cfg,\n-                                 &full_path, sp);\n-    let (inner, next) = p0.parse_inner_attrs_and_next();\n-    let mod_attrs = vec::append(outer_attrs, inner);\n-    let first_item_outer_attrs = next;\n-    let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n-    return (ast::item_mod(m0), mod_attrs);\n-}\n-\n-// XXX: Duplicated from parser.rs\n-fn mk_item(ctx: ctx, lo: BytePos, hi: BytePos, +ident: ast::ident,\n-           +node: ast::item_, vis: ast::visibility,\n-           +attrs: ~[ast::attribute]) -> @ast::item {\n-    return @{ident: ident,\n-             attrs: attrs,\n-             id: next_node_id(ctx.sess),\n-             node: node,\n-             vis: vis,\n-             span: mk_sp(lo, hi)};\n-}\n-\n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n-                        view_items: &mut ~[@ast::view_item],\n-                        items: &mut ~[@ast::item]) {\n-    match cdir.node {\n-      ast::cdir_src_mod(vis, id, attrs) => {\n-        let (m, mod_attrs) = eval_src_mod(cx, prefix, attrs, id, cdir.span);\n-        let i = mk_item(cx, cdir.span.lo, cdir.span.hi,\n-                           /* FIXME (#2543) */ copy id,\n-                           m, vis, mod_attrs);\n-        items.push(i);\n-      }\n-      ast::cdir_dir_mod(vis, id, cdirs, attrs) => {\n-        let path = Path(cdir_path_opt(*cx.sess.interner.get(id), attrs));\n-        let full_path = if path.is_absolute {\n-            copy path\n-        } else {\n-            prefix.push_many(path.components)\n-        };\n-        let (m0, a0) = eval_crate_directives_to_mod(\n-            cx, cdirs, &full_path, &None);\n-        let i =\n-            @{ident: /* FIXME (#2543) */ copy id,\n-              attrs: vec::append(attrs, a0),\n-              id: cx.sess.next_id,\n-              node: ast::item_mod(m0),\n-              vis: vis,\n-              span: cdir.span};\n-        cx.sess.next_id += 1;\n-        items.push(i);\n-      }\n-      ast::cdir_view_item(vi) => view_items.push(vi),\n-    }\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}]}