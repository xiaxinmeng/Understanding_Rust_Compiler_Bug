{"sha": "8e61ca4acc5aa4089847d220921da529882f5807", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNjFjYTRhY2M1YWE0MDg5ODQ3ZDIyMDkyMWRhNTI5ODgyZjU4MDc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-31T04:27:39Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-03T23:39:10Z"}, "message": "Refactor resolve_item_in_lexical_scope", "tree": {"sha": "bf916473a44a004141bcbb804e094765bf87e305", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf916473a44a004141bcbb804e094765bf87e305"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e61ca4acc5aa4089847d220921da529882f5807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e61ca4acc5aa4089847d220921da529882f5807", "html_url": "https://github.com/rust-lang/rust/commit/8e61ca4acc5aa4089847d220921da529882f5807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e61ca4acc5aa4089847d220921da529882f5807/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "298346dd5bf8211e879ef6750398a1e7d1226c7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/298346dd5bf8211e879ef6750398a1e7d1226c7e", "html_url": "https://github.com/rust-lang/rust/commit/298346dd5bf8211e879ef6750398a1e7d1226c7e"}], "stats": {"total": 74, "additions": 18, "deletions": 56}, "files": [{"sha": "0d629fd05375f32c9c8289dafd46765bfbc96613", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 56, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8e61ca4acc5aa4089847d220921da529882f5807/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e61ca4acc5aa4089847d220921da529882f5807/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8e61ca4acc5aa4089847d220921da529882f5807", "patch": "@@ -1423,47 +1423,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                namespace,\n                module_to_string(&*module_));\n \n-        // The current module node is handled specially. First, check for\n-        // its immediate children.\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n-\n-        if let Some(binding) = module_.get_child(name, namespace) {\n-            debug!(\"top name bindings succeeded\");\n-            return Success((Target::new(module_, binding, Shadowable::Never), false));\n-        }\n+        // Proceed up the scope chain looking for parent modules.\n+        let mut search_module = module_;\n+        loop {\n+            // Resolve the name in the parent module.\n+            match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n+                Failed(Some((span, msg))) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                }\n+                Failed(None) => (), // Continue up the search chain.\n+                Indeterminate => {\n+                    // We couldn't see through the higher scope because of an\n+                    // unresolved import higher up. Bail.\n \n-        // Now check for its import directives. We don't have to have resolved\n-        // all its imports in the usual way; this is because chains of\n-        // adjacent import statements are processed as though they mutated the\n-        // current scope.\n-        if let Some(import_resolution) =\n-            module_.import_resolutions.borrow().get(&(name, namespace)) {\n-            match import_resolution.target.clone() {\n-                None => {\n-                    // Not found; continue.\n-                    debug!(\"(resolving item in lexical scope) found import resolution, but not \\\n-                            in namespace {:?}\",\n-                           namespace);\n+                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n+                    return Indeterminate;\n                 }\n-                Some(target) => {\n-                    debug!(\"(resolving item in lexical scope) using import resolution\");\n-                    // track used imports and extern crates as well\n-                    let id = import_resolution.id;\n-                    if record_used {\n-                        self.used_imports.insert((id, namespace));\n-                        self.record_import_use(id, name);\n-                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n-                            self.used_crates.insert(kid);\n-                        }\n-                    }\n-                    return Success((target, false));\n+                Success((target, used_reexport)) => {\n+                    // We found the module.\n+                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n+                    return Success((target, used_reexport));\n                 }\n             }\n-        }\n \n-        // Finally, proceed up the scope chain looking for parent modules.\n-        let mut search_module = module_;\n-        loop {\n             // Go to the next parent.\n             match search_module.parent_link {\n                 NoParentLink => {\n@@ -1485,26 +1467,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     search_module = parent_module_node;\n                 }\n             }\n-\n-            // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n-                Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n-                }\n-                Failed(None) => (), // Continue up the search chain.\n-                Indeterminate => {\n-                    // We couldn't see through the higher scope because of an\n-                    // unresolved import higher up. Bail.\n-\n-                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n-                    return Indeterminate;\n-                }\n-                Success((target, used_reexport)) => {\n-                    // We found the module.\n-                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success((target, used_reexport));\n-                }\n-            }\n         }\n     }\n "}]}