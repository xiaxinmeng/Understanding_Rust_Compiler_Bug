{"sha": "e2d923ac3b138bb69511bb1f6212633ca14e61ee", "node_id": "C_kwDOAAsO6NoAKGUyZDkyM2FjM2IxMzhiYjY5NTExYmIxZjYyMTI2MzNjYTE0ZTYxZWU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-07T21:58:30Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-30T11:55:13Z"}, "message": "Store all generic bounds as where predicates.", "tree": {"sha": "b452345ec5ba768b02e8647979b51687009c4700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b452345ec5ba768b02e8647979b51687009c4700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2d923ac3b138bb69511bb1f6212633ca14e61ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d923ac3b138bb69511bb1f6212633ca14e61ee", "html_url": "https://github.com/rust-lang/rust/commit/e2d923ac3b138bb69511bb1f6212633ca14e61ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2d923ac3b138bb69511bb1f6212633ca14e61ee/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67241bb03ca83e132efbce8deffe5ca3438dd529", "url": "https://api.github.com/repos/rust-lang/rust/commits/67241bb03ca83e132efbce8deffe5ca3438dd529", "html_url": "https://github.com/rust-lang/rust/commit/67241bb03ca83e132efbce8deffe5ca3438dd529"}], "stats": {"total": 84, "additions": 41, "deletions": 43}, "files": [{"sha": "662a561f171e91c49450f05d4818ff68ce973531", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=e2d923ac3b138bb69511bb1f6212633ca14e61ee", "patch": "@@ -139,28 +139,35 @@ fn check_fn_inner<'tcx>(\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n-        for bound in typ.bounds {\n-            let mut visitor = RefVisitor::new(cx);\n-            walk_param_bound(&mut visitor, bound);\n-            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n-                return;\n+        for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n+            if pred.in_where_clause {\n+                // has_where_lifetimes checked that this predicate contains no lifetime.\n+                continue;\n             }\n-            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n-                let params = &trait_ref\n-                    .trait_ref\n-                    .path\n-                    .segments\n-                    .last()\n-                    .expect(\"a path must have at least one segment\")\n-                    .args;\n-                if let Some(params) = *params {\n-                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n-                        _ => None,\n-                    });\n-                    for bound in lifetimes {\n-                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n-                            return;\n+\n+            for bound in pred.bounds {\n+                let mut visitor = RefVisitor::new(cx);\n+                walk_param_bound(&mut visitor, bound);\n+                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                    return;\n+                }\n+                if let GenericBound::Trait(ref trait_ref, _) = *bound {\n+                    let params = &trait_ref\n+                        .trait_ref\n+                        .path\n+                        .segments\n+                        .last()\n+                        .expect(\"a path must have at least one segment\")\n+                        .args;\n+                    if let Some(params) = *params {\n+                        let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        for bound in lifetimes {\n+                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -322,9 +329,7 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n-            if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n-            }\n+            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);"}, {"sha": "3d1b2ee925bcebfd9d5511895d51e7ebf1f8c987", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=e2d923ac3b138bb69511bb1f6212633ca14e61ee", "patch": "@@ -8,8 +8,7 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, ParamName, Path, PathSegment, QPath, TraitItem, Ty, TyKind,\n-    WherePredicate,\n+    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, QPath, TraitItem, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -219,30 +218,19 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         return;\n     }\n \n-    let mut map = FxHashMap::default();\n-    for param in gen.params {\n-        if let ParamName::Plain(ref ident) = param.name {\n-            let res = param\n-                .bounds\n-                .iter()\n-                .filter_map(get_trait_info_from_bound)\n-                .collect::<Vec<_>>();\n-            map.insert(*ident, res);\n-        }\n-    }\n-\n+    let mut map = FxHashMap::<_, Vec<_>>::default();\n     for predicate in gen.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n-            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {\n-                for (res_where, _,  _) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    if let Some((_, _, span_direct)) = trait_resolutions_direct\n+                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n+                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n                                                 .iter()\n-                                                .find(|(res_direct, _, _)| *res_direct == res_where) {\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n@@ -252,6 +240,9 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n                             \"consider removing this trait bound\",\n                         );\n                     }\n+                    else {\n+                        trait_resolutions_direct.push((res_where, span_where))\n+                    }\n                 }\n             }\n         }"}, {"sha": "f35f44eda5679fb34f365965dac7433983875010", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d923ac3b138bb69511bb1f6212633ca14e61ee/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=e2d923ac3b138bb69511bb1f6212633ca14e61ee", "patch": "@@ -104,8 +104,10 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic;\n+        if let Some(generics) = cx.tcx.hir().get_generics(id.owner);\n+        if let Some(pred) = generics.bounds_for_param(did.expect_local()).next();\n         then {\n-            Some(generic_param.bounds)\n+            Some(pred.bounds)\n         } else {\n             None\n         }"}]}