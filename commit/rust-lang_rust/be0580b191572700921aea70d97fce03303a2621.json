{"sha": "be0580b191572700921aea70d97fce03303a2621", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDU4MGIxOTE1NzI3MDA5MjFhZWE3MGQ5N2ZjZTAzMzAzYTI2MjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-05T03:51:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-05T17:40:06Z"}, "message": "Solve some nasty deschedulinging races with a lock\n\nRight now, as pointed out in #8132, it is very easy to introduce a subtle race\nin the runtime. I believe that this is the cause of the current flakiness on the\nbots.\n\nI have taken the last idea mentioned in that issue which is to use a lock around\ndescheduling and context switching in order to solve this race.\n\nCloses #8132", "tree": {"sha": "b994a61dac70efb9a2b1e489cc02f294a574a05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b994a61dac70efb9a2b1e489cc02f294a574a05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be0580b191572700921aea70d97fce03303a2621", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be0580b191572700921aea70d97fce03303a2621", "html_url": "https://github.com/rust-lang/rust/commit/be0580b191572700921aea70d97fce03303a2621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be0580b191572700921aea70d97fce03303a2621/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edb9e85ce2e3708abe3a81d9645054e3eab85395", "url": "https://api.github.com/repos/rust-lang/rust/commits/edb9e85ce2e3708abe3a81d9645054e3eab85395", "html_url": "https://github.com/rust-lang/rust/commit/edb9e85ce2e3708abe3a81d9645054e3eab85395"}], "stats": {"total": 53, "additions": 49, "deletions": 4}, "files": [{"sha": "8ba493030798266cb52649d7f4d849ee20b2339b", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be0580b191572700921aea70d97fce03303a2621/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0580b191572700921aea70d97fce03303a2621/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=be0580b191572700921aea70d97fce03303a2621", "patch": "@@ -27,8 +27,10 @@ use borrow::{to_uint};\n use cell::Cell;\n use rand::{XorShiftRng, Rng, Rand};\n use iter::range;\n+use unstable::mutex::Mutex;\n use vec::{OwnedVector};\n \n+\n /// A scheduler is responsible for coordinating the execution of Tasks\n /// on a single thread. The scheduler runs inside a slightly modified\n /// Rust Task. When not running this task is stored in the scheduler\n@@ -618,6 +620,12 @@ impl Scheduler {\n         unsafe {\n             let task: *mut Task = Local::unsafe_borrow();\n             (*task).sched.get_mut_ref().run_cleanup_job();\n+\n+            // See the comments in switch_running_tasks_and_then for why a lock\n+            // is acquired here. This is the resumption points and the \"bounce\"\n+            // that it is referring to.\n+            (*task).nasty_deschedule_lock.lock();\n+            (*task).nasty_deschedule_lock.unlock();\n         }\n     }\n \n@@ -671,6 +679,15 @@ impl Scheduler {\n     /// This passes a Scheduler pointer to the fn after the context switch\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n+    ///\n+    /// Note that if the closure provided relinquishes ownership of the\n+    /// BlockedTask, then it is possible for the task to resume execution before\n+    /// the closure has finished executing. This would naturally introduce a\n+    /// race if the closure and task shared portions of the environment.\n+    ///\n+    /// This situation is currently prevented, or in other words it is\n+    /// guaranteed that this function will not return before the given closure\n+    /// has returned.\n     pub fn deschedule_running_task_and_then(mut ~self,\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n@@ -682,10 +699,29 @@ impl Scheduler {\n \n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n                                          f: |&mut Scheduler, BlockedTask|) {\n-        // This is where we convert the BlockedTask-taking closure into one\n-        // that takes just a Task\n-        self.change_task_context(next_task, |sched, task| {\n-            f(sched, BlockedTask::block(task))\n+        // And here comes one of the sad moments in which a lock is used in a\n+        // core portion of the rust runtime. As always, this is highly\n+        // undesirable, so there's a good reason behind it.\n+        //\n+        // There is an excellent outline of the problem in issue #8132, and it's\n+        // summarized in that `f` is executed on a sched task, but its\n+        // environment is on the previous task. If `f` relinquishes ownership of\n+        // the BlockedTask, then it may introduce a race where `f` is using the\n+        // environment as well as the code after the 'deschedule' block.\n+        //\n+        // The solution we have chosen to adopt for now is to acquire a\n+        // task-local lock around this block. The resumption of the task in\n+        // context switching will bounce on the lock, thereby waiting for this\n+        // block to finish, eliminating the race mentioned above.\n+        //\n+        // To actually maintain a handle to the lock, we use an unsafe pointer\n+        // to it, but we're guaranteed that the task won't exit until we've\n+        // unlocked the lock so there's no worry of this memory going away.\n+        self.change_task_context(next_task, |sched, mut task| {\n+            let lock: *mut Mutex = &mut task.nasty_deschedule_lock;\n+            unsafe { (*lock).lock() }\n+            f(sched, BlockedTask::block(task));\n+            unsafe { (*lock).unlock() }\n         })\n     }\n "}, {"sha": "fd7fee9e2b405cba2cfb3858154a59a263106fe7", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be0580b191572700921aea70d97fce03303a2621/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0580b191572700921aea70d97fce03303a2621/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=be0580b191572700921aea70d97fce03303a2621", "patch": "@@ -37,6 +37,7 @@ use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use send_str::SendStr;\n use unstable::finally::Finally;\n+use unstable::mutex::Mutex;\n \n // The Task struct represents all state associated with a rust\n // task. There are at this point two primary \"subtypes\" of task,\n@@ -59,6 +60,9 @@ pub struct Task {\n     // Dynamic borrowck debugging info\n     borrow_list: Option<~[BorrowRecord]>,\n     stdout_handle: Option<~Writer>,\n+\n+    // See the comments in the scheduler about why this is necessary\n+    nasty_deschedule_lock: Mutex,\n }\n \n pub enum TaskType {\n@@ -193,6 +197,7 @@ impl Task {\n             task_type: SchedTask,\n             borrow_list: None,\n             stdout_handle: None,\n+            nasty_deschedule_lock: unsafe { Mutex::new() },\n         }\n     }\n \n@@ -227,6 +232,7 @@ impl Task {\n             task_type: GreenTask(Some(home)),\n             borrow_list: None,\n             stdout_handle: None,\n+            nasty_deschedule_lock: unsafe { Mutex::new() },\n         }\n     }\n \n@@ -249,6 +255,7 @@ impl Task {\n             task_type: GreenTask(Some(home)),\n             borrow_list: None,\n             stdout_handle: None,\n+            nasty_deschedule_lock: unsafe { Mutex::new() },\n         }\n     }\n \n@@ -391,6 +398,8 @@ impl Drop for Task {\n     fn drop(&mut self) {\n         rtdebug!(\"called drop for a task: {}\", borrow::to_uint(self));\n         rtassert!(self.destroyed);\n+\n+        unsafe { self.nasty_deschedule_lock.destroy(); }\n     }\n }\n "}]}