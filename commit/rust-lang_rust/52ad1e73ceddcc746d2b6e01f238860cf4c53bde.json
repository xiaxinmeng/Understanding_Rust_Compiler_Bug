{"sha": "52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYWQxZTczY2VkZGNjNzQ2ZDJiNmUwMWYyMzg4NjBjZjRjNTNiZGU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-28T20:06:06Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-28T20:07:20Z"}, "message": "Don't bug when taking discriminant of generator", "tree": {"sha": "f7950c5c2e73b6949486a7a502436283e9e5d1c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7950c5c2e73b6949486a7a502436283e9e5d1c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "html_url": "https://github.com/rust-lang/rust/commit/52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52ad1e73ceddcc746d2b6e01f238860cf4c53bde/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0", "html_url": "https://github.com/rust-lang/rust/commit/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0"}], "stats": {"total": 126, "additions": 72, "deletions": 54}, "files": [{"sha": "f223c2ec4d19b71165cb3b6b908810bf935d99ca", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/52ad1e73ceddcc746d2b6e01f238860cf4c53bde/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ad1e73ceddcc746d2b6e01f238860cf4c53bde/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "patch": "@@ -239,14 +239,24 @@ where\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, .. } => {\n-                self.propagate_bits_into_switch_int_successors(\n-                    in_out,\n-                    (bb, bb_data),\n-                    dirty_list,\n-                    discr,\n-                    &*values,\n-                    &*targets,\n-                );\n+                // If this is a switch on an enum discriminant, a custom effect may be applied\n+                // along each outgoing edge.\n+                if let Some(place) = discr.place() {\n+                    let enum_def = switch_on_enum_discriminant(self.tcx, self.body, bb_data, place);\n+                    if let Some(enum_def) = enum_def {\n+                        self.propagate_bits_into_enum_discriminant_switch_successors(\n+                            in_out, bb, enum_def, place, dirty_list, &*values, &*targets,\n+                        );\n+\n+                        return;\n+                    }\n+                }\n+\n+                // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n+                // exit state.\n+                for target in targets.iter().copied() {\n+                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n+                }\n             }\n \n             Call { cleanup, ref destination, ref func, ref args, .. } => {\n@@ -293,64 +303,72 @@ where\n         }\n     }\n \n-    fn propagate_bits_into_switch_int_successors(\n+    fn propagate_bits_into_enum_discriminant_switch_successors(\n         &mut self,\n         in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &mir::BasicBlockData<'tcx>),\n+        bb: BasicBlock,\n+        enum_def: &'tcx ty::AdtDef,\n+        enum_place: &mir::Place<'tcx>,\n         dirty_list: &mut WorkQueue<BasicBlock>,\n-        switch_on: &mir::Operand<'tcx>,\n         values: &[u128],\n         targets: &[BasicBlock],\n     ) {\n-        match bb_data.statements.last().map(|stmt| &stmt.kind) {\n-            // Look at the last statement to see if it is an assignment of an enum discriminant to\n-            // the local that determines the target of a `SwitchInt` like so:\n-            //   _42 = discriminant(..)\n-            //   SwitchInt(_42, ..)\n-            Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(enum_))))\n-                if Some(lhs) == switch_on.place() =>\n-            {\n-                let adt = match enum_.ty(self.body, self.tcx).ty.kind {\n-                    ty::Adt(def, _) => def,\n-                    _ => bug!(\"Switch on discriminant of non-ADT\"),\n-                };\n-\n-                // MIR building adds discriminants to the `values` array in the same order as they\n-                // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                // discriminant in `values` to its corresponding variant in linear time.\n-                let mut tmp = BitSet::new_empty(in_out.domain_size());\n-                let mut discriminants = adt.discriminants(self.tcx);\n-                for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                    let (variant_idx, _) =\n-                        discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                            \"Order of `AdtDef::discriminants` differed \\\n-                                 from that of `SwitchInt::values`\",\n-                        );\n+        // MIR building adds discriminants to the `values` array in the same order as they\n+        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+        // discriminant in `values` to its corresponding variant in linear time.\n+        let mut tmp = BitSet::new_empty(in_out.domain_size());\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        for (value, target) in values.iter().zip(targets.iter().copied()) {\n+            let (variant_idx, _) = discriminants.find(|&(_, discr)| discr.val == *value).expect(\n+                \"Order of `AdtDef::discriminants` differed from that of `SwitchInt::values`\",\n+            );\n \n-                    tmp.overwrite(in_out);\n-                    self.analysis.apply_discriminant_switch_effect(\n-                        &mut tmp,\n-                        bb,\n-                        enum_,\n-                        adt,\n-                        variant_idx,\n-                    );\n-                    self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n-                }\n+            tmp.overwrite(in_out);\n+            self.analysis.apply_discriminant_switch_effect(\n+                &mut tmp,\n+                bb,\n+                enum_place,\n+                enum_def,\n+                variant_idx,\n+            );\n+            self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n+        }\n \n-                std::mem::drop(tmp);\n+        std::mem::drop(tmp);\n \n-                // Propagate dataflow state along the \"otherwise\" edge.\n-                let otherwise = targets.last().copied().unwrap();\n-                self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n-            }\n+        // Propagate dataflow state along the \"otherwise\" edge.\n+        let otherwise = targets.last().copied().unwrap();\n+        self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n+    }\n+}\n \n-            _ => {\n-                for target in targets.iter().copied() {\n-                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n-                }\n+/// Look at the last statement of a block that ends with  to see if it is an assignment of an enum\n+/// discriminant to the local that determines the target of a `SwitchInt` like so:\n+///   _42 = discriminant(..)\n+///   SwitchInt(_42, ..)\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mir::Body<'tcx>,\n+    block: &mir::BasicBlockData<'tcx>,\n+    switch_on: &mir::Place<'tcx>,\n+) -> Option<&'tcx ty::AdtDef> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind {\n+                ty::Adt(def, _) => Some(def),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n             }\n         }\n+\n+        _ => None,\n     }\n }\n "}]}