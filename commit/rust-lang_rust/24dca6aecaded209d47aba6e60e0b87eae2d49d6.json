{"sha": "24dca6aecaded209d47aba6e60e0b87eae2d49d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGNhNmFlY2FkZWQyMDlkNDdhYmE2ZTYwZTBiODdlYWUyZDQ5ZDY=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-09-10T12:40:12Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-09-11T09:27:12Z"}, "message": "Simplify Scope/ScopeData to have less chance of introducing UB or size increases", "tree": {"sha": "39726bfb02de0d85cc0acc0fd03fc0681c894b5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39726bfb02de0d85cc0acc0fd03fc0681c894b5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24dca6aecaded209d47aba6e60e0b87eae2d49d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24dca6aecaded209d47aba6e60e0b87eae2d49d6", "html_url": "https://github.com/rust-lang/rust/commit/24dca6aecaded209d47aba6e60e0b87eae2d49d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24dca6aecaded209d47aba6e60e0b87eae2d49d6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88ebb95f46c077baf165c9d2b174f90e5d369854", "url": "https://api.github.com/repos/rust-lang/rust/commits/88ebb95f46c077baf165c9d2b174f90e5d369854", "html_url": "https://github.com/rust-lang/rust/commit/88ebb95f46c077baf165c9d2b174f90e5d369854"}], "stats": {"total": 180, "additions": 77, "deletions": 103}, "files": [{"sha": "2bf1c79c8a43606dc5e0c120d359da8252e8f13c", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -772,7 +772,15 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n+impl_stable_hash_for!(struct ::middle::region::Scope { id, data });\n+\n+impl_stable_hash_for!(enum ::middle::region::ScopeData {\n+    Node,\n+    CallSite,\n+    Arguments,\n+    Destruction,\n+    Remainder(first_statement_index)\n+});\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n@@ -783,11 +791,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::region::BlockRemainder {\n-    block,\n-    first_statement_index\n-});\n-\n impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });"}, {"sha": "a0c96554c91f1d4046d0ac1206eaaca6f6852ad8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -119,17 +119,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n                 let scope_decorated_tag = match scope.data() {\n-                    region::ScopeData::Node(_) => tag,\n-                    region::ScopeData::CallSite(_) => \"scope of call-site for function\",\n-                    region::ScopeData::Arguments(_) => \"scope of function body\",\n-                    region::ScopeData::Destruction(_) => {\n+                    region::ScopeData::Node => tag,\n+                    region::ScopeData::CallSite => \"scope of call-site for function\",\n+                    region::ScopeData::Arguments => \"scope of function body\",\n+                    region::ScopeData::Destruction => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::ScopeData::Remainder(r) => {\n+                    region::ScopeData::Remainder(first_statement_index) => {\n                         new_string = format!(\n                             \"block suffix following statement {}\",\n-                            r.first_statement_index.index()\n+                            first_statement_index.index()\n                         );\n                         &new_string[..]\n                     }"}, {"sha": "6fa5d363ffa7a6426c3ed28a59ae6943446a9583", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -20,7 +20,6 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n-use std::fmt;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n use syntax::source_map;\n@@ -100,39 +99,29 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-///\n-/// Scope is a bit-packed to save space - if `code` is SCOPE_DATA_REMAINDER_MAX\n-/// or less, it is a `ScopeData::Remainder`, otherwise it is a type specified\n-/// by the bitpacking.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n     pub(crate) id: hir::ItemLocalId,\n-    pub(crate) code: u32\n+    pub(crate) data: ScopeData,\n }\n \n-const SCOPE_DATA_NODE: u32 = 0xFFFF_FFFF;\n-const SCOPE_DATA_CALLSITE: u32 = 0xFFFF_FFFE;\n-const SCOPE_DATA_ARGUMENTS: u32 = 0xFFFF_FFFD;\n-const SCOPE_DATA_DESTRUCTION: u32 = 0xFFFF_FFFC;\n-// be sure to add the MAX of FirstStatementIndex if you add more constants here\n-\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum ScopeData {\n-    Node(hir::ItemLocalId),\n+    Node,\n \n     // Scope of the call-site for a function or closure\n     // (outlives the arguments as well as the body).\n-    CallSite(hir::ItemLocalId),\n+    CallSite,\n \n     // Scope of arguments passed to a function or closure\n     // (they outlive its body).\n-    Arguments(hir::ItemLocalId),\n+    Arguments,\n \n     // Scope of destructors for temporaries of node-id.\n-    Destruction(hir::ItemLocalId),\n+    Destruction,\n \n     // Scope following a `let id = expr;` binding in a block.\n-    Remainder(BlockRemainder)\n+    Remainder(FirstStatementIndex)\n }\n \n /// Represents a subscope of `block` for a binding that is introduced\n@@ -152,81 +141,61 @@ pub enum ScopeData {\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-         RustcDecodable, Debug, Copy)]\n-pub struct BlockRemainder {\n-    pub block: hir::ItemLocalId,\n-    pub first_statement_index: FirstStatementIndex,\n-}\n \n newtype_index! {\n     pub struct FirstStatementIndex;\n }\n \n impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { private });\n \n-impl From<ScopeData> for Scope {\n-    #[inline]\n-    fn from(scope_data: ScopeData) -> Self {\n-        let (id, code) = match scope_data {\n-            ScopeData::Node(id) => (id, SCOPE_DATA_NODE),\n-            ScopeData::CallSite(id) => (id, SCOPE_DATA_CALLSITE),\n-            ScopeData::Arguments(id) => (id, SCOPE_DATA_ARGUMENTS),\n-            ScopeData::Destruction(id) => (id, SCOPE_DATA_DESTRUCTION),\n-            ScopeData::Remainder(r) => (r.block, r.first_statement_index.index() as u32)\n-        };\n-        Self { id, code }\n-    }\n-}\n-\n-impl fmt::Debug for Scope {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.data(), formatter)\n-    }\n-}\n+// compilation error if size of `ScopeData` is not the same as a `u32`\n+#[allow(dead_code)]\n+// only works on stage 1 when the rustc_layout_scalar_valid_range attribute actually exists\n+#[cfg(not(stage0))]\n+static ASSERT: () = [()][(mem::size_of::<ScopeData>() != 4) as usize];\n \n #[allow(non_snake_case)]\n impl Scope {\n     #[inline]\n     pub fn data(self) -> ScopeData {\n-        match self.code {\n-            SCOPE_DATA_NODE => ScopeData::Node(self.id),\n-            SCOPE_DATA_CALLSITE => ScopeData::CallSite(self.id),\n-            SCOPE_DATA_ARGUMENTS => ScopeData::Arguments(self.id),\n-            SCOPE_DATA_DESTRUCTION => ScopeData::Destruction(self.id),\n-            idx => ScopeData::Remainder(BlockRemainder {\n-                block: self.id,\n-                first_statement_index: FirstStatementIndex::new(idx as usize)\n-            })\n+        self.data\n         }\n+\n+    #[inline]\n+    pub fn new(id: hir::ItemLocalId, data: ScopeData) -> Self {\n+        Scope { id, data }\n     }\n \n     #[inline]\n     pub fn Node(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Node(id))\n+        Self::new(id, ScopeData::Node)\n     }\n \n     #[inline]\n     pub fn CallSite(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::CallSite(id))\n+        Self::new(id, ScopeData::CallSite)\n     }\n \n     #[inline]\n     pub fn Arguments(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Arguments(id))\n+        Self::new(id, ScopeData::Arguments)\n     }\n \n     #[inline]\n     pub fn Destruction(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Destruction(id))\n+        Self::new(id, ScopeData::Destruction)\n     }\n \n     #[inline]\n-    pub fn Remainder(r: BlockRemainder) -> Self {\n-        Self::from(ScopeData::Remainder(r))\n+    pub fn Remainder(\n+        id: hir::ItemLocalId,\n+        first: FirstStatementIndex,\n+    ) -> Self {\n+        Self::new(id, ScopeData::Remainder(first))\n     }\n }\n \n+\n impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n@@ -257,7 +226,7 @@ impl Scope {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let ScopeData::Remainder(r) = self.data() {\n+        if let ScopeData::Remainder(first_statement_index) = self.data() {\n             if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n@@ -267,7 +236,7 @@ impl Scope {\n                 // (This is the special case aluded to in the\n                 // doc-comment for this method)\n \n-                let stmt_span = blk.stmts[r.first_statement_index.index()].span;\n+                let stmt_span = blk.stmts[first_statement_index.index()].span;\n \n                 // To avoid issues with macro-generated spans, the span\n                 // of the statement must be nested in that of the block.\n@@ -511,8 +480,8 @@ impl<'tcx> ScopeTree {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let ScopeData::Destruction(n) = child.data() {\n-            self.destruction_scopes.insert(n, child);\n+        if let ScopeData::Destruction = child.data() {\n+            self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n     }\n \n@@ -595,7 +564,7 @@ impl<'tcx> ScopeTree {\n \n         while let Some(&(p, _)) = self.parent_map.get(&id) {\n             match p.data() {\n-                ScopeData::Destruction(..) => {\n+                ScopeData::Destruction => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -650,8 +619,8 @@ impl<'tcx> ScopeTree {\n     /// Returns the id of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope)-> Option<hir::ItemLocalId> {\n         loop {\n-            if let ScopeData::CallSite(id) = scope.data() {\n-                return Some(id);\n+            if let ScopeData::CallSite = scope.data() {\n+                return Some(scope.item_local_id());\n             }\n \n             match self.opt_encl_scope(scope) {\n@@ -867,10 +836,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n                 visitor.enter_scope(\n-                    Scope::Remainder(BlockRemainder {\n-                        block: blk.hir_id.local_id,\n-                        first_statement_index: FirstStatementIndex::new(i)\n-                    })\n+                    Scope::Remainder(blk.hir_id.local_id, FirstStatementIndex::new(i))\n                 );\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n@@ -1033,7 +999,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n                 Some(&(superscope, _)) => match superscope.data() {\n-                    ScopeData::CallSite(_) => break,\n+                    ScopeData::CallSite => break,\n                     _ => scope = superscope\n                 },\n                 None => break"}, {"sha": "1206690c86e24dd6bf2044ff61521bd41711d166", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n use mir::interpret::ConstValue;\n-use middle::region::{self, BlockRemainder};\n+use middle::region;\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{Bool, Char, Adt};\n@@ -770,17 +770,20 @@ define_print! {\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n                     match scope.data() {\n-                        region::ScopeData::Node(id) =>\n-                            write!(f, \"'{}s\", id.as_usize()),\n-                        region::ScopeData::CallSite(id) =>\n-                            write!(f, \"'{}cs\", id.as_usize()),\n-                        region::ScopeData::Arguments(id) =>\n-                            write!(f, \"'{}as\", id.as_usize()),\n-                        region::ScopeData::Destruction(id) =>\n-                            write!(f, \"'{}ds\", id.as_usize()),\n-                        region::ScopeData::Remainder(BlockRemainder\n-                                                     { block, first_statement_index }) =>\n-                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                        region::ScopeData::Node =>\n+                            write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::CallSite =>\n+                            write!(f, \"'{}cs\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Arguments =>\n+                            write!(f, \"'{}as\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Destruction =>\n+                            write!(f, \"'{}ds\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Remainder(first_statement_index) => write!(\n+                            f,\n+                            \"'{}_{}rs\",\n+                            scope.item_local_id().as_usize(),\n+                            first_statement_index.index()\n+                        ),\n                     }\n                 }\n                 ty::ReVar(region_vid) if cx.identify_regions => {"}, {"sha": "2f11fea46d69a6c6db09c10ea0a5c0d32e4a6546", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -72,7 +72,8 @@ macro_rules! newtype_index {\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @type         [$name]\n-            @max          [0xFFFF_FFFE]\n+            // shave off 256 indices at the end to allow space for packing these indices into enums\n+            @max          [0xFFFF_FF00]\n             @vis          [$v]\n             @debug_format [\"{}\"]);\n     );\n@@ -82,7 +83,8 @@ macro_rules! newtype_index {\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @type         [$name]\n-            @max          [0xFFFF_FFFE]\n+            // shave off 256 indices at the end to allow space for packing these indices into enums\n+            @max          [0xFFFF_FF00]\n             @vis          [$v]\n             @debug_format [\"{}\"]\n                           $($tokens)+);"}, {"sha": "d46b0813ca703e840c6fb4331fbd470a78e5bc79", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> CFG<'tcx> {\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n         if tcx.emit_end_regions() {\n-            if let region::ScopeData::CallSite(_) = region_scope.data() {\n+            if let region::ScopeData::CallSite = region_scope.data() {\n                 // The CallSite scope (aka the root scope) is sort of weird, in that it is\n                 // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n                 // that, it is not really a part of the region hierarchy, but for some"}, {"sha": "1406183955bd430ce962fc556893714165d9d557", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n         assert!(match self.scopes[1].region_scope.data() {\n-            region::ScopeData::Arguments(_) => true,\n+            region::ScopeData::Arguments => true,\n             _ => false,\n         });\n         self.scopes[1].region_scope"}, {"sha": "730603dff56ff7d1f19f77974c5b28b7b8623c69", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dca6aecaded209d47aba6e60e0b87eae2d49d6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=24dca6aecaded209d47aba6e60e0b87eae2d49d6", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n-use rustc::middle::region::{self, BlockRemainder};\n+use rustc::middle::region;\n use rustc::hir;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -71,10 +71,10 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclKind::Local(ref local) => {\n-                        let remainder_scope = region::Scope::Remainder(BlockRemainder {\n-                            block: block_id,\n-                            first_statement_index: region::FirstStatementIndex::new(index),\n-                        });\n+                        let remainder_scope = region::Scope::Remainder(\n+                            block_id,\n+                            region::FirstStatementIndex::new(index),\n+                        );\n \n                         let ty = local.ty.clone().map(|ty| ty.hir_id);\n                         let pattern = cx.pattern_from_hir(&local.pat);"}]}