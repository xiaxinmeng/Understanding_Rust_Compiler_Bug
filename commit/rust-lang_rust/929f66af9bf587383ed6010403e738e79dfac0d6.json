{"sha": "929f66af9bf587383ed6010403e738e79dfac0d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOWY2NmFmOWJmNTg3MzgzZWQ2MDEwNDAzZTczOGU3OWRmYWMwZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-02T09:52:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-02T09:52:26Z"}, "message": "Auto merge of #80115 - tgnottingham:specialize_opaque_u8_sequences, r=oli-obk\n\nrustc_serialize: specialize opaque encoding and decoding of some u8 sequences\n\nThis specializes encoding and decoding of some contiguous u8 sequences to use a more efficient implementation. The default implementations process each u8 individually, but that isn't necessary for the opaque encoder and decoder. The opaque encoding for u8s is a no-op, so we can just copy entire sequences as-is, rather than process them byte by byte.\n\nThis also changes some encode and decode implementations for contiguous sequences to forward to the slice and vector implementations, so that they can take advantage of the new specialization when applicable.", "tree": {"sha": "5e2e74e91f1eb6ba9f4a4d119c79d6c011abd611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2e74e91f1eb6ba9f4a4d119c79d6c011abd611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/929f66af9bf587383ed6010403e738e79dfac0d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/929f66af9bf587383ed6010403e738e79dfac0d6", "html_url": "https://github.com/rust-lang/rust/commit/929f66af9bf587383ed6010403e738e79dfac0d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/929f66af9bf587383ed6010403e738e79dfac0d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5986dd878f3e432025eb1946149e3241d3998b1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5986dd878f3e432025eb1946149e3241d3998b1b", "html_url": "https://github.com/rust-lang/rust/commit/5986dd878f3e432025eb1946149e3241d3998b1b"}, {"sha": "be79f493fb310b3a6b01ceada32713813bb12a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/be79f493fb310b3a6b01ceada32713813bb12a91", "html_url": "https://github.com/rust-lang/rust/commit/be79f493fb310b3a6b01ceada32713813bb12a91"}], "stats": {"total": 131, "additions": 84, "deletions": 47}, "files": [{"sha": "8afe94ac8dba845679f30ed04bae4b2128317dde", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -4,7 +4,7 @@ use rustc_serialize::{\n     Decodable, Encodable,\n };\n use std::hash::{Hash, Hasher};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy)]\n pub struct Fingerprint(u64, u64);\n@@ -61,7 +61,7 @@ impl Fingerprint {\n     }\n \n     pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {\n-        let mut bytes = [0; 16];\n+        let mut bytes: [MaybeUninit<u8>; 16] = MaybeUninit::uninit_array();\n \n         decoder.read_raw_bytes(&mut bytes)?;\n "}, {"sha": "72bd4804e98c0b81e4f5e20a6228db87f74e07a6", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -203,7 +203,7 @@ fn encodable_body(\n                                 #field_name,\n                                 #field_idx,\n                                 |__encoder|\n-                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)\n@@ -237,7 +237,7 @@ fn encodable_body(\n                                 __encoder,\n                                 #field_idx,\n                                 |__encoder|\n-                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                                ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n                                 ::std::result::Result::Ok(()) => (),\n                                 ::std::result::Result::Err(__err)"}, {"sha": "9b40c9a7ed88ad42a7f2cf9942787af37e61e5b5", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -807,6 +807,15 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n \n crate::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n+// This ensures that the `Decodable<opaque::Decoder>::decode` specialization for `Vec<u8>` is used\n+// when a `CacheDecoder` is passed to `Decodable::decode`. Unfortunately, we have to manually opt\n+// into specializations this way, given how `CacheDecoder` and the decoding traits currently work.\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Vec<u8> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        Decodable::decode(&mut d.opaque)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n     fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         let syntax_contexts = decoder.syntax_contexts;\n@@ -1149,6 +1158,16 @@ where\n     }\n }\n \n+// This ensures that the `Encodable<opaque::Encoder>::encode` specialization for byte slices\n+// is used when a `CacheEncoder` having an `opaque::Encoder` is passed to `Encodable::encode`.\n+// Unfortunately, we have to manually opt into specializations this way, given how `CacheEncoder`\n+// and the encoding traits currently work.\n+impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx, opaque::Encoder>> for [u8] {\n+    fn encode(&self, e: &mut CacheEncoder<'a, 'tcx, opaque::Encoder>) -> opaque::EncodeResult {\n+        self.encode(e.encoder)\n+    }\n+}\n+\n // An integer that will always encode to 8 bytes.\n struct IntEncodedWithFixedSize(u64);\n "}, {"sha": "ae6d27e037b2dbda7a1f66ffa7712a4c0de77381", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 10, "deletions": 32, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -11,12 +11,8 @@ use smallvec::{Array, SmallVec};\n \n impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        let slice: &[A::Item] = self;\n+        slice.encode(s)\n     }\n }\n \n@@ -292,46 +288,28 @@ where\n \n impl<E: Encoder, T: Encodable<E>> Encodable<E> for Rc<[T]> {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (index, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(index, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        let slice: &[T] = self;\n+        slice.encode(s)\n     }\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<[T]> {\n     fn decode(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut vec = Vec::with_capacity(len);\n-            for index in 0..len {\n-                vec.push(d.read_seq_elt(index, |d| Decodable::decode(d))?);\n-            }\n-            Ok(vec.into())\n-        })\n+        let vec: Vec<T> = Decodable::decode(d)?;\n+        Ok(vec.into())\n     }\n }\n \n impl<E: Encoder, T: Encodable<E>> Encodable<E> for Arc<[T]> {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (index, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(index, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n+        let slice: &[T] = self;\n+        slice.encode(s)\n     }\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<[T]> {\n     fn decode(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut vec = Vec::with_capacity(len);\n-            for index in 0..len {\n-                vec.push(d.read_seq_elt(index, |d| Decodable::decode(d))?);\n-            }\n-            Ok(vec.into())\n-        })\n+        let vec: Vec<T> = Decodable::decode(d)?;\n+        Ok(vec.into())\n     }\n }"}, {"sha": "f58ed14d9971e09103241349f806c83484c8f162", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -14,6 +14,8 @@ Core encoding and decoding interfaces.\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n #![cfg_attr(bootstrap, feature(min_const_generics))]\n+#![feature(min_specialization)]\n+#![feature(vec_spare_capacity)]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]\n "}, {"sha": "673742df7f0dce75c3e99508075c1813e448becd", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -1,6 +1,8 @@\n use crate::leb128::{self, read_signed_leb128, write_signed_leb128};\n use crate::serialize;\n use std::borrow::Cow;\n+use std::mem::MaybeUninit;\n+use std::ptr;\n \n // -----------------------------------------------------------------------------\n // Encoder\n@@ -179,11 +181,19 @@ impl<'a> Decoder<'a> {\n     }\n \n     #[inline]\n-    pub fn read_raw_bytes(&mut self, s: &mut [u8]) -> Result<(), String> {\n+    pub fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), String> {\n         let start = self.position;\n         let end = start + s.len();\n+        assert!(end <= self.data.len());\n \n-        s.copy_from_slice(&self.data[start..end]);\n+        // SAFETY: Both `src` and `dst` point to at least `s.len()` elements:\n+        // `src` points to at least `s.len()` elements by above assert, and\n+        // `dst` points to `s.len()` elements by derivation from `s`.\n+        unsafe {\n+            let src = self.data.as_ptr().add(start);\n+            let dst = s.as_mut_ptr() as *mut u8;\n+            ptr::copy_nonoverlapping(src, dst, s.len());\n+        }\n \n         self.position = end;\n \n@@ -316,3 +326,36 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         err.to_string()\n     }\n }\n+\n+// Specializations for contiguous byte sequences follow. The default implementations for slices\n+// encode and decode each element individually. This isn't necessary for `u8` slices when using\n+// opaque encoders and decoders, because each `u8` is unchanged by encoding and decoding.\n+// Therefore, we can use more efficient implementations that process the entire sequence at once.\n+\n+// Specialize encoding byte slices. This specialization also applies to encoding `Vec<u8>`s, etc.,\n+// since the default implementations call `encode` on their slices internally.\n+impl serialize::Encodable<Encoder> for [u8] {\n+    fn encode(&self, e: &mut Encoder) -> EncodeResult {\n+        serialize::Encoder::emit_usize(e, self.len())?;\n+        e.emit_raw_bytes(self);\n+        Ok(())\n+    }\n+}\n+\n+// Specialize decoding `Vec<u8>`. This specialization also applies to decoding `Box<[u8]>`s, etc.,\n+// since the default implementations call `decode` to produce a `Vec<u8>` internally.\n+impl<'a> serialize::Decodable<Decoder<'a>> for Vec<u8> {\n+    fn decode(d: &mut Decoder<'a>) -> Result<Self, String> {\n+        let len = serialize::Decoder::read_usize(d)?;\n+\n+        let mut v = Vec::with_capacity(len);\n+        let buf = &mut v.spare_capacity_mut()[..len];\n+        d.read_raw_bytes(buf)?;\n+\n+        unsafe {\n+            v.set_len(len);\n+        }\n+\n+        Ok(v)\n+    }\n+}"}, {"sha": "47aad5b88c6229dc5532f820c575007354af80b1", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929f66af9bf587383ed6010403e738e79dfac0d6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=929f66af9bf587383ed6010403e738e79dfac0d6", "patch": "@@ -527,7 +527,7 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n }\n \n impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+    default fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -545,7 +545,7 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n-    fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n+    default fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n@@ -591,13 +591,8 @@ where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n     fn decode(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for i in 0..len {\n-                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-            }\n-            Ok(Cow::Owned(v))\n-        })\n+        let v: Vec<T> = Decodable::decode(d)?;\n+        Ok(Cow::Owned(v))\n     }\n }\n "}]}