{"sha": "0ede2ea4e2e9384ac5bd614012d85ed213873dab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZGUyZWE0ZTJlOTM4NGFjNWJkNjE0MDEyZDg1ZWQyMTM4NzNkYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-10T11:31:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-10T11:31:24Z"}, "message": "auto merge of #9749 : alexcrichton/rust/less-io, r=brson\n\nThis implements a number of the baby steps needed to start eliminating everything inside of `std::io`. It turns out that there are a *lot* of users of that module, so I'm going to try to tackle them separately instead of bringing down the whole system all at once.\r\n\r\nThis pull implements a large amount of unimplemented functionality inside of `std::rt::io` including:\r\n\r\n* Native file I/O (file descriptors, *FILE)\r\n* Native stdio (through the native file descriptors)\r\n* Native processes (extracted from `std::run`)\r\n\r\nI also found that there are a number of users of `std::io` which desire to read an input line-by-line, so I added an implementation of `read_until` and `read_line` to `BufferedReader`.\r\n\r\nWith all of these changes in place, I started to axe various usages of `std::io`. There's a lot of one-off uses here-and-there, but the major use-case remaining that doesn't have a fantastic solution is `extra::json`. I ran into a few compiler bugs when attempting to remove that, so I figured I'd come back to it later instead. \r\n\r\nThere is one fairly major change in this pull, and it's moving from native stdio to uv stdio via `print` and `println`. Unfortunately logging still goes through native I/O (via `dumb_println`). This is going to need some thinking, because I still want the goal of logging/printing to be 0 allocations, and this is not possible if `io::stdio::stderr()` is called on each log message. Instead I think that this may need to be cached as the `logger` field inside the `Task` struct, but that will require a little more workings to get right (this is also a similar problem for print/println, do we cache `stdout()` to not have to re-create it every time?).", "tree": {"sha": "1c1273aa2aabe17e0557c01b41d4d438c5dd130e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c1273aa2aabe17e0557c01b41d4d438c5dd130e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ede2ea4e2e9384ac5bd614012d85ed213873dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ede2ea4e2e9384ac5bd614012d85ed213873dab", "html_url": "https://github.com/rust-lang/rust/commit/0ede2ea4e2e9384ac5bd614012d85ed213873dab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ede2ea4e2e9384ac5bd614012d85ed213873dab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d123db4eb03c1b2378b6248ebea5f0f40f2a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d123db4eb03c1b2378b6248ebea5f0f40f2a4f", "html_url": "https://github.com/rust-lang/rust/commit/34d123db4eb03c1b2378b6248ebea5f0f40f2a4f"}, {"sha": "413747176c9ce52a87775175e096b3eca88e6b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/413747176c9ce52a87775175e096b3eca88e6b64", "html_url": "https://github.com/rust-lang/rust/commit/413747176c9ce52a87775175e096b3eca88e6b64"}], "stats": {"total": 2386, "additions": 1382, "deletions": 1004}, "files": [{"sha": "e49a9701460b0eff721ffe3ae9c4e595949cf2e3", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -8,24 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n+    use std::rt::io::Open;\n+    use std::rt::io::file::FileInfo;\n+    use std::rt::io::buffered::BufferedReader;\n+\n     let mut error_patterns = ~[];\n-    let rdr = io::file_reader(testfile).unwrap();\n+    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n     let mut line_num = 1u;\n-    while !rdr.eof() {\n-        let ln = rdr.read_line();\n+    loop {\n+        let ln = match rdr.read_line() {\n+            Some(ln) => ln, None => break,\n+        };\n         error_patterns.push_all_move(parse_expected(line_num, ln));\n         line_num += 1u;\n     }\n     return error_patterns;\n }\n \n fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n+    let line = line.trim();\n     let error_tag = ~\"//~\";\n     let mut idx;\n     match line.find_str(error_tag) {"}, {"sha": "730df66af23e6ea6b80efa2694b9aa24491c95f2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -12,8 +12,6 @@ use common::config;\n use common;\n use util;\n \n-use std::io;\n-\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     error_patterns: ~[~str],\n@@ -104,17 +102,23 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     !val\n }\n \n-fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n-    let rdr = io::file_reader(testfile).unwrap();\n-    while !rdr.eof() {\n-        let ln = rdr.read_line();\n+fn iter_header(testfile: &Path, it: &fn(&str) -> bool) -> bool {\n+    use std::rt::io::Open;\n+    use std::rt::io::file::FileInfo;\n+    use std::rt::io::buffered::BufferedReader;\n+\n+    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n+    loop {\n+        let ln = match rdr.read_line() {\n+            Some(ln) => ln, None => break\n+        };\n \n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return true;\n-        } else { if !(it(ln)) { return false; } }\n+        } else { if !(it(ln.trim())) { return false; } }\n     }\n     return true;\n }"}, {"sha": "829916117d2667142d41d6a242970398da1b650f", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -57,7 +57,7 @@ pub fn run(lib_path: &str,\n     });\n \n     for input in input.iter() {\n-        proc.input().write_str(*input);\n+        proc.input().write(input.as_bytes());\n     }\n     let output = proc.finish_with_output();\n "}, {"sha": "1c9944664eee6bc9f016dae81e27124fc7263c8c", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -68,9 +68,6 @@ fn debug_mem() -> bool {\n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n-    use io::WriterUtil;\n-    use io;\n-    use libc;\n     use sys;\n     use managed;\n \n@@ -126,14 +123,10 @@ pub unsafe fn annihilate() {\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n-        let dbg = libc::STDERR_FILENO as io::fd_t;\n-        dbg.write_str(\"annihilator stats:\");\n-        dbg.write_str(\"\\n  total_boxes: \");\n-        dbg.write_uint(stats.n_total_boxes);\n-        dbg.write_str(\"\\n  unique_boxes: \");\n-        dbg.write_uint(stats.n_unique_boxes);\n-        dbg.write_str(\"\\n  bytes_freed: \");\n-        dbg.write_uint(stats.n_bytes_freed);\n-        dbg.write_str(\"\\n\");\n+        rterrln!(\"annihilator stats:\\n  \\\n+                     total boxes: {}\\n  \\\n+                    unique boxes: {}\\n  \\\n+                     bytes freed: {}\",\n+                 stats.n_total_boxes, stats.n_unique_boxes, stats.n_bytes_freed);\n     }\n }"}, {"sha": "791616d330e69d1523d5410191da85c25e9a4827", "filename": "src/libstd/io.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -1233,14 +1233,6 @@ impl Writer for *libc::FILE {\n     }\n }\n \n-pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n-    if cleanup {\n-        @Wrapper { base: f, cleanup: FILERes::new(f) } as @Writer\n-    } else {\n-        @f as @Writer\n-    }\n-}\n-\n impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         #[fixed_stack_segment]; #[inline(never)];\n@@ -1618,25 +1610,6 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n     mk_file_writer(path, flags).and_then(|w| Ok(w))\n }\n \n-\n-// FIXME: fileflags // #2004\n-pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        let f = do path.with_c_str |pathbuf| {\n-            do \"w\".with_c_str |modebuf| {\n-                libc::fopen(pathbuf, modebuf)\n-            }\n-        };\n-        return if f as uint == 0u {\n-            Err(~\"error opening \" + path.to_str())\n-        } else {\n-            Ok(FILE_writer(f, true))\n-        }\n-    }\n-}\n-\n // FIXME (#2004) it would be great if this could be a const\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n@@ -2086,16 +2059,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn buffered_file_writer_bad_name() {\n-        match io::buffered_file_writer(&Path(\"?/?\")) {\n-          Err(e) => {\n-            assert!(e.starts_with(\"error opening\"));\n-          }\n-          Ok(_) => fail2!()\n-        }\n-    }\n-\n     #[test]\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter::new();"}, {"sha": "17dc03d0098a8523510daa614fa5fcd5dc19be4b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -13,7 +13,7 @@\n \n macro_rules! rterrln (\n     ($($arg:tt)*) => ( {\n-        ::rt::util::dumb_println(format!($($arg)*));\n+        format_args!(::rt::util::dumb_println, $($arg)*)\n     } )\n )\n "}, {"sha": "3da337add948c8ac6e0d510fddda1924354b2425", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -39,7 +39,7 @@ pub use option::{Option, Some, None};\n pub use result::{Result, Ok, Err};\n \n // Reexported functions\n-pub use io::{print, println};\n+pub use rt::io::stdio::{print, println};\n pub use iter::range;\n pub use from_str::from_str;\n "}, {"sha": "6be23a983abb24f939cfc548f4558f678936c451", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -9,11 +9,8 @@\n // except according to those terms.\n \n use cell::Cell;\n-use c_str::ToCStr;\n-use cast::transmute;\n-use io::{Writer, WriterUtil};\n-use io;\n-use libc::{c_char, size_t, STDERR_FILENO};\n+use c_str::{ToCStr, CString};\n+use libc::{c_char, size_t};\n use option::{Option, None, Some};\n use ptr::RawPtr;\n use rt::env;\n@@ -113,51 +110,10 @@ unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n                                                new_bits: uint,\n                                                filename: *c_char,\n                                                line: size_t) {\n-        let dbg = STDERR_FILENO as io::fd_t;\n-        dbg.write_str(tag);\n-        dbg.write_hex(p.to_uint());\n-        dbg.write_str(\" \");\n-        dbg.write_hex(old_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_hex(new_bits);\n-        dbg.write_str(\" \");\n-        dbg.write_cstr(filename);\n-        dbg.write_str(\":\");\n-        dbg.write_hex(line as uint);\n-        dbg.write_str(\"\\n\");\n-    }\n-}\n-\n-trait DebugPrints {\n-    fn write_hex(&self, val: uint);\n-    unsafe fn write_cstr(&self, str: *c_char);\n-}\n-\n-impl DebugPrints for io::fd_t {\n-    fn write_hex(&self, mut i: uint) {\n-        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n-        static UINT_NIBBLES: uint = ::uint::bytes << 1;\n-        let mut buffer = [0_u8, ..UINT_NIBBLES+1];\n-        let mut c = UINT_NIBBLES;\n-        while c > 0 {\n-            c -= 1;\n-            buffer[c] = letters[i & 0xF] as u8;\n-            i >>= 4;\n-        }\n-        self.write(buffer.slice(0, UINT_NIBBLES));\n-    }\n-\n-    unsafe fn write_cstr(&self, p: *c_char) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        use libc::strlen;\n-        use vec;\n-\n-        let len = strlen(p);\n-        let p: *u8 = transmute(p);\n-        do vec::raw::buf_as_slice(p, len as uint) |s| {\n-            self.write(s);\n-        }\n+        let filename = CString::new(filename, false);\n+        rterrln!(\"{}{:#x} {:x} {:x} {}:{}\",\n+                 tag, p.to_uint(), old_bits, new_bits,\n+                 filename.as_str().unwrap(), line);\n     }\n }\n "}, {"sha": "9dcb35c806f7cb8512df97b2c467596e0666131d", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -55,6 +55,7 @@ use prelude::*;\n \n use num;\n use vec;\n+use str;\n use super::{Reader, Writer, Stream, Decorator};\n \n // libuv recommends 64k buffers to maximize throughput\n@@ -84,23 +85,69 @@ impl<R: Reader> BufferedReader<R> {\n     pub fn new(inner: R) -> BufferedReader<R> {\n         BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n     }\n-}\n \n-impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    /// Reads the next line of input, interpreted as a sequence of utf-8\n+    /// encoded unicode codepoints. If a newline is encountered, then the\n+    /// newline is contained in the returned string.\n+    pub fn read_line(&mut self) -> Option<~str> {\n+        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n+    }\n+\n+    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n+    /// specified byte is encountered, reading ceases and the bytes up to and\n+    /// including the delimiter are returned.\n+    pub fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n+        let mut res = ~[];\n+        let mut used;\n+        loop {\n+            {\n+                let available = self.fill_buffer();\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n+                    }\n+                }\n+            }\n+            if used == 0 {\n+                break\n+            }\n+            self.pos += used;\n+        }\n+        self.pos += used;\n+        return if res.len() == 0 {None} else {Some(res)};\n+    }\n+\n+    fn fill_buffer<'a>(&'a mut self) -> &'a [u8] {\n         if self.pos == self.cap {\n             match self.inner.read(self.buf) {\n                 Some(cap) => {\n                     self.pos = 0;\n                     self.cap = cap;\n                 }\n-                None => return None\n+                None => {}\n             }\n         }\n+        return self.buf.slice(self.pos, self.cap);\n+    }\n+}\n \n-        let src = self.buf.slice(self.pos, self.cap);\n-        let nread = num::min(src.len(), buf.len());\n-        vec::bytes::copy_memory(buf, src, nread);\n+impl<R: Reader> Reader for BufferedReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let nread = {\n+            let available = self.fill_buffer();\n+            if available.len() == 0 {\n+                return None;\n+            }\n+            let nread = num::min(available.len(), buf.len());\n+            vec::bytes::copy_memory(buf, available, nread);\n+            nread\n+        };\n         self.pos += nread;\n         Some(nread)\n     }\n@@ -355,4 +402,15 @@ mod test {\n         stream.write(buf);\n         stream.flush();\n     }\n+\n+    #[test]\n+    fn test_read_until() {\n+        let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n+        let mut reader = BufferedReader::with_capacity(2, inner);\n+        assert_eq!(reader.read_until(0), Some(~[0]));\n+        assert_eq!(reader.read_until(2), Some(~[1, 2]));\n+        assert_eq!(reader.read_until(1), Some(~[1]));\n+        assert_eq!(reader.read_until(8), Some(~[0]));\n+        assert_eq!(reader.read_until(9), None);\n+    }\n }"}, {"sha": "3258c350cd08415c3811ad0c9a5eca6566ecdd40", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -599,7 +599,7 @@ impl FileInfo for Path { }\n ///     else { fail2!(\"nope\"); }\n /// }\n /// ```\n-trait DirectoryInfo : FileSystemInfo {\n+pub trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) is pointing at a directory in the underlying FS.\n     /// Will return false for paths to non-existent locations or if the item is"}, {"sha": "f9542cbf5f91c180c0bad22a9d69c2a721b3e293", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -313,8 +313,11 @@ pub mod buffered;\n pub mod native {\n     /// Posix file I/O\n     pub mod file;\n-    /// # XXX - implement this\n-    pub mod stdio { }\n+    /// Process spawning and child management\n+    pub mod process;\n+    /// Posix stdio\n+    pub mod stdio;\n+\n     /// Sockets\n     /// # XXX - implement this\n     pub mod net {\n@@ -459,6 +462,16 @@ pub trait Reader {\n     fn eof(&mut self) -> bool;\n }\n \n+impl Reader for ~Reader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn eof(&mut self) -> bool { self.eof() }\n+}\n+\n+impl<'self> Reader for &'self mut Reader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn eof(&mut self) -> bool { self.eof() }\n+}\n+\n pub trait Writer {\n     /// Write the given buffer\n     ///\n@@ -471,6 +484,16 @@ pub trait Writer {\n     fn flush(&mut self);\n }\n \n+impl Writer for ~Writer {\n+    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n+    fn flush(&mut self) { self.flush() }\n+}\n+\n+impl<'self> Writer for &'self mut Writer {\n+    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n+    fn flush(&mut self) { self.flush() }\n+}\n+\n pub trait Stream: Reader + Writer { }\n \n impl<T: Reader + Writer> Stream for T {}"}, {"sha": "dc8d34d1b11058c5cd2a6654b38ddaa78ab779d9", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 231, "deletions": 25, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -10,68 +10,274 @@\n \n //! Blocking posix-based file I/O\n \n+#[allow(non_camel_case_types)];\n+\n+use libc;\n+use os;\n use prelude::*;\n use super::super::*;\n-use libc::{c_int, FILE};\n \n-#[allow(non_camel_case_types)]\n-pub type fd_t = c_int;\n+fn raise_error() {\n+    // XXX: this should probably be a bit more descriptive...\n+    let (kind, desc) = match os::errno() as i32 {\n+        libc::EOF => (EndOfFile, \"end of file\"),\n+        _ => (OtherIoError, \"unknown error\"),\n+    };\n+\n+    io_error::cond.raise(IoError {\n+        kind: kind,\n+        desc: desc,\n+        detail: Some(os::last_os_error())\n+    });\n+}\n+\n+fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n+    #[cfg(windows)] static eintr: int = 0; // doesn't matter\n+    #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n+\n+    let (data, origamt) = do data.as_imm_buf |data, amt| { (data, amt) };\n+    let mut data = data;\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let mut ret;\n+        loop {\n+            ret = f(data, amt);\n+            if cfg!(not(windows)) { break } // windows has no eintr\n+            // if we get an eintr, then try again\n+            if ret != -1 || os::errno() as int != eintr { break }\n+        }\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n+pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n-    priv fd: fd_t\n+    priv fd: fd_t,\n }\n \n impl FileDesc {\n     /// Create a `FileDesc` from an open C file descriptor.\n     ///\n-    /// The `FileDesc` takes ownership of the file descriptor\n-    /// and will close it upon destruction.\n-    pub fn new(_fd: fd_t) -> FileDesc { fail2!() }\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n }\n \n impl Reader for FileDesc {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        #[cfg(windows)] type rlen = libc::c_uint;\n+        #[cfg(not(windows))] type rlen = libc::size_t;\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::read(self.fd, buf as *mut libc::c_void, len as rlen) as i64\n+            }\n+        };\n+        if ret == 0 {\n+            None\n+        } else if ret < 0 {\n+            raise_error();\n+            None\n+        } else {\n+            Some(ret as uint)\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { false }\n }\n \n impl Writer for FileDesc {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn write(&mut self, buf: &[u8]) {\n+        #[cfg(windows)] type wlen = libc::c_uint;\n+        #[cfg(not(windows))] type wlen = libc::size_t;\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n+            }\n+        };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+    }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) {}\n }\n \n-impl Seek for FileDesc {\n-    fn tell(&self) -> u64 { fail2!() }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+impl Drop for FileDesc {\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn drop(&mut self) {\n+        unsafe { libc::close(self.fd); }\n+    }\n }\n \n pub struct CFile {\n-    priv file: *FILE\n+    priv file: *libc::FILE\n }\n \n impl CFile {\n     /// Create a `CFile` from an open `FILE` pointer.\n     ///\n-    /// The `CFile` takes ownership of the file descriptor\n-    /// and will close it upon destruction.\n-    pub fn new(_file: *FILE) -> CFile { fail2!() }\n+    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n+    /// destruction.\n+    pub fn new(file: *libc::FILE) -> CFile { CFile { file: file } }\n }\n \n impl Reader for CFile {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        };\n+        if ret == 0 {\n+            None\n+        } else if ret < 0 {\n+            raise_error();\n+            None\n+        } else {\n+            Some(ret as uint)\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn eof(&mut self) -> bool {\n+        unsafe { libc::feof(self.file) != 0 }\n+    }\n }\n \n impl Writer for CFile {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn write(&mut self, buf: &[u8]) {\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+    }\n \n-    fn flush(&mut self) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn flush(&mut self) {\n+        if unsafe { libc::fflush(self.file) } < 0 {\n+            raise_error();\n+        }\n+    }\n }\n \n impl Seek for CFile {\n-    fn tell(&self) -> u64 { fail2!() }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn tell(&self) -> u64 {\n+        let ret = unsafe { libc::ftell(self.file) };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+        return ret as u64;\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        let whence = match style {\n+            SeekSet => libc::SEEK_SET,\n+            SeekEnd => libc::SEEK_END,\n+            SeekCur => libc::SEEK_CUR,\n+        };\n+        if unsafe { libc::fseek(self.file, pos as libc::c_long, whence) } < 0 {\n+            raise_error();\n+        }\n+    }\n+}\n+\n+impl Drop for CFile {\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn drop(&mut self) {\n+        unsafe { libc::fclose(self.file); }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use libc;\n+    use os;\n+    use prelude::*;\n+    use rt::io::{io_error, SeekSet};\n+    use super::*;\n+\n+    #[test] #[fixed_stack_segment]\n+    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        unsafe {\n+            let os::Pipe { input, out } = os::pipe();\n+            let mut reader = FileDesc::new(input);\n+            let mut writer = FileDesc::new(out);\n+\n+            writer.write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            match reader.read(buf) {\n+                Some(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail2!(\"invalid read: {:?}\", r)\n+            }\n+\n+            let mut raised = false;\n+            do io_error::cond.trap(|_| { raised = true; }).inside {\n+                writer.read(buf);\n+            }\n+            assert!(raised);\n+\n+            raised = false;\n+            do io_error::cond.trap(|_| { raised = true; }).inside {\n+                reader.write(buf);\n+            }\n+            assert!(raised);\n+        }\n+    }\n+\n+    #[test] #[fixed_stack_segment]\n+    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n+    fn test_cfile() {\n+        unsafe {\n+            let f = libc::tmpfile();\n+            assert!(!f.is_null());\n+            let mut file = CFile::new(f);\n+\n+            file.write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            file.seek(0, SeekSet);\n+            match file.read(buf) {\n+                Some(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail2!(\"invalid read: {:?}\", r)\n+            }\n+        }\n+    }\n }"}, {"sha": "d338192c664bca23cf57abfca8d7a8c0fb8da5ad", "filename": "src/libstd/rt/io/native/process.rs", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -0,0 +1,745 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use libc::{pid_t, c_void, c_int};\n+use libc;\n+use os;\n+use prelude::*;\n+use ptr;\n+use rt::io;\n+use super::file;\n+\n+/**\n+ * A value representing a child process.\n+ *\n+ * The lifetime of this value is linked to the lifetime of the actual\n+ * process - the Process destructor calls self.finish() which waits\n+ * for the process to terminate.\n+ */\n+pub struct Process {\n+    /// The unique id of the process (this should never be negative).\n+    priv pid: pid_t,\n+\n+    /// A handle to the process - on unix this will always be NULL, but on\n+    /// windows it will be a HANDLE to the process, which will prevent the\n+    /// pid being re-used until the handle is closed.\n+    priv handle: *(),\n+\n+    /// Currently known stdin of the child, if any\n+    priv input: Option<file::FileDesc>,\n+    /// Currently known stdout of the child, if any\n+    priv output: Option<file::FileDesc>,\n+    /// Currently known stderr of the child, if any\n+    priv error: Option<file::FileDesc>,\n+\n+    /// None until finish() is called.\n+    priv exit_code: Option<int>,\n+}\n+\n+impl Process {\n+    /// Creates a new process using native process-spawning abilities provided\n+    /// by the OS. Operations on this process will be blocking instead of using\n+    /// the runtime for sleeping just this current task.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * prog - the program to run\n+    /// * args - the arguments to pass to the program, not including the program\n+    ///          itself\n+    /// * env - an optional envrionment to specify for the child process. If\n+    ///         this value is `None`, then the child will inherit the parent's\n+    ///         environment\n+    /// * cwd - an optionally specified current working directory of the child,\n+    ///         defaulting to the parent's current working directory\n+    /// * stdin, stdout, stderr - These optionally specified file descriptors\n+    ///     dictate where the stdin/out/err of the child process will go. If\n+    ///     these are `None`, then this module will bind the input/output to an\n+    ///     os pipe instead. This process takes ownership of these file\n+    ///     descriptors, closing them upon destruction of the process.\n+    pub fn new(prog: &str, args: &[~str], env: Option<~[(~str, ~str)]>,\n+               cwd: Option<&Path>,\n+               stdin: Option<file::fd_t>,\n+               stdout: Option<file::fd_t>,\n+               stderr: Option<file::fd_t>) -> Process {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        let (in_pipe, in_fd) = match stdin {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.input)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (out_pipe, out_fd) = match stdout {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (err_pipe, err_fd) = match stderr {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+\n+        let res = spawn_process_os(prog, args, env, cwd,\n+                                   in_fd, out_fd, err_fd);\n+\n+        unsafe {\n+            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n+        }\n+\n+        Process {\n+            pid: res.pid,\n+            handle: res.handle,\n+            input: in_pipe.map(|pipe| file::FileDesc::new(pipe.out)),\n+            output: out_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n+            error: err_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n+            exit_code: None,\n+        }\n+    }\n+\n+    /// Returns the unique id of the process\n+    pub fn id(&self) -> pid_t { self.pid }\n+\n+    /**\n+     * Returns an io::Writer that can be used to write to this Process's stdin.\n+     *\n+     * Fails if there is no stdinavailable (it's already been removed by\n+     * take_input)\n+     */\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n+        match self.input {\n+            Some(ref mut fd) => fd as &mut io::Writer,\n+            None => fail2!(\"This process has no stdin\")\n+        }\n+    }\n+\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's\n+     * stdout.\n+     *\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_output)\n+     */\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n+        match self.input {\n+            Some(ref mut fd) => fd as &mut io::Reader,\n+            None => fail2!(\"This process has no stdout\")\n+        }\n+    }\n+\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's\n+     * stderr.\n+     *\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_error)\n+     */\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n+        match self.error {\n+            Some(ref mut fd) => fd as &mut io::Reader,\n+            None => fail2!(\"This process has no stderr\")\n+        }\n+    }\n+\n+    /**\n+     * Takes the stdin of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_input(&mut self) -> Option<~io::Writer> {\n+        self.input.take().map(|fd| ~fd as ~io::Writer)\n+    }\n+\n+    /**\n+     * Takes the stdout of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_output(&mut self) -> Option<~io::Reader> {\n+        self.output.take().map(|fd| ~fd as ~io::Reader)\n+    }\n+\n+    /**\n+     * Takes the stderr of this process, transferring ownership to the caller.\n+     * Note that when the return value is destroyed, the handle will be closed\n+     * for the child process.\n+     */\n+    pub fn take_error(&mut self) -> Option<~io::Reader> {\n+        self.error.take().map(|fd| ~fd as ~io::Reader)\n+    }\n+\n+    pub fn wait(&mut self) -> int {\n+        for &code in self.exit_code.iter() {\n+            return code;\n+        }\n+        let code = waitpid(self.pid);\n+        self.exit_code = Some(code);\n+        return code;\n+    }\n+\n+    pub fn signal(&mut self, signum: int) -> Result<(), io::IoError> {\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        match self.exit_code {\n+            Some(*) => return Err(io::IoError {\n+                kind: io::OtherIoError,\n+                desc: \"can't kill an exited process\",\n+                detail: None,\n+            }),\n+            None => {}\n+        }\n+        return unsafe { killpid(self.pid, signum) };\n+\n+        #[cfg(windows)]\n+        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            match signal {\n+                io::process::PleaseExitSignal |\n+                io::process::MustDieSignal => {\n+                    libc::funcs::extra::kernel32::TerminateProcess(\n+                        cast::transmute(pid), 1);\n+                    Ok(())\n+                }\n+                _ => Err(io::IoError {\n+                    kind: io::OtherIoError,\n+                    desc: \"unsupported signal on windows\",\n+                    detail: None,\n+                })\n+            }\n+        }\n+\n+        #[cfg(not(windows))]\n+        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        // close all these handles\n+        self.take_input();\n+        self.take_output();\n+        self.take_error();\n+        self.wait();\n+        free_handle(self.handle);\n+    }\n+}\n+\n+struct SpawnProcessResult {\n+    pid: pid_t,\n+    handle: *(),\n+}\n+\n+#[cfg(windows)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use libc::consts::os::extra::{\n+        TRUE, FALSE,\n+        STARTF_USESTDHANDLES,\n+        INVALID_HANDLE_VALUE,\n+        DUPLICATE_SAME_ACCESS\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        GetCurrentProcess,\n+        DuplicateHandle,\n+        CloseHandle,\n+        CreateProcessA\n+    };\n+    use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+    use sys;\n+\n+    unsafe {\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n+\n+        let cur_proc = GetCurrentProcess();\n+\n+        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n+        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n+        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n+        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        }\n+\n+        let cmd = make_command_line(prog, args);\n+        let mut pi = zeroed_process_information();\n+        let mut create_err = None;\n+\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n+                do cmd.with_c_str |cmdp| {\n+                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n+                                                 0, envp, dirp, &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(os::last_os_error());\n+                    }\n+                }\n+            }\n+        }\n+\n+        CloseHandle(si.hStdInput);\n+        CloseHandle(si.hStdOutput);\n+        CloseHandle(si.hStdError);\n+\n+        for msg in create_err.iter() {\n+            fail2!(\"failure in CreateProcess: {}\", *msg);\n+        }\n+\n+        // We close the thread handle because we don't care about keeping the\n+        // thread id valid, and we aren't keeping the thread handle around to be\n+        // able to close it later. We don't close the process handle however\n+        // because we want the process id to stay valid at least until the\n+        // calling code closes the process handle.\n+        CloseHandle(pi.hThread);\n+\n+        SpawnProcessResult {\n+            pid: pi.dwProcessId as pid_t,\n+            handle: pi.hProcess as *()\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::mut_null(),\n+        lpDesktop: ptr::mut_null(),\n+        lpTitle: ptr::mut_null(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::mut_null(),\n+        hStdInput: ptr::mut_null(),\n+        hStdOutput: ptr::mut_null(),\n+        hStdError: ptr::mut_null()\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::mut_null(),\n+        hThread: ptr::mut_null(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// FIXME: this is only pub so it can be tested (see issue #4536)\n+#[cfg(windows)]\n+pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+    let mut cmd = ~\"\";\n+    append_arg(&mut cmd, prog);\n+    for arg in args.iter() {\n+        cmd.push_char(' ');\n+        append_arg(&mut cmd, *arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut ~str, arg: &str) {\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+        for i in range(0u, arg.len()) {\n+            append_char_at(cmd, arg, i);\n+        }\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+        match arg[i] as char {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push_char('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push_char(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n+        while i < s.len() && s[i] as char == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] as char == '\"';\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use libc::funcs::bsd44::getdtablesize;\n+\n+    mod rustrt {\n+        #[abi = \"cdecl\"]\n+        extern {\n+            pub fn rust_unset_sigprocmask();\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    unsafe fn set_environ(_envp: *c_void) {}\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn set_environ(envp: *c_void) {\n+        externfn!(fn _NSGetEnviron() -> *mut *c_void);\n+\n+        *_NSGetEnviron() = envp;\n+    }\n+    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    unsafe fn set_environ(envp: *c_void) {\n+        extern {\n+            static mut environ: *c_void;\n+        }\n+        environ = envp;\n+    }\n+\n+    unsafe {\n+\n+        let pid = fork();\n+        if pid < 0 {\n+            fail2!(\"failure in fork: {}\", os::last_os_error());\n+        } else if pid > 0 {\n+            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n+        }\n+\n+        rustrt::rust_unset_sigprocmask();\n+\n+        if dup2(in_fd, 0) == -1 {\n+            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n+        }\n+        if dup2(out_fd, 1) == -1 {\n+            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n+        }\n+        if dup2(err_fd, 2) == -1 {\n+            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n+        }\n+        // close all other fds\n+        for fd in range(3, getdtablesize()).invert() {\n+            close(fd as c_int);\n+        }\n+\n+        do with_dirp(dir) |dirp| {\n+            if !dirp.is_null() && chdir(dirp) == -1 {\n+                fail2!(\"failure in chdir: {}\", os::last_os_error());\n+            }\n+        }\n+\n+        do with_envp(env) |envp| {\n+            if !envp.is_null() {\n+                set_environ(envp);\n+            }\n+            do with_argv(prog, args) |argv| {\n+                execvp(*argv, argv);\n+                // execvp only returns if an error occurred\n+                fail2!(\"failure in execvp: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+    use vec;\n+\n+    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n+    // a reference to the intermediary byte buffers. So first build an array to\n+    // hold all the ~[u8] byte strings.\n+    let mut tmps = vec::with_capacity(args.len() + 1);\n+\n+    tmps.push(prog.to_c_str());\n+\n+    for arg in args.iter() {\n+        tmps.push(arg.to_c_str());\n+    }\n+\n+    // Next, convert each of the byte strings into a pointer. This is\n+    // technically unsafe as the caller could leak these pointers out of our\n+    // scope.\n+    let mut ptrs = do tmps.map |tmp| {\n+        tmp.with_ref(|buf| buf)\n+    };\n+\n+    // Finally, make sure we add a null pointer.\n+    ptrs.push(ptr::null());\n+\n+    ptrs.as_imm_buf(|buf, _| cb(buf))\n+}\n+\n+#[cfg(unix)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n+    use vec;\n+\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n+    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                tmps.push(kv.to_c_str());\n+            }\n+\n+            // Once again, this is unsafe.\n+            let mut ptrs = do tmps.map |tmp| {\n+                tmp.with_ref(|buf| buf)\n+            };\n+            ptrs.push(ptr::null());\n+\n+            do ptrs.as_imm_buf |buf, _| {\n+                unsafe { cb(cast::transmute(buf)) }\n+            }\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n+    // On win32 we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = ~[];\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                blk.push_all(kv.as_bytes());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            do blk.as_imm_buf |p, _len| {\n+                unsafe { cb(cast::transmute(p)) }\n+            }\n+        }\n+        _ => cb(ptr::mut_null())\n+    }\n+}\n+\n+fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n+    match d {\n+      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn free_handle(handle: *()) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe {\n+        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn free_handle(_handle: *()) {\n+    // unix has no process handle object, just a pid\n+}\n+\n+/**\n+ * Waits for a process to exit and returns the exit code, failing\n+ * if there is no process with the specified id.\n+ *\n+ * Note that this is private to avoid race conditions on unix where if\n+ * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+ * and some_process.destroy() and some_process.finalize() will then either\n+ * operate on a none-existent process or, even worse, on a newer process\n+ * with the same id.\n+ */\n+fn waitpid(pid: pid_t) -> int {\n+    return waitpid_os(pid);\n+\n+    #[cfg(windows)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_FAILED\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject\n+        };\n+\n+        unsafe {\n+\n+            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+            if proc.is_null() {\n+                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(proc, &mut status) == FALSE {\n+                    CloseHandle(proc);\n+                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n+                }\n+                if status != STILL_ACTIVE {\n+                    CloseHandle(proc);\n+                    return status as int;\n+                }\n+                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n+                    CloseHandle(proc);\n+                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::funcs::posix01::wait::*;\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0xffi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0x7fi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            (status >> 8i32) & 0xffi32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            status >> 8i32\n+        }\n+\n+        let mut status = 0 as c_int;\n+        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n+        }\n+\n+        return if WIFEXITED(status) {\n+            WEXITSTATUS(status) as int\n+        } else {\n+            1\n+        };\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test] #[cfg(windows)]\n+    fn test_make_command_line() {\n+        use super::make_command_line;\n+        assert_eq!(\n+            make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n+            ~\"prog aaa bbb ccc\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            make_command_line(\"echo\", [~\"a b c\"]),\n+            ~\"echo \\\"a b c\\\"\"\n+        );\n+    }\n+\n+    // Currently most of the tests of this functionality live inside std::run,\n+    // but they may move here eventually as a non-blocking backend is added to\n+    // std::run\n+}"}, {"sha": "5661725d77baa40f6d8247a2c015a3d9c800d500", "filename": "src/libstd/rt/io/native/stdio.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use option::Option;\n+use rt::io::{Reader, Writer};\n+use super::file;\n+\n+/// Creates a new handle to the stdin of this process\n+pub fn stdin() -> StdIn { StdIn::new() }\n+/// Creates a new handle to the stdout of this process\n+pub fn stdout() -> StdOut { StdOut::new(libc::STDOUT_FILENO) }\n+/// Creates a new handle to the stderr of this process\n+pub fn stderr() -> StdOut { StdOut::new(libc::STDERR_FILENO) }\n+\n+pub fn print(s: &str) {\n+    stdout().write(s.as_bytes())\n+}\n+\n+pub fn println(s: &str) {\n+    let mut out = stdout();\n+    out.write(s.as_bytes());\n+    out.write(['\\n' as u8]);\n+}\n+\n+pub struct StdIn {\n+    priv fd: file::FileDesc\n+}\n+\n+impl StdIn {\n+    /// Duplicates the stdin file descriptor, returning an io::Reader\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn new() -> StdIn {\n+        let fd = unsafe { libc::dup(libc::STDIN_FILENO) };\n+        StdIn { fd: file::FileDesc::new(fd) }\n+    }\n+}\n+\n+impl Reader for StdIn {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.fd.read(buf) }\n+    fn eof(&mut self) -> bool { self.fd.eof() }\n+}\n+\n+pub struct StdOut {\n+    priv fd: file::FileDesc\n+}\n+\n+impl StdOut {\n+    /// Duplicates the specified file descriptor, returning an io::Writer\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn new(fd: file::fd_t) -> StdOut {\n+        let fd = unsafe { libc::dup(fd) };\n+        StdOut { fd: file::FileDesc::new(fd) }\n+    }\n+}\n+\n+impl Writer for StdOut {\n+    fn write(&mut self, buf: &[u8]) { self.fd.write(buf) }\n+    fn flush(&mut self) { self.fd.flush() }\n+}"}, {"sha": "5f2453852ee7fe9a82704d64ecde3ae9efbf1274", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -18,6 +18,13 @@ use rt::io::io_error;\n use rt::local::Local;\n use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n \n+// windows values don't matter as long as they're at least one of unix's\n+// TERM/KILL/INT signals\n+#[cfg(windows)] pub static PleaseExitSignal: int = 15;\n+#[cfg(windows)] pub static MustDieSignal: int = 9;\n+#[cfg(not(windows))] pub static PleaseExitSignal: int = libc::SIGTERM as int;\n+#[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n+\n pub struct Process {\n     priv handle: ~RtioProcessObject,\n     io: ~[Option<io::PipeStream>],"}, {"sha": "e3ca148862fbe9fe88d3cf96a68c0af3853f2248", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 81, "deletions": 24, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -8,45 +8,102 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::{Reader, Writer};\n+use libc;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::local::Local;\n+use rt::rtio::{RtioFileStream, IoFactoryObject, IoFactory};\n+use super::{Reader, Writer, io_error};\n \n-pub fn stdin() -> StdReader { fail2!() }\n-\n-pub fn stdout() -> StdWriter { fail2!() }\n-\n-pub fn stderr() -> StdReader { fail2!() }\n+/// Creates a new non-blocking handle to the stdin of the current process.\n+///\n+/// See `stdout()` for notes about this function.\n+pub fn stdin() -> StdReader {\n+    let stream = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_from_raw_fd(libc::STDIN_FILENO, false)\n+    };\n+    StdReader { inner: stream }\n+}\n \n-pub fn print(_s: &str) { fail2!() }\n+/// Creates a new non-blocking handle to the stdout of the current process.\n+///\n+/// Note that this is a fairly expensive operation in that at least one memory\n+/// allocation is performed. Additionally, this must be called from a runtime\n+/// task context because the stream returned will be a non-blocking object using\n+/// the local scheduler to perform the I/O.\n+pub fn stdout() -> StdWriter {\n+    let stream = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_from_raw_fd(libc::STDOUT_FILENO, false)\n+    };\n+    StdWriter { inner: stream }\n+}\n \n-pub fn println(_s: &str) { fail2!() }\n+/// Creates a new non-blocking handle to the stderr of the current process.\n+///\n+/// See `stdout()` for notes about this function.\n+pub fn stderr() -> StdWriter {\n+    let stream = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_from_raw_fd(libc::STDERR_FILENO, false)\n+    };\n+    StdWriter { inner: stream }\n+}\n \n-pub enum StdStream {\n-    StdIn,\n-    StdOut,\n-    StdErr\n+/// Prints a string to the stdout of the current process. No newline is emitted\n+/// after the string is printed.\n+pub fn print(s: &str) {\n+    // XXX: need to see if not caching stdin() is the cause of performance\n+    //      issues, it should be possible to cache a stdout handle in each Task\n+    //      and then re-use that across calls to print/println\n+    stdout().write(s.as_bytes());\n }\n \n-pub struct StdReader;\n+/// Prints a string as a line. to the stdout of the current process. A literal\n+/// `\\n` character is printed to the console after the string.\n+pub fn println(s: &str) {\n+    let mut out = stdout();\n+    out.write(s.as_bytes());\n+    out.write(['\\n' as u8]);\n+}\n \n-impl StdReader {\n-    pub fn new(_stream: StdStream) -> StdReader { fail2!() }\n+/// Representation of a reader of a standard input stream\n+pub struct StdReader {\n+    priv inner: ~RtioFileStream\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match self.inner.read(buf) {\n+            Ok(amt) => Some(amt as uint),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n+            }\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { false }\n }\n \n-pub struct StdWriter;\n-\n-impl StdWriter {\n-    pub fn new(_stream: StdStream) -> StdWriter { fail2!() }\n+/// Representation of a writer to a standard output stream\n+pub struct StdWriter {\n+    priv inner: ~RtioFileStream\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        match self.inner.write(buf) {\n+            Ok(()) => {}\n+            Err(e) => io_error::cond.raise(e)\n+        }\n+    }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) {\n+        match self.inner.flush() {\n+            Ok(()) => {}\n+            Err(e) => io_error::cond.raise(e)\n+        }\n+    }\n }"}, {"sha": "660d1cd43595fcabdfc6597ff4e882ed4bd3621b", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -12,8 +12,6 @@ use fmt;\n use from_str::from_str;\n use libc::exit;\n use option::{Some, None, Option};\n-use rt;\n-use rt::util::dumb_println;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use u32;\n@@ -88,16 +86,16 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n                         log_level = num;\n                     },\n                     _ => {\n-                        dumb_println(format!(\"warning: invalid logging spec \\\n-                                              '{}', ignoring it\", parts[1]));\n-                        continue;\n+                        rterrln!(\"warning: invalid logging spec '{}', \\\n+                                  ignoring it\", parts[1]);\n+                        continue\n                     }\n                 }\n             },\n             _ => {\n-                dumb_println(format!(\"warning: invalid logging spec '{}',\\\n-                                      ignoring it\", s));\n-                continue;\n+                rterrln!(\"warning: invalid logging spec '{}', \\\n+                          ignoring it\", s);\n+                continue\n             }\n         }\n         let dir = LogDirective {name: name, level: log_level};\n@@ -141,9 +139,9 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     let mut dirs = ~[];\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n-        dumb_println(\"\\nCrate log map:\\n\");\n+            rterrln!(\"\\nCrate log map:\\n\");\n             do iter_crate_map(crate_map) |entry| {\n-                dumb_println(\" \"+entry.name);\n+                rterrln!(\" {}\", entry.name);\n             }\n             unsafe { exit(1); }\n         }\n@@ -157,12 +155,10 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     }\n \n     if n_matches < (dirs.len() as u32) {\n-        dumb_println(format!(\"warning: got {} RUST_LOG specs but only matched\\n\\\n-                              {} of them. You may have mistyped a RUST_LOG \\\n-                              spec. \\n\\\n-                              Use RUST_LOG=::help to see the list of crates \\\n-                              and modules.\\n\",\n-                             dirs.len(), n_matches));\n+        rterrln!(\"warning: got {} RUST_LOG specs but only matched\\n\\\n+                  {} of them. You may have mistyped a RUST_LOG spec. \\n\\\n+                  Use RUST_LOG=::help to see the list of crates and modules.\\n\",\n+                 dirs.len(), n_matches);\n     }\n }\n \n@@ -174,24 +170,13 @@ pub struct StdErrLogger;\n \n impl Logger for StdErrLogger {\n     fn log(&mut self, args: &fmt::Arguments) {\n-        fmt::writeln(self as &mut rt::io::Writer, args);\n+        // FIXME(#6846): this should not call the blocking version of println,\n+        //               or at least the default loggers for tasks shouldn't do\n+        //               that\n+        ::rt::util::dumb_println(args);\n     }\n }\n \n-impl rt::io::Writer for StdErrLogger {\n-    fn write(&mut self, buf: &[u8]) {\n-        // Nothing like swapping between I/O implementations! In theory this\n-        // could use the libuv bindings for writing to file descriptors, but\n-        // that may not necessarily be desirable because logging should work\n-        // outside of the uv loop. (modify with caution)\n-        use io::Writer;\n-        let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-        dbg.write(buf);\n-    }\n-\n-    fn flush(&mut self) {}\n-}\n-\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init() {\n@@ -212,7 +197,7 @@ pub fn init() {\n         _ => {\n             match log_spec {\n                 Some(_) => {\n-                    dumb_println(\"warning: RUST_LOG set, but no crate map found.\");\n+                    rterrln!(\"warning: RUST_LOG set, but no crate map found.\");\n                 },\n                 None => {}\n             }"}, {"sha": "727bdb782d2c8b6cf38f61ae5d6bf33aa0211d67", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use container::Container;\n+use fmt;\n use from_str::FromStr;\n use libc;\n use option::{Some, None, Option};\n@@ -74,10 +75,11 @@ pub fn default_sched_threads() -> uint {\n     }\n }\n \n-pub fn dumb_println(s: &str) {\n-    use io::WriterUtil;\n-    let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-    dbg.write_str(s + \"\\n\");\n+pub fn dumb_println(args: &fmt::Arguments) {\n+    use rt::io::native::stdio::stderr;\n+    use rt::io::Writer;\n+    let mut out = stderr();\n+    fmt::writeln(&mut out as &mut Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "8712d01aae9639339a38a7d98cfa77049311342e", "filename": "src/libstd/run.rs", "status": "modified", "additions": 78, "deletions": 781, "changes": 859, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -12,19 +12,14 @@\n \n #[allow(missing_doc)];\n \n-use c_str::ToCStr;\n-use cast;\n-use clone::Clone;\n-use comm::{stream, SharedChan, GenericChan, GenericPort};\n-use io;\n-use libc::{pid_t, c_void, c_int};\n+use cell::Cell;\n+use comm::{stream, SharedChan};\n+use libc::{pid_t, c_int};\n use libc;\n-use option::{Some, None};\n-use os;\n use prelude::*;\n-use ptr;\n+use rt::io::native::process;\n+use rt::io;\n use task;\n-use vec::ImmutableVector;\n \n /**\n  * A value representing a child process.\n@@ -34,28 +29,7 @@ use vec::ImmutableVector;\n  * for the process to terminate.\n  */\n pub struct Process {\n-\n-    /// The unique id of the process (this should never be negative).\n-    priv pid: pid_t,\n-\n-    /**\n-     * A handle to the process - on unix this will always be NULL, but on\n-     * windows it will be a HANDLE to the process, which will prevent the\n-     * pid being re-used until the handle is closed.\n-     */\n-    priv handle: *(),\n-\n-    /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n-    priv input: Option<c_int>,\n-\n-    /// Some(file), or None when stdout is being redirected to a fd not created by Process::new.\n-    priv output: Option<*libc::FILE>,\n-\n-    /// Some(file), or None when stderr is being redirected to a fd not created by Process::new.\n-    priv error: Option<*libc::FILE>,\n-\n-    /// None until finish() is called.\n-    priv exit_code: Option<int>,\n+    priv inner: process::Process,\n }\n \n /// Options that can be given when starting a Process.\n@@ -147,178 +121,50 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str],\n-               options: ProcessOptions)\n-               -> Process {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let (in_pipe, in_fd) = match options.in_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.input)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (out_pipe, out_fd) = match options.out_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (err_pipe, err_fd) = match options.err_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-\n-        let res = spawn_process_os(prog, args, options.env.clone(), options.dir,\n-                                   in_fd, out_fd, err_fd);\n-\n-        unsafe {\n-            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n-        }\n-\n-        Process {\n-            pid: res.pid,\n-            handle: res.handle,\n-            input: in_pipe.map(|pipe| pipe.out),\n-            output: out_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            error: err_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            exit_code: None,\n-        }\n+    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n+        let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n+        let inner = process::Process::new(prog, args, env, dir,\n+                                          in_fd, out_fd, err_fd);\n+        Process { inner: inner }\n     }\n \n     /// Returns the unique id of the process\n-    pub fn get_id(&self) -> pid_t { self.pid }\n-\n-    fn input_fd(&mut self) -> c_int {\n-        match self.input {\n-            Some(fd) => fd,\n-            None => fail2!(\"This Process's stdin was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn output_file(&mut self) -> *libc::FILE {\n-        match self.output {\n-            Some(file) => file,\n-            None => fail2!(\"This Process's stdout was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn error_file(&mut self) -> *libc::FILE {\n-        match self.error {\n-            Some(file) => file,\n-            None => fail2!(\"This Process's stderr was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    /**\n-     * Returns whether this process is reading its stdin from an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.input() will fail.\n-     */\n-    pub fn input_redirected(&self) -> bool {\n-        self.input.is_none()\n-    }\n-\n-    /**\n-     * Returns whether this process is writing its stdout to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.output() will fail.\n-     */\n-    pub fn output_redirected(&self) -> bool {\n-        self.output.is_none()\n-    }\n-\n-    /**\n-     * Returns whether this process is writing its stderr to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.error() will fail.\n-     */\n-    pub fn error_redirected(&self) -> bool {\n-        self.error.is_none()\n-    }\n+    pub fn get_id(&self) -> pid_t { self.inner.id() }\n \n     /**\n      * Returns an io::Writer that can be used to write to this Process's stdin.\n      *\n-     * Fails if this Process's stdin was redirected to an existing file descriptor.\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_input)\n      */\n-    pub fn input(&mut self) -> @io::Writer {\n-        // FIXME: the Writer can still be used after self is destroyed: #2625\n-       io::fd_writer(self.input_fd(), false)\n-    }\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer { self.inner.input() }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stdout.\n      *\n-     * Fails if this Process's stdout was redirected to an existing file descriptor.\n+     * Fails if there is no stdout available (it's already been removed by\n+     * take_output)\n      */\n-    pub fn output(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.output_file(), false)\n-    }\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.output() }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stderr.\n      *\n-     * Fails if this Process's stderr was redirected to an existing file descriptor.\n+     * Fails if there is no stderr available (it's already been removed by\n+     * take_error)\n      */\n-    pub fn error(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.error_file(), false)\n-    }\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.error() }\n \n     /**\n      * Closes the handle to the child process's stdin.\n-     *\n-     * If this process is reading its stdin from an existing file descriptor, then this\n-     * method does nothing.\n      */\n     pub fn close_input(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        match self.input {\n-            Some(-1) | None => (),\n-            Some(fd) => {\n-                unsafe {\n-                    libc::close(fd);\n-                }\n-                self.input = Some(-1);\n-            }\n-        }\n+        self.inner.take_input();\n     }\n \n     fn close_outputs(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        fclose_and_null(&mut self.output);\n-        fclose_and_null(&mut self.error);\n-\n-        fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n-            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n-            match *f_opt {\n-                Some(f) if !f.is_null() => {\n-                    unsafe {\n-                        libc::fclose(f);\n-                        *f_opt = Some(0 as *libc::FILE);\n-                    }\n-                },\n-                _ => ()\n-            }\n-        }\n+        self.inner.take_output();\n+        self.inner.take_error();\n     }\n \n     /**\n@@ -327,29 +173,35 @@ impl Process {\n      *\n      * If the child has already been finished then the exit code is returned.\n      */\n-    pub fn finish(&mut self) -> int {\n-        for &code in self.exit_code.iter() {\n-            return code;\n-        }\n-        self.close_input();\n-        let code = waitpid(self.pid);\n-        self.exit_code = Some(code);\n-        return code;\n-    }\n+    pub fn finish(&mut self) -> int { self.inner.wait() }\n \n     /**\n-     * Closes the handle to stdin, waits for the child process to terminate, and reads\n-     * and returns all remaining output of stdout and stderr, along with the exit code.\n+     * Closes the handle to stdin, waits for the child process to terminate, and\n+     * reads and returns all remaining output of stdout and stderr, along with\n+     * the exit code.\n      *\n-     * If the child has already been finished then the exit code and any remaining\n-     * unread output of stdout and stderr will be returned.\n+     * If the child has already been finished then the exit code and any\n+     * remaining unread output of stdout and stderr will be returned.\n      *\n-     * This method will fail if the child process's stdout or stderr streams were\n-     * redirected to existing file descriptors.\n+     * This method will fail if the child process's stdout or stderr streams\n+     * were redirected to existing file descriptors.\n      */\n     pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        let output_file = self.output_file();\n-        let error_file = self.error_file();\n+        self.inner.take_input(); // close stdin\n+        let output = Cell::new(self.inner.take_output());\n+        let error = Cell::new(self.inner.take_error());\n+\n+        fn read_everything(r: &mut io::Reader) -> ~[u8] {\n+            let mut ret = ~[];\n+            let mut buf = [0, ..1024];\n+            loop {\n+                match r.read(buf) {\n+                    Some(n) => { ret.push_all(buf.slice_to(n)); }\n+                    None => break\n+                }\n+            }\n+            return ret;\n+        }\n \n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n@@ -359,12 +211,16 @@ impl Process {\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n-            let errput = io::FILE_reader(error_file, false);\n-            ch.send((2, errput.read_whole_stream()));\n+            match error.take() {\n+                Some(ref mut e) => ch.send((2, read_everything(*e))),\n+                None => ch.send((2, ~[]))\n+            }\n         }\n         do task::spawn_sched(task::SingleThreaded) {\n-            let output = io::FILE_reader(output_file, false);\n-            ch_clone.send((1, output.read_whole_stream()));\n+            match output.take() {\n+                Some(ref mut e) => ch_clone.send((1, read_everything(*e))),\n+                None => ch_clone.send((1, ~[]))\n+            }\n         }\n \n         let status = self.finish();\n@@ -382,48 +238,17 @@ impl Process {\n                               error: errs};\n     }\n \n-    fn destroy_internal(&mut self, force: bool) {\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.exit_code.is_none() {\n-            killpid(self.pid, force);\n-            self.finish();\n-        }\n-\n-        #[cfg(windows)]\n-        fn killpid(pid: pid_t, _force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe {\n-                libc::funcs::extra::kernel32::TerminateProcess(\n-                    cast::transmute(pid), 1);\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn killpid(pid: pid_t, force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n-            let signal = if force {\n-                libc::consts::os::posix88::SIGKILL\n-            } else {\n-                libc::consts::os::posix88::SIGTERM\n-            };\n-\n-            unsafe {\n-                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            }\n-        }\n-    }\n-\n     /**\n      * Terminates the process, giving it a chance to clean itself up if\n      * this is supported by the operating system.\n      *\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) { self.destroy_internal(false); }\n+    pub fn destroy(&mut self) {\n+        self.inner.signal(io::process::PleaseExitSignal);\n+        self.finish();\n+    }\n \n     /**\n      * Terminates the process as soon as possible without giving it a\n@@ -432,386 +257,12 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) { self.destroy_internal(true); }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n+    pub fn force_destroy(&mut self) {\n+        self.inner.signal(io::process::MustDieSignal);\n         self.finish();\n-        self.close_outputs();\n-        free_handle(self.handle);\n     }\n }\n \n-struct SpawnProcessResult {\n-    pid: pid_t,\n-    handle: *(),\n-}\n-\n-#[cfg(windows)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n-        TRUE, FALSE,\n-        STARTF_USESTDHANDLES,\n-        INVALID_HANDLE_VALUE,\n-        DUPLICATE_SAME_ACCESS\n-    };\n-    use libc::funcs::extra::kernel32::{\n-        GetCurrentProcess,\n-        DuplicateHandle,\n-        CloseHandle,\n-        CreateProcessA\n-    };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-    use sys;\n-\n-    unsafe {\n-\n-        let mut si = zeroed_startupinfo();\n-        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n-        si.dwFlags = STARTF_USESTDHANDLES;\n-\n-        let cur_proc = GetCurrentProcess();\n-\n-        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n-        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n-        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n-        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let cmd = make_command_line(prog, args);\n-        let mut pi = zeroed_process_information();\n-        let mut create_err = None;\n-\n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                do cmd.with_c_str |cmdp| {\n-                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n-                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n-                                                 0, envp, dirp, &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(os::last_os_error());\n-                    }\n-                }\n-            }\n-        }\n-\n-        CloseHandle(si.hStdInput);\n-        CloseHandle(si.hStdOutput);\n-        CloseHandle(si.hStdError);\n-\n-        for msg in create_err.iter() {\n-            fail2!(\"failure in CreateProcess: {}\", *msg);\n-        }\n-\n-        // We close the thread handle because we don't care about keeping the thread id valid,\n-        // and we aren't keeping the thread handle around to be able to close it later. We don't\n-        // close the process handle however because we want the process id to stay valid at least\n-        // until the calling code closes the process handle.\n-        CloseHandle(pi.hThread);\n-\n-        SpawnProcessResult {\n-            pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *()\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n-    libc::types::os::arch::extra::STARTUPINFO {\n-        cb: 0,\n-        lpReserved: ptr::mut_null(),\n-        lpDesktop: ptr::mut_null(),\n-        lpTitle: ptr::mut_null(),\n-        dwX: 0,\n-        dwY: 0,\n-        dwXSize: 0,\n-        dwYSize: 0,\n-        dwXCountChars: 0,\n-        dwYCountCharts: 0,\n-        dwFillAttribute: 0,\n-        dwFlags: 0,\n-        wShowWindow: 0,\n-        cbReserved2: 0,\n-        lpReserved2: ptr::mut_null(),\n-        hStdInput: ptr::mut_null(),\n-        hStdOutput: ptr::mut_null(),\n-        hStdError: ptr::mut_null()\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n-    libc::types::os::arch::extra::PROCESS_INFORMATION {\n-        hProcess: ptr::mut_null(),\n-        hThread: ptr::mut_null(),\n-        dwProcessId: 0,\n-        dwThreadId: 0\n-    }\n-}\n-\n-// FIXME: this is only pub so it can be tested (see issue #4536)\n-#[cfg(windows)]\n-pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n-    let mut cmd = ~\"\";\n-    append_arg(&mut cmd, prog);\n-    for arg in args.iter() {\n-        cmd.push_char(' ');\n-        append_arg(&mut cmd, *arg);\n-    }\n-    return cmd;\n-\n-    fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-        for i in range(0u, arg.len()) {\n-            append_char_at(cmd, arg, i);\n-        }\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-    }\n-\n-    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n-        match arg[i] as char {\n-            '\"' => {\n-                // Escape quotes.\n-                cmd.push_str(\"\\\\\\\"\");\n-            }\n-            '\\\\' => {\n-                if backslash_run_ends_in_quote(arg, i) {\n-                    // Double all backslashes that are in runs before quotes.\n-                    cmd.push_str(\"\\\\\\\\\");\n-                } else {\n-                    // Pass other backslashes through unescaped.\n-                    cmd.push_char('\\\\');\n-                }\n-            }\n-            c => {\n-                cmd.push_char(c);\n-            }\n-        }\n-    }\n-\n-    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n-        while i < s.len() && s[i] as char == '\\\\' {\n-            i += 1;\n-        }\n-        return i < s.len() && s[i] as char == '\"';\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n-\n-    mod rustrt {\n-        #[abi = \"cdecl\"]\n-        extern {\n-            pub fn rust_unset_sigprocmask();\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe fn set_environ(_envp: *c_void) {}\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn set_environ(envp: *c_void) {\n-        externfn!(fn _NSGetEnviron() -> *mut *c_void);\n-\n-        *_NSGetEnviron() = envp;\n-    }\n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern {\n-            static mut environ: *c_void;\n-        }\n-        environ = envp;\n-    }\n-\n-    unsafe {\n-\n-        let pid = fork();\n-        if pid < 0 {\n-            fail2!(\"failure in fork: {}\", os::last_os_error());\n-        } else if pid > 0 {\n-            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n-        }\n-\n-        rustrt::rust_unset_sigprocmask();\n-\n-        if dup2(in_fd, 0) == -1 {\n-            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n-        }\n-        if dup2(out_fd, 1) == -1 {\n-            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n-        }\n-        if dup2(err_fd, 2) == -1 {\n-            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n-        }\n-        // close all other fds\n-        for fd in range(3, getdtablesize()).invert() {\n-            close(fd as c_int);\n-        }\n-\n-        do with_dirp(dir) |dirp| {\n-            if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail2!(\"failure in chdir: {}\", os::last_os_error());\n-            }\n-        }\n-\n-        do with_envp(env) |envp| {\n-            if !envp.is_null() {\n-                set_environ(envp);\n-            }\n-            do with_argv(prog, args) |argv| {\n-                execvp(*argv, argv);\n-                // execvp only returns if an error occurred\n-                fail2!(\"failure in execvp: {}\", os::last_os_error());\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n-    use vec;\n-\n-    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n-    // a reference to the intermediary byte buffers. So first build an array to\n-    // hold all the ~[u8] byte strings.\n-    let mut tmps = vec::with_capacity(args.len() + 1);\n-\n-    tmps.push(prog.to_c_str());\n-\n-    for arg in args.iter() {\n-        tmps.push(arg.to_c_str());\n-    }\n-\n-    // Next, convert each of the byte strings into a pointer. This is\n-    // technically unsafe as the caller could leak these pointers out of our\n-    // scope.\n-    let mut ptrs = do tmps.map |tmp| {\n-        tmp.with_ref(|buf| buf)\n-    };\n-\n-    // Finally, make sure we add a null pointer.\n-    ptrs.push(ptr::null());\n-\n-    ptrs.as_imm_buf(|buf, _| cb(buf))\n-}\n-\n-#[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n-    use vec;\n-\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n-    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = vec::with_capacity(env.len());\n-\n-            for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n-                tmps.push(kv.to_c_str());\n-            }\n-\n-            // Once again, this is unsafe.\n-            let mut ptrs = do tmps.map |tmp| {\n-                tmp.with_ref(|buf| buf)\n-            };\n-            ptrs.push(ptr::null());\n-\n-            do ptrs.as_imm_buf |buf, _| {\n-                unsafe { cb(cast::transmute(buf)) }\n-            }\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n-    // On win32 we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = ~[];\n-\n-            for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n-                blk.push_all(kv.as_bytes());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            do blk.as_imm_buf |p, _len| {\n-                unsafe { cb(cast::transmute(p)) }\n-            }\n-        }\n-        _ => cb(ptr::mut_null())\n-    }\n-}\n-\n-fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n-    match d {\n-      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n-      None => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn free_handle(handle: *()) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn free_handle(_handle: *()) {\n-    // unix has no process handle object, just a pid\n-}\n-\n /**\n  * Spawns a process and waits for it to terminate. The process will\n  * inherit the current stdin/stdout/stderr file descriptors.\n@@ -825,13 +276,14 @@ fn free_handle(_handle: *()) {\n  *\n  * The process's exit code\n  */\n+#[fixed_stack_segment] #[inline(never)]\n pub fn process_status(prog: &str, args: &[~str]) -> int {\n     let mut prog = Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n-        in_fd: Some(0),\n-        out_fd: Some(1),\n-        err_fd: Some(2)\n+        in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n+        out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n+        err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n     });\n     prog.finish()\n }\n@@ -853,138 +305,17 @@ pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n     prog.finish_with_output()\n }\n \n-/**\n- * Waits for a process to exit and returns the exit code, failing\n- * if there is no process with the specified id.\n- *\n- * Note that this is private to avoid race conditions on unix where if\n- * a user calls waitpid(some_process.get_id()) then some_process.finish()\n- * and some_process.destroy() and some_process.finalize() will then either\n- * operate on a none-existent process or, even worse, on a newer process\n- * with the same id.\n- */\n-fn waitpid(pid: pid_t) -> int {\n-    return waitpid_os(pid);\n-\n-    #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n-            SYNCHRONIZE,\n-            PROCESS_QUERY_INFORMATION,\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_FAILED\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            OpenProcess,\n-            GetExitCodeProcess,\n-            CloseHandle,\n-            WaitForSingleObject\n-        };\n-\n-        unsafe {\n-\n-            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n-            if proc.is_null() {\n-                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n-            }\n-\n-            loop {\n-                let mut status = 0;\n-                if GetExitCodeProcess(proc, &mut status) == FALSE {\n-                    CloseHandle(proc);\n-                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n-                }\n-                if status != STILL_ACTIVE {\n-                    CloseHandle(proc);\n-                    return status as int;\n-                }\n-                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n-                    CloseHandle(proc);\n-                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::funcs::posix01::wait::*;\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0xffi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0x7fi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            (status >> 8i32) & 0xffi32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            status >> 8i32\n-        }\n-\n-        let mut status = 0 as c_int;\n-        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n-            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n-        }\n-\n-        return if WIFEXITED(status) {\n-            WEXITSTATUS(status) as int\n-        } else {\n-            1\n-        };\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use io;\n     use libc::c_int;\n     use option::{Option, None, Some};\n     use os;\n     use path::Path;\n     use run;\n     use str;\n     use unstable::running_on_valgrind;\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn test_make_command_line() {\n-        assert_eq!(\n-            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n-            ~\"prog aaa bbb ccc\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"echo\", [~\"a b c\"]),\n-            ~\"echo \\\"a b c\\\"\"\n-        );\n-    }\n+    use rt::io::native::file;\n+    use rt::io::{Writer, Reader};\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n@@ -1068,10 +399,6 @@ mod tests {\n             err_fd: Some(pipe_err.out)\n         });\n \n-        assert!(proc.input_redirected());\n-        assert!(proc.output_redirected());\n-        assert!(proc.error_redirected());\n-\n         os::close(pipe_in.input);\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n@@ -1086,21 +413,21 @@ mod tests {\n     }\n \n     fn writeclose(fd: c_int, s: &str) {\n-        let writer = io::fd_writer(fd, false);\n-        writer.write_str(s);\n-        os::close(fd);\n+        let mut writer = file::FileDesc::new(fd);\n+        writer.write(s.as_bytes());\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let file = os::fdopen(fd);\n-            let reader = io::FILE_reader(file, false);\n-            let buf = reader.read_whole_stream();\n-            os::fclose(file);\n-            str::from_utf8(buf)\n+        let mut res = ~[];\n+        let mut reader = file::FileDesc::new(fd);\n+        let mut buf = [0, ..1024];\n+        loop {\n+            match reader.read(buf) {\n+                Some(n) => { res.push_all(buf.slice_to(n)); }\n+                None => break\n+            }\n         }\n+        str::from_utf8_owned(res)\n     }\n \n     #[test]\n@@ -1223,36 +550,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[cfg(not(windows),not(target_os=\"android\"))]\n-    fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions {\n-            env: None,\n-            dir: None,\n-            in_fd: Some(0),\n-            out_fd: Some(1),\n-            err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n-        prog.finish_with_output();\n-    }\n-    #[test]\n-    #[should_fail]\n-    #[cfg(not(windows),target_os=\"android\")]\n-    fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                         run::ProcessOptions {\n-            env: None,\n-            dir: None,\n-            in_fd: Some(0),\n-            out_fd: Some(1),\n-            err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n-        prog.finish_with_output();\n-    }\n-\n     #[cfg(unix,not(target_os=\"android\"))]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"pwd\", [], run::ProcessOptions {"}, {"sha": "5222c4f59b723e1c92fbb9d64dfccf9b744ff39b", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -15,7 +15,6 @@\n extern mod extra;\n \n use extra::time::precise_time_s;\n-use std::io;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -70,11 +69,15 @@ fn shift_push() {\n }\n \n fn read_line() {\n+    use std::rt::io::{Reader, Open};\n+    use std::rt::io::file::FileInfo;\n+    use std::rt::io::buffered::BufferedReader;\n+\n     let path = Path(env!(\"CFG_SRC_DIR\"))\n         .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n \n     for _ in range(0, 3) {\n-        let reader = io::file_reader(&path).unwrap();\n+        let mut reader = BufferedReader::new(path.open_reader(Open).unwrap());\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "445b28b693cfccaa7859d214921e50862d953df6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ede2ea4e2e9384ac5bd614012d85ed213873dab/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=0ede2ea4e2e9384ac5bd614012d85ed213873dab", "patch": "@@ -156,17 +156,21 @@ fn make_sequence_processor(sz: uint,\n \n // given a FASTA file on stdin, process sequence THREE\n fn main() {\n-    let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n-       // FIXME: Using this compile-time env variable is a crummy way to\n-       // get to this massive data set, but include_bin! chokes on it (#2598)\n-       let path = Path(env!(\"CFG_SRC_DIR\"))\n-           .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n-       io::file_reader(&path).unwrap()\n-   } else {\n-      io::stdin()\n-   };\n-\n+    use std::rt::io::{Reader, Open};\n+    use std::rt::io::file::FileInfo;\n+    use std::rt::io::native::stdio;\n+    use std::rt::io::buffered::BufferedReader;\n \n+    let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n+        // FIXME: Using this compile-time env variable is a crummy way to\n+        // get to this massive data set, but include_bin! chokes on it (#2598)\n+        let path = Path(env!(\"CFG_SRC_DIR\"))\n+            .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n+        ~path.open_reader(Open).unwrap() as ~Reader\n+    } else {\n+        ~stdio::stdin() as ~Reader\n+    };\n+    let mut rdr = BufferedReader::new(rdr);\n \n     // initialize each sequence sorter\n     let sizes = ~[1u,2,3,4,6,12,18];\n@@ -193,8 +197,11 @@ fn main() {\n    // reading the sequence of interest\n    let mut proc_mode = false;\n \n-   while !rdr.eof() {\n-      let line: ~str = rdr.read_line();\n+   loop {\n+      let line = match rdr.read_line() {\n+          Some(ln) => ln, None => break,\n+      };\n+      let line = line.trim().to_owned();\n \n       if line.len() == 0u { continue; }\n "}]}