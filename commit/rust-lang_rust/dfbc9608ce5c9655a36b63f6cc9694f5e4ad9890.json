{"sha": "dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYmM5NjA4Y2U1Yzk2NTVhMzZiNjNmNmNjOTY5NGY1ZTRhZDk4OTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T05:51:23Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:36:20Z"}, "message": "rustc: replace Repr/UserString impls with Debug/Display ones.", "tree": {"sha": "84244801e94d6024105f362481633f62c9e0bc94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84244801e94d6024105f362481633f62c9e0bc94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "html_url": "https://github.com/rust-lang/rust/commit/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e333d31b6237c2e3775b254e3808d1137c6b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e333d31b6237c2e3775b254e3808d1137c6b94", "html_url": "https://github.com/rust-lang/rust/commit/17e333d31b6237c2e3775b254e3808d1137c6b94"}], "stats": {"total": 2873, "additions": 977, "deletions": 1896}, "files": [{"sha": "693ccc13f1e4645318d035cc1e1e399a735475cb", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -898,7 +898,7 @@ fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds w\n fn parse_builtin_bounds_<F>(st: &mut PState, _conv: &mut F) -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n-    let mut builtin_bounds = ty::empty_builtin_bounds();\n+    let mut builtin_bounds = ty::BuiltinBounds::empty();\n \n     loop {\n         match next(st) {"}, {"sha": "abdaa9f38c0e1e06a5eee2ea2918d9c904d42444", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -25,6 +25,7 @@ use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n+#[derive(Debug)]\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n@@ -400,7 +401,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr\n+        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n@@ -454,34 +455,3 @@ pub fn object_region_bounds<'tcx>(\n     let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n     ty::required_region_bounds(tcx, open_ty, predicates)\n }\n-\n-impl<'tcx> Repr for Implication<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            Implication::RegionSubRegion(_, ref r_a, ref r_b) => {\n-                format!(\"RegionSubRegion({}, {})\",\n-                        r_a.repr(),\n-                        r_b.repr())\n-            }\n-\n-            Implication::RegionSubGeneric(_, ref r, ref p) => {\n-                format!(\"RegionSubGeneric({}, {})\",\n-                        r.repr(),\n-                        p.repr())\n-            }\n-\n-            Implication::RegionSubClosure(_, ref a, ref b, ref c) => {\n-                format!(\"RegionSubClosure({}, {}, {})\",\n-                        a.repr(),\n-                        b.repr(),\n-                        c.repr())\n-            }\n-\n-            Implication::Predicate(ref def_id, ref p) => {\n-                format!(\"Predicate({}, {})\",\n-                        def_id.repr(),\n-                        p.repr())\n-            }\n-        }\n-    }\n-}"}, {"sha": "9f3dd0a4b736bf8cf881812d45ad7076321d031a", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             \"{}: {} ({})\",\n                  trace.origin,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr));\n+                 terr);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>"}, {"sha": "37f3a12b05f6124ca43b35c6c8d3c39187ae82e3", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -518,7 +518,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)\n                                                -> (T, SkolemizationMap)\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     /*!\n      * Replace all regions bound by `binder` with skolemized regions and\n@@ -616,7 +616,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                              snapshot: &CombinedSnapshot,\n                              value: &T)\n                              -> T\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n "}, {"sha": "71febd981e045eaa72c9be0f41cda10974989dbb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 140, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -160,7 +160,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     origin: TypeOrigin,\n     values: ValuePairs<'tcx>,\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n                                            -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         /*! See `higher_ranked::skolemize_late_bound_regions` */\n \n@@ -733,7 +733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          snapshot: &CombinedSnapshot,\n                          value: &T)\n                          -> T\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         /*! See `higher_ranked::plug_leaks` */\n \n@@ -979,7 +979,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Some(t) if ty::type_is_error(t) => (),\n             _ => {\n                 let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                    format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n+                    format!(\" ({})\", t_err)\n                 });\n \n                 self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         ty_fold::replace_late_bound_regions(\n             self.tcx,\n@@ -1099,9 +1099,9 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for TypeTrace<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TypeTrace({})\", self.origin.repr())\n+impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeTrace({:?})\", self.origin)\n     }\n }\n \n@@ -1123,44 +1123,6 @@ impl TypeOrigin {\n     }\n }\n \n-impl<'tcx> Repr for TypeOrigin {\n-    fn repr(&self) -> String {\n-        match *self {\n-            MethodCompatCheck(a) => {\n-                format!(\"MethodCompatCheck({})\", a.repr())\n-            }\n-            ExprAssignable(a) => {\n-                format!(\"ExprAssignable({})\", a.repr())\n-            }\n-            Misc(a) => format!(\"Misc({})\", a.repr()),\n-            RelateTraitRefs(a) => {\n-                format!(\"RelateTraitRefs({})\", a.repr())\n-            }\n-            RelateSelfType(a) => {\n-                format!(\"RelateSelfType({})\", a.repr())\n-            }\n-            RelateOutputImplTypes(a) => {\n-                format!(\"RelateOutputImplTypes({})\", a.repr())\n-            }\n-            MatchExpressionArm(a, b) => {\n-                format!(\"MatchExpressionArm({}, {})\", a.repr(), b.repr())\n-            }\n-            IfExpression(a) => {\n-                format!(\"IfExpression({})\", a.repr())\n-            }\n-            IfExpressionWithNoElse(a) => {\n-                format!(\"IfExpressionWithNoElse({})\", a.repr())\n-            }\n-            RangeExpression(a) => {\n-                format!(\"RangeExpression({})\", a.repr())\n-            }\n-            EquatePredicate(a) => {\n-                format!(\"EquatePredicate({})\", a.repr())\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -1190,70 +1152,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for SubregionOrigin<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            Subtype(ref a) => {\n-                format!(\"Subtype({})\", a.repr())\n-            }\n-            InfStackClosure(a) => {\n-                format!(\"InfStackClosure({})\", a.repr())\n-            }\n-            InvokeClosure(a) => {\n-                format!(\"InvokeClosure({})\", a.repr())\n-            }\n-            DerefPointer(a) => {\n-                format!(\"DerefPointer({})\", a.repr())\n-            }\n-            FreeVariable(a, b) => {\n-                format!(\"FreeVariable({}, {})\", a.repr(), b)\n-            }\n-            IndexSlice(a) => {\n-                format!(\"IndexSlice({})\", a.repr())\n-            }\n-            RelateObjectBound(a) => {\n-                format!(\"RelateObjectBound({})\", a.repr())\n-            }\n-            RelateParamBound(a, b) => {\n-                format!(\"RelateParamBound({},{})\",\n-                        a.repr(),\n-                        b.repr())\n-            }\n-            RelateRegionParamBound(a) => {\n-                format!(\"RelateRegionParamBound({})\",\n-                        a.repr())\n-            }\n-            RelateDefaultParamBound(a, b) => {\n-                format!(\"RelateDefaultParamBound({},{})\",\n-                        a.repr(),\n-                        b.repr())\n-            }\n-            Reborrow(a) => format!(\"Reborrow({})\", a.repr()),\n-            ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{:?})\", a.repr(), b)\n-            }\n-            ReferenceOutlivesReferent(_, a) => {\n-                format!(\"ReferenceOutlivesReferent({})\", a.repr())\n-            }\n-            ExprTypeIsNotInScope(a, b) => {\n-                format!(\"ExprTypeIsNotInScope({}, {})\",\n-                        a.repr(),\n-                        b.repr())\n-            }\n-            BindingTypeIsNotValidAtDecl(a) => {\n-                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr())\n-            }\n-            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr()),\n-            CallArg(a) => format!(\"CallArg({})\", a.repr()),\n-            CallReturn(a) => format!(\"CallReturn({})\", a.repr()),\n-            Operand(a) => format!(\"Operand({})\", a.repr()),\n-            AddrOf(a) => format!(\"AddrOf({})\", a.repr()),\n-            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr()),\n-            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr()),\n-        }\n-    }\n-}\n-\n impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -1269,33 +1167,3 @@ impl RegionVariableOrigin {\n         }\n     }\n }\n-\n-impl<'tcx> Repr for RegionVariableOrigin {\n-    fn repr(&self) -> String {\n-        match *self {\n-            MiscVariable(a) => {\n-                format!(\"MiscVariable({})\", a.repr())\n-            }\n-            PatternRegion(a) => {\n-                format!(\"PatternRegion({})\", a.repr())\n-            }\n-            AddrOfRegion(a) => {\n-                format!(\"AddrOfRegion({})\", a.repr())\n-            }\n-            Autoref(a) => format!(\"Autoref({})\", a.repr()),\n-            Coercion(a) => format!(\"Coercion({})\", a.repr()),\n-            EarlyBoundRegion(a, b) => {\n-                format!(\"EarlyBoundRegion({},{})\", a.repr(), b.repr())\n-            }\n-            LateBoundRegion(a, b, c) => {\n-                format!(\"LateBoundRegion({},{},{:?})\", a.repr(), b.repr(), c)\n-            }\n-            BoundRegionInCoherence(a) => {\n-                format!(\"bound_regionInCoherence({})\", a.repr())\n-            }\n-            UpvarRegion(a, b) => {\n-                format!(\"UpvarRegion({}, {})\", a.repr(), b.repr())\n-            }\n-        }\n-    }\n-}"}, {"sha": "024889d08290b9bc6a29b2f0488801355d1d12c0", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 21, "deletions": 47, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -30,10 +30,11 @@ use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n+use std::fmt;\n use std::iter::repeat;\n use std::u32;\n use syntax::ast;\n@@ -68,7 +69,7 @@ pub enum Verify<'tcx> {\n     VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n@@ -959,7 +960,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n #[derive(Copy, Clone, PartialEq, Debug)]\n enum Classification { Expanding, Contracting }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum VarValue { NoValue, Value(Region), ErrorValue }\n \n struct VarData {\n@@ -1589,31 +1590,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n }\n \n-impl Repr for Constraint {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ConstrainVarSubVar(a, b) => {\n-                format!(\"ConstrainVarSubVar({}, {})\", a.repr(), b.repr())\n-            }\n-            ConstrainRegSubVar(a, b) => {\n-                format!(\"ConstrainRegSubVar({}, {})\", a.repr(), b.repr())\n-            }\n-            ConstrainVarSubReg(a, b) => {\n-                format!(\"ConstrainVarSubReg({}, {})\", a.repr(), b.repr())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr for Verify<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for Verify<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             VerifyRegSubReg(_, ref a, ref b) => {\n-                format!(\"VerifyRegSubReg({}, {})\", a.repr(), b.repr())\n+                write!(f, \"VerifyRegSubReg({:?}, {:?})\", a, b)\n             }\n             VerifyGenericBound(_, ref p, ref a, ref bs) => {\n-                format!(\"VerifyGenericBound({}, {}, {})\",\n-                        p.repr(), a.repr(), bs.repr())\n+                write!(f, \"VerifyGenericBound({:?}, {:?}, {:?})\", p, a, bs)\n             }\n         }\n     }\n@@ -1634,38 +1618,28 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     }\n }\n \n-impl Repr for VarValue {\n-    fn repr(&self) -> String {\n-        match *self {\n-            NoValue => format!(\"NoValue\"),\n-            Value(r) => format!(\"Value({})\", r.repr()),\n-            ErrorValue => format!(\"ErrorValue\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr for RegionAndOrigin<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"RegionAndOrigin({},{})\",\n-                self.region.repr(),\n-                self.origin.repr())\n+impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionAndOrigin({},{})\",\n+               self.region.repr(),\n+               self.origin.repr())\n     }\n }\n \n-impl<'tcx> Repr for GenericKind<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            GenericKind::Param(ref p) => p.repr(),\n-            GenericKind::Projection(ref p) => p.repr(),\n+            GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n         }\n     }\n }\n \n-impl<'tcx> UserString for GenericKind<'tcx> {\n-    fn user_string(&self) -> String {\n+impl<'tcx> fmt::Display for GenericKind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            GenericKind::Param(ref p) => p.user_string(),\n-            GenericKind::Projection(ref p) => p.user_string(),\n+            GenericKind::Param(ref p) => write!(f, \"{}\", p),\n+            GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n         }\n     }\n }"}, {"sha": "6ff774b4bb01f211b2393830882ed9e5f185bdac", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -16,6 +16,8 @@ use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n use middle::ty::{self, Ty};\n use util::ppaux::Repr;\n \n+use std::fmt;\n+\n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n use syntax::ast;\n@@ -277,13 +279,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for TransmuteRestriction<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TransmuteRestriction(id={}, original=({},{}), substituted=({},{}))\",\n-                self.id,\n-                self.original_from.repr(),\n-                self.original_to.repr(),\n-                self.substituted_from.repr(),\n-                self.substituted_to.repr())\n+impl<'tcx> fmt::Debug for TransmuteRestriction<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TransmuteRestriction(id={}, original=({:?},{:?}), substituted=({:?},{:?}))\",\n+               self.id,\n+               self.original_from,\n+               self.original_to,\n+               self.substituted_from,\n+               self.substituted_to)\n     }\n }"}, {"sha": "935c077b6338f42defc946ae14229e9f6e74da42", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -84,12 +84,12 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n-use syntax::parse::token;\n \n use std::cell::RefCell;\n+use std::fmt;\n use std::rc::Rc;\n \n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum categorization<'tcx> {\n     cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n     cat_static_item,\n@@ -103,14 +103,14 @@ pub enum categorization<'tcx> {\n }\n \n // Represents any kind of upvar\n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n     pub kind: ty::ClosureKind\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum PointerKind {\n     /// `Box<T>`\n     Unique,\n@@ -127,7 +127,7 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(InteriorOffsetKind, ElementKind),\n@@ -184,7 +184,7 @@ pub enum Note {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq)]\n pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -1569,33 +1569,36 @@ impl<'tcx> cmt_<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for cmt_<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n-                self.cat.repr(),\n-                self.id,\n-                self.mutbl,\n-                self.ty.repr())\n+impl<'tcx> fmt::Debug for cmt_<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{{{:?} id:{} m:{:?} ty:{:?}}}\",\n+               self.cat,\n+               self.id,\n+               self.mutbl,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr for categorization<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for categorization<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            cat_static_item |\n-            cat_rvalue(..) |\n-            cat_local(..) |\n-            cat_upvar(..) => {\n-                format!(\"{:?}\", *self)\n+            cat_static_item => write!(f, \"static\"),\n+            cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n+            cat_local(id) => {\n+               let name = ty::tls::with(|tcx| ty::local_var_name_str(tcx, id));\n+               write!(f, \"local({})\", name)\n+            }\n+            cat_upvar(upvar) => {\n+                write!(f, \"upvar({:?})\", upvar)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\", cmt.cat.repr(), ptr.repr(), derefs)\n+                write!(f, \"{:?}-{:?}{}->\", cmt.cat, ptr, derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n-                format!(\"{}.{}\", cmt.cat.repr(), interior.repr())\n+                write!(f, \"{:?}.{:?}\", cmt.cat, interior)\n             }\n             cat_downcast(ref cmt, _) => {\n-                format!(\"{}->(enum)\", cmt.cat.repr())\n+                write!(f, \"{:?}->(enum)\", cmt.cat)\n             }\n         }\n     }\n@@ -1614,39 +1617,33 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl Repr for PointerKind {\n-    fn repr(&self) -> String {\n+impl fmt::Debug for PointerKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Unique => {\n-                format!(\"Box\")\n-            }\n+            Unique => write!(f, \"Box\"),\n             BorrowedPtr(ty::ImmBorrow, ref r) |\n             Implicit(ty::ImmBorrow, ref r) => {\n-                format!(\"&{}\", r.repr())\n+                write!(f, \"&{:?}\", r)\n             }\n             BorrowedPtr(ty::MutBorrow, ref r) |\n             Implicit(ty::MutBorrow, ref r) => {\n-                format!(\"&{} mut\", r.repr())\n+                write!(f, \"&{:?} mut\", r)\n             }\n             BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n             Implicit(ty::UniqueImmBorrow, ref r) => {\n-                format!(\"&{} uniq\", r.repr())\n-            }\n-            UnsafePtr(_) => {\n-                format!(\"*\")\n+                write!(f, \"&{:?} uniq\", r)\n             }\n+            UnsafePtr(_) => write!(f, \"*\")\n         }\n     }\n }\n \n-impl Repr for InteriorKind {\n-    fn repr(&self) -> String {\n+impl fmt::Debug for InteriorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).to_string()\n-            }\n-            InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(..) => \"[]\".to_string(),\n+            InteriorField(NamedField(fld)) => write!(f, \"{}\", fld),\n+            InteriorField(PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }\n }\n@@ -1663,25 +1660,19 @@ fn element_kind(t: Ty) -> ElementKind {\n     }\n }\n \n-impl Repr for ty::ClosureKind {\n-    fn repr(&self) -> String {\n-        format!(\"Upvar({:?})\", self)\n-    }\n-}\n-\n-impl Repr for Upvar {\n-    fn repr(&self) -> String {\n-        format!(\"Upvar({})\", self.kind.repr())\n+impl fmt::Debug for Upvar {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}/{:?}\", self.id, self.kind)\n     }\n }\n \n-impl UserString for Upvar {\n-    fn user_string(&self) -> String {\n+impl fmt::Display for Upvar {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let kind = match self.kind {\n             ty::FnClosureKind => \"Fn\",\n             ty::FnMutClosureKind => \"FnMut\",\n             ty::FnOnceClosureKind => \"FnOnce\",\n         };\n-        format!(\"captured outer variable in an `{}` closure\", kind)\n+        write!(f, \"captured outer variable in an `{}` closure\", kind)\n     }\n }"}, {"sha": "957bd76bb94269710aa2a41e558e9ab812f463c7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -29,7 +29,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n /// identify each in-scope parameter by an *index* and a *parameter\n /// space* (which indices where the parameter is defined; see\n /// `ParamSpace`).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Substs<'tcx> {\n     pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n@@ -38,7 +38,7 @@ pub struct Substs<'tcx> {\n /// Represents the values to use when substituting lifetime parameters.\n /// If the value is `ErasedRegions`, then this subst is occurring during\n /// trans, and all region parameters will be replaced with `ty::ReStatic`.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n@@ -240,13 +240,11 @@ pub struct SeparateVecsPerParamSpace<T> {\n }\n \n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"VecPerParamSpace {{\"));\n-        for space in &ParamSpace::all() {\n-            try!(write!(fmt, \"{:?}: {:?}, \", *space, self.get_slice(*space)));\n-        }\n-        try!(write!(fmt, \"}}\"));\n-        Ok(())\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"[{:?};{:?};{:?}]\",\n+               self.get_slice(TypeSpace),\n+               self.get_slice(SelfSpace),\n+               self.get_slice(FnSpace))\n     }\n }\n "}, {"sha": "7d4bbb5d7f03f2939f611e9b6ed32233e497efcd", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -69,7 +69,7 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(),\n-                ty::type_err_to_str(infcx.tcx, &error.err));\n+                error.err);\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -217,7 +217,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(),\n-                                    ty::type_err_to_str(infcx.tcx, &err));\n+                                    err);\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n@@ -227,7 +227,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(),\n-                                    ty::type_err_to_str(infcx.tcx, &err));\n+                                    err);\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n@@ -252,7 +252,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         expected_trait_ref.self_ty().user_string(),\n                         expected_trait_ref.user_string(),\n                         actual_trait_ref.user_string(),\n-                        ty::type_err_to_str(infcx.tcx, e));\n+                        e);\n                     note_obligation_cause(infcx, obligation);\n             }\n         }"}, {"sha": "0828a67c6c678f96552fb265dcdf8ee7d54f7cd1", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -10,8 +10,9 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, RegionEscape, Ty};\n+\n use std::collections::HashSet;\n-use std::default::Default;\n+use std::fmt;\n use syntax::ast;\n use util::common::ErrorReported;\n use util::ppaux::Repr;\n@@ -461,11 +462,11 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-impl<'tcx> Repr for RegionObligation<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"RegionObligation(sub_region={}, sup_type={})\",\n-                self.sub_region.repr(),\n-                self.sup_type.repr())\n+impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n     }\n }\n "}, {"sha": "35855767e609882e15018ab400dd3ad023198bc9", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -219,7 +219,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Debug,Clone)]\n+#[derive(Clone)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -277,13 +277,13 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct VtableDefaultImplData<N> {\n     pub trait_def_id: ast::DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Debug,Clone)]\n+#[derive(Clone)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }\n@@ -433,7 +433,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     debug!(\"normalize_param_env(value={})\", value.repr());\n "}, {"sha": "daa03c5160c01396b43498949a9617c59a409b2c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -27,6 +27,7 @@ use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;\n \n+#[derive(Debug)]\n pub enum ObjectSafetyViolation<'tcx> {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n@@ -352,19 +353,6 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n     error\n }\n \n-impl<'tcx> Repr for ObjectSafetyViolation<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ObjectSafetyViolation::SizedSelf =>\n-                format!(\"SizedSelf\"),\n-            ObjectSafetyViolation::SupertraitSelf =>\n-                format!(\"SupertraitSelf\"),\n-            ObjectSafetyViolation::Method(ref m, code) =>\n-                format!(\"Method({},{:?})\", m.repr(), code),\n-        }\n-    }\n-}\n-\n fn is_self<'tcx>(ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyParam(ref data) => data.space == subst::SelfSpace,"}, {"sha": "967edabc0b9c1ab364b4b255d5bb6b56eb6d1458", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -30,6 +30,8 @@ use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n use util::ppaux::Repr;\n \n+use std::fmt;\n+\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -40,6 +42,7 @@ pub type ProjectionTyObligation<'tcx> =\n     Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n \n /// When attempting to resolve `<T as TraitRef>::Name` ...\n+#[derive(Debug)]\n pub enum ProjectionTyError<'tcx> {\n     /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n     TooManyCandidates,\n@@ -53,7 +56,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::type_err<'tcx>\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n@@ -193,7 +196,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -204,7 +207,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -236,7 +239,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n         }\n     }\n \n-    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes + Clone>(&mut self, value: &T) -> T {\n+    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projection_types() {\n@@ -864,7 +867,7 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n                 &format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n                          obligation.repr(),\n                          projection.repr(),\n-                         ty::type_err_to_str(selcx.tcx(), &e)));\n+                         e));\n         }\n     }\n \n@@ -915,32 +918,6 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                                        trait_ref.repr()));\n }\n \n-impl<'tcx> Repr for ProjectionTyError<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ProjectionTyError::TooManyCandidates =>\n-                format!(\"NoCandidate\"),\n-            ProjectionTyError::TraitSelectionError(ref e) =>\n-                format!(\"TraitSelectionError({})\", e.repr()),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr for ProjectionTyCandidate<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ProjectionTyCandidate::ParamEnv(ref data) =>\n-                format!(\"ParamEnv({})\", data.repr()),\n-            ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr()),\n-            ProjectionTyCandidate::Closure(ref data) =>\n-                format!(\"Closure({})\", data.repr()),\n-            ProjectionTyCandidate::FnPointer(a) =>\n-                format!(\"FnPointer(({}))\", a.repr()),\n-        }\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n         Normalized {\n@@ -950,10 +927,10 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n     }\n }\n \n-impl<'tcx, T:Repr> Repr for Normalized<'tcx, T> {\n-    fn repr(&self) -> String {\n-        format!(\"Normalized({},{})\",\n-                self.value.repr(),\n-                self.obligations.repr())\n+impl<'tcx, T:fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Normalized({:?},{:?})\",\n+               self.value,\n+               self.obligations)\n     }\n }"}, {"sha": "96d48faf9e0922370415f6872e2499e39536b589", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -44,7 +44,9 @@ use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n use middle::ty_match;\n use middle::ty_relate::TypeRelation;\n+\n use std::cell::RefCell;\n+use std::fmt;\n use std::rc::Rc;\n use syntax::{abi, ast};\n use util::common::ErrorReported;\n@@ -2666,14 +2668,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   origin,\n                                                   impl_trait_ref.value.clone(),\n                                                   skol_obligation_trait_ref) {\n-            debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n-                   ty::type_err_to_str(self.tcx(), &e));\n+            debug!(\"match_impl: failed sub_trait_refs due to `{}`\", e);\n             return Err(());\n         }\n \n         if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n-            debug!(\"match_impl: failed leak check due to `{}`\",\n-                   ty::type_err_to_str(self.tcx(), &e));\n+            debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }\n \n@@ -2962,28 +2962,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for SelectionCandidate<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n-            ErrorCandidate => format!(\"ErrorCandidate\"),\n-            BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n-            BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n-            BuiltinUnsizeCandidate => format!(\"BuiltinUnsizeCandidate\"),\n-            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr()),\n-            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr()),\n-            DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n-            DefaultImplObjectCandidate(t) => format!(\"DefaultImplObjectCandidate({:?})\", t),\n-            ProjectionCandidate => format!(\"ProjectionCandidate\"),\n-            FnPointerCandidate => format!(\"FnPointerCandidate\"),\n-            ObjectCandidate => format!(\"ObjectCandidate\"),\n-            ClosureCandidate(c, ref s) => {\n-                format!(\"ClosureCandidate({:?},{})\", c, s.repr())\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n@@ -3031,10 +3009,9 @@ impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     }\n }\n \n-impl<'o,'tcx> Repr for TraitObligationStack<'o,'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TraitObligationStack({})\",\n-                self.obligation.repr())\n+impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n "}, {"sha": "2c6feb66fa8ca72e683fc920d88697d6e9b80298", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 43, "deletions": 95, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -302,24 +302,12 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n-    }\n-}\n-\n impl<'tcx, N> fmt::Debug for super::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableClosure({:?})\", self.closure_def_id)\n     }\n }\n \n-impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(...)\")\n-    }\n-}\n-\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n@@ -485,118 +473,84 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n }\n \n-impl<'tcx,O:Repr> Repr for super::Obligation<'tcx, O> {\n-    fn repr(&self) -> String {\n-        format!(\"Obligation(predicate={},depth={})\",\n-                self.predicate.repr(),\n-                self.recursion_depth)\n+impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Obligation(predicate={:?},depth={})\",\n+               self.predicate,\n+               self.recursion_depth)\n     }\n }\n \n-impl<'tcx, N:Repr> Repr for super::Vtable<'tcx, N> {\n-    fn repr(&self) -> String {\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::VtableImpl(ref v) =>\n-                v.repr(),\n+                write!(f, \"{:?}\", v),\n \n             super::VtableDefaultImpl(ref t) =>\n-                t.repr(),\n+                write!(f, \"{:?}\", t),\n \n             super::VtableClosure(ref d) =>\n-                d.repr(),\n+                write!(f, \"{:?}\", d),\n \n             super::VtableFnPointer(ref d) =>\n-                format!(\"VtableFnPointer({})\",\n-                        d.repr()),\n+                write!(f, \"VtableFnPointer({:?})\", d),\n \n             super::VtableObject(ref d) =>\n-                format!(\"VtableObject({})\",\n-                        d.repr()),\n+                write!(f, \"VtableObject({:?})\", d),\n \n             super::VtableParam(ref n) =>\n-                format!(\"VtableParam({})\",\n-                        n.repr()),\n+                write!(f, \"VtableParam({:?})\", n),\n \n             super::VtableBuiltin(ref d) =>\n-                d.repr()\n+                write!(f, \"{:?}\", d)\n         }\n     }\n }\n \n-impl<'tcx, N:Repr> Repr for super::VtableImplData<'tcx, N> {\n-    fn repr(&self) -> String {\n-        format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n-                self.impl_def_id.repr(),\n-                self.substs.repr(),\n-                self.nested.repr())\n-    }\n-}\n-\n-impl<'tcx, N:Repr> Repr for super::VtableClosureData<'tcx, N> {\n-    fn repr(&self) -> String {\n-        format!(\"VtableClosure(closure_def_id={}, substs={}, nested={})\",\n-                self.closure_def_id.repr(),\n-                self.substs.repr(),\n-                self.nested.repr())\n-    }\n-}\n-\n-impl<'tcx, N:Repr> Repr for super::VtableBuiltinData<N> {\n-    fn repr(&self) -> String {\n-        format!(\"VtableBuiltin(nested={})\",\n-                self.nested.repr())\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableImplData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.impl_def_id,\n+               self.substs,\n+               self.nested)\n     }\n }\n \n-impl<'tcx, N:Repr> Repr for super::VtableDefaultImplData<N> {\n-    fn repr(&self) -> String {\n-        format!(\"VtableDefaultImplData(trait_def_id={}, nested={})\",\n-                self.trait_def_id.repr(),\n-                self.nested.repr())\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n     }\n }\n \n-impl<'tcx> Repr for super::VtableObjectData<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"VtableObject(object_ty={})\",\n-                self.object_ty.repr())\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n     }\n }\n \n-impl<'tcx> Repr for super::SelectionError<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            super::Unimplemented =>\n-                format!(\"Unimplemented\"),\n-\n-            super::OutputTypeParameterMismatch(ref a, ref b, ref c) =>\n-                format!(\"OutputTypeParameterMismatch({},{},{})\",\n-                        a.repr(),\n-                        b.repr(),\n-                        c.repr()),\n-\n-            super::TraitNotObjectSafe(ref tr) =>\n-                format!(\"TraitNotObjectSafe({})\",\n-                        tr.repr())\n-        }\n+impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n+               self.trait_def_id,\n+               self.nested)\n     }\n }\n \n-impl<'tcx> Repr for super::FulfillmentError<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"FulfillmentError({},{})\",\n-                self.obligation.repr(),\n-                self.code.repr())\n+impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(object_ty={:?})\", self.object_ty)\n     }\n }\n \n-impl<'tcx> Repr for super::FulfillmentErrorCode<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            super::CodeSelectionError(ref o) => o.repr(),\n-            super::CodeProjectionError(ref o) => o.repr(),\n-            super::CodeAmbiguity => format!(\"Ambiguity\")\n-        }\n+impl<'tcx> fmt::Debug for super::FulfillmentError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"FulfillmentError({:?},{:?})\",\n+               self.obligation,\n+               self.code)\n     }\n }\n \n@@ -610,14 +564,8 @@ impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for super::MismatchedProjectionTypes<'tcx> {\n-    fn repr(&self) -> String {\n-        self.err.repr()\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes(..)\")\n+        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n     }\n }"}, {"sha": "1274b3498fd3377bfaed838888dfea96e80e871e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 248, "deletions": 258, "changes": 506, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -12,7 +12,6 @@\n \n pub use self::terr_vstore_kind::*;\n pub use self::type_err::*;\n-pub use self::BuiltinBound::*;\n pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n@@ -35,6 +34,11 @@ pub use self::IntVarValue::*;\n pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n \n+pub use self::BuiltinBound::Send as BoundSend;\n+pub use self::BuiltinBound::Sized as BoundSized;\n+pub use self::BuiltinBound::Copy as BoundCopy;\n+pub use self::BuiltinBound::Sync as BoundSync;\n+\n use ast_map::{self, LinkedPath};\n use back::svh::Svh;\n use session::Session;\n@@ -78,7 +82,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n-use collections::enum_set::{EnumSet, CLike};\n+use collections::enum_set::{self, EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n@@ -130,7 +134,7 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub enum ImplOrTraitItem<'tcx> {\n     ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n@@ -293,15 +297,15 @@ pub struct ItemVariances {\n     pub regions: VecPerParamSpace<Variance>,\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n     Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n     AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n@@ -370,7 +374,7 @@ pub enum AutoAdjustment<'tcx> {\n ///     unsize: Some(Box<[i32]>),\n /// }\n /// ```\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct AutoDerefRef<'tcx> {\n     /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n@@ -400,7 +404,7 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -418,7 +422,7 @@ pub enum MethodOrigin<'tcx> {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed. Note that it\n@@ -439,7 +443,7 @@ pub struct MethodParam<'tcx> {\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n     pub trait_ref: TraitRef<'tcx>,\n@@ -803,7 +807,7 @@ impl<'tcx> ctxt<'tcx> {\n         self.free_region_maps.borrow()[&id].clone()\n     }\n \n-    pub fn lift<T: Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n }\n@@ -825,7 +829,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n         let mut result = Vec::with_capacity(self.len());\n@@ -1115,7 +1119,6 @@ impl<'tcx> ctxt<'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n pub struct TyS<'tcx> {\n     pub sty: TypeVariants<'tcx>,\n     pub flags: Cell<TypeFlags>,\n@@ -1238,7 +1241,7 @@ pub struct BareFnTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n@@ -1309,7 +1312,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: u32,\n@@ -1363,7 +1366,7 @@ pub struct DebruijnIndex {\n }\n \n /// Representation of regions:\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1411,7 +1414,7 @@ pub struct EarlyBoundRegion {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n@@ -1476,7 +1479,7 @@ pub enum UpvarCapture {\n     ByRef(UpvarBorrow),\n }\n \n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct UpvarBorrow {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -1516,7 +1519,7 @@ impl Region {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -1525,7 +1528,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, Debug)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -1636,7 +1639,7 @@ pub enum TypeVariants<'tcx> {\n     TyError,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds<'tcx>,\n@@ -1707,7 +1710,7 @@ impl<'tcx> TraitTy<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -1842,7 +1845,7 @@ pub enum type_err<'tcx> {\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n /// as well as the existential type parameter in an object type.\n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[derive(PartialEq, Eq, Hash, Clone)]\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n@@ -1855,41 +1858,57 @@ pub struct ParamBounds<'tcx> {\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[derive(PartialEq, Eq, Hash, Clone)]\n pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n     pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n-pub type BuiltinBounds = EnumSet<BuiltinBound>;\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n-#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n-           Debug, Copy)]\n-#[repr(usize)]\n-pub enum BuiltinBound {\n-    BoundSend,\n-    BoundSized,\n-    BoundCopy,\n-    BoundSync,\n+impl BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n+        BuiltinBounds(EnumSet::new())\n+    }\n+\n+    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n+        self.into_iter()\n+    }\n }\n \n-pub fn empty_builtin_bounds() -> BuiltinBounds {\n-    EnumSet::new()\n+impl ops::Deref for BuiltinBounds {\n+    type Target = EnumSet<BuiltinBound>;\n+    fn deref(&self) -> &Self::Target { &self.0 }\n }\n \n-pub fn all_builtin_bounds() -> BuiltinBounds {\n-    let mut set = EnumSet::new();\n-    set.insert(BoundSend);\n-    set.insert(BoundSized);\n-    set.insert(BoundSync);\n-    set\n+impl ops::DerefMut for BuiltinBounds {\n+    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n+}\n+\n+impl<'a> IntoIterator for &'a BuiltinBounds {\n+    type Item = BuiltinBound;\n+    type IntoIter = enum_set::Iter<BuiltinBound>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        (**self).into_iter()\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n+           Debug, Copy)]\n+#[repr(usize)]\n+pub enum BuiltinBound {\n+    Send,\n+    Sized,\n+    Copy,\n+    Sync,\n }\n \n /// An existential bound that does not implement any traits.\n pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx> {\n     ty::ExistentialBounds { region_bound: r,\n-                            builtin_bounds: empty_builtin_bounds(),\n+                            builtin_bounds: BuiltinBounds::empty(),\n                             projection_bounds: Vec::new() }\n }\n \n@@ -1968,7 +1987,7 @@ impl cmp::PartialEq for InferRegion {\n }\n \n impl fmt::Debug for TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}t\", self.index)\n     }\n }\n@@ -2024,7 +2043,7 @@ impl fmt::Debug for IntVarValue {\n /// from `T:'a` annotations appearing in the type definition.  If\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub enum ObjectLifetimeDefault {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n@@ -2034,7 +2053,7 @@ pub enum ObjectLifetimeDefault {\n     Specific(Region),\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -2097,7 +2116,7 @@ impl<'tcx> Generics<'tcx> {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n@@ -2127,7 +2146,7 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -2258,7 +2277,7 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -2306,7 +2325,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::R\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -2495,7 +2514,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n@@ -3679,7 +3698,7 @@ impl<'tcx> ItemSubsts<'tcx> {\n impl<'tcx> ParamBounds<'tcx> {\n     pub fn empty() -> ParamBounds<'tcx> {\n         ParamBounds {\n-            builtin_bounds: empty_builtin_bounds(),\n+            builtin_bounds: BuiltinBounds::empty(),\n             trait_bounds: Vec::new(),\n             region_bounds: Vec::new(),\n             projection_bounds: Vec::new(),\n@@ -5316,138 +5335,132 @@ pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n     }\n }\n \n-impl<'tcx> Repr for ty::type_err<'tcx> {\n-    fn repr(&self) -> String {\n-        tls::with(|tcx| ty::type_err_to_str(tcx, self))\n-    }\n-}\n-\n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n-pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n-    match *err {\n-        terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n-        terr_mismatch => \"types differ\".to_string(),\n-        terr_unsafety_mismatch(values) => {\n-            format!(\"expected {} fn, found {} fn\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_abi_mismatch(values) => {\n-            format!(\"expected {} fn, found {} fn\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_mutability => \"values differ in mutability\".to_string(),\n-        terr_box_mutability => {\n-            \"boxed values differ in mutability\".to_string()\n-        }\n-        terr_vec_mutability => \"vectors differ in mutability\".to_string(),\n-        terr_ptr_mutability => \"pointers differ in mutability\".to_string(),\n-        terr_ref_mutability => \"references differ in mutability\".to_string(),\n-        terr_ty_param_size(values) => {\n-            format!(\"expected a type with {} type params, \\\n-                     found one with {} type params\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_fixed_array_size(values) => {\n-            format!(\"expected an array with a fixed size of {} elements, \\\n-                     found one with {} elements\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_tuple_size(values) => {\n-            format!(\"expected a tuple with {} elements, \\\n-                     found one with {} elements\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_arg_count => {\n-            \"incorrect number of function parameters\".to_string()\n-        }\n-        terr_regions_does_not_outlive(..) => {\n-            \"lifetime mismatch\".to_string()\n-        }\n-        terr_regions_not_same(..) => {\n-            \"lifetimes are not the same\".to_string()\n-        }\n-        terr_regions_no_overlap(..) => {\n-            \"lifetimes do not intersect\".to_string()\n-        }\n-        terr_regions_insufficiently_polymorphic(br, _) => {\n-            format!(\"expected bound lifetime parameter {}, \\\n-                     found concrete lifetime\",\n-                    br.user_string())\n-        }\n-        terr_regions_overly_polymorphic(br, _) => {\n-            format!(\"expected concrete lifetime, \\\n-                     found bound lifetime parameter {}\",\n-                    br.user_string())\n-        }\n-        terr_sorts(values) => {\n-            // A naive approach to making sure that we're not reporting silly errors such as:\n-            // (expected closure, found closure).\n-            let expected_str = ty_sort_string(cx, values.expected);\n-            let found_str = ty_sort_string(cx, values.found);\n-            if expected_str == found_str {\n-                format!(\"expected {}, found a different {}\", expected_str, found_str)\n-            } else {\n-                format!(\"expected {}, found {}\", expected_str, found_str)\n+impl<'tcx> fmt::Display for type_err<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            terr_cyclic_ty => write!(f, \"cyclic type of infinite size\"),\n+            terr_mismatch => write!(f, \"types differ\"),\n+            terr_unsafety_mismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n             }\n-        }\n-        terr_traits(values) => {\n-            format!(\"expected trait `{}`, found trait `{}`\",\n-                    item_path_str(cx, values.expected),\n-                    item_path_str(cx, values.found))\n-        }\n-        terr_builtin_bounds(values) => {\n-            if values.expected.is_empty() {\n-                format!(\"expected no bounds, found `{}`\",\n-                        values.found.user_string())\n-            } else if values.found.is_empty() {\n-                format!(\"expected bounds `{}`, found no bounds\",\n-                        values.expected.user_string())\n-            } else {\n-                format!(\"expected bounds `{}`, found bounds `{}`\",\n-                        values.expected.user_string(),\n-                        values.found.user_string())\n+            terr_abi_mismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_mutability => write!(f, \"values differ in mutability\"),\n+            terr_box_mutability => {\n+                write!(f, \"boxed values differ in mutability\")\n+            }\n+            terr_vec_mutability => write!(f, \"vectors differ in mutability\"),\n+            terr_ptr_mutability => write!(f, \"pointers differ in mutability\"),\n+            terr_ref_mutability => write!(f, \"references differ in mutability\"),\n+            terr_ty_param_size(values) => {\n+                write!(f, \"expected a type with {} type params, \\\n+                           found one with {} type params\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_fixed_array_size(values) => {\n+                write!(f, \"expected an array with a fixed size of {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_tuple_size(values) => {\n+                write!(f, \"expected a tuple with {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_arg_count => {\n+                write!(f, \"incorrect number of function parameters\")\n+            }\n+            terr_regions_does_not_outlive(..) => {\n+                write!(f, \"lifetime mismatch\")\n+            }\n+            terr_regions_not_same(..) => {\n+                write!(f, \"lifetimes are not the same\")\n+            }\n+            terr_regions_no_overlap(..) => {\n+                write!(f, \"lifetimes do not intersect\")\n+            }\n+            terr_regions_insufficiently_polymorphic(br, _) => {\n+                write!(f, \"expected bound lifetime parameter {}, \\\n+                           found concrete lifetime\", br)\n+            }\n+            terr_regions_overly_polymorphic(br, _) => {\n+                write!(f, \"expected concrete lifetime, \\\n+                           found bound lifetime parameter {}\", br)\n+            }\n+            terr_sorts(values) => tls::with(|tcx| {\n+                // A naive approach to making sure that we're not reporting silly errors such as:\n+                // (expected closure, found closure).\n+                let expected_str = ty_sort_string(tcx, values.expected);\n+                let found_str = ty_sort_string(tcx, values.found);\n+                if expected_str == found_str {\n+                    write!(f, \"expected {}, found a different {}\", expected_str, found_str)\n+                } else {\n+                    write!(f, \"expected {}, found {}\", expected_str, found_str)\n+                }\n+            }),\n+            terr_traits(values) => tls::with(|tcx| {\n+                write!(f, \"expected trait `{}`, found trait `{}`\",\n+                       item_path_str(tcx, values.expected),\n+                       item_path_str(tcx, values.found))\n+            }),\n+            terr_builtin_bounds(values) => {\n+                if values.expected.is_empty() {\n+                    write!(f, \"expected no bounds, found `{}`\",\n+                           values.found)\n+                } else if values.found.is_empty() {\n+                    write!(f, \"expected bounds `{}`, found no bounds\",\n+                           values.expected)\n+                } else {\n+                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n+                           values.expected,\n+                           values.found)\n+                }\n+            }\n+            terr_integer_as_char => {\n+                write!(f, \"expected an integral type, found `char`\")\n+            }\n+            terr_int_mismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_float_mismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_variadic_mismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"variadic\" } else { \"non-variadic\" },\n+                       if values.found { \"variadic\" } else { \"non-variadic\" })\n+            }\n+            terr_convergence_mismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"converging\" } else { \"diverging\" },\n+                       if values.found { \"converging\" } else { \"diverging\" })\n+            }\n+            terr_projection_name_mismatched(ref values) => {\n+                write!(f, \"expected {}, found {}\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            terr_projection_bounds_length(ref values) => {\n+                write!(f, \"expected {} associated type bindings, found {}\",\n+                       values.expected,\n+                       values.found)\n             }\n-        }\n-        terr_integer_as_char => {\n-            \"expected an integral type, found `char`\".to_string()\n-        }\n-        terr_int_mismatch(ref values) => {\n-            format!(\"expected `{:?}`, found `{:?}`\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_float_mismatch(ref values) => {\n-            format!(\"expected `{:?}`, found `{:?}`\",\n-                    values.expected,\n-                    values.found)\n-        }\n-        terr_variadic_mismatch(ref values) => {\n-            format!(\"expected {} fn, found {} function\",\n-                    if values.expected { \"variadic\" } else { \"non-variadic\" },\n-                    if values.found { \"variadic\" } else { \"non-variadic\" })\n-        }\n-        terr_convergence_mismatch(ref values) => {\n-            format!(\"expected {} fn, found {} function\",\n-                    if values.expected { \"converging\" } else { \"diverging\" },\n-                    if values.found { \"converging\" } else { \"diverging\" })\n-        }\n-        terr_projection_name_mismatched(ref values) => {\n-            format!(\"expected {}, found {}\",\n-                    token::get_name(values.expected),\n-                    token::get_name(values.found))\n-        }\n-        terr_projection_bounds_length(ref values) => {\n-            format!(\"expected {} associated type bindings, found {}\",\n-                    values.expected,\n-                    values.found)\n         }\n     }\n }\n@@ -6914,14 +6927,14 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n     }\n }\n \n-impl Variance {\n-    pub fn to_string(self) -> &'static str {\n-        match self {\n+impl fmt::Debug for Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n             Covariant => \"+\",\n             Contravariant => \"-\",\n             Invariant => \"o\",\n             Bivariant => \"*\",\n-        }\n+        })\n     }\n }\n \n@@ -7265,7 +7278,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n     all_outlive_scope: region::DestructionScopeData,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     ty_fold::replace_late_bound_regions(\n         tcx, value,\n@@ -7276,7 +7289,7 @@ pub fn count_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> usize\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     let (_, skol_map) = ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n     skol_map.len()\n@@ -7286,7 +7299,7 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> bool\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     count_late_bound_regions(tcx, value) > 0\n }\n@@ -7297,7 +7310,7 @@ pub fn flatten_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     bound2_value: &Binder<Binder<T>>)\n     -> Binder<T>\n-    where T: TypeFoldable<'tcx> + Repr\n+    where T: TypeFoldable<'tcx>\n {\n     let bound0_value = bound2_value.skip_binder().skip_binder();\n     let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n@@ -7319,7 +7332,7 @@ pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> Option<T>\n-    where T : TypeFoldable<'tcx> + Repr + Clone\n+    where T : TypeFoldable<'tcx>\n {\n     if binds_late_bound_regions(tcx, value) {\n         None\n@@ -7334,7 +7347,7 @@ pub fn erase_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n }\n@@ -7351,7 +7364,7 @@ pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n     -> Binder<T>\n-    where T : TypeFoldable<'tcx> + Repr,\n+    where T : TypeFoldable<'tcx>,\n {\n     let mut counter = 0;\n     ty::Binder(ty_fold::replace_late_bound_regions(tcx, sig, |_| {\n@@ -7371,58 +7384,45 @@ impl DebruijnIndex {\n     }\n }\n \n-impl<'tcx> Repr for AutoAdjustment<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for AutoAdjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             AdjustReifyFnPointer => {\n-                format!(\"AdjustReifyFnPointer\")\n+                write!(f, \"AdjustReifyFnPointer\")\n             }\n             AdjustUnsafeFnPointer => {\n-                format!(\"AdjustUnsafeFnPointer\")\n+                write!(f, \"AdjustUnsafeFnPointer\")\n             }\n             AdjustDerefRef(ref data) => {\n-                data.repr()\n+                write!(f, \"{:?}\", data)\n             }\n         }\n     }\n }\n \n-impl<'tcx> Repr for AutoDerefRef<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"AutoDerefRef({}, unsize={}, {})\",\n-                self.autoderefs, self.unsize.repr(), self.autoref.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for AutoRef<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            AutoPtr(a, b) => {\n-                format!(\"AutoPtr({},{:?})\", a.repr(), b)\n-            }\n-            AutoUnsafe(ref a) => {\n-                format!(\"AutoUnsafe({:?})\", a)\n-            }\n-        }\n+impl<'tcx> fmt::Debug for AutoDerefRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n+               self.autoderefs, self.unsize, self.autoref)\n     }\n }\n \n-impl<'tcx> Repr for TraitTy<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TraitTy({},{})\",\n-                self.principal.repr(),\n-                self.bounds.repr())\n+impl<'tcx> fmt::Debug for TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitTy({:?},{:?})\",\n+               self.principal,\n+               self.bounds)\n     }\n }\n \n-impl<'tcx> Repr for ty::Predicate<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Predicate::Trait(ref a) => a.repr(),\n-            Predicate::Equate(ref pair) => pair.repr(),\n-            Predicate::RegionOutlives(ref pair) => pair.repr(),\n-            Predicate::TypeOutlives(ref pair) => pair.repr(),\n-            Predicate::Projection(ref pair) => pair.repr(),\n+            Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n+            Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n         }\n     }\n }\n@@ -7628,14 +7628,6 @@ impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for ty::ProjectionPredicate<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ProjectionPredicate({}, {})\",\n-                self.projection_ty.repr(),\n-                self.ty.repr())\n-    }\n-}\n-\n pub trait HasProjectionTypes {\n     fn has_projection_types(&self) -> bool;\n }\n@@ -7870,48 +7862,46 @@ impl ReferencesError for Region\n     }\n }\n \n-impl<'tcx> Repr for ClosureTy<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ClosureTy({},{},{})\",\n-                self.unsafety,\n-                self.sig.repr(),\n-                self.abi)\n+impl<'tcx> fmt::Debug for ClosureTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureTy({},{:?},{})\",\n+               self.unsafety,\n+               self.sig,\n+               self.abi)\n     }\n }\n \n-impl<'tcx> Repr for ClosureUpvar<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ClosureUpvar({},{})\",\n-                self.def.repr(),\n-                self.ty.repr())\n+impl<'tcx> fmt::Debug for ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr for field<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"field({},{})\",\n-                self.name.repr(),\n-                self.mt.repr())\n+impl<'tcx> fmt::Debug for field<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"field({},{})\", self.name, self.mt)\n     }\n }\n \n-impl<'a, 'tcx> Repr for ParameterEnvironment<'a, 'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ParameterEnvironment(\\\n-            free_substs={}, \\\n-            implicit_region_bound={}, \\\n-            caller_bounds={})\",\n-            self.free_substs.repr(),\n-            self.implicit_region_bound.repr(),\n-            self.caller_bounds.repr())\n+impl<'a, 'tcx> fmt::Debug for ParameterEnvironment<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ParameterEnvironment(\\\n+            free_substs={:?}, \\\n+            implicit_region_bound={:?}, \\\n+            caller_bounds={:?})\",\n+            self.free_substs,\n+            self.implicit_region_bound,\n+            self.caller_bounds)\n     }\n }\n \n-impl<'tcx> Repr for ObjectLifetimeDefault {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for ObjectLifetimeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ObjectLifetimeDefault::Ambiguous => format!(\"Ambiguous\"),\n-            ObjectLifetimeDefault::Specific(ref r) => r.repr(),\n+            ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n+            ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n         }\n     }\n }"}, {"sha": "adc282bc2fdd548bc70e6dc7c0d2f35edfef2fed", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -38,6 +38,8 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use middle::traits;\n+\n+use std::fmt;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n@@ -50,7 +52,7 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx>: Repr + Clone {\n+pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -74,7 +76,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     fn exit_region_binder(&mut self) { }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr + Clone\n+        where T : TypeFoldable<'tcx>\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         super_fold_binder(self, t)\n@@ -197,7 +199,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>+Repr+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n@@ -885,7 +887,7 @@ pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                                             mut f: F)\n                                             -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n     where F : FnMut(ty::BoundRegion) -> ty::Region,\n-          T : TypeFoldable<'tcx> + Repr,\n+          T : TypeFoldable<'tcx>,\n {\n     debug!(\"replace_late_bound_regions({})\", value.repr());\n     let mut replacer = RegionReplacer::new(tcx, &mut f);\n@@ -994,8 +996,8 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr>(tcx: &ty::ctxt<'tcx>,\n-                                                            amount: u32, value: &T) -> T {\n+pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n+                                                 amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(), amount);\n "}, {"sha": "5d524c51b5eb3470fd96ef7347876e78d38077c1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 476, "deletions": 982, "changes": 1458, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -9,15 +9,12 @@\n // except according to those terms.\n \n \n-use middle::def;\n-use middle::region;\n-use middle::subst::{VecPerParamSpace,Subst};\n-use middle::subst;\n+use middle::subst::{self, Subst};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, Ty, ParamTy};\n+use middle::ty::{mt, Ty};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n@@ -26,16 +23,10 @@ use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable};\n \n-use std::collections::HashMap;\n-use std::collections::hash_state::HashState;\n-use std::hash::Hash;\n-use std::rc::Rc;\n+use std::fmt;\n use syntax::abi;\n-use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::ptr::P;\n use syntax::{ast, ast_util};\n-use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n@@ -47,61 +38,124 @@ pub trait UserString {\n     fn user_string(&self) -> String;\n }\n \n+impl<T: fmt::Debug> Repr for T {\n+    fn repr(&self) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl<T: fmt::Display> UserString for T {\n+    fn user_string(&self) -> String {\n+        format!(\"{}\", *self)\n+    }\n+}\n+\n pub fn verbose() -> bool {\n     ty::tls::with(|tcx| tcx.sess.verbose())\n }\n \n-fn parameterized<GG>(substs: &subst::Substs,\n+fn fn_sig(f: &mut fmt::Formatter,\n+          inputs: &[Ty],\n+          variadic: bool,\n+          output: ty::FnOutput)\n+          -> fmt::Result {\n+    try!(write!(f, \"(\"));\n+    let mut inputs = inputs.iter();\n+    if let Some(&ty) = inputs.next() {\n+        try!(write!(f, \"{}\", ty));\n+        for &ty in inputs {\n+            try!(write!(f, \", {}\", ty));\n+        }\n+        if variadic {\n+            try!(write!(f, \", ...\"));\n+        }\n+    }\n+    try!(write!(f, \")\"));\n+\n+    match output {\n+        ty::FnConverging(ty) => {\n+            if !ty::type_is_nil(ty) {\n+                try!(write!(f, \" -> {}\", ty));\n+            }\n+            Ok(())\n+        }\n+        ty::FnDiverging => {\n+            write!(f, \" -> !\")\n+        }\n+    }\n+}\n+\n+fn parameterized<GG>(f: &mut fmt::Formatter,\n+                     substs: &subst::Substs,\n                      did: ast::DefId,\n                      projections: &[ty::ProjectionPredicate],\n                      get_generics: GG)\n-                     -> String\n+                     -> fmt::Result\n     where GG: for<'tcx> FnOnce(&ty::ctxt<'tcx>) -> ty::Generics<'tcx>\n {\n-    let base = ty::tls::with(|tcx| ty::item_path_str(tcx, did));\n-    if verbose() {\n-        let mut strings = vec![];\n+    let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n+        try!(write!(f, \"{}\", ty::item_path_str(tcx, did)));\n+        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n+    }));\n+\n+    let mut empty = true;\n+    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n+        if empty {\n+            empty = false;\n+            write!(f, \"{}\", start)\n+        } else {\n+            write!(f, \"{}\", cont)\n+        }\n+    };\n+\n+    if verbose {\n         match substs.regions {\n             subst::ErasedRegions => {\n-                strings.push(format!(\"..\"));\n+                try!(start_or_continue(f, \"<\", \", \"));\n+                try!(write!(f, \"..\"));\n             }\n             subst::NonerasedRegions(ref regions) => {\n                 for region in regions {\n-                    strings.push(region.repr());\n+                    try!(start_or_continue(f, \"<\", \", \"));\n+                    try!(write!(f, \"{:?}\", region));\n                 }\n             }\n         }\n-        for ty in &substs.types {\n-            strings.push(ty.repr());\n+        for &ty in &substs.types {\n+            try!(start_or_continue(f, \"<\", \", \"));\n+            try!(write!(f, \"{}\", ty));\n         }\n         for projection in projections {\n-            strings.push(format!(\"{}={}\",\n-                                 projection.projection_ty.item_name.user_string(),\n-                                 projection.ty.user_string()));\n+            try!(start_or_continue(f, \"<\", \", \"));\n+            try!(write!(f, \"{}={}\",\n+                        projection.projection_ty.item_name,\n+                        projection.ty));\n         }\n-        return if strings.is_empty() {\n-            format!(\"{}\", base)\n-        } else {\n-            format!(\"{}<{}>\", base, strings.connect(\",\"))\n-        };\n+        return start_or_continue(f, \"\", \">\");\n     }\n \n-    let mut strs = Vec::new();\n+    if fn_trait_kind.is_some() && projections.len() == 1 {\n+        let projection_ty = projections[0].ty;\n+        if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n+            return fn_sig(f, args, false, ty::FnConverging(projection_ty));\n+        }\n+    }\n \n     match substs.regions {\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n+                try!(start_or_continue(f, \"<\", \", \"));\n                 let s = r.user_string();\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n                     // because the user omitted it in the first place,\n                     // or because it refers to some block in the code,\n                     // etc. I'm not sure how best to serialize this.\n-                    strs.push(format!(\"'_\"));\n+                    try!(write!(f, \"'_\"));\n                 } else {\n-                    strs.push(s)\n+                    try!(write!(f, \"{}\", s));\n                 }\n             }\n         }\n@@ -112,14 +166,13 @@ fn parameterized<GG>(substs: &subst::Substs,\n     // ICEs trying to fetch the generics early in the pipeline. This\n     // is kind of a hacky workaround in that -Z verbose is required to\n     // avoid those ICEs.\n-    ty::tls::with(|tcx| {\n+    let tps = substs.types.get_slice(subst::TypeSpace);\n+    let num_defaults = ty::tls::with(|tcx| {\n         let generics = get_generics(tcx);\n \n         let has_self = substs.self_ty().is_some();\n-        let tps = substs.types.get_slice(subst::TypeSpace);\n         let ty_params = generics.types.get_slice(subst::TypeSpace);\n-        let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-        let num_defaults = if has_defaults {\n+        if ty_params.last().map_or(false, |def| def.default.is_some()) {\n             let substs = tcx.lift(&substs);\n             ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n                 match def.default {\n@@ -142,49 +195,29 @@ fn parameterized<GG>(substs: &subst::Substs,\n             }).count()\n         } else {\n             0\n-        };\n-\n-        for t in &tps[..tps.len() - num_defaults] {\n-            strs.push(t.user_string())\n         }\n     });\n \n-    for projection in projections {\n-        strs.push(format!(\"{}={}\",\n-                          projection.projection_ty.item_name.user_string(),\n-                          projection.ty.user_string()));\n+    for &ty in &tps[..tps.len() - num_defaults] {\n+        try!(start_or_continue(f, \"<\", \", \"));\n+        try!(write!(f, \"{}\", ty));\n     }\n \n-    let fn_trait_kind = ty::tls::with(|tcx| tcx.lang_items.fn_trait_kind(did));\n-    if fn_trait_kind.is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        let tail =\n-            if ty::type_is_nil(projection_ty) {\n-                format!(\"\")\n-            } else {\n-                format!(\" -> {}\", projection_ty.user_string())\n-            };\n-        format!(\"{}({}){}\",\n-                base,\n-                if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n-                } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n-                } else {\n-                    &strs[0][..]\n-                },\n-                tail)\n-    } else if !strs.is_empty() {\n-        format!(\"{}<{}>\", base, strs.connect(\", \"))\n-    } else {\n-        format!(\"{}\", base)\n+    for projection in projections {\n+        try!(start_or_continue(f, \"<\", \", \"));\n+        try!(write!(f, \"{}={}\",\n+                    projection.projection_ty.item_name,\n+                    projection.ty));\n     }\n+\n+    start_or_continue(f, \"\", \">\")\n }\n \n-fn in_binder<'tcx, T, U>(tcx: &ty::ctxt<'tcx>,\n+fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n+                         tcx: &ty::ctxt<'tcx>,\n                          original: &ty::Binder<T>,\n-                         lifted: Option<ty::Binder<U>>) -> String\n-    where T: UserString, U: UserString + TypeFoldable<'tcx>\n+                         lifted: Option<ty::Binder<U>>) -> fmt::Result\n+    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n {\n     // Replace any anonymous late-bound regions with named\n     // variants, using gensym'd identifiers, so that we can\n@@ -194,110 +227,38 @@ fn in_binder<'tcx, T, U>(tcx: &ty::ctxt<'tcx>,\n     let value = if let Some(v) = lifted {\n         v\n     } else {\n-        return original.0.user_string();\n+        return write!(f, \"{}\", original.0);\n+    };\n+\n+    let mut empty = true;\n+    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n+        if empty {\n+            empty = false;\n+            write!(f, \"{}\", start)\n+        } else {\n+            write!(f, \"{}\", cont)\n+        }\n     };\n-    let mut names = Vec::new();\n-    let value_str = ty_fold::replace_late_bound_regions(tcx, &value, |br| {\n+\n+    let new_value = ty_fold::replace_late_bound_regions(tcx, &value, |br| {\n+        let _ = start_or_continue(f, \"for<\", \", \");\n         ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n             ty::BrNamed(_, name) => {\n-                names.push(token::get_name(name).to_string());\n+                let _ = write!(f, \"{}\", name);\n                 br\n             }\n             ty::BrAnon(_) |\n             ty::BrFresh(_) |\n             ty::BrEnv => {\n-                let name = token::gensym(\"'r\");\n-                names.push(token::get_name(name).to_string());\n+                let name = token::intern(\"'r\");\n+                let _ = write!(f, \"{}\", name);\n                 ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n             }\n         })\n-    }).0.user_string();\n-\n-    if names.is_empty() {\n-        value_str\n-    } else {\n-        format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n-    }\n-}\n-\n-impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self) -> String {\n-        match self {\n-            &None => \"None\".to_string(),\n-            &Some(ref t) => t.repr(),\n-        }\n-    }\n-}\n+    }).0;\n \n-impl<T:Repr> Repr for P<T> {\n-    fn repr(&self) -> String {\n-        (**self).repr()\n-    }\n-}\n-\n-impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self) -> String {\n-        match self {\n-            &Ok(ref t) => t.repr(),\n-            &Err(ref u) => format!(\"Err({})\", u.repr())\n-        }\n-    }\n-}\n-\n-impl Repr for () {\n-    fn repr(&self) -> String {\n-        \"()\".to_string()\n-    }\n-}\n-\n-impl<'a, T: ?Sized +Repr> Repr for &'a T {\n-    fn repr(&self) -> String {\n-        (**self).repr()\n-    }\n-}\n-\n-impl<T:Repr> Repr for Rc<T> {\n-    fn repr(&self) -> String {\n-        (&**self).repr()\n-    }\n-}\n-\n-impl<T:Repr> Repr for Box<T> {\n-    fn repr(&self) -> String {\n-        (&**self).repr()\n-    }\n-}\n-\n-impl<T:Repr> Repr for [T] {\n-    fn repr(&self) -> String {\n-        format!(\"[{}]\", self.iter().map(|t| t.repr()).collect::<Vec<_>>().connect(\", \"))\n-    }\n-}\n-\n-impl<T:Repr> Repr for OwnedSlice<T> {\n-    fn repr(&self) -> String {\n-        self[..].repr()\n-    }\n-}\n-\n-// This is necessary to handle types like Option<Vec<T>>, for which\n-// autoderef cannot convert the &[T] handler\n-impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self) -> String {\n-        self[..].repr()\n-    }\n-}\n-\n-impl<'a, T: ?Sized +UserString> UserString for &'a T {\n-    fn user_string(&self) -> String {\n-        (**self).user_string()\n-    }\n-}\n-\n-impl Repr for def::Def {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n+    try!(start_or_continue(f, \"\", \"> \"));\n+    write!(f, \"{}\", new_value)\n }\n \n /// This curious type is here to help pretty-print trait objects. In\n@@ -311,274 +272,194 @@ impl Repr for def::Def {\n /// Right now there is only one trait in an object that can have\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n-type TraitAndProjections<'tcx> =\n-    (ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n+#[derive(Clone, Debug)]\n+struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n-impl<'tcx> UserString for TraitAndProjections<'tcx> {\n-    fn user_string(&self) -> String {\n-        let &(ref trait_ref, ref projection_bounds) = self;\n-        parameterized(trait_ref.substs,\n+impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n+    fn fold_with<F:ty_fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n+                                              -> TraitAndProjections<'tcx> {\n+        TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n+        parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n-                      &projection_bounds[..],\n+                      projection_bounds,\n                       |tcx| ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n     }\n }\n \n-impl<'tcx> UserString for ty::TraitTy<'tcx> {\n-    fn user_string(&self) -> String {\n-        let &ty::TraitTy { ref principal, ref bounds } = self;\n-\n-        let mut components = vec![];\n-\n-        let tap: ty::Binder<TraitAndProjections<'tcx>> =\n-            ty::Binder((principal.0.clone(),\n-                        bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n+impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let bounds = &self.bounds;\n \n         // Generate the main trait ref, including associated types.\n-        components.push(tap.user_string());\n+        try!(ty::tls::with(|tcx| {\n+            let principal = tcx.lift(&self.principal.0)\n+                               .expect(\"could not lift TraitRef for printing\");\n+            let projections = tcx.lift(&bounds.projection_bounds[..])\n+                                 .expect(\"could not lift projections for printing\");\n+            let projections = projections.map_in_place(|p| p.0);\n+\n+            let tap = ty::Binder(TraitAndProjections(principal, projections));\n+            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n+        }));\n \n         // Builtin bounds.\n         for bound in &bounds.builtin_bounds {\n-            components.push(bound.user_string());\n+            try!(write!(f, \" + {:?}\", bound));\n         }\n \n         // Region, if not obviously implied by builtin bounds.\n         if bounds.region_bound != ty::ReStatic {\n             // Region bound is implied by builtin bounds:\n-            components.push(bounds.region_bound.user_string());\n+            let bound = bounds.region_bound.user_string();\n+            if !bound.is_empty() {\n+                try!(write!(f, \" + {}\", bound));\n+            }\n         }\n \n-        components.retain(|s| !s.is_empty());\n-\n-        components.connect(\" + \")\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr for ty::TypeParameterDef<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TypeParameterDef({:?}, {:?}/{})\",\n-                self.def_id,\n-                self.space,\n-                self.index)\n+impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeParameterDef({:?}, {:?}/{})\",\n+               self.def_id, self.space, self.index)\n     }\n }\n \n-impl Repr for ty::RegionParameterDef {\n-    fn repr(&self) -> String {\n-        format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n-                token::get_name(self.name),\n-                self.def_id.repr(),\n-                self.bounds.repr())\n+impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", *self)\n     }\n }\n \n-impl<'tcx> Repr for ty::TyS<'tcx> {\n-    fn repr(&self) -> String {\n-        self.user_string()\n+impl<'tcx> fmt::Display for ty::mt<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}{}\",\n+               if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr for ty::mt<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"{}{}\",\n-            if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n-            self.ty.user_string())\n+impl<'tcx> fmt::Debug for subst::Substs<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Substs[types={:?}, regions={:?}]\",\n+               self.types, self.regions)\n     }\n }\n \n-impl<'tcx> Repr for subst::Substs<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Substs[types={}, regions={}]\",\n-                       self.types.repr(),\n-                       self.regions.repr())\n+impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ItemSubsts({:?})\", self.substs)\n     }\n }\n \n-impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n-    fn repr(&self) -> String {\n-        format!(\"[{};{};{}]\",\n-                self.get_slice(subst::TypeSpace).repr(),\n-                self.get_slice(subst::SelfSpace).repr(),\n-                self.get_slice(subst::FnSpace).repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::ItemSubsts<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ItemSubsts({})\", self.substs.repr())\n-    }\n-}\n-\n-impl Repr for subst::RegionSubsts {\n-    fn repr(&self) -> String {\n+impl fmt::Debug for subst::RegionSubsts {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            subst::ErasedRegions => \"erased\".to_string(),\n-            subst::NonerasedRegions(ref regions) => regions.repr()\n+            subst::ErasedRegions => write!(f, \"erased\"),\n+            subst::NonerasedRegions(ref regions) => write!(f, \"{:?}\", regions)\n         }\n     }\n }\n \n-impl Repr for ty::BuiltinBounds {\n-    fn repr(&self) -> String {\n-        let mut res = Vec::new();\n-        for b in self {\n-            res.push(match b {\n-                ty::BoundSend => \"Send\".to_string(),\n-                ty::BoundSized => \"Sized\".to_string(),\n-                ty::BoundCopy => \"Copy\".to_string(),\n-                ty::BoundSync => \"Sync\".to_string(),\n-            });\n-        }\n-        res.connect(\"+\")\n-    }\n-}\n \n-impl<'tcx> Repr for ty::ParamBounds<'tcx> {\n-    fn repr(&self) -> String {\n-        let mut res = Vec::new();\n-        res.push(self.builtin_bounds.repr());\n-        for t in &self.trait_bounds {\n-            res.push(t.repr());\n+impl<'tcx> fmt::Debug for ty::ParamBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.builtin_bounds));\n+        let mut bounds = self.trait_bounds.iter();\n+        if self.builtin_bounds.is_empty() {\n+            if let Some(bound) = bounds.next() {\n+                try!(write!(f, \"{:?}\", bound));\n+            }\n+        }\n+        for bound in bounds {\n+            try!(write!(f, \" + {:?}\", bound));\n         }\n-        res.connect(\"+\")\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr for ty::TraitRef<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        let result = self.user_string();\n         match self.substs.self_ty() {\n-            None => result,\n-            Some(sty) => format!(\"<{} as {}>\", sty.repr(), result)\n+            None => write!(f, \"{}\", *self),\n+            Some(self_ty) => write!(f, \"<{:?} as {}>\", self_ty, *self)\n         }\n     }\n }\n \n-impl<'tcx> Repr for ty::TraitDef<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TraitDef(generics={}, trait_ref={})\",\n-                self.generics.repr(),\n-                self.trait_ref.repr())\n-    }\n-}\n-\n-impl Repr for ast::Expr {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::Path {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl UserString for ast::Path {\n-    fn user_string(&self) -> String {\n-        format!(\"{}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::Ty {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::Lifetime {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::Stmt {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::Pat {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ty::BoundRegion {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n-            ty::BrNamed(id, name) => {\n-                format!(\"BrNamed({}, {})\", id.repr(), token::get_name(name))\n-            }\n-            ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n-            ty::BrEnv => \"BrEnv\".to_string()\n-        }\n+impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitDef(generics={:?}, trait_ref={:?})\",\n+               self.generics, self.trait_ref)\n     }\n }\n \n-impl UserString for ty::BoundRegion {\n-    fn user_string(&self) -> String {\n+impl fmt::Display for ty::BoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n-            return self.repr();\n+            return write!(f, \"{:?}\", *self);\n         }\n \n         match *self {\n-            BrNamed(_, name) => token::get_name(name).to_string(),\n-            BrAnon(_) | BrFresh(_) | BrEnv => String::new()\n+            BrNamed(_, name) => write!(f, \"{}\", name),\n+            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n         }\n     }\n }\n \n-impl Repr for ty::Region {\n-    fn repr(&self) -> String {\n+impl fmt::Debug for ty::Region {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n-                        data.param_id,\n-                        data.space,\n-                        data.index,\n-                        token::get_name(data.name))\n+                write!(f, \"ReEarlyBound({}, {:?}, {}, {})\",\n+                       data.param_id,\n+                       data.space,\n+                       data.index,\n+                       data.name)\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n-                format!(\"ReLateBound({:?}, {})\",\n-                        binder_id,\n-                        bound_region.repr())\n+                write!(f, \"ReLateBound({:?}, {:?})\",\n+                       binder_id,\n+                       bound_region)\n             }\n \n-            ty::ReFree(ref fr) => fr.repr(),\n+            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n             ty::ReScope(id) => {\n-                format!(\"ReScope({:?})\", id)\n+                write!(f, \"ReScope({:?})\", id)\n             }\n \n-            ty::ReStatic => {\n-                \"ReStatic\".to_string()\n-            }\n+            ty::ReStatic => write!(f, \"ReStatic\"),\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"{:?}\", vid)\n+                write!(f, \"{:?}\", vid)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n-                format!(\"re_skolemized({}, {})\", id, bound_region.repr())\n+                write!(f, \"ReSkolemized({}, {:?})\", id, bound_region)\n             }\n \n-            ty::ReEmpty => {\n-                \"ReEmpty\".to_string()\n-            }\n+            ty::ReEmpty => write!(f, \"ReEmpty\")\n         }\n     }\n }\n \n-impl UserString for ty::Region {\n-    fn user_string(&self) -> String {\n+impl fmt::Display for ty::Region {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n-            return self.repr();\n+            return write!(f, \"{:?}\", *self);\n         }\n \n         // These printouts are concise.  They do not contain all the information\n@@ -587,815 +468,428 @@ impl UserString for ty::Region {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                token::get_name(data.name).to_string()\n+                write!(f, \"{}\", data.name)\n             }\n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::ReInfer(ReSkolemized(_, br)) => {\n-                br.user_string()\n+                write!(f, \"{}\", br)\n             }\n             ty::ReScope(_) |\n-            ty::ReInfer(ReVar(_)) => String::new(),\n-            ty::ReStatic => \"'static\".to_owned(),\n-            ty::ReEmpty => \"'<empty>\".to_owned(),\n-        }\n-    }\n-}\n-\n-impl Repr for ty::FreeRegion {\n-    fn repr(&self) -> String {\n-        format!(\"ReFree({}, {})\",\n-                self.scope.repr(),\n-                self.bound_region.repr())\n-    }\n-}\n-\n-impl Repr for region::CodeExtent {\n-    fn repr(&self) -> String {\n-        match *self {\n-            region::CodeExtent::ParameterScope { fn_id, body_id } =>\n-                format!(\"ParameterScope({}, {})\", fn_id, body_id),\n-            region::CodeExtent::Misc(node_id) =>\n-                format!(\"Misc({})\", node_id),\n-            region::CodeExtent::DestructionScope(node_id) =>\n-                format!(\"DestructionScope({})\", node_id),\n-            region::CodeExtent::Remainder(rem) =>\n-                format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n-        }\n-    }\n-}\n-\n-impl Repr for region::DestructionScopeData {\n-    fn repr(&self) -> String {\n-        match *self {\n-            region::DestructionScopeData{ node_id } =>\n-                format!(\"DestructionScopeData {{ node_id: {} }}\", node_id),\n+            ty::ReInfer(ReVar(_)) => Ok(()),\n+            ty::ReStatic => write!(f, \"'static\"),\n+            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n     }\n }\n \n-impl Repr for ast::DefId {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::TypeScheme<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TypeScheme {{generics: {}, ty: {}}}\",\n-                self.generics.repr(),\n-                self.ty.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::Generics<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Generics(types: {}, regions: {})\",\n-                self.types.repr(),\n-                self.regions.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::GenericPredicates<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"GenericPredicates(predicates: {})\",\n-                self.predicates.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::InstantiatedPredicates<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"InstantiatedPredicates({})\",\n-                self.predicates.repr())\n-    }\n-}\n-\n-impl Repr for ty::ItemVariances {\n-    fn repr(&self) -> String {\n-        format!(\"ItemVariances(types={}, \\\n-                regions={})\",\n-                self.types.repr(),\n-                self.regions.repr())\n-    }\n-}\n-\n-impl Repr for ty::Variance {\n-    fn repr(&self) -> String {\n-        // The first `.to_string()` returns a &'static str (it is not an implementation\n-        // of the ToString trait). Because of that, we need to call `.to_string()` again\n-        // if we want to have a `String`.\n-        let result: &'static str = (*self).to_string();\n-        result.to_string()\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::ImplOrTraitItem<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"ImplOrTraitItem({})\",\n-                match *self {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(),\n-                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(),\n-                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(),\n-                })\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::AssociatedConst<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n-                self.name.repr(),\n-                self.ty.repr(),\n-                self.vis.repr(),\n-                self.def_id.repr())\n+impl fmt::Debug for ty::FreeRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ReFree({:?}, {:?})\",\n+               self.scope, self.bound_region)\n     }\n }\n \n-impl<'tcx> Repr for ty::AssociatedType<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n-                self.name.repr(),\n-                self.vis.repr(),\n-                self.def_id.repr())\n+impl fmt::Debug for ty::ItemVariances {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n+               self.types, self.regions)\n     }\n }\n \n-impl<'tcx> Repr for ty::Method<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n-                 explicit_self: {}, vis: {}, def_id: {})\",\n-                self.name.repr(),\n-                self.generics.repr(),\n-                self.predicates.repr(),\n-                self.fty.repr(),\n-                self.explicit_self.repr(),\n-                self.vis.repr(),\n-                self.def_id.repr())\n+impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"GenericPredicates({:?})\", self.predicates)\n     }\n }\n \n-impl Repr for ast::Name {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n+impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"InstantiatedPredicates({:?})\",\n+               self.predicates)\n     }\n }\n \n-impl UserString for ast::Name {\n-    fn user_string(&self) -> String {\n-        format!(\"{}\", *self)\n+impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"ImplOrTraitItem(\"));\n+        try!(match *self {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n+            ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n+            ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n+        });\n+        write!(f, \")\")\n     }\n }\n \n-impl Repr for ast::ExplicitSelf_ {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n+impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"fn\"));\n+        fn_sig(f, &self.inputs, self.variadic, self.output)\n     }\n }\n \n-impl Repr for ast::Visibility {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::BareFnTy<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"BareFnTy {{unsafety: {}, abi: {}, sig: {}}}\",\n-                self.unsafety,\n-                self.abi.to_string(),\n-                self.sig.repr())\n-    }\n-}\n-\n-\n-impl<'tcx> Repr for ty::FnSig<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"fn{} -> {}\", self.inputs.repr(), self.output.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::FnOutput<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for ty::MethodOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::FnConverging(ty) =>\n-                format!(\"FnConverging({0})\", ty.repr()),\n-            ty::FnDiverging =>\n-                \"FnDiverging\".to_string()\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::MethodCallee<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n-                self.origin.repr(),\n-                self.ty.repr(),\n-                self.substs.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::MethodOrigin<'tcx> {\n-    fn repr(&self) -> String {\n-        match self {\n-            &ty::MethodStatic(def_id) => {\n-                format!(\"MethodStatic({})\", def_id.repr())\n-            }\n-            &ty::MethodStaticClosure(def_id) => {\n-                format!(\"MethodStaticClosure({})\", def_id.repr())\n+            ty::MethodStatic(def_id) => {\n+                write!(f, \"MethodStatic({:?})\", def_id)\n             }\n-            &ty::MethodTypeParam(ref p) => {\n-                p.repr()\n-            }\n-            &ty::MethodTraitObject(ref p) => {\n-                p.repr()\n+            ty::MethodStaticClosure(def_id) => {\n+                write!(f, \"MethodStaticClosure({:?})\", def_id)\n             }\n+            ty::MethodTypeParam(ref p) => write!(f, \"{:?}\", p),\n+            ty::MethodTraitObject(ref p) => write!(f, \"{:?}\", p)\n         }\n     }\n }\n \n-impl<'tcx> Repr for ty::MethodParam<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"MethodParam({},{})\",\n-                self.trait_ref.repr(),\n-                self.method_num)\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::MethodObject<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"MethodObject({},{},{})\",\n-                self.trait_ref.repr(),\n-                self.method_num,\n-                self.vtable_index)\n-    }\n-}\n-\n-impl Repr for ty::BuiltinBound {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl UserString for ty::BuiltinBound {\n-    fn user_string(&self) -> String {\n-        match *self {\n-            ty::BoundSend => \"Send\".to_string(),\n-            ty::BoundSized => \"Sized\".to_string(),\n-            ty::BoundCopy => \"Copy\".to_string(),\n-            ty::BoundSync => \"Sync\".to_string(),\n-        }\n+impl<'tcx> fmt::Debug for ty::MethodParam<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MethodParam({:?},{})\",\n+               self.trait_ref,\n+               self.method_num)\n     }\n }\n \n-impl Repr for Span {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n+impl<'tcx> fmt::Debug for ty::MethodObject<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MethodObject({:?},{},{})\",\n+               self.trait_ref,\n+               self.method_num,\n+               self.vtable_index)\n     }\n }\n \n-impl<A:UserString> UserString for Rc<A> {\n-    fn user_string(&self) -> String {\n-        let this: &A = &**self;\n-        this.user_string()\n-    }\n-}\n-\n-impl<'tcx> UserString for ty::ParamBounds<'tcx> {\n-    fn user_string(&self) -> String {\n-        let mut result = Vec::new();\n-        let s = self.builtin_bounds.user_string();\n-        if !s.is_empty() {\n-            result.push(s);\n+impl<'tcx> fmt::Display for ty::ParamBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{}\", self.builtin_bounds));\n+        let mut bounds = self.trait_bounds.iter();\n+        if self.builtin_bounds.is_empty() {\n+            if let Some(bound) = bounds.next() {\n+                try!(write!(f, \"{}\", bound));\n+            }\n         }\n-        for n in &self.trait_bounds {\n-            result.push(n.user_string());\n+        for bound in bounds {\n+            try!(write!(f, \" + {}\", bound));\n         }\n-        result.connect(\" + \")\n+        Ok(())\n     }\n }\n \n-impl<'tcx> Repr for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self) -> String {\n-        let mut res = Vec::new();\n+impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut empty = true;\n+        let mut maybe_continue = |f: &mut fmt::Formatter| {\n+            if empty {\n+                empty = false;\n+                Ok(())\n+            } else {\n+                write!(f, \" + \")\n+            }\n+        };\n \n         let region_str = self.region_bound.repr();\n         if !region_str.is_empty() {\n-            res.push(region_str);\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{}\", region_str));\n         }\n \n         for bound in &self.builtin_bounds {\n-            res.push(bound.repr());\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{:?}\", bound));\n         }\n \n         for projection_bound in &self.projection_bounds {\n-            res.push(projection_bound.repr());\n+            try!(maybe_continue(f));\n+            try!(write!(f, \"{:?}\", projection_bound));\n         }\n \n-        res.connect(\"+\")\n+        Ok(())\n     }\n }\n \n-impl UserString for ty::BuiltinBounds {\n-    fn user_string(&self) -> String {\n-        self.iter()\n-            .map(|bb| bb.user_string())\n-            .collect::<Vec<String>>()\n-            .connect(\"+\")\n-            .to_string()\n+impl fmt::Display for ty::BuiltinBounds {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut bounds = self.iter();\n+        if let Some(bound) = bounds.next() {\n+            try!(write!(f, \"{:?}\", bound));\n+            for bound in bounds {\n+                try!(write!(f, \" + {:?}\", bound));\n+            }\n+        }\n+        Ok(())\n     }\n }\n \n // The generic impl doesn't work yet because projections are not\n // normalized under HRTB.\n-/*impl<T> UserString for ty::Binder<T>\n-    where T: UserString + for<'a> ty::Lift<'a>,\n-          for<'a> <T as ty::Lift<'a>>::Lifted: UserString + TypeFoldable<'a>\n+/*impl<T> fmt::Display for ty::Binder<T>\n+    where T: fmt::Display + for<'a> ty::Lift<'a>,\n+          for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }*/\n \n-impl<'tcx> UserString for ty::Binder<ty::TraitRef<'tcx>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> UserString for ty::Binder<ty::TraitPredicate<'tcx>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString for ty::Binder<ty::EquatePredicate<'tcx>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString for ty::Binder<TraitAndProjections<'tcx>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl UserString for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n-    fn user_string(&self) -> String {\n-        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString for ty::TraitRef<'tcx> {\n-    fn user_string(&self) -> String {\n-        parameterized(self.substs, self.def_id, &[],\n+impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        parameterized(f, self.substs, self.def_id, &[],\n                       |tcx| ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n     }\n }\n \n-impl<'tcx> UserString for ty::TyS<'tcx> {\n-    fn user_string(&self) -> String {\n-        fn bare_fn_to_string(opt_def_id: Option<ast::DefId>,\n-                             unsafety: ast::Unsafety,\n-                             abi: abi::Abi,\n-                             ident: Option<ast::Ident>,\n-                             sig: &ty::PolyFnSig)\n-                             -> String {\n-            let mut s = String::new();\n-\n-            match unsafety {\n-                ast::Unsafety::Normal => {}\n-                ast::Unsafety::Unsafe => {\n-                    s.push_str(&unsafety.to_string());\n-                    s.push(' ');\n-                }\n-            };\n-\n-            if abi != abi::Rust {\n-                s.push_str(&format!(\"extern {} \", abi.to_string()));\n-            };\n-\n-            s.push_str(\"fn\");\n-\n-            match ident {\n-                Some(i) => {\n-                    s.push(' ');\n-                    s.push_str(&token::get_ident(i));\n-                }\n-                _ => { }\n-            }\n-\n-            push_sig_to_string(&mut s, '(', ')', sig);\n-\n-            match opt_def_id {\n-                Some(def_id) => {\n-                    s.push_str(\" {\");\n-                    let path_str = ty::tls::with(|tcx| ty::item_path_str(tcx, def_id));\n-                    s.push_str(&path_str[..]);\n-                    s.push_str(\"}\");\n-                }\n-                None => { }\n-            }\n-\n-            s\n-        }\n-\n-        fn push_sig_to_string(s: &mut String,\n-                              bra: char,\n-                              ket: char,\n-                              sig: &ty::PolyFnSig) {\n-            s.push(bra);\n-            let strs = sig.0.inputs\n-                .iter()\n-                .map(|a| a.user_string())\n-                .collect::<Vec<_>>();\n-            s.push_str(&strs.connect(\", \"));\n-            if sig.0.variadic {\n-                s.push_str(\", ...\");\n-            }\n-            s.push(ket);\n-\n-            match sig.0.output {\n-                ty::FnConverging(t) => {\n-                    if !ty::type_is_nil(t) {\n-                        s.push_str(\" -> \");\n-                        s.push_str(&t.user_string());\n-                    }\n-                }\n-                ty::FnDiverging => {\n-                    s.push_str(\" -> !\");\n-                }\n-            }\n-        }\n-\n-        // pretty print the structural type representation:\n-        match self.sty {\n-            TyBool => \"bool\".to_string(),\n-            TyChar => \"char\".to_string(),\n-            TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n-            TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n-            TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n-            TyBox(typ) => format!(\"Box<{}>\",  typ.user_string()),\n+impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TyBool => write!(f, \"bool\"),\n+            TyChar => write!(f, \"char\"),\n+            TyInt(t) => write!(f, \"{}\", ast_util::int_ty_to_string(t, None)),\n+            TyUint(t) => write!(f, \"{}\", ast_util::uint_ty_to_string(t, None)),\n+            TyFloat(t) => write!(f, \"{}\", ast_util::float_ty_to_string(t)),\n+            TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n             TyRawPtr(ref tm) => {\n-                format!(\"*{} {}\", match tm.mutbl {\n+                write!(f, \"*{} {}\", match tm.mutbl {\n                     ast::MutMutable => \"mut\",\n                     ast::MutImmutable => \"const\",\n-                },  tm.ty.user_string())\n+                },  tm.ty)\n             }\n             TyRef(r, ref tm) => {\n-                let mut buf = \"&\".to_owned();\n-                buf.push_str(&r.user_string());\n-                if buf.len() > 1 {\n-                    buf.push_str(\" \");\n+                try!(write!(f, \"&\"));\n+                let s = r.user_string();\n+                try!(write!(f, \"{}\", s));\n+                if !s.is_empty() {\n+                    try!(write!(f, \" \"));\n                 }\n-                buf.push_str(&tm.repr());\n-                buf\n-            }\n-            TyTuple(ref elems) => {\n-                let strs = elems\n-                    .iter()\n-                    .map(|elem| elem.user_string())\n-                    .collect::<Vec<_>>();\n-                match &strs[..] {\n-                    [ref string] => format!(\"({},)\", string),\n-                    strs => format!(\"({})\", strs.connect(\", \"))\n+                write!(f, \"{}\", tm)\n+            }\n+            TyTuple(ref tys) => {\n+                try!(write!(f, \"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    try!(write!(f, \"{},\", ty));\n+                    if let Some(&ty) = tys.next() {\n+                        try!(write!(f, \" {}\", ty));\n+                        for &ty in tys {\n+                            try!(write!(f, \", {}\", ty));\n+                        }\n+                    }\n                 }\n+                write!(f, \")\")\n             }\n-            TyBareFn(opt_def_id, ref f) => {\n-                bare_fn_to_string(opt_def_id, f.unsafety, f.abi, None, &f.sig)\n+            TyBareFn(opt_def_id, ref bare_fn) => {\n+                if bare_fn.unsafety == ast::Unsafety::Unsafe {\n+                    try!(write!(f, \"unsafe \"));\n+                }\n+\n+                if bare_fn.abi != abi::Rust {\n+                    try!(write!(f, \"extern {} \", bare_fn.abi));\n+                }\n+\n+                try!(write!(f, \"{}\", bare_fn.sig.0));\n+\n+                if let Some(def_id) = opt_def_id {\n+                    try!(write!(f, \" {{{}}}\", ty::tls::with(|tcx| {\n+                        ty::item_path_str(tcx, def_id)\n+                    })));\n+                }\n+                Ok(())\n             }\n-            TyInfer(infer_ty) => infer_ty.repr(),\n-            TyError => \"[type error]\".to_string(),\n-            TyParam(ref param_ty) => param_ty.user_string(),\n+            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+            TyError => write!(f, \"[type error]\"),\n+            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n             TyEnum(did, substs) | TyStruct(did, substs) => {\n-                parameterized(substs, did, &[],\n+                parameterized(f, substs, did, &[],\n                               |tcx| ty::lookup_item_type(tcx, did).generics)\n             }\n-            TyTrait(ref data) => {\n-                data.user_string()\n-            }\n-            ty::TyProjection(ref data) => {\n-                format!(\"<{} as {}>::{}\",\n-                        data.trait_ref.self_ty().user_string(),\n-                        data.trait_ref.user_string(),\n-                        data.item_name.user_string())\n-            }\n-            TyStr => \"str\".to_string(),\n+            TyTrait(ref data) => write!(f, \"{}\", data),\n+            ty::TyProjection(ref data) => write!(f, \"{}\", data),\n+            TyStr => write!(f, \"str\"),\n             TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n+                try!(write!(f, \"[closure\"));\n                 let closure_tys = tcx.closure_tys.borrow();\n-                closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n+                try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n                     tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n                 }).map(|sig| {\n-                    let mut s = String::new();\n-                    s.push_str(\"[closure\");\n-                    push_sig_to_string(&mut s, '(', ')', &sig);\n-                    if verbose() {\n-                        s.push_str(&format!(\" id={:?}]\", did));\n-                    } else {\n-                        s.push(']');\n-                    }\n-                    s\n+                    fn_sig(f, &sig.0.inputs, false, sig.0.output)\n                 }).unwrap_or_else(|| {\n-                    let id_str = if verbose() {\n-                        format!(\" id={:?}\", did)\n-                    } else {\n-                        \"\".to_owned()\n-                    };\n-\n                     if did.krate == ast::LOCAL_CRATE {\n-                        let span = ty::tls::with(|tcx| tcx.map.span(did.node));\n-                        format!(\"[closure {}{}]\", span.repr(), id_str)\n-                    } else {\n-                        format!(\"[closure{}]\", id_str)\n+                        try!(write!(f, \" {:?}\", tcx.map.span(did.node)));\n                     }\n-                })\n+                    Ok(())\n+                }));\n+                if verbose() {\n+                    try!(write!(f, \" id={:?}\", did));\n+                }\n+                write!(f, \"]\")\n             }),\n-            TyArray(t, sz) => {\n-                format!(\"[{}; {}]\",  t.user_string(), sz)\n-            }\n-            TySlice(t) => {\n-                format!(\"[{}]\",  t.user_string())\n-            }\n-        }\n-    }\n-}\n-\n-impl UserString for ast::Ident {\n-    fn user_string(&self) -> String {\n-        format!(\"{}\", *self)\n-    }\n-}\n-\n-impl Repr for abi::Abi {\n-    fn repr(&self) -> String {\n-        self.to_string()\n-    }\n-}\n-\n-impl UserString for abi::Abi {\n-    fn user_string(&self) -> String {\n-        self.to_string()\n-    }\n-}\n-\n-impl Repr for ty::UpvarId {\n-    fn repr(&self) -> String {\n-        format!(\"UpvarId({};`{}`;{})\",\n-                self.var_id,\n-                ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n-                self.closure_expr_id)\n-    }\n-}\n-\n-impl Repr for ast::Mutability {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ty::BorrowKind {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ty::UpvarBorrow {\n-    fn repr(&self) -> String {\n-        format!(\"UpvarBorrow({}, {})\",\n-                self.kind.repr(),\n-                self.region.repr())\n-    }\n-}\n-\n-impl Repr for ty::UpvarCapture {\n-    fn repr(&self) -> String {\n-        match *self {\n-            ty::UpvarCapture::ByValue => format!(\"ByValue\"),\n-            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr()),\n+            TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),\n+            TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n }\n \n-impl Repr for ty::IntVid {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl Repr for ty::FloatVid {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl Repr for ty::RegionVid {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", self)\n+impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.sty)\n     }\n }\n \n-impl Repr for ty::TyVid {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", self)\n+impl fmt::Debug for ty::UpvarId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"UpvarId({};`{}`;{})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n+               self.closure_expr_id)\n     }\n }\n \n-impl Repr for ty::IntVarValue {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n+impl fmt::Debug for ty::UpvarBorrow {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n     }\n }\n \n-impl Repr for ty::InferTy {\n-    fn repr(&self) -> String {\n+impl fmt::Display for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let print_var_ids = verbose();\n         match *self {\n-            ty::TyVar(ref vid) if print_var_ids => vid.repr(),\n-            ty::IntVar(ref vid) if print_var_ids => vid.repr(),\n-            ty::FloatVar(ref vid) if print_var_ids => vid.repr(),\n-            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n+            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n+            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => write!(f, \"_\"),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n         }\n     }\n }\n \n-impl Repr for ast::IntTy {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::UintTy {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ast::FloatTy {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}\n-\n-impl Repr for ty::ExplicitSelfCategory {\n-    fn repr(&self) -> String {\n-        match *self {\n+impl fmt::Display for ty::ExplicitSelfCategory {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n             ty::StaticExplicitSelfCategory => \"static\",\n             ty::ByValueExplicitSelfCategory => \"self\",\n             ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n                 \"&mut self\"\n             }\n             ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n             ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n-        }.to_owned()\n-    }\n-}\n-\n-impl UserString for ParamTy {\n-    fn user_string(&self) -> String {\n-        format!(\"{}\", token::get_name(self.name))\n-    }\n-}\n-\n-impl Repr for ParamTy {\n-    fn repr(&self) -> String {\n-        let ident = self.user_string();\n-        format!(\"{}/{:?}.{}\", ident, self.space, self.idx)\n-    }\n-}\n-\n-impl<A:Repr, B:Repr> Repr for (A,B) {\n-    fn repr(&self) -> String {\n-        let &(ref a, ref b) = self;\n-        format!(\"({},{})\", a.repr(), b.repr())\n-    }\n-}\n-\n-impl<T:Repr> Repr for ty::Binder<T> {\n-    fn repr(&self) -> String {\n-        format!(\"Binder({})\", self.0.repr())\n+        })\n     }\n }\n \n-impl<S, K, V> Repr for HashMap<K, V, S>\n-    where K: Hash + Eq + Repr,\n-          V: Repr,\n-          S: HashState,\n-{\n-    fn repr(&self) -> String {\n-        format!(\"HashMap({})\",\n-                self.iter()\n-                    .map(|(k,v)| format!(\"{} => {}\", k.repr(), v.repr()))\n-                    .collect::<Vec<String>>()\n-                    .connect(\", \"))\n+impl fmt::Display for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.name)\n     }\n }\n \n-impl<'tcx, T, U> Repr for ty::OutlivesPredicate<T,U>\n-    where T : Repr + TypeFoldable<'tcx>,\n-          U : Repr + TypeFoldable<'tcx>,\n-{\n-    fn repr(&self) -> String {\n-        format!(\"OutlivesPredicate({}, {})\",\n-                self.0.repr(),\n-                self.1.repr())\n+impl fmt::Debug for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}/{:?}.{}\", self, self.space, self.idx)\n     }\n }\n \n-impl<'tcx, T, U> UserString for ty::OutlivesPredicate<T,U>\n-    where T : UserString + TypeFoldable<'tcx>,\n-          U : UserString + TypeFoldable<'tcx>,\n+impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n+    where T: fmt::Display, U: fmt::Display\n {\n-    fn user_string(&self) -> String {\n-        format!(\"{} : {}\",\n-                self.0.user_string(),\n-                self.1.user_string())\n-    }\n-}\n-\n-impl<'tcx> Repr for ty::EquatePredicate<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"EquatePredicate({}, {})\",\n-                self.0.repr(),\n-                self.1.repr())\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} : {}\", self.0, self.1)\n     }\n }\n \n-impl<'tcx> UserString for ty::EquatePredicate<'tcx> {\n-    fn user_string(&self) -> String {\n-        format!(\"{} == {}\",\n-                self.0.user_string(),\n-                self.1.user_string())\n+impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} == {}\", self.0, self.1)\n     }\n }\n \n-impl<'tcx> Repr for ty::TraitPredicate<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"TraitPredicate({})\",\n-                self.trait_ref.repr())\n+impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitPredicate({:?})\",\n+               self.trait_ref)\n     }\n }\n \n-impl<'tcx> UserString for ty::TraitPredicate<'tcx> {\n-    fn user_string(&self) -> String {\n-        format!(\"{} : {}\",\n-                self.trait_ref.self_ty().user_string(),\n-                self.trait_ref.user_string())\n+impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} : {}\",\n+               self.trait_ref.self_ty(),\n+               self.trait_ref)\n     }\n }\n \n-impl<'tcx> UserString for ty::ProjectionPredicate<'tcx> {\n-    fn user_string(&self) -> String {\n-        format!(\"{} == {}\",\n-                self.projection_ty.user_string(),\n-                self.ty.user_string())\n+impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n+               self.projection_ty,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> Repr for ty::ProjectionTy<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"{}::{}\",\n-                self.trait_ref.repr(),\n-                self.item_name.repr())\n+impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} == {}\",\n+               self.projection_ty,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> UserString for ty::ProjectionTy<'tcx> {\n-    fn user_string(&self) -> String {\n-        format!(\"<{} as {}>::{}\",\n-                self.trait_ref.self_ty().user_string(),\n-                self.trait_ref.user_string(),\n-                self.item_name.user_string())\n+impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}::{}\",\n+               self.trait_ref,\n+               self.item_name)\n     }\n }\n \n-impl<'tcx> UserString for ty::Predicate<'tcx> {\n-    fn user_string(&self) -> String {\n+impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref data) => data.user_string(),\n-            ty::Predicate::Equate(ref predicate) => predicate.user_string(),\n-            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(),\n-            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(),\n-            ty::Predicate::Projection(ref predicate) => predicate.user_string(),\n+            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n+            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n         }\n     }\n }\n-\n-impl Repr for ast::Unsafety {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-}"}, {"sha": "63d9383d69d553a49dab7b0f050249313914017c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -34,9 +34,10 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n use rustc::util::ppaux::{Repr, UserString};\n+\n+use std::fmt;\n use std::mem;\n use std::rc::Rc;\n-use std::string::String;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -329,7 +330,7 @@ impl<'tcx> Loan<'tcx> {\n     }\n }\n \n-#[derive(Eq, Hash, Debug)]\n+#[derive(Eq, Hash)]\n pub struct LoanPath<'tcx> {\n     kind: LoanPathKind<'tcx>,\n     ty: ty::Ty<'tcx>,\n@@ -369,7 +370,7 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n // information that is not relevant to loan-path analysis. (In\n // particular, the distinction between how precisely a array-element\n // is tracked is irrelevant here.)\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(mc::FieldName),\n     InteriorElement(mc::ElementKind),\n@@ -1148,39 +1149,38 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl<'tcx> Repr for InteriorKind {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for InteriorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(mc::NamedField(fld)) =>\n-                format!(\"{}\", token::get_name(fld)),\n-            InteriorField(mc::PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(..) => \"[]\".to_string(),\n+            InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n+            InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }\n }\n \n-impl<'tcx> Repr for Loan<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\",\n-                 self.index,\n-                 self.loan_path.repr(),\n-                 self.kind,\n-                 self.gen_scope,\n-                 self.kill_scope,\n-                 self.restricted_paths.repr())\n+impl<'tcx> fmt::Debug for Loan<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n+               self.index,\n+               self.loan_path,\n+               self.kind,\n+               self.gen_scope,\n+               self.kill_scope,\n+               self.restricted_paths)\n     }\n }\n \n-impl<'tcx> Repr for LoanPath<'tcx> {\n-    fn repr(&self) -> String {\n+impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", ty::tls::with(|tcx| tcx.map.node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| tcx.map.node_to_string(var_id));\n-                format!(\"$({} captured by id={})\", s, closure_expr_id)\n+                write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n@@ -1189,30 +1189,30 @@ impl<'tcx> Repr for LoanPath<'tcx> {\n                 } else {\n                     variant_def_id.repr()\n                 };\n-                format!(\"({}{}{})\", lp.repr(), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.repr())\n+                write!(f, \"{:?}.*\", lp)\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.repr(), interior.repr())\n+                write!(f, \"{:?}.{:?}\", lp, interior)\n             }\n         }\n     }\n }\n \n-impl<'tcx> UserString for LoanPath<'tcx> {\n-    fn user_string(&self) -> String {\n+impl<'tcx> fmt::Display for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", ty::tls::with(|tcx| tcx.map.node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.map.node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| tcx.map.node_to_user_string(var_id));\n-                format!(\"$({} captured by closure)\", s)\n+                write!(f, \"$({} captured by closure)\", s)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n@@ -1221,15 +1221,15 @@ impl<'tcx> UserString for LoanPath<'tcx> {\n                 } else {\n                     variant_def_id.repr()\n                 };\n-                format!(\"({}{}{})\", lp.user_string(), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.user_string())\n+                write!(f, \"{}.*\", lp)\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.user_string(), interior.repr())\n+                write!(f, \"{}.{:?}\", lp, interior)\n             }\n         }\n     }"}, {"sha": "658d5166ef5fc04485a56b501e76b8f6216b314d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -227,8 +227,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n-            Err(ref e) => panic!(\"Encountered error: {}\",\n-                                ty::type_err_to_str(self.infcx.tcx, e))\n+            Err(ref e) => panic!(\"Encountered error: {}\", e)\n         }\n     }\n \n@@ -376,8 +375,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n         match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n-                                ty::type_err_to_str(self.infcx.tcx, e))\n+            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e)\n         }\n     }\n \n@@ -390,7 +388,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 panic!(\"unexpected error computing sub({},{}): {}\",\n                        t1.repr(),\n                        t2.repr(),\n-                       ty::type_err_to_str(self.infcx.tcx, e));\n+                       e);\n             }\n         }\n     }\n@@ -415,8 +413,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n-                panic!(\"unexpected error in LUB: {}\",\n-                      ty::type_err_to_str(self.infcx.tcx, e))\n+                panic!(\"unexpected error in LUB: {}\", e)\n             }\n         }\n     }"}, {"sha": "7f68e654c2c5370653cae99135ab8db82cd31fb0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -221,6 +221,7 @@ use util::ppaux::{self, Repr};\n \n use std;\n use std::cmp::Ordering;\n+use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, NodeId};\n@@ -371,13 +372,13 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n }\n \n-impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n-    fn repr(&self) -> String {\n+impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if ppaux::verbose() {\n             // for many programs, this just take too long to serialize\n-            self.pats.repr()\n+            write!(f, \"{:?}\", self.pats)\n         } else {\n-            format!(\"{} pats\", self.pats.len())\n+            write!(f, \"{} pats\", self.pats.len())\n         }\n     }\n }"}, {"sha": "22582787c7c0b1f7818d531ab8c48368070b07a1", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -64,7 +64,7 @@ pub use trans::context::CrateContext;\n /// subtyping, but they are anonymized and normalized as well). This\n /// is a stronger, caching version of `ty_fold::erase_regions`.\n pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     let value1 = value.fold_with(&mut RegionEraser(cx));\n     debug!(\"erase_regions({}) = {}\",\n@@ -88,7 +88,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n         }\n \n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-            where T : TypeFoldable<'tcx> + Repr\n+            where T : TypeFoldable<'tcx>\n         {\n             let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n             ty_fold::super_fold_binder(self, &u)\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -624,7 +624,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -1135,7 +1135,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                                 result: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n@@ -1159,7 +1159,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + Repr\n+    where T : TypeFoldable<'tcx>\n {\n     debug!(\"drain_fulfillment_cx(result={})\",\n            result.repr());"}, {"sha": "e0ac4391d67d1ea1a17d9c1c55ec39b49986f098", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -205,19 +205,6 @@ impl<'tcx> DropGlueKind<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for DropGlueKind<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            DropGlueKind::Ty(ty) => {\n-                format!(\"DropGlueKind::Ty({})\", ty.repr())\n-            }\n-            DropGlueKind::TyContents(ty) => {\n-                format!(\"DropGlueKind::TyContents({})\", ty.repr())\n-            }\n-        }\n-    }\n-}\n-\n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n     debug!(\"make drop glue for {}\", g.repr());"}, {"sha": "4a81610dd852f9e006ac13fbf0f675fea19b9fff", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -303,7 +303,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n@@ -314,7 +314,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     debug!(\"normalize_associated_type(t={})\", value.repr());\n "}, {"sha": "dee8eefd9da5fa2dd26b106cb1a931519af3c0dc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -2106,7 +2106,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                             ast_bounds: &'a [ast::TyParamBound])\n                             -> PartitionedBounds<'a>\n {\n-    let mut builtin_bounds = ty::empty_builtin_bounds();\n+    let mut builtin_bounds = ty::BuiltinBounds::empty();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     for ast_bound in ast_bounds {"}, {"sha": "ec5752fb50fffb9597f9254e5550511a229d82c0", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -24,7 +24,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes\n {\n     debug!(\"normalize_associated_types_in(value={})\", value.repr());\n     let mut selcx = SelectionContext::new(infcx, typer);"}, {"sha": "da1c44604f9fcb9b1206c003933a2f4741fd01c6", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -328,6 +328,7 @@ fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n }\n \n+#[derive(Debug)]\n struct CallResolution<'tcx> {\n     call_expr: &'tcx ast::Expr,\n     callee_expr: &'tcx ast::Expr,\n@@ -337,19 +338,6 @@ struct CallResolution<'tcx> {\n     closure_def_id: ast::DefId,\n }\n \n-impl<'tcx> Repr for CallResolution<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n-                autoderefs={}, fn_sig={}, closure_def_id={})\",\n-                self.call_expr.repr(),\n-                self.callee_expr.repr(),\n-                self.adjusted_ty.repr(),\n-                self.autoderefs,\n-                self.fn_sig.repr(),\n-                self.closure_def_id.repr())\n-    }\n-}\n-\n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {}\","}, {"sha": "3c38f471c85352cb47d54df7c124a48bb3044ea1", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -341,7 +341,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_err!(tcx.sess, impl_m_span, E0053,\n                       \"method `{}` has an incompatible type for trait: {}\",\n                       token::get_name(trait_m.name),\n-                      ty::type_err_to_str(tcx, &terr));\n+                      terr);\n             return;\n         }\n     }\n@@ -487,7 +487,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       \"implemented const `{}` has an incompatible type for \\\n                       trait: {}\",\n                       token::get_name(trait_c.name),\n-                      ty::type_err_to_str(tcx, &terr));\n+                      terr);\n             return;\n         }\n     }"}, {"sha": "2b5fb524b524f3b94f99ba9f4c04e67f4b107ecf", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -657,7 +657,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0"}, {"sha": "d71b91762e920d2bcb707a4c9677a9931dfd46df", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -46,18 +46,21 @@ struct ProbeContext<'a, 'tcx:'a> {\n     static_candidates: Vec<CandidateSource>,\n }\n \n+#[derive(Debug)]\n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n     autoderefs: usize,\n     unsize: bool\n }\n \n+#[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n     item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n }\n \n+#[derive(Debug)]\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n@@ -70,6 +73,7 @@ enum CandidateKind<'tcx> {\n     ProjectionCandidate(ast::DefId, ItemIndex),\n }\n \n+#[derive(Debug)]\n pub struct Pick<'tcx> {\n     pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n@@ -1264,7 +1268,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///    and/or tracking the substitution and\n     ///    so forth.\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         ty::erase_late_bound_regions(self.tcx(), value)\n     }\n@@ -1370,59 +1374,3 @@ impl<'tcx> Candidate<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> Repr for Candidate<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Candidate(xform_self_ty={}, kind={})\",\n-                self.xform_self_ty.repr(),\n-                self.kind.repr())\n-    }\n-}\n-\n-impl<'tcx> Repr for CandidateKind<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            InherentImplCandidate(ref a, ref b, ref c) =>\n-                format!(\"InherentImplCandidate({},{},{})\", a.repr(), b.repr(),\n-                        c.repr()),\n-            ObjectCandidate(a, b, c) =>\n-                format!(\"ObjectCandidate({},{},{})\", a.repr(), b, c),\n-            ExtensionImplCandidate(ref a, ref b, ref c, ref d, ref e) =>\n-                format!(\"ExtensionImplCandidate({},{},{},{},{})\", a.repr(), b.repr(),\n-                        c.repr(), d, e.repr()),\n-            ClosureCandidate(ref a, ref b) =>\n-                format!(\"ClosureCandidate({},{})\", a.repr(), b),\n-            WhereClauseCandidate(ref a, ref b) =>\n-                format!(\"WhereClauseCandidate({},{})\", a.repr(), b),\n-            ProjectionCandidate(ref a, ref b) =>\n-                format!(\"ProjectionCandidate({},{})\", a.repr(), b),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Repr for CandidateStep<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"CandidateStep({}, autoderefs={}, unsize={})\",\n-                self.self_ty.repr(),\n-                self.autoderefs,\n-                self.unsize)\n-    }\n-}\n-\n-impl<'tcx> Repr for PickKind<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Repr for Pick<'tcx> {\n-    fn repr(&self) -> String {\n-        format!(\"Pick(item={}, autoderefs={},\n-                 autoref={}, unsize={}, kind={:?})\",\n-                self.item.repr(),\n-                self.autoderefs,\n-                self.autoref.repr(),\n-                self.unsize.repr(),\n-                self.kind)\n-    }\n-}"}, {"sha": "cc57ec8a8cd8fb878a98eaaf79023fe89bccd81a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -193,7 +193,7 @@ type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx\n \n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -1444,7 +1444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n@@ -1470,7 +1470,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n+        where T : TypeFoldable<'tcx> + HasProjectionTypes\n     {\n         self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n@@ -3605,8 +3605,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                type_and_substs.ty) {\n                 Ok(()) => {}\n                 Err(type_error) => {\n-                    let type_error_description =\n-                        ty::type_err_to_str(tcx, &type_error);\n                     span_err!(fcx.tcx().sess, path.span, E0235,\n                                  \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n@@ -3616,7 +3614,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description);\n+                                         type_error);\n                     ty::note_and_explain_type_err(tcx, &type_error, path.span);\n                 }\n             }\n@@ -3907,20 +3905,6 @@ impl<'tcx> Expectation<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr for Expectation<'tcx> {\n-    fn repr(&self) -> String {\n-        match *self {\n-            NoExpectation => format!(\"NoExpectation\"),\n-            ExpectHasType(t) => format!(\"ExpectHasType({})\",\n-                                        t.repr()),\n-            ExpectCastableToType(t) => format!(\"ExpectCastableToType({})\",\n-                                               t.repr()),\n-            ExpectRvalueLikeUnsized(t) => format!(\"ExpectRvalueLikeUnsized({})\",\n-                                                  t.repr()),\n-        }\n-    }\n-}\n-\n pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                        local: &'tcx ast::Local,\n                                        init: &'tcx ast::Expr)"}, {"sha": "7bcd3ddf59048abfa929c0f05bdced787d26e8c5", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -536,7 +536,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n     }\n \n     fn fold_binder<T>(&mut self, binder: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         self.binding_count += 1;\n         let value = liberate_late_bound_regions("}, {"sha": "9987b884cf282143f79a2c5f4a855f7598b18c2f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -2235,7 +2235,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         scope: region::DestructionScopeData,\n         value: &T)\n         -> T\n-        where T : TypeFoldable<'tcx> + Repr\n+        where T : TypeFoldable<'tcx>\n     {\n         /*!\n          * Convert early-bound regions into free regions; normally this is done by"}, {"sha": "b56bb895b9ed69f77a797e97193596c2083af1b9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -199,11 +199,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            span_err!(tcx.sess, span, E0211,\n-                              \"{}: {}\",\n-                                      msg(),\n-                                      ty::type_err_to_str(tcx,\n-                                                          terr));\n+            span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n             ty::note_and_explain_type_err(tcx, terr, span);\n             false\n         }"}, {"sha": "d40a9522f23a9e44da1c9ff841559071af940be2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -522,7 +522,7 @@ pub enum TyParamBound {\n impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n         use syntax::ast::TraitBoundModifier as TBM;\n-        let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n+        let mut sized_bound = ty::BoundSized.clean(cx);\n         if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n             *tbm = TBM::Maybe\n         };"}, {"sha": "b71eadd6d08af03d7ce587c39aa1d2811a561d8c", "filename": "src/test/compile-fail/object-lifetime-default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs?ref=dfbc9608ce5c9655a36b63f6cc9694f5e4ad9890", "patch": "@@ -29,6 +29,6 @@ struct E<'a,'b:'a,T:'b>(&'a T, &'b T); //~ ERROR 'b\n struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U); //~ ERROR 'a,'b\n \n #[rustc_object_lifetime_default]\n-struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Ambiguous\n+struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Some(Ambiguous)\n \n fn main() { }"}]}