{"sha": "3f0c97740f10372a6dc8a085eba571822911afc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMGM5Nzc0MGYxMDM3MmE2ZGM4YTA4NWViYTU3MTgyMjkxMWFmYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-16T01:48:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-16T01:48:01Z"}, "message": "Auto merge of #7531 - Jarcho:manual_map_7413, r=camsteffen\n\nManual map 7413\n\nfixes: #7413\n\nThis only fixes the specific problem from #7413, not the general case. The full fix requires interacting with the borrow checker to determine the lifetime of all the borrows made in the function. I'll open an issue about it later.\n\nchangelog: Don't suggest using `map` when the option is borrowed in the match, and also consumed in the arm.\nchangelog: Locals declared within the would-be closure will not prevent the closure from being suggested in `manual_map` and `map_entry`", "tree": {"sha": "2dc77ba66f61affddca0f576cd743b097ab24fec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dc77ba66f61affddca0f576cd743b097ab24fec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f0c97740f10372a6dc8a085eba571822911afc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0c97740f10372a6dc8a085eba571822911afc7", "html_url": "https://github.com/rust-lang/rust/commit/3f0c97740f10372a6dc8a085eba571822911afc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f0c97740f10372a6dc8a085eba571822911afc7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e2fcabb1cd69ecea19c6f8503ca86a34a183ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e2fcabb1cd69ecea19c6f8503ca86a34a183ec", "html_url": "https://github.com/rust-lang/rust/commit/d4e2fcabb1cd69ecea19c6f8503ca86a34a183ec"}, {"sha": "f0444d73def161f7f0fda7b3f5a13e9908e9c550", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0444d73def161f7f0fda7b3f5a13e9908e9c550", "html_url": "https://github.com/rust-lang/rust/commit/f0444d73def161f7f0fda7b3f5a13e9908e9c550"}], "stats": {"total": 579, "additions": 519, "deletions": 60}, "files": [{"sha": "7fb8e4276600f898a50ed6db0c85cc42ffc40389", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -7,8 +7,9 @@ use clippy_utils::{\n };\n use rustc_errors::Applicability;\n use rustc_hir::{\n+    hir_id::HirIdSet,\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -336,6 +337,8 @@ struct InsertSearcher<'cx, 'tcx> {\n     edits: Vec<Edit<'tcx>>,\n     /// A stack of loops the visitor is currently in.\n     loops: Vec<HirId>,\n+    /// Local variables created in the expression. These don't need to be captured.\n+    locals: HirIdSet,\n }\n impl<'tcx> InsertSearcher<'_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n@@ -383,13 +386,16 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 }\n             },\n             StmtKind::Expr(e) => self.visit_expr(e),\n-            StmtKind::Local(Local { init: Some(e), .. }) => {\n-                self.allow_insert_closure &= !self.in_tail_pos;\n-                self.in_tail_pos = false;\n-                self.is_single_insert = false;\n-                self.visit_expr(e);\n+            StmtKind::Local(l) => {\n+                self.visit_pat(l.pat);\n+                if let Some(e) = l.init {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.in_tail_pos = false;\n+                    self.is_single_insert = false;\n+                    self.visit_expr(e);\n+                }\n             },\n-            _ => {\n+            StmtKind::Item(_) => {\n                 self.allow_insert_closure &= !self.in_tail_pos;\n                 self.is_single_insert = false;\n             },\n@@ -471,6 +477,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n+                        self.visit_pat(arm.pat);\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n@@ -496,7 +503,8 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 },\n                 _ => {\n                     self.allow_insert_closure &= !self.in_tail_pos;\n-                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    self.allow_insert_closure &=\n+                        can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops, &self.locals);\n                     // Sub expressions are no longer in the tail position.\n                     self.is_single_insert = false;\n                     self.in_tail_pos = false;\n@@ -505,6 +513,12 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n             },\n         }\n     }\n+\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+        p.each_binding_or_first(&mut |_, id, _, _| {\n+            self.locals.insert(id);\n+        });\n+    }\n }\n \n struct InsertSearchResults<'tcx> {\n@@ -630,6 +644,7 @@ fn find_insert_calls(\n         in_tail_pos: true,\n         is_single_insert: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n     };\n     s.visit_expr(expr);\n     let allow_insert_closure = s.allow_insert_closure;"}, {"sha": "3ea88f52a1ccfded52f7ebf2832855e579c78d4e", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -4,12 +4,14 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -111,10 +113,6 @@ impl LateLintPass<'_> for ManualMap {\n                 return;\n             }\n \n-            if !can_move_expr_to_closure(cx, some_expr) {\n-                return;\n-            }\n-\n             // Determine which binding mode to use.\n             let explicit_ref = some_pat.contains_explicit_ref_binding();\n             let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n@@ -125,6 +123,32 @@ impl LateLintPass<'_> for ManualMap {\n                 None => \"\",\n             };\n \n+            match can_move_expr_to_closure(cx, some_expr) {\n+                Some(captures) => {\n+                    // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+                    // TODO: check all the references made in the scrutinee expression. This will require interacting\n+                    // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+                    if let Some(binding_ref_mutability) = binding_ref {\n+                        let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                            ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                            _ => None,\n+                        });\n+                        if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                            match captures.get(l) {\n+                                Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                                Some(CaptureKind::Ref(Mutability::Not))\n+                                    if binding_ref_mutability == Mutability::Mut =>\n+                                {\n+                                    return;\n+                                }\n+                                Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                            }\n+                        }\n+                    }\n+                },\n+                None => return,\n+            };\n+\n             let mut app = Applicability::MachineApplicable;\n \n             // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or"}, {"sha": "bd229402f418203b67e9845c5617450566d6043f", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 241, "deletions": 26, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -62,23 +62,27 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n+use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n+    PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n-use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::binding::BindingMode;\n+use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -89,7 +93,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -626,11 +630,46 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n }\n \n /// Checks if the top level expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+/// Currently checks for:\n+/// * Break/Continue outside the given loop HIR ids.\n+/// * Yield/Return statments.\n+/// * Inline assembly.\n+/// * Usages of a field of a local where the type of the local can be partially moved.\n+///\n+/// For example, given the following function:\n+///\n+/// ```\n+/// fn f<'a>(iter: &mut impl Iterator<Item = (usize, &'a mut String)>) {\n+///     for item in iter {\n+///         let s = item.1;\n+///         if item.0 > 10 {\n+///             continue;\n+///         } else {\n+///             s.clear();\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// When called on the expression `item.0` this will return false unless the local `item` is in the\n+/// `ignore_locals` set. The type `(usize, &mut String)` can have the second element moved, so it\n+/// isn't always safe to move into a closure when only a single field is needed.\n+///\n+/// When called on the `continue` expression this will return false unless the outer loop expression\n+/// is in the `loop_ids` set.\n+///\n+/// Note that this check is not recursive, so passing the `if` expression will always return true\n+/// even though sub-expressions might return false.\n+pub fn can_move_expr_to_closure_no_visit(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    loop_ids: &[HirId],\n+    ignore_locals: &HirIdSet,\n+) -> bool {\n     match expr.kind {\n         ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n         | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n-            if jump_targets.contains(&id) =>\n+            if loop_ids.contains(&id) =>\n         {\n             true\n         },\n@@ -642,25 +681,158 @@ pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Exp\n         | ExprKind::LlvmInlineAsm(_) => false,\n         // Accessing a field of a local value can only be done if the type isn't\n         // partially moved.\n-        ExprKind::Field(base_expr, _)\n-            if matches!(\n-                base_expr.kind,\n-                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n-        {\n+        ExprKind::Field(\n+            &Expr {\n+                hir_id,\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Local(local_id),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            _,\n+        ) if !ignore_locals.contains(local_id) && can_partially_move_ty(cx, cx.typeck_results().node_type(hir_id)) => {\n             // TODO: check if the local has been partially moved. Assume it has for now.\n             false\n-        }\n+        },\n         _ => true,\n     }\n }\n \n-/// Checks if the expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+/// How a local is captured by a closure\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureKind {\n+    Value,\n+    Ref(Mutability),\n+}\n+impl std::ops::BitOr for CaptureKind {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self::Output {\n+        match (self, rhs) {\n+            (CaptureKind::Value, _) | (_, CaptureKind::Value) => CaptureKind::Value,\n+            (CaptureKind::Ref(Mutability::Mut), CaptureKind::Ref(_))\n+            | (CaptureKind::Ref(_), CaptureKind::Ref(Mutability::Mut)) => CaptureKind::Ref(Mutability::Mut),\n+            (CaptureKind::Ref(Mutability::Not), CaptureKind::Ref(Mutability::Not)) => CaptureKind::Ref(Mutability::Not),\n+        }\n+    }\n+}\n+impl std::ops::BitOrAssign for CaptureKind {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+/// Given an expression referencing a local, determines how it would be captured in a closure.\n+/// Note as this will walk up to parent expressions until the capture can be determined it should\n+/// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n+/// function argument (other than a receiver).\n+pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+    fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n+        let mut capture = CaptureKind::Ref(Mutability::Not);\n+        pat.each_binding_or_first(&mut |_, id, span, _| match cx\n+            .typeck_results()\n+            .extract_binding_mode(cx.sess(), id, span)\n+            .unwrap()\n+        {\n+            BindingMode::BindByValue(_) if !is_copy(cx, cx.typeck_results().node_type(id)) => {\n+                capture = CaptureKind::Value;\n+            },\n+            BindingMode::BindByReference(Mutability::Mut) if capture != CaptureKind::Value => {\n+                capture = CaptureKind::Ref(Mutability::Mut);\n+            },\n+            _ => (),\n+        });\n+        capture\n+    }\n+\n+    debug_assert!(matches!(\n+        e.kind,\n+        ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(_), .. }))\n+    ));\n+\n+    let map = cx.tcx.hir();\n+    let mut child_id = e.hir_id;\n+    let mut capture = CaptureKind::Value;\n+    let mut capture_expr_ty = e;\n+\n+    for (parent_id, parent) in map.parent_iter(e.hir_id) {\n+        if let [Adjustment {\n+            kind: Adjust::Deref(_) | Adjust::Borrow(AutoBorrow::Ref(..)),\n+            target,\n+        }, ref adjust @ ..] = *cx\n+            .typeck_results()\n+            .adjustments()\n+            .get(child_id)\n+            .map_or(&[][..], |x| &**x)\n+        {\n+            if let rustc_ty::RawPtr(TypeAndMut { mutbl: mutability, .. }) | rustc_ty::Ref(_, _, mutability) =\n+                *adjust.last().map_or(target, |a| a.target).kind()\n+            {\n+                return CaptureKind::Ref(mutability);\n+            }\n+        }\n+\n+        match parent {\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n+                ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n+                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                    return CaptureKind::Ref(Mutability::Mut);\n+                },\n+                ExprKind::Field(..) => {\n+                    if capture == CaptureKind::Value {\n+                        capture_expr_ty = e;\n+                    }\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    let mut mutability = Mutability::Not;\n+                    for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {\n+                        match capture {\n+                            CaptureKind::Value => break,\n+                            CaptureKind::Ref(Mutability::Mut) => mutability = Mutability::Mut,\n+                            CaptureKind::Ref(Mutability::Not) => (),\n+                        }\n+                    }\n+                    return CaptureKind::Ref(mutability);\n+                },\n+                _ => break,\n+            },\n+            Node::Local(l) => match pat_capture_kind(cx, l.pat) {\n+                CaptureKind::Value => break,\n+                capture @ CaptureKind::Ref(_) => return capture,\n+            },\n+            _ => break,\n+        }\n+\n+        child_id = parent_id;\n+    }\n+\n+    if capture == CaptureKind::Value && is_copy(cx, cx.typeck_results().expr_ty(capture_expr_ty)) {\n+        // Copy types are never automatically captured by value.\n+        CaptureKind::Ref(Mutability::Not)\n+    } else {\n+        capture\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is. This will return a list of captures\n+/// if so, otherwise, `None`.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n+        // Stack of potential break targets contained in the expression.\n         loops: Vec<HirId>,\n+        /// Local variables created in the expression. These don't need to be captured.\n+        locals: HirIdSet,\n+        /// Whether this expression can be turned into a closure.\n         allow_closure: bool,\n+        /// Locals which need to be captured, and whether they need to be by value, reference, or\n+        /// mutable reference.\n+        captures: HirIdMap<CaptureKind>,\n     }\n     impl Visitor<'tcx> for V<'_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n@@ -672,24 +844,67 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n             if !self.allow_closure {\n                 return;\n             }\n-            if let ExprKind::Loop(b, ..) = e.kind {\n-                self.loops.push(e.hir_id);\n-                self.visit_block(b);\n-                self.loops.pop();\n-            } else {\n-                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n-                walk_expr(self, e);\n+\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, &Path { res: Res::Local(l), .. })) => {\n+                    if !self.locals.contains(&l) {\n+                        let cap = capture_local_usage(self.cx, e);\n+                        self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n+                    }\n+                },\n+                ExprKind::Closure(..) => {\n+                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id).to_def_id();\n+                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n+                        let local_id = match capture.place.base {\n+                            PlaceBase::Local(id) => id,\n+                            PlaceBase::Upvar(var) => var.var_path.hir_id,\n+                            _ => continue,\n+                        };\n+                        if !self.locals.contains(&local_id) {\n+                            let capture = match capture.info.capture_kind {\n+                                UpvarCapture::ByValue(_) => CaptureKind::Value,\n+                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                    BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n+                                    BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n+                                        CaptureKind::Ref(Mutability::Mut)\n+                                    },\n+                                },\n+                            };\n+                            self.captures\n+                                .entry(local_id)\n+                                .and_modify(|e| *e |= capture)\n+                                .or_insert(capture);\n+                        }\n+                    }\n+                },\n+                ExprKind::Loop(b, ..) => {\n+                    self.loops.push(e.hir_id);\n+                    self.visit_block(b);\n+                    self.loops.pop();\n+                },\n+                _ => {\n+                    self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n+                    walk_expr(self, e);\n+                },\n             }\n         }\n+\n+        fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+            p.each_binding_or_first(&mut |_, id, _, _| {\n+                self.locals.insert(id);\n+            });\n+        }\n     }\n \n     let mut v = V {\n         cx,\n         allow_closure: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n+        captures: HirIdMap::default(),\n     };\n     v.visit_expr(expr);\n-    v.allow_closure\n+    v.allow_closure.then(|| v.captures)\n }\n \n /// Returns the method names and argument list of nested method call expressions that make up\n@@ -1715,7 +1930,7 @@ pub fn peel_hir_expr_while<'tcx>(\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n     let mut remaining = count;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) if remaining != 0 => {\n             remaining -= 1;\n             Some(e)\n         },\n@@ -1729,7 +1944,7 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     let mut count = 0;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) => {\n             count += 1;\n             Some(e)\n         },"}, {"sha": "8a36ec833d76d3aa331b120d356507efe46168e1", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -142,14 +142,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n-    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-        e.insert(v);\n-        foo();\n-    }\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n+    m.entry(k).or_insert_with(|| {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n+        v\n+    });\n }\n \n fn main() {}"}, {"sha": "d972a201ad76460e401c6a0ff613eab5e4f53af9", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -146,13 +146,12 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n     if !m.contains_key(&k) {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n         m.insert(k, v);\n-        foo();\n     }\n }\n "}, {"sha": "1076500498d32fe321a2de82c68e91514cae9ac8", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -165,21 +165,23 @@ LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:153:5\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:151:5\n    |\n LL | /     if !m.contains_key(&k) {\n+LL | |         let x = (String::new(), String::new());\n+LL | |         let _ = x.0;\n LL | |         m.insert(k, v);\n-LL | |         foo();\n LL | |     }\n    | |_____^\n    |\n help: try this\n    |\n-LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-LL +         e.insert(v);\n-LL +         foo();\n-LL +     }\n+LL ~     m.entry(k).or_insert_with(|| {\n+LL +         let x = (String::new(), String::new());\n+LL +         let _ = x.0;\n+LL +         v\n+LL +     });\n    |\n \n error: aborting due to 10 previous errors"}, {"sha": "94979104556bc882267d230b41c535319d712bd8", "filename": "tests/ui/entry_btree.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.fixed?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "080c1d959e89425d326ae8c05e8053128a347425", "filename": "tests/ui/entry_btree.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5c6fcdf1a28c01f1ba0cbdd646bfb48453cde0e3", "filename": "tests/ui/entry_btree.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fentry_btree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.stderr?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,20 @@\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry_btree.rs:12:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL +         e.insert(v);\n+LL +         foo();\n+LL +     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "8cc12149403d32aa22aaba2618c187eb65ea5c20", "filename": "tests/ui/manual_map_option_2.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = Some(0).map(|x| {\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        });\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = s.as_ref().map(|x| {\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        });\n+}"}, {"sha": "0862b201ead4b7290f600e6b27454a8a1b72dc4a", "filename": "tests/ui/manual_map_option_2.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = match Some(0) {\n+        Some(x) => Some({\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        }),\n+        None => None,\n+    };\n+}"}, {"sha": "711ff6c4a4b095dfc5da5efd75116e4b2fa5445d", "filename": "tests/ui/manual_map_option_2.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f0c97740f10372a6dc8a085eba571822911afc7/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=3f0c97740f10372a6dc8a085eba571822911afc7", "patch": "@@ -0,0 +1,43 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:8:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             let y = (String::new(), String::new());\n+LL | |             (x, y.0)\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     let _ = Some(0).map(|x| {\n+LL +             let y = (String::new(), String::new());\n+LL +             (x, y.0)\n+LL ~         });\n+   |\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:50:13\n+   |\n+LL |       let _ = match &s {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     let _ = s.as_ref().map(|x| {\n+LL +             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL ~         });\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}]}