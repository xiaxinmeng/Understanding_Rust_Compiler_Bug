{"sha": "73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczY2M2MjRlOGUzMjZmNTRlYjBlYThiZmY3MDM4OGQ2MmRjY2QzY2I=", "commit": {"author": {"name": "Rob Arnold", "email": "robarnold@cs.cmu.edu", "date": "2011-06-30T15:29:35Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-01T23:59:10Z"}, "message": "Move the channel destroy code into rust_chan.\n\nThis lets native code more easily destroy channels since directly deleting a\nchannel is not always the right way to destroy it.", "tree": {"sha": "d0623428177fdc2f305e749eab9b03a80459d8d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0623428177fdc2f305e749eab9b03a80459d8d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "html_url": "https://github.com/rust-lang/rust/commit/73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/comments", "author": {"login": "robarnold", "id": 326113, "node_id": "MDQ6VXNlcjMyNjExMw==", "avatar_url": "https://avatars.githubusercontent.com/u/326113?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robarnold", "html_url": "https://github.com/robarnold", "followers_url": "https://api.github.com/users/robarnold/followers", "following_url": "https://api.github.com/users/robarnold/following{/other_user}", "gists_url": "https://api.github.com/users/robarnold/gists{/gist_id}", "starred_url": "https://api.github.com/users/robarnold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robarnold/subscriptions", "organizations_url": "https://api.github.com/users/robarnold/orgs", "repos_url": "https://api.github.com/users/robarnold/repos", "events_url": "https://api.github.com/users/robarnold/events{/privacy}", "received_events_url": "https://api.github.com/users/robarnold/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09921cf86f156208741243a7e0ea55b88155ec72", "url": "https://api.github.com/repos/rust-lang/rust/commits/09921cf86f156208741243a7e0ea55b88155ec72", "html_url": "https://github.com/rust-lang/rust/commit/09921cf86f156208741243a7e0ea55b88155ec72"}], "stats": {"total": 68, "additions": 39, "deletions": 29}, "files": [{"sha": "3065a55e582608fe726e0f4b079a58364c92b7e8", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "patch": "@@ -116,6 +116,41 @@ rust_chan *rust_chan::clone(maybe_proxy<rust_task> *target) {\n     return new (target_task) rust_chan(target_task, port, unit_sz);\n }\n \n+/**\n+ * Cannot Yield: If the task were to unwind, the dropped ref would still\n+ * appear to be live, causing modify-after-free errors.\n+ */\n+void rust_chan::destroy() {\n+    A(task->sched, ref_count == 0,\n+      \"Channel's ref count should be zero.\");\n+\n+    if (is_associated()) {\n+        if (port->is_proxy()) {\n+            // Here is a good place to delete the port proxy we allocated\n+            // in upcall_clone_chan.\n+            rust_proxy<rust_port> *proxy = port->as_proxy();\n+            disassociate();\n+            delete proxy;\n+        } else {\n+            // We're trying to delete a channel that another task may be\n+            // reading from. We have two options:\n+            //\n+            // 1. We can flush the channel by blocking in upcall_flush_chan()\n+            //    and resuming only when the channel is flushed. The problem\n+            //    here is that we can get ourselves in a deadlock if the\n+            //    parent task tries to join us.\n+            //\n+            // 2. We can leave the channel in a \"dormnat\" state by not freeing\n+            //    it and letting the receiver task delete it for us instead.\n+            if (buffer.is_empty() == false) {\n+                return;\n+            }\n+            disassociate();\n+        }\n+    }\n+    delete this;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "a327dbf0c95d45eb8bacf5dc504877a4c9844b8b", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "patch": "@@ -21,6 +21,9 @@ class rust_chan : public rc_base<rust_chan>,\n     void send(void *sptr);\n \n     rust_chan *clone(maybe_proxy<rust_task> *target);\n+\n+    // Called whenever the channel's ref count drops to zero.\n+    void destroy();\n };\n \n //"}, {"sha": "05220f026065c3ff0d29d4a7204e6f43f7847b55", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/73cc624e8e326f54eb0ea8bff70388d62dccd3cb/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=73cc624e8e326f54eb0ea8bff70388d62dccd3cb", "patch": "@@ -126,35 +126,7 @@ void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     scoped_lock with(task->kernel->scheduler_lock);\n \n     LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n-\n-    A(task->sched, chan->ref_count == 0,\n-      \"Channel's ref count should be zero.\");\n-\n-    if (chan->is_associated()) {\n-        if (chan->port->is_proxy()) {\n-            // Here is a good place to delete the port proxy we allocated\n-            // in upcall_clone_chan.\n-            rust_proxy<rust_port> *proxy = chan->port->as_proxy();\n-            chan->disassociate();\n-            delete proxy;\n-        } else {\n-            // We're trying to delete a channel that another task may be\n-            // reading from. We have two options:\n-            //\n-            // 1. We can flush the channel by blocking in upcall_flush_chan()\n-            //    and resuming only when the channel is flushed. The problem\n-            //    here is that we can get ourselves in a deadlock if the\n-            //    parent task tries to join us.\n-            //\n-            // 2. We can leave the channel in a \"dormant\" state by not freeing\n-            //    it and letting the receiver task delete it for us instead.\n-            if (chan->buffer.is_empty() == false) {\n-                return;\n-            }\n-            chan->disassociate();\n-        }\n-    }\n-    delete chan;\n+    chan->destroy();\n }\n \n /**"}]}