{"sha": "1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNmEyZWIxNGE4NGMzYTY2OTcyZDFhNmRhNDI5Y2NhMWFhOGI0MGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-31T09:29:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-31T09:29:19Z"}, "message": "Move the rest of the features to generated docs", "tree": {"sha": "adc80cc0840911ca3aa86fd03fff6e49d99cc821", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adc80cc0840911ca3aa86fd03fff6e49d99cc821"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "html_url": "https://github.com/rust-lang/rust/commit/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b795a07320e13bcbedb6435bcfddb3ecd0ed2bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/b795a07320e13bcbedb6435bcfddb3ecd0ed2bde", "html_url": "https://github.com/rust-lang/rust/commit/b795a07320e13bcbedb6435bcfddb3ecd0ed2bde"}], "stats": {"total": 598, "additions": 358, "deletions": 240}, "files": [{"sha": "d890b69d26fa914fe21009a97ac4807b605f3921", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n mod completion_config;\n mod completion_item;\n mod completion_context;\n@@ -35,6 +33,51 @@ pub use crate::completion::{\n     completion_item::{CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat},\n };\n \n+//FIXME: split the following feature into fine-grained features.\n+\n+// Feature: Magic Completions\n+//\n+// In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n+// completions as well:\n+//\n+// Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n+// is placed at the appropriate position. Even though `if` is easy to type, you\n+// still want to complete it, to get ` { }` for free! `return` is inserted with a\n+// space or `;` depending on the return type of the function.\n+//\n+// When completing a function call, `()` are automatically inserted. If a function\n+// takes arguments, the cursor is positioned inside the parenthesis.\n+//\n+// There are postfix completions, which can be triggered by typing something like\n+// `foo().if`. The word after `.` determines postfix completion. Possible variants are:\n+//\n+// - `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n+// - `expr.match` -> `match expr {}`\n+// - `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n+// - `expr.ref` -> `&expr`\n+// - `expr.refm` -> `&mut expr`\n+// - `expr.not` -> `!expr`\n+// - `expr.dbg` -> `dbg!(expr)`\n+//\n+// There also snippet completions:\n+//\n+// .Expressions\n+// - `pd` -> `println!(\"{:?}\")`\n+// - `ppd` -> `println!(\"{:#?}\")`\n+//\n+// .Items\n+// - `tfn` -> `#[test] fn f(){}`\n+// - `tmod` ->\n+// ```rust\n+// #[cfg(test)]\n+// mod tests {\n+//     use super::*;\n+//\n+//     #[test]\n+//     fn test_fn() {}\n+// }\n+// ```\n+\n /// Main entry point for completion. We run completion as a two-phase process.\n ///\n /// First, we look at the position and collect a so-called `CompletionContext."}, {"sha": "59b58bf98b6b5282466190326f2c9431569429df", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,20 +1,20 @@\n //! FIXME: write short doc here\n-\n+use ra_assists::utils::TryEnum;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextRange, TextSize,\n };\n use ra_text_edit::TextEdit;\n \n-use super::completion_config::SnippetCap;\n use crate::{\n     completion::{\n         completion_context::CompletionContext,\n         completion_item::{Builder, CompletionKind, Completions},\n     },\n     CompletionItem,\n };\n-use ra_assists::utils::TryEnum;\n+\n+use super::completion_config::SnippetCap;\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_postfix_completions {"}, {"sha": "d96cb55969180c582b76c36ebce2ae6eafb049fc", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,10 +1,10 @@\n-//! Logic for computing info that is displayed when the user hovers over any\n-//! source code items (e.g. function call, struct field, variable symbol...)\n+use std::iter::once;\n \n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n     ModuleSource, Semantics,\n };\n+use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n@@ -21,8 +21,6 @@ use crate::{\n     display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n     FilePosition, RangeInfo,\n };\n-use itertools::Itertools;\n-use std::iter::once;\n \n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n@@ -62,6 +60,63 @@ impl HoverResult {\n     }\n }\n \n+// Feature: Hover\n+//\n+// Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n+// Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n+    let sema = Semantics::new(db);\n+    let file = sema.parse(position.file_id).syntax().clone();\n+    let token = pick_best(file.token_at_offset(position.offset))?;\n+    let token = sema.descend_into_macros(token);\n+\n+    let mut res = HoverResult::new();\n+\n+    if let Some((node, name_kind)) = match_ast! {\n+        match (token.parent()) {\n+            ast::NameRef(name_ref) => {\n+                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n+            },\n+            ast::Name(name) => {\n+                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n+            },\n+            _ => None,\n+        }\n+    } {\n+        let range = sema.original_range(&node).range;\n+        res.extend(hover_text_from_name_kind(db, name_kind));\n+\n+        if !res.is_empty() {\n+            return Some(RangeInfo::new(range, res));\n+        }\n+    }\n+\n+    let node = token\n+        .ancestors()\n+        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n+\n+    let ty = match_ast! {\n+        match node {\n+            ast::MacroCall(_it) => {\n+                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+                // (e.g expanding a builtin macro). So we give up here.\n+                return None;\n+            },\n+            ast::Expr(it) => {\n+                sema.type_of_expr(&it)\n+            },\n+            ast::Pat(it) => {\n+                sema.type_of_pat(&it)\n+            },\n+            _ => None,\n+        }\n+    }?;\n+\n+    res.extend(Some(rust_code_markup(&ty.display(db))));\n+    let range = sema.original_range(&node).range;\n+    Some(RangeInfo::new(range, res))\n+}\n+\n fn hover_text(\n     docs: Option<String>,\n     desc: Option<String>,\n@@ -160,59 +215,6 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     }\n }\n \n-pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id).syntax().clone();\n-    let token = pick_best(file.token_at_offset(position.offset))?;\n-    let token = sema.descend_into_macros(token);\n-\n-    let mut res = HoverResult::new();\n-\n-    if let Some((node, name_kind)) = match_ast! {\n-        match (token.parent()) {\n-            ast::NameRef(name_ref) => {\n-                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n-            },\n-            ast::Name(name) => {\n-                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n-            },\n-            _ => None,\n-        }\n-    } {\n-        let range = sema.original_range(&node).range;\n-        res.extend(hover_text_from_name_kind(db, name_kind));\n-\n-        if !res.is_empty() {\n-            return Some(RangeInfo::new(range, res));\n-        }\n-    }\n-\n-    let node = token\n-        .ancestors()\n-        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n-\n-    let ty = match_ast! {\n-        match node {\n-            ast::MacroCall(_it) => {\n-                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n-                // (e.g expanding a builtin macro). So we give up here.\n-                return None;\n-            },\n-            ast::Expr(it) => {\n-                sema.type_of_expr(&it)\n-            },\n-            ast::Pat(it) => {\n-                sema.type_of_pat(&it)\n-            },\n-            _ => None,\n-        }\n-    }?;\n-\n-    res.extend(Some(rust_code_markup(&ty.display(db))));\n-    let range = sema.original_range(&node).range;\n-    Some(RangeInfo::new(range, res))\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}, {"sha": "75bd3c96bb1fc841d6fc4473c7248913e871e492", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,5 +1,3 @@\n-//! This module defines multiple types of inlay hints and their visibility\n-\n use hir::{Adt, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -39,6 +37,26 @@ pub struct InlayHint {\n     pub label: SmolStr,\n }\n \n+// Feature: Inlay Hints\n+//\n+// rust-analyzer shows additional information inline with the source code.\n+// Editors usually render this using read-only virtual text snippets interspersed with code.\n+//\n+// rust-analyzer shows hits for\n+//\n+// * types of local variables\n+// * names of function arguments\n+// * types of chained expressions\n+//\n+// **Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n+// This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n+// https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Toggle inlay hints*\n+// |===\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,"}, {"sha": "3ab1f0a21573c307b832b6a40a163b54f8507459", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 84, "deletions": 77, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,5 +1,3 @@\n-//! Implements syntax highlighting.\n-\n mod tags;\n mod html;\n #[cfg(test)]\n@@ -32,81 +30,15 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n-#[derive(Debug)]\n-struct HighlightedRangeStack {\n-    stack: Vec<Vec<HighlightedRange>>,\n-}\n-\n-/// We use a stack to implement the flattening logic for the highlighted\n-/// syntax ranges.\n-impl HighlightedRangeStack {\n-    fn new() -> Self {\n-        Self { stack: vec![Vec::new()] }\n-    }\n-\n-    fn push(&mut self) {\n-        self.stack.push(Vec::new());\n-    }\n-\n-    /// Flattens the highlighted ranges.\n-    ///\n-    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-    /// 1) parent-range: Attribute [0, 23)\n-    /// 2) child-range: String [16, 21)\n-    ///\n-    /// The following code implements the flattening, for our example this results to:\n-    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-    fn pop(&mut self) {\n-        let children = self.stack.pop().unwrap();\n-        let prev = self.stack.last_mut().unwrap();\n-        let needs_flattening = !children.is_empty()\n-            && !prev.is_empty()\n-            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n-        if !needs_flattening {\n-            prev.extend(children);\n-        } else {\n-            let mut parent = prev.pop().unwrap();\n-            for ele in children {\n-                assert!(parent.range.contains_range(ele.range));\n-                let mut cloned = parent.clone();\n-                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n-                if !parent.range.is_empty() {\n-                    prev.push(parent);\n-                }\n-                prev.push(ele);\n-                parent = cloned;\n-            }\n-            if !parent.range.is_empty() {\n-                prev.push(parent);\n-            }\n-        }\n-    }\n-\n-    fn add(&mut self, range: HighlightedRange) {\n-        self.stack\n-            .last_mut()\n-            .expect(\"during DFS traversal, the stack must not be empty\")\n-            .push(range)\n-    }\n-\n-    fn flattened(mut self) -> Vec<HighlightedRange> {\n-        assert_eq!(\n-            self.stack.len(),\n-            1,\n-            \"after DFS traversal, the stack should only contain a single element\"\n-        );\n-        let mut res = self.stack.pop().unwrap();\n-        res.sort_by_key(|range| range.range.start());\n-        // Check that ranges are sorted and disjoint\n-        assert!(res\n-            .iter()\n-            .zip(res.iter().skip(1))\n-            .all(|(left, right)| left.range.end() <= right.range.start()));\n-        res\n-    }\n-}\n-\n+// Feature: Semantic Syntax Highlighting\n+//\n+// rust-analyzer highlights the code semantically.\n+// For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n+// rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n+// It's up to the client to map those to specific colors.\n+//\n+// The general rule is that a reference to an entity gets colored the same way as the entity itself.\n+// We also give special modifier for `mut` and `&mut` local variables.\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -291,6 +223,81 @@ pub(crate) fn highlight(\n     stack.flattened()\n }\n \n+#[derive(Debug)]\n+struct HighlightedRangeStack {\n+    stack: Vec<Vec<HighlightedRange>>,\n+}\n+\n+/// We use a stack to implement the flattening logic for the highlighted\n+/// syntax ranges.\n+impl HighlightedRangeStack {\n+    fn new() -> Self {\n+        Self { stack: vec![Vec::new()] }\n+    }\n+\n+    fn push(&mut self) {\n+        self.stack.push(Vec::new());\n+    }\n+\n+    /// Flattens the highlighted ranges.\n+    ///\n+    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+    /// 1) parent-range: Attribute [0, 23)\n+    /// 2) child-range: String [16, 21)\n+    ///\n+    /// The following code implements the flattening, for our example this results to:\n+    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+    fn pop(&mut self) {\n+        let children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        let needs_flattening = !children.is_empty()\n+            && !prev.is_empty()\n+            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n+        if !needs_flattening {\n+            prev.extend(children);\n+        } else {\n+            let mut parent = prev.pop().unwrap();\n+            for ele in children {\n+                assert!(parent.range.contains_range(ele.range));\n+                let mut cloned = parent.clone();\n+                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n+                if !parent.range.is_empty() {\n+                    prev.push(parent);\n+                }\n+                prev.push(ele);\n+                parent = cloned;\n+            }\n+            if !parent.range.is_empty() {\n+                prev.push(parent);\n+            }\n+        }\n+    }\n+\n+    fn add(&mut self, range: HighlightedRange) {\n+        self.stack\n+            .last_mut()\n+            .expect(\"during DFS traversal, the stack must not be empty\")\n+            .push(range)\n+    }\n+\n+    fn flattened(mut self) -> Vec<HighlightedRange> {\n+        assert_eq!(\n+            self.stack.len(),\n+            1,\n+            \"after DFS traversal, the stack should only contain a single element\"\n+        );\n+        let mut res = self.stack.pop().unwrap();\n+        res.sort_by_key(|range| range.range.start());\n+        // Check that ranges are sorted and disjoint\n+        assert!(res\n+            .iter()\n+            .zip(res.iter().skip(1))\n+            .all(|(left, right)| left.range.end() <= right.range.start()));\n+        res\n+    }\n+}\n+\n fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n     Some(match kind {\n         FormatSpecifier::Open"}, {"sha": "a341684fda203cf697c758a438d36ba144c75684", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::SourceDatabase;\n+use ra_db::{FileId, SourceDatabase};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,"}, {"sha": "ff8cb2d6ef67f950c940a7ed2bed20e3667af834", "filename": "docs/user/features.md", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b795a07320e13bcbedb6435bcfddb3ecd0ed2bde/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b795a07320e13bcbedb6435bcfddb3ecd0ed2bde/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=b795a07320e13bcbedb6435bcfddb3ecd0ed2bde", "patch": "@@ -1,96 +0,0 @@\n-This document is an index of features that the rust-analyzer language server\n-provides. Shortcuts are for the default VS Code layout. If there's no shortcut,\n-you can use <kbd>Ctrl+Shift+P</kbd> to search for the corresponding action.\n-\n-### Commands <kbd>ctrl+shift+p</kbd>\n-\n-\n-#### Toggle inlay hints\n-\n-Toggle inlay hints view for the current workspace.\n-It is recommended to assign a shortcut for this command to quickly turn off\n-inlay hints when they prevent you from reading/writing the code.\n-\n-### Magic Completions\n-\n-In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n-completions as well:\n-\n-Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n-is placed at the appropriate position. Even though `if` is easy to type, you\n-still want to complete it, to get ` { }` for free! `return` is inserted with a\n-space or `;` depending on the return type of the function.\n-\n-When completing a function call, `()` are automatically inserted. If a function\n-takes arguments, the cursor is positioned inside the parenthesis.\n-\n-There are postfix completions, which can be triggered by typing something like\n-`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n-\n-- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n-- `expr.match` -> `match expr {}`\n-- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n-- `expr.ref` -> `&expr`\n-- `expr.refm` -> `&mut expr`\n-- `expr.not` -> `!expr`\n-- `expr.dbg` -> `dbg!(expr)`\n-\n-There also snippet completions:\n-\n-#### Inside Expressions\n-\n-- `pd` -> `println!(\"{:?}\")`\n-- `ppd` -> `println!(\"{:#?}\")`\n-\n-#### Inside Modules\n-\n-- `tfn` -> `#[test] fn f(){}`\n-- `tmod` ->\n-```rust\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_fn() {}\n-}\n-```\n-\n-### Code Highlighting\n-\n-Experimental feature to let rust-analyzer highlight Rust code instead of using the\n-default highlighter.\n-\n-#### Rainbow Highlighting\n-\n-Experimental feature that, given code highlighting using rust-analyzer is\n-active, will pick unique colors for identifiers.\n-\n-### Code hints\n-\n-Rust-analyzer has two types of hints to show the information about the code:\n-\n-* hover hints, appearing on hover on any element.\n-\n-These contain extended information on the hovered language item.\n-\n-* inlay hints, shown near the element hinted directly in the editor.\n-\n-Two types of inlay hints are displayed currently:\n-\n-* type hints, displaying the minimal information on the type of the expression (if the information is available)\n-* method chaining hints, type information for multi-line method chains\n-* parameter name hints, displaying the names of the parameters in the corresponding methods\n-\n-#### VS Code\n-\n-In VS Code, the following settings can be used to configure the inlay hints:\n-\n-* `rust-analyzer.inlayHints.typeHints` - enable hints for inferred types.\n-* `rust-analyzer.inlayHints.chainingHints` - enable hints for inferred types on method chains.\n-* `rust-analyzer.inlayHints.parameterHints` - enable hints for function parameters.\n-* `rust-analyzer.inlayHints.maxLength` \u2014\u00a0shortens the hints if their length exceeds the value specified. If no value is specified (`null`), no shortening is applied.\n-\n-**Note:** VS Code does not have native support for inlay hints [yet](https://github.com/microsoft/vscode/issues/16221) and the hints are implemented using decorations.\n-This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n-[1](https://github.com/rust-analyzer/rust-analyzer/issues/1623), [2](https://github.com/rust-analyzer/rust-analyzer/issues/3453)."}, {"sha": "a806e3ff119af979e4fd664bebb8e3b6ed5ad531", "filename": "docs/user/generated_features.adoc", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/docs%2Fuser%2Fgenerated_features.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/docs%2Fuser%2Fgenerated_features.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_features.adoc?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -1,3 +1,16 @@\n+=== Expand Macro Recursively\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/expand_macro.rs[expand_macro.rs]\n+\n+\n+Shows the full macro expansion of the macro at current cursor.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Expand macro recursively**\n+|===\n+\n+\n === Extend Selection\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/extend_selection.rs[extend_selection.rs]\n \n@@ -68,6 +81,38 @@ Navigates to the type of an identifier.\n |===\n \n \n+=== Hover\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs[hover.rs]\n+\n+\n+Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n+Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n+\n+\n+=== Inlay Hints\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/inlay_hints.rs[inlay_hints.rs]\n+\n+\n+rust-analyzer shows additional information inline with the source code.\n+Editors usually render this using read-only virtual text snippets interspersed with code.\n+\n+rust-analyzer shows hits for\n+\n+* types of local variables\n+* names of function arguments\n+* types of chained expressions\n+\n+**Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n+This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n+https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Toggle inlay hints*\n+|===\n+\n+\n === Join Lines\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/join_lines.rs[join_lines.rs]\n \n@@ -81,6 +126,52 @@ Join selected lines into one, smartly fixing up whitespace, trailing commas, and\n |===\n \n \n+=== Magic Completions\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/completion.rs[completion.rs]\n+\n+\n+In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n+completions as well:\n+\n+Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n+is placed at the appropriate position. Even though `if` is easy to type, you\n+still want to complete it, to get ` { }` for free! `return` is inserted with a\n+space or `;` depending on the return type of the function.\n+\n+When completing a function call, `()` are automatically inserted. If a function\n+takes arguments, the cursor is positioned inside the parenthesis.\n+\n+There are postfix completions, which can be triggered by typing something like\n+`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n+\n+- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n+- `expr.match` -> `match expr {}`\n+- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n+- `expr.ref` -> `&expr`\n+- `expr.refm` -> `&mut expr`\n+- `expr.not` -> `!expr`\n+- `expr.dbg` -> `dbg!(expr)`\n+\n+There also snippet completions:\n+\n+.Expressions\n+- `pd` -> `println!(\"{:?}\")`\n+- `ppd` -> `println!(\"{:#?}\")`\n+\n+.Items\n+- `tfn` -> `#[test] fn f(){}`\n+- `tmod` ->\n+```rust\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_fn() {}\n+}\n+```\n+\n+\n === Matching Brace\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/matching_brace.rs[matching_brace.rs]\n \n@@ -135,6 +226,19 @@ to a shortcut!\n |===\n \n \n+=== Semantic Syntax Highlighting\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs[syntax_highlighting.rs]\n+\n+\n+rust-analyzer highlights the code semantically.\n+For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n+rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n+It's up to the client to map those to specific colors.\n+\n+The general rule is that a reference to an entity gets colored the same way as the entity itself.\n+We also give special modifier for `mut` and `&mut` local variables.\n+\n+\n === Show Syntax Tree\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_tree.rs[syntax_tree.rs]\n \n@@ -149,6 +253,45 @@ rust-analyzer itself.\n |===\n \n \n+=== Status\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/status.rs[status.rs]\n+\n+\n+Shows internal statistic about memory usage of rust-analyzer.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Status**\n+|===\n+\n+\n+=== Structural Seach and Replace\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/ssr.rs[ssr.rs]\n+\n+\n+Search and replace with named wildcards that will match any expression.\n+The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n+A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n+Available via the command `rust-analyzer.ssr`.\n+\n+```rust\n+// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n+\n+// BEFORE\n+String::from(foo(y + 5, z))\n+\n+// AFTER\n+String::from((y + 5).foo(z))\n+```\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Structural Search Replace**\n+|===\n+\n+\n === Workspace Symbol\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs[symbol_index.rs]\n "}, {"sha": "12def732710c2643b89e704bdc99c2eb7a66e869", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -8,6 +8,7 @@\n :important-caption: :heavy_exclamation_mark:\n :caution-caption: :fire:\n :warning-caption: :warning:\n+:source-highlighter: rouge\n :experimental:\n \n // Master copy of this document lives in the https://github.com/rust-analyzer/rust-analyzer repository"}, {"sha": "a0c2ffef91ce189a005e651bea46dc8866ffdbe3", "filename": "xtask/src/codegen/gen_feature_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs?ref=1c6a2eb14a84c3a66972d1a6da429cca1aa8b40a", "patch": "@@ -50,12 +50,12 @@ impl Feature {\n \n fn is_valid_feature_name(feature: &str) -> bool {\n     'word: for word in feature.split_whitespace() {\n-        for &short in [\"to\"].iter() {\n+        for &short in [\"to\", \"and\"].iter() {\n             if word == short {\n                 continue 'word;\n             }\n         }\n-        for &short in [\"To\"].iter() {\n+        for &short in [\"To\", \"And\"].iter() {\n             if word == short {\n                 return false;\n             }"}]}