{"sha": "d1017940d77f35f841008c3e108e3da5e48a592f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMDE3OTQwZDc3ZjM1Zjg0MTAwOGMzZTEwOGUzZGE1ZTQ4YTU5MmY=", "commit": {"author": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-06-30T08:27:21Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-07-16T21:25:32Z"}, "message": "remove inlined lazy::Waiter in favor of sync::Once", "tree": {"sha": "73e377a65f41111d15d2355e490bd727d4be8649", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73e377a65f41111d15d2355e490bd727d4be8649"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1017940d77f35f841008c3e108e3da5e48a592f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1017940d77f35f841008c3e108e3da5e48a592f", "html_url": "https://github.com/rust-lang/rust/commit/d1017940d77f35f841008c3e108e3da5e48a592f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1017940d77f35f841008c3e108e3da5e48a592f/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1263f5e66d31ad170c524a70aa5f21e08474326", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1263f5e66d31ad170c524a70aa5f21e08474326", "html_url": "https://github.com/rust-lang/rust/commit/d1263f5e66d31ad170c524a70aa5f21e08474326"}], "stats": {"total": 158, "additions": 29, "deletions": 129}, "files": [{"sha": "761cc2b439f679821bcd83e8431a61603178c2db", "filename": "src/libstd/lazy.rs", "status": "modified", "additions": 15, "deletions": 125, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d1017940d77f35f841008c3e108e3da5e48a592f/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1017940d77f35f841008c3e108e3da5e48a592f/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=d1017940d77f35f841008c3e108e3da5e48a592f", "patch": "@@ -3,12 +3,10 @@\n use crate::{\n     cell::{Cell, UnsafeCell},\n     fmt,\n-    marker::PhantomData,\n     mem::{self, MaybeUninit},\n     ops::{Deref, Drop},\n     panic::{RefUnwindSafe, UnwindSafe},\n-    sync::atomic::{AtomicBool, AtomicUsize, Ordering},\n-    thread::{self, Thread},\n+    sync::Once,\n };\n \n #[doc(inline)]\n@@ -42,10 +40,7 @@ pub use core::lazy::*;\n /// ```\n #[unstable(feature = \"once_cell\", issue = \"68198\")]\n pub struct SyncOnceCell<T> {\n-    // This `state` word is actually an encoded version of just a pointer to a\n-    // `Waiter`, so we add the `PhantomData` appropriately.\n-    state_and_queue: AtomicUsize,\n-    _marker: PhantomData<*mut Waiter>,\n+    once: Once,\n     // Whether or not the value is initialized is tracked by `state_and_queue`.\n     value: UnsafeCell<MaybeUninit<T>>,\n }\n@@ -122,8 +117,7 @@ impl<T> SyncOnceCell<T> {\n     #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub const fn new() -> SyncOnceCell<T> {\n         SyncOnceCell {\n-            state_and_queue: AtomicUsize::new(INCOMPLETE),\n-            _marker: PhantomData,\n+            once: Once::new(),\n             value: UnsafeCell::new(MaybeUninit::uninit()),\n         }\n     }\n@@ -135,7 +129,7 @@ impl<T> SyncOnceCell<T> {\n     #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get(&self) -> Option<&T> {\n         if self.is_initialized() {\n-            // Safe b/c checked is_initialize\n+            // Safe b/c checked is_initialized\n             Some(unsafe { self.get_unchecked() })\n         } else {\n             None\n@@ -148,7 +142,7 @@ impl<T> SyncOnceCell<T> {\n     #[unstable(feature = \"once_cell\", issue = \"68198\")]\n     pub fn get_mut(&mut self) -> Option<&mut T> {\n         if self.is_initialized() {\n-            // Safe b/c checked is_initialize and we have a unique access\n+            // Safe b/c checked is_initialized and we have a unique access\n             Some(unsafe { self.get_unchecked_mut() })\n         } else {\n             None\n@@ -350,37 +344,32 @@ impl<T> SyncOnceCell<T> {\n         }\n     }\n \n-    /// Safety: synchronizes with store to value via Release/(Acquire|SeqCst).\n     #[inline]\n     fn is_initialized(&self) -> bool {\n-        // An `Acquire` load is enough because that makes all the initialization\n-        // operations visible to us, and, this being a fast path, weaker\n-        // ordering helps with performance. This `Acquire` synchronizes with\n-        // `SeqCst` operations on the slow path.\n-        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n+        self.once.is_completed()\n     }\n \n-    /// Safety: synchronizes with store to value via SeqCst read from state,\n-    /// writes value only once because we never get to INCOMPLETE state after a\n-    /// successful write.\n     #[cold]\n     fn initialize<F, E>(&self, f: F) -> Result<(), E>\n     where\n         F: FnOnce() -> Result<T, E>,\n     {\n-        let mut f = Some(f);\n         let mut res: Result<(), E> = Ok(());\n         let slot = &self.value;\n-        initialize_inner(&self.state_and_queue, &mut || {\n-            let f = f.take().unwrap();\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|p| {\n             match f() {\n                 Ok(value) => {\n                     unsafe { (&mut *slot.get()).write(value) };\n-                    true\n                 }\n                 Err(e) => {\n                     res = Err(e);\n-                    false\n+\n+                    // Treat the underlying `Once` as poisoned since we\n+                    // failed to initialize our value. Calls\n+                    p.poison();\n                 }\n             }\n         });\n@@ -407,106 +396,6 @@ impl<T> Drop for SyncOnceCell<T> {\n     }\n }\n \n-const INCOMPLETE: usize = 0x0;\n-const RUNNING: usize = 0x1;\n-const COMPLETE: usize = 0x2;\n-\n-const STATE_MASK: usize = 0x3;\n-\n-// The alignment here is so that we can stash the state in the lower\n-// bits of the `next` pointer\n-#[repr(align(4))]\n-struct Waiter {\n-    thread: Cell<Option<Thread>>,\n-    signaled: AtomicBool,\n-    next: *const Waiter,\n-}\n-\n-struct WaiterQueue<'a> {\n-    state_and_queue: &'a AtomicUsize,\n-    set_state_on_drop_to: usize,\n-}\n-\n-impl Drop for WaiterQueue<'_> {\n-    fn drop(&mut self) {\n-        let state_and_queue =\n-            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n-\n-        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n-\n-        unsafe {\n-            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n-            while !queue.is_null() {\n-                let next = (*queue).next;\n-                let thread = (*queue).thread.replace(None).unwrap();\n-                (*queue).signaled.store(true, Ordering::Release);\n-                queue = next;\n-                thread.unpark();\n-            }\n-        }\n-    }\n-}\n-\n-fn initialize_inner(my_state_and_queue: &AtomicUsize, init: &mut dyn FnMut() -> bool) -> bool {\n-    let mut state_and_queue = my_state_and_queue.load(Ordering::Acquire);\n-\n-    loop {\n-        match state_and_queue {\n-            COMPLETE => return true,\n-            INCOMPLETE => {\n-                let old = my_state_and_queue.compare_and_swap(\n-                    state_and_queue,\n-                    RUNNING,\n-                    Ordering::Acquire,\n-                );\n-                if old != state_and_queue {\n-                    state_and_queue = old;\n-                    continue;\n-                }\n-                let mut waiter_queue = WaiterQueue {\n-                    state_and_queue: my_state_and_queue,\n-                    set_state_on_drop_to: INCOMPLETE,\n-                };\n-                let success = init();\n-\n-                waiter_queue.set_state_on_drop_to = if success { COMPLETE } else { INCOMPLETE };\n-                return success;\n-            }\n-            _ => {\n-                assert!(state_and_queue & STATE_MASK == RUNNING);\n-                wait(&my_state_and_queue, state_and_queue);\n-                state_and_queue = my_state_and_queue.load(Ordering::Acquire);\n-            }\n-        }\n-    }\n-}\n-\n-fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n-    loop {\n-        if current_state & STATE_MASK != RUNNING {\n-            return;\n-        }\n-\n-        let node = Waiter {\n-            thread: Cell::new(Some(thread::current())),\n-            signaled: AtomicBool::new(false),\n-            next: (current_state & !STATE_MASK) as *const Waiter,\n-        };\n-        let me = &node as *const Waiter as usize;\n-\n-        let old = state_and_queue.compare_and_swap(current_state, me | RUNNING, Ordering::Release);\n-        if old != current_state {\n-            current_state = old;\n-            continue;\n-        }\n-\n-        while !node.signaled.load(Ordering::Acquire) {\n-            thread::park();\n-        }\n-        break;\n-    }\n-}\n-\n /// A value which is initialized on the first access.\n ///\n /// This type is a thread-safe `Lazy`, and can be used in statics.\n@@ -763,6 +652,7 @@ mod tests {\n \n         let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n         assert!(res.is_err());\n+        assert!(!cell.is_initialized());\n         assert!(cell.get().is_none());\n \n         assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));"}, {"sha": "1fce5dc03522489fc4b580a83e7d42f1fc9d6379", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1017940d77f35f841008c3e108e3da5e48a592f/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1017940d77f35f841008c3e108e3da5e48a592f/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=d1017940d77f35f841008c3e108e3da5e48a592f", "patch": "@@ -132,6 +132,7 @@ unsafe impl Send for Once {}\n #[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n+    set_state_on_drop_to: Cell<usize>,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -321,7 +322,7 @@ impl Once {\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| f.take().unwrap()(&OnceState { poisoned: p }));\n+        self.call_inner(true, &mut |p| f.take().unwrap()(p));\n     }\n \n     /// Returns `true` if some `call_once` call has completed\n@@ -385,7 +386,7 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n+    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n             match state_and_queue {\n@@ -413,8 +414,9 @@ impl Once {\n                     };\n                     // Run the initialization function, letting it know if we're\n                     // poisoned or not.\n-                    init(state_and_queue == POISONED);\n-                    waiter_queue.set_state_on_drop_to = COMPLETE;\n+                    let init_state = OnceState { poisoned: state_and_queue == POISONED, set_state_on_drop_to: Cell::new(COMPLETE) };\n+                    init(&init_state);\n+                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n                     break;\n                 }\n                 _ => {\n@@ -554,6 +556,14 @@ impl OnceState {\n     pub fn poisoned(&self) -> bool {\n         self.poisoned\n     }\n+\n+    /// Poison the associated [`Once`] without explicitly panicking.\n+    ///\n+    /// [`Once`]: struct.Once.html\n+    // NOTE: This is currently only exposed for the `lazy` module\n+    pub(crate) fn poison(&self) {\n+        self.set_state_on_drop_to.set(POISONED);\n+    }\n }\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]"}]}