{"sha": "26e067b058102e3dcfef461a3f45f403fd456bb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZTA2N2IwNTgxMDJlM2RjZmVmNDYxYTNmNDVmNDAzZmQ0NTZiYjg=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-05T21:35:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-05T21:35:29Z"}, "message": "Rollup merge of #41734 - nikomatsakis:incr-comp-refactor-variance, r=pnkfelix\n\nRefactor variance and remove last `[pub]` map\n\nThis PR refactors variance to work in a more red-green friendly way. Because red-green doesn't exist yet, it has to be a bit hacky. The basic idea is this:\n\n- We compute a big map with the variance for all items in the crate; when you request variances for a particular item, we read it from the crate\n- We now hard-code that traits are invariant (which they are, for deep reasons, not gonna' change)\n- When building constraints, we compute the transitive closure of all things within the crate that depend on what using `TransitiveRelation`\n    - this lets us gin up the correct dependencies when requesting variance of a single item\n\nAh damn, just remembered, one TODO:\n\n- [x] Update the variance README -- ah, I guess the README updates I did are sufficient\n\nr? @michaelwoerister", "tree": {"sha": "c9201a1edd4d92eb6fd8b0ca98b8bb0bf8dba03c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9201a1edd4d92eb6fd8b0ca98b8bb0bf8dba03c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e067b058102e3dcfef461a3f45f403fd456bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e067b058102e3dcfef461a3f45f403fd456bb8", "html_url": "https://github.com/rust-lang/rust/commit/26e067b058102e3dcfef461a3f45f403fd456bb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e067b058102e3dcfef461a3f45f403fd456bb8/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b2aacfdbe9569666d2d723bcde78ba3deef41a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2aacfdbe9569666d2d723bcde78ba3deef41a0", "html_url": "https://github.com/rust-lang/rust/commit/9b2aacfdbe9569666d2d723bcde78ba3deef41a0"}, {"sha": "3da5daf42587c9cece98a7b0985215cc40c31d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da5daf42587c9cece98a7b0985215cc40c31d58", "html_url": "https://github.com/rust-lang/rust/commit/3da5daf42587c9cece98a7b0985215cc40c31d58"}], "stats": {"total": 841, "additions": 472, "deletions": 369}, "files": [{"sha": "12e0d4d3ea26cf6907a7d608098d34b4abb543e0", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -81,6 +81,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TransCrateItem(D),\n     TransInlinedItem(D),\n     TransWriteMetadata,\n+    CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n     // table in the tcx (or elsewhere) maps to one of these\n@@ -89,6 +90,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    ItemVarianceConstraints(D),\n+    ItemVariances(D),\n     IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n@@ -180,6 +183,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            ItemVariances,\n             IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n@@ -201,6 +205,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             Coherence => Some(Coherence),\n+            CrateVariances => Some(CrateVariances),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n             PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n@@ -232,6 +237,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            ItemVariances(ref d) => op(d).map(ItemVariances),\n+            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n             IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))"}, {"sha": "809bed939f54ca4bcb78e102d33077f0ba4499f7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -18,7 +18,6 @@ mod raii;\n mod safe;\n mod shadow;\n mod thread;\n-mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n@@ -28,5 +27,4 @@ pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "bf3748659fe07f0e4f4e84e8bb7ccb7782a85eb0", "filename": "src/librustc/dep_graph/visit.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9b2aacfdbe9569666d2d723bcde78ba3deef41a0/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2aacfdbe9569666d2d723bcde78ba3deef41a0/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=9b2aacfdbe9569666d2d723bcde78ba3deef41a0", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir;\n-use hir::def_id::DefId;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use ty::TyCtxt;\n-\n-use super::dep_node::DepNode;\n-\n-/// Visit all the items in the krate in some order. When visiting a\n-/// particular item, first create a dep-node by calling `dep_node_fn`\n-/// and push that onto the dep-graph stack of tasks, and also create a\n-/// read edge from the corresponding AST node. This is used in\n-/// compiler passes to automatically record the item that they are\n-/// working on.\n-pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                     mut dep_node_fn: F,\n-                                                     visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-{\n-    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n-        dep_node_fn: &'visit mut F,\n-        visitor: &'visit mut V,\n-    }\n-\n-    impl<'visit, 'tcx, F, V> ItemLikeVisitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n-    {\n-        fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_trait_item(&mut self, i: &'tcx hir::TraitItem) {\n-            let trait_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(trait_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(trait_item_def_id));\n-            self.visitor.visit_trait_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-\n-        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n-            let impl_item_def_id = self.tcx.hir.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(impl_item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n-            self.visitor.visit_impl_item(i);\n-            debug!(\"Ended task {:?}\", task_id);\n-        }\n-    }\n-\n-    let krate = tcx.dep_graph.with_ignore(|| tcx.hir.krate());\n-    let mut tracking_visitor = TrackingVisitor {\n-        tcx: tcx,\n-        dep_node_fn: &mut dep_node_fn,\n-        visitor: visitor,\n-    };\n-    krate.visit_all_item_likes(&mut tracking_visitor)\n-}\n-"}, {"sha": "def6b2b3421f6f4135e0741b575506381f5a2e10", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -88,7 +88,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// that are inside of an item-like.\n     ///\n     /// **This is the most common choice.** A very commmon pattern is\n-    /// to use `tcx.visit_all_item_likes_in_krate()` as an outer loop,\n+    /// to use `visit_all_item_likes()` as an outer loop,\n     /// and to have the visitor that visits the contents of each item\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),"}, {"sha": "ce1a34faf5ee8a850df8e9ec91ce463009c1c9ad", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -19,9 +19,8 @@ use super::intravisit::Visitor;\n ///\n /// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n ///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.visit_all_item_likes_in_krate()`.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.hir.krate().visit_all_item_likes()`.\n ///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n-///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting\n ///    - Con: Don't have methods for specific bits of HIR, like \"on\n ///      every expr, do this\".\n@@ -30,7 +29,7 @@ use super::intravisit::Visitor;\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n ///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.visit_all_item_likes_in_krate(visitor.as_deep_visitor())`. Within\n+///      `tcx.hir.krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n ///      your `intravisit::Visitor` impl, implement methods like\n ///      `visit_expr()`; don't forget to invoke\n ///      `intravisit::walk_visit_expr()` to keep walking the subparts."}, {"sha": "74aac7b788b26263580a72d2043dcfb098bf090c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -470,9 +470,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// True if the variance has been computed yet; false otherwise.\n-    pub variance_computed: Cell<bool>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -744,7 +741,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n-            variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),"}, {"sha": "a737e7caa3e59dc7639d69b49ec702d2134530bc", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -266,6 +266,12 @@ impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\",\n@@ -549,18 +555,6 @@ macro_rules! define_map_struct {\n         }\n     };\n \n-    // Detect things with the `pub` modifier\n-    (tcx: $tcx:tt,\n-     input: (([pub $($other_modifiers:tt)*] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([pub] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n     // No modifiers left? This is a private item.\n     (tcx: $tcx:tt,\n      input: (([] $attrs:tt $name:tt) $($input:tt)*),\n@@ -687,9 +681,13 @@ define_maps! { <'tcx>\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n+    /// Get a map with the variance of every item; use `item_variance`\n+    /// instead.\n+    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n@@ -825,3 +823,7 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n     DepNode::MirKeys\n }\n+\n+fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::CrateVariances\n+}"}, {"sha": "a361c80a2529f34090920688e728b255a6ffb2da", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -15,7 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::{self, DepNode};\n+use dep_graph::DepNode;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -55,9 +55,9 @@ use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use hir;\n-use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{FnSig, PolyFnSig};\n@@ -309,6 +309,27 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n+/// The crate variances map is computed during typeck and contains the\n+/// variance of every item in the local crate. You should not use it\n+/// directly, because to do so will make your pass dependent on the\n+/// HIR of every item in the local crate. Instead, use\n+/// `tcx.variances_of()` to get the variance for a *particular*\n+/// item.\n+pub struct CrateVariancesMap {\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n+\n+    /// For each item with generics, maps to a vector of the variance\n+    /// of its generics.  If an item has no generics, it will have no\n+    /// entry.\n+    pub variances: FxHashMap<DefId, Rc<Vec<ty::Variance>>>,\n+\n+    /// An empty vector, useful for cloning.\n+    pub empty_variance: Rc<Vec<ty::Variance>>,\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n@@ -2543,14 +2564,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.node_extent(id)))\n     }\n \n-    pub fn visit_all_item_likes_in_krate<V,F>(self,\n-                                              dep_node_fn: F,\n-                                              visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'gcx>\n-    {\n-        dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "dfa11b9c71a04c6c038621d4dc63330310fa986b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -124,14 +124,8 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n            a_subst,\n            b_subst);\n \n-    let variances;\n-    let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = relation.tcx().variances_of(item_def_id);\n-        Some(&*variances)\n-    } else {\n-        None\n-    };\n-    relate_substs(relation, opt_variances, a_subst, b_subst)\n+    let opt_variances = relation.tcx().variances_of(item_def_id);\n+    relate_substs(relation, Some(&opt_variances), a_subst, b_subst)\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,"}, {"sha": "46463944043bd63c8d2c983246a919df159361c1", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -9,21 +9,23 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n-use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use fx::FxHashMap;\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem;\n \n \n-\n #[derive(Clone)]\n-pub struct TransitiveRelation<T: Debug + PartialEq> {\n-    // List of elements. This is used to map from a T to a usize.  We\n-    // expect domain to be small so just use a linear list versus a\n-    // hashmap or something.\n+pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n+    // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n+    // Maps each element to an index.\n+    map: FxHashMap<T, Index>,\n+\n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n@@ -40,19 +42,20 @@ pub struct TransitiveRelation<T: Debug + PartialEq> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n struct Edge {\n     source: Index,\n     target: Index,\n }\n \n-impl<T: Debug + PartialEq> TransitiveRelation<T> {\n+impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     pub fn new() -> TransitiveRelation<T> {\n         TransitiveRelation {\n             elements: vec![],\n+            map: FxHashMap(),\n             edges: vec![],\n             closure: RefCell::new(None),\n         }\n@@ -63,29 +66,35 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.elements.iter().position(|e| *e == *a).map(Index)\n+        self.map.get(a).cloned()\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        match self.index(&a) {\n-            Some(i) => i,\n-            None => {\n-                self.elements.push(a);\n-\n-                // if we changed the dimensions, clear the cache\n-                *self.closure.borrow_mut() = None;\n-\n-                Index(self.elements.len() - 1)\n-            }\n-        }\n+        let &mut TransitiveRelation {\n+            ref mut elements,\n+            ref closure,\n+            ref mut map,\n+            ..\n+        } = self;\n+\n+        map.entry(a.clone())\n+           .or_insert_with(|| {\n+               elements.push(a);\n+\n+               // if we changed the dimensions, clear the cache\n+               *closure.borrow_mut() = None;\n+\n+               Index(elements.len() - 1)\n+           })\n+           .clone()\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n     /// relation.  If `f` returns `None` for any end-point, returns\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n         where F: FnMut(&T) -> Option<U>,\n-              U: Debug + PartialEq,\n+              U: Clone + Debug + Eq + Hash + Clone,\n     {\n         let mut result = TransitiveRelation::new();\n         for edge in &self.edges {\n@@ -125,6 +134,20 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    /// Returns a vector of all things less than `a`.\n+    ///\n+    /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n+    /// I'm too lazy to make that work, and -- given the caching\n+    /// strategy -- it'd be a touch tricky anyhow.\n+    pub fn less_than(&self, a: &T) -> Vec<&T> {\n+        match self.index(a) {\n+            Some(a) => self.with_closure(|closure| {\n+                closure.iter(a.0).map(|i| &self.elements[i]).collect()\n+            }),\n+            None => vec![],\n+        }\n+    }\n+\n     /// Picks what I am referring to as the \"postdominating\"\n     /// upper-bound for `a` and `b`. This is usually the least upper\n     /// bound, but in cases where there is no single least upper\n@@ -335,7 +358,7 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n }\n \n impl<T> Encodable for TransitiveRelation<T>\n-    where T: Encodable + Debug + PartialEq\n+    where T: Clone + Encodable + Debug + Eq + Hash + Clone\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_struct(\"TransitiveRelation\", 2, |s| {\n@@ -347,19 +370,23 @@ impl<T> Encodable for TransitiveRelation<T>\n }\n \n impl<T> Decodable for TransitiveRelation<T>\n-    where T: Decodable + Debug + PartialEq\n+    where T: Clone + Decodable + Debug + Eq + Hash + Clone\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n+            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n             let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            Ok(TransitiveRelation { elements, edges, closure: RefCell::new(None) })\n+            let map = elements.iter()\n+                              .enumerate()\n+                              .map(|(index, elem)| (elem.clone(), Index(index)))\n+                              .collect();\n+            Ok(TransitiveRelation { elements, edges, map, closure: RefCell::new(None) })\n         })\n     }\n }\n \n impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-    where T: HashStable<CTX> + PartialEq + Debug\n+    where T: HashStable<CTX> + Eq + Debug + Clone + Hash\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,\n@@ -369,6 +396,8 @@ impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n+            // \"map\" is just a copy of elements vec\n+            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _\n         } = *self;"}, {"sha": "7905128bb6eca4266c734c38a9762e2628edcd3d", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -51,7 +51,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n use graphviz::IntoCow;\n use std::env;\n@@ -80,7 +80,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -166,17 +166,29 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n+        intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.process_attrs(trait_item.id, &trait_item.attrs);\n+        intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.process_attrs(impl_item.id, &impl_item.attrs);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.process_attrs(s.id, &s.attrs);\n+        intravisit::walk_struct_field(self, s);\n     }\n }\n "}, {"sha": "796cb8c4d651d08f02a107965013af44899af221", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -240,8 +240,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"EntryBuilder::encode_item_variances({:?})\", def_id);\n+    fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+        debug!(\"EntryBuilder::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n     }\n@@ -824,7 +824,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_item_variances(def_id),\n+                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {"}, {"sha": "c1456e7978280cce003fbe8e6f855a36600653f9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -293,6 +293,7 @@ pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n     coherence::provide(providers);\n     check::provide(providers);\n+    variance::provide(providers);\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -307,9 +308,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     })?;\n \n-    time(time_passes, \"variance inference\", ||\n-         variance::infer_variance(tcx));\n-\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n              impl_wf_check::impl_wf_check(tcx));\n@@ -320,6 +318,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n           coherence::check_coherence(tcx));\n     })?;\n \n+    tcx.sess.track_errors(|| {\n+        time(time_passes, \"variance testing\", ||\n+             variance::test::test_variance(tcx));\n+    })?;\n+\n     time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n \n     time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;"}, {"sha": "592916178897c8ab203ec2dd6f06f852f325e742", "filename": "src/librustc_typeck/variance/README.md", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -97,51 +97,29 @@ types involved before considering variance.\n \n #### Dependency graph management\n \n-Because variance works in two phases, if we are not careful, we wind\n-up with a muddled mess of a dep-graph. Basically, when gathering up\n-the constraints, things are fairly well-structured, but then we do a\n-fixed-point iteration and write the results back where they\n-belong. You can't give this fixed-point iteration a single task\n-because it reads from (and writes to) the variance of all types in the\n-crate. In principle, we *could* switch the \"current task\" in a very\n-fine-grained way while propagating constraints in the fixed-point\n-iteration and everything would be automatically tracked, but that\n-would add some overhead and isn't really necessary anyway.\n-\n-Instead what we do is to add edges into the dependency graph as we\n-construct the constraint set: so, if computing the constraints for\n-node `X` requires loading the inference variables from node `Y`, then\n-we can add an edge `Y -> X`, since the variance we ultimately infer\n-for `Y` will affect the variance we ultimately infer for `X`.\n-\n-At this point, we've basically mirrored the inference graph in the\n-dependency graph. This means we can just completely ignore the\n-fixed-point iteration, since it is just shuffling values along this\n-graph. In other words, if we added the fine-grained switching of tasks\n-I described earlier, all it would show is that we repeatedly read the\n-values described by the constraints, but those edges were already\n-added when building the constraints in the first place.\n-\n-Here is how this is implemented (at least as of the time of this\n-writing). The associated `DepNode` for the variance map is (at least\n-presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n-when we visit an item to load up its constraints, we set\n-`Signature(DefId)` as the current task (the \"memoization\" pattern\n-described in the `dep-graph` README). Then whenever we find an\n-embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n-which covers the variances we will compute for all of its\n-parameters. This read is synthetic (i.e., we call\n-`variance_map.read()`) because, in fact, the final variance is not yet\n-computed -- the read *will* occur (repeatedly) during the fixed-point\n-iteration phase.\n-\n-In fact, we don't really *need* this synthetic read. That's because we\n-do wind up looking up the `TypeScheme` or `TraitDef` for all\n-references types/traits, and those reads add an edge from\n-`Signature(DefId)` (that is, they share the same dep node as\n-variance). However, I've kept the synthetic reads in place anyway,\n-just for future-proofing (in case we change the dep-nodes in the\n-future), and because it makes the intention a bit clearer I think.\n+Because variance is a whole-crate inference, its dependency graph\n+can become quite muddled if we are not careful. To resolve this, we refactor\n+into two queries:\n+\n+- `crate_variances` computes the variance for all items in the current crate.\n+- `variances_of` accesses the variance for an individual reading; it\n+  works by requesting `crate_variances` and extracting the relevant data.\n+  \n+If you limit yourself to reading `variances_of`, your code will only\n+depend then on the inference inferred for that particular item.\n+\n+Eventually, the goal is to rely on the red-green dependency management\n+algorithm. At the moment, however, we rely instead on a hack, where\n+`variances_of` ignores the dependencies of accessing\n+`crate_variances` and instead computes the *correct* dependencies\n+itself. To this end, when we build up the constraints in the system,\n+we also built up a transitive `dependencies` relation as part of the\n+crate map. A `(X, Y)` pair is added to the map each time we have a\n+constraint that the variance of some inferred for the item `X` depends\n+on the variance of some element of `Y`. This is to some extent a\n+mirroring of the inference graph in the dependency graph. This means\n+we can just completely ignore the fixed-point iteration, since it is\n+just shuffling values along this graph.\n \n ### Addendum: Variance on traits\n "}, {"sha": "e986a381cd963df034968e27a66fa463c2a5c2e6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 149, "deletions": 95, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -15,19 +15,20 @@\n \n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -38,6 +39,11 @@ pub struct ConstraintContext<'a, 'tcx: 'a> {\n     bivariant: VarianceTermPtr<'a>,\n \n     pub constraints: Vec<Constraint<'a>>,\n+\n+    /// This relation tracks the dependencies between the variance of\n+    /// various items. In particular, if `a < b`, then the variance of\n+    /// `a` depends on the sources of `b`.\n+    pub dependencies: TransitiveRelation<DefId>,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -48,6 +54,20 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n+/// To build constriants, we visit one item (type, trait) at a time\n+/// and look at its contents. So e.g. if we have\n+///\n+///     struct Foo<T> {\n+///         b: Bar<T>\n+///     }\n+///\n+/// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n+/// the def-id and generics of `Foo`.\n+pub struct CurrentItem<'a> {\n+    def_id: DefId,\n+    generics: &'a ty::Generics,\n+}\n+\n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n                                             -> ConstraintContext<'a, 'tcx> {\n     let tcx = terms_cx.tcx;\n@@ -62,50 +82,93 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n         invariant: invariant,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n+        dependencies: TransitiveRelation::new(),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut constraint_cx);\n \n     constraint_cx\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n-        let did = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(item.id);\n+\n+        // Encapsulate constructing the constraints into a task we can\n+        // reference later. This can go away once the red-green\n+        // algorithm is in place.\n+        //\n+        // See README.md for a detailed discussion\n+        // on dep-graph management.\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n+                tcx.dep_graph.with_task(DepNode::ItemVarianceConstraints(def_id),\n+                                        AssertDepGraphSafe(self),\n+                                        def_id,\n+                                        visit_item_task);\n+            }\n+            _ => {\n+                // Nothing to do here, skip the task.\n+            }\n+        }\n+\n+        fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n+                                     def_id: DefId)\n+        {\n+            ccx.0.build_constraints_for_item(def_id);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(hir_map::NodeLifetime(..)) => true,\n+        _ => false,\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.terms_cx.tcx\n+    }\n \n+    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+        let tcx = self.tcx();\n+        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+        let item = tcx.hir.expect_item(id);\n         debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(did);\n+                let generics = tcx.generics_of(def_id);\n+                let current_item = &CurrentItem { def_id, generics };\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(generics,\n+                for field in tcx.adt_def(def_id).all_fields() {\n+                    self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n-                let generics = tcx.generics_of(did);\n-                let trait_ref = ty::TraitRef {\n-                    def_id: did,\n-                    substs: Substs::identity_for_item(tcx, did)\n-                };\n-                self.add_constraints_from_trait_ref(generics,\n-                                                    trait_ref,\n-                                                    self.invariant);\n-            }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemStatic(..) |\n@@ -116,38 +179,25 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemGlobalAsm(..) |\n             hir::ItemTy(..) |\n             hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {}\n+            hir::ItemDefaultImpl(..) => {\n+                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.terms_cx.tcx\n+    /// Load the generics for another item, adding a corresponding\n+    /// relation into the dependencies to indicate that the variance\n+    /// for `current` relies on `def_id`.\n+    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n+        let generics = self.tcx().generics_of(def_id);\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+        generics\n     }\n \n-    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.get(&param_id) {\n-            Some(&index) => index,\n-            None => {\n-                bug!(\"no inferred index entry for {}\",\n-                     self.tcx().hir.node_to_string(param_id));\n-            }\n-        }\n+    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n+        self.terms_cx.inferred_map.get(&param_id)\n     }\n \n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n@@ -228,8 +278,27 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_node_id);\n-            self.terms_cx.inferred_infos[index].term\n+            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n+                self.terms_cx.inferred_infos[index].term\n+            } else {\n+                // If there is no inferred entry for a type parameter,\n+                // it must be declared on a (locally defiend) trait -- they don't\n+                // get inferreds because they are always invariant.\n+                if cfg!(debug_assertions) {\n+                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n+                    let item = self.tcx().hir.expect_item(item_node_id);\n+                    let success = match item.node {\n+                        hir::ItemTrait(..) => true,\n+                        _ => false,\n+                    };\n+                    if !success {\n+                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n+                             item_def_id,\n+                             item);\n+                    }\n+                }\n+                self.invariant\n+            }\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -279,7 +348,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics,\n+                                      current: &CurrentItem,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n@@ -288,12 +357,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-        // This edge is actually implied by the call to\n-        // `trait_def`, but I'm trying to be future-proof. See\n-        // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-        self.add_constraints_from_substs(generics,\n+        self.add_constraints_from_substs(current,\n                                          trait_ref.def_id,\n                                          &trait_generics.types,\n                                          &trait_generics.regions,\n@@ -305,7 +369,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n@@ -325,34 +389,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, region, contra);\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyArray(typ, _) |\n             ty::TySlice(typ) => {\n-                self.add_constraints_from_ty(generics, typ, variance);\n+                self.add_constraints_from_ty(current, typ, variance);\n             }\n \n             ty::TyRawPtr(ref mt) => {\n-                self.add_constraints_from_mt(generics, mt, variance);\n+                self.add_constraints_from_mt(current, mt, variance);\n             }\n \n             ty::TyTuple(subtys, _) => {\n                 for &subty in subtys {\n-                    self.add_constraints_from_ty(generics, subty, variance);\n+                    self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.tcx().generics_of(def.did);\n+                let adt_generics = self.read_generics(current, def.did);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  def.did,\n                                                  &adt_generics.types,\n                                                  &adt_generics.regions,\n@@ -364,12 +423,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let trait_ref = &data.trait_ref;\n                 let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n-                // This edge is actually implied by the call to\n-                // `trait_def`, but I'm trying to be future-proof. See\n-                // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n-\n-                self.add_constraints_from_substs(generics,\n+                self.add_constraints_from_substs(current,\n                                                  trait_ref.def_id,\n                                                  &trait_generics.types,\n                                                  &trait_generics.regions,\n@@ -380,25 +434,25 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, r, contra);\n+                self.add_constraints_from_region(current, r, contra);\n \n                 if let Some(p) = data.principal() {\n                     let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                    self.add_constraints_from_trait_ref(current, poly_trait_ref.0, variance);\n                 }\n \n                 for projection in data.projection_bounds() {\n-                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                    self.add_constraints_from_ty(current, projection.0.ty, self.invariant);\n                 }\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(generics.parent, None);\n+                assert_eq!(current.generics.parent, None);\n                 let mut i = data.idx as usize;\n-                if !generics.has_self || i > 0 {\n-                    i -= generics.regions.len();\n+                if !current.generics.has_self || i > 0 {\n+                    i -= current.generics.regions.len();\n                 }\n-                let def_id = generics.types[i].def_id;\n+                let def_id = current.generics.types[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -414,7 +468,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyFnDef(.., sig) |\n             ty::TyFnPtr(sig) => {\n-                self.add_constraints_from_sig(generics, sig, variance);\n+                self.add_constraints_from_sig(current, sig, variance);\n             }\n \n             ty::TyError => {\n@@ -433,7 +487,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef],\n                                    region_param_defs: &[ty::RegionParameterDef],\n@@ -451,44 +505,44 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n+            self.add_constraints_from_ty(current, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n             let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(generics, substs_r, variance_i);\n+            self.add_constraints_from_region(current, substs_r, variance_i);\n         }\n     }\n \n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics,\n+                                current: &CurrentItem,\n                                 sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs() {\n-            self.add_constraints_from_ty(generics, input, contra);\n+            self.add_constraints_from_ty(current, input, contra);\n         }\n-        self.add_constraints_from_ty(generics, sig.0.output(), variance);\n+        self.add_constraints_from_ty(current, sig.0.output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics,\n+                                   current: &CurrentItem,\n                                    region: ty::Region<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(generics.parent, None);\n-                let i = data.index as usize - generics.has_self as usize;\n-                let def_id = generics.regions[i].def_id;\n+                assert_eq!(current.generics.parent, None);\n+                let i = data.index as usize - current.generics.has_self as usize;\n+                let def_id = current.generics.regions[i].def_id;\n                 let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n-                    let index = self.inferred_index(node_id);\n+                    let &index = self.opt_inferred_index(node_id).unwrap();\n                     self.add_constraint(index, variance);\n                 }\n             }\n@@ -518,17 +572,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics,\n+                               current: &CurrentItem,\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             hir::MutMutable => {\n                 let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(generics, mt.ty, invar);\n+                self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n             hir::MutImmutable => {\n-                self.add_constraints_from_ty(generics, mt.ty, variance);\n+                self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }\n     }"}, {"sha": "1afe2725ac87d6fabbebe93b5c58a73b5d17b344", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -12,7 +12,12 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::ty::TyCtxt;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc::ty::maps::Providers;\n+use std::rc::Rc;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -24,13 +29,67 @@ mod constraints;\n /// Code to solve constraints and write out the results.\n mod solve;\n \n+/// Code to write unit tests of variance.\n+pub mod test;\n+\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        variances_of,\n+        crate_variances,\n+        ..*providers\n+    };\n+}\n+\n+fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+                             -> Rc<CrateVariancesMap> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n-    solve::solve_constraints(constraints_cx);\n-    tcx.variance_computed.set(true);\n+    Rc::new(solve::solve_constraints(constraints_cx))\n+}\n+\n+fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+                            -> Rc<Vec<ty::Variance>> {\n+    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let item = tcx.hir.expect_item(item_id);\n+    match item.node {\n+        hir::ItemTrait(..) => {\n+            // Traits are always invariant.\n+            let generics = tcx.generics_of(item_def_id);\n+            assert!(generics.parent.is_none());\n+            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n+        }\n+\n+        hir::ItemEnum(..) |\n+        hir::ItemStruct(..) |\n+        hir::ItemUnion(..) => {\n+            // Everything else must be inferred.\n+\n+            // Lacking red/green, we read the variances for all items here\n+            // but ignore the dependencies, then re-synthesize the ones we need.\n+            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+            tcx.dep_graph.read(DepNode::ItemVarianceConstraints(item_def_id));\n+            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+                if dep_def_id.is_local() {\n+                    tcx.dep_graph.read(DepNode::ItemVarianceConstraints(dep_def_id));\n+                } else {\n+                    tcx.dep_graph.read(DepNode::ItemVariances(dep_def_id));\n+                }\n+            }\n+\n+            crate_map.variances.get(&item_def_id)\n+                               .unwrap_or(&crate_map.empty_variance)\n+                               .clone()\n+        }\n+\n+        _ => {\n+            // Variance not relevant.\n+            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+        }\n+    }\n }\n+"}, {"sha": "af8ad491ec00e7075ba0a5c3e2a56922bdb30ef5", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -15,7 +15,9 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n \n use super::constraints::*;\n@@ -31,8 +33,8 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n+pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+    let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n     let solutions = terms_cx.inferred_infos\n         .iter()\n@@ -45,7 +47,10 @@ pub fn solve_constraints(constraints_cx: ConstraintContext) {\n         solutions: solutions,\n     };\n     solutions_cx.solve();\n-    solutions_cx.write();\n+    let variances = solutions_cx.create_map();\n+    let empty_variance = Rc::new(Vec::new());\n+\n+    ty::CrateVariancesMap { dependencies, variances, empty_variance }\n }\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n@@ -83,7 +88,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write(&self) {\n+    fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n         // Collect all the variances for a particular item and stick\n         // them into the variance map. We rely on the fact that we\n         // generate all the inferreds for a particular item\n@@ -95,11 +100,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let tcx = self.terms_cx.tcx;\n \n-        // Ignore the writes here because the relevant edges were\n-        // already accounted for in `constraints.rs`. See the section\n-        // on dependency graph management in README.md for more\n-        // information.\n-        let _ignore = tcx.dep_graph.in_ignore();\n+        let mut map = FxHashMap();\n \n         let solutions = &self.solutions;\n         let inferred_infos = &self.terms_cx.inferred_infos;\n@@ -127,19 +128,10 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n             let item_def_id = tcx.hir.local_def_id(item_id);\n \n-            // For unit testing: check for a special \"rustc_variance\"\n-            // attribute and report an error with various results if found.\n-            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n-                span_err!(tcx.sess,\n-                          tcx.hir.span(item_id),\n-                          E0208,\n-                          \"{:?}\",\n-                          item_variances);\n-            }\n-\n-            tcx.maps.variances_of.borrow_mut()\n-               .insert(item_def_id, Rc::new(item_variances));\n+            map.insert(item_def_id, Rc::new(item_variances));\n         }\n+\n+        map\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "ad787c57e76f2a60ee49739eef874e17c4ae5665", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -32,8 +32,6 @@ use self::VarianceTerm::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n-use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n-\n #[derive(Copy, Clone, Debug)]\n pub struct InferredIndex(pub usize);\n \n@@ -109,7 +107,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);\n+    tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx\n }\n@@ -139,7 +137,6 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self,\n                               item_id: ast::NodeId,\n-                              has_self: bool,\n                               generics: &hir::Generics) {\n         //! Add \"inferreds\" for the generic parameters declared on this\n         //! item. This has a lot of annoying parameters because we are\n@@ -149,38 +146,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         //!\n \n         // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-\n-        let inferreds_on_entry = self.num_inferred();\n-\n-        if has_self {\n-            self.add_inferred(item_id, 0, item_id);\n-        }\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-        for (i, p) in generics.lifetimes.iter().enumerate() {\n+        for (p, i) in generics.lifetimes.iter().zip(0..) {\n             let id = p.lifetime.id;\n-            let i = has_self as usize + i;\n             self.add_inferred(item_id, i, id);\n         }\n \n-        for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + generics.lifetimes.len() + i;\n+        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n             self.add_inferred(item_id, i, p.id);\n         }\n-\n-        // If this item has no type or lifetime parameters,\n-        // then there are no variances to infer, so just\n-        // insert an empty entry into the variance map.\n-        // Arguably we could just leave the map empty in this\n-        // case but it seems cleaner to be able to distinguish\n-        // \"invalid item id\" from \"item id with no\n-        // parameters\".\n-        if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx.maps.variances_of.borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone());\n-        }\n     }\n \n     fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n@@ -232,15 +208,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, false, generics);\n-            }\n-            hir::ItemTrait(_, ref generics, ..) => {\n-                // Note: all inputs for traits are ultimately\n-                // constrained to be invariant. See `visit_item` in\n-                // the impl for `ConstraintContext` in `constraints.rs`.\n-                self.add_inferreds_for_item(item.id, true, generics);\n+                self.add_inferreds_for_item(item.id, generics);\n             }\n \n+            hir::ItemTrait(..) |\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) |\n             hir::ItemDefaultImpl(..) |"}, {"sha": "1acadb7e772365efc7b1cfd7c380dcc202b6e48e", "filename": "src/librustc_typeck/variance/test.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ty::TyCtxt;\n+\n+pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.hir.krate().visit_all_item_likes(&mut VarianceTest { tcx });\n+}\n+\n+struct VarianceTest<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+\n+        // For unit testing: check for a special \"rustc_variance\"\n+        // attribute and report an error with various results if found.\n+        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+            let variances_of = self.tcx.variances_of(item_def_id);\n+            span_err!(self.tcx.sess,\n+                      item.span,\n+                      E0208,\n+                      \"{:?}\",\n+                      variances_of);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+}"}, {"sha": "3f568194e23d8071fc9bd67c7fe05d1f2120d02f", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -58,13 +58,15 @@ mod signatures {\n         fn method(&self, x: u32) { }\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     struct WillChanges {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         x: WillChange,\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n         y: WillChange\n     }\n \n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    // The fields change, not the type itself.\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n     fn indirect(x: WillChanges) { }\n }\n "}, {"sha": "56636a00a313a26afb911c4cce8f3a32d517d709", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -23,15 +23,21 @@ fn main() { }\n #[rustc_if_this_changed]\n type TypeAlias = u32;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+// The type alias directly affects the type of the field,\n+// not the enclosing struct:\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n struct Struct {\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     x: TypeAlias,\n     y: u32\n }\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n enum Enum {\n-    Variant1(TypeAlias),\n+    Variant1 {\n+        #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+        t: TypeAlias\n+    },\n     Variant2(i32)\n }\n "}, {"sha": "9b621a13fc484b7200b44c96a81294ab127664bd", "filename": "src/test/compile-fail/dep-graph-variance-alias.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-variance-alias.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that changing what a `type` points to does not go unnoticed\n+// by the variance analysis.\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+struct Foo<T> {\n+    f: T\n+}\n+\n+#[rustc_if_this_changed]\n+type TypeAlias<T> = Foo<T>;\n+\n+#[rustc_then_this_would_need(ItemVariances)] //~ ERROR OK\n+struct Use<T> {\n+    x: TypeAlias<T>\n+}"}, {"sha": "cd047cc580f8720b2c0df3c0873a5f7c74c7fcf1", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -60,7 +60,6 @@ struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n \n #[rustc_variance]\n struct Test7<'a> { //~ ERROR [*]\n-    //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n "}, {"sha": "60d4d73fe88b8845e08405d77869515eedf44c73", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -16,27 +16,23 @@\n \n #[rustc_variance]\n enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n-    //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n-    //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n-    //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n "}, {"sha": "58fb785c48ca7b24a70c92e2cd5c9e897b6c9230", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e067b058102e3dcfef461a3f45f403fd456bb8/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=26e067b058102e3dcfef461a3f45f403fd456bb8", "patch": "@@ -30,8 +30,7 @@ struct TestStruct<U,T:Setter<U>> { //~ ERROR [+, +]\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n+enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n@@ -51,13 +50,11 @@ trait TestTrait3<U> { //~ ERROR [o, o]\n \n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR [*, +]\n-    //~^ ERROR parameter `U` is never used\n     t: T\n }\n "}]}