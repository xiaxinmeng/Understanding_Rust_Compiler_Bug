{"sha": "4a58b14db5ed21654e952f051af2a6c51dfb15fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNThiMTRkYjVlZDIxNjU0ZTk1MmYwNTFhZjJhNmM1MWRmYjE1ZmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-24T21:45:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-24T21:45:20Z"}, "message": "Rollup merge of #64443 - Mark-Simulacrum:rustdoc-clean-1, r=GuillaumeGomez\n\nrustdoc: general cleanup\n\nReview should be conducted commit-by-commit.\n\nThere are some general cleanup commits in the end, which are somewhat related but can be easily split into another PR, so just let me know.", "tree": {"sha": "f6e3cbb104105066fd30a1291a2eed77e738da12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6e3cbb104105066fd30a1291a2eed77e738da12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a58b14db5ed21654e952f051af2a6c51dfb15fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdio5wCRBK7hj4Ov3rIwAAdHIIAGOpL73somHPVcGUjP4ktx5S\nLvRhc2a4UU6LlNT54bG1D5RIJLd506c4YTI2y/P1k79rSHOgGcsmSuuQ1DfCCiiG\n33YJWlM7Of51Dyrh70GS6xl2dLcirCQR5A1KT93ywsWd/kc49FveYKcFQJwmjUBu\nmJ7cpF+UU3T+YRh1M8Fa60Mb+eI+EXljOuPlTo6I8VTS9j0Y8mudXZl1TVy/rtLD\nfF2GlZAppCM15h5mSF++9wOhjqWumh4ayXEobcaaxmFZZskqHxAbvk1QbnP5yVOB\n5r7BoAVeibgp+nNVggcMrA5d82DrB+WvduaVEIoXYC4D1DspMLJeRgHqsroAcfc=\n=yV7c\n-----END PGP SIGNATURE-----\n", "payload": "tree f6e3cbb104105066fd30a1291a2eed77e738da12\nparent e74d953bdc062d739ad06b36bcbc3228b01913f1\nparent 059163fad796e3ecf04c29f423b9cf985717f025\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569361520 +0200\ncommitter GitHub <noreply@github.com> 1569361520 +0200\n\nRollup merge of #64443 - Mark-Simulacrum:rustdoc-clean-1, r=GuillaumeGomez\n\nrustdoc: general cleanup\n\nReview should be conducted commit-by-commit.\n\nThere are some general cleanup commits in the end, which are somewhat related but can be easily split into another PR, so just let me know.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a58b14db5ed21654e952f051af2a6c51dfb15fd", "html_url": "https://github.com/rust-lang/rust/commit/4a58b14db5ed21654e952f051af2a6c51dfb15fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a58b14db5ed21654e952f051af2a6c51dfb15fd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e74d953bdc062d739ad06b36bcbc3228b01913f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e74d953bdc062d739ad06b36bcbc3228b01913f1", "html_url": "https://github.com/rust-lang/rust/commit/e74d953bdc062d739ad06b36bcbc3228b01913f1"}, {"sha": "059163fad796e3ecf04c29f423b9cf985717f025", "url": "https://api.github.com/repos/rust-lang/rust/commits/059163fad796e3ecf04c29f423b9cf985717f025", "html_url": "https://github.com/rust-lang/rust/commit/059163fad796e3ecf04c29f423b9cf985717f025"}], "stats": {"total": 2930, "additions": 1480, "deletions": 1450}, "files": [{"sha": "18a84cd0eeb76fe24c0b7eaee03f1b53324c0b83", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n-                visibility: None,\n+                visibility: Inherited,\n                 def_id: self.cx.next_def_id(param_env_def_id.krate),\n                 stability: None,\n                 deprecation: None,"}, {"sha": "4cd1cc1a1cf50bd265a841927e22302a3e1fa8fd", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     source: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n                     name: None,\n                     attrs: Default::default(),\n-                    visibility: None,\n+                    visibility: Inherited,\n                     def_id: self.cx.next_def_id(impl_def_id.krate),\n                     stability: None,\n                     deprecation: None,"}, {"sha": "031e77ff1dbe0d1da41b7a9a4ec55efd36b6ee7a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -131,7 +131,7 @@ pub fn try_inline(\n         name: Some(name.clean(cx)),\n         attrs,\n         inner,\n-        visibility: Some(clean::Public),\n+        visibility: clean::Public,\n         stability: cx.tcx.lookup_stability(did).clean(cx),\n         deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n@@ -418,7 +418,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n         source: tcx.def_span(did).clean(cx),\n         name: None,\n         attrs,\n-        visibility: Some(clean::Inherited),\n+        visibility: clean::Inherited,\n         stability: tcx.lookup_stability(did).clean(cx),\n         deprecation: tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,"}, {"sha": "197c09ba759e7d2cc9d9a91f33bb1d1b12e9f5a6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -187,7 +187,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n                 source: Span::empty(),\n                 name: Some(prim.to_url_str().to_string()),\n                 attrs: attrs.clone(),\n-                visibility: Some(Public),\n+                visibility: Public,\n                 stability: get_stability(cx, def_id),\n                 deprecation: get_deprecation(cx, def_id),\n                 def_id,\n@@ -199,7 +199,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n                 source: Span::empty(),\n                 name: Some(kw.clone()),\n                 attrs: attrs,\n-                visibility: Some(Public),\n+                visibility: Public,\n                 stability: get_stability(cx, def_id),\n                 deprecation: get_deprecation(cx, def_id),\n                 def_id,\n@@ -361,7 +361,7 @@ pub struct Item {\n     pub name: Option<String>,\n     pub attrs: Attributes,\n     pub inner: ItemEnum,\n-    pub visibility: Option<Visibility>,\n+    pub visibility: Visibility,\n     pub def_id: DefId,\n     pub stability: Option<Stability>,\n     pub deprecation: Option<Deprecation>,\n@@ -1849,7 +1849,7 @@ fn get_real_types(\n     cx: &DocContext<'_>,\n     recurse: i32,\n ) -> FxHashSet<Type> {\n-    let arg_s = arg.to_string();\n+    let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n         return res;\n@@ -2311,7 +2311,7 @@ impl Clean<Item> for hir::TraitItem {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: local_did,\n-            visibility: None,\n+            visibility: Visibility::Inherited,\n             stability: get_stability(cx, local_did),\n             deprecation: get_deprecation(cx, local_did),\n             inner,\n@@ -2496,7 +2496,7 @@ impl Clean<Item> for ty::AssocItem {\n \n         let visibility = match self.container {\n             ty::ImplContainer(_) => self.vis.clean(cx),\n-            ty::TraitContainer(_) => None,\n+            ty::TraitContainer(_) => Inherited,\n         };\n \n         Item {\n@@ -3293,9 +3293,9 @@ pub enum Visibility {\n     Restricted(DefId, Path),\n }\n \n-impl Clean<Option<Visibility>> for hir::Visibility {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<Visibility> {\n-        Some(match self.node {\n+impl Clean<Visibility> for hir::Visibility {\n+    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+        match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n             hir::VisibilityKind::Crate(_) => Visibility::Crate,\n@@ -3304,13 +3304,13 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n                 let did = register_res(cx, path.res);\n                 Visibility::Restricted(did, path)\n             }\n-        })\n+        }\n     }\n }\n \n-impl Clean<Option<Visibility>> for ty::Visibility {\n-    fn clean(&self, _: &DocContext<'_>) -> Option<Visibility> {\n-        Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n+impl Clean<Visibility> for ty::Visibility {\n+    fn clean(&self, _: &DocContext<'_>) -> Visibility {\n+        if *self == ty::Visibility::Public { Public } else { Inherited }\n     }\n }\n \n@@ -3427,7 +3427,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: None,\n+            visibility: Inherited,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),\n@@ -3470,7 +3470,7 @@ impl Clean<Item> for ty::VariantDef {\n             name: Some(self.ident.clean(cx)),\n             attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n-            visibility: Some(Inherited),\n+            visibility: Inherited,\n             def_id: self.def_id,\n             inner: VariantItem(Variant { kind }),\n             stability: get_stability(cx, self.def_id),\n@@ -3573,16 +3573,6 @@ pub enum GenericArg {\n     Const(Constant),\n }\n \n-impl fmt::Display for GenericArg {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            GenericArg::Lifetime(lt) => lt.fmt(f),\n-            GenericArg::Type(ty) => ty.fmt(f),\n-            GenericArg::Const(ct) => ct.fmt(f),\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n@@ -4274,7 +4264,7 @@ fn resolve_type(cx: &DocContext<'_>,\n             return Generic(kw::SelfUpper.to_string());\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path));\n+            return Generic(format!(\"{:#}\", path.print()));\n         }\n         Res::SelfTy(..)\n         | Res::Def(DefKind::TyParam, _)\n@@ -4343,7 +4333,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: Some(Public),\n+            visibility: Public,\n             stability: cx.stability(self.hid).clean(cx),\n             deprecation: cx.deprecation(self.hid).clean(cx),\n             def_id: self.def_id,\n@@ -4371,7 +4361,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: Some(Public),\n+            visibility: Public,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),"}, {"sha": "fafd43cb60b69a4cb72a6e83ef8e1a71ba348746", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 495, "deletions": 469, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -99,10 +99,6 @@ impl Buffer {\n         self.into_inner()\n     }\n \n-    crate fn with_formatter<T: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result>(&mut self, t: T) {\n-        self.from_display(display_fn(move |f| (t)(f)));\n-    }\n-\n     crate fn from_display<T: std::fmt::Display>(&mut self, t: T) {\n         if self.for_html {\n             write!(self, \"{}\", t);\n@@ -112,30 +108,6 @@ impl Buffer {\n     }\n }\n \n-/// Helper to render an optional visibility with a space after it (if the\n-/// visibility is preset)\n-#[derive(Copy, Clone)]\n-pub struct VisSpace<'a>(pub &'a Option<clean::Visibility>);\n-/// Similarly to VisSpace, this structure is used to render a function style with a\n-/// space after it.\n-#[derive(Copy, Clone)]\n-pub struct UnsafetySpace(pub hir::Unsafety);\n-/// Similarly to VisSpace, this structure is used to render a function constness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct ConstnessSpace(pub hir::Constness);\n-/// Similarly to VisSpace, this structure is used to render a function asyncness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct AsyncSpace(pub hir::IsAsync);\n-/// Similar to VisSpace, but used for mutability\n-#[derive(Copy, Clone)]\n-pub struct MutableSpace(pub clean::Mutability);\n-/// Wrapper struct for emitting type parameter bounds.\n-pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n-pub struct AbiSpace(pub Abi);\n-pub struct DefaultSpace(pub bool);\n-\n /// Wrapper struct for properly emitting a function or method declaration.\n pub struct Function<'a> {\n     /// The declaration to emit.\n@@ -161,102 +133,89 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-impl<'a> VisSpace<'a> {\n-    pub fn get(self) -> &'a Option<clean::Visibility> {\n-        let VisSpace(v) = self; v\n-    }\n-}\n-\n-impl UnsafetySpace {\n-    pub fn get(&self) -> hir::Unsafety {\n-        let UnsafetySpace(v) = *self; v\n-    }\n-}\n-\n-impl ConstnessSpace {\n-    pub fn get(&self) -> hir::Constness {\n-        let ConstnessSpace(v) = *self; v\n-    }\n-}\n-\n-fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+fn comma_sep<T: fmt::Display>(items: impl Iterator<Item=T>) -> impl fmt::Display {\n     display_fn(move |f| {\n-        for (i, item) in items.iter().enumerate() {\n+        for (i, item) in items.enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n-            fmt::Display::fmt(item, f)?;\n+            fmt::Display::fmt(&item, f)?;\n         }\n         Ok(())\n     })\n }\n \n-impl<'a> fmt::Display for GenericBounds<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_generic_bounds(bounds: &[clean::GenericBound]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n-        let &GenericBounds(bounds) = self;\n \n-        for (i, bound) in bounds.iter().filter(|b| bounds_dup.insert(b.to_string())).enumerate() {\n+        for (i, bound) in bounds.iter().filter(|b| {\n+            bounds_dup.insert(b.print().to_string())\n+        }).enumerate() {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(bound, f)?;\n+            fmt::Display::fmt(&bound.print(), f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n-impl fmt::Display for clean::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n-            clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n-                f.write_str(&self.name)?;\n+impl clean::GenericParamDef {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.kind {\n+                clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n+                clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n+                    f.write_str(&self.name)?;\n \n-                if !bounds.is_empty() {\n-                    if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n-                    } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n+                    }\n+\n+                    if let Some(ref ty) = default {\n+                        if f.alternate() {\n+                            write!(f, \" = {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \"&nbsp;=&nbsp;{}\", ty.print())?;\n+                        }\n                     }\n+\n+                    Ok(())\n                 }\n+                clean::GenericParamDefKind::Const { ref ty, .. } => {\n+                    f.write_str(\"const \")?;\n+                    f.write_str(&self.name)?;\n \n-                if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty)?;\n+                        write!(f, \": {:#}\", ty.print())\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                        write!(f, \":&nbsp;{}\", ty.print())\n                     }\n                 }\n-\n-                Ok(())\n             }\n-            clean::GenericParamDefKind::Const { ref ty, .. } => {\n-                f.write_str(\"const \")?;\n-                f.write_str(&self.name)?;\n-\n-                if f.alternate() {\n-                    write!(f, \": {:#}\", ty)\n-                } else {\n-                    write!(f, \":&nbsp;{}\", ty)\n-                }\n-            }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Generics {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let real_params = self.params\n-            .iter()\n-            .filter(|p| !p.is_synthetic_type_param())\n-            .collect::<Vec<_>>();\n-        if real_params.is_empty() {\n-            return Ok(());\n-        }\n-        if f.alternate() {\n-            write!(f, \"<{:#}>\", comma_sep(&real_params))\n-        } else {\n-            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n-        }\n+impl clean::Generics {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let real_params = self.params\n+                .iter()\n+                .filter(|p| !p.is_synthetic_type_param())\n+                .collect::<Vec<_>>();\n+            if real_params.is_empty() {\n+                return Ok(());\n+            }\n+            if f.alternate() {\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print())))\n+            } else {\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print())))\n+            }\n+        })\n     }\n }\n \n@@ -287,24 +246,26 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#}: {:#}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{:#}: {:#}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     } else {\n-                        clause.push_str(&format!(\"{}: {}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{}: {}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime, ref bounds } => {\n                     clause.push_str(&format!(\"{}: {}\",\n-                                                lifetime,\n+                                                lifetime.print(),\n                                                 bounds.iter()\n-                                                    .map(|b| b.to_string())\n+                                                    .map(|b| b.print().to_string())\n                                                     .collect::<Vec<_>>()\n                                                     .join(\" + \")));\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#} == {:#}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(), rhs.print()));\n                     } else {\n-                        clause.push_str(&format!(\"{} == {}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{} == {}\", lhs.print(), rhs.print()));\n                     }\n                 }\n             }\n@@ -336,153 +297,164 @@ impl<'a> fmt::Display for WhereClause<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.get_ref())?;\n-        Ok(())\n+impl clean::Lifetime {\n+    crate fn print(&self) -> &str {\n+        self.get_ref()\n     }\n }\n \n-impl fmt::Display for clean::Constant {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.expr, f)\n+impl clean::Constant {\n+    crate fn print(&self) -> &str {\n+        &self.expr\n     }\n }\n \n-impl fmt::Display for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if !self.generic_params.is_empty() {\n+impl clean::PolyTrait {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if !self.generic_params.is_empty() {\n+                if f.alternate() {\n+                    write!(f, \"for<{:#}> \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                } else {\n+                    write!(f, \"for&lt;{}&gt; \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                }\n+            }\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{:#}\", self.trait_.print())\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{}\", self.trait_.print())\n             }\n-        }\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.trait_)\n-        } else {\n-            write!(f, \"{}\", self.trait_)\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericBound {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericBound::Outlives(ref lt) => {\n-                write!(f, \"{}\", *lt)\n-            }\n-            clean::GenericBound::TraitBound(ref ty, modifier) => {\n-                let modifier_str = match modifier {\n-                    hir::TraitBoundModifier::None => \"\",\n-                    hir::TraitBoundModifier::Maybe => \"?\",\n-                };\n-                if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, *ty)\n-                } else {\n-                    write!(f, \"{}{}\", modifier_str, *ty)\n+impl clean::GenericBound {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericBound::Outlives(lt) => {\n+                    write!(f, \"{}\", lt.print())\n+                }\n+                clean::GenericBound::TraitBound(ty, modifier) => {\n+                    let modifier_str = match modifier {\n+                        hir::TraitBoundModifier::None => \"\",\n+                        hir::TraitBoundModifier::Maybe => \"?\",\n+                    };\n+                    if f.alternate() {\n+                        write!(f, \"{}{:#}\", modifier_str, ty.print())\n+                    } else {\n+                        write!(f, \"{}{}\", modifier_str, ty.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericArgs {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n-                if !args.is_empty() || !bindings.is_empty() {\n-                    if f.alternate() {\n-                        f.write_str(\"<\")?;\n-                    } else {\n-                        f.write_str(\"&lt;\")?;\n-                    }\n-                    let mut comma = false;\n-                    for arg in args {\n-                        if comma {\n-                            f.write_str(\", \")?;\n+impl clean::GenericArgs {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n+                    if !args.is_empty() || !bindings.is_empty() {\n+                        if f.alternate() {\n+                            f.write_str(\"<\")?;\n+                        } else {\n+                            f.write_str(\"&lt;\")?;\n+                        }\n+                        let mut comma = false;\n+                        for arg in args {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", arg.print())?;\n+                            } else {\n+                                write!(f, \"{}\", arg.print())?;\n+                            }\n+                        }\n+                        for binding in bindings {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", binding.print())?;\n+                            } else {\n+                                write!(f, \"{}\", binding.print())?;\n+                            }\n                         }\n-                        comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *arg)?;\n+                            f.write_str(\">\")?;\n                         } else {\n-                            write!(f, \"{}\", *arg)?;\n+                            f.write_str(\"&gt;\")?;\n                         }\n                     }\n-                    for binding in bindings {\n+                }\n+                clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n+                    f.write_str(\"(\")?;\n+                    let mut comma = false;\n+                    for ty in inputs {\n                         if comma {\n                             f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *binding)?;\n+                            write!(f, \"{:#}\", ty.print())?;\n                         } else {\n-                            write!(f, \"{}\", *binding)?;\n+                            write!(f, \"{}\", ty.print())?;\n                         }\n                     }\n-                    if f.alternate() {\n-                        f.write_str(\">\")?;\n-                    } else {\n-                        f.write_str(\"&gt;\")?;\n-                    }\n-                }\n-            }\n-            clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n-                f.write_str(\"(\")?;\n-                let mut comma = false;\n-                for ty in inputs {\n-                    if comma {\n-                        f.write_str(\", \")?;\n-                    }\n-                    comma = true;\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *ty)?;\n-                    } else {\n-                        write!(f, \"{}\", *ty)?;\n-                    }\n-                }\n-                f.write_str(\")\")?;\n-                if let Some(ref ty) = *output {\n-                    if f.alternate() {\n-                        write!(f, \" -> {:#}\", ty)?;\n-                    } else {\n-                        write!(f, \" -&gt; {}\", ty)?;\n+                    f.write_str(\")\")?;\n+                    if let Some(ref ty) = *output {\n+                        if f.alternate() {\n+                            write!(f, \" -> {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \" -&gt; {}\", ty.print())?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.args)\n-        } else {\n-            write!(f, \"{}\", self.args)\n-        }\n+impl clean::PathSegment {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", self.args.print())\n+            } else {\n+                write!(f, \"{}\", self.args.print())\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.global {\n-            f.write_str(\"::\")?\n-        }\n-\n-        for (i, seg) in self.segments.iter().enumerate() {\n-            if i > 0 {\n+impl clean::Path {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if self.global {\n                 f.write_str(\"::\")?\n             }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", seg)?;\n-            } else {\n-                write!(f, \"{}\", seg)?;\n+\n+            for (i, seg) in self.segments.iter().enumerate() {\n+                if i > 0 {\n+                    f.write_str(\"::\")?\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", seg.print())?;\n+                } else {\n+                    write!(f, \"{}\", seg.print())?;\n+                }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n@@ -516,7 +488,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.css_class());\n+            url.push_str(shortty.as_str());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");\n@@ -537,7 +509,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args)?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print())?;\n     } else {\n         let path = if use_absolute {\n             if let Some((_, _, fqp)) = href(did) {\n@@ -550,7 +522,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         } else {\n             anchor(did, &last.name).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args)?;\n+        write!(w, \"{}{}\", path, last.args.print())?;\n     }\n     Ok(())\n }\n@@ -606,7 +578,7 @@ fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display\n             Some(ref params) => {\n                 for param in params {\n                     write!(f, \" + \")?;\n-                    fmt::Display::fmt(param, f)?;\n+                    fmt::Display::fmt(&param.print(), f)?;\n                 }\n                 Ok(())\n             }\n@@ -644,14 +616,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n-                       comma_sep(&decl.generic_params),\n-                       decl.decl)\n+                       decl.unsafety.print_with_space(),\n+                       print_abi_with_space(decl.abi),\n+                       decl.print_generic_params(),\n+                       decl.decl.print())\n             } else {\n-                write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n+                write!(f, \"{}{}\",\n+                    decl.unsafety.print_with_space(), print_abi_with_space(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", decl.print_generic_params(), decl.decl.print())\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -660,24 +633,27 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(one, f)?;\n+                    fmt::Display::fmt(&one.print(), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&comma_sep(many), f)?;\n+                    for (i, item) in many.iter().enumerate() {\n+                        if i != 0 { write!(f, \", \")?; }\n+                        fmt::Display::fmt(&item.print(), f)?;\n+                    }\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n             primitive_link(f, PrimitiveType::Slice, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n         clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n@@ -691,24 +667,24 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {:#}\", m, t))\n+                                       &format!(\"*{} {:#}\", m, t.print()))\n                     } else {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {}\", m, t))\n+                                       &format!(\"*{} {}\", m, t.print()))\n                     }\n                 }\n                 _ => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n-                    fmt::Display::fmt(t, f)\n+                    fmt::Display::fmt(&t.print(), f)\n                 }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-            let lt = match *l {\n-                Some(ref l) => format!(\"{} \", *l),\n-                _ => String::new(),\n+            let lt = match l {\n+                Some(l) => format!(\"{} \", l.print()),\n+                _ => String::new()\n             };\n-            let m = MutableSpace(mutability);\n+            let m = mutability.print_with_space();\n             let amp = if f.alternate() {\n                 \"&\".to_string()\n             } else {\n@@ -720,19 +696,19 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         clean::Generic(_) => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print()))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print()))\n                             }\n                         }\n                         _ => {\n                             primitive_link(f, PrimitiveType::Slice,\n                                            &format!(\"{}{}{}[\", amp, lt, m))?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", **bt)?;\n+                                write!(f, \"{:#}\", bt.print())?;\n                             } else {\n-                                write!(f, \"{}\", **bt)?;\n+                                write!(f, \"{}\", bt.print())?;\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n@@ -756,9 +732,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", GenericBounds(bounds))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds))\n             } else {\n-                write!(f, \"impl {}\", GenericBounds(bounds))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -770,15 +746,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type)?\n+                    write!(f, \"{:#}::\", self_type.print())?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{}::\", self_type)?\n+                    write!(f, \"{}::\", self_type.print())?\n                 }\n             };\n             match *trait_ {\n@@ -818,331 +794,381 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_type(self, f, false)\n+impl clean::Type {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            fmt_type(self, f, false)\n+        })\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl,\n-            f: &mut fmt::Formatter<'_>,\n-            link_trait: bool,\n-            use_absolute: bool) -> fmt::Result {\n-    if f.alternate() {\n-        write!(f, \"impl{:#} \", i.generics)?;\n-    } else {\n-        write!(f, \"impl{} \", i.generics)?;\n+impl clean::Impl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        self.print_inner(true, false)\n     }\n \n-    if let Some(ref ty) = i.trait_ {\n-        if i.polarity == Some(clean::ImplPolarity::Negative) {\n-            write!(f, \"!\")?;\n-        }\n+    fn print_inner(\n+        &self,\n+        link_trait: bool,\n+        use_absolute: bool,\n+    ) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f, \"impl{:#} \", self.generics.print())?;\n+            } else {\n+                write!(f, \"impl{} \", self.generics.print())?;\n+            }\n \n-        if link_trait {\n-            fmt::Display::fmt(ty, f)?;\n-        } else {\n-            match *ty {\n-                clean::ResolvedPath { param_names: None, ref path, is_generic: false, .. } => {\n-                    let last = path.segments.last().unwrap();\n-                    fmt::Display::fmt(&last.name, f)?;\n-                    fmt::Display::fmt(&last.args, f)?;\n+            if let Some(ref ty) = self.trait_ {\n+                if self.polarity == Some(clean::ImplPolarity::Negative) {\n+                    write!(f, \"!\")?;\n                 }\n-                _ => unreachable!(),\n-            }\n-        }\n-        write!(f, \" for \")?;\n-    }\n \n-    if let Some(ref ty) = i.blanket_impl {\n-        fmt_type(ty, f, use_absolute)?;\n-    } else {\n-        fmt_type(&i.for_, f, use_absolute)?;\n-    }\n+                if link_trait {\n+                    fmt::Display::fmt(&ty.print(), f)?;\n+                } else {\n+                    match ty {\n+                        clean::ResolvedPath { param_names: None, path, is_generic: false, .. } => {\n+                            let last = path.segments.last().unwrap();\n+                            fmt::Display::fmt(&last.name, f)?;\n+                            fmt::Display::fmt(&last.args.print(), f)?;\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                write!(f, \" for \")?;\n+            }\n \n-    fmt::Display::fmt(&WhereClause { gens: &i.generics, indent: 0, end_newline: true }, f)?;\n-    Ok(())\n-}\n+            if let Some(ref ty) = self.blanket_impl {\n+                fmt_type(ty, f, use_absolute)?;\n+            } else {\n+                fmt_type(&self.for_, f, use_absolute)?;\n+            }\n \n-impl fmt::Display for clean::Impl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_impl(self, f, true, false)\n+            fmt::Display::fmt(&WhereClause {\n+                gens: &self.generics,\n+                indent: 0,\n+                end_newline: true,\n+            }, f)?;\n+            Ok(())\n+        })\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n                                f: &mut Buffer,\n                                use_absolute: bool) {\n-    f.with_formatter(|f| fmt_impl(i, f, false, use_absolute))\n+    f.from_display(i.print_inner(false, use_absolute))\n }\n \n-impl fmt::Display for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, input) in self.values.iter().enumerate() {\n-            if !input.name.is_empty() {\n-                write!(f, \"{}: \", input.name)?;\n-            }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", input.type_)?;\n-            } else {\n-                write!(f, \"{}\", input.type_)?;\n+impl clean::Arguments {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            for (i, input) in self.values.iter().enumerate() {\n+                if !input.name.is_empty() {\n+                    write!(f, \"{}: \", input.name)?;\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", input.type_.print())?;\n+                } else {\n+                    write!(f, \"{}\", input.type_.print())?;\n+                }\n+                if i + 1 < self.values.len() { write!(f, \", \")?; }\n             }\n-            if i + 1 < self.values.len() { write!(f, \", \")?; }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n-            clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n-            clean::DefaultReturn => Ok(()),\n-        }\n+impl clean::FunctionRetTy {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n+                clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print()),\n+                clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print()),\n+                clean::DefaultReturn => Ok(()),\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n-        } else {\n-            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n-        }\n+impl clean::BareFunctionDecl {\n+    fn print_generic_params(&self) -> impl fmt::Display + '_ {\n+        comma_sep(self.generic_params.iter().map(|g| g.print()))\n     }\n }\n \n-impl<'a> fmt::Display for Function<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let &Function { decl, header_len, indent, asyncness } = self;\n-        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n-        let mut args = String::new();\n-        let mut args_plain = String::new();\n-        for (i, input) in decl.inputs.values.iter().enumerate() {\n-            if i == 0 {\n-                args.push_str(\"<br>\");\n+impl clean::FnDecl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f,\n+                    \"({args:#}){arrow:#}\", args = self.inputs.print(), arrow = self.output.print())\n+            } else {\n+                write!(f,\n+                    \"({args}){arrow}\", args = self.inputs.print(), arrow = self.output.print())\n             }\n+        })\n+    }\n+}\n \n-            if let Some(selfty) = input.to_self() {\n-                match selfty {\n-                    clean::SelfValue => {\n-                        args.push_str(\"self\");\n-                        args_plain.push_str(\"self\");\n+\n+impl Function<'_> {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let &Function { decl, header_len, indent, asyncness } = self;\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n+            let mut args = String::new();\n+            let mut args_plain = String::new();\n+            for (i, input) in decl.inputs.values.iter().enumerate() {\n+                if i == 0 {\n+                    args.push_str(\"<br>\");\n+                }\n+\n+                if let Some(selfty) = input.to_self() {\n+                    match selfty {\n+                        clean::SelfValue => {\n+                            args.push_str(\"self\");\n+                            args_plain.push_str(\"self\");\n+                        }\n+                        clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                            args.push_str(\n+                                &format!(\"{}{} {}self\", amp, lt.print(), mtbl.print_with_space()));\n+                            args_plain.push_str(\n+                                &format!(\"&{} {}self\", lt.print(), mtbl.print_with_space()));\n+                        }\n+                        clean::SelfBorrowed(None, mtbl) => {\n+                            args.push_str(&format!(\"{}{}self\", amp, mtbl.print_with_space()));\n+                            args_plain.push_str(&format!(\"&{}self\", mtbl.print_with_space()));\n+                        }\n+                        clean::SelfExplicit(ref typ) => {\n+                            if f.alternate() {\n+                                args.push_str(&format!(\"self: {:#}\", typ.print()));\n+                            } else {\n+                                args.push_str(&format!(\"self: {}\", typ.print()));\n+                            }\n+                            args_plain.push_str(&format!(\"self: {:#}\", typ.print()));\n+                        }\n                     }\n-                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        args.push_str(&format!(\"{}{} {}self\", amp, *lt, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{} {}self\", *lt, MutableSpace(mtbl)));\n+                } else {\n+                    if i > 0 {\n+                        args.push_str(\" <br>\");\n+                        args_plain.push_str(\" \");\n                     }\n-                    clean::SelfBorrowed(None, mtbl) => {\n-                        args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n+                    if !input.name.is_empty() {\n+                        args.push_str(&format!(\"{}: \", input.name));\n+                        args_plain.push_str(&format!(\"{}: \", input.name));\n                     }\n-                    clean::SelfExplicit(ref typ) => {\n-                        if f.alternate() {\n-                            args.push_str(&format!(\"self: {:#}\", *typ));\n-                        } else {\n-                            args.push_str(&format!(\"self: {}\", *typ));\n-                        }\n-                        args_plain.push_str(&format!(\"self: {:#}\", *typ));\n+\n+                    if f.alternate() {\n+                        args.push_str(&format!(\"{:#}\", input.type_.print()));\n+                    } else {\n+                        args.push_str(&input.type_.print().to_string());\n                     }\n+                    args_plain.push_str(&format!(\"{:#}\", input.type_.print()));\n                 }\n-            } else {\n-                if i > 0 {\n-                    args.push_str(\" <br>\");\n-                    args_plain.push_str(\" \");\n-                }\n-                if !input.name.is_empty() {\n-                    args.push_str(&format!(\"{}: \", input.name));\n-                    args_plain.push_str(&format!(\"{}: \", input.name));\n-                }\n-\n-                if f.alternate() {\n-                    args.push_str(&format!(\"{:#}\", input.type_));\n-                } else {\n-                    args.push_str(&input.type_.to_string());\n+                if i + 1 < decl.inputs.values.len() {\n+                    args.push(',');\n+                    args_plain.push(',');\n                 }\n-                args_plain.push_str(&format!(\"{:#}\", input.type_));\n-            }\n-            if i + 1 < decl.inputs.values.len() {\n-                args.push(',');\n-                args_plain.push(',');\n             }\n-        }\n \n-        let args_plain = format!(\"({})\", args_plain);\n+            let args_plain = format!(\"({})\", args_plain);\n \n-        let output = if let hir::IsAsync::Async = asyncness {\n-            Cow::Owned(decl.sugared_async_return_type())\n-        } else {\n-            Cow::Borrowed(&decl.output)\n-        };\n+            let output = if let hir::IsAsync::Async = asyncness {\n+                Cow::Owned(decl.sugared_async_return_type())\n+            } else {\n+                Cow::Borrowed(&decl.output)\n+            };\n \n-        let arrow_plain = format!(\"{:#}\", &output);\n-        let arrow = if f.alternate() {\n-            format!(\"{:#}\", &output)\n-        } else {\n-            output.to_string()\n-        };\n+            let arrow_plain = format!(\"{:#}\", &output.print());\n+            let arrow = if f.alternate() {\n+                format!(\"{:#}\", &output.print())\n+            } else {\n+                output.print().to_string()\n+            };\n \n-        let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n-        let output = if declaration_len > 80 {\n-            let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n-            let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n-            format!(\"({args}{close}){arrow}\",\n-                    args = args.replace(\"<br>\", &full_pad),\n-                    close = close_pad,\n-                    arrow = arrow)\n-        } else {\n-            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n-        };\n+            let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n+            let output = if declaration_len > 80 {\n+                let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n+                let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n+                format!(\"({args}{close}){arrow}\",\n+                        args = args.replace(\"<br>\", &full_pad),\n+                        close = close_pad,\n+                        arrow = arrow)\n+            } else {\n+                format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n+            };\n \n-        if f.alternate() {\n-            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n-        } else {\n-            write!(f, \"{}\", output)\n-        }\n+            if f.alternate() {\n+                write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+            } else {\n+                write!(f, \"{}\", output)\n+            }\n+        })\n     }\n }\n \n-impl<'a> fmt::Display for VisSpace<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self.get() {\n-            Some(clean::Public) => f.write_str(\"pub \"),\n-            Some(clean::Inherited) | None => Ok(()),\n-            Some(clean::Visibility::Crate) => write!(f, \"pub(crate) \"),\n-            Some(clean::Visibility::Restricted(did, ref path)) => {\n-                f.write_str(\"pub(\")?;\n-                if path.segments.len() != 1\n-                    || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n-                {\n-                    f.write_str(\"in \")?;\n+impl clean::Visibility {\n+    crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Public => f.write_str(\"pub \"),\n+                clean::Inherited => Ok(()),\n+                clean::Visibility::Crate => write!(f, \"pub(crate) \"),\n+                clean::Visibility::Restricted(did, ref path) => {\n+                    f.write_str(\"pub(\")?;\n+                    if path.segments.len() != 1\n+                        || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n+                    {\n+                        f.write_str(\"in \")?;\n+                    }\n+                    resolved_path(f, did, path, true, false)?;\n+                    f.write_str(\") \")\n                 }\n-                resolved_path(f, did, path, true, false)?;\n-                f.write_str(\") \")\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n-            hir::Unsafety::Normal => Ok(())\n+crate trait PrintWithSpace {\n+    fn print_with_space(&self) -> &str;\n+}\n+\n+impl PrintWithSpace for hir::Unsafety {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Unsafety::Unsafe => \"unsafe \",\n+            hir::Unsafety::Normal => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for ConstnessSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            hir::Constness::Const => write!(f, \"const \"),\n-            hir::Constness::NotConst => Ok(())\n+impl PrintWithSpace for hir::Constness {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Constness::Const => \"const \",\n+            hir::Constness::NotConst => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for AsyncSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {\n-            hir::IsAsync::Async => write!(f, \"async \"),\n-            hir::IsAsync::NotAsync => Ok(()),\n+impl PrintWithSpace for hir::IsAsync {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::IsAsync::Async => \"async \",\n+            hir::IsAsync::NotAsync => \"\",\n         }\n     }\n }\n \n-impl fmt::Display for clean::Import {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Import::Simple(ref name, ref src) => {\n-                if *name == src.path.last_name() {\n-                    write!(f, \"use {};\", *src)\n-                } else {\n-                    write!(f, \"use {} as {};\", *src, *name)\n+impl clean::Import {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Import::Simple(ref name, ref src) => {\n+                    if *name == src.path.last_name() {\n+                        write!(f, \"use {};\", src.print())\n+                    } else {\n+                        write!(f, \"use {} as {};\", src.print(), *name)\n+                    }\n                 }\n-            }\n-            clean::Import::Glob(ref src) => {\n-                if src.path.segments.is_empty() {\n-                    write!(f, \"use *;\")\n-                } else {\n-                    write!(f, \"use {}::*;\", *src)\n+                clean::Import::Glob(ref src) => {\n+                    if src.path.segments.is_empty() {\n+                        write!(f, \"use *;\")\n+                    } else {\n+                        write!(f, \"use {}::*;\", src.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false),\n-            _ => {\n-                for (i, seg) in self.path.segments.iter().enumerate() {\n-                    if i > 0 {\n-                        write!(f, \"::\")?\n+impl clean::ImportSource {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.did {\n+                Some(did) => resolved_path(f, did, &self.path, true, false),\n+                _ => {\n+                    for (i, seg) in self.path.segments.iter().enumerate() {\n+                        if i > 0 {\n+                            write!(f, \"::\")?\n+                        }\n+                        write!(f, \"{}\", seg.name)?;\n                     }\n-                    write!(f, \"{}\", seg.name)?;\n+                    Ok(())\n                 }\n-                Ok(())\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::TypeBinding {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        match self.kind {\n-            clean::TypeBindingKind::Equality { ref ty } => {\n-                if f.alternate() {\n-                    write!(f, \" = {:#}\", ty)?;\n-                } else {\n-                    write!(f, \" = {}\", ty)?;\n-                }\n-            }\n-            clean::TypeBindingKind::Constraint { ref bounds } => {\n-                if !bounds.is_empty() {\n+impl clean::TypeBinding {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            match self.kind {\n+                clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {:#}\", ty.print())?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {}\", ty.print())?;\n+                    }\n+                }\n+                clean::TypeBindingKind::Constraint { ref bounds } => {\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for MutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            MutableSpace(clean::Immutable) => Ok(()),\n-            MutableSpace(clean::Mutable) => write!(f, \"mut \"),\n+impl clean::Mutability {\n+    crate fn print_with_space(&self) -> &str {\n+        match self {\n+            clean::Immutable => \"\",\n+            clean::Mutable => \"mut \",\n         }\n     }\n }\n \n-impl fmt::Display for AbiSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n+    display_fn(move |f| {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n-        match self.0 {\n+        match abi {\n             Abi::Rust => Ok(()),\n             abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n+    })\n+}\n+\n+crate fn print_default_space<'a>(v: bool) -> &'a str {\n+    if v {\n+        \"default \"\n+    } else {\n+        \"\"\n     }\n }\n \n-impl fmt::Display for DefaultSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.0 {\n-            write!(f, \"default \")\n-        } else {\n-            Ok(())\n-        }\n+impl clean::GenericArg {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n+                clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(), f),\n+                clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(), f),\n+            }\n+        })\n     }\n }\n "}, {"sha": "5fb9afd6c49a04abd4f5c2cf7c727267c138bca9", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -46,14 +46,6 @@ pub enum ItemType {\n }\n \n \n-#[derive(Copy, Eq, PartialEq, Clone)]\n-pub enum NameSpace {\n-    Type,\n-    Value,\n-    Macro,\n-    Keyword,\n-}\n-\n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n         let inner = match item.inner {\n@@ -120,7 +112,7 @@ impl From<clean::TypeKind> for ItemType {\n }\n \n impl ItemType {\n-    pub fn css_class(&self) -> &'static str {\n+    pub fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -151,7 +143,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn name_space(&self) -> NameSpace {\n+    pub fn name_space(&self) -> &'static str {\n         match *self {\n             ItemType::Struct |\n             ItemType::Union |\n@@ -163,7 +155,7 @@ impl ItemType {\n             ItemType::AssocType |\n             ItemType::OpaqueTy |\n             ItemType::TraitAlias |\n-            ItemType::ForeignType => NameSpace::Type,\n+            ItemType::ForeignType => NAMESPACE_TYPE,\n \n             ItemType::ExternCrate |\n             ItemType::Import |\n@@ -175,41 +167,24 @@ impl ItemType {\n             ItemType::StructField |\n             ItemType::Variant |\n             ItemType::Constant |\n-            ItemType::AssocConst => NameSpace::Value,\n+            ItemType::AssocConst => NAMESPACE_VALUE,\n \n             ItemType::Macro |\n             ItemType::ProcAttribute |\n-            ItemType::ProcDerive => NameSpace::Macro,\n+            ItemType::ProcDerive => NAMESPACE_MACRO,\n \n-            ItemType::Keyword => NameSpace::Keyword,\n+            ItemType::Keyword => NAMESPACE_KEYWORD,\n         }\n     }\n }\n \n impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.css_class().fmt(f)\n+        write!(f, \"{}\", self.as_str())\n     }\n }\n \n pub const NAMESPACE_TYPE: &'static str = \"t\";\n pub const NAMESPACE_VALUE: &'static str = \"v\";\n pub const NAMESPACE_MACRO: &'static str = \"m\";\n pub const NAMESPACE_KEYWORD: &'static str = \"k\";\n-\n-impl NameSpace {\n-    pub fn to_static_str(&self) -> &'static str {\n-        match *self {\n-            NameSpace::Type => NAMESPACE_TYPE,\n-            NameSpace::Value => NAMESPACE_VALUE,\n-            NameSpace::Macro => NAMESPACE_MACRO,\n-            NameSpace::Keyword => NAMESPACE_KEYWORD,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for NameSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.to_static_str().fmt(f)\n-    }\n-}"}, {"sha": "6414241727a722b2a577b9bb02a9a6fc8b08dede", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -1,7 +1,7 @@\n use std::path::PathBuf;\n \n use crate::externalfiles::ExternalHtml;\n-use crate::html::render::SlashChecker;\n+use crate::html::render::ensure_trailing_slash;\n use crate::html::format::{Buffer, Print};\n \n #[derive(Clone)]\n@@ -180,7 +180,7 @@ pub fn render<T: Print, S: Print>(\n     css_class = page.css_class,\n     logo      = {\n         let p = format!(\"{}{}\", page.root_path, layout.krate);\n-        let p = SlashChecker(&p);\n+        let p = ensure_trailing_slash(&p);\n         if layout.logo.is_empty() {\n             format!(\"<a href='{path}index.html'>\\\n                      <div class='logo-container'>\\"}, {"sha": "9ff1e1d31197d28d8538369a788da11130d16ad9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -752,7 +752,7 @@ impl MarkdownWithToc<'_> {\n             html::push_html(&mut s, p);\n         }\n \n-        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc(), s)\n+        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc().print(), s)\n     }\n }\n "}, {"sha": "301dddbbfb9b2e748a51b02554270d83c44fa986", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 251, "deletions": 883, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -25,20 +25,17 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-pub use self::ExternalLocation::*;\n-\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n use std::error;\n-use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n+use std::fmt::{self, Formatter, Write as FmtWrite};\n use std::ffi::OsStr;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n-use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n@@ -52,7 +49,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::{Symbol, sym};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n@@ -63,11 +60,10 @@ use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutabilit\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n-use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n-use crate::html::format::{Buffer, AsyncSpace, ConstnessSpace};\n-use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace, DefaultSpace};\n-use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n+use crate::html::format::{Buffer, PrintWithSpace, print_abi_with_space};\n+use crate::html::format::{print_generic_bounds, WhereClause, href, print_default_space};\n+use crate::html::format::{Function};\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n@@ -79,19 +75,22 @@ use minifier;\n #[cfg(test)]\n mod tests;\n \n+mod cache;\n+\n+use cache::Cache;\n+crate use cache::ExternalLocation::{self, *};\n+\n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n \n-pub struct SlashChecker<'a>(pub &'a str);\n-\n-impl<'a> Display for SlashChecker<'a> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        if !self.0.ends_with(\"/\") && !self.0.is_empty() {\n-            write!(f, \"{}/\", self.0)\n+crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n+    crate::html::format::display_fn(move |f| {\n+        if !v.ends_with(\"/\") && !v.is_empty() {\n+            write!(f, \"{}/\", v)\n         } else {\n-            write!(f, \"{}\", self.0)\n+            write!(f, \"{}\", v)\n         }\n-    }\n+    })\n }\n \n #[derive(Debug)]\n@@ -106,7 +105,7 @@ impl error::Error for Error {\n     }\n }\n \n-impl Display for Error {\n+impl std::fmt::Display for Error {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         let file = self.file.display().to_string();\n         if file.is_empty() {\n@@ -165,13 +164,10 @@ struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n-    pub codes: ErrorCodes,\n-    /// The default edition used to parse doctests.\n-    pub edition: Edition,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    playground: Option<markdown::Playground>,\n+    pub cache: Arc<Cache>,\n }\n \n crate struct SharedContext {\n@@ -210,6 +206,30 @@ crate struct SharedContext {\n     pub generate_redirect_pages: bool,\n     /// The fs handle we are working with.\n     pub fs: DocFS,\n+    /// The default edition used to parse doctests.\n+    pub edition: Edition,\n+    pub codes: ErrorCodes,\n+    playground: Option<markdown::Playground>,\n+}\n+\n+impl Context {\n+    fn path(&self, filename: &str) -> PathBuf {\n+        // We use splitn vs Path::extension here because we might get a filename\n+        // like `style.min.css` and we want to process that into\n+        // `style-suffix.min.css`.  Path::extension would just return `css`\n+        // which would result in `style.min-suffix.css` which isn't what we\n+        // want.\n+        let mut iter = filename.splitn(2, '.');\n+        let base = iter.next().unwrap();\n+        let ext = iter.next().unwrap();\n+        let filename = format!(\n+            \"{}{}.{}\",\n+            base,\n+            self.shared.resource_suffix,\n+            ext,\n+        );\n+        self.dst.join(&filename)\n+    }\n }\n \n impl SharedContext {\n@@ -222,9 +242,7 @@ impl SharedContext {\n \n         Ok(())\n     }\n-}\n \n-impl SharedContext {\n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n     pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n@@ -236,16 +254,6 @@ impl SharedContext {\n     }\n }\n \n-/// Indicates where an external crate can be found.\n-pub enum ExternalLocation {\n-    /// Remote URL root of the external crate\n-    Remote(String),\n-    /// This external crate can be found in the local doc/ folder\n-    Local,\n-    /// The external crate could not be found.\n-    Unknown,\n-}\n-\n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n pub struct Impl {\n@@ -265,106 +273,6 @@ impl Impl {\n     }\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-pub struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    deref_trait_did: Option<DefId>,\n-    deref_mut_trait_did: Option<DefId>,\n-    owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    aliases: FxHashMap<String, Vec<IndexItem>>,\n-}\n-\n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n@@ -520,29 +428,6 @@ pub fn run(mut krate: clean::Crate,\n         _ => PathBuf::new(),\n     };\n     let mut errors = Arc::new(ErrorStorage::new());\n-    let mut scx = SharedContext {\n-        collapsed: krate.collapsed,\n-        src_root,\n-        include_sources: true,\n-        local_sources: Default::default(),\n-        issue_tracker_base_url: None,\n-        layout: layout::Layout {\n-            logo: String::new(),\n-            favicon: String::new(),\n-            external_html,\n-            krate: krate.name.clone(),\n-            css_file_extension: extension_css,\n-            generate_search_filter,\n-        },\n-        created_dirs: Default::default(),\n-        sort_modules_alphabetically,\n-        themes,\n-        resource_suffix,\n-        static_root_path,\n-        generate_redirect_pages,\n-        fs: DocFS::new(&errors),\n-    };\n-\n     // If user passed in `--playground-url` arg, we fill in crate name here\n     let mut playground = None;\n     if let Some(url) = playground_url {\n@@ -551,17 +436,27 @@ pub fn run(mut krate: clean::Crate,\n             url,\n         });\n     }\n+    let mut layout = layout::Layout {\n+        logo: String::new(),\n+        favicon: String::new(),\n+        external_html,\n+        krate: krate.name.clone(),\n+        css_file_extension: extension_css,\n+        generate_search_filter,\n+    };\n+    let mut issue_tracker_base_url = None;\n+    let mut include_sources = true;\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n         for attr in attrs.lists(sym::doc) {\n             match (attr.name_or_empty(), attr.value_str()) {\n                 (sym::html_favicon_url, Some(s)) => {\n-                    scx.layout.favicon = s.to_string();\n+                    layout.favicon = s.to_string();\n                 }\n                 (sym::html_logo_url, Some(s)) => {\n-                    scx.layout.logo = s.to_string();\n+                    layout.logo = s.to_string();\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n                     playground = Some(markdown::Playground {\n@@ -570,122 +465,62 @@ pub fn run(mut krate: clean::Crate,\n                     });\n                 }\n                 (sym::issue_tracker_base_url, Some(s)) => {\n-                    scx.issue_tracker_base_url = Some(s.to_string());\n+                    issue_tracker_base_url = Some(s.to_string());\n                 }\n                 (sym::html_no_source, None) if attr.is_word() => {\n-                    scx.include_sources = false;\n+                    include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    let mut scx = SharedContext {\n+        collapsed: krate.collapsed,\n+        src_root,\n+        include_sources,\n+        local_sources: Default::default(),\n+        issue_tracker_base_url,\n+        layout,\n+        created_dirs: Default::default(),\n+        sort_modules_alphabetically,\n+        themes,\n+        resource_suffix,\n+        static_root_path,\n+        generate_redirect_pages,\n+        fs: DocFS::new(&errors),\n+        edition,\n+        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        playground,\n+    };\n+\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n     krate = sources::render(&dst, &mut scx, krate)?;\n+    let (new_crate, index, cache) = Cache::from_krate(\n+        renderinfo,\n+        &extern_html_root_urls,\n+        &dst,\n+        krate,\n+    );\n+    krate = new_crate;\n+    let cache = Arc::new(cache);\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n-        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n-        edition,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n-        playground,\n-    };\n-\n-    // Crawl the crate to build various caches used for the output\n-    let RenderInfo {\n-        inlined: _,\n-        external_paths,\n-        exact_paths,\n-        access_levels,\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-    } = renderinfo;\n-\n-    let external_paths = external_paths.into_iter()\n-        .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n-        .collect();\n-\n-    let mut cache = Cache {\n-        impls: Default::default(),\n-        external_paths,\n-        exact_paths,\n-        paths: Default::default(),\n-        implementors: Default::default(),\n-        stack: Vec::new(),\n-        parent_stack: Vec::new(),\n-        search_index: Vec::new(),\n-        parent_is_trait_impl: false,\n-        extern_locations: Default::default(),\n-        primitive_locations: Default::default(),\n-        stripped_mod: false,\n-        access_levels,\n-        crate_version: krate.version.take(),\n-        orphan_impl_items: Vec::new(),\n-        orphan_trait_impls: Vec::new(),\n-        traits: krate.external_traits.replace(Default::default()),\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-        masked_crates: mem::take(&mut krate.masked_crates),\n-        aliases: Default::default(),\n+        cache: cache.clone(),\n     };\n \n-    // Cache where all our extern crates are located\n-    for &(n, ref e) in &krate.externs {\n-        let src_root = match e.src {\n-            FileName::Real(ref p) => match p.parent() {\n-                Some(p) => p.to_path_buf(),\n-                None => PathBuf::new(),\n-            },\n-            _ => PathBuf::new(),\n-        };\n-        let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-        cache.extern_locations.insert(n, (e.name.clone(), src_root,\n-                                          extern_location(e, extern_url, &cx.dst)));\n-\n-        let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-        cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-    }\n-\n-    // Cache where all known primitives have their documentation located.\n-    //\n-    // Favor linking to as local extern as possible, so iterate all crates in\n-    // reverse topological order.\n-    for &(_, ref e) in krate.externs.iter().rev() {\n-        for &(def_id, prim, _) in &e.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-    }\n-    for &(def_id, prim, _) in &krate.primitives {\n-        cache.primitive_locations.insert(prim, def_id);\n-    }\n-\n-    cache.stack.push(krate.name.clone());\n-    krate = cache.fold_crate(krate);\n-\n-    for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-        if cache.traits.contains_key(&trait_did) {\n-            for did in dids {\n-                cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-            }\n-        }\n-    }\n-\n-    // Build our search index\n-    let index = build_index(&krate, &mut cache);\n-\n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n-    let cache = Arc::new(cache);\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_DEPTH.with(|s| s.set(0));\n \n     // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n+    write_shared(&cx, &krate, index, &md_opts, diag)?;\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n \n     // And finally render the whole crate's documentation\n@@ -700,80 +535,9 @@ pub fn run(mut krate: clean::Crate,\n     }\n }\n \n-/// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = FxHashMap::default();\n-    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n-    let mut crate_paths = Vec::<Json>::new();\n-\n-    let Cache { ref mut search_index,\n-                ref orphan_impl_items,\n-                ref mut paths, .. } = *cache;\n-\n-    // Attach all orphan items to the type's definition if the type\n-    // has since been learned.\n-    for &(did, ref item) in orphan_impl_items {\n-        if let Some(&(ref fqp, _)) = paths.get(&did) {\n-            search_index.push(IndexItem {\n-                ty: item.type_(),\n-                name: item.name.clone().unwrap(),\n-                path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: shorten(plain_summary_line(item.doc_value())),\n-                parent: Some(did),\n-                parent_idx: None,\n-                search_type: get_index_search_type(&item),\n-            });\n-        }\n-    }\n-\n-    // Reduce `NodeId` in paths into smaller sequential numbers,\n-    // and prune the paths that do not appear in the index.\n-    let mut lastpath = String::new();\n-    let mut lastpathid = 0usize;\n-\n-    for item in search_index {\n-        item.parent_idx = item.parent.map(|nodeid| {\n-            if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n-            } else {\n-                let pathid = lastpathid;\n-                nodeid_to_pathid.insert(nodeid, pathid);\n-                lastpathid += 1;\n-\n-                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n-                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n-                pathid\n-            }\n-        });\n-\n-        // Omit the parent path if it is same to that of the prior item.\n-        if lastpath == item.path {\n-            item.path.clear();\n-        } else {\n-            lastpath = item.path.clone();\n-        }\n-        crate_items.push(item.to_json());\n-    }\n-\n-    let crate_doc = krate.module.as_ref().map(|module| {\n-        shorten(plain_summary_line(module.doc_value()))\n-    }).unwrap_or(String::new());\n-\n-    let mut crate_data = BTreeMap::new();\n-    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n-    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n-    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n-\n-    // Collect the index into a string\n-    format!(\"searchIndex[{}] = {};\",\n-            as_json(&krate.name),\n-            Json::Object(crate_data))\n-}\n-\n fn write_shared(\n     cx: &Context,\n     krate: &clean::Crate,\n-    cache: &Cache,\n     search_index: String,\n     options: &RenderOptions,\n     diag: &errors::Handler,\n@@ -786,13 +550,13 @@ fn write_shared(\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"rustdoc.css\"),\n                  static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"settings.css\"),\n                  static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"noscript.css\"),\n                  static_files::NOSCRIPT_CSS,\n                  options.enable_minification)?;\n \n@@ -804,34 +568,25 @@ fn write_shared(\n         let content = try_err!(fs::read(&entry), &entry);\n         let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n         let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n-        cx.shared.fs.write(\n-            cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n-            content.as_slice())?;\n+        cx.shared.fs.write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n         themes.insert(theme.to_owned());\n     }\n \n     let write = |p, c| { cx.shared.fs.write(p, c) };\n     if (*cx.shared).layout.logo.is_empty() {\n-        write(cx.dst.join(&format!(\"rust-logo{}.png\", cx.shared.resource_suffix)),\n-              static_files::RUST_LOGO)?;\n+        write(cx.path(\"rust-log.png\"), static_files::RUST_LOGO)?;\n     }\n     if (*cx.shared).layout.favicon.is_empty() {\n-        write(cx.dst.join(&format!(\"favicon{}.ico\", cx.shared.resource_suffix)),\n-              static_files::RUST_FAVICON)?;\n-    }\n-    write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n-          static_files::BRUSH_SVG)?;\n-    write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n-          static_files::WHEEL_SVG)?;\n-    write(cx.dst.join(&format!(\"down-arrow{}.svg\", cx.shared.resource_suffix)),\n-          static_files::DOWN_ARROW_SVG)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n-                 static_files::themes::LIGHT,\n-                 options.enable_minification)?;\n+        write(cx.path(\"favicon.ico\"), static_files::RUST_FAVICON)?;\n+    }\n+    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n+    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n+    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n+    write_minify(&cx.shared.fs,\n+        cx.path(\"light.css\"), static_files::themes::LIGHT, options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n-                 static_files::themes::DARK,\n-                 options.enable_minification)?;\n+    write_minify(&cx.shared.fs,\n+        cx.path(\"dark.css\"), static_files::themes::DARK, options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n \n     let mut themes: Vec<&String> = themes.iter().collect();\n@@ -894,40 +649,40 @@ themePicker.onblur = handleThemeButtonsBlur;\n           theme_js.as_bytes()\n     )?;\n \n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"main.js\"),\n                  static_files::MAIN_JS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"settings.js\"),\n                  static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n     if cx.shared.include_sources {\n         write_minify(\n             &cx.shared.fs,\n-            cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n+            cx.path(\"source-script.js\"),\n             static_files::sidebar::SOURCE_SCRIPT,\n             options.enable_minification)?;\n     }\n \n     {\n         write_minify(\n             &cx.shared.fs,\n-            cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n+            cx.path(\"storage.js\"),\n             &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n                      cx.shared.resource_suffix,\n                      static_files::STORAGE_JS),\n             options.enable_minification)?;\n     }\n \n     if let Some(ref css) = cx.shared.layout.css_file_extension {\n-        let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n+        let out = cx.path(\"theme.css\");\n         let buffer = try_err!(fs::read_to_string(css), css);\n         if !options.enable_minification {\n             cx.shared.fs.write(&out, &buffer)?;\n         } else {\n             write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n         }\n     }\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"normalize.css\"),\n                  static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n@@ -1004,7 +759,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n         let mut output = String::with_capacity(100);\n-        for (alias, items) in &cache.aliases {\n+        for (alias, items) in &cx.cache.aliases {\n             if items.is_empty() {\n                 continue\n             }\n@@ -1136,7 +891,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             md_opts.output = cx.dst.clone();\n             md_opts.external_html = (*cx.shared).layout.external_html.clone();\n \n-            crate::markdown::render(index_page, md_opts, diag, cx.edition);\n+            crate::markdown::render(index_page, md_opts, diag, cx.shared.edition);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let page = layout::Page {\n@@ -1162,7 +917,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                     .iter()\n                                     .map(|s| {\n                                         format!(\"<li><a href=\\\"{}index.html\\\">{}</li>\",\n-                                                SlashChecker(s), s)\n+                                                ensure_trailing_slash(s), s)\n                                     })\n                                     .collect::<String>());\n             let v = layout::render(&cx.shared.layout,\n@@ -1174,17 +929,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cache.implementors {\n+    for (&did, imps) in &cx.cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cache.external_paths.get(&did) {\n+            None => match cx.cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             }\n@@ -1203,7 +958,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             if !imp.impl_item.def_id.is_local() { continue }\n             have_impls = true;\n             write!(implementors, \"{{text:{},synthetic:{},types:{}}},\",\n-                   as_json(&imp.inner_impl().to_string()),\n+                   as_json(&imp.inner_impl().print().to_string()),\n                    imp.inner_impl().synthetic,\n                    as_json(&collect_paths_for_type(imp.inner_impl().for_.clone()))).unwrap();\n         }\n@@ -1212,7 +967,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if !have_impls && !cache.paths.contains_key(&did) {\n+        if !have_impls && !cx.cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1222,7 +977,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.css_class(),\n+                            remote_item_type,\n                             remote_path[remote_path.len() - 1]));\n \n         let (mut all_implementors, _, _) = try_err!(collect(&mydst, &krate.name, \"implementors\",\n@@ -1326,327 +1081,6 @@ fn minify_replacer(\n     }\n }\n \n-/// Attempts to find where an external crate is located, given that we're\n-/// rendering in to the specified source destination.\n-fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n-    -> ExternalLocation\n-{\n-    // See if there's documentation generated into the local directory\n-    let local_location = dst.join(&e.name);\n-    if local_location.is_dir() {\n-        return Local;\n-    }\n-\n-    if let Some(url) = extern_url {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/');\n-        }\n-        return Remote(url);\n-    }\n-\n-    // Failing that, see if there's an attribute specifying where to find this\n-    // external crate\n-    e.attrs.lists(sym::doc)\n-     .filter(|a| a.check_name(sym::html_root_url))\n-     .filter_map(|a| a.value_str())\n-     .map(|url| {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/')\n-        }\n-        Remote(url)\n-    }).next().unwrap_or(Unknown) // Well, at least we tried.\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate) ||\n-               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n-               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors.entry(did).or_default().push(Impl {\n-                        impl_item: item.clone(),\n-                    });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) |\n-                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..) |\n-                clean::TyMethodItem(..) |\n-                clean::StructFieldItem(..) |\n-                clean::VariantItem(..) => {\n-                    ((Some(*self.parent_stack.last().unwrap()),\n-                      Some(&self.stack[..self.stack.len() - 1])),\n-                     false)\n-                }\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().unwrap();\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(ref fqp, ItemType::Trait)) |\n-                            Some(&(ref fqp, ItemType::Struct)) |\n-                            Some(&(ref fqp, ItemType::Union)) |\n-                            Some(&(ref fqp, ItemType::Enum)) =>\n-                                Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false)\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TypedefItem(..) | clean::TraitItem(..) |\n-            clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem |\n-            clean::MacroItem(..) | clean::ProcMacroItem(..)\n-            if !self.stripped_mod => {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id) ||\n-                   self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), item.type_()));\n-                }\n-                self.add_aliases(&item);\n-            }\n-            // Link variants to their parent enum because pages aren't emitted\n-            // for each variant.\n-            clean::VariantItem(..) if !self.stripped_mod => {\n-                let mut stack = self.stack.clone();\n-                stack.pop();\n-                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n-            }\n-\n-            clean::PrimitiveItem(..) if item.visibility.is_some() => {\n-                self.add_aliases(&item);\n-                self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n-            clean::StructItem(..) | clean::UnionItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath{ did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t.primitive_type().and_then(|t| {\n-                            self.primitive_locations.get(&t).cloned()\n-                        });\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. } |\n-                        clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t.primitive_type().and_then(|t| {\n-                                self.primitive_locations.get(&t).cloned()\n-                            });\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl {\n-                    impl_item: item,\n-                };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed { self.stack.pop().unwrap(); }\n-        if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n-impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self.paths.get(&item.def_id)\n-                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                                 .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(sym::doc)\n-                                   .filter(|a| a.check_name(sym::alias))\n-                                   .filter_map(|a| a.value_str()\n-                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                                   .filter(|v| !v.is_empty())\n-                                   .collect::<FxHashSet<_>>()\n-                                   .into_iter() {\n-                self.aliases.entry(alias)\n-                            .or_insert(Vec::with_capacity(1))\n-                            .push(IndexItem {\n-                                ty: item.type_(),\n-                                name: item_name.to_string(),\n-                                path: path.clone(),\n-                                desc: shorten(plain_summary_line(item.doc_value())),\n-                                parent: None,\n-                                parent_idx: None,\n-                                search_type: get_index_search_type(&item),\n-                            });\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,\n@@ -1665,9 +1099,11 @@ impl ItemEntry {\n     }\n }\n \n-impl fmt::Display for ItemEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+impl ItemEntry {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        crate::html::format::display_fn(move |f| {\n+            write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+        })\n     }\n }\n \n@@ -1759,7 +1195,7 @@ fn print_entries(f: &mut Buffer, e: &FxHashSet<ItemEntry>, title: &str, class: &\n                title,\n                Escape(title),\n                class,\n-               e.iter().map(|s| format!(\"<li>{}</li>\", s)).collect::<String>());\n+               e.iter().map(|s| format!(\"<li>{}</li>\", s.print())).collect::<String>());\n     }\n }\n \n@@ -1882,7 +1318,7 @@ impl Context {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = cache().crate_version {\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n             format!(\"<p class='location'>Crate {}</p>\\\n                      <div class='block version'>\\\n                          <p>Version {}</p>\\\n@@ -1939,7 +1375,7 @@ impl Context {\n             title.push_str(it.name.as_ref().unwrap());\n         }\n         title.push_str(\" - Rust\");\n-        let tyname = it.type_().css_class();\n+        let tyname = it.type_();\n         let desc = if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\",\n                     self.shared.layout.krate)\n@@ -1949,7 +1385,7 @@ impl Context {\n         };\n         let keywords = make_item_keywords(it);\n         let page = layout::Page {\n-            css_class: tyname,\n+            css_class: tyname.as_str(),\n             root_path: &self.root_path(),\n             static_root_path: self.shared.static_root_path.as_deref(),\n             title: &title,\n@@ -1972,7 +1408,7 @@ impl Context {\n                            &self.shared.themes)\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -2090,7 +1526,7 @@ impl Context {\n         for item in &m.items {\n             if item.is_stripped() { continue }\n \n-            let short = item.type_().css_class();\n+            let short = item.type_();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -2122,7 +1558,6 @@ impl Context {\n     fn src_href(&self, item: &clean::Item) -> Option<String> {\n         let mut root = self.root_path();\n \n-        let cache = cache();\n         let mut path = String::new();\n \n         // We can safely ignore macros from other libraries\n@@ -2138,7 +1573,7 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&item.def_id.krate)? {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&item.def_id.krate)? {\n                 (ref name, ref src, Local) => (name, src),\n                 (ref name, ref src, Remote(ref s)) => {\n                     root = s.to_string();\n@@ -2267,12 +1702,12 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n         clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(ref p) => item_primitive(buf, cx, item, p),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n             item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n         clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n-        clean::KeywordItem(ref k) => item_keyword(buf, cx, item, k),\n+        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n         clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n         clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n         _ => {\n@@ -2284,8 +1719,8 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n \n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n-        ItemType::Module => format!(\"{}index.html\", SlashChecker(name)),\n-        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n+        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n+        _ => format!(\"{}.{}.html\", ty, name),\n     }\n }\n \n@@ -2353,7 +1788,7 @@ fn render_markdown(\n            if is_hidden { \" hidden\" } else { \"\" },\n            prefix,\n            Markdown(md_text, &links, &mut ids,\n-           cx.codes, cx.edition, &cx.playground).to_string())\n+           cx.shared.codes, cx.shared.edition, &cx.shared.playground).to_string())\n }\n \n fn document_short(\n@@ -2571,13 +2006,13 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, src),\n                                name)\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, name))\n                     }\n                 }\n@@ -2586,7 +2021,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(&myitem.visibility), *import);\n+                       myitem.visibility.print_with_space(), import.print());\n             }\n \n             _ => {\n@@ -2688,7 +2123,7 @@ fn stability_tags(item: &clean::Item) -> String {\n /// documentation.\n fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n-    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let error_codes = cx.shared.codes;\n \n     if let Some(Deprecation { note, since }) = &item.deprecation() {\n         // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n@@ -2710,7 +2145,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();\n-            let html = MarkdownHtml(&note, &mut ids, error_codes, cx.edition, &cx.playground);\n+            let html = MarkdownHtml(\n+                &note, &mut ids, error_codes, cx.shared.edition, &cx.shared.playground);\n             message.push_str(&format!(\": {}\", html.to_string()));\n         }\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n@@ -2763,8 +2199,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n                     &unstable_reason,\n                     &mut ids,\n                     error_codes,\n-                    cx.edition,\n-                    &cx.playground,\n+                    cx.shared.edition,\n+                    &cx.shared.playground,\n                 ).to_string()\n             );\n         }\n@@ -2792,9 +2228,9 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n     render_attributes(w, it, false);\n     write!(w, \"{vis}const \\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n+           vis = it.visibility.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n-           typ = c.type_);\n+           typ = c.type_.print());\n     document(w, cx, it)\n }\n \n@@ -2803,43 +2239,43 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n     render_attributes(w, it, false);\n     write!(w, \"{vis}static {mutability}\\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           mutability = MutableSpace(s.mutability),\n+           vis = it.visibility.print_with_space(),\n+           mutability = s.mutability.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n-           typ = s.type_);\n+           typ = s.type_.print());\n     document(w, cx, it)\n }\n \n fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        VisSpace(&it.visibility),\n-        ConstnessSpace(f.header.constness),\n-        UnsafetySpace(f.header.unsafety),\n-        AsyncSpace(f.header.asyncness),\n-        AbiSpace(f.header.abi),\n+        it.visibility.print_with_space(),\n+        f.header.constness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics\n+        f.generics.print()\n     ).len();\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it));\n     render_attributes(w, it, false);\n     write!(w,\n            \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n            {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           constness = ConstnessSpace(f.header.constness),\n-           unsafety = UnsafetySpace(f.header.unsafety),\n-           asyncness = AsyncSpace(f.header.asyncness),\n-           abi = AbiSpace(f.header.abi),\n+           vis = it.visibility.print_with_space(),\n+           constness = f.header.constness.print_with_space(),\n+           unsafety = f.header.unsafety.print_with_space(),\n+           asyncness = f.header.asyncness.print_with_space(),\n+           abi = print_abi_with_space(f.header.abi),\n            name = it.name.as_ref().unwrap(),\n-           generics = f.generics,\n+           generics = f.generics.print(),\n            where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n            decl = Function {\n               decl: &f.decl,\n               header_len,\n               indent: 0,\n               asyncness: f.header.asyncness,\n-           });\n+           }.print());\n     document(w, cx, it)\n }\n \n@@ -2880,15 +2316,15 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&(*p).to_string());\n+            bounds.push_str(&p.print().to_string());\n         }\n     }\n     bounds\n }\n \n fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl());\n-    let rhs = format!(\"{}\", rhs.inner_impl());\n+    let lhs = format!(\"{}\", lhs.inner_impl().print());\n+    let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n     name_key(&lhs).cmp(&name_key(&rhs))\n@@ -2911,11 +2347,11 @@ fn item_trait(\n         write!(w, \"<pre class='rust trait'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}{}{}trait {}{}{}\",\n-               VisSpace(&it.visibility),\n-               UnsafetySpace(t.unsafety),\n+               it.visibility.print_with_space(),\n+               t.unsafety.print_with_space(),\n                if t.is_auto { \"auto \" } else { \"\" },\n                it.name.as_ref().unwrap(),\n-               t.generics,\n+               t.generics.print(),\n                bounds);\n \n         if !t.generics.where_predicates.is_empty() {\n@@ -3047,11 +2483,9 @@ fn item_trait(\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n-    let cache = cache();\n-\n     let mut synthetic_types = Vec::new();\n \n-    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -3074,7 +2508,7 @@ fn item_trait(\n \n         let (local, foreign) = implementors.iter()\n             .partition::<Vec<_>, _>(|i| i.inner_impl().for_.def_id()\n-                                         .map_or(true, |d| cache.paths.contains_key(&d)));\n+                                         .map_or(true, |d| cx.cache.paths.contains_key(&d)));\n \n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) = local.iter()\n@@ -3139,10 +2573,10 @@ fn item_trait(\n            path = if it.def_id.is_local() {\n                cx.current.join(\"/\")\n            } else {\n-               let (ref path, _) = cache.external_paths[&it.def_id];\n+               let (ref path, _) = cx.cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = it.type_().css_class(),\n+           ty = it.type_(),\n            name = *it.name.as_ref().unwrap());\n }\n \n@@ -3173,10 +2607,10 @@ fn assoc_const(w: &mut Buffer,\n                extra: &str) {\n     write!(w, \"{}{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            extra,\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n-           ty);\n+           ty.print());\n }\n \n fn assoc_type(w: &mut Buffer, it: &clean::Item,\n@@ -3189,10 +2623,10 @@ fn assoc_type(w: &mut Buffer, it: &clean::Item,\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap());\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", GenericBounds(bounds))\n+        write!(w, \": {}\", print_generic_bounds(bounds))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)\n+        write!(w, \" = {}\", default.print())\n     }\n }\n \n@@ -3238,14 +2672,14 @@ fn render_assoc_item(w: &mut Buffer,\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            VisSpace(&meth.visibility),\n-            ConstnessSpace(header.constness),\n-            UnsafetySpace(header.unsafety),\n-            AsyncSpace(header.asyncness),\n-            DefaultSpace(meth.is_default()),\n-            AbiSpace(header.abi),\n+            meth.visibility.print_with_space(),\n+            header.constness.print_with_space(),\n+            header.unsafety.print_with_space(),\n+            header.asyncness.print_with_space(),\n+            print_default_space(meth.is_default()),\n+            print_abi_with_space(header.abi),\n             name,\n-            *g\n+            g.print()\n         ).len();\n         let (indent, end_newline) = if parent == ItemType::Trait {\n             header_len += 4;\n@@ -3257,21 +2691,21 @@ fn render_assoc_item(w: &mut Buffer,\n         write!(w, \"{}{}{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                if parent == ItemType::Trait { \"    \" } else { \"\" },\n-               VisSpace(&meth.visibility),\n-               ConstnessSpace(header.constness),\n-               UnsafetySpace(header.unsafety),\n-               AsyncSpace(header.asyncness),\n-               DefaultSpace(meth.is_default()),\n-               AbiSpace(header.abi),\n+               meth.visibility.print_with_space(),\n+               header.constness.print_with_space(),\n+               header.unsafety.print_with_space(),\n+               header.asyncness.print_with_space(),\n+               print_default_space(meth.is_default()),\n+               print_abi_with_space(header.abi),\n                href = href,\n                name = name,\n-               generics = *g,\n+               generics = g.print(),\n                decl = Function {\n                    decl: d,\n                    header_len,\n                    indent,\n                    asyncness: header.asyncness,\n-               },\n+               }.print(),\n                where_clause = WhereClause {\n                    gens: g,\n                    indent,\n@@ -3340,7 +2774,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n                        id = id,\n                        ns_id = ns_id,\n                        name = field.name.as_ref().unwrap(),\n-                       ty = ty);\n+                       ty = ty.print());\n                 document(w, cx, field);\n             }\n         }\n@@ -3381,7 +2815,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n                    id = id,\n                    name = name,\n                    shortty = ItemType::StructField,\n-                   ty = ty);\n+                   ty = ty.print());\n             if let Some(stability_class) = field.stability_class() {\n                 write!(w, \"<span class='stab {stab}'></span>\",\n                     stab = stability_class);\n@@ -3397,9 +2831,9 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}enum {}{}{}\",\n-               VisSpace(&it.visibility),\n+               it.visibility.print_with_space(),\n                it.name.as_ref().unwrap(),\n-               e.generics,\n+               e.generics.print(),\n                WhereClause { gens: &e.generics, indent: 0, end_newline: true });\n         if e.variants.is_empty() && !e.variants_stripped {\n             write!(w, \" {{}}\");\n@@ -3418,7 +2852,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                     if i > 0 {\n                                         write!(w, \",&nbsp;\")\n                                     }\n-                                    write!(w, \"{}\", *ty);\n+                                    write!(w, \"{}\", ty.print());\n                                 }\n                                 write!(w, \")\");\n                             }\n@@ -3472,7 +2906,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                         if i > 0 {\n                             write!(w, \",&nbsp;\");\n                         }\n-                        write!(w, \"{}\", *ty);\n+                        write!(w, \"{}\", ty.print());\n                     }\n                     write!(w, \")\");\n                 }\n@@ -3510,7 +2944,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                id = id,\n                                ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n-                               t = *ty);\n+                               t = ty.print());\n                         document(w, cx, field);\n                     }\n                 }\n@@ -3586,11 +3020,11 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g)\n+        write!(w, \"{}\", g.print())\n     }\n     match ty {\n         doctree::Plain => {\n@@ -3603,9 +3037,9 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"\\n{}    {}{}: {},\",\n                            tab,\n-                           VisSpace(&field.visibility),\n+                           field.visibility.print_with_space(),\n                            field.name.as_ref().unwrap(),\n-                           *ty);\n+                           ty.print());\n                     has_visible_fields = true;\n                 }\n             }\n@@ -3633,7 +3067,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                         write!(w, \"_\")\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)\n+                        write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n                     }\n                     _ => unreachable!()\n                 }\n@@ -3660,21 +3094,21 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n                 tab: &str,\n                 structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g);\n+        write!(w, \"{}\", g.print());\n         write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true });\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n         if let clean::StructFieldItem(ref ty) = field.inner {\n             write!(w, \"    {}{}: {},\\n{}\",\n-                   VisSpace(&field.visibility),\n+                   field.visibility.print_with_space(),\n                    field.name.as_ref().unwrap(),\n-                   *ty,\n+                   ty.print(),\n                    tab);\n         }\n     }\n@@ -3716,7 +3150,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       containing_item: &clean::Item,\n                       it: DefId,\n                       what: AssocItemRender<'_>) {\n-    let c = cache();\n+    let c = &cx.cache;\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n@@ -3740,7 +3174,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       Methods from {}&lt;Target = {}&gt;\\\n                       <a href='#deref-methods' class='anchor'></a>\\\n                     </h2>\\\n-                \", trait_, type_);\n+                \", trait_.print(), type_.print());\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n@@ -3822,7 +3256,7 @@ fn render_deref_methods(w: &mut Buffer, cx: &Context, impl_: &Impl,\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cache().primitive_locations.get(&prim) {\n+            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n@@ -3856,19 +3290,15 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n }\n \n fn render_spotlight_traits(item: &clean::Item) -> String {\n-    let mut out = String::new();\n-\n     match item.inner {\n         clean::FunctionItem(clean::Function { ref decl, .. }) |\n         clean::TyMethodItem(clean::TyMethod { ref decl, .. }) |\n         clean::MethodItem(clean::Method { ref decl, .. }) |\n         clean::ForeignFunctionItem(clean::Function { ref decl, .. }) => {\n-            out = spotlight_decl(decl);\n+            spotlight_decl(decl)\n         }\n-        _ => {}\n+        _ => String::new()\n     }\n-\n-    out\n }\n \n fn spotlight_decl(decl: &clean::FnDecl) -> String {\n@@ -3885,12 +3315,13 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                         out.push_str(\n                             &format!(\"<h3 class=\\\"important\\\">Important traits for {}</h3>\\\n                                       <code class=\\\"content\\\">\",\n-                                     impl_.for_));\n-                        trait_.push_str(&impl_.for_.to_string());\n+                                     impl_.for_.print()));\n+                        trait_.push_str(&impl_.for_.print().to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n-                    out.push_str(&format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_));\n+                    out.push_str(\n+                        &format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_.print()));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = it.inner {\n@@ -3927,7 +3358,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             Some(ref t) => if is_on_foreign_type {\n                 get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t)\n             } else {\n-                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t)))\n+                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print())))\n             },\n             None => \"impl\".to_string(),\n         });\n@@ -3948,7 +3379,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             write!(w, \"</code>\");\n         } else {\n             write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n-                id, i.inner_impl()\n+                id, i.inner_impl().print()\n             );\n         }\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n@@ -3963,7 +3394,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n                    Markdown(&*dox, &i.impl_item.links(), &mut ids,\n-                            cx.codes, cx.edition, &cx.playground).to_string());\n+                            cx.shared.codes, cx.shared.edition, &cx.shared.playground).to_string());\n         }\n     }\n \n@@ -3974,7 +3405,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n-        let render_method_item: bool = match render_mode {\n+        let render_method_item = match render_mode {\n             RenderMode::Normal => true,\n             RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n         };\n@@ -3993,8 +3424,10 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\",\n+                            name, item_type.name_space()));\n+                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\",\n+                        id, item_type, extra_class);\n                     write!(w, \"{}\", spotlight_decl(decl));\n                     write!(w, \"<code id='{}'>\", ns_id);\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n@@ -4041,7 +3474,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n-        if render_method_item || render_mode == RenderMode::Normal {\n+        if render_method_item {\n             if !is_default_item {\n                 if let Some(t) = trait_ {\n                     // The trait item may have been stripped so we might not\n@@ -4073,7 +3506,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n         }\n     }\n \n-    let traits = &cache().traits;\n+    let traits = &cx.cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -4125,7 +3558,7 @@ fn item_opaque_ty(\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = impl {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds = bounds(&t.bounds, false));\n \n@@ -4144,7 +3577,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item,\n     render_attributes(w, it, false);\n     write!(w, \"trait {}{}{} = {};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds(&t.bounds, true));\n \n@@ -4162,9 +3595,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           type_ = t.type_);\n+           type_ = t.type_.print());\n \n     document(w, cx, it);\n \n@@ -4181,7 +3614,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        VisSpace(&it.visibility),\n+        it.visibility.print_with_space(),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -4215,7 +3648,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cache().crate_version {\n+        if let Some(ref version) = cx.cache.crate_version {\n             write!(buffer,\n                     \"<div class='block version'>\\\n                     <p>Version {}</p>\\\n@@ -4232,11 +3665,11 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     match it.inner {\n         clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n         clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n-        clean::PrimitiveItem(ref p) => sidebar_primitive(buffer, it, p),\n+        clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n         clean::UnionItem(ref u) => sidebar_union(buffer, it, u),\n         clean::EnumItem(ref e) => sidebar_enum(buffer, it, e),\n-        clean::TypedefItem(ref t, _) => sidebar_typedef(buffer, it, t),\n-        clean::ModuleItem(ref m) => sidebar_module(buffer, it, &m.items),\n+        clean::TypedefItem(_, _) => sidebar_typedef(buffer, it),\n+        clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n         clean::ForeignTypeItem => sidebar_foreign_type(buffer, it),\n         _ => (),\n     }\n@@ -4269,7 +3702,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n                 relpath: '{path}'\\\n             }};</script>\",\n             name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-            ty = it.type_().css_class(),\n+            ty = it.type_(),\n             path = relpath);\n     if parentlen == 0 {\n         // There is no sidebar-items.js beyond the crate root path\n@@ -4301,8 +3734,7 @@ fn get_methods(\n ) -> Vec<String> {\n     i.items.iter().filter_map(|item| {\n         match item.name {\n-            // Maybe check with clean::Visibility::Public as well?\n-            Some(ref name) if !name.is_empty() && item.visibility.is_some() && item.is_method() => {\n+            Some(ref name) if !name.is_empty() && item.is_method() => {\n                 if !for_deref || should_render_item(item, deref_mut) {\n                     Some(format!(\"<a href=\\\"#{}\\\">{}</a>\",\n                                  get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -4339,12 +3771,12 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n         let mut used_links = FxHashSet::default();\n \n         {\n-            let used_links_bor = Rc::new(RefCell::new(&mut used_links));\n+            let used_links_bor = &mut used_links;\n             let mut ret = v.iter()\n                            .filter(|i| i.inner_impl().trait_.is_none())\n                            .flat_map(move |i| get_methods(i.inner_impl(),\n                                                           false,\n-                                                          &mut used_links_bor.borrow_mut(), false))\n+                                                          used_links_bor, false))\n                            .collect::<Vec<_>>();\n             // We want links' order to be reproducible so we don't use unstable sort.\n             ret.sort();\n@@ -4370,9 +3802,10 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     if let Some(impls) = inner_impl {\n                         out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n                         out.push_str(&format!(\"Methods from {}&lt;Target={}&gt;\",\n-                                              Escape(&format!(\"{:#}\",\n-                                                     impl_.inner_impl().trait_.as_ref().unwrap())),\n-                                              Escape(&format!(\"{:#}\", target))));\n+                            Escape(&format!(\n+                                \"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print()\n+                            )),\n+                            Escape(&format!(\"{:#}\", target.print()))));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls.iter()\n                                            .filter(|i| i.inner_impl().trait_.is_none())\n@@ -4397,9 +3830,9 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     .filter_map(|i| {\n                         let is_negative_impl = is_negative_impl(i.inner_impl());\n                         if let Some(ref i) = i.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i);\n+                            let i_display = format!(\"{:#}\", i.print());\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(&format!(\"{:#}\", i));\n+                            let encoded = small_url_encode(&format!(\"{:#}\", i.print()));\n                             let generated = format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                                     encoded,\n                                                     if is_negative_impl { \"!\" } else { \"\" },\n@@ -4471,14 +3904,17 @@ fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n }\n \n fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) -> String {\n-    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_, for_))\n+    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(), for_.print()))\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n     match item.inner {\n         clean::ItemEnum::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n-                Some((format!(\"{:#}\", i.for_), get_id_for_impl_on_foreign_type(&i.for_, trait_)))\n+                Some((\n+                    format!(\"{:#}\", i.for_.print()),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_),\n+                ))\n             } else {\n                 None\n             }\n@@ -4602,15 +4038,15 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n-fn sidebar_primitive(buf: &mut Buffer, it: &clean::Item, _p: &clean::PrimitiveType) {\n+fn sidebar_primitive(buf: &mut Buffer, it: &clean::Item) {\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n     }\n }\n \n-fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item, _t: &clean::Typedef) {\n+fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n@@ -4702,7 +4138,7 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n     }\n }\n \n-fn sidebar_module(buf: &mut Buffer, _it: &clean::Item, items: &[clean::Item]) {\n+fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n     let mut sidebar = String::new();\n \n     if items.iter().any(|it| it.type_() == ItemType::ExternCrate ||\n@@ -4780,16 +4216,12 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context,\n-                  it: &clean::Item,\n-                  _p: &clean::PrimitiveType) {\n+fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     document(w, cx, it);\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut Buffer, cx: &Context,\n-                it: &clean::Item,\n-                _p: &str) {\n+fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     document(w, cx, it)\n }\n \n@@ -4799,37 +4231,6 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n-        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        _ => return None,\n-    };\n-\n-    let inputs = all_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect();\n-    let output = ret_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n-    let output = if output.is_empty() {\n-        None\n-    } else {\n-        Some(output)\n-    };\n-\n-    Some(IndexItemFunctionType { inputs, output })\n-}\n-\n-fn get_index_type(clean_type: &clean::Type) -> Type {\n-    let t = Type {\n-        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n-        generics: get_generics(clean_type),\n-    };\n-    t\n-}\n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained\n@@ -4887,39 +4288,6 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     out\n }\n \n-fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n-    match *clean_type {\n-        clean::ResolvedPath { ref path, .. } => {\n-            let segments = &path.segments;\n-            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n-                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n-                clean_type, accept_generic\n-            ));\n-            Some(path_segment.name.clone())\n-        }\n-        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n-        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n-        // FIXME: add all from clean::Type.\n-        _ => None\n-    }\n-}\n-\n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n-    clean_type.generics()\n-              .and_then(|types| {\n-                  let r = types.iter()\n-                               .filter_map(|t| get_index_type_name(t, false))\n-                               .map(|s| s.to_ascii_lowercase())\n-                               .collect::<Vec<_>>();\n-                  if r.is_empty() {\n-                      None\n-                  } else {\n-                      Some(r)\n-                  }\n-              })\n-}\n-\n-pub fn cache() -> Arc<Cache> {\n+crate fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "65dd119c27cb7e958d78dddcf2d9eaef91271d33", "filename": "src/librustdoc/html/render/cache.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -0,0 +1,675 @@\n+use crate::clean::{self, GetDefId, AttributesExt};\n+use crate::fold::DocFolder;\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::middle::privacy::AccessLevels;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::collections::BTreeMap;\n+use syntax::source_map::FileName;\n+use syntax::symbol::sym;\n+use serialize::json::{ToJson, Json, as_json};\n+\n+use super::{ItemType, IndexItem, IndexItemFunctionType, Impl, shorten, plain_summary_line};\n+use super::{Type, RenderInfo};\n+\n+/// Indicates where an external crate can be found.\n+pub enum ExternalLocation {\n+    /// Remote URL root of the external crate\n+    Remote(String),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n+}\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+crate struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    search_index: Vec<IndexItem>,\n+    stripped_mod: bool,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        renderinfo: RenderInfo,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, String, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+        } = renderinfo;\n+\n+        let external_paths = external_paths.into_iter()\n+            .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n+            .collect();\n+\n+        let mut cache = Cache {\n+            impls: Default::default(),\n+            external_paths,\n+            exact_paths,\n+            paths: Default::default(),\n+            implementors: Default::default(),\n+            stack: Vec::new(),\n+            parent_stack: Vec::new(),\n+            search_index: Vec::new(),\n+            parent_is_trait_impl: false,\n+            extern_locations: Default::default(),\n+            primitive_locations: Default::default(),\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            orphan_impl_items: Vec::new(),\n+            orphan_trait_impls: Vec::new(),\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            aliases: Default::default(),\n+        };\n+\n+        // Cache where all our extern crates are located\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache.extern_locations.insert(n, (e.name.clone(), src_root,\n+                                            extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache);\n+\n+        (krate, index, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate) ||\n+               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n+               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors.entry(did).or_default().push(Impl {\n+                        impl_item: item.clone(),\n+                    });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) |\n+                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..) |\n+                clean::TyMethodItem(..) |\n+                clean::StructFieldItem(..) |\n+                clean::VariantItem(..) => {\n+                    ((Some(*self.parent_stack.last().unwrap()),\n+                      Some(&self.stack[..self.stack.len() - 1])),\n+                     false)\n+                }\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().unwrap();\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(ref fqp, ItemType::Trait)) |\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Union)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n+                                Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false)\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TypedefItem(..) | clean::TraitItem(..) |\n+            clean::FunctionItem(..) | clean::ModuleItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::StaticItem(..) |\n+            clean::UnionItem(..) | clean::ForeignTypeItem |\n+            clean::MacroItem(..) | clean::ProcMacroItem(..)\n+            if !self.stripped_mod => {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id) ||\n+                   self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id,\n+                                      (self.stack.clone(), item.type_()));\n+                }\n+                self.add_aliases(&item);\n+            }\n+            // Link variants to their parent enum because pages aren't emitted\n+            // for each variant.\n+            clean::VariantItem(..) if !self.stripped_mod => {\n+                let mut stack = self.stack.clone();\n+                stack.pop();\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n+            }\n+\n+            clean::PrimitiveItem(..) => {\n+                self.add_aliases(&item);\n+                self.paths.insert(item.def_id, (self.stack.clone(),\n+                                                item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n+            clean::StructItem(..) | clean::UnionItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath{ did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).cloned()\n+                        });\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).cloned()\n+                            });\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl {\n+                    impl_item: item,\n+                };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().unwrap();\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed { self.stack.pop().unwrap(); }\n+        if parent_pushed { self.parent_stack.pop().unwrap(); }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+impl Cache {\n+    fn add_aliases(&mut self, item: &clean::Item) {\n+        if item.def_id.index == CRATE_DEF_INDEX {\n+            return\n+        }\n+        if let Some(ref item_name) = item.name {\n+            let path = self.paths.get(&item.def_id)\n+                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n+                                 .unwrap_or(\"std\".to_owned());\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n+                                   .filter_map(|a| a.value_str()\n+                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+                                   .filter(|v| !v.is_empty())\n+                                   .collect::<FxHashSet<_>>()\n+                                   .into_iter() {\n+                self.aliases.entry(alias)\n+                            .or_insert(Vec::with_capacity(1))\n+                            .push(IndexItem {\n+                                ty: item.type_(),\n+                                name: item_name.to_string(),\n+                                path: path.clone(),\n+                                desc: shorten(plain_summary_line(item.doc_value())),\n+                                parent: None,\n+                                parent_idx: None,\n+                                search_type: get_index_search_type(&item),\n+                            });\n+            }\n+        }\n+    }\n+}\n+\n+/// Attempts to find where an external crate is located, given that we're\n+/// rendering in to the specified source destination.\n+fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n+    -> ExternalLocation\n+{\n+    use ExternalLocation::*;\n+    // See if there's documentation generated into the local directory\n+    let local_location = dst.join(&e.name);\n+    if local_location.is_dir() {\n+        return Local;\n+    }\n+\n+    if let Some(url) = extern_url {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/');\n+        }\n+        return Remote(url);\n+    }\n+\n+    // Failing that, see if there's an attribute specifying where to find this\n+    // external crate\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n+     .filter_map(|a| a.value_str())\n+     .map(|url| {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/')\n+        }\n+        Remote(url)\n+    }).next().unwrap_or(Unknown) // Well, at least we tried.\n+}\n+\n+/// Builds the search index from the collected metadata\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+    let mut nodeid_to_pathid = FxHashMap::default();\n+    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n+    let mut crate_paths = Vec::<Json>::new();\n+\n+    let Cache { ref mut search_index,\n+                ref orphan_impl_items,\n+                ref paths, .. } = *cache;\n+\n+    // Attach all orphan items to the type's definition if the type\n+    // has since been learned.\n+    for &(did, ref item) in orphan_impl_items {\n+        if let Some(&(ref fqp, _)) = paths.get(&did) {\n+            search_index.push(IndexItem {\n+                ty: item.type_(),\n+                name: item.name.clone().unwrap(),\n+                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                desc: shorten(plain_summary_line(item.doc_value())),\n+                parent: Some(did),\n+                parent_idx: None,\n+                search_type: get_index_search_type(&item),\n+            });\n+        }\n+    }\n+\n+    // Reduce `NodeId` in paths into smaller sequential numbers,\n+    // and prune the paths that do not appear in the index.\n+    let mut lastpath = String::new();\n+    let mut lastpathid = 0usize;\n+\n+    for item in search_index {\n+        item.parent_idx = item.parent.map(|nodeid| {\n+            if nodeid_to_pathid.contains_key(&nodeid) {\n+                *nodeid_to_pathid.get(&nodeid).unwrap()\n+            } else {\n+                let pathid = lastpathid;\n+                nodeid_to_pathid.insert(nodeid, pathid);\n+                lastpathid += 1;\n+\n+                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n+                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                pathid\n+            }\n+        });\n+\n+        // Omit the parent path if it is same to that of the prior item.\n+        if lastpath == item.path {\n+            item.path.clear();\n+        } else {\n+            lastpath = item.path.clone();\n+        }\n+        crate_items.push(item.to_json());\n+    }\n+\n+    let crate_doc = krate.module.as_ref().map(|module| {\n+        shorten(plain_summary_line(module.doc_value()))\n+    }).unwrap_or(String::new());\n+\n+    let mut crate_data = BTreeMap::new();\n+    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n+    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n+    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n+\n+    // Collect the index into a string\n+    format!(\"searchIndex[{}] = {};\",\n+            as_json(&krate.name),\n+            Json::Object(crate_data))\n+}\n+\n+fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        _ => return None,\n+    };\n+\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect();\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n+    };\n+\n+    Some(IndexItemFunctionType { inputs, output })\n+}\n+\n+fn get_index_type(clean_type: &clean::Type) -> Type {\n+    let t = Type {\n+        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n+        generics: get_generics(clean_type),\n+    };\n+    t\n+}\n+\n+fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n+    match *clean_type {\n+        clean::ResolvedPath { ref path, .. } => {\n+            let segments = &path.segments;\n+            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n+                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n+                clean_type, accept_generic\n+            ));\n+            Some(path_segment.name.clone())\n+        }\n+        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n+        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n+        // FIXME: add all from clean::Type.\n+        _ => None\n+    }\n+}\n+\n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+    clean_type.generics()\n+              .and_then(|types| {\n+                  let r = types.iter()\n+                               .filter_map(|t| get_index_type_name(t, false))\n+                               .map(|s| s.to_ascii_lowercase())\n+                               .collect::<Vec<_>>();\n+                  if r.is_empty() {\n+                      None\n+                  } else {\n+                      Some(r)\n+                  }\n+              })\n+}"}, {"sha": "0fb2f8dd7962ab09774069176b92b7cec5bc500d", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -1,10 +1,7 @@\n //! Table-of-contents creation.\n \n-use std::fmt;\n-use std::string::String;\n-\n /// A (recursive) table of contents\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n@@ -28,7 +25,7 @@ impl Toc {\n     }\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct TocEntry {\n     level: u32,\n     sec_number: String,\n@@ -165,25 +162,23 @@ impl TocBuilder {\n     }\n }\n \n-impl fmt::Debug for Toc {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for Toc {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"<ul>\")?;\n+impl Toc {\n+    fn print_inner(&self, v: &mut String) {\n+        v.push_str(\"<ul>\");\n         for entry in &self.entries {\n-            // recursively format this table of contents (the\n-            // `{children}` is the key).\n-            write!(fmt,\n-                   \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>{children}</li>\",\n+            // recursively format this table of contents\n+            v.push_str(&format!(\"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>\",\n                    id = entry.id,\n-                   num = entry.sec_number, name = entry.name,\n-                   children = entry.children)?\n+                   num = entry.sec_number, name = entry.name));\n+            entry.children.print_inner(&mut *v);\n+            v.push_str(\"</li>\");\n         }\n-        write!(fmt, \"</ul>\")\n+        v.push_str(\"</ul>\");\n+    }\n+    crate fn print(&self) -> String {\n+        let mut v = String::new();\n+        self.print_inner(&mut v);\n+        v\n     }\n }\n "}, {"sha": "dc1ca8d7668ae156aec2316eb1958d6e18552cf4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -142,7 +142,8 @@ impl fold::DocFolder for CoverageCalculator {\n             }\n             clean::ImplItem(ref impl_) => {\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\"impl {:#} for {:#} in {}\", tr, impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} for {:#} in {}\",\n+                        tr.print(), impl_.for_.print(), i.source.filename);\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -151,11 +152,11 @@ impl fold::DocFolder for CoverageCalculator {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(), i.source.filename);\n                 }\n             }\n             _ => {\n-                debug!(\"counting {} {:?} in {}\", i.type_(), i.name, i.source.filename);\n+                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n                 self.items.entry(i.source.filename.clone())\n                           .or_default()\n                           .count_item(has_docs);"}, {"sha": "b67f39d328015962fa245dd73bac70f554701284", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         if parent_node.is_some() {\n-            debug!(\"got parent node for {} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            debug!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         let current_item = match item.inner {"}, {"sha": "f6560218a78c82935454dd7b9d5fa88529b576b7", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -153,7 +153,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n                 // items to the `retained` set.\n-                debug!(\"Stripper: recursing into stripped {} {:?}\", i.type_(), i.name);\n+                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n                 let old = mem::replace(&mut self.update_retained, false);\n                 let ret = self.fold_item_recur(i);\n                 self.update_retained = old;\n@@ -178,20 +178,20 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n-                        debug!(\"Stripper: stripping {} {:?}\", i.type_(), i.name);\n+                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n                 }\n             }\n \n             clean::StructFieldItem(..) => {\n-                if i.visibility != Some(clean::Public) {\n+                if i.visibility != clean::Public {\n                     return StripItem(i).strip();\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                if i.def_id.is_local() && i.visibility != clean::Public {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n@@ -299,7 +299,7 @@ impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ExternCrateItem(..) | clean::ImportItem(..)\n-                if i.visibility != Some(clean::Public) =>\n+                if i.visibility != clean::Public =>\n             {\n                 None\n             }"}, {"sha": "0159e03f6f2997c41a287a97fcae11a07a62a7a4", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a58b14db5ed21654e952f051af2a6c51dfb15fd/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=4a58b14db5ed21654e952f051af2a6c51dfb15fd", "patch": "@@ -39,7 +39,7 @@ struct Stripper<'a> {\n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n-            debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n+            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {"}]}