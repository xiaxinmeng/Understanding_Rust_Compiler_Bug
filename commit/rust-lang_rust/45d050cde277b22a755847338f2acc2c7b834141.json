{"sha": "45d050cde277b22a755847338f2acc2c7b834141", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDA1MGNkZTI3N2IyMmE3NTU4NDczMzhmMmFjYzJjN2I4MzQxNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-21T08:58:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-21T08:58:44Z"}, "message": "Auto merge of #71170 - spastorino:dyn-fnonce-alignment, r=nikomatsakis\n\nMake Box<dyn FnOnce> respect self alignment\n\nCloses #68304\n\nr? @eddyb @nikomatsakis", "tree": {"sha": "90fb0f78cf09d11457d8835b168ba7edfcad9e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90fb0f78cf09d11457d8835b168ba7edfcad9e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d050cde277b22a755847338f2acc2c7b834141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d050cde277b22a755847338f2acc2c7b834141", "html_url": "https://github.com/rust-lang/rust/commit/45d050cde277b22a755847338f2acc2c7b834141", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d050cde277b22a755847338f2acc2c7b834141/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f070d1edf3d54d8933e00eeac95ce55ca8eabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f070d1edf3d54d8933e00eeac95ce55ca8eabb", "html_url": "https://github.com/rust-lang/rust/commit/25f070d1edf3d54d8933e00eeac95ce55ca8eabb"}, {"sha": "4e53a9af4725222a617900aac0680f1a472255ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e53a9af4725222a617900aac0680f1a472255ec", "html_url": "https://github.com/rust-lang/rust/commit/4e53a9af4725222a617900aac0680f1a472255ec"}], "stats": {"total": 182, "additions": 166, "deletions": 16}, "files": [{"sha": "9a75f3afe8f082bccffe7e60cc0d895c4400f37d", "filename": "src/librustc_mir_build/build/expr/as_operand.rs", "status": "modified", "additions": 129, "deletions": 3, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -10,9 +10,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Returns an operand suitable for use until the end of the current\n     /// scope expression.\n     ///\n-    /// The operand returned from this function will *not be valid* after\n-    /// an ExprKind::Scope is passed, so please do *not* return it from\n-    /// functions to avoid bad miscompiles.\n+    /// The operand returned from this function will *not be valid*\n+    /// after the current enclosing `ExprKind::Scope` has ended, so\n+    /// please do *not* return it from functions to avoid bad\n+    /// miscompiles.\n     crate fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -21,6 +22,66 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.as_operand(block, local_scope, expr)\n     }\n \n+    /// Returns an operand suitable for use until the end of the current scope expression and\n+    /// suitable also to be passed as function arguments.\n+    ///\n+    /// The operand returned from this function will *not be valid* after an ExprKind::Scope is\n+    /// passed, so please do *not* return it from functions to avoid bad miscompiles.  Returns an\n+    /// operand suitable for use as a call argument. This is almost always equivalent to\n+    /// `as_operand`, except for the particular case of passing values of (potentially) unsized\n+    /// types \"by value\" (see details below).\n+    ///\n+    /// The operand returned from this function will *not be valid*\n+    /// after the current enclosing `ExprKind::Scope` has ended, so\n+    /// please do *not* return it from functions to avoid bad\n+    /// miscompiles.\n+    ///\n+    /// # Parameters of unsized types\n+    ///\n+    /// We tweak the handling of parameters of unsized type slightly to avoid the need to create a\n+    /// local variable of unsized type. For example, consider this program:\n+    ///\n+    /// ```rust\n+    /// fn foo(p: dyn Debug) { ... }\n+    ///\n+    /// fn bar(box_p: Box<dyn Debug>) { foo(*p); }\n+    /// ```\n+    ///\n+    /// Ordinarily, for sized types, we would compile the call `foo(*p)` like so:\n+    ///\n+    /// ```rust\n+    /// let tmp0 = *box_p; // tmp0 would be the operand returned by this function call\n+    /// foo(tmp0)\n+    /// ```\n+    ///\n+    /// But because the parameter to `foo` is of the unsized type `dyn Debug`, and because it is\n+    /// being moved the deref of a box, we compile it slightly differently. The temporary `tmp0`\n+    /// that we create *stores the entire box*, and the parameter to the call itself will be\n+    /// `*tmp0`:\n+    ///\n+    /// ```rust\n+    /// let tmp0 = box_p; call foo(*tmp0)\n+    /// ```\n+    ///\n+    /// This way, the temporary `tmp0` that we create has type `Box<dyn Debug>`, which is sized.\n+    /// The value passed to the call (`*tmp0`) still has the `dyn Debug` type -- but the way that\n+    /// calls are compiled means that this parameter will be passed \"by reference\", meaning that we\n+    /// will actually provide a pointer to the interior of the box, and not move the `dyn Debug`\n+    /// value to the stack.\n+    ///\n+    /// See #68034 for more details.\n+    crate fn as_local_call_operand<M>(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: M,\n+    ) -> BlockAnd<Operand<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let local_scope = self.local_scope();\n+        self.as_call_operand(block, local_scope, expr)\n+    }\n+\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is a place like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n@@ -40,6 +101,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.expr_as_operand(block, scope, expr)\n     }\n \n+    /// Like `as_local_call_operand`, except that the argument will\n+    /// not be valid once `scope` ends.\n+    fn as_call_operand<M>(\n+        &mut self,\n+        block: BasicBlock,\n+        scope: Option<region::Scope>,\n+        expr: M,\n+    ) -> BlockAnd<Operand<'tcx>>\n+    where\n+        M: Mirror<'tcx, Output = Expr<'tcx>>,\n+    {\n+        let expr = self.hir.mirror(expr);\n+        self.expr_as_call_operand(block, scope, expr)\n+    }\n+\n     fn expr_as_operand(\n         &mut self,\n         mut block: BasicBlock,\n@@ -69,4 +145,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn expr_as_call_operand(\n+        &mut self,\n+        mut block: BasicBlock,\n+        scope: Option<region::Scope>,\n+        expr: Expr<'tcx>,\n+    ) -> BlockAnd<Operand<'tcx>> {\n+        debug!(\"expr_as_call_operand(block={:?}, expr={:?})\", block, expr);\n+        let this = self;\n+\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+            let source_info = this.source_info(expr.span);\n+            let region_scope = (region_scope, source_info);\n+            return this.in_scope(region_scope, lint_level, |this| {\n+                this.as_call_operand(block, scope, value)\n+            });\n+        }\n+\n+        let tcx = this.hir.tcx();\n+\n+        if tcx.features().unsized_locals {\n+            let ty = expr.ty;\n+            let span = expr.span;\n+            let param_env = this.hir.param_env;\n+\n+            if !ty.is_sized(tcx.at(span), param_env) {\n+                // !sized means !copy, so this is an unsized move\n+                assert!(!ty.is_copy_modulo_regions(tcx, param_env, span));\n+\n+                // As described above, detect the case where we are passing a value of unsized\n+                // type, and that value is coming from the deref of a box.\n+                if let ExprKind::Deref { ref arg } = expr.kind {\n+                    let arg = this.hir.mirror(arg.clone());\n+\n+                    // Generate let tmp0 = arg0\n+                    let operand = unpack!(block = this.as_temp(block, scope, arg, Mutability::Mut));\n+\n+                    // Return the operand *tmp0 to be used as the call argument\n+                    let place = Place {\n+                        local: operand,\n+                        projection: tcx.intern_place_elems(&[PlaceElem::Deref]),\n+                    };\n+\n+                    return block.and(Operand::Move(place));\n+                }\n+            }\n+        }\n+\n+        this.expr_as_operand(block, scope, expr)\n+    }\n }"}, {"sha": "52336b40a48dcd5884ea593acdf4cf3f69ac9092", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()\n-                        .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n+                        .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n                         .collect();\n \n                     let success = this.cfg.start_new_block();"}, {"sha": "125f44bbf0093071599e8fab4fa76f9b12e37fe7", "filename": "src/test/ui/fn/dyn-fn-alignment.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fdyn-fn-alignment.rs?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+#![feature(unsized_locals)]\n+#![allow(dead_code)]\n+#[repr(align(256))]\n+struct A {\n+    v: u8,\n+}\n+\n+impl A {\n+    fn f(&self) -> *const A {\n+        self\n+    }\n+}\n+\n+fn f2(v: u8) -> Box<dyn FnOnce() -> *const A> {\n+    let a = A { v };\n+    Box::new(move || a.f())\n+}\n+\n+fn main() {\n+    let addr = f2(0)();\n+    assert_eq!(addr as usize % 256, 0, \"addr: {:?}\", addr);\n+}"}, {"sha": "110edab69be871d08c4d5c676123c6650666ca44", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -45,12 +45,12 @@ LL |         println!(\"{}\", &y);\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24\n    |\n+LL |         let x = \"hello\".to_owned().into_boxed_str();\n+   |             - move occurs because `x` has type `std::boxed::Box<str>`, which does not implement the `Copy` trait\n LL |         x.foo();\n    |         - value moved here\n LL |         println!(\"{}\", &x);\n-   |                        ^^ value borrowed here after partial move\n-   |\n-   = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n+   |                        ^^ value borrowed here after move\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5b936fb64474f3ccd8af16f71cf262da7d05dafc", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -38,25 +38,25 @@ LL |         y.foo();\n LL |         y.foo();\n    |         ^ value used here after move\n \n-error[E0382]: use of moved value: `*x`\n+error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:45:9\n    |\n LL |         let _y = *x;\n    |                  -- value moved here\n LL |         x.foo();\n-   |         ^ value used here after move\n+   |         ^ value used here after partial move\n    |\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `*x`\n   --> $DIR/double-move.rs:51:18\n    |\n+LL |         let x = \"hello\".to_owned().into_boxed_str();\n+   |             - move occurs because `x` has type `std::boxed::Box<str>`, which does not implement the `Copy` trait\n LL |         x.foo();\n    |         - value moved here\n LL |         let _y = *x;\n    |                  ^^ value used here after move\n-   |\n-   = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n error: aborting due to 6 previous errors\n "}, {"sha": "88269f237afb7d613601da9f3479a849691e71f1", "filename": "src/test/ui/unsized-locals/unsized-exprs2.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d050cde277b22a755847338f2acc2c7b834141/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.stderr?ref=45d050cde277b22a755847338f2acc2c7b834141", "patch": "@@ -1,11 +1,11 @@\n error[E0508]: cannot move out of type `[u8]`, a non-copy slice\n-  --> $DIR/unsized-exprs2.rs:22:19\n+  --> $DIR/unsized-exprs2.rs:22:5\n    |\n LL |     udrop::<[u8]>(foo()[..]);\n-   |                   ^^^^^^^^^\n-   |                   |\n-   |                   cannot move out of here\n-   |                   move occurs because value has type `[u8]`, which does not implement the `Copy` trait\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     cannot move out of here\n+   |     move occurs because value has type `[u8]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}]}