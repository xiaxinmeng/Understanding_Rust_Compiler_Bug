{"sha": "cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYzlkNjgyYjA2NmIxMTBlMGE0NGU1ZjhmMWM1NzRiMzhjMTZiYTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-21T11:48:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-21T11:48:12Z"}, "message": "Merge #2629\n\n2629: Remove imports from hir r=matklad a=matklad\n\nWe only used them to avoid self-confirming completions (`use self::foo`), but that can be handled more locally.\r\n\r\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d1429d913719f73b4dee771e0c9ce85e871fc54a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1429d913719f73b4dee771e0c9ce85e871fc54a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/gZ8CRBK7hj4Ov3rIwAAdHIIAJMZog6PP9bW0JkRlem3kotL\nHRY/5URASnL1k9WILQFqfAQwSYC/7YNk2WRfW4w8f6qO5dARpqmc62eAxdQSDqdW\nUFjT02BfgybFfpJvCJKc/ux72akIZ/MNLGfGj5LGdRBjDLFf9dxZCQ9HeMFqQ9EW\no55fgxty6oJ4XYxVC75xmBafApqrH1RDCPJ4qdxh/9EJtUB9HKiuQMAvKoOdR3gK\nC0BXOJzXqj9hNoFq4PrmoFrXel1tbz74OA4yBFBHcEZunKdrBF5LTPygKhsGOcP4\ng8MotUTMMvbmBOD18EFqOZp4Oh4TZCH/CO6nF/jhZek2Y/aKIlrEVmhNSvHO04U=\n=dWmq\n-----END PGP SIGNATURE-----\n", "payload": "tree d1429d913719f73b4dee771e0c9ce85e871fc54a\nparent 90ef070db3dce0a7acb9cd11d0b0d72de13c9d79\nparent 2d3fdf3fb52f32ececdfa19df7ab2971a24bae71\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576928892 +0000\ncommitter GitHub <noreply@github.com> 1576928892 +0000\n\nMerge #2629\n\n2629: Remove imports from hir r=matklad a=matklad\n\nWe only used them to avoid self-confirming completions (`use self::foo`), but that can be handled more locally.\r\n\r\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "html_url": "https://github.com/rust-lang/rust/commit/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ef070db3dce0a7acb9cd11d0b0d72de13c9d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ef070db3dce0a7acb9cd11d0b0d72de13c9d79", "html_url": "https://github.com/rust-lang/rust/commit/90ef070db3dce0a7acb9cd11d0b0d72de13c9d79"}, {"sha": "2d3fdf3fb52f32ececdfa19df7ab2971a24bae71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3fdf3fb52f32ececdfa19df7ab2971a24bae71", "html_url": "https://github.com/rust-lang/rust/commit/2d3fdf3fb52f32ececdfa19df7ab2971a24bae71"}], "stats": {"total": 237, "additions": 71, "deletions": 166}, "files": [{"sha": "e6768ea0bc0f98ce840f49746e24669105d0b512", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -12,8 +12,8 @@ use hir_def::{\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n     AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeParamId, UnionId,\n+    LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n+    TypeParamId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -180,13 +180,11 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<Import>)> {\n+    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef)> {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n-            .map(|(name, res)| {\n-                (name.clone(), res.def.into(), res.import.map(|id| Import { parent: self, id }))\n-            })\n+            .map(|(name, res)| (name.clone(), res.def.into()))\n             .collect()\n     }\n \n@@ -229,10 +227,10 @@ impl Module {\n     }\n }\n \n-pub struct Import {\n-    pub(crate) parent: Module,\n-    pub(crate) id: LocalImportId,\n-}\n+// pub struct Import {\n+//     pub(crate) parent: Module,\n+//     pub(crate) id: LocalImportId,\n+// }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructField {"}, {"sha": "f5ffd64fa7b17622250d204d26ebf855fad4295b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -4,8 +4,8 @@ pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQuery, CrateLangItemsQuery,\n     DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery, ExprScopesQuery,\n     FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n-    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, RawItemsWithSourceMapQuery,\n-    StaticDataQuery, StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,"}, {"sha": "5541266e2b1e0f534909313d9d630ee7c1b71087", "filename": "crates/ra_hir/src/has_source.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fhas_source.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -9,8 +9,8 @@ use hir_def::{\n use ra_syntax::ast;\n \n use crate::{\n-    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, Import, MacroDef,\n-    Module, Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n+    db::DefDatabase, Const, Enum, EnumVariant, FieldSource, Function, ImplBlock, MacroDef, Module,\n+    Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n };\n \n pub use hir_expand::InFile;\n@@ -117,18 +117,6 @@ impl HasSource for ImplBlock {\n         self.id.lookup(db).source(db)\n     }\n }\n-impl HasSource for Import {\n-    type Ast = Either<ast::UseTree, ast::ExternCrateItem>;\n-\n-    /// Returns the syntax of the last path segment corresponding to this import\n-    fn source(self, db: &impl DefDatabase) -> InFile<Self::Ast> {\n-        let src = self.parent.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n-        let root = db.parse_or_expand(src.file_id).unwrap();\n-        let ptr = source_map.get(self.id);\n-        src.with_value(ptr.map_left(|it| it.to_node(&root)).map_right(|it| it.to_node(&root)))\n-    }\n-}\n \n impl HasSource for TypeParam {\n     type Ast = Either<ast::TraitDef, ast::TypeParam>;"}, {"sha": "0008a8858fc44a45813fe5f96830c90594c2c6c4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -40,8 +40,8 @@ mod from_source;\n pub use crate::{\n     code_model::{\n         Adt, AssocItem, AttrDef, Const, Crate, CrateDependency, DefWithBody, Docs, Enum,\n-        EnumVariant, FieldSource, Function, GenericDef, HasAttrs, ImplBlock, Import, Local,\n-        MacroDef, Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n+        EnumVariant, FieldSource, Function, GenericDef, HasAttrs, ImplBlock, Local, MacroDef,\n+        Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n         TypeParam, Union, VariantDef,\n     },\n     from_source::FromSource,"}, {"sha": "c55fd411107f9baca6fa9d569c6318a7aebbaa35", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -13,10 +13,7 @@ use crate::{\n     docs::Documentation,\n     generics::GenericParams,\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{\n-        raw::{ImportSourceMap, RawItems},\n-        CrateDefMap,\n-    },\n+    nameres::{raw::RawItems, CrateDefMap},\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -46,12 +43,6 @@ pub trait InternDatabase: SourceDatabase {\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + AstDatabase {\n-    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(\n-        &self,\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n-\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n "}, {"sha": "5c14fefff4378be1f8e923507654d427b4663909", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -5,7 +5,7 @@ use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n-use crate::{per_ns::PerNs, BuiltinType, ImplId, LocalImportId, MacroDefId, ModuleDefId, TraitId};\n+use crate::{per_ns::PerNs, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n@@ -30,7 +30,7 @@ static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n         .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), declaration: false })\n         })\n         .collect()\n });\n@@ -53,11 +53,9 @@ impl ItemScope {\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n+        self.entries().filter(|(_name, res)| res.declaration).flat_map(|(_name, res)| {\n+            res.def.take_types().into_iter().chain(res.def.take_values().into_iter())\n+        })\n     }\n \n     pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n@@ -112,38 +110,26 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(\n-        &mut self,\n-        name: Name,\n-        res: &Resolution,\n-        import: Option<LocalImportId>,\n-    ) -> bool {\n+    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution, declaration: bool) -> bool {\n         let mut changed = false;\n         let existing = self.items.entry(name.clone()).or_default();\n \n         if existing.def.types.is_none() && res.def.types.is_some() {\n             existing.def.types = res.def.types;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n         if existing.def.values.is_none() && res.def.values.is_some() {\n             existing.def.values = res.def.values;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n         if existing.def.macros.is_none() && res.def.macros.is_some() {\n             existing.def.macros = res.def.macros;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n \n-        if existing.def.is_none()\n-            && res.def.is_none()\n-            && existing.import.is_none()\n-            && res.import.is_some()\n-        {\n-            existing.import = res.import;\n-        }\n         changed\n     }\n \n@@ -160,6 +146,5 @@ impl ItemScope {\n pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<LocalImportId>,\n+    pub declaration: bool,\n }"}, {"sha": "f6c7f38d171c2e06812bc79f8de962672966951c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -51,10 +51,6 @@ use ra_syntax::{ast, AstNode};\n use crate::body::Expander;\n use crate::builtin_type::BuiltinType;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LocalImportId(RawId);\n-impl_arena_id!(LocalImportId);\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,"}, {"sha": "9419461a864fd80f3b022afd3b582f82b828e5db", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -26,8 +26,7 @@ use crate::{\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n-    LocalImportId, LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc,\n-    TypeAliasLoc, UnionLoc,\n+    LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -93,7 +92,7 @@ impl PartialResolvedImport {\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct ImportDirective {\n     module_id: LocalModuleId,\n-    import_id: LocalImportId,\n+    import_id: raw::LocalImportId,\n     import: raw::ImportData,\n     status: PartialResolvedImport,\n }\n@@ -110,7 +109,7 @@ struct MacroDirective {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, raw::LocalImportId)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n@@ -218,8 +217,7 @@ where\n         if export {\n             self.update(\n                 self.def_map.root,\n-                None,\n-                &[(name, Resolution { def: PerNs::macros(macro_), import: None })],\n+                &[(name, Resolution { def: PerNs::macros(macro_), declaration: false })],\n             );\n         }\n     }\n@@ -374,7 +372,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -384,7 +382,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|it| *it == (module_id, import_id)) {\n@@ -404,12 +402,12 @@ where\n                             let variant = EnumVariantId { parent: e, local_id };\n                             let res = Resolution {\n                                 def: PerNs::both(variant.into(), variant.into()),\n-                                import: Some(import_id),\n+                                declaration: false,\n                             };\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n+                    self.update(module_id, &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -431,27 +429,21 @@ where\n                         }\n                     }\n \n-                    let resolution = Resolution { def, import: Some(import_id) };\n-                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                    let resolution = Resolution { def, declaration: false };\n+                    self.update(module_id, &[(name, resolution)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, Resolution)]) {\n+        self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n@@ -462,7 +454,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res, import);\n+            changed |= scope.push_res(name.clone(), res, depth == 0 && res.declaration);\n         }\n \n         if !changed {\n@@ -475,9 +467,9 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n+        for (glob_importing_module, _glob_import) in glob_imports {\n             // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n         }\n     }\n \n@@ -719,9 +711,9 @@ where\n             def: PerNs::types(\n                 ModuleId { krate: self.def_collector.def_map.krate, local_id: res }.into(),\n             ),\n-            import: None,\n+            declaration: true,\n         };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        self.def_collector.update(self.module_id, &[(name, resolution)]);\n         res\n     }\n \n@@ -791,8 +783,8 @@ where\n                 PerNs::types(def.into())\n             }\n         };\n-        let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        let resolution = Resolution { def, declaration: true };\n+        self.def_collector.update(self.module_id, &[(name, resolution)])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "b10e458a2072ca3cb2d9b46bcd0dca3796542a8a", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -7,24 +7,24 @@\n \n use std::{ops::Index, sync::Arc};\n \n-use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n     db::AstDatabase,\n     hygiene::Hygiene,\n     name::{AsName, Name},\n };\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n+use ra_arena::{impl_arena_id, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr,\n+    AstNode,\n };\n use test_utils::tested_by;\n \n-use crate::{\n-    attr::Attrs, db::DefDatabase, path::ModPath, trace::Trace, FileAstId, HirFileId, InFile,\n-    LocalImportId,\n-};\n+use crate::{attr::Attrs, db::DefDatabase, path::ModPath, FileAstId, HirFileId, InFile};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(super) struct LocalImportId(RawId);\n+impl_arena_id!(LocalImportId);\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n ///\n@@ -41,35 +41,14 @@ pub struct RawItems {\n     items: Vec<RawItem>,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImportSourceMap {\n-    map: ArenaMap<LocalImportId, ImportSourcePtr>,\n-}\n-\n-type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-\n-impl ImportSourceMap {\n-    pub fn get(&self, import: LocalImportId) -> ImportSourcePtr {\n-        self.map[import].clone()\n-    }\n-}\n-\n impl RawItems {\n     pub(crate) fn raw_items_query(\n         db: &(impl DefDatabase + AstDatabase),\n         file_id: HirFileId,\n     ) -> Arc<RawItems> {\n-        db.raw_items_with_source_map(file_id).0\n-    }\n-\n-    pub(crate) fn raw_items_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n-            imports: Trace::new(),\n             file_id,\n             hygiene: Hygiene::new(db, file_id),\n         };\n@@ -80,11 +59,8 @@ impl RawItems {\n                 collector.process_module(None, item_list);\n             }\n         }\n-        let mut raw_items = collector.raw_items;\n-        let (arena, map) = collector.imports.into_arena_and_map();\n-        raw_items.imports = arena;\n-        let source_map = ImportSourceMap { map };\n-        (Arc::new(raw_items), Arc::new(source_map))\n+        let raw_items = collector.raw_items;\n+        Arc::new(raw_items)\n     }\n \n     pub(super) fn items(&self) -> &[RawItem] {\n@@ -223,7 +199,6 @@ pub(super) struct ImplData {\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n-    imports: Trace<LocalImportId, ImportData, ImportSourcePtr>,\n     source_ast_id_map: Arc<AstIdMap>,\n     file_id: HirFileId,\n     hygiene: Hygiene,\n@@ -330,7 +305,7 @@ impl RawItemsCollector {\n         ModPath::expand_use_item(\n             InFile { value: use_item, file_id: self.file_id },\n             &self.hygiene,\n-            |path, use_tree, is_glob, alias| {\n+            |path, _use_tree, is_glob, alias| {\n                 let import_data = ImportData {\n                     path,\n                     alias,\n@@ -339,11 +314,11 @@ impl RawItemsCollector {\n                     is_extern_crate: false,\n                     is_macro_use: false,\n                 };\n-                buf.push((import_data, Either::Left(AstPtr::new(use_tree))));\n+                buf.push(import_data);\n             },\n         );\n-        for (import_data, ptr) in buf {\n-            self.push_import(current_module, attrs.clone(), import_data, ptr);\n+        for import_data in buf {\n+            self.push_import(current_module, attrs.clone(), import_data);\n         }\n     }\n \n@@ -366,12 +341,7 @@ impl RawItemsCollector {\n                 is_extern_crate: true,\n                 is_macro_use,\n             };\n-            self.push_import(\n-                current_module,\n-                attrs,\n-                import_data,\n-                Either::Right(AstPtr::new(&extern_crate)),\n-            );\n+            self.push_import(current_module, attrs, import_data);\n         }\n     }\n \n@@ -402,14 +372,8 @@ impl RawItemsCollector {\n         self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n     }\n \n-    fn push_import(\n-        &mut self,\n-        current_module: Option<Module>,\n-        attrs: Attrs,\n-        data: ImportData,\n-        source: ImportSourcePtr,\n-    ) {\n-        let import = self.imports.alloc(|| source, || data);\n+    fn push_import(&mut self, current_module: Option<Module>, attrs: Attrs, data: ImportData) {\n+        let import = self.raw_items.imports.alloc(data);\n         self.push_item(current_module, attrs, RawItemKind::Import(import))\n     }\n "}, {"sha": "9769e88df583779c035a9d8a33c7d4d7df574814", "filename": "crates/ra_hir_def/src/trace.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftrace.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -18,10 +18,6 @@ pub(crate) struct Trace<ID: ArenaId, T, V> {\n }\n \n impl<ID: ra_arena::ArenaId + Copy, T, V> Trace<ID, T, V> {\n-    pub(crate) fn new() -> Trace<ID, T, V> {\n-        Trace { arena: Some(Arena::default()), map: Some(ArenaMap::default()), len: 0 }\n-    }\n-\n     pub(crate) fn new_for_arena() -> Trace<ID, T, V> {\n         Trace { arena: Some(Arena::default()), map: None, len: 0 }\n     }\n@@ -52,8 +48,4 @@ impl<ID: ra_arena::ArenaId + Copy, T, V> Trace<ID, T, V> {\n     pub(crate) fn into_map(mut self) -> ArenaMap<ID, V> {\n         self.map.take().unwrap()\n     }\n-\n-    pub(crate) fn into_arena_and_map(mut self) -> (Arena<ID, T>, ArenaMap<ID, V>) {\n-        (self.arena.take().unwrap(), self.map.take().unwrap())\n-    }\n }"}, {"sha": "387a9cafb65751833f6335248c3f2325121e4657", "filename": "crates/ra_ide/src/change.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fchange.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -270,7 +270,6 @@ impl RootDatabase {\n \n         self.query(hir::db::AstIdMapQuery).sweep(sweep);\n \n-        self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);\n \n         self.query(hir::db::ExprScopesQuery).sweep(sweep);\n@@ -309,7 +308,6 @@ impl RootDatabase {\n             hir::db::StructDataQuery\n             hir::db::EnumDataQuery\n             hir::db::TraitDataQuery\n-            hir::db::RawItemsWithSourceMapQuery\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery\n             hir::db::GenericParamsQuery"}, {"sha": "8ce86ad7d210fa4d73511a28d9cc5f2c145d7406", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -1,7 +1,6 @@\n //! FIXME: write short doc here\n \n-use either::Either;\n-use hir::{Adt, HasSource, PathResolution};\n+use hir::{Adt, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -19,17 +18,15 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n     match def {\n         hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n-            for (name, def, import) in module_scope {\n-                if let hir::ScopeDef::ModuleDef(hir::ModuleDef::BuiltinType(..)) = def {\n-                    if ctx.use_item_syntax.is_some() {\n+            for (name, def) in module_scope {\n+                if ctx.use_item_syntax.is_some() {\n+                    if let hir::ScopeDef::ModuleDef(hir::ModuleDef::BuiltinType(..)) = def {\n                         tested_by!(dont_complete_primitive_in_use);\n                         continue;\n                     }\n-                }\n-                if Some(module) == ctx.module {\n-                    if let Some(import) = import {\n-                        if let Either::Left(use_tree) = import.source(ctx.db).value {\n-                            if use_tree.syntax().text_range().contains_inclusive(ctx.offset) {\n+                    if let ScopeDef::Unknown = def {\n+                        if let Some(name_ref) = ctx.name_ref.as_ref() {\n+                            if &name_ref.syntax().text() == name.to_string().as_str() {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n                                 tested_by!(dont_complete_current_use);\n                                 continue;"}, {"sha": "8f56ce7062a63d1a85d44fa0abf1e4951b971936", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc9d682b066b110e0a44e5f8f1c574b38c16ba9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=cdc9d682b066b110e0a44e5f8f1c574b38c16ba9", "patch": "@@ -18,6 +18,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) analyzer: hir::SourceAnalyzer,\n     pub(super) offset: TextUnit,\n     pub(super) token: SyntaxToken,\n+    pub(super) name_ref: Option<ast::NameRef>,\n     pub(super) module: Option<hir::Module>,\n     pub(super) function_syntax: Option<ast::FnDef>,\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n@@ -68,6 +69,7 @@ impl<'a> CompletionContext<'a> {\n             analyzer,\n             token,\n             offset: position.offset,\n+            name_ref: None,\n             module,\n             function_syntax: None,\n             use_item_syntax: None,\n@@ -142,6 +144,8 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name_ref(&mut self, original_file: SourceFile, name_ref: ast::NameRef) {\n+        self.name_ref =\n+            find_node_at_offset(original_file.syntax(), name_ref.syntax().text_range().start());\n         let name_range = name_ref.syntax().text_range();\n         if name_ref.syntax().parent().and_then(ast::RecordField::cast).is_some() {\n             self.record_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);"}]}