{"sha": "b775541aafb5dcb12f33c6ad4e275d79e54b6987", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NzU1NDFhYWZiNWRjYjEyZjMzYzZhZDRlMjc1ZDc5ZTU0YjY5ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-08T17:59:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-08T17:59:20Z"}, "message": "Auto merge of #22984 - carols10cents:tests-for-float, r=huonw\n\nBuilding on #22076, I've added some tests for stable methods in f32 and f64 that didn't have any before.\r\n\r\nPlease let me know if there are any improvements I can make, and I am happy to make them! :mailbox_with_mail:", "tree": {"sha": "cbc84850cded1df793d818d2f082c25f3499a4dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc84850cded1df793d818d2f082c25f3499a4dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b775541aafb5dcb12f33c6ad4e275d79e54b6987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b775541aafb5dcb12f33c6ad4e275d79e54b6987", "html_url": "https://github.com/rust-lang/rust/commit/b775541aafb5dcb12f33c6ad4e275d79e54b6987", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b775541aafb5dcb12f33c6ad4e275d79e54b6987/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ead9ab84b80ba3b172d529b1d2a2917bb05b4820", "url": "https://api.github.com/repos/rust-lang/rust/commits/ead9ab84b80ba3b172d529b1d2a2917bb05b4820", "html_url": "https://github.com/rust-lang/rust/commit/ead9ab84b80ba3b172d529b1d2a2917bb05b4820"}, {"sha": "1bda1ff9dab84a9fc05272091710575585760d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bda1ff9dab84a9fc05272091710575585760d1a", "html_url": "https://github.com/rust-lang/rust/commit/1bda1ff9dab84a9fc05272091710575585760d1a"}], "stats": {"total": 1270, "additions": 925, "deletions": 345}, "files": [{"sha": "969dd35ba228878ea1f90aebd5eb10f397bc9960", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 463, "deletions": 173, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/b775541aafb5dcb12f33c6ad4e275d79e54b6987/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b775541aafb5dcb12f33c6ad4e275d79e54b6987/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=b775541aafb5dcb12f33c6ad4e275d79e54b6987", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -468,6 +468,11 @@ mod tests {\n     use num::*;\n     use num::FpCategory as Fp;\n \n+    #[test]\n+    fn test_num_f32() {\n+        test_num(10f32, 2f32);\n+    }\n+\n     #[test]\n     fn test_min_nan() {\n         assert_eq!(NAN.min(2.0), 2.0);\n@@ -481,8 +486,163 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_num_f32() {\n-        test_num(10f32, 2f32);\n+    fn test_nan() {\n+        let nan: f32 = Float::nan();\n+        assert!(nan.is_nan());\n+        assert!(!nan.is_infinite());\n+        assert!(!nan.is_finite());\n+        assert!(!nan.is_normal());\n+        assert!(!nan.is_positive());\n+        assert!(!nan.is_negative());\n+        assert_eq!(Fp::Nan, nan.classify());\n+    }\n+\n+    #[test]\n+    fn test_infinity() {\n+        let inf: f32 = Float::infinity();\n+        assert!(inf.is_infinite());\n+        assert!(!inf.is_finite());\n+        assert!(inf.is_positive());\n+        assert!(!inf.is_negative());\n+        assert!(!inf.is_nan());\n+        assert!(!inf.is_normal());\n+        assert_eq!(Fp::Infinite, inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_infinity() {\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(neg_inf.is_infinite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(!neg_inf.is_positive());\n+        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_nan());\n+        assert!(!neg_inf.is_normal());\n+        assert_eq!(Fp::Infinite, neg_inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_zero() {\n+        let zero: f32 = Float::zero();\n+        assert_eq!(0.0, zero);\n+        assert!(!zero.is_infinite());\n+        assert!(zero.is_finite());\n+        assert!(zero.is_positive());\n+        assert!(!zero.is_negative());\n+        assert!(!zero.is_nan());\n+        assert!(!zero.is_normal());\n+        assert_eq!(Fp::Zero, zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_zero() {\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(0.0, neg_zero);\n+        assert!(!neg_zero.is_infinite());\n+        assert!(neg_zero.is_finite());\n+        assert!(!neg_zero.is_positive());\n+        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_nan());\n+        assert!(!neg_zero.is_normal());\n+        assert_eq!(Fp::Zero, neg_zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_one() {\n+        let one: f32 = Float::one();\n+        assert_eq!(1.0, one);\n+        assert!(!one.is_infinite());\n+        assert!(one.is_finite());\n+        assert!(one.is_positive());\n+        assert!(!one.is_negative());\n+        assert!(!one.is_nan());\n+        assert!(one.is_normal());\n+        assert_eq!(Fp::Normal, one.classify());\n+    }\n+\n+    #[test]\n+    fn test_is_nan() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(nan.is_nan());\n+        assert!(!0.0f32.is_nan());\n+        assert!(!5.3f32.is_nan());\n+        assert!(!(-10.732f32).is_nan());\n+        assert!(!inf.is_nan());\n+        assert!(!neg_inf.is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_infinite() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(!nan.is_infinite());\n+        assert!(inf.is_infinite());\n+        assert!(neg_inf.is_infinite());\n+        assert!(!0.0f32.is_infinite());\n+        assert!(!42.8f32.is_infinite());\n+        assert!(!(-109.2f32).is_infinite());\n+    }\n+\n+    #[test]\n+    fn test_is_finite() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(!nan.is_finite());\n+        assert!(!inf.is_finite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(0.0f32.is_finite());\n+        assert!(42.8f32.is_finite());\n+        assert!((-109.2f32).is_finite());\n+    }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Float::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n+        assert!(1f32.is_normal());\n+        assert!(1e-37f32.is_normal());\n+        assert!(!1e-38f32.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Float::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1f32.classify(), Fp::Normal);\n+        assert_eq!(1e-37f32.classify(), Fp::Normal);\n+        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n+    }\n+\n+    #[test]\n+    fn test_integer_decode() {\n+        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n+        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+        assert_eq!(NAN.integer_decode(), (12582912, 105, 1));\n     }\n \n     #[test]\n@@ -555,6 +715,140 @@ mod tests {\n         assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n     }\n \n+    #[test]\n+    fn test_abs() {\n+        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(1f32.abs(), 1f32);\n+        assert_eq!(0f32.abs(), 0f32);\n+        assert_eq!((-0f32).abs(), 0f32);\n+        assert_eq!((-1f32).abs(), 1f32);\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n+        assert!(NAN.abs().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert_eq!(INFINITY.signum(), 1f32);\n+        assert_eq!(1f32.signum(), 1f32);\n+        assert_eq!(0f32.signum(), 1f32);\n+        assert_eq!((-0f32).signum(), -1f32);\n+        assert_eq!((-1f32).signum(), -1f32);\n+        assert_eq!(NEG_INFINITY.signum(), -1f32);\n+        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n+        assert!(NAN.signum().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!(INFINITY.is_positive());\n+        assert!(1f32.is_positive());\n+        assert!(0f32.is_positive());\n+        assert!(!(-0f32).is_positive());\n+        assert!(!(-1f32).is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f32/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!INFINITY.is_negative());\n+        assert!(!1f32.is_negative());\n+        assert!(!0f32.is_negative());\n+        assert!((-0f32).is_negative());\n+        assert!((-1f32).is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f32/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n+    }\n+\n+    #[test]\n+    fn test_mul_add() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n+        assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n+        assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n+        assert_approx_eq!(3.4f32.mul_add(-0.0, 5.6), 5.6);\n+        assert!(nan.mul_add(7.8, 9.0).is_nan());\n+        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+        assert_eq!(8.9f32.mul_add(inf, 3.2), inf);\n+        assert_eq!((-3.2f32).mul_add(2.4, neg_inf), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_recip() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.recip(), 1.0);\n+        assert_eq!(2.0f32.recip(), 0.5);\n+        assert_eq!((-0.4f32).recip(), -2.5);\n+        assert_eq!(0.0f32.recip(), inf);\n+        assert!(nan.recip().is_nan());\n+        assert_eq!(inf.recip(), 0.0);\n+        assert_eq!(neg_inf.recip(), 0.0);\n+    }\n+\n+    #[test]\n+    fn test_powi() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.powi(1), 1.0);\n+        assert_approx_eq!((-3.1f32).powi(2), 9.61);\n+        assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n+        assert_eq!(8.3f32.powi(0), 1.0);\n+        assert!(nan.powi(2).is_nan());\n+        assert_eq!(inf.powi(3), inf);\n+        assert_eq!(neg_inf.powi(2), inf);\n+    }\n+\n+    #[test]\n+    fn test_powf() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.powf(1.0), 1.0);\n+        assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n+        assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n+        assert_approx_eq!((-3.1f32).powf(2.0), 9.61);\n+        assert_approx_eq!(5.9f32.powf(-2.0), 0.028727);\n+        assert_eq!(8.3f32.powf(0.0), 1.0);\n+        assert!(nan.powf(2.0).is_nan());\n+        assert_eq!(inf.powf(2.0), inf);\n+        assert_eq!(neg_inf.powf(3.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_sqrt_domain() {\n+        assert!(NAN.sqrt().is_nan());\n+        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!((-1.0f32).sqrt().is_nan());\n+        assert_eq!((-0.0f32).sqrt(), -0.0);\n+        assert_eq!(0.0f32.sqrt(), 0.0);\n+        assert_eq!(1.0f32.sqrt(), 1.0);\n+        assert_eq!(INFINITY.sqrt(), INFINITY);\n+    }\n+\n+    #[test]\n+    fn test_rsqrt() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert!(nan.rsqrt().is_nan());\n+        assert_eq!(inf.rsqrt(), 0.0);\n+        assert!(neg_inf.rsqrt().is_nan());\n+        assert!((-1.0f32).rsqrt().is_nan());\n+        assert_eq!((-0.0f32).rsqrt(), neg_inf);\n+        assert_eq!(0.0f32.rsqrt(), inf);\n+        assert_eq!(1.0f32.rsqrt(), 1.0);\n+        assert_eq!(4.0f32.rsqrt(), 0.5);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n@@ -582,6 +876,172 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ln() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n+        assert!(nan.ln().is_nan());\n+        assert_eq!(inf.ln(), inf);\n+        assert!(neg_inf.ln().is_nan());\n+        assert!((-2.3f32).ln().is_nan());\n+        assert_eq!((-0.0f32).ln(), neg_inf);\n+        assert_eq!(0.0f32.ln(), neg_inf);\n+        assert_approx_eq!(4.0f32.ln(), 1.386294);\n+    }\n+\n+    #[test]\n+    fn test_log() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(10.0f32.log(10.0), 1.0);\n+        assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n+        assert_eq!(1.0f32.exp().log(1.0.exp()), 1.0);\n+        assert!(1.0f32.log(1.0).is_nan());\n+        assert!(1.0f32.log(-13.9).is_nan());\n+        assert!(nan.log(2.3).is_nan());\n+        assert_eq!(inf.log(10.0), inf);\n+        assert!(neg_inf.log(8.8).is_nan());\n+        assert!((-2.3f32).log(0.1).is_nan());\n+        assert_eq!((-0.0f32).log(2.0), neg_inf);\n+        assert_eq!(0.0f32.log(7.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log2() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_approx_eq!(10.0f32.log2(), 3.321928);\n+        assert_approx_eq!(2.3f32.log2(), 1.201634);\n+        assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n+        assert!(nan.log2().is_nan());\n+        assert_eq!(inf.log2(), inf);\n+        assert!(neg_inf.log2().is_nan());\n+        assert!((-2.3f32).log2().is_nan());\n+        assert_eq!((-0.0f32).log2(), neg_inf);\n+        assert_eq!(0.0f32.log2(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log10() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(10.0f32.log10(), 1.0);\n+        assert_approx_eq!(2.3f32.log10(), 0.361728);\n+        assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n+        assert_eq!(1.0f32.log10(), 0.0);\n+        assert!(nan.log10().is_nan());\n+        assert_eq!(inf.log10(), inf);\n+        assert!(neg_inf.log10().is_nan());\n+        assert!((-2.3f32).log10().is_nan());\n+        assert_eq!((-0.0f32).log10(), neg_inf);\n+        assert_eq!(0.0f32.log10(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_degrees() {\n+        let pi: f32 = consts::PI;\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(0.0f32.to_degrees(), 0.0);\n+        assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n+        assert_eq!(pi.to_degrees(), 180.0);\n+        assert!(nan.to_degrees().is_nan());\n+        assert_eq!(inf.to_degrees(), inf);\n+        assert_eq!(neg_inf.to_degrees(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_radians() {\n+        let pi: f32 = consts::PI;\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        assert_eq!(0.0f32.to_radians(), 0.0);\n+        assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n+        assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n+        assert_eq!(180.0f32.to_radians(), pi);\n+        assert!(nan.to_radians().is_nan());\n+        assert_eq!(inf.to_radians(), inf);\n+        assert_eq!(neg_inf.to_radians(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(Float::ldexp(1f32, -123), f1);\n+        assert_eq!(Float::ldexp(1f32, -111), f2);\n+        assert_eq!(Float::ldexp(1.75f32, -12), f3);\n+\n+        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n+        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::nan();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        let (x3, exp3) = f3.frexp();\n+        assert_eq!((x1, exp1), (0.5f32, -122));\n+        assert_eq!((x2, exp2), (0.5f32, -110));\n+        assert_eq!((x3, exp3), (0.875f32, -122));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x3, exp3), f3);\n+\n+        assert_eq!(0f32.frexp(), (0f32, 0));\n+        assert_eq!((-0f32).frexp(), (-0f32, 0));\n+    }\n+\n+    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    fn test_frexp_nowin() {\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::nan();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f32).abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(0f32), 1f32);\n+        assert_eq!(1f32.abs_sub(-1f32), 2f32);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f32), 0f32);\n+        assert_eq!(INFINITY.abs_sub(1f32), INFINITY);\n+        assert_eq!(0f32.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f32.abs_sub(INFINITY), 0f32);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub_nowin() {\n+        assert!(NAN.abs_sub(-1f32).is_nan());\n+        assert!(1f32.abs_sub(NAN).is_nan());\n+    }\n+\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n@@ -674,174 +1134,4 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f32.ln());\n         assert_approx_eq!(ln_10, 10f32.ln());\n     }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n-        assert_eq!(1f32.abs(), 1f32);\n-        assert_eq!(0f32.abs(), 0f32);\n-        assert_eq!((-0f32).abs(), 0f32);\n-        assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n-        assert!(NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1f32).abs_sub(1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(0f32), 1f32);\n-        assert_eq!(1f32.abs_sub(-1f32), 2f32);\n-        assert_eq!(NEG_INFINITY.abs_sub(0f32), 0f32);\n-        assert_eq!(INFINITY.abs_sub(1f32), INFINITY);\n-        assert_eq!(0f32.abs_sub(NEG_INFINITY), INFINITY);\n-        assert_eq!(0f32.abs_sub(INFINITY), 0f32);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(-1f32).is_nan());\n-        assert!(1f32.abs_sub(NAN).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f32);\n-        assert_eq!(1f32.signum(), 1f32);\n-        assert_eq!(0f32.signum(), 1f32);\n-        assert_eq!((-0f32).signum(), -1f32);\n-        assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n-        assert!(NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f32.is_positive());\n-        assert!(0f32.is_positive());\n-        assert!(!(-0f32).is_positive());\n-        assert!(!(-1f32).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f32/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f32.is_negative());\n-        assert!(!0f32.is_negative());\n-        assert!((-0f32).is_negative());\n-        assert!((-1f32).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f32/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f32.is_normal());\n-        assert!(1e-37f32.is_normal());\n-        assert!(!1e-38f32.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1f32.classify(), Fp::Normal);\n-        assert_eq!(1e-37f32.classify(), Fp::Normal);\n-        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(Float::ldexp(1f32, -123), f1);\n-        assert_eq!(Float::ldexp(1f32, -111), f2);\n-\n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n-\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        assert_eq!((x1, exp1), (0.5f32, -122));\n-        assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-\n-        assert_eq!(0f32.frexp(), (0f32, 0));\n-        assert_eq!((-0f32).frexp(), (-0f32, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    fn test_frexp_nowin() {\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n-    #[test]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-        assert_eq!(NAN.integer_decode(), (12582912, 105, 1));\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f32).sqrt().is_nan());\n-        assert_eq!((-0.0f32).sqrt(), -0.0);\n-        assert_eq!(0.0f32.sqrt(), 0.0);\n-        assert_eq!(1.0f32.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n-    }\n }"}, {"sha": "95065b59678c951052eef175475ebab3ff75c39f", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 462, "deletions": 172, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/b775541aafb5dcb12f33c6ad4e275d79e54b6987/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b775541aafb5dcb12f33c6ad4e275d79e54b6987/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=b775541aafb5dcb12f33c6ad4e275d79e54b6987", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -477,6 +477,11 @@ mod tests {\n     use num::*;\n     use num::FpCategory as Fp;\n \n+    #[test]\n+    fn test_num_f64() {\n+        test_num(10f64, 2f64);\n+    }\n+\n     #[test]\n     fn test_min_nan() {\n         assert_eq!(NAN.min(2.0), 2.0);\n@@ -490,8 +495,162 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_num_f64() {\n-        test_num(10f64, 2f64);\n+    fn test_nan() {\n+        let nan: f64 = Float::nan();\n+        assert!(nan.is_nan());\n+        assert!(!nan.is_infinite());\n+        assert!(!nan.is_finite());\n+        assert!(!nan.is_normal());\n+        assert!(!nan.is_positive());\n+        assert!(!nan.is_negative());\n+        assert_eq!(Fp::Nan, nan.classify());\n+    }\n+\n+    #[test]\n+    fn test_infinity() {\n+        let inf: f64 = Float::infinity();\n+        assert!(inf.is_infinite());\n+        assert!(!inf.is_finite());\n+        assert!(inf.is_positive());\n+        assert!(!inf.is_negative());\n+        assert!(!inf.is_nan());\n+        assert!(!inf.is_normal());\n+        assert_eq!(Fp::Infinite, inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_infinity() {\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(neg_inf.is_infinite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(!neg_inf.is_positive());\n+        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_nan());\n+        assert!(!neg_inf.is_normal());\n+        assert_eq!(Fp::Infinite, neg_inf.classify());\n+    }\n+\n+    #[test]\n+    fn test_zero() {\n+        let zero: f64 = Float::zero();\n+        assert_eq!(0.0, zero);\n+        assert!(!zero.is_infinite());\n+        assert!(zero.is_finite());\n+        assert!(zero.is_positive());\n+        assert!(!zero.is_negative());\n+        assert!(!zero.is_nan());\n+        assert!(!zero.is_normal());\n+        assert_eq!(Fp::Zero, zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_neg_zero() {\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(0.0, neg_zero);\n+        assert!(!neg_zero.is_infinite());\n+        assert!(neg_zero.is_finite());\n+        assert!(!neg_zero.is_positive());\n+        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_nan());\n+        assert!(!neg_zero.is_normal());\n+        assert_eq!(Fp::Zero, neg_zero.classify());\n+    }\n+\n+    #[test]\n+    fn test_one() {\n+        let one: f64 = Float::one();\n+        assert_eq!(1.0, one);\n+        assert!(!one.is_infinite());\n+        assert!(one.is_finite());\n+        assert!(one.is_positive());\n+        assert!(!one.is_negative());\n+        assert!(!one.is_nan());\n+        assert!(one.is_normal());\n+        assert_eq!(Fp::Normal, one.classify());\n+    }\n+\n+    #[test]\n+    fn test_is_nan() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(nan.is_nan());\n+        assert!(!0.0f64.is_nan());\n+        assert!(!5.3f64.is_nan());\n+        assert!(!(-10.732f64).is_nan());\n+        assert!(!inf.is_nan());\n+        assert!(!neg_inf.is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_infinite() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(!nan.is_infinite());\n+        assert!(inf.is_infinite());\n+        assert!(neg_inf.is_infinite());\n+        assert!(!0.0f64.is_infinite());\n+        assert!(!42.8f64.is_infinite());\n+        assert!(!(-109.2f64).is_infinite());\n+    }\n+\n+    #[test]\n+    fn test_is_finite() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(!nan.is_finite());\n+        assert!(!inf.is_finite());\n+        assert!(!neg_inf.is_finite());\n+        assert!(0.0f64.is_finite());\n+        assert!(42.8f64.is_finite());\n+        assert!((-109.2f64).is_finite());\n+    }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Float::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n+        assert!(1f64.is_normal());\n+        assert!(1e-307f64.is_normal());\n+        assert!(!1e-308f64.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Float::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1e-307f64.classify(), Fp::Normal);\n+        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n+    }\n+\n+    #[test]\n+    fn test_integer_decode() {\n+        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+        assert_eq!(NAN.integer_decode(), (6755399441055744, 972, 1));\n     }\n \n     #[test]\n@@ -564,6 +723,140 @@ mod tests {\n         assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n     }\n \n+    #[test]\n+    fn test_abs() {\n+        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(1f64.abs(), 1f64);\n+        assert_eq!(0f64.abs(), 0f64);\n+        assert_eq!((-0f64).abs(), 0f64);\n+        assert_eq!((-1f64).abs(), 1f64);\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n+        assert!(NAN.abs().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert_eq!(INFINITY.signum(), 1f64);\n+        assert_eq!(1f64.signum(), 1f64);\n+        assert_eq!(0f64.signum(), 1f64);\n+        assert_eq!((-0f64).signum(), -1f64);\n+        assert_eq!((-1f64).signum(), -1f64);\n+        assert_eq!(NEG_INFINITY.signum(), -1f64);\n+        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n+        assert!(NAN.signum().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!(INFINITY.is_positive());\n+        assert!(1f64.is_positive());\n+        assert!(0f64.is_positive());\n+        assert!(!(-0f64).is_positive());\n+        assert!(!(-1f64).is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f64/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!INFINITY.is_negative());\n+        assert!(!1f64.is_negative());\n+        assert!(!0f64.is_negative());\n+        assert!((-0f64).is_negative());\n+        assert!((-1f64).is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f64/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n+    }\n+\n+    #[test]\n+    fn test_mul_add() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n+        assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n+        assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n+        assert_approx_eq!(3.4f64.mul_add(-0.0, 5.6), 5.6);\n+        assert!(nan.mul_add(7.8, 9.0).is_nan());\n+        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+        assert_eq!(8.9f64.mul_add(inf, 3.2), inf);\n+        assert_eq!((-3.2f64).mul_add(2.4, neg_inf), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_recip() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.recip(), 1.0);\n+        assert_eq!(2.0f64.recip(), 0.5);\n+        assert_eq!((-0.4f64).recip(), -2.5);\n+        assert_eq!(0.0f64.recip(), inf);\n+        assert!(nan.recip().is_nan());\n+        assert_eq!(inf.recip(), 0.0);\n+        assert_eq!(neg_inf.recip(), 0.0);\n+    }\n+\n+    #[test]\n+    fn test_powi() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.powi(1), 1.0);\n+        assert_approx_eq!((-3.1f64).powi(2), 9.61);\n+        assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n+        assert_eq!(8.3f64.powi(0), 1.0);\n+        assert!(nan.powi(2).is_nan());\n+        assert_eq!(inf.powi(3), inf);\n+        assert_eq!(neg_inf.powi(2), inf);\n+    }\n+\n+    #[test]\n+    fn test_powf() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(1.0f64.powf(1.0), 1.0);\n+        assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n+        assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n+        assert_approx_eq!((-3.1f64).powf(2.0), 9.61);\n+        assert_approx_eq!(5.9f64.powf(-2.0), 0.028727);\n+        assert_eq!(8.3f64.powf(0.0), 1.0);\n+        assert!(nan.powf(2.0).is_nan());\n+        assert_eq!(inf.powf(2.0), inf);\n+        assert_eq!(neg_inf.powf(3.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_sqrt_domain() {\n+        assert!(NAN.sqrt().is_nan());\n+        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!((-1.0f64).sqrt().is_nan());\n+        assert_eq!((-0.0f64).sqrt(), -0.0);\n+        assert_eq!(0.0f64.sqrt(), 0.0);\n+        assert_eq!(1.0f64.sqrt(), 1.0);\n+        assert_eq!(INFINITY.sqrt(), INFINITY);\n+    }\n+\n+    #[test]\n+    fn test_rsqrt() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert!(nan.rsqrt().is_nan());\n+        assert_eq!(inf.rsqrt(), 0.0);\n+        assert!(neg_inf.rsqrt().is_nan());\n+        assert!((-1.0f64).rsqrt().is_nan());\n+        assert_eq!((-0.0f64).rsqrt(), neg_inf);\n+        assert_eq!(0.0f64.rsqrt(), inf);\n+        assert_eq!(1.0f64.rsqrt(), 1.0);\n+        assert_eq!(4.0f64.rsqrt(), 0.5);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n@@ -591,6 +884,172 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ln() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n+        assert!(nan.ln().is_nan());\n+        assert_eq!(inf.ln(), inf);\n+        assert!(neg_inf.ln().is_nan());\n+        assert!((-2.3f64).ln().is_nan());\n+        assert_eq!((-0.0f64).ln(), neg_inf);\n+        assert_eq!(0.0f64.ln(), neg_inf);\n+        assert_approx_eq!(4.0f64.ln(), 1.386294);\n+    }\n+\n+    #[test]\n+    fn test_log() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(10.0f64.log(10.0), 1.0);\n+        assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n+        assert_eq!(1.0f64.exp().log(1.0.exp()), 1.0);\n+        assert!(1.0f64.log(1.0).is_nan());\n+        assert!(1.0f64.log(-13.9).is_nan());\n+        assert!(nan.log(2.3).is_nan());\n+        assert_eq!(inf.log(10.0), inf);\n+        assert!(neg_inf.log(8.8).is_nan());\n+        assert!((-2.3f64).log(0.1).is_nan());\n+        assert_eq!((-0.0f64).log(2.0), neg_inf);\n+        assert_eq!(0.0f64.log(7.0), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log2() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_approx_eq!(10.0f64.log2(), 3.321928);\n+        assert_approx_eq!(2.3f64.log2(), 1.201634);\n+        assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n+        assert!(nan.log2().is_nan());\n+        assert_eq!(inf.log2(), inf);\n+        assert!(neg_inf.log2().is_nan());\n+        assert!((-2.3f64).log2().is_nan());\n+        assert_eq!((-0.0f64).log2(), neg_inf);\n+        assert_eq!(0.0f64.log2(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_log10() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(10.0f64.log10(), 1.0);\n+        assert_approx_eq!(2.3f64.log10(), 0.361728);\n+        assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n+        assert_eq!(1.0f64.log10(), 0.0);\n+        assert!(nan.log10().is_nan());\n+        assert_eq!(inf.log10(), inf);\n+        assert!(neg_inf.log10().is_nan());\n+        assert!((-2.3f64).log10().is_nan());\n+        assert_eq!((-0.0f64).log10(), neg_inf);\n+        assert_eq!(0.0f64.log10(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_degrees() {\n+        let pi: f64 = consts::PI;\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(0.0f64.to_degrees(), 0.0);\n+        assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n+        assert_eq!(pi.to_degrees(), 180.0);\n+        assert!(nan.to_degrees().is_nan());\n+        assert_eq!(inf.to_degrees(), inf);\n+        assert_eq!(neg_inf.to_degrees(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_to_radians() {\n+        let pi: f64 = consts::PI;\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        assert_eq!(0.0f64.to_radians(), 0.0);\n+        assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n+        assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n+        assert_eq!(180.0f64.to_radians(), pi);\n+        assert!(nan.to_radians().is_nan());\n+        assert_eq!(inf.to_radians(), inf);\n+        assert_eq!(neg_inf.to_radians(), neg_inf);\n+    }\n+\n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(Float::ldexp(1f64, -123), f1);\n+        assert_eq!(Float::ldexp(1f64, -111), f2);\n+        assert_eq!(Float::ldexp(1.75f64, -12), f3);\n+\n+        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n+        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::nan();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        let (x3, exp3) = f3.frexp();\n+        assert_eq!((x1, exp1), (0.5f64, -122));\n+        assert_eq!((x2, exp2), (0.5f64, -110));\n+        assert_eq!((x3, exp3), (0.875f64, -122));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x3, exp3), f3);\n+\n+        assert_eq!(0f64.frexp(), (0f64, 0));\n+        assert_eq!((-0f64).frexp(), (-0f64, 0));\n+    }\n+\n+    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    fn test_frexp_nowin() {\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::nan();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f64).abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(0f64), 1f64);\n+        assert_eq!(1f64.abs_sub(-1f64), 2f64);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f64), 0f64);\n+        assert_eq!(INFINITY.abs_sub(1f64), INFINITY);\n+        assert_eq!(0f64.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f64.abs_sub(INFINITY), 0f64);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub_nowin() {\n+        assert!(NAN.abs_sub(-1f64).is_nan());\n+        assert!(1f64.abs_sub(NAN).is_nan());\n+    }\n+\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n@@ -677,173 +1136,4 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f64.ln());\n         assert_approx_eq!(ln_10, 10f64.ln());\n     }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n-        assert_eq!(1f64.abs(), 1f64);\n-        assert_eq!(0f64.abs(), 0f64);\n-        assert_eq!((-0f64).abs(), 0f64);\n-        assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n-        assert!(NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1f64).abs_sub(1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(0f64), 1f64);\n-        assert_eq!(1f64.abs_sub(-1f64), 2f64);\n-        assert_eq!(NEG_INFINITY.abs_sub(0f64), 0f64);\n-        assert_eq!(INFINITY.abs_sub(1f64), INFINITY);\n-        assert_eq!(0f64.abs_sub(NEG_INFINITY), INFINITY);\n-        assert_eq!(0f64.abs_sub(INFINITY), 0f64);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(-1f64).is_nan());\n-        assert!(1f64.abs_sub(NAN).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f64);\n-        assert_eq!(1f64.signum(), 1f64);\n-        assert_eq!(0f64.signum(), 1f64);\n-        assert_eq!((-0f64).signum(), -1f64);\n-        assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n-        assert!(NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f64.is_positive());\n-        assert!(0f64.is_positive());\n-        assert!(!(-0f64).is_positive());\n-        assert!(!(-1f64).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f64/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f64.is_negative());\n-        assert!(!0f64.is_negative());\n-        assert!((-0f64).is_negative());\n-        assert!((-1f64).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f64/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f64.is_normal());\n-        assert!(1e-307f64.is_normal());\n-        assert!(!1e-308f64.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1e-307f64.classify(), Fp::Normal);\n-        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(Float::ldexp(1f64, -123), f1);\n-        assert_eq!(Float::ldexp(1f64, -111), f2);\n-\n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n-\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        assert_eq!((x1, exp1), (0.5f64, -122));\n-        assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-\n-        assert_eq!(0f64.frexp(), (0f64, 0));\n-        assert_eq!((-0f64).frexp(), (-0f64, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    fn test_frexp_nowin() {\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n-    #[test]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-        assert_eq!(NAN.integer_decode(), (6755399441055744, 972, 1));\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f64).sqrt().is_nan());\n-        assert_eq!((-0.0f64).sqrt(), -0.0);\n-        assert_eq!(0.0f64.sqrt(), 0.0);\n-        assert_eq!(1.0f64.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n-    }\n }"}]}