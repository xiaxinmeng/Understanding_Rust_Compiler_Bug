{"sha": "d66c67be784a4d0678f60158adb9e76c6b58d9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NmM2N2JlNzg0YTRkMDY3OGY2MDE1OGFkYjllNzZjNmI1OGQ5YzM=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T00:49:58Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T00:49:58Z"}, "message": "clarify atomics", "tree": {"sha": "ee8f0f7124aa63609d7414a4a89e4294d99ccd0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8f0f7124aa63609d7414a4a89e4294d99ccd0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d66c67be784a4d0678f60158adb9e76c6b58d9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d66c67be784a4d0678f60158adb9e76c6b58d9c3", "html_url": "https://github.com/rust-lang/rust/commit/d66c67be784a4d0678f60158adb9e76c6b58d9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d66c67be784a4d0678f60158adb9e76c6b58d9c3/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc6408281ce7d67a3454761e832d402971a85cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6408281ce7d67a3454761e832d402971a85cf", "html_url": "https://github.com/rust-lang/rust/commit/cbc6408281ce7d67a3454761e832d402971a85cf"}], "stats": {"total": 85, "additions": 57, "deletions": 28}, "files": [{"sha": "82e69dd2e13fc0bd6f091dedcdbe734a0508684c", "filename": "atomics.md", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d66c67be784a4d0678f60158adb9e76c6b58d9c3/atomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/d66c67be784a4d0678f60158adb9e76c6b58d9c3/atomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/atomics.md?ref=d66c67be784a4d0678f60158adb9e76c6b58d9c3", "patch": "@@ -10,8 +10,8 @@ C.\n Trying to fully explain the model in this book is fairly hopeless. It's defined\n in terms of madness-inducing causality graphs that require a full book to properly\n understand in a practical way. If you want all the nitty-gritty details, you\n-should check out [C's specification][C11-model]. Still, we'll try to cover the\n-basics and some of the problems Rust developers face.\n+should check out [C's specification (Section 7.17)][C11-model]. Still, we'll try\n+to cover the basics and some of the problems Rust developers face.\n \n The C11 memory model is fundamentally about trying to bridge the gap between\n the semantics we want, the optimizations compilers want, and the inconsistent\n@@ -127,7 +127,8 @@ to propagate the changes made in data accesses to other threads\n as lazily and inconsistently as it wants. Mostly critically, data accesses are\n how data races happen. Data accesses are very friendly to the hardware and\n compiler, but as we've seen they offer *awful* semantics to try to\n-write synchronized code with.\n+write synchronized code with. Actually, that's too weak. *It is literally\n+impossible to write correct synchronized code using only data accesses*.\n \n Atomic accesses are how we tell the hardware and compiler that our program is\n multi-threaded. Each atomic access can be marked with\n@@ -146,29 +147,33 @@ exposes are:\n (Note: We explicitly do not expose the C11 *consume* ordering)\n \n TODO: negative reasoning vs positive reasoning?\n-\n+TODO: \"can't forget to synchronize\"\n \n \n \n # Sequentially Consistent\n \n Sequentially Consistent is the most powerful of all, implying the restrictions\n-of all other orderings. A Sequentially Consistent operation *cannot*\n+of all other orderings. Intuitively, a sequentially consistent operation *cannot*\n be reordered: all accesses on one thread that happen before and after it *stay*\n-before and after it. A program that has sequential consistency has the very nice\n-property that there is a single global execution of the program's instructions\n-that all threads agree on. This execution is also particularly nice to reason\n-about: it's just an interleaving of each thread's individual executions.\n+before and after it. A data-race-free program that uses only sequentially consistent\n+atomics and data accesses has the very nice property that there is a single global\n+execution of the program's instructions that all threads agree on. This execution\n+is also particularly nice to reason about: it's just an interleaving of each thread's\n+individual executions. This *does not* hold if you start using the weaker atomic\n+orderings.\n \n The relative developer-friendliness of sequential consistency doesn't come for\n-free. Even on strongly-ordered platforms, sequential consistency involves\n+free. Even on strongly-ordered platforms sequential consistency involves\n emitting memory fences.\n \n In practice, sequential consistency is rarely necessary for program correctness.\n However sequential consistency is definitely the right choice if you're not\n confident about the other memory orders. Having your program run a bit slower\n than it needs to is certainly better than it running incorrectly! It's also\n-completely trivial to downgrade to a weaker consistency later.\n+*mechanically* trivial to downgrade atomic operations to have a weaker\n+consistency later on. Just change `SeqCst` to e.g. `Relaxed` and you're done! Of\n+course, proving that this transformation is *correct* is whole other matter.\n \n \n \n@@ -179,20 +184,42 @@ Acquire and Release are largely intended to be paired. Their names hint at\n their use case: they're perfectly suited for acquiring and releasing locks,\n and ensuring that critical sections don't overlap.\n \n-An acquire access ensures that every access after it *stays* after it. However\n-operations that occur before an acquire are free to be reordered to occur after\n-it.\n+Intuitively, an acquire access ensures that every access after it *stays* after\n+it. However operations that occur before an acquire are free to be reordered to\n+occur after it. Similarly, a release access ensures that every access before it\n+*stays* before it. However operations that occur after a release are free to\n+be reordered to occur before it.\n+\n+When thread A releases a location in memory and then thread B subsequently\n+acquires *the same* location in memory, causality is established. Every write\n+that happened *before* A's release will be observed by B *after* it's release.\n+However no causality is established with any other threads. Similarly, no\n+causality is established if A and B access *different* locations in memory.\n+\n+Basic use of release-acquire is therefore simple: you acquire a location of\n+memory to begin the critical section, and then release that location to end it.\n+For instance, a simple spinlock might look like:\n+\n+```rust\n+use std::sync::Arc;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::thread;\n \n-A release access ensures that every access before it *stays* before it. However\n-operations that occur after a release are free to be reordered to occur before\n-it.\n+fn main() {\n+    let lock = Arc::new(AtomicBool::new(true)); // value answers \"am I locked?\"\n \n-Basic use of release-acquire is simple: you acquire a location of memory to\n-begin the critical section, and the release that location to end it. If\n-thread A releases a location of memory and thread B acquires that location of\n-memory, this establishes that A's critical section *happened before* B's\n-critical section. All accesses that happened before the release will be observed\n-by anything that happens after the acquire.\n+    // ... distribute lock to threads somehow ...\n+\n+    // Try to acquire the lock by setting it to false\n+    while !lock.compare_and_swap(true, false, Ordering::Acquire) { }\n+    // broke out of the loop, so we successfully acquired the lock!\n+\n+    // ... scary data accesses ...\n+\n+    // ok we're done, release the lock\n+    lock.store(true, Ordering::Release);\n+}\n+```\n \n On strongly-ordered platforms most accesses have release or acquire semantics,\n making release and acquire often totally free. This is not the case on\n@@ -205,10 +232,12 @@ weakly-ordered platforms.\n \n Relaxed accesses are the absolute weakest. They can be freely re-ordered and\n provide no happens-before relationship. Still, relaxed operations *are* still\n-atomic, which is valuable. Relaxed operations are appropriate for things that\n-you definitely want to happen, but don't particularly care about much else. For\n-instance, incrementing a counter can be relaxed if you're not using the\n-counter to synchronize any other accesses.\n+atomic. That is, they don't count as data accesses and any read-modify-write\n+operations done to them occur atomically. Relaxed operations are appropriate for\n+things that you definitely want to happen, but don't particularly otherwise care\n+about. For instance, incrementing a counter can be safely done by multiple\n+threads using a relaxed `fetch_add` if you're not using the counter to\n+synchronize any other accesses.\n \n There's rarely a benefit in making an operation relaxed on strongly-ordered\n platforms, since they usually provide release-acquire semantics anyway. However\n@@ -219,4 +248,4 @@ relaxed operations can be cheaper on weakly-ordered platforms.\n \n \n [C11-busted]: http://plv.mpi-sws.org/c11comp/popl15.pdf\n-[C11-model]: http://en.cppreference.com/w/c/atomic/memory_order\n+[C11-model]: http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899"}]}