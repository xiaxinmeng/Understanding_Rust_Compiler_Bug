{"sha": "88008b3ad564ed2ba16c2acf4e9538f20a71f541", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MDA4YjNhZDU2NGVkMmJhMTZjMmFjZjRlOTUzOGYyMGE3MWY1NDE=", "commit": {"author": {"name": "Alisdair Owens", "email": "awo101@zepler.net", "date": "2014-06-29T15:33:42Z"}, "committer": {"name": "Alisdair Owens", "email": "awo101@zepler.net", "date": "2014-07-01T16:58:40Z"}, "message": "Improve rustdocs for Rc, add examples", "tree": {"sha": "9846ccf61e35c319c834c22ca8cd984516cf7ea4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9846ccf61e35c319c834c22ca8cd984516cf7ea4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88008b3ad564ed2ba16c2acf4e9538f20a71f541", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88008b3ad564ed2ba16c2acf4e9538f20a71f541", "html_url": "https://github.com/rust-lang/rust/commit/88008b3ad564ed2ba16c2acf4e9538f20a71f541", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88008b3ad564ed2ba16c2acf4e9538f20a71f541/comments", "author": {"login": "AlisdairO", "id": 6296622, "node_id": "MDQ6VXNlcjYyOTY2MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6296622?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlisdairO", "html_url": "https://github.com/AlisdairO", "followers_url": "https://api.github.com/users/AlisdairO/followers", "following_url": "https://api.github.com/users/AlisdairO/following{/other_user}", "gists_url": "https://api.github.com/users/AlisdairO/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlisdairO/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlisdairO/subscriptions", "organizations_url": "https://api.github.com/users/AlisdairO/orgs", "repos_url": "https://api.github.com/users/AlisdairO/repos", "events_url": "https://api.github.com/users/AlisdairO/events{/privacy}", "received_events_url": "https://api.github.com/users/AlisdairO/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AlisdairO", "id": 6296622, "node_id": "MDQ6VXNlcjYyOTY2MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6296622?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlisdairO", "html_url": "https://github.com/AlisdairO", "followers_url": "https://api.github.com/users/AlisdairO/followers", "following_url": "https://api.github.com/users/AlisdairO/following{/other_user}", "gists_url": "https://api.github.com/users/AlisdairO/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlisdairO/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlisdairO/subscriptions", "organizations_url": "https://api.github.com/users/AlisdairO/orgs", "repos_url": "https://api.github.com/users/AlisdairO/repos", "events_url": "https://api.github.com/users/AlisdairO/events{/privacy}", "received_events_url": "https://api.github.com/users/AlisdairO/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c0b3ab42a8f963b5e766605f31028e30cd9c0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c0b3ab42a8f963b5e766605f31028e30cd9c0a", "html_url": "https://github.com/rust-lang/rust/commit/14c0b3ab42a8f963b5e766605f31028e30cd9c0a"}], "stats": {"total": 143, "additions": 134, "deletions": 9}, "files": [{"sha": "d97bce39c2de947693943229e618881f7bd5bfe7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 134, "deletions": 9, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/88008b3ad564ed2ba16c2acf4e9538f20a71f541/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88008b3ad564ed2ba16c2acf4e9538f20a71f541/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=88008b3ad564ed2ba16c2acf4e9538f20a71f541", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,16 +10,141 @@\n \n /*! Task-local reference-counted boxes (`Rc` type)\n \n-The `Rc` type provides shared ownership of an immutable value. Destruction is deterministic, and\n-will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n-overhead of atomic reference counting.\n+The `Rc` type provides shared ownership of an immutable value. Destruction is\n+deterministic, and will occur as soon as the last owner is gone. It is marked\n+as non-sendable because it avoids the overhead of atomic reference counting.\n \n-The `downgrade` method can be used to create a non-owning `Weak` pointer to the box. A `Weak`\n-pointer can be upgraded to an `Rc` pointer, but will return `None` if the value has already been\n-freed.\n+The `downgrade` method can be used to create a non-owning `Weak` pointer to the\n+box. A `Weak` pointer can be upgraded to an `Rc` pointer, but will return\n+`None` if the value has already been freed.\n \n-For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n-pointers, and then storing the parent pointers as `Weak` pointers.\n+For example, a tree with parent pointers can be represented by putting the\n+nodes behind strong `Rc` pointers, and then storing the parent pointers as\n+`Weak` pointers.\n+\n+\n+## Examples\n+\n+Consider a scenario where a set of Gadgets are owned by a given Owner.  We want\n+to have our Gadgets point to their Owner.  We can't do this with unique\n+ownership, because more than one gadget may belong to the same Owner.  Rc\n+allows us to share an Owner between multiple Gadgets, and have the Owner kept\n+alive as long as any Gadget points at it.\n+\n+```rust\n+use std::rc::Rc;\n+\n+struct Owner {\n+    name: String\n+    // ...other fields\n+}\n+\n+struct Gadget {\n+    id: int,\n+    owner: Rc<Owner>\n+    // ...other fields\n+}\n+\n+fn main() {\n+    // Create a reference counted Owner.\n+    let gadget_owner : Rc<Owner> = Rc::new(\n+            Owner { name: String::from_str(\"Gadget Man\") }\n+    );\n+\n+    // Create Gadgets belonging to gadget_owner.  To increment the reference\n+    // count we clone the Rc object.\n+    let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n+    let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+\n+    drop(gadget_owner);\n+\n+    // Despite dropping gadget_owner, we're still able to print out the name of\n+    // the Owner of the Gadgets. This is because we've only dropped the\n+    // reference count object, not the Owner it wraps. As long as there are\n+    // other Rc objects pointing at the same Owner, it will stay alive. Notice\n+    // that the Rc wrapper around Gadget.owner gets automatically dereferenced\n+    // for us.\n+    println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n+    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n+\n+    // At the end of the method, gadget1 and gadget2 get destroyed, and with\n+    // them the last counted references to our Owner.  Gadget Man now gets\n+    // destroyed as well.\n+}\n+```\n+\n+If our requirements change, and we also need to be able to traverse from\n+Owner->Gadget, we will run into problems: an Rc pointer from Owner->Gadget\n+introduces a cycle between the objects.  This means that their reference counts\n+can never reach 0, and the objects will stay alive: a memory leak.  In order to\n+get around this, we can use `Weak` pointers.  These are reference counted\n+pointers that don't keep an object alive if there are no normal `Rc` (or\n+*strong*) pointers left.\n+\n+Rust actually makes it somewhat difficult to produce this loop in the first\n+place: in order to end up with two objects that point at each other, one of\n+them needs to be mutable.  This is problematic because Rc enforces memory\n+safety by only giving out shared references to the object it wraps, and these\n+don't allow direct mutation.  We need to wrap the part of the object we wish to\n+mutate in a `RefCell`, which provides *interior mutability*: a method to\n+achieve mutability through a shared reference.  `RefCell` enforces Rust's\n+borrowing rules at runtime.  Read the `Cell` documentation for more details on\n+interior mutability.\n+\n+```rust\n+use std::rc::Rc;\n+use std::rc::Weak;\n+use std::cell::RefCell;\n+\n+struct Owner {\n+    name: String,\n+    gadgets: RefCell<Vec<Weak<Gadget>>>\n+    // ...other fields\n+}\n+\n+struct Gadget {\n+    id: int,\n+    owner: Rc<Owner>\n+    // ...other fields\n+}\n+\n+fn main() {\n+    // Create a reference counted Owner.  Note the fact that we've put the\n+    // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n+    // through a shared reference.\n+    let gadget_owner : Rc<Owner> = Rc::new(\n+            Owner {\n+                name: \"Gadget Man\".to_string(),\n+                gadgets: RefCell::new(Vec::new())\n+            }\n+    );\n+\n+    // Create Gadgets belonging to gadget_owner as before.\n+    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n+    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+\n+    // Add the Gadgets to their Owner.  To do this we mutably borrow from\n+    // the RefCell holding the Owner's Gadgets.\n+    gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n+    gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n+\n+    // Iterate over our Gadgets, printing their details out\n+    for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+\n+        // gadget_opt is a Weak<Gadget>.  Since weak pointers can't guarantee\n+        // that their object is still alive, we need to call upgrade() on them\n+        // to turn them into a strong reference.  This returns an Option, which\n+        // contains a reference to our object if it still exists.\n+        let gadget = gadget_opt.upgrade().unwrap();\n+        println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n+    }\n+\n+    // At the end of the method, gadget_owner, gadget1 and gadget2 get\n+    // destroyed.  There are now no strong (Rc) references to the gadgets.\n+    // Once they get destroyed, the Gadgets get destroyed.  This zeroes the\n+    // reference count on Gadget Man, so he gets destroyed as well.\n+}\n+```\n \n */\n "}]}