{"sha": "a8207b195840fc664ffc4a9c033cd3ee0746ea2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MjA3YjE5NTg0MGZjNjY0ZmZjNGE5YzAzM2NkM2VlMDc0NmVhMmU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-11-12T21:35:52Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-12-12T21:36:25Z"}, "message": "Remove `NodeState::{Waiting,Done}`.\n\n`NodeState` has two states, `Success` and `Done`, that are only used\nwithin `ObligationForest` methods. This commit removes them, and renames\nthe existing `Waiting` state as `Success`.\n\nWe are left with three states: `Pending`, `Success`, and `Error`.\n`Success` is augmented with a new `WaitingState`, which indicates when\n(if ever) it was last waiting on one or more `Pending` nodes. This\nnotion of \"when\" requires adding a \"process generation\" to\n`ObligationForest`; it is incremented on each call to\n`process_obligtions`.\n\nThis commit is a performance win.\n\n- Most of the benefit comes from `mark_as_waiting` (which the commit\n  renames as `mark_still_waiting_nodes`). This function used to do two\n  things: (a) change all `Waiting` nodes to `Success`, and (b) mark all\n  nodes that depend on a pending node as `Waiting`. In practice, many\n  nodes went from `Waiting` to `Success` and then immediately back to\n  `Waiting`. The use of generations lets us skip step (a).\n\n- A smaller benefit comes from not having to change nodes to the `Done`\n  state in `process_cycles`.", "tree": {"sha": "4ca27332618afe412333ad644543a4f5f347da5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ca27332618afe412333ad644543a4f5f347da5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8207b195840fc664ffc4a9c033cd3ee0746ea2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8207b195840fc664ffc4a9c033cd3ee0746ea2e", "html_url": "https://github.com/rust-lang/rust/commit/a8207b195840fc664ffc4a9c033cd3ee0746ea2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8207b195840fc664ffc4a9c033cd3ee0746ea2e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9469a6aec2f49fa1e2ae670649f293866932253", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9469a6aec2f49fa1e2ae670649f293866932253", "html_url": "https://github.com/rust-lang/rust/commit/e9469a6aec2f49fa1e2ae670649f293866932253"}], "stats": {"total": 213, "additions": 126, "deletions": 87}, "files": [{"sha": "020facff5ff9e42a34032c098a4fb371406f4a89", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 126, "deletions": 87, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a8207b195840fc664ffc4a9c033cd3ee0746ea2e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8207b195840fc664ffc4a9c033cd3ee0746ea2e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=a8207b195840fc664ffc4a9c033cd3ee0746ea2e", "patch": "@@ -128,21 +128,19 @@ type ObligationTreeIdGenerator =\n     ::std::iter::Map<::std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n-    /// The list of obligations. In between calls to\n-    /// `process_obligations`, this list only contains nodes in the\n-    /// `Pending` or `Success` state (with a non-zero number of\n-    /// incomplete children). During processing, some of those nodes\n-    /// may be changed to the error state, or we may find that they\n-    /// are completed (That is, `num_incomplete_children` drops to 0).\n-    /// At the end of processing, those nodes will be removed by a\n-    /// call to `compress`.\n+    /// The list of obligations. In between calls to `process_obligations`,\n+    /// this list only contains nodes in the `Pending` or `Success` state.\n     ///\n     /// `usize` indices are used here and throughout this module, rather than\n-    /// `rustc_index::newtype_index!` indices, because this code is hot enough that the\n-    /// `u32`-to-`usize` conversions that would be required are significant,\n-    /// and space considerations are not important.\n+    /// `rustc_index::newtype_index!` indices, because this code is hot enough\n+    /// that the `u32`-to-`usize` conversions that would be required are\n+    /// significant, and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n+    /// The process generation is 1 on the first call to `process_obligations`,\n+    /// 2 on the second call, etc.\n+    gen: u32,\n+\n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n@@ -211,31 +209,61 @@ impl<O> Node<O> {\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n ///\n-/// Outside of ObligationForest methods, nodes should be either Pending\n-/// or Waiting.\n+/// The non-`Error` state transitions are as follows.\n+/// ```\n+/// (Pre-creation)\n+///  |\n+///  |     register_obligation_at() (called by process_obligations() and\n+///  v                               from outside the crate)\n+/// Pending\n+///  |\n+///  |     process_obligations()\n+///  v\n+/// Success(not_waiting())\n+///  |  |\n+///  |  |  mark_still_waiting_nodes()\n+///  |  v\n+///  | Success(still_waiting())\n+///  |  |\n+///  |  |  compress()\n+///  v  v\n+/// (Removed)\n+/// ```\n+/// The `Error` state can be introduced in several places, via `error_at()`.\n+///\n+/// Outside of `ObligationForest` methods, nodes should be either `Pending` or\n+/// `Success`.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum NodeState {\n-    /// Obligations for which selection had not yet returned a\n-    /// non-ambiguous result.\n+    /// This obligation has not yet been selected successfully. Cannot have\n+    /// subobligations.\n     Pending,\n \n-    /// This obligation was selected successfully, but may or\n-    /// may not have subobligations.\n-    Success,\n-\n-    /// This obligation was selected successfully, but it has\n-    /// a pending subobligation.\n-    Waiting,\n-\n-    /// This obligation, along with its subobligations, are complete,\n-    /// and will be removed in the next collection.\n-    Done,\n+    /// This obligation was selected successfully, but it may be waiting on one\n+    /// or more pending subobligations, as indicated by the `WaitingState`.\n+    Success(WaitingState),\n \n-    /// This obligation was resolved to an error. Error nodes are\n-    /// removed from the vector by the compression step.\n+    /// This obligation was resolved to an error. It will be removed by the\n+    /// next compression step.\n     Error,\n }\n \n+/// Indicates when a `Success` node was last (if ever) waiting on one or more\n+/// `Pending` nodes. The notion of \"when\" comes from `ObligationForest::gen`.\n+/// - 0: \"Not waiting\". This is a special value, set by `process_obligation`,\n+///   and usable because generation counting starts at 1.\n+/// - 1..ObligationForest::gen: \"Was waiting\" in a previous generation, but\n+///   waiting no longer. In other words, finished.\n+/// - ObligationForest::gen: \"Still waiting\" in this generation.\n+///\n+/// Things to note about this encoding:\n+/// - Every time `ObligationForest::gen` is incremented, all the \"still\n+///   waiting\" nodes automatically become \"was waiting\".\n+/// - `ObligationForest::is_still_waiting` is very cheap.\n+///\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd)]\n+struct WaitingState(u32);\n+\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n     /// Obligations that were completely evaluated, including all\n@@ -272,6 +300,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n+            gen: 0,\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n             node_rewrites: RefCell::new(vec![]),\n@@ -382,6 +411,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_predicate().clone());\n     }\n \n+    fn not_waiting() -> WaitingState {\n+        WaitingState(0)\n+    }\n+\n+    fn still_waiting(&self) -> WaitingState {\n+        WaitingState(self.gen)\n+    }\n+\n+    fn is_still_waiting(&self, waiting: WaitingState) -> bool {\n+        waiting.0 == self.gen\n+    }\n+\n     /// Performs a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n@@ -392,6 +433,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n \n+        self.gen += 1;\n+\n         let mut errors = vec![];\n         let mut stalled = true;\n \n@@ -429,7 +472,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    node.state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success(Self::not_waiting()));\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n@@ -464,7 +507,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             };\n         }\n \n-        self.mark_as_waiting();\n+        self.mark_still_waiting_nodes();\n         self.process_cycles(processor);\n         let completed = self.compress(do_completed);\n \n@@ -477,10 +520,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    /// Mark all `NodeState::Success` nodes as `NodeState::Done` and\n-    /// report all cycles between them. This should be called\n-    /// after `mark_as_waiting` marks all nodes with pending\n-    /// subobligations as NodeState::Waiting.\n+    /// Report cycles between all `Success` nodes that aren't still waiting.\n+    /// This must be called after `mark_still_waiting_nodes`.\n     fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n@@ -489,11 +530,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n         debug!(\"process_cycles()\");\n \n         for (index, node) in self.nodes.iter().enumerate() {\n-            // For some benchmarks this state test is extremely\n-            // hot. It's a win to handle the no-op cases immediately to avoid\n-            // the cost of the function call.\n-            if node.state.get() == NodeState::Success {\n-                self.find_cycles_from_node(&mut stack, processor, index);\n+            // For some benchmarks this state test is extremely hot. It's a win\n+            // to handle the no-op cases immediately to avoid the cost of the\n+            // function call.\n+            if let NodeState::Success(waiting) = node.state.get() {\n+                if !self.is_still_waiting(waiting) {\n+                    self.find_cycles_from_node(&mut stack, processor, index);\n+                }\n             }\n         }\n \n@@ -506,22 +549,23 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let node = &self.nodes[index];\n-        if node.state.get() == NodeState::Success {\n-            match stack.iter().rposition(|&n| n == index) {\n-                None => {\n-                    stack.push(index);\n-                    for &index in node.dependents.iter() {\n-                        self.find_cycles_from_node(stack, processor, index);\n+        if let NodeState::Success(waiting) = node.state.get() {\n+            if !self.is_still_waiting(waiting) {\n+                match stack.iter().rposition(|&n| n == index) {\n+                    None => {\n+                        stack.push(index);\n+                        for &index in node.dependents.iter() {\n+                            self.find_cycles_from_node(stack, processor, index);\n+                        }\n+                        stack.pop();\n+                    }\n+                    Some(rpos) => {\n+                        // Cycle detected.\n+                        processor.process_backedge(\n+                            stack[rpos..].iter().map(GetObligation(&self.nodes)),\n+                            PhantomData\n+                        );\n                     }\n-                    stack.pop();\n-                    node.state.set(NodeState::Done);\n-                }\n-                Some(rpos) => {\n-                    // Cycle detected.\n-                    processor.process_backedge(\n-                        stack[rpos..].iter().map(GetObligation(&self.nodes)),\n-                        PhantomData\n-                    );\n                 }\n             }\n         }\n@@ -562,62 +606,52 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n-    fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+    fn inlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n         for &index in node.dependents.iter() {\n             let node = &self.nodes[index];\n-            match node.state.get() {\n-                NodeState::Waiting | NodeState::Error => {}\n-                NodeState::Success => {\n-                    node.state.set(NodeState::Waiting);\n+            if let NodeState::Success(waiting) = node.state.get() {\n+                if !self.is_still_waiting(waiting) {\n+                    node.state.set(NodeState::Success(self.still_waiting()));\n                     // This call site is cold.\n-                    self.uninlined_mark_neighbors_as_waiting_from(node);\n-                }\n-                NodeState::Pending | NodeState::Done => {\n-                    // This call site is cold.\n-                    self.uninlined_mark_neighbors_as_waiting_from(node);\n+                    self.uninlined_mark_dependents_as_still_waiting(node);\n                 }\n             }\n         }\n     }\n \n     // This never-inlined function is for the cold call site.\n     #[inline(never)]\n-    fn uninlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        self.inlined_mark_neighbors_as_waiting_from(node)\n+    fn uninlined_mark_dependents_as_still_waiting(&self, node: &Node<O>) {\n+        self.inlined_mark_dependents_as_still_waiting(node)\n     }\n \n-    /// Marks all nodes that depend on a pending node as `NodeState::Waiting`.\n-    fn mark_as_waiting(&self) {\n-        for node in &self.nodes {\n-            if node.state.get() == NodeState::Waiting {\n-                node.state.set(NodeState::Success);\n-            }\n-        }\n-\n+    /// Mark all `Success` nodes that depend on a pending node as still\n+    /// waiting. Upon completion, any `Success` nodes that aren't still waiting\n+    /// can be removed by `compress`.\n+    fn mark_still_waiting_nodes(&self) {\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n                 // This call site is hot.\n-                self.inlined_mark_neighbors_as_waiting_from(node);\n+                self.inlined_mark_dependents_as_still_waiting(node);\n             }\n         }\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts the\n-    /// indices and hence invalidates any outstanding indices.\n-    ///\n-    /// Beforehand, all nodes must be marked as `Done` and no cycles\n-    /// on these nodes may be present. This is done by e.g., `process_cycles`.\n+    /// indices and hence invalidates any outstanding indices. `process_cycles`\n+    /// must be run beforehand to remove any cycles on not-still-waiting\n+    /// `Success` nodes.\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let orig_nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.node_rewrites.replace(vec![]);\n         debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n-        let mut removed_done_obligations: Vec<O> = vec![];\n+        let mut removed_success_obligations: Vec<O> = vec![];\n \n-        // Now move all Done/Error nodes to the end, preserving the order of\n-        // the Pending/Waiting nodes.\n+        // Move removable nodes to the end, preserving the order of the\n+        // remaining nodes.\n         //\n         // LOOP INVARIANT:\n         //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n@@ -626,13 +660,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n         for index in 0..orig_nodes_len {\n             let node = &self.nodes[index];\n             match node.state.get() {\n-                NodeState::Pending | NodeState::Waiting => {\n+                NodeState::Pending => {\n+                    if dead_nodes > 0 {\n+                        self.nodes.swap(index, index - dead_nodes);\n+                        node_rewrites[index] -= dead_nodes;\n+                    }\n+                }\n+                NodeState::Success(waiting) if self.is_still_waiting(waiting) => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(index, index - dead_nodes);\n                         node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n-                NodeState::Done => {\n+                NodeState::Success(_) => {\n                     // This lookup can fail because the contents of\n                     // `self.active_cache` are not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n@@ -646,7 +686,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                     if do_completed == DoCompleted::Yes {\n                         // Extract the success stories.\n-                        removed_done_obligations.push(node.obligation.clone());\n+                        removed_success_obligations.push(node.obligation.clone());\n                     }\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n@@ -660,7 +700,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n-                NodeState::Success => unreachable!()\n             }\n         }\n \n@@ -674,7 +713,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.node_rewrites.replace(node_rewrites);\n \n         if do_completed == DoCompleted::Yes {\n-            Some(removed_done_obligations)\n+            Some(removed_success_obligations)\n         } else {\n             None\n         }"}]}