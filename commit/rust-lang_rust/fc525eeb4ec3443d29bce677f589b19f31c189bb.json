{"sha": "fc525eeb4ec3443d29bce677f589b19f31c189bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNTI1ZWViNGVjMzQ0M2QyOWJjZTY3N2Y1ODliMTlmMzFjMTg5YmI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-09-15T03:27:36Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-09-16T21:37:48Z"}, "message": "Fallout from renaming", "tree": {"sha": "d807bad5c91171751157a945dde963dcfd4ea95e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d807bad5c91171751157a945dde963dcfd4ea95e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc525eeb4ec3443d29bce677f589b19f31c189bb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc525eeb4ec3443d29bce677f589b19f31c189bb", "html_url": "https://github.com/rust-lang/rust/commit/fc525eeb4ec3443d29bce677f589b19f31c189bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc525eeb4ec3443d29bce677f589b19f31c189bb/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8dfe1957b6541de8fe2797e248fe4bd2fac02d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8dfe1957b6541de8fe2797e248fe4bd2fac02d9", "html_url": "https://github.com/rust-lang/rust/commit/d8dfe1957b6541de8fe2797e248fe4bd2fac02d9"}], "stats": {"total": 1575, "additions": 793, "deletions": 782}, "files": [{"sha": "8188cb17b27c805e8a7cf5a50dd7b5eee75ff04a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -259,7 +259,7 @@ pub fn run_tests(config: &Config) {\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n     io::test::raise_fd_limit();\n-    let res = test::run_tests_console(&opts, tests.move_iter().collect());\n+    let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}\n         Ok(false) => fail!(\"Some tests failed\"),\n@@ -400,4 +400,4 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n         },\n         _ => None\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f3f860d470d9317e858a2fdc8f103024f8fd59a2", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -40,7 +40,7 @@ pub fn run(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.move_iter() {\n+    for (key, val) in env.into_iter() {\n         cmd.env(key, val);\n     }\n \n@@ -72,7 +72,7 @@ pub fn run_background(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args);\n     add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env.move_iter() {\n+    for (key, val) in env.into_iter() {\n         cmd.env(key, val);\n     }\n "}, {"sha": "40acb7da1750a968150c03723436f0e8e33473b3", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -768,7 +768,7 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n         \"--debuginfo\".to_string()\n     ];\n     let new_options =\n-        split_maybe_args(options).move_iter()\n+        split_maybe_args(options).into_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n                                  .collect::<Vec<String>>()\n                                  .connect(\" \");\n@@ -1461,7 +1461,7 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     // run test via adb_run_wrapper\n     runargs.push(\"shell\".to_string());\n-    for (key, val) in env.move_iter() {\n+    for (key, val) in env.into_iter() {\n         runargs.push(format!(\"{}={}\", key, val));\n     }\n     runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));"}, {"sha": "95bcc9ca12b30abaa843fefdfdb79f7954c17c28", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -238,7 +238,7 @@ fn main() {\n     let mut futures = Vec::from_fn(1000, |ind| Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n-    for ft in futures.mut_iter()  {\n+    for ft in futures.iter_mut()  {\n         final_res += ft.get();\n     }\n     println!(\"\u03c0^2/6 is not far from : {}\", final_res);"}, {"sha": "41a0e9abf6c02944b66deff5f3a0556af2c2f8f2", "filename": "src/doc/guide.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1319,7 +1319,7 @@ upper bound is exclusive, though, so our loop will print `0` through `9`, not\n \n Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n-developers. \n+developers.\n \n We'll talk more about `for` when we cover **iterator**s, later in the Guide.\n "}, {"sha": "51e1f64e0065defebb62ec4ec77cc07c22f007ee", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -140,7 +140,7 @@ static MIN_ALIGN: uint = 16;\n #[cfg(jemalloc)]\n mod imp {\n     use core::option::{None, Option};\n-    use core::ptr::{RawPtr, mut_null, null};\n+    use core::ptr::{RawPtr, null_mut, null};\n     use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n     use super::MIN_ALIGN;\n@@ -230,7 +230,7 @@ mod imp {\n \n     pub fn stats_print() {\n         unsafe {\n-            je_malloc_stats_print(None, mut_null(), null())\n+            je_malloc_stats_print(None, null_mut(), null())\n         }\n     }\n }"}, {"sha": "4f6400630fd9c14aceb5e963c01c1d26c3020db9", "filename": "src/liballoc/libc_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fliballoc%2Flibc_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Fliballoc%2Flibc_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flibc_heap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -12,15 +12,15 @@\n //! The global (exchange) heap.\n \n use libc::{c_void, size_t, free, malloc, realloc};\n-use core::ptr::{RawPtr, mut_null};\n+use core::ptr::{RawPtr, null_mut};\n \n /// A wrapper around libc::malloc, aborting on out-of-memory.\n #[inline]\n pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n     // `malloc(0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/malloc.html\n     if size == 0 {\n-        mut_null()\n+        null_mut()\n     } else {\n         let p = malloc(size as size_t);\n         if p.is_null() {\n@@ -37,7 +37,7 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n     if size == 0 {\n         free(ptr as *mut c_void);\n-        mut_null()\n+        null_mut()\n     } else {\n         let p = realloc(ptr as *mut c_void, size as size_t);\n         if p.is_null() {"}, {"sha": "d691e01a562766f02d521b69bf1163aac8361d3b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -448,7 +448,7 @@ impl<T> TypedArena<T> {\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n         unsafe {\n-            let chunk = TypedArenaChunk::<T>::new(ptr::mut_null(), capacity);\n+            let chunk = TypedArenaChunk::<T>::new(ptr::null_mut(), capacity);\n             TypedArena {\n                 ptr: Cell::new((*chunk).start() as *const T),\n                 end: Cell::new((*chunk).end() as *const T),"}, {"sha": "11affb9dfd576bc55921b8ee5b82a4048a2fdbc7", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -178,7 +178,7 @@ impl Bitv {\n         // `op` is a bitwise operation, since any bits that should've\n         // been masked were fine to change anyway. `b` is masked to\n         // make sure its unmasked bits do not cause damage.\n-        for (a, (_, b)) in self.storage.mut_iter()\n+        for (a, (_, b)) in self.storage.iter_mut()\n                            .zip(other.mask_words(0)) {\n             let w = op(*a, b);\n             if *a != w {\n@@ -310,7 +310,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n-        for w in self.storage.mut_iter() { *w = !0u; }\n+        for w in self.storage.iter_mut() { *w = !0u; }\n     }\n \n     /// Flips all bits.\n@@ -329,7 +329,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n-        for w in self.storage.mut_iter() { *w = !*w; }\n+        for w in self.storage.iter_mut() { *w = !*w; }\n     }\n \n     /// Calculates the union of two bitvectors. This acts like the bitwise `or`\n@@ -797,7 +797,7 @@ impl Collection for Bitv {\n impl Mutable for Bitv {\n     #[inline]\n     fn clear(&mut self) {\n-        for w in self.storage.mut_iter() { *w = 0u; }\n+        for w in self.storage.iter_mut() { *w = 0u; }\n     }\n }\n \n@@ -831,7 +831,7 @@ impl Clone for Bitv {\n     fn clone_from(&mut self, source: &Bitv) {\n         self.nbits = source.nbits;\n         self.storage.reserve(source.storage.len());\n-        for (i, w) in self.storage.mut_iter().enumerate() { *w = source.storage[i]; }\n+        for (i, w) in self.storage.iter_mut().enumerate() { *w = source.storage[i]; }\n     }\n }\n "}, {"sha": "45f5e98aa3e83f4548b8340b86a3727f43de8a7a", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -79,7 +79,7 @@ pub struct MoveItems<T> {\n impl<T> Rawlink<T> {\n     /// Like Option::None for Rawlink\n     fn none() -> Rawlink<T> {\n-        Rawlink{p: ptr::mut_null()}\n+        Rawlink{p: ptr::null_mut()}\n     }\n \n     /// Like Option::Some for Rawlink\n@@ -431,7 +431,7 @@ impl<T> DList<T> {\n     /// ```\n     pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) {\n         {\n-            let mut it = self.mut_iter();\n+            let mut it = self.iter_mut();\n             loop {\n                 match it.peek_next() {\n                     None => break,\n@@ -451,7 +451,7 @@ impl<T> DList<T> {\n     /// This operation should compute in O(max(N, M)) time.\n     pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n         {\n-            let mut it = self.mut_iter();\n+            let mut it = self.iter_mut();\n             loop {\n                 let take_a = match (it.peek_next(), other.front()) {\n                     (_   , None) => return,\n@@ -871,7 +871,7 @@ mod tests {\n         check_links(&m);\n         let sum = v.append(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.move_iter() {\n+        for elt in sum.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -895,7 +895,7 @@ mod tests {\n         check_links(&m);\n         let sum = u.append(v.as_slice());\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.move_iter() {\n+        for elt in sum.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -920,7 +920,7 @@ mod tests {\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(vec![3i,9,5,1,2], m.move_iter().collect());\n+        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect());\n     }\n \n     #[test]\n@@ -991,16 +991,16 @@ mod tests {\n     fn test_mut_iter() {\n         let mut m = generate_test();\n         let mut len = m.len();\n-        for (i, elt) in m.mut_iter().enumerate() {\n+        for (i, elt) in m.iter_mut().enumerate() {\n             assert_eq!(i as int, *elt);\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n         let mut n = DList::new();\n-        assert!(n.mut_iter().next().is_none());\n+        assert!(n.iter_mut().next().is_none());\n         n.push_front(4i);\n         n.push(5);\n-        let mut it = n.mut_iter();\n+        let mut it = n.iter_mut();\n         assert_eq!(it.size_hint(), (2, Some(2)));\n         assert!(it.next().is_some());\n         assert!(it.next().is_some());\n@@ -1011,11 +1011,11 @@ mod tests {\n     #[test]\n     fn test_iterator_mut_double_end() {\n         let mut n = DList::new();\n-        assert!(n.mut_iter().next_back().is_none());\n+        assert!(n.iter_mut().next_back().is_none());\n         n.push_front(4i);\n         n.push_front(5);\n         n.push_front(6);\n-        let mut it = n.mut_iter();\n+        let mut it = n.iter_mut();\n         assert_eq!(it.size_hint(), (3, Some(3)));\n         assert_eq!(*it.next().unwrap(), 6);\n         assert_eq!(it.size_hint(), (2, Some(2)));\n@@ -1031,7 +1031,7 @@ mod tests {\n         let mut m = list_from(&[0i,2,4,6,8]);\n         let len = m.len();\n         {\n-            let mut it = m.mut_iter();\n+            let mut it = m.iter_mut();\n             it.insert_next(-2);\n             loop {\n                 match it.next() {\n@@ -1050,7 +1050,7 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.move_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -1061,7 +1061,7 @@ mod tests {\n         m.merge(n, |a, b| a <= b);\n         assert_eq!(m.len(), len);\n         check_links(&m);\n-        let res = m.move_iter().collect::<Vec<int>>();\n+        let res = m.into_iter().collect::<Vec<int>>();\n         assert_eq!(res, vec![-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n     }\n \n@@ -1077,19 +1077,19 @@ mod tests {\n         m.push(4);\n         m.insert_ordered(3);\n         check_links(&m);\n-        assert_eq!(vec![2,3,4], m.move_iter().collect::<Vec<int>>());\n+        assert_eq!(vec![2,3,4], m.into_iter().collect::<Vec<int>>());\n     }\n \n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n-        for (i, elt) in m.mut_iter().rev().enumerate() {\n+        for (i, elt) in m.iter_mut().rev().enumerate() {\n             assert_eq!((6-i) as int, *elt);\n         }\n         let mut n = DList::new();\n-        assert!(n.mut_iter().rev().next().is_none());\n+        assert!(n.iter_mut().rev().next().is_none());\n         n.push_front(4i);\n-        let mut it = n.mut_iter().rev();\n+        let mut it = n.iter_mut().rev();\n         assert!(it.next().is_some());\n         assert!(it.next().is_none());\n     }\n@@ -1229,7 +1229,7 @@ mod tests {\n         check_links(&m);\n \n         let mut i = 0u;\n-        for (a, &b) in m.move_iter().zip(v.iter()) {\n+        for (a, &b) in m.into_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n         }\n@@ -1311,7 +1311,7 @@ mod tests {\n         let v = &[0i, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.mut_iter().count() == 128);\n+            assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n@@ -1327,7 +1327,7 @@ mod tests {\n         let v = &[0i, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.mut_iter().rev().count() == 128);\n+            assert!(m.iter_mut().rev().count() == 128);\n         })\n     }\n }"}, {"sha": "90ee24eb587a54c03d1fd9fb6e8ed3d43fea3f00", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -43,7 +43,7 @@ impl<T> Collection for RingBuf<T> {\n impl<T> Mutable for RingBuf<T> {\n     /// Clears the `RingBuf`, removing all values.\n     fn clear(&mut self) {\n-        for x in self.elts.mut_iter() { *x = None }\n+        for x in self.elts.iter_mut() { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n     }\n@@ -267,11 +267,11 @@ impl<T> RingBuf<T> {\n     /// buf.push(5i);\n     /// buf.push(3);\n     /// buf.push(4);\n-    /// for num in buf.mut_iter() {\n+    /// for num in buf.iter_mut() {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.mut_iter().collect::<Vec<&mut int>>().as_slice(), b);\n+    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>().as_slice(), b);\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -283,15 +283,15 @@ impl<T> RingBuf<T> {\n             //    start_index to self.elts.len()\n             // and then\n             //    0 to end_index\n-            let (temp, remaining1) = self.elts.mut_split_at(start_index);\n-            let (remaining2, _) = temp.mut_split_at(end_index);\n+            let (temp, remaining1) = self.elts.split_at_mut(start_index);\n+            let (remaining2, _) = temp.split_at_mut(end_index);\n             MutItems { remaining1: remaining1,\n                                  remaining2: remaining2,\n                                  nelts: self.nelts }\n         } else {\n             // Items to iterate goes from start_index to end_index:\n-            let (empty, elts) = self.elts.mut_split_at(0);\n-            let remaining1 = elts.mut_slice(start_index, end_index);\n+            let (empty, elts) = self.elts.split_at_mut(0);\n+            let remaining1 = elts.slice_mut(start_index, end_index);\n             MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }\n@@ -919,34 +919,34 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter_wrap() {\n         let mut d = RingBuf::with_capacity(3);\n-        assert!(d.mut_iter().rev().next().is_none());\n+        assert!(d.iter_mut().rev().next().is_none());\n \n         d.push(1i);\n         d.push(2);\n         d.push(3);\n         assert_eq!(d.pop_front(), Some(1));\n         d.push(4);\n \n-        assert_eq!(d.mut_iter().rev().map(|x| *x).collect::<Vec<int>>(),\n+        assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<int>>(),\n                    vec!(4, 3, 2));\n     }\n \n     #[test]\n     fn test_mut_iter() {\n         let mut d = RingBuf::new();\n-        assert!(d.mut_iter().next().is_none());\n+        assert!(d.iter_mut().next().is_none());\n \n         for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        for (i, elt) in d.mut_iter().enumerate() {\n+        for (i, elt) in d.iter_mut().enumerate() {\n             assert_eq!(*elt, 2 - i);\n             *elt = i;\n         }\n \n         {\n-            let mut it = d.mut_iter();\n+            let mut it = d.iter_mut();\n             assert_eq!(*it.next().unwrap(), 0);\n             assert_eq!(*it.next().unwrap(), 1);\n             assert_eq!(*it.next().unwrap(), 2);\n@@ -957,19 +957,19 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut d = RingBuf::new();\n-        assert!(d.mut_iter().rev().next().is_none());\n+        assert!(d.iter_mut().rev().next().is_none());\n \n         for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        for (i, elt) in d.mut_iter().rev().enumerate() {\n+        for (i, elt) in d.iter_mut().rev().enumerate() {\n             assert_eq!(*elt, i);\n             *elt = i;\n         }\n \n         {\n-            let mut it = d.mut_iter().rev();\n+            let mut it = d.iter_mut().rev();\n             assert_eq!(*it.next().unwrap(), 0);\n             assert_eq!(*it.next().unwrap(), 1);\n             assert_eq!(*it.next().unwrap(), 2);"}, {"sha": "f93b5c89127e51d29f2498570cf367fc404dc4a3", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -77,7 +77,7 @@\n //! }\n //! ```\n //!\n-//! * `.mut_iter()` returns an iterator that allows modifying each value.\n+//! * `.iter_mut()` returns an iterator that allows modifying each value.\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n@@ -195,7 +195,7 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n                 self.sdir.as_mut_slice().swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n-                for x in self.sdir.mut_iter() {\n+                for x in self.sdir.iter_mut() {\n                     if x.size > sd.size {\n                         x.dir = match x.dir { Pos => Neg, Neg => Pos };\n                     }\n@@ -606,7 +606,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -698,7 +698,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.mut_slice_from(i).reverse();\n+        self.slice_from_mut(i).reverse();\n \n         true\n     }\n@@ -719,7 +719,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.mut_slice_from(i).reverse();\n+        self.slice_from_mut(i).reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -1685,7 +1685,7 @@ mod tests {\n     fn test_iter_size_hints() {\n         let mut xs = [1i, 2, 5, 10, 11];\n         assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.mut_iter().size_hint(), (5, Some(5)));\n+        assert_eq!(xs.iter_mut().size_hint(), (5, Some(5)));\n     }\n \n     #[test]\n@@ -1702,7 +1702,7 @@ mod tests {\n     #[test]\n     fn test_mut_iterator() {\n         let mut xs = [1i, 2, 3, 4, 5];\n-        for x in xs.mut_iter() {\n+        for x in xs.iter_mut() {\n             *x += 1;\n         }\n         assert!(xs == [2, 3, 4, 5, 6])\n@@ -1724,7 +1724,7 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iterator() {\n         let mut xs = [1u, 2, 3, 4, 5];\n-        for (i,x) in xs.mut_iter().rev().enumerate() {\n+        for (i,x) in xs.iter_mut().rev().enumerate() {\n             *x += i;\n         }\n         assert!(xs == [5, 5, 5, 5, 5])\n@@ -1733,13 +1733,13 @@ mod tests {\n     #[test]\n     fn test_move_iterator() {\n         let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.move_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+        assert_eq!(xs.into_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n         let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.move_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        assert_eq!(xs.into_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n     #[test]\n@@ -1892,7 +1892,7 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n+        assert_eq!(a.slice_mut(2,4).move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n@@ -1911,7 +1911,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values.mut_slice(1, 4).reverse();\n+        values.slice_mut(1, 4).reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -1958,9 +1958,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values.mut_slice(0,5).set_memory(0xAB);\n+        values.slice_mut(0,5).set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values.mut_slice(2,4).set_memory(0xFF);\n+        values.slice_mut(2,4).set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n@@ -1985,14 +1985,14 @@ mod tests {\n     fn test_mut_split_at() {\n         let mut values = [1u8,2,3,4,5];\n         {\n-            let (left, right) = values.mut_split_at(2);\n+            let (left, right) = values.split_at_mut(2);\n             assert!(left.slice(0, left.len()) == [1, 2]);\n-            for p in left.mut_iter() {\n+            for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             assert!(right.slice(0, right.len()) == [3, 4, 5]);\n-            for p in right.mut_iter() {\n+            for p in right.iter_mut() {\n                 *p += 2;\n             }\n         }\n@@ -2021,13 +2021,13 @@ mod tests {\n         }\n         assert_eq!(cnt, 5);\n \n-        for f in v.mut_iter() {\n+        for f in v.iter_mut() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }\n         assert_eq!(cnt, 8);\n \n-        for f in v.move_iter() {\n+        for f in v.into_iter() {\n             assert!(f == Foo);\n             cnt += 1;\n         }\n@@ -2113,14 +2113,14 @@ mod tests {\n     #[test]\n     fn test_mut_splitator() {\n         let mut xs = [0i,1,0,2,3,0,0,4,5,0];\n-        assert_eq!(xs.mut_split(|x| *x == 0).count(), 6);\n-        for slice in xs.mut_split(|x| *x == 0) {\n+        assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n+        for slice in xs.split_mut(|x| *x == 0) {\n             slice.reverse();\n         }\n         assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n \n         let mut xs = [0i,1,0,2,3,0,0,4,5,0,6,7];\n-        for slice in xs.mut_split(|x| *x == 0).take(5) {\n+        for slice in xs.split_mut(|x| *x == 0).take(5) {\n             slice.reverse();\n         }\n         assert!(xs == [0,1,0,3,2,0,0,5,4,0,6,7]);\n@@ -2129,7 +2129,7 @@ mod tests {\n     #[test]\n     fn test_mut_splitator_rev() {\n         let mut xs = [1i,2,0,3,4,0,0,5,6,0];\n-        for slice in xs.mut_split(|x| *x == 0).rev().take(4) {\n+        for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n             slice.reverse();\n         }\n         assert!(xs == [1,2,0,4,3,0,0,6,5,0]);\n@@ -2148,8 +2148,8 @@ mod tests {\n     #[test]\n     fn test_mut_chunks() {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n-        for (i, chunk) in v.mut_chunks(3).enumerate() {\n-            for x in chunk.mut_iter() {\n+        for (i, chunk) in v.chunks_mut(3).enumerate() {\n+            for x in chunk.iter_mut() {\n                 *x = i as u8;\n             }\n         }\n@@ -2160,8 +2160,8 @@ mod tests {\n     #[test]\n     fn test_mut_chunks_rev() {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n-        for (i, chunk) in v.mut_chunks(3).rev().enumerate() {\n-            for x in chunk.mut_iter() {\n+        for (i, chunk) in v.chunks_mut(3).rev().enumerate() {\n+            for x in chunk.iter_mut() {\n                 *x = i as u8;\n             }\n         }\n@@ -2173,7 +2173,7 @@ mod tests {\n     #[should_fail]\n     fn test_mut_chunks_0() {\n         let mut v = [1i, 2, 3, 4];\n-        let _it = v.mut_chunks(0);\n+        let _it = v.chunks_mut(0);\n     }\n \n     #[test]\n@@ -2207,11 +2207,11 @@ mod tests {\n     #[test]\n     fn test_mut_last() {\n         let mut x = [1i, 2, 3, 4, 5];\n-        let h = x.mut_last();\n+        let h = x.last_mut();\n         assert_eq!(*h.unwrap(), 5);\n \n         let y: &mut [int] = [];\n-        assert!(y.mut_last().is_none());\n+        assert!(y.last_mut().is_none());\n     }\n }\n \n@@ -2248,7 +2248,7 @@ mod bench {\n \n         b.iter(|| {\n             let mut i = 0i;\n-            for x in v.mut_iter() {\n+            for x in v.iter_mut() {\n                 *x = i;\n                 i += 1;\n             }\n@@ -2382,7 +2382,7 @@ mod bench {\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for x in v.mut_iter() {\n+            for x in v.iter_mut() {\n                 *x = 0i;\n             }\n             v"}, {"sha": "31d3415ef48934fa00a795b814ec2415f62b5c3d", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -163,7 +163,7 @@ impl<V:Clone> Clone for SmallIntMap<V> {\n     #[inline]\n     fn clone_from(&mut self, source: &SmallIntMap<V>) {\n         self.v.reserve(source.v.len());\n-        for (i, w) in self.v.mut_iter().enumerate() {\n+        for (i, w) in self.v.iter_mut().enumerate() {\n             *w = source.v[i].clone();\n         }\n     }\n@@ -280,7 +280,7 @@ impl<V> SmallIntMap<V> {\n     /// map.insert(2, \"b\");\n     /// map.insert(3, \"c\");\n     ///\n-    /// for (key, value) in map.mut_iter() {\n+    /// for (key, value) in map.iter_mut() {\n     ///     *value = \"x\";\n     /// }\n     ///\n@@ -292,7 +292,7 @@ impl<V> SmallIntMap<V> {\n         MutEntries {\n             front: 0,\n             back: self.v.len(),\n-            iter: self.v.mut_iter()\n+            iter: self.v.iter_mut()\n         }\n     }\n \n@@ -319,7 +319,7 @@ impl<V> SmallIntMap<V> {\n     /// map.insert(2, \"b\");\n     ///\n     /// // Not possible with .iter()\n-    /// let vec: Vec<(uint, &str)> = map.move_iter().collect();\n+    /// let vec: Vec<(uint, &str)> = map.into_iter().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n@@ -328,7 +328,7 @@ impl<V> SmallIntMap<V> {\n                 Enumerate<vec::MoveItems<Option<V>>>>\n     {\n         let values = replace(&mut self.v, vec!());\n-        values.move_iter().enumerate().filter_map(|(i, v)| {\n+        values.into_iter().enumerate().filter_map(|(i, v)| {\n             v.map(|v| (i, v))\n         })\n     }\n@@ -692,8 +692,8 @@ mod test_map {\n \n         assert_eq!(m.iter().size_hint(), (0, Some(11)));\n         assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n-        assert_eq!(m.mut_iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.mut_iter().rev().size_hint(), (0, Some(11)));\n+        assert_eq!(m.iter_mut().size_hint(), (0, Some(11)));\n+        assert_eq!(m.iter_mut().rev().size_hint(), (0, Some(11)));\n     }\n \n     #[test]\n@@ -706,7 +706,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for (k, v) in m.mut_iter() {\n+        for (k, v) in m.iter_mut() {\n             *v += k as int;\n         }\n \n@@ -748,7 +748,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for (k, v) in m.mut_iter().rev() {\n+        for (k, v) in m.iter_mut().rev() {\n             *v += k as int;\n         }\n \n@@ -766,7 +766,7 @@ mod test_map {\n         let mut m = SmallIntMap::new();\n         m.insert(1, box 2i);\n         let mut called = false;\n-        for (k, v) in m.move_iter() {\n+        for (k, v) in m.into_iter() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);"}, {"sha": "73e2d8466546ffcaedda6b8b3039e323bdf905e7", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -380,7 +380,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// map.insert(\"b\", 2i);\n     ///\n     /// // Add 10 until we find \"b\"\n-    /// for (key, value) in map.mut_iter() {\n+    /// for (key, value) in map.iter_mut() {\n     ///     *value += 10;\n     ///     if key == &\"b\" { break }\n     /// }\n@@ -417,7 +417,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// map.insert(\"b\", 2i);\n     ///\n     /// // Add 10 until we find \"b\"\n-    /// for (key, value) in map.mut_rev_iter() {\n+    /// for (key, value) in map.rev_iter_mut() {\n     ///     *value += 10;\n     ///     if key == &\"b\" { break }\n     /// }\n@@ -427,11 +427,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.find(&\"c\"), Some(&13));\n     /// ```\n     pub fn rev_iter_mut<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n-        RevMutEntries{iter: self.mut_iter()}\n+        RevMutEntries{iter: self.iter_mut()}\n     }\n \n     /// Deprecated: use `into_iter`.\n-    #[depreated = \"use into_iter\"]\n+    #[deprecated = \"use into_iter\"]\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         self.into_iter()\n     }\n@@ -448,7 +448,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// map.insert(\"b\", 2i);\n     ///\n     /// // Not possible with a regular `.iter()`\n-    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n     /// ```\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n@@ -512,7 +512,7 @@ impl<K, V> TreeMap<K, V> {\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n     /// let new_ua = \"Safari/156.0\";\n-    /// match t.find_mut_with(|k| \"User-Agent\".cmp(k)) {\n+    /// match t.find_with_mut(|k| \"User-Agent\".cmp(k)) {\n     ///    Some(x) => *x = new_ua,\n     ///    None => fail!(),\n     /// }\n@@ -649,11 +649,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// map.insert(6, \"c\");\n     /// map.insert(8, \"d\");\n     ///\n-    /// assert_eq!(map.mut_lower_bound(&4).next(), Some((&4, &mut \"b\")));\n-    /// assert_eq!(map.mut_lower_bound(&5).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.mut_lower_bound(&10).next(), None);\n+    /// assert_eq!(map.lower_bound_mut(&4).next(), Some((&4, &mut \"b\")));\n+    /// assert_eq!(map.lower_bound_mut(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.lower_bound_mut(&10).next(), None);\n     ///\n-    /// for (key, value) in map.mut_lower_bound(&4) {\n+    /// for (key, value) in map.lower_bound_mut(&4) {\n     ///     *value = \"changed\";\n     /// }\n     ///\n@@ -689,11 +689,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// map.insert(6, \"c\");\n     /// map.insert(8, \"d\");\n     ///\n-    /// assert_eq!(map.mut_upper_bound(&4).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.mut_upper_bound(&5).next(), Some((&6, &mut \"c\")));\n-    /// assert_eq!(map.mut_upper_bound(&10).next(), None);\n+    /// assert_eq!(map.upper_bound_mut(&4).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.upper_bound_mut(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.upper_bound_mut(&10).next(), None);\n     ///\n-    /// for (key, value) in map.mut_upper_bound(&4) {\n+    /// for (key, value) in map.upper_bound_mut(&4) {\n     ///     *value = \"changed\";\n     /// }\n     ///\n@@ -919,7 +919,7 @@ fn deref_mut<K, V>(x: &mut Option<Box<TreeNode<K, V>>>)\n             let n: &mut TreeNode<K, V> = &mut **n;\n             n as *mut TreeNode<K, V>\n         }\n-        None => ptr::mut_null()\n+        None => ptr::null_mut()\n     }\n }\n \n@@ -1220,7 +1220,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n     ///\n     /// // Not possible with a regular `.iter()`\n-    /// let v: Vec<int> = set.move_iter().collect();\n+    /// let v: Vec<int> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n@@ -1583,7 +1583,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n                                  child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n-        for x in child.mut_iter() {\n+        for x in child.iter_mut() {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n@@ -1639,18 +1639,18 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n \n                 if right_level > save.level {\n                     let save_level = save.level;\n-                    for x in save.right.mut_iter() { x.level = save_level }\n+                    for x in save.right.iter_mut() { x.level = save_level }\n                 }\n \n                 skew(save);\n \n-                for right in save.right.mut_iter() {\n+                for right in save.right.iter_mut() {\n                     skew(right);\n-                    for x in right.right.mut_iter() { skew(x) }\n+                    for x in right.right.iter_mut() { skew(x) }\n                 }\n \n                 split(save);\n-                for x in save.right.mut_iter() { split(x) }\n+                for x in save.right.iter_mut() { split(x) }\n             }\n \n             return ret;\n@@ -1780,7 +1780,7 @@ mod test_treemap {\n         assert!(m.insert(\"t2\", 8));\n         assert!(m.insert(\"t5\", 14));\n         let new = 100;\n-        match m.find_mut_with(|k| \"t5\".cmp(k)) {\n+        match m.find_with_mut(|k| \"t5\".cmp(k)) {\n           None => fail!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find_with(|k| \"t5\".cmp(k)), Some(&new));\n@@ -2006,7 +2006,7 @@ mod test_treemap {\n             assert!(m.insert(i, 100 * i));\n         }\n \n-        for (i, (&k, v)) in m.mut_iter().enumerate() {\n+        for (i, (&k, v)) in m.iter_mut().enumerate() {\n             *v += k * 10 + i; // 000 + 00 + 0, 100 + 10 + 1, ...\n         }\n \n@@ -2021,7 +2021,7 @@ mod test_treemap {\n             assert!(m.insert(i, 100 * i));\n         }\n \n-        for (i, (&k, v)) in m.mut_rev_iter().enumerate() {\n+        for (i, (&k, v)) in m.rev_iter_mut().enumerate() {\n             *v += k * 10 + (9 - i); // 900 + 90 + (9 - 0), 800 + 80 + (9 - 1), ...\n         }\n \n@@ -2040,23 +2040,23 @@ mod test_treemap {\n         }\n \n         for i in range(1i, 199) {\n-            let mut lb_it = m_lower.mut_lower_bound(&i);\n+            let mut lb_it = m_lower.lower_bound_mut(&i);\n             let (&k, v) = lb_it.next().unwrap();\n             let lb = i + i % 2;\n             assert_eq!(lb, k);\n             *v -= k;\n         }\n         for i in range(0i, 198) {\n-            let mut ub_it = m_upper.mut_upper_bound(&i);\n+            let mut ub_it = m_upper.upper_bound_mut(&i);\n             let (&k, v) = ub_it.next().unwrap();\n             let ub = i + 2 - i % 2;\n             assert_eq!(ub, k);\n             *v -= k;\n         }\n \n-        assert!(m_lower.mut_lower_bound(&199).next().is_none());\n+        assert!(m_lower.lower_bound_mut(&199).next().is_none());\n \n-        assert!(m_upper.mut_upper_bound(&198).next().is_none());\n+        assert!(m_upper.upper_bound_mut(&198).next().is_none());\n \n         assert!(m_lower.iter().all(|(_, &x)| x == 0));\n         assert!(m_upper.iter().all(|(_, &x)| x == 0));\n@@ -2065,7 +2065,7 @@ mod test_treemap {\n     #[test]\n     fn test_keys() {\n         let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.move_iter().collect::<TreeMap<int, char>>();\n+        let map = vec.into_iter().collect::<TreeMap<int, char>>();\n         let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n@@ -2076,7 +2076,7 @@ mod test_treemap {\n     #[test]\n     fn test_values() {\n         let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.move_iter().collect::<TreeMap<int, char>>();\n+        let map = vec.into_iter().collect::<TreeMap<int, char>>();\n         let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n@@ -2402,17 +2402,17 @@ mod test_set {\n         let s: TreeSet<int> = range(0i, 5).collect();\n \n         let mut n = 0;\n-        for x in s.move_iter() {\n+        for x in s.into_iter() {\n             assert_eq!(x, n);\n             n += 1;\n         }\n     }\n \n     #[test]\n     fn test_move_iter_size_hint() {\n-        let s: TreeSet<int> = vec!(0i, 1).move_iter().collect();\n+        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n \n-        let mut it = s.move_iter();\n+        let mut it = s.into_iter();\n \n         assert_eq!(it.size_hint(), (2, Some(2)));\n         assert!(it.next() != None);"}, {"sha": "99e5899dc15672f25582239e4c3bd92e85c6951b", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -282,7 +282,7 @@ impl<T> TrieMap<T> {\n     /// use std::collections::TrieMap;\n     /// let mut map: TrieMap<int> = [(1, 2), (2, 4), (3, 6)].iter().map(|&x| x).collect();\n     ///\n-    /// for (key, value) in map.mut_iter() {\n+    /// for (key, value) in map.iter_mut() {\n     ///     *value = -(key as int);\n     /// }\n     ///\n@@ -292,7 +292,7 @@ impl<T> TrieMap<T> {\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, T> {\n         let mut iter = unsafe {MutEntries::new()};\n-        iter.stack[0] = self.root.children.mut_iter();\n+        iter.stack[0] = self.root.children.iter_mut();\n         iter.length = 1;\n         iter.remaining_min = self.length;\n         iter.remaining_max = self.length;\n@@ -453,11 +453,11 @@ impl<T> TrieMap<T> {\n     /// use std::collections::TrieMap;\n     /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n     ///\n-    /// assert_eq!(map.mut_lower_bound(4).next(), Some((4, &mut \"b\")));\n-    /// assert_eq!(map.mut_lower_bound(5).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.mut_lower_bound(10).next(), None);\n+    /// assert_eq!(map.lower_bound_mut(4).next(), Some((4, &mut \"b\")));\n+    /// assert_eq!(map.lower_bound_mut(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.lower_bound_mut(10).next(), None);\n     ///\n-    /// for (key, value) in map.mut_lower_bound(4) {\n+    /// for (key, value) in map.lower_bound_mut(4) {\n     ///     *value = \"changed\";\n     /// }\n     ///\n@@ -484,11 +484,11 @@ impl<T> TrieMap<T> {\n     /// use std::collections::TrieMap;\n     /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n     ///\n-    /// assert_eq!(map.mut_upper_bound(4).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.mut_upper_bound(5).next(), Some((6, &mut \"c\")));\n-    /// assert_eq!(map.mut_upper_bound(10).next(), None);\n+    /// assert_eq!(map.upper_bound_mut(4).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.upper_bound_mut(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.upper_bound_mut(10).next(), None);\n     ///\n-    /// for (key, value) in map.mut_upper_bound(4) {\n+    /// for (key, value) in map.upper_bound_mut(4) {\n     ///     *value = \"changed\";\n     /// }\n     ///\n@@ -1195,7 +1195,7 @@ mod test_map {\n     #[test]\n     fn test_keys() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.move_iter().collect::<TrieMap<char>>();\n+        let map = vec.into_iter().collect::<TrieMap<char>>();\n         let keys = map.keys().collect::<Vec<uint>>();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n@@ -1206,7 +1206,7 @@ mod test_map {\n     #[test]\n     fn test_values() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.move_iter().collect::<TrieMap<char>>();\n+        let map = vec.into_iter().collect::<TrieMap<char>>();\n         let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n@@ -1239,7 +1239,7 @@ mod test_map {\n     #[test]\n     fn test_mut_iter() {\n         let mut empty_map : TrieMap<uint> = TrieMap::new();\n-        assert!(empty_map.mut_iter().next().is_none());\n+        assert!(empty_map.iter_mut().next().is_none());\n \n         let first = uint::MAX - 10000;\n         let last = uint::MAX;\n@@ -1250,7 +1250,7 @@ mod test_map {\n         }\n \n         let mut i = 0;\n-        for (k, v) in map.mut_iter() {\n+        for (k, v) in map.iter_mut() {\n             assert_eq!(k, first + i);\n             *v -= k / 2;\n             i += 1;\n@@ -1316,23 +1316,23 @@ mod test_map {\n         }\n \n         for i in range(0u, 199) {\n-            let mut lb_it = m_lower.mut_lower_bound(i);\n+            let mut lb_it = m_lower.lower_bound_mut(i);\n             let (k, v) = lb_it.next().unwrap();\n             let lb = i + i % 2;\n             assert_eq!(lb, k);\n             *v -= k;\n         }\n \n         for i in range(0u, 198) {\n-            let mut ub_it = m_upper.mut_upper_bound(i);\n+            let mut ub_it = m_upper.upper_bound_mut(i);\n             let (k, v) = ub_it.next().unwrap();\n             let ub = i + 2 - i % 2;\n             assert_eq!(ub, k);\n             *v -= k;\n         }\n \n-        assert!(m_lower.mut_lower_bound(199).next().is_none());\n-        assert!(m_upper.mut_upper_bound(198).next().is_none());\n+        assert!(m_lower.lower_bound_mut(199).next().is_none());\n+        assert!(m_upper.upper_bound_mut(198).next().is_none());\n \n         assert!(m_lower.iter().all(|(_, &x)| x == 0));\n         assert!(m_upper.iter().all(|(_, &x)| x == 0));"}, {"sha": "f570573262a412e2a16d83400cb4b4e1ad3f4a75", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -181,7 +181,7 @@ impl<T> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len), op(len));\n+                ptr::write(xs.as_mut_slice().unsafe_mut(len), op(len));\n                 xs.len += 1;\n             }\n             xs\n@@ -252,7 +252,7 @@ impl<T> Vec<T> {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n-        for elt in self.move_iter() {\n+        for elt in self.into_iter() {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -311,7 +311,7 @@ impl<T: Clone> Vec<T> {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n                 let len = xs.len;\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len),\n+                ptr::write(xs.as_mut_slice().unsafe_mut(len),\n                            value.clone());\n                 xs.len += 1;\n             }\n@@ -343,7 +343,7 @@ impl<T: Clone> Vec<T> {\n             // during the loop can prevent this optimisation.\n             unsafe {\n                 ptr::write(\n-                    self.as_mut_slice().unsafe_mut_ref(len),\n+                    self.as_mut_slice().unsafe_mut(len),\n                     other.unsafe_get(i).clone());\n                 self.set_len(len + 1);\n             }\n@@ -437,7 +437,7 @@ impl<T:Clone> Clone for Vec<T> {\n         }\n \n         // reuse the contained values' allocations/resources.\n-        for (place, thing) in self.mut_iter().zip(other.iter()) {\n+        for (place, thing) in self.iter_mut().zip(other.iter()) {\n             place.clone_from(thing)\n         }\n \n@@ -738,7 +738,7 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.move_iter() {\n+    /// for s in v.into_iter() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n     /// }\n@@ -841,13 +841,13 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3];\n-    /// for num in vec.mut_iter() {\n+    /// for num in vec.iter_mut() {\n     ///     *num = 0;\n     /// }\n     /// ```\n     #[inline]\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a,T> {\n-        self.as_mut_slice().mut_iter()\n+        self.as_mut_slice().iter_mut()\n     }\n \n     /// Sorts the vector, in place, using `compare` to compare elements.\n@@ -951,12 +951,12 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3];\n-    /// *vec.mut_last().unwrap() = 4;\n+    /// *vec.last_mut().unwrap() = 4;\n     /// assert_eq!(vec, vec![1i, 2, 4]);\n     /// ```\n     #[inline]\n     pub fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.as_mut_slice().mut_last()\n+        self.as_mut_slice().last_mut()\n     }\n \n     /// Removes an element from anywhere in the vector and return it, replacing\n@@ -1119,7 +1119,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n-        self.extend(other.move_iter());\n+        self.extend(other.into_iter());\n     }\n \n     /// Deprecated: use `slice_mut`.\n@@ -1140,12 +1140,12 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.mut_slice(0, 2) == [1, 2]);\n+    /// assert!(vec.slice_mut(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self.as_mut_slice().mut_slice(start, end)\n+        self.as_mut_slice().slice_mut(start, end)\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n@@ -1164,11 +1164,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.mut_slice_from(2) == [3, 4]);\n+    /// assert!(vec.slice_from_mut(2) == [3, 4]);\n     /// ```\n     #[inline]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self.as_mut_slice().mut_slice_from(start)\n+        self.as_mut_slice().slice_from_mut(start)\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n@@ -1187,11 +1187,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.mut_slice_to(2) == [1, 2]);\n+    /// assert!(vec.slice_to_mut(2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self.as_mut_slice().mut_slice_to(end)\n+        self.as_mut_slice().slice_to_mut(end)\n     }\n \n     /// Deprecated: use `split_at_mut`.\n@@ -1217,26 +1217,26 @@ impl<T> Vec<T> {\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n-    ///    let (left, right) = vec.mut_split_at(0);\n+    ///    let (left, right) = vec.split_at_mut(0);\n     ///    assert!(left == &mut []);\n     ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n-    ///     let (left, right) = vec.mut_split_at(2);\n+    ///     let (left, right) = vec.split_at_mut(2);\n     ///     assert!(left == &mut [1, 2]);\n     ///     assert!(right == &mut [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n-    ///     let (left, right) = vec.mut_split_at(6);\n+    ///     let (left, right) = vec.split_at_mut(6);\n     ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n     ///     assert!(right == &mut []);\n     /// }\n     /// ```\n     #[inline]\n     pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.as_mut_slice().mut_split_at(mid)\n+        self.as_mut_slice().split_at_mut(mid)\n     }\n \n     /// Reverses the order of elements in a vector, in place.\n@@ -2111,9 +2111,9 @@ mod tests {\n     fn test_mut_slice_from() {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n-            let slice = values.mut_slice_from(2);\n+            let slice = values.slice_from_mut(2);\n             assert!(slice == [3, 4, 5]);\n-            for p in slice.mut_iter() {\n+            for p in slice.iter_mut() {\n                 *p += 2;\n             }\n         }\n@@ -2125,9 +2125,9 @@ mod tests {\n     fn test_mut_slice_to() {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n-            let slice = values.mut_slice_to(2);\n+            let slice = values.slice_to_mut(2);\n             assert!(slice == [1, 2]);\n-            for p in slice.mut_iter() {\n+            for p in slice.iter_mut() {\n                 *p += 1;\n             }\n         }\n@@ -2139,14 +2139,14 @@ mod tests {\n     fn test_mut_split_at() {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n-            let (left, right) = values.mut_split_at(2);\n+            let (left, right) = values.split_at_mut(2);\n             assert!(left.slice(0, left.len()) == [1, 2]);\n-            for p in left.mut_iter() {\n+            for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             assert!(right.slice(0, right.len()) == [3, 4, 5]);\n-            for p in right.mut_iter() {\n+            for p in right.iter_mut() {\n                 *p += 2;\n             }\n         }\n@@ -2223,15 +2223,15 @@ mod tests {\n \n         for &() in v.iter() {}\n \n-        assert_eq!(v.mut_iter().count(), 2);\n+        assert_eq!(v.iter_mut().count(), 2);\n         v.push(());\n-        assert_eq!(v.mut_iter().count(), 3);\n+        assert_eq!(v.iter_mut().count(), 3);\n         v.push(());\n-        assert_eq!(v.mut_iter().count(), 4);\n+        assert_eq!(v.iter_mut().count(), 4);\n \n-        for &() in v.mut_iter() {}\n+        for &() in v.iter_mut() {}\n         unsafe { v.set_len(0); }\n-        assert_eq!(v.mut_iter().count(), 0);\n+        assert_eq!(v.iter_mut().count(), 0);\n     }\n \n     #[test]\n@@ -2339,7 +2339,7 @@ mod tests {\n         vec.push(1);\n         vec.push(2);\n         let ptr = vec.as_ptr();\n-        vec = vec.move_iter().unwrap();\n+        vec = vec.into_iter().unwrap();\n         assert_eq!(vec.as_ptr(), ptr);\n         assert_eq!(vec.capacity(), 7);\n         assert_eq!(vec.len(), 0);\n@@ -2495,7 +2495,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = FromIterator::from_iter(src.clone().move_iter());\n+            let dst: Vec<uint> = FromIterator::from_iter(src.clone().into_iter());\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });\n@@ -2529,7 +2529,7 @@ mod tests {\n \n         b.iter(|| {\n             let mut dst = dst.clone();\n-            dst.extend(src.clone().move_iter());\n+            dst.extend(src.clone().into_iter());\n             assert_eq!(dst.len(), dst_len + src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "fcc794fd0d10c252b8878149ba2b3bf71c6bbf76", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -203,7 +203,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    buf.mut_slice_to(end).reverse();\n+    buf.slice_to_mut(end).reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -342,7 +342,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.mut_slice_from(*self.end),\n+                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())"}, {"sha": "7bab59960b0fea938d1f633a7bbba580ca8f3423", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -420,7 +420,7 @@ impl<'a> Formatter<'a> {\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |f: &mut Formatter| {\n-            for c in sign.move_iter() {\n+            for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(b).unwrap_or(0);\n                 try!(f.buf.write(b.slice_to(n)));"}, {"sha": "568745d70b399eca09088433fc8815c4887aa94c", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -43,7 +43,7 @@ trait GenericRadix {\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n-            for byte in buf.mut_iter().rev() {\n+            for byte in buf.iter_mut().rev() {\n                 let n = x % base;                         // Get the current place value.\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n@@ -52,7 +52,7 @@ trait GenericRadix {\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n-            for byte in buf.mut_iter().rev() {\n+            for byte in buf.iter_mut().rev() {\n                 let n = -(x % base);                      // Get the current place value.\n                 x = x / base;                             // Deaccumulate the number.\n                 *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer."}, {"sha": "6bee0573facc37340f5020c9feccda4b523da70c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -377,7 +377,7 @@ pub trait Iterator<A> {\n     ///     sum\n     /// }\n     /// let x = vec![1i,2,3,7,8,9];\n-    /// assert_eq!(process(x.move_iter()), 1006);\n+    /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n     fn fuse(self) -> Fuse<Self> {\n@@ -1682,7 +1682,7 @@ impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T,\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n-            for inner in self.frontiter.mut_iter() {\n+            for inner in self.frontiter.iter_mut() {\n                 for x in *inner {\n                     return Some(x)\n                 }\n@@ -1713,7 +1713,7 @@ impl<'a,\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n-            for inner in self.backiter.mut_iter() {\n+            for inner in self.backiter.iter_mut() {\n                 match inner.next_back() {\n                     None => (),\n                     y => return y"}, {"sha": "b76c92140fda6c6f029a24c265dfe960b49c2292", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -124,7 +124,7 @@ pub fn mut_null<T>() -> *mut T { null_mut() }\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *mut int = ptr::mut_null();\n+/// let p: *mut int = ptr::null_mut();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n@@ -327,7 +327,7 @@ impl<T> RawPtr<T> for *const T {\n \n impl<T> RawPtr<T> for *mut T {\n     #[inline]\n-    fn null() -> *mut T { mut_null() }\n+    fn null() -> *mut T { null_mut() }\n \n     #[inline]\n     fn is_null(&self) -> bool { *self == RawPtr::null() }"}, {"sha": "65ad7bb1753b4cde3be645588d10017d4fbf021a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -583,7 +583,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n-     *     *self = self.mut_slice_from(1);\n+     *     *self = self.slice_from_mut(1);\n      *     Some(head)\n      * ```\n      *\n@@ -602,7 +602,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.mut_slice_to(self.len() - 1);\n+     *     *self = self.slice_to_mut(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n@@ -650,19 +650,19 @@ pub trait MutableSlice<'a, T> {\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n-    ///    let (left, right) = v.mut_split_at(0);\n+    ///    let (left, right) = v.split_at_mut(0);\n     ///    assert!(left == &mut []);\n     ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n-    ///     let (left, right) = v.mut_split_at(2);\n+    ///     let (left, right) = v.split_at_mut(2);\n     ///     assert!(left == &mut [1i, 2]);\n     ///     assert!(right == &mut [3i, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n-    ///     let (left, right) = v.mut_split_at(6);\n+    ///     let (left, right) = v.split_at_mut(6);\n     ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n     ///     assert!(right == &mut []);\n     /// }\n@@ -768,20 +768,20 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n         let len = self.len();\n-        self.mut_slice(start, len)\n+        self.slice_mut(start, len)\n     }\n \n     #[inline]\n     fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n-        self.mut_slice(0, end)\n+        self.slice_mut(0, end)\n     }\n \n     #[inline]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let len = self.len();\n             let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+            (self.slice_mut(0, mid), self2.slice_mut(mid, len))\n         }\n     }\n \n@@ -861,8 +861,8 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {\n-                let pa: *mut T = self.unsafe_mut_ref(i);\n-                let pb: *mut T = self.unsafe_mut_ref(ln - i - 1);\n+                let pa: *mut T = self.unsafe_mut(i);\n+                let pb: *mut T = self.unsafe_mut(ln - i - 1);\n                 ptr::swap(pa, pb);\n             }\n             i += 1;\n@@ -881,7 +881,7 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut_ref(index) = val;\n+        *self.unsafe_mut(index) = val;\n     }\n \n     #[inline]\n@@ -1018,7 +1018,7 @@ pub trait MutableCloneableSlice<T> {\n impl<'a, T:Clone> MutableCloneableSlice<T> for &'a mut [T] {\n     #[inline]\n     fn clone_from_slice(self, src: &[T]) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.iter()) {\n+        for (a, b) in self.iter_mut().zip(src.iter()) {\n             a.clone_from(b);\n         }\n         cmp::min(self.len(), src.len())\n@@ -1274,14 +1274,14 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n                 self.finished = true;\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n+                let (head, tail) = tmp.split_at_mut(len);\n                 self.v = tail;\n                 Some(head)\n             }\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = tail.mut_slice_from(1);\n+                let (head, tail) = tmp.split_at_mut(idx);\n+                self.v = tail.slice_from_mut(1);\n                 Some(head)\n             }\n         }\n@@ -1314,9 +1314,9 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n             }\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n+                let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.mut_slice_from(1))\n+                Some(tail.slice_from_mut(1))\n             }\n         }\n     }\n@@ -1483,7 +1483,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n             let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(sz);\n+            let (head, tail) = tmp.split_at_mut(sz);\n             self.v = tail;\n             Some(head)\n         }\n@@ -1512,7 +1512,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = mem::replace(&mut self.v, &mut []);\n             let tmp_len = tmp.len();\n-            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n+            let (head, tail) = tmp.split_at_mut(tmp_len - sz);\n             self.v = head;\n             Some(tail)\n         }"}, {"sha": "1aaea19216264709b4cfe450edc9f58718e1a543", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -794,7 +794,7 @@ fn test_range_step_inclusive() {\n #[test]\n fn test_reverse() {\n     let mut ys = [1i, 2, 3, 4, 5];\n-    ys.mut_iter().reverse_();\n+    ys.iter_mut().reverse_();\n     assert!(ys == [5, 4, 3, 2, 1]);\n }\n "}, {"sha": "ed7fc3aa4f23661bef01eb008e7f47b2058500e7", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -213,7 +213,7 @@ fn test_mut_iter() {\n \n     let mut x = Some(val);\n     {\n-        let mut it = x.mut_iter();\n+        let mut it = x.iter_mut();\n \n         assert_eq!(it.size_hint(), (1, Some(1)));\n \n@@ -275,7 +275,7 @@ fn test_collect() {\n     // test that it does not take more elements than it needs\n     let mut functions = [|| Some(()), || None, || fail!()];\n \n-    let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n+    let v: Option<Vec<()>> = collect(functions.iter_mut().map(|f| (*f)()));\n \n     assert!(v == None);\n }"}, {"sha": "b45ac6a993efb9280ce4188a09979590bc53454a", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -84,7 +84,7 @@ fn test_collect() {\n     // test that it does not take more elements than it needs\n     let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n-    let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n+    let v: Result<Vec<()>, int> = collect(functions.iter_mut().map(|f| (*f)()));\n     assert!(v == Err(1));\n }\n \n@@ -104,7 +104,7 @@ fn test_fold() {\n     // test that it does not take more elements than it needs\n     let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n-    assert_eq!(fold_(functions.mut_iter()\n+    assert_eq!(fold_(functions.iter_mut()\n                     .map(|f| (*f)())),\n                Err(1));\n }"}, {"sha": "337919b5c6864423c9d411d3d8bacc84078e81ce", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -190,7 +190,7 @@ fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n     match fs::readdir(path) {\n         Ok(mut children) => {\n             children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            Some(children.move_iter().collect())\n+            Some(children.into_iter().collect())\n         }\n         Err(..) => None\n     }\n@@ -505,7 +505,7 @@ fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path\n         None => {\n             match list_dir_sorted(path) {\n                 Some(entries) => {\n-                    todo.extend(entries.move_iter().map(|x|(x, idx)));\n+                    todo.extend(entries.into_iter().map(|x|(x, idx)));\n \n                     // Matching the special directory entries . and .. that refer to\n                     // the current and parent directory respectively requires that"}, {"sha": "19f58a210d00bb6c8fca3b64d6a0753d09d0e95c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -588,12 +588,12 @@ mod tests {\n         fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n             match self {\n                 UnlabelledNodes(len)\n-                    => Vec::from_elem(len, None).move_iter().collect(),\n+                    => Vec::from_elem(len, None).into_iter().collect(),\n                 AllNodesLabelled(lbls)\n-                    => lbls.move_iter().map(\n+                    => lbls.into_iter().map(\n                         |l|Some(l)).collect(),\n                 SomeNodesLabelled(lbls)\n-                    => lbls.move_iter().collect(),\n+                    => lbls.into_iter().collect(),\n             }\n         }\n     }"}, {"sha": "27c71cb3e7c7e7a8cc1112ba467f4480bc2b88ae", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -53,7 +53,7 @@ impl BasicLoop {\n     /// Process everything in the work queue (continually)\n     fn work(&mut self) {\n         while self.work.len() > 0 {\n-            for work in mem::replace(&mut self.work, vec![]).move_iter() {\n+            for work in mem::replace(&mut self.work, vec![]).into_iter() {\n                 work();\n             }\n         }\n@@ -63,15 +63,15 @@ impl BasicLoop {\n         let messages = unsafe {\n             mem::replace(&mut *self.messages.lock(), Vec::new())\n         };\n-        for message in messages.move_iter() {\n+        for message in messages.into_iter() {\n             self.message(message);\n         }\n     }\n \n     fn message(&mut self, message: Message) {\n         match message {\n             RunRemote(i) => {\n-                match self.remotes.mut_iter().find(|& &(id, _)| id == i) {\n+                match self.remotes.iter_mut().find(|& &(id, _)| id == i) {\n                     Some(&(_, ref mut f)) => f.call(),\n                     None => unreachable!()\n                 }"}, {"sha": "00f246ea05eec83f01a6382de97277a8fb66526e", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -435,7 +435,7 @@ impl SchedPool {\n         // Now that we've got all our work queues, create one scheduler per\n         // queue, spawn the scheduler into a thread, and be sure to keep a\n         // handle to the scheduler and the thread to keep them alive.\n-        for worker in workers.move_iter() {\n+        for worker in workers.into_iter() {\n             rtdebug!(\"inserting a regular scheduler\");\n \n             let mut sched = box Scheduler::new(pool.id,\n@@ -493,7 +493,7 @@ impl SchedPool {\n \n         // Tell all existing schedulers about this new scheduler so they can all\n         // steal work from it\n-        for handle in self.handles.mut_iter() {\n+        for handle in self.handles.iter_mut() {\n             handle.send(NewNeighbor(stealer.clone()));\n         }\n \n@@ -535,10 +535,10 @@ impl SchedPool {\n         }\n \n         // Now that everyone's gone, tell everything to shut down.\n-        for mut handle in replace(&mut self.handles, vec![]).move_iter() {\n+        for mut handle in replace(&mut self.handles, vec![]).into_iter() {\n             handle.send(Shutdown);\n         }\n-        for thread in replace(&mut self.threads, vec![]).move_iter() {\n+        for thread in replace(&mut self.threads, vec![]).into_iter() {\n             thread.join();\n         }\n     }"}, {"sha": "3c49e1c40d63cc72eb0a1dfd286c894c6ac43c43", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -355,7 +355,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n-        dirs.move_iter().filter(|path| {\n+        dirs.into_iter().filter(|path| {\n             path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }"}, {"sha": "6aa965948fd7066dc77f13d5b9eb2443e58ed21d", "filename": "src/libnative/io/file_windows.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ffile_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ffile_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_windows.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -52,7 +52,7 @@ impl FileDesc {\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n                            buf.len() as libc::DWORD, &mut read,\n-                           ptr::mut_null())\n+                           ptr::null_mut())\n         };\n         if ret != 0 {\n             Ok(read as uint)\n@@ -68,7 +68,7 @@ impl FileDesc {\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(), cur as libc::LPVOID,\n                                 remaining as libc::DWORD, &mut amt,\n-                                ptr::mut_null())\n+                                ptr::null_mut())\n             };\n             if ret != 0 {\n                 remaining -= amt as uint;\n@@ -313,10 +313,10 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n         libc::CreateFileW(path.as_ptr(),\n                           dwDesiredAccess,\n                           dwShareMode,\n-                          ptr::mut_null(),\n+                          ptr::null_mut(),\n                           dwCreationDisposition,\n                           dwFlagsAndAttributes,\n-                          ptr::mut_null())\n+                          ptr::null_mut())\n     };\n     if handle == libc::INVALID_HANDLE_VALUE {\n         Err(super::last_error())\n@@ -337,7 +337,7 @@ pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n-        libc::CreateDirectoryW(p.as_ptr(), ptr::mut_null())\n+        libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n     })\n }\n \n@@ -346,7 +346,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n-        dirs.move_iter().filter(|path| {\n+        dirs.into_iter().filter(|path| {\n             path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }\n@@ -428,10 +428,10 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n         libc::CreateFileW(p.as_ptr(),\n                           libc::GENERIC_READ,\n                           libc::FILE_SHARE_READ,\n-                          ptr::mut_null(),\n+                          ptr::null_mut(),\n                           libc::OPEN_EXISTING,\n                           libc::FILE_ATTRIBUTE_NORMAL,\n-                          ptr::mut_null())\n+                          ptr::null_mut())\n     };\n     if handle == libc::INVALID_HANDLE_VALUE {\n         return Err(super::last_error())\n@@ -468,7 +468,7 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     let src = try!(to_utf16(src));\n     let dst = try!(to_utf16(dst));\n     super::mkerr_winbool(unsafe {\n-        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::mut_null())\n+        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n     })\n }\n "}, {"sha": "1f51f8eacd634afefa06ab8db42a9d61dafe3dfe", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -172,7 +172,7 @@ mod imp {\n \n     pub fn new() -> (HANDLE, HANDLE) {\n         unsafe {\n-            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+            let handle = CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n                                       ptr::null());\n             (handle, handle)\n         }"}, {"sha": "86f72bf65ddd399ca8d23fce1d5891bc10202995", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -267,7 +267,7 @@ impl rtio::IoFactory for IoFactory {\n                          Vec<Option<Box<rtio::RtioPipe + Send>>>)> {\n         process::Process::spawn(cfg).map(|(p, io)| {\n             (box p as Box<rtio::RtioProcess + Send>,\n-             io.move_iter().map(|p| p.map(|p| {\n+             io.into_iter().map(|p| p.map(|p| {\n                  box p as Box<rtio::RtioPipe + Send>\n              })).collect())\n         })"}, {"sha": "af7508ccbe9a28b5e19a0ae87e097954eac415e9", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -543,7 +543,7 @@ impl TcpAcceptor {\n \n         while !self.inner.closed.load(atomic::SeqCst) {\n             match retry(|| unsafe {\n-                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n             }) {\n                 -1 if util::wouldblock() => {}\n                 -1 => return Err(os::last_error()),\n@@ -608,7 +608,7 @@ impl TcpAcceptor {\n \n             if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n             match unsafe {\n-                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n             } {\n                 -1 if util::wouldblock() => {}\n                 -1 => return Err(os::last_error()),"}, {"sha": "c222907fa5b88afc62eb1d443a698d35c074cd9c", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -50,7 +50,7 @@ fn addr_to_sockaddr_un(addr: &CString,\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-    for (slot, value) in s.sun_path.mut_iter().zip(addr.iter()) {\n+    for (slot, value) in s.sun_path.iter_mut().zip(addr.iter()) {\n         *slot = value;\n     }\n "}, {"sha": "2de9cd9a41c4b9a5fac2d341c46cd0ee8aaa35c6", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -104,7 +104,7 @@ struct Event(libc::HANDLE);\n impl Event {\n     fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n         let event = unsafe {\n-            libc::CreateEventW(ptr::mut_null(),\n+            libc::CreateEventW(ptr::null_mut(),\n                                manual_reset as libc::BOOL,\n                                initial_state as libc::BOOL,\n                                ptr::null())\n@@ -164,7 +164,7 @@ unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n         65536,\n         65536,\n         0,\n-        ptr::mut_null()\n+        ptr::null_mut()\n     )\n }\n \n@@ -225,10 +225,10 @@ impl UnixStream {\n             libc::CreateFileW(p,\n                 libc::GENERIC_READ | libc::GENERIC_WRITE,\n                 0,\n-                ptr::mut_null(),\n+                ptr::null_mut(),\n                 libc::OPEN_EXISTING,\n                 libc::FILE_FLAG_OVERLAPPED,\n-                ptr::mut_null())\n+                ptr::null_mut())\n         };\n         if result != libc::INVALID_HANDLE_VALUE {\n             return Some(result)\n@@ -240,10 +240,10 @@ impl UnixStream {\n                 libc::CreateFileW(p,\n                     libc::GENERIC_READ | libc::FILE_WRITE_ATTRIBUTES,\n                     0,\n-                    ptr::mut_null(),\n+                    ptr::null_mut(),\n                     libc::OPEN_EXISTING,\n                     libc::FILE_FLAG_OVERLAPPED,\n-                    ptr::mut_null())\n+                    ptr::null_mut())\n             };\n             if result != libc::INVALID_HANDLE_VALUE {\n                 return Some(result)\n@@ -255,10 +255,10 @@ impl UnixStream {\n                 libc::CreateFileW(p,\n                     libc::GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES,\n                     0,\n-                    ptr::mut_null(),\n+                    ptr::null_mut(),\n                     libc::OPEN_EXISTING,\n                     libc::FILE_FLAG_OVERLAPPED,\n-                    ptr::mut_null())\n+                    ptr::null_mut())\n             };\n             if result != libc::INVALID_HANDLE_VALUE {\n                 return Some(result)\n@@ -280,8 +280,8 @@ impl UnixStream {\n                     let ret = unsafe {\n                         libc::SetNamedPipeHandleState(inner.handle,\n                                                       &mut mode,\n-                                                      ptr::mut_null(),\n-                                                      ptr::mut_null())\n+                                                      ptr::null_mut(),\n+                                                      ptr::null_mut())\n                     };\n                     return if ret == 0 {\n                         Err(super::last_error())\n@@ -341,7 +341,7 @@ impl UnixStream {\n     }\n \n     fn cancel_io(&self) -> IoResult<()> {\n-        match unsafe { c::CancelIoEx(self.handle(), ptr::mut_null()) } {\n+        match unsafe { c::CancelIoEx(self.handle(), ptr::null_mut()) } {\n             0 if os::errno() == libc::ERROR_NOT_FOUND as uint => {\n                 Ok(())\n             }"}, {"sha": "cb392e1675feb2dc2ab6f2630a93fd773380c576", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -313,7 +313,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n             if b\"PATH\" != key.as_bytes_no_nul() { continue }\n \n             // Split the value and test each path to see if the program exists.\n-            for path in os::split_paths(v.as_bytes_no_nul()).move_iter() {\n+            for path in os::split_paths(v.as_bytes_no_nul()).into_iter() {\n                 let path = path.join(cfg.program.as_bytes_no_nul())\n                                .with_extension(os::consts::EXE_EXTENSION);\n                 if path.exists() {\n@@ -347,7 +347,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n                     let mut sa = libc::SECURITY_ATTRIBUTES {\n                         nLength: size as libc::DWORD,\n-                        lpSecurityDescriptor: ptr::mut_null(),\n+                        lpSecurityDescriptor: ptr::null_mut(),\n                         bInheritHandle: 1,\n                     };\n                     let filename: Vec<u16> = \"NUL\".utf16_units().collect();\n@@ -359,7 +359,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                                               &mut sa,\n                                               libc::OPEN_EXISTING,\n                                               0,\n-                                              ptr::mut_null());\n+                                              ptr::null_mut());\n                     if *slot == INVALID_HANDLE_VALUE {\n                         return Err(super::last_error())\n                     }\n@@ -399,8 +399,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n                 cmd_str = cmd_str.append_one(0);\n                 let created = CreateProcessW(ptr::null(),\n                                              cmd_str.as_mut_ptr(),\n-                                             ptr::mut_null(),\n-                                             ptr::mut_null(),\n+                                             ptr::null_mut(),\n+                                             ptr::null_mut(),\n                                              TRUE,\n                                              flags, envp, dirp,\n                                              &mut si, &mut pi);\n@@ -437,9 +437,9 @@ fn spawn_process_os(cfg: ProcessConfig,\n fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n     libc::types::os::arch::extra::STARTUPINFO {\n         cb: 0,\n-        lpReserved: ptr::mut_null(),\n-        lpDesktop: ptr::mut_null(),\n-        lpTitle: ptr::mut_null(),\n+        lpReserved: ptr::null_mut(),\n+        lpDesktop: ptr::null_mut(),\n+        lpTitle: ptr::null_mut(),\n         dwX: 0,\n         dwY: 0,\n         dwXSize: 0,\n@@ -450,7 +450,7 @@ fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n         dwFlags: 0,\n         wShowWindow: 0,\n         cbReserved2: 0,\n-        lpReserved2: ptr::mut_null(),\n+        lpReserved2: ptr::null_mut(),\n         hStdInput: libc::INVALID_HANDLE_VALUE,\n         hStdOutput: libc::INVALID_HANDLE_VALUE,\n         hStdError: libc::INVALID_HANDLE_VALUE,\n@@ -460,8 +460,8 @@ fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n #[cfg(windows)]\n fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n     libc::types::os::arch::extra::PROCESS_INFORMATION {\n-        hProcess: ptr::mut_null(),\n-        hThread: ptr::mut_null(),\n+        hProcess: ptr::null_mut(),\n+        hThread: ptr::null_mut(),\n         dwProcessId: 0,\n         dwThreadId: 0\n     }\n@@ -596,7 +596,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     Err(..) => {\n                         Ok(SpawnProcessResult {\n                             pid: pid,\n-                            handle: ptr::mut_null()\n+                            handle: ptr::null_mut()\n                         })\n                     }\n                     Ok(..) => fail!(\"short read on the cloexec pipe\"),\n@@ -806,7 +806,7 @@ fn with_envp<T>(env: Option<&[(&CString, &CString)]>, cb: |*mut c_void| -> T) ->\n \n             cb(blk.as_mut_ptr() as *mut c_void)\n         }\n-        _ => cb(ptr::mut_null())\n+        _ => cb(ptr::null_mut())\n     }\n }\n \n@@ -1050,14 +1050,14 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n                     tv = util::ms_to_timeval(ms);\n                     (&mut tv as *mut _, idx)\n                 }\n-                None => (ptr::mut_null(), -1),\n+                None => (ptr::null_mut(), -1),\n             };\n \n             // Wait for something to happen\n             c::fd_set(&mut set, input);\n             c::fd_set(&mut set, read_fd);\n-            match unsafe { c::select(max, &mut set, ptr::mut_null(),\n-                                     ptr::mut_null(), p) } {\n+            match unsafe { c::select(max, &mut set, ptr::null_mut(),\n+                                     ptr::null_mut(), p) } {\n                 // interrupted, retry\n                 -1 if os::errno() == libc::EINTR as int => continue,\n \n@@ -1129,7 +1129,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n         // Once this helper thread is done, we re-register the old sigchld\n         // handler and close our intermediate file descriptors.\n         unsafe {\n-            assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::mut_null()), 0);\n+            assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::null_mut()), 0);\n             let _ = libc::close(read_fd);\n             let _ = libc::close(WRITE_FD);\n             WRITE_FD = -1;"}, {"sha": "0a5de325c0922d5b99f5f9206905a34555727cbf", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -88,7 +88,7 @@ pub enum Req {\n pub fn now() -> u64 {\n     unsafe {\n         let mut now: libc::timeval = mem::zeroed();\n-        assert_eq!(c::gettimeofday(&mut now, ptr::mut_null()), 0);\n+        assert_eq!(c::gettimeofday(&mut now, ptr::null_mut()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n@@ -133,7 +133,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     'outer: loop {\n         let timeout = if active.len() == 0 {\n             // Empty array? no timeout (wait forever for the next request)\n-            ptr::mut_null()\n+            ptr::null_mut()\n         } else {\n             let now = now();\n             // If this request has already expired, then signal it and go\n@@ -154,8 +154,8 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n         c::fd_set(&mut set, input);\n         match unsafe {\n-            c::select(input + 1, &mut set, ptr::mut_null(),\n-                      ptr::mut_null(), timeout)\n+            c::select(input + 1, &mut set, ptr::null_mut(),\n+                      ptr::null_mut(), timeout)\n         } {\n             // timed out\n             0 => signal(&mut active, &mut dead),"}, {"sha": "82d318111727f1714d34527fb9e71aa9ce586678", "filename": "src/libnative/io/timer_windows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftimer_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftimer_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_windows.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -107,7 +107,7 @@ impl Timer {\n         unsafe { HELPER.boot(|| {}, helper) }\n \n         let obj = unsafe {\n-            imp::CreateWaitableTimerA(ptr::mut_null(), 0, ptr::null())\n+            imp::CreateWaitableTimerA(ptr::null_mut(), 0, ptr::null())\n         };\n         if obj.is_null() {\n             Err(super::last_error())\n@@ -141,8 +141,8 @@ impl rtio::RtioTimer for Timer {\n         // 100ns intervals, so we multiply by 10^4.\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n-                                  ptr::mut_null(), 0)\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null_mut(),\n+                                  ptr::null_mut(), 0)\n         }, 1);\n \n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n@@ -154,8 +154,8 @@ impl rtio::RtioTimer for Timer {\n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n-                                  ptr::mut_null(), 0)\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null_mut(),\n+                                  ptr::null_mut(), 0)\n         }, 1);\n \n         unsafe { HELPER.send(NewTimer(self.obj, cb, true)) }\n@@ -169,7 +169,7 @@ impl rtio::RtioTimer for Timer {\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n             imp::SetWaitableTimer(self.obj, &due, msecs as libc::LONG,\n-                                  ptr::mut_null(), ptr::mut_null(), 0)\n+                                  ptr::null_mut(), ptr::null_mut(), 0)\n         }, 1);\n \n         unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }"}, {"sha": "7263036e1659eb8024cf922443b9b237dd724d89", "filename": "src/libnative/io/tty_windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftty_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Ftty_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftty_windows.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -98,7 +98,7 @@ impl RtioTTY for WindowsTTY {\n                                          utf16.as_mut_ptr() as LPVOID,\n                                          utf16.len() as u32,\n                                          &mut num as LPDWORD,\n-                                         ptr::mut_null()) } {\n+                                         ptr::null_mut()) } {\n                 0 => return Err(super::last_error()),\n                 _ => (),\n             };\n@@ -123,7 +123,7 @@ impl RtioTTY for WindowsTTY {\n                                      utf16.as_ptr() as LPCVOID,\n                                      utf16.len() as u32,\n                                      &mut num as LPDWORD,\n-                                     ptr::mut_null()) } {\n+                                     ptr::null_mut()) } {\n             0 => Err(super::last_error()),\n             _ => Ok(()),\n         }"}, {"sha": "5f69ec00cddd493195ab2989e8aea1ae9268dcce", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -155,15 +155,15 @@ pub fn connect_timeout(fd: net::sock_t,\n             // undefined what the value of the 'tv' is after select\n             // returns EINTR).\n             let mut tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-            c::select(fd + 1, ptr::mut_null(), set as *mut _,\n-                      ptr::mut_null(), &mut tv)\n+            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n+                      ptr::null_mut(), &mut tv)\n         })\n     }\n     #[cfg(windows)]\n     fn await(_fd: net::sock_t, set: &mut c::fd_set,\n              timeout: u64) -> libc::c_int {\n         let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::mut_null(), set, ptr::mut_null(), &mut tv) }\n+        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n     }\n }\n \n@@ -180,15 +180,15 @@ pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n     }\n \n     let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::mut_null()),\n-        Writable => (ptr::mut_null(), &mut set as *mut _),\n+        Readable => (&mut set as *mut _, ptr::null_mut()),\n+        Writable => (ptr::null_mut(), &mut set as *mut _),\n     };\n     let mut tv: libc::timeval = unsafe { mem::zeroed() };\n \n     match retry(|| {\n         let now = ::io::timer::now();\n         let tvp = match deadline {\n-            None => ptr::mut_null(),\n+            None => ptr::null_mut(),\n             Some(deadline) => {\n                 // If we're past the deadline, then pass a 0 timeout to\n                 // select() so we can poll the status\n@@ -198,7 +198,7 @@ pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n             }\n         };\n         let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::mut_null(), tvp)\n+            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n         };\n         r\n     }) {"}, {"sha": "89c8e90f2c38b35afb285b5b201af80b214934ca", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -126,7 +126,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // we convert the list from individual weights to cumulative\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n-        for item in items.mut_iter() {\n+        for item in items.iter_mut() {\n             running_total = match running_total.checked_add(&item.weight) {\n                 Some(n) => n,\n                 None => fail!(\"WeightedChoice::new called with a total weight \\"}, {"sha": "0a857da92bbe498cee3f6d3032143eae1dc546c1", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -207,7 +207,7 @@ impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n         // - 1], 0, 0, ...], to fill rng.rsl.\n         let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u32));\n \n-        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+        for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n             *rsl_elem = seed_elem;\n         }\n         self.cnt = 0;\n@@ -442,7 +442,7 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n         // - 1], 0, 0, ...], to fill rng.rsl.\n         let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u64));\n \n-        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+        for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n             *rsl_elem = seed_elem;\n         }\n         self.cnt = 0;"}, {"sha": "f8a775478f1f85b88b63454322a5559dd4f2fff9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -113,7 +113,7 @@ pub trait Rng {\n         // optimisations are on.\n         let mut count = 0i;\n         let mut num = 0;\n-        for byte in dest.mut_iter() {\n+        for byte in dest.iter_mut() {\n             if count == 0 {\n                 // we could micro-optimise here by generating a u32 if\n                 // we only need a few more bytes to fill the vector"}, {"sha": "51115990a3113c14de54172e59761649fc4d09ce", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -102,7 +102,7 @@ impl Writer for SeekableMemWriter {\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n+                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "869dd25e3fab3f41d1412598b13fc391ebf2501a", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -165,7 +165,7 @@ impl<'r> Compiler<'r> {\n                 self.push(Save(2 * cap + 1));\n             }\n             Cat(xs) => {\n-                for x in xs.move_iter() {\n+                for x in xs.into_iter() {\n                     self.compile(x)\n                 }\n             }"}, {"sha": "12555b7c443830d83b372bca91e8e0caa677f6a8", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -418,13 +418,13 @@ impl<'a> Parser<'a> {\n                     if ranges.len() > 0 {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n                         let mut ast = Class(combine_ranges(ranges), flags);\n-                        for alt in alts.move_iter() {\n+                        for alt in alts.into_iter() {\n                             ast = Alt(box alt, box ast)\n                         }\n                         self.push(ast);\n                     } else if alts.len() > 0 {\n                         let mut ast = alts.pop().unwrap();\n-                        for alt in alts.move_iter() {\n+                        for alt in alts.into_iter() {\n                             ast = Alt(box alt, box ast)\n                         }\n                         self.push(ast);\n@@ -961,7 +961,7 @@ fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n     // This is currently O(n^2), but I think with sufficient cleverness,\n     // it can be reduced to O(n) **if necessary**.\n     let mut ordered: Vec<(char, char)> = Vec::with_capacity(unordered.len());\n-    for (us, ue) in unordered.move_iter() {\n+    for (us, ue) in unordered.into_iter() {\n         let (mut us, mut ue) = (us, ue);\n         assert!(us <= ue);\n         let mut which: Option<uint> = None;"}, {"sha": "be8e12b09f020e757b1348512a789ddbbd76f22d", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -157,7 +157,7 @@ fn gen_text(n: uint) -> String {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_chars().map(|n| n as u8).take(n)\n                        .collect::<Vec<u8>>();\n-    for (i, b) in bytes.mut_iter().enumerate() {\n+    for (i, b) in bytes.iter_mut().enumerate() {\n         if i % 20 == 0 {\n             *b = b'\\n'\n         }"}, {"sha": "6db07923c4d574019eca79a5db61e56a694b7d00", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -204,7 +204,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                         return StepMatch\n                     }\n                     Submatches => {\n-                        for (slot, val) in groups.mut_iter().zip(caps.iter()) {\n+                        for (slot, val) in groups.iter_mut().zip(caps.iter()) {\n                             *slot = *val;\n                         }\n                         return StepMatch\n@@ -470,7 +470,7 @@ impl Threads {\n                 *t.groups.get_mut(1) = groups[1];\n             }\n             (false, Submatches) => {\n-                for (slot, val) in t.groups.mut_iter().zip(groups.iter()) {\n+                for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n                     *slot = *val;\n                 }\n             }"}, {"sha": "128091840031d054eaece54fb75b03adcccf692a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -283,7 +283,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                     t.groups[1] = groups[1];\n                 }\n                 Submatches => {\n-                    for (slot, val) in t.groups.mut_iter().zip(groups.iter()) {\n+                    for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n                         *slot = *val;\n                     }\n                 }\n@@ -449,7 +449,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                                 return StepMatch\n                             }\n                             Submatches => {\n-                                for (slot, val) in groups.mut_iter().zip(caps.iter()) {\n+                                for (slot, val) in groups.iter_mut().zip(caps.iter()) {\n                                     *slot = *val;\n                                 }\n                                 return StepMatch"}, {"sha": "de1eef1dce3be1554796d513c88e4db0fbacb66b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -378,7 +378,7 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n-    mangle(path.chain(Some(gensym_name(flav)).move_iter()), None)\n+    mangle(path.chain(Some(gensym_name(flav)).into_iter()), None)\n }\n \n pub fn get_cc_prog(sess: &Session) -> String {\n@@ -780,7 +780,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         ab.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n-        all_native_libs.extend(native_libs.move_iter());\n+        all_native_libs.extend(native_libs.into_iter());\n     }\n \n     ab.update_symbols();\n@@ -1381,7 +1381,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, _) in crates.move_iter() {\n+    for (cnum, _) in crates.into_iter() {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in libs.iter() {\n             match kind {"}, {"sha": "250557d0af1ac9f11fd8791b110a93835a5f8ce2", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -46,7 +46,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n-    for (cnum, path) in crates.move_iter() {\n+    for (cnum, path) in crates.into_iter() {\n         let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let path = match path {\n             Some(p) => p,"}, {"sha": "cff5ac5375dcd77fd892a685e8cf6dae491aec40", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -857,7 +857,7 @@ fn run_work_multithreaded(sess: &Session,\n     }\n \n     let mut failed = false;\n-    for future in futures.move_iter() {\n+    for future in futures.into_iter() {\n         match future.unwrap() {\n             Ok(()) => {},\n             Err(_) => {"}, {"sha": "309c7a44c5d9b544f7376576e74888e80bea77bb", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -396,7 +396,7 @@ cgoptions!(\n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n-    for option in matches.opt_strs(\"C\").move_iter() {\n+    for option in matches.opt_strs(\"C\").into_iter() {\n         let mut iter = option.as_slice().splitn(1, '=');\n         let key = iter.next().unwrap();\n         let value = iter.next();\n@@ -486,7 +486,7 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.opts.test {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n-    user_cfg.move_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n+    user_cfg.into_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {\n@@ -630,7 +630,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n-    cfgspecs.move_iter().map(|s| {\n+    cfgspecs.into_iter().map(|s| {\n         parse::parse_meta_from_source_str(\"cfgspec\".to_string(),\n                                           s.to_string(),\n                                           Vec::new(),\n@@ -652,7 +652,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut describe_lints = false;\n \n     for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n-        for lint_name in matches.opt_strs(level.as_str()).move_iter() {\n+        for lint_name in matches.opt_strs(level.as_str()).into_iter() {\n             if lint_name.as_slice() == \"help\" {\n                 describe_lints = true;\n             } else {"}, {"sha": "2f252fc042a21588c43020d944f1469a8fbcd614", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -237,11 +237,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     {\n         let mut ls = sess.lint_store.borrow_mut();\n-        for pass in lint_passes.move_iter() {\n+        for pass in lint_passes.into_iter() {\n             ls.register_pass(Some(sess), true, pass);\n         }\n \n-        for (name, to) in lint_groups.move_iter() {\n+        for (name, to) in lint_groups.into_iter() {\n             ls.register_group(Some(sess), true, name, to);\n         }\n     }\n@@ -701,15 +701,15 @@ pub fn collect_crate_types(session: &Session,\n     // will be found in crate attributes.\n     let mut base = session.opts.crate_types.clone();\n     if base.len() == 0 {\n-        base.extend(attr_types.move_iter());\n+        base.extend(attr_types.into_iter());\n         if base.len() == 0 {\n             base.push(link::default_output_for_target(session));\n         }\n         base.as_mut_slice().sort();\n         base.dedup();\n     }\n \n-    base.move_iter().filter(|crate_type| {\n+    base.into_iter().filter(|crate_type| {\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {"}, {"sha": "d9ccfd260101b07fc3ca422bc72a2a65d2e5a7f9", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -170,7 +170,7 @@ Available lint options:\n \");\n \n     fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n-        let mut lints: Vec<_> = lints.move_iter().map(|(x, _)| x).collect();\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n         lints.sort_by(|x: &&Lint, y: &&Lint| {\n             match x.default_level.cmp(&y.default_level) {\n                 // The sort doesn't case-fold but it's doubtful we care.\n@@ -183,7 +183,7 @@ Available lint options:\n \n     fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n                      -> Vec<(&'static str, Vec<lint::LintId>)> {\n-        let mut lints: Vec<_> = lints.move_iter().map(|(x, y, _)| (x, y)).collect();\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n         lints.sort_by(|&(x, _): &(&'static str, Vec<lint::LintId>),\n                        &(y, _): &(&'static str, Vec<lint::LintId>)| {\n             x.cmp(&y)\n@@ -211,7 +211,7 @@ Available lint options:\n     println!(\"    {}  {:7.7s}  {}\", padded(\"----\"), \"-------\", \"-------\");\n \n     let print_lints = |lints: Vec<&Lint>| {\n-        for lint in lints.move_iter() {\n+        for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7s}  {}\",\n                      padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n@@ -235,10 +235,10 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n \n     let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n-        for (name, to) in lints.move_iter() {\n+        for (name, to) in lints.into_iter() {\n             let name = name.chars().map(|x| x.to_lowercase())\n                            .collect::<String>().replace(\"_\", \"-\");\n-            let desc = to.move_iter().map(|x| x.as_str()).collect::<Vec<String>>().connect(\", \");\n+            let desc = to.into_iter().map(|x| x.as_str()).collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n                      padded(name.as_slice()), desc);\n         }\n@@ -401,7 +401,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n                 &sess.parse_sess)\n         }\n     };\n-    result.move_iter().collect()\n+    result.into_iter().collect()\n }\n \n pub fn early_error(msg: &str) -> ! {"}, {"sha": "9b6d6d4620d364b01e318f314fc1ca971aa95955", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -342,7 +342,7 @@ impl UserIdentifiedItem {\n                                        -> NodesMatchingUII<'a, 'ast> {\n         match *self {\n             ItemViaNode(node_id) =>\n-                NodesMatchingDirect(Some(node_id).move_iter()),\n+                NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n                 NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n         }"}, {"sha": "2e05cb054e8864830745fc371f051b51d85e2704", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -67,16 +67,16 @@ fn filter_view_item(cx: &mut Context, view_item: ast::ViewItem) -> Option<ast::V\n fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n     ast::Mod {\n         inner: inner,\n-        view_items: view_items.move_iter().filter_map(|a| {\n+        view_items: view_items.into_iter().filter_map(|a| {\n             filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n         }).collect(),\n-        items: items.move_iter().filter_map(|a| {\n+        items: items.into_iter().filter_map(|a| {\n             if item_in_cfg(cx, &*a) {\n                 Some(cx.fold_item(a))\n             } else {\n                 None\n             }\n-        }).flat_map(|x| x.move_iter()).collect()\n+        }).flat_map(|x| x.into_iter()).collect()\n     }\n }\n \n@@ -93,10 +93,10 @@ fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}:\n                     -> ast::ForeignMod {\n     ast::ForeignMod {\n         abi: abi,\n-        view_items: view_items.move_iter().filter_map(|a| {\n+        view_items: view_items.into_iter().filter_map(|a| {\n             filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n         }).collect(),\n-        items: items.move_iter()\n+        items: items.into_iter()\n                     .filter_map(|a| filter_foreign_item(cx, a))\n                     .collect()\n     }\n@@ -105,13 +105,13 @@ fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}:\n fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n     let item = match item {\n         ast::ItemImpl(a, b, c, impl_items) => {\n-            let impl_items = impl_items.move_iter()\n+            let impl_items = impl_items.into_iter()\n                                        .filter(|ii| impl_item_in_cfg(cx, ii))\n                                        .collect();\n             ast::ItemImpl(a, b, c, impl_items)\n         }\n         ast::ItemTrait(a, b, c, methods) => {\n-            let methods = methods.move_iter()\n+            let methods = methods.into_iter()\n                                  .filter(|m| trait_method_in_cfg(cx, m))\n                                  .collect();\n             ast::ItemTrait(a, b, c, methods)\n@@ -120,7 +120,7 @@ fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n             ast::ItemStruct(fold_struct(cx, def), generics)\n         }\n         ast::ItemEnum(def, generics) => {\n-            let mut variants = def.variants.move_iter().filter_map(|v| {\n+            let mut variants = def.variants.into_iter().filter_map(|v| {\n                 if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n                     None\n                 } else {\n@@ -158,7 +158,7 @@ fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n     def.map(|ast::StructDef {fields, ctor_id, super_struct, is_virtual}| {\n         ast::StructDef {\n-            fields: fields.move_iter().filter(|m| {\n+            fields: fields.into_iter().filter(|m| {\n                 (cx.in_cfg)(m.node.attrs.as_slice())\n             }).collect(),\n             ctor_id: ctor_id,\n@@ -185,11 +185,11 @@ fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n     b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n-            stmts.move_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n-        let resulting_stmts = resulting_stmts.move_iter()\n-            .flat_map(|stmt| cx.fold_stmt(stmt).move_iter())\n+            stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n+        let resulting_stmts = resulting_stmts.into_iter()\n+            .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n-        let filtered_view_items = view_items.move_iter().filter_map(|a| {\n+        let filtered_view_items = view_items.into_iter().filter_map(|a| {\n             filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n         }).collect();\n         ast::Block {\n@@ -209,7 +209,7 @@ fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n             id: id,\n             node: match node {\n                 ast::ExprMatch(m, arms) => {\n-                    ast::ExprMatch(m, arms.move_iter()\n+                    ast::ExprMatch(m, arms.into_iter()\n                                         .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n                                         .collect())\n                 }"}, {"sha": "737fe748340e694abbd57a47eddd94c4d20e3eea", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -160,7 +160,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                 ast::Item {\n                     id: id,\n                     ident: ident,\n-                    attrs: attrs.move_iter().filter_map(|attr| {\n+                    attrs: attrs.into_iter().filter_map(|attr| {\n                         if !attr.check_name(\"main\") {\n                             Some(attr)\n                         } else {\n@@ -195,11 +195,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     let mut view_items = Vec::new();\n     let super_ = token::str_to_ident(\"super\");\n \n-    view_items.extend(tests.move_iter().map(|r| {\n+    view_items.extend(tests.into_iter().map(|r| {\n         cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n     }));\n-    view_items.extend(tested_submods.move_iter().map(|(r, sym)| {\n+    view_items.extend(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n         cx.ext_cx.view_use_simple_(DUMMY_SP, ast::Public, r, path)\n     }));\n@@ -444,7 +444,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n-        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n+        segments: ids.into_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n             lifetimes: Vec::new(),\n             types: OwnedSlice::empty(),\n@@ -552,7 +552,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n             );\n         }\n     };\n-    visible_path.extend(path.move_iter());\n+    visible_path.extend(path.into_iter());\n \n     let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n "}, {"sha": "c75b57dcafae061e8e0386bf6355d31a1bf40863", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -259,7 +259,7 @@ macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n     let mut passes = $cx.lints.passes.take().unwrap();\n-    for obj in passes.mut_iter() {\n+    for obj in passes.iter_mut() {\n         obj.$f($cx, $($args),*);\n     }\n     $cx.lints.passes = Some(passes);\n@@ -340,7 +340,7 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n-    for span in note.move_iter() {\n+    for span in note.into_iter() {\n         sess.span_note(span, \"lint level defined here\");\n     }\n }\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         // specified closure\n         let mut pushed = 0u;\n \n-        for result in gather_attrs(attrs).move_iter() {\n+        for result in gather_attrs(attrs).into_iter() {\n             let v = match result {\n                 Err(span) => {\n                     self.tcx.sess.span_err(span, \"malformed lint attribute\");\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 }\n             };\n \n-            for (lint_id, level, span) in v.move_iter() {\n+            for (lint_id, level, span) in v.into_iter() {\n                 let now = self.lints.get_level_source(lint_id).val0();\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n@@ -667,7 +667,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}\n             Some(lints) => {\n-                for (lint_id, span, msg) in lints.move_iter() {\n+                for (lint_id, span, msg) in lints.into_iter() {\n                     self.span_lint(lint_id.lint, span, msg.as_slice())\n                 }\n             }"}, {"sha": "342a42fbb261123c2a1cc3c35bf528a0c22bfcaa", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -85,11 +85,11 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n         map.find_or_insert_with(data.name(), |_| Vec::new()).push(cnum);\n     });\n \n-    for (name, dupes) in map.move_iter() {\n+    for (name, dupes) in map.into_iter() {\n         if dupes.len() == 1 { continue }\n         diag.handler().warn(\n             format!(\"using multiple versions of crate `{}`\", name).as_slice());\n-        for dupe in dupes.move_iter() {\n+        for dupe in dupes.into_iter() {\n             let data = cstore.get_crate_data(dupe);\n             diag.span_note(data.span, \"used here\");\n             loader::note_crate_name(diag, data.name().as_slice());"}, {"sha": "c7af7b249398af0519bb88bc866ab5b4aea0d941", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1026,7 +1026,7 @@ fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems.move_iter().collect()));\n+        items.push(attr::mk_list_item(n, subitems.into_iter().collect()));\n         true\n     });\n     return items;\n@@ -1044,7 +1044,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert_eq!(meta_items.len(), 1u);\n-            let meta_item = meta_items.move_iter().nth(0).unwrap();\n+            let meta_item = meta_items.into_iter().nth(0).unwrap();\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {"}, {"sha": "c4f7c2db6a25fd8ea6c295c1aa93ba7a5483019e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -873,7 +873,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     encode_bounds_and_type(rbml_w, ecx, &pty);\n \n     let elem = ast_map::PathName(m.ident.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n             encode_attributes(rbml_w, ast_method.attrs.as_slice());\n@@ -1295,7 +1295,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     let elem = ast_map::PathName(method_ty.ident.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).move_iter()));\n+                                path.clone().chain(Some(elem).into_iter()));\n \n                     match method_ty.explicit_self {\n                         ty::StaticExplicitSelfCategory => {\n@@ -1497,7 +1497,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n                          write_fn: |&mut SeekableMemWriter, &T|) {\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n-    for elt in index.move_iter() {\n+    for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets.get_mut(h % 256).push(elt);\n     }\n@@ -1913,7 +1913,7 @@ pub static metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't',\n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n-    wr.unwrap().move_iter().collect()\n+    wr.unwrap().into_iter().collect()\n }\n \n fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate: &Crate) {"}, {"sha": "f63705bfb9901dd792e47dea25929c877dfacce0", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -449,7 +449,7 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = Vec::new();\n-        for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n+        for (_hash, (rlibs, dylibs)) in candidates.into_iter() {\n             let mut metadata = None;\n             let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n             let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n@@ -470,7 +470,7 @@ impl<'a> Context<'a> {\n         // libraries or not.\n         match libraries.len() {\n             0 => None,\n-            1 => Some(libraries.move_iter().next().unwrap()),\n+            1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n@@ -521,11 +521,11 @@ impl<'a> Context<'a> {\n             if m.len() == 0 {\n                 return None\n             } else if m.len() == 1 {\n-                return Some(m.move_iter().next().unwrap())\n+                return Some(m.into_iter().next().unwrap())\n             }\n         }\n \n-        for lib in m.move_iter() {\n+        for lib in m.into_iter() {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.os, &lib) {\n                 Ok(blob) => {"}, {"sha": "272b7111fb88f40923c48add61ccf2570c998996", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -330,7 +330,7 @@ struct NestedItemsDropper;\n impl Folder for NestedItemsDropper {\n     fn fold_block(&mut self, blk: P<ast::Block>) -> P<ast::Block> {\n         blk.and_then(|ast::Block {id, stmts, expr, rules, span, ..}| {\n-            let stmts_sans_items = stmts.move_iter().filter_map(|stmt| {\n+            let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n                 let use_stmt = match stmt.node {\n                     ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n                     ast::StmtDecl(ref decl, _) => {\n@@ -810,7 +810,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                              tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n-             .unwrap().move_iter().collect()\n+             .unwrap().into_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n@@ -1466,7 +1466,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n-            .move_iter()\n+            .into_iter()\n             .collect()\n     }\n \n@@ -1585,7 +1585,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t> {\n-        self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().move_iter().collect()\n+        self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n     fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef> {\n@@ -1917,7 +1917,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     c::tag_table_freevars => {\n                         let fv_info = val_dsr.read_to_vec(|val_dsr| {\n                             Ok(val_dsr.read_freevar_entry(dcx))\n-                        }).unwrap().move_iter().collect();\n+                        }).unwrap().into_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_upvar_borrow_map => {"}, {"sha": "b826768c937281e875304b2494d1aaa55c5211af", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -95,7 +95,7 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n         } else {\n             Vec::new()\n         };\n-        for ge in grouped_errors.mut_iter() {\n+        for ge in grouped_errors.iter_mut() {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n                 ge.move_to_places.push_all_move(move_to);"}, {"sha": "f1c288ae7a9aab382d6b825de77f2f1743779ce6", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             ast::ExprIndex(ref l, ref r) |\n             ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n-                self.call(expr, pred, &**l, Some(&**r).move_iter())\n+                self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n             ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprParen(ref e) |\n             ast::ExprField(ref e, _, _) |\n             ast::ExprTupField(ref e, _, _) => {\n-                self.straightline(expr, pred, Some(&**e).move_iter())\n+                self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n \n             ast::ExprInlineAsm(ref inline_asm) => {"}, {"sha": "d3321e555a40ae264b7bd03357f266911b0c1db2", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -72,9 +72,9 @@ impl<'a> fmt::Show for Matrix<'a> {\n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n         let br = String::from_char(total_width, '+');\n         try!(write!(f, \"{}\\n\", br));\n-        for row in pretty_printed_matrix.move_iter() {\n+        for row in pretty_printed_matrix.into_iter() {\n             try!(write!(f, \"+\"));\n-            for (column, pat_str) in row.move_iter().enumerate() {\n+            for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n                 f.width = Some(*column_widths.get(column));\n                 try!(f.pad(pat_str.as_slice()));\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                      pats: Vec<&Pat>, left_ty: ty::t) -> P<Pat> {\n     let pats_len = pats.len();\n-    let mut pats = pats.move_iter().map(|p| P((*p).clone()));\n+    let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n         ty::ty_tup(_) => PatTup(pats.collect()),\n \n@@ -383,7 +383,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n-                let field_pats: Vec<FieldPat> = fields.move_iter()\n+                let field_pats: Vec<FieldPat> = fields.into_iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != PatWild(PatWildSingle))\n                     .map(|(field, pat)| FieldPat {\n@@ -450,10 +450,10 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).move_iter())\n+        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).into_iter())\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n-        .move_iter()\n+        .into_iter()\n         .find(|c| !used_constructors.contains(c))\n }\n \n@@ -536,7 +536,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     if constructors.is_empty() {\n         match missing_constructor(cx, matrix, left_ty, max_slice_length) {\n             None => {\n-                all_constructors(cx, left_ty, max_slice_length).move_iter().map(|c| {\n+                all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n                     match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n@@ -547,7 +547,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                                 });\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n-                            result.extend(pats.move_iter().skip(arity));\n+                            result.extend(pats.into_iter().skip(arity));\n                             result\n                         }),\n                         result => result\n@@ -569,15 +569,15 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         let wild_pats = Vec::from_elem(arity, &DUMMY_WILD_PAT);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n-                        new_pats.extend(pats.move_iter());\n+                        new_pats.extend(pats.into_iter());\n                         UsefulWithWitness(new_pats)\n                     },\n                     result => result\n                 }\n             }\n         }\n     } else {\n-        constructors.move_iter().map(|c|\n+        constructors.into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n         ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n     }"}, {"sha": "cc1789ec642e27bc1346316481dc4b3b45cad856", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.mut_slice(start, end);\n+        let gens = self.gens.slice_mut(start, end);\n         set_bit(gens, bit);\n     }\n \n@@ -242,7 +242,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = self.kills.mut_slice(start, end);\n+        let kills = self.kills.slice_mut(start, end);\n         set_bit(kills, bit);\n     }\n \n@@ -415,7 +415,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             }\n \n             if changed {\n-                let bits = self.kills.mut_slice(start, end);\n+                let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.copy_from(orig_kills.as_slice());\n@@ -498,7 +498,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n-        for b in bits.mut_iter() {\n+        for b in bits.iter_mut() {\n             *b = e;\n         }\n     }\n@@ -525,7 +525,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n+            let on_entry = self.dfcx.on_entry.slice_mut(start, end);\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n@@ -566,7 +566,7 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec.iter()) {\n         let old_val = *out_elt;\n         let new_val = op.join(old_val, *in_elt);\n         *out_elt = new_val;"}, {"sha": "a9c0b877d55b7aafaec628ccdc5e34407a779242", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -302,7 +302,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     }\n \n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs).move_iter() {\n+    for attr in lint::gather_attrs(attrs).into_iter() {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n                 if name.get() == dead_code.as_slice() => return true,"}, {"sha": "8e2d4d0dc5a94ce102616e8272779bf5945d0554", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -224,7 +224,7 @@ fn add_library(sess: &session::Session,\n fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-        Some(crates.move_iter().map(|_| Some(cstore::RequireStatic)).collect())\n+        Some(crates.into_iter().map(|_| Some(cstore::RequireStatic)).collect())\n     } else {\n         None\n     }"}, {"sha": "e3806f02ed4c86dfc9afbeee6c18672bd61f7814", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -121,7 +121,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n             identifier: Ident::new(elem.name()),\n             lifetimes: vec!(),\n             types: OwnedSlice::empty()\n-        }).move_iter().collect(),\n+        }).into_iter().collect(),\n         span: DUMMY_SP,\n     })\n }"}, {"sha": "ded4883350ff2c6cc1ec1e7debd7646209b31475", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -6045,7 +6045,7 @@ impl<'a> Resolver<'a> {\n         if idents.len() == 0 {\n             return \"???\".to_string();\n         }\n-        self.idents_to_string(idents.move_iter().rev()\n+        self.idents_to_string(idents.into_iter().rev()\n                                  .collect::<Vec<ast::Ident>>()\n                                  .as_slice())\n     }"}, {"sha": "4b35024ecb05f655bf010baba5135aa6d8f3c088", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -64,7 +64,7 @@ impl<T> HomogeneousTuple3<T> for (T, T, T) {\n     }\n \n     fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.as_mut_slice().mut_iter()\n+        self.as_mut_slice().iter_mut()\n     }\n \n     fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n@@ -350,7 +350,7 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n         let mut result = VecPerParamSpace::empty();\n-        for t in t.move_iter() {\n+        for t in t.into_iter() {\n             result.push(space(&t), t);\n         }\n         result\n@@ -394,7 +394,7 @@ impl<T> VecPerParamSpace<T> {\n     pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n         self.truncate(space, 0);\n-        for t in elems.move_iter() {\n+        for t in elems.into_iter() {\n             self.push(space, t);\n         }\n     }\n@@ -420,7 +420,7 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.mut_slice(start, limit)\n+        self.content.slice_mut(start, limit)\n     }\n \n     pub fn opt_get<'a>(&'a self,\n@@ -471,9 +471,9 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n         let (t, s, f) = self.split();\n-        VecPerParamSpace::new(t.move_iter().map(|p| pred(p)).collect(),\n-                              s.move_iter().map(|p| pred(p)).collect(),\n-                              f.move_iter().map(|p| pred(p)).collect())\n+        VecPerParamSpace::new(t.into_iter().map(|p| pred(p)).collect(),\n+                              s.into_iter().map(|p| pred(p)).collect(),\n+                              f.into_iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {"}, {"sha": "22392f3f1c0acccc83a566ccb318bec1a065f000", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -142,7 +142,7 @@ impl FulfillmentContext {\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n-            for selection in selections.move_iter() {\n+            for selection in selections.into_iter() {\n                 selection.map_move_nested(\n                     |o| self.register_obligation(tcx, o));\n             }\n@@ -247,4 +247,3 @@ impl FulfillmentContext {\n         }\n     }\n }\n-"}, {"sha": "3b670dc04fd422bed743e7e0944467801ab21aea", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1735,7 +1735,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .iter()\n                 .chain(slice.iter())\n                 .chain(after.iter())\n-                .zip(extracted.vals.move_iter())\n+                .zip(extracted.vals.into_iter())\n                 .fold(bcx, |bcx, (inner, elem)|\n                     bind_irrefutable_pat(bcx, &**inner, elem, binding_mode, cleanup_scope)\n                 );"}, {"sha": "a5e6d606d7bc1ff0e85e26966c08435a000dfd1c", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -80,7 +80,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     let mut constraints =\n         String::from_str(constraints.iter()\n                                     .map(|s| s.get().to_string())\n-                                    .chain(ext_constraints.move_iter())\n+                                    .chain(ext_constraints.into_iter())\n                                     .collect::<Vec<String>>()\n                                     .connect(\",\")\n                                     .as_slice());"}, {"sha": "a0cb8810289fa0405ba0dd0197b6b7e6ffd43960", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1631,7 +1631,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n \n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n-    for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n+    for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n         // have all locals and arguments be by-ref so that we can cancel the\n@@ -1662,7 +1662,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n \n     assert_eq!(arg_datums.len(), 1);\n \n-    let arg_datum = arg_datums.move_iter().next().unwrap();\n+    let arg_datum = arg_datums.into_iter().next().unwrap();\n \n     // Untuple the rest of the arguments.\n     let tuple_datum =\n@@ -2062,7 +2062,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n         let repr = adt::represent_type(ccx, result_ty);\n-        for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n+        for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n                                                  dest,\n@@ -3133,7 +3133,7 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n     // the final product, so LTO needs to preserve them.\n     shared_ccx.sess().cstore.iter_crate_data(|cnum, _| {\n         let syms = csearch::get_reachable_extern_fns(&shared_ccx.sess().cstore, cnum);\n-        reachable.extend(syms.move_iter().map(|did| {\n+        reachable.extend(syms.into_iter().map(|did| {\n             csearch::get_symbol(&shared_ccx.sess().cstore, did)\n         }));\n     });"}, {"sha": "e95f640b4486949a9259d07038c8fa19e51ff680", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // we care about.\n         if ixs.len() < 16 {\n             let mut small_vec = [ C_i32(self.ccx, 0), ..16 ];\n-            for (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n+            for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))"}, {"sha": "2fd58303de309807488c477fb5545c23099e0029", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -145,7 +145,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        for elt in cls.mut_iter() {\n+        for elt in cls.iter_mut() {\n             *elt = Memory;\n         }\n     }"}, {"sha": "cdc0bd76225aa62de759177f2c33af36b4eed7de", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -382,7 +382,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_clean_in_ast_scope(cleanup_scope={:?})\",\n                cleanup_scope);\n \n-        for scope in self.scopes.borrow_mut().mut_iter().rev() {\n+        for scope in self.scopes.borrow_mut().iter_mut().rev() {\n             if scope.kind.is_ast_with_id(cleanup_scope) {\n                 scope.cleanups.push(cleanup);\n                 scope.clear_cached_exits();\n@@ -712,7 +712,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // Check if a landing pad block exists; if not, create one.\n         {\n             let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.mut_last().unwrap();\n+            let last_scope = scopes.last_mut().unwrap();\n             match last_scope.cached_landing_pad {\n                 Some(llbb) => { return llbb; }\n                 None => {"}, {"sha": "6ab344ff69e930e11632e25ac55ee63f318188ce", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -197,7 +197,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    for (i, bv) in bound_values.move_iter().enumerate() {\n+    for (i, bv) in bound_values.into_iter().enumerate() {\n         debug!(\"Copy {} into closure\", bv.to_string(ccx));\n \n         if ccx.sess().asm_comments() {"}, {"sha": "962f97ab74c6fc8908e7df162b0691e1a871a957", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -422,8 +422,8 @@ impl LocalCrateContext {\n                 adt_reprs: RefCell::new(HashMap::new()),\n                 type_hashcodes: RefCell::new(HashMap::new()),\n                 all_llvm_symbols: RefCell::new(HashSet::new()),\n-                int_type: Type::from_ref(ptr::mut_null()),\n-                opaque_vec_type: Type::from_ref(ptr::mut_null()),\n+                int_type: Type::from_ref(ptr::null_mut()),\n+                opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 unboxed_closure_vals: RefCell::new(DefIdMap::new()),\n                 dbg_cx: dbg_cx,"}, {"sha": "a600baba5540cf6a725dcbb360754902967872ad", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -822,7 +822,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                         type_metadata,\n                                                         is_local_to_unit,\n                                                         global,\n-                                                        ptr::mut_null());\n+                                                        ptr::null_mut());\n             }\n         })\n     });\n@@ -1014,7 +1014,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::mut_null() {\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n             cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n@@ -1273,7 +1273,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     cx.sess().opts.optimize != config::No,\n                     llfn,\n                     template_parameters,\n-                    ptr::mut_null())\n+                    ptr::null_mut())\n             }\n         })\n     });\n@@ -1308,7 +1308,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n             ast::TyNil => {\n-                signature.push(ptr::mut_null());\n+                signature.push(ptr::null_mut());\n             }\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n@@ -1382,7 +1382,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_self_type_metadata,\n-                            ptr::mut_null(),\n+                            ptr::null_mut(),\n                             0,\n                             0)\n                     }\n@@ -1417,7 +1417,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_type_metadata,\n-                            ptr::mut_null(),\n+                            ptr::null_mut(),\n                             0,\n                             0)\n                     }\n@@ -2410,7 +2410,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 bytes_to_bits(enum_type_size),\n                 bytes_to_bits(enum_type_align),\n                 0, // Flags\n-                ptr::mut_null(),\n+                ptr::null_mut(),\n                 0, // RuntimeLang\n                 unique_type_id_str)\n             }\n@@ -2581,10 +2581,10 @@ fn create_struct_stub(cx: &CrateContext,\n                     bytes_to_bits(struct_size),\n                     bytes_to_bits(struct_align),\n                     0,\n-                    ptr::mut_null(),\n+                    ptr::null_mut(),\n                     empty_array,\n                     0,\n-                    ptr::mut_null(),\n+                    ptr::null_mut(),\n                     unique_type_id)\n             })\n         })\n@@ -2798,7 +2798,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n-        ty::ty_nil => ptr::mut_null(),\n+        ty::ty_nil => ptr::null_mut(),\n         _ => type_metadata(cx, signature.output, span)\n     });\n \n@@ -3074,7 +3074,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n             let col = UNKNOWN_COLUMN_NUMBER;\n             debug!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32),\n-                            scope, ptr::mut_null()];\n+                            scope, ptr::null_mut()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n                                                           elements.as_ptr(),\n@@ -3083,7 +3083,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            metadata_node = ptr::mut_null();\n+            metadata_node = ptr::null_mut();\n         }\n     };\n \n@@ -3953,7 +3953,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n         } else {\n             None\n         };\n-        let mut path = krate.move_iter().chain(path).peekable();\n+        let mut path = krate.into_iter().chain(path).peekable();\n \n         let mut current_key = Vec::new();\n         let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n@@ -3981,7 +3981,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                     // create and insert\n                     let parent_scope = match parent_node {\n                         Some(ref node) => node.scope,\n-                        None => ptr::mut_null()\n+                        None => ptr::null_mut()\n                     };\n                     let namespace_name = token::get_name(name);\n                     let scope = namespace_name.get().with_c_str(|namespace_name| {\n@@ -3991,7 +3991,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                                 parent_scope,\n                                 namespace_name,\n                                 // cannot reconstruct file ...\n-                                ptr::mut_null(),\n+                                ptr::null_mut(),\n                                 // ... or line information, but that's not so important.\n                                 0)\n                         }"}, {"sha": "f3049dcee5084fb182d8ece0332c2e41d6100107", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -618,7 +618,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n-            link::mangle(path.chain(abi.move_iter()), hash)\n+            link::mangle(path.chain(abi.into_iter()), hash)\n         });\n \n         // Compute the type that the function would have if it were just a"}, {"sha": "27216d067b99926436d0c8ade5e8b31766d42507", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -560,7 +560,7 @@ pub fn get_vtable(bcx: Block,\n                     impl_def_id: id,\n                     substs: substs,\n                     nested: _ }) => {\n-                emit_vtable_methods(bcx, id, substs).move_iter()\n+                emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n             traits::VtableUnboxedClosure(closure_def_id) => {\n                 let callee_substs =\n@@ -626,7 +626,7 @@ pub fn get_vtable(bcx: Block,\n                     }\n                 }\n \n-                (vec!(llfn)).move_iter()\n+                (vec!(llfn)).into_iter()\n             }\n             traits::VtableBuiltin |\n             traits::VtableParam(..) => {\n@@ -662,7 +662,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     let _icx = push_ctxt(\"meth::make_vtable\");\n \n     let head = vec![drop_glue, size, align];\n-    let components: Vec<_> = head.move_iter().chain(ptrs).collect();\n+    let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n         let tbl = C_struct(ccx, components.as_slice(), false);"}, {"sha": "bd472195b958cd8f5ca6c8b9f76963e9db73e387", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -4488,7 +4488,7 @@ pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Vec<attr::ReprAttr> {\n     let mut acc = Vec::new();\n \n     ty::each_attr(tcx, did, |meta| {\n-        acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(), meta).move_iter());\n+        acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(), meta).into_iter());\n         true\n     });\n "}, {"sha": "cb449f80ed4a49f7905523ec9134e9f37625117c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -197,7 +197,7 @@ fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         }\n \n         match anon_regions {\n-            Ok(v) => v.move_iter().collect(),\n+            Ok(v) => v.into_iter().collect(),\n             Err(()) => Vec::from_fn(expected_num_region_params,\n                                     |_| ty::ReStatic) // hokey\n         }\n@@ -1012,7 +1012,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     };\n     let input_tys = input_tys.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let self_and_input_tys: Vec<_> =\n-        self_ty.move_iter().chain(input_tys).collect();\n+        self_ty.into_iter().chain(input_tys).collect();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output"}, {"sha": "17cfa040804e1e541e1564eb5f32778d79f835b6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -179,7 +179,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     kind_name = \"[error]\";\n                     arg_types = subpats.clone()\n                                        .unwrap_or_default()\n-                                       .move_iter()\n+                                       .into_iter()\n                                        .map(|_| ty::mk_err())\n                                        .collect();\n                 }"}, {"sha": "d3cae157d3b2c46994534765307447305932584a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n         let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n-        for applicable_traits in opt_applicable_traits.move_iter() {\n+        for applicable_traits in opt_applicable_traits.into_iter() {\n             for trait_did in applicable_traits.iter() {\n                 debug!(\"push_extension_candidates() found trait: {}\",\n                        if trait_did.krate == ast::LOCAL_CRATE {\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n                     t.subst(tcx, &all_substs)\n                 });\n-                Some(*fn_sig.inputs.get(0)).move_iter().chain(args).collect()\n+                Some(*fn_sig.inputs.get(0)).into_iter().chain(args).collect()\n             }\n             _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };"}, {"sha": "37b77e872ca6959f5e43ffddd0c262c2573fb3dc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -650,7 +650,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**lhs),\n-                               Some(&**rhs).move_iter(), true);\n+                               Some(&**rhs).into_iter(), true);\n             }\n \n             adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n@@ -665,7 +665,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n             constrain_call(rcx, expr, Some(&**lhs),\n-                           Some(&**rhs).move_iter(), true);\n+                           Some(&**rhs).into_iter(), true);\n \n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "c7b4a78492bb7cc53946c9572b66b8e51e38d388", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -560,7 +560,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            methods.move_iter(),\n+                            methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n@@ -1273,10 +1273,10 @@ fn conv_param_bounds(ccx: &CrateCtxt,\n                                      unboxed_fn_ty_bounds } =\n         astconv::partition_bounds(ccx.tcx, span, all_bounds.as_slice());\n     let unboxed_fn_ty_bounds =\n-        unboxed_fn_ty_bounds.move_iter()\n+        unboxed_fn_ty_bounds.into_iter()\n         .map(|b| instantiate_unboxed_fn_ty(ccx, b, param_ty));\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n-        trait_bounds.move_iter()\n+        trait_bounds.into_iter()\n         .map(|b| instantiate_trait_ref(ccx, b, param_ty.to_ty(ccx.tcx)))\n         .chain(unboxed_fn_ty_bounds)\n         .collect();"}, {"sha": "499740a78ef3926747504ad20dfaa04a60cd6b84", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                   same_frs: &FreeRegionsFromSameFn) {\n             let scope_id = same_frs.scope_id;\n             let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.mut_iter() {\n+            for sr in same_regions.iter_mut() {\n                 if sr.contains(&sup_fr.bound_region)\n                    && scope_id == sr.scope_id {\n                     sr.push(sub_fr.bound_region);\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         ast::TyFixedLengthVec(build_to(ty, to), e)\n                     }\n                     ast::TyTup(tys) => {\n-                        ast::TyTup(tys.move_iter().map(|ty| build_to(ty, to)).collect())\n+                        ast::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())\n                     }\n                     ast::TyParen(typ) => ast::TyParen(build_to(typ, to)),\n                     other => other"}, {"sha": "be31e81d29baf07ed47ac6417644fef7812db554", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -84,6 +84,6 @@ impl Registry {\n \n     /// Register a lint group.\n     pub fn register_lint_group(&mut self, name: &'static str, to: Vec<&'static Lint>) {\n-        self.lint_groups.insert(name, to.move_iter().map(|x| LintId::of(x)).collect());\n+        self.lint_groups.insert(name, to.into_iter().map(|x| LintId::of(x)).collect());\n     }\n }"}, {"sha": "e0946366abc818541f39014a94fa3afe5491cfa4", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -47,7 +47,7 @@ pub fn get_rpath_flags(config: RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.move_iter().filter_map(|(_, l)| {\n+    let libs = libs.into_iter().filter_map(|(_, l)| {\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n "}, {"sha": "8f3dd18c69c59c03a1ab33bdb43efc656da9311d", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -136,14 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer.mut_slice(self.buffer_idx, size),\n+                        self.buffer.slice_mut(self.buffer_idx, size),\n                         input.slice_to(buffer_remaining));\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -162,7 +162,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer.mut_slice(0, input_remaining),\n+            self.buffer.slice_mut(0, input_remaining),\n             input.slice_from(i));\n         self.buffer_idx += input_remaining;\n     }\n@@ -173,13 +173,13 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n@@ -359,7 +359,7 @@ impl Engine256State {\n              )\n         )\n \n-        read_u32v_be(w.mut_slice(0, 16), data);\n+        read_u32v_be(w.slice_mut(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -495,14 +495,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.h0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.h1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.h2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.h3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.h4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.h5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.h6);\n-        write_u32_be(out.mut_slice(28, 32), self.engine.state.h7);\n+        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n+        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n+        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n+        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n+        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n+        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n+        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n+        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {\n@@ -631,7 +631,7 @@ mod tests {\n \n         let expected_vec: Vec<u8> = expected.from_hex()\n                                             .unwrap()\n-                                            .move_iter()\n+                                            .into_iter()\n                                             .collect();\n         assert_eq!(expected_vec, result_bytes);\n     }"}, {"sha": "ccff8afc50b03ff9ac808a0168e271df45cd3cc1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -52,7 +52,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n     let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n     try_inline_def(cx, tcx, def).map(|vec| {\n-        vec.move_iter().map(|mut item| {\n+        vec.into_iter().map(|mut item| {\n             match into {\n                 Some(into) if item.name.is_some() => {\n                     item.name = Some(into.clean(cx));\n@@ -84,12 +84,12 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n         }\n         def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n-            ret.extend(build_impls(cx, tcx, did).move_iter());\n+            ret.extend(build_impls(cx, tcx, did).into_iter());\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n         def::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n-            ret.extend(build_impls(cx, tcx, did).move_iter());\n+            ret.extend(build_impls(cx, tcx, did).into_iter());\n             build_type(cx, tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n@@ -123,7 +123,7 @@ pub fn load_attrs(cx: &DocContext, tcx: &ty::ctxt,\n                   did: ast::DefId) -> Vec<clean::Attribute> {\n     let mut attrs = Vec::new();\n     csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n-        attrs.extend(v.move_iter().map(|a| {\n+        attrs.extend(v.into_iter().map(|a| {\n             a.clean(cx)\n         }));\n     });\n@@ -138,7 +138,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n     match cx.tcx_opt() {\n         Some(tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n-            let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n+            let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n             cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n         None => {}\n@@ -150,7 +150,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let provided = ty::provided_trait_methods(tcx, did);\n-    let mut items = trait_items.move_iter().map(|trait_item| {\n+    let mut items = trait_items.into_iter().map(|trait_item| {\n         if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n             clean::ProvidedMethod(trait_item)\n         } else {\n@@ -262,7 +262,7 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     }\n \n-    impls.move_iter().filter_map(|a| a).collect()\n+    impls.into_iter().filter_map(|a| a).collect()\n }\n \n fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n@@ -369,7 +369,7 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n                 }\n                 decoder::DlDef(def) if vis == ast::Public => {\n                     match try_inline_def(cx, tcx, def) {\n-                        Some(i) => items.extend(i.move_iter()),\n+                        Some(i) => items.extend(i.into_iter()),\n                         None => {}\n                     }\n                 }"}, {"sha": "c42d8c79144dcbdf512f6035dca0f03dffc0f7aa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                 _ => unreachable!(),\n             };\n             let mut tmp = Vec::new();\n-            for child in m.items.mut_iter() {\n+            for child in m.items.iter_mut() {\n                 let inner = match child.inner {\n                     ModuleItem(ref mut m) => m,\n                     _ => continue,\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                 inner.items.push(i);\n \n             }\n-            m.items.extend(tmp.move_iter());\n+            m.items.extend(tmp.into_iter());\n         }\n \n         Crate {\n@@ -333,8 +333,8 @@ impl Clean<Item> for doctree::Module {\n             \"\".to_string()\n         };\n         let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean(cx).move_iter() {\n-            for foreign in subforeigns.move_iter() {\n+        for subforeigns in self.foreigns.clean(cx).into_iter() {\n+            for foreign in subforeigns.into_iter() {\n                 foreigns.push(foreign)\n             }\n         }\n@@ -348,8 +348,8 @@ impl Clean<Item> for doctree::Module {\n             self.statics.clean(cx),\n             self.traits.clean(cx),\n             self.impls.clean(cx),\n-            self.view_items.clean(cx).move_iter()\n-                           .flat_map(|s| s.move_iter()).collect(),\n+            self.view_items.clean(cx).into_iter()\n+                           .flat_map(|s| s.into_iter()).collect(),\n             self.macros.clean(cx),\n         );\n \n@@ -538,7 +538,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                  external_path(cx, \"Sync\", &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n-        let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n+        let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n                                                                 (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n@@ -556,7 +556,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n             None => return RegionBound,\n         };\n         let fqn = csearch::get_item_path(tcx, self.def_id);\n-        let fqn = fqn.move_iter().map(|i| i.to_string())\n+        let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n@@ -842,9 +842,9 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n-            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).move_iter()\n+            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n         } else {\n-            Vec::new().move_iter()\n+            Vec::new().into_iter()\n         }.peekable();\n         if names.peek().map(|s| s.as_slice()) == Some(\"self\") {\n             let _ = names.next();\n@@ -1274,7 +1274,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n-                let fqn: Vec<String> = fqn.move_iter().map(|i| {\n+                let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()\n                 }).collect();\n                 let kind = match ty::get(*self).sty {\n@@ -1739,7 +1739,7 @@ impl Clean<Item> for doctree::Impl {\n                 generics: self.generics.clean(cx),\n                 trait_: self.trait_.clean(cx),\n                 for_: self.for_.clean(cx),\n-                items: self.items.clean(cx).move_iter().map(|ti| {\n+                items: self.items.clean(cx).into_iter().map(|ti| {\n                         match ti {\n                             MethodImplItem(i) => i,\n                         }\n@@ -1789,7 +1789,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         let remaining = list.iter().filter(|path| {\n                             match inline::try_inline(cx, path.node.id(), None) {\n                                 Some(items) => {\n-                                    ret.extend(items.move_iter()); false\n+                                    ret.extend(items.into_iter()); false\n                                 }\n                                 None => true,\n                             }\n@@ -1804,7 +1804,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                     }\n                     ast::ViewPathSimple(ident, _, id) => {\n                         match inline::try_inline(cx, id, Some(ident)) {\n-                            Some(items) => ret.extend(items.move_iter()),\n+                            Some(items) => ret.extend(items.into_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n                     }\n@@ -2131,7 +2131,7 @@ fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n         None => return fallback(box t.clean(cx)),\n     };\n     let fqn = csearch::get_item_path(cx.tcx(), did);\n-    let fqn: Vec<String> = fqn.move_iter().map(|i| {\n+    let fqn: Vec<String> = fqn.into_iter().map(|i| {\n         i.to_string()\n     }).collect();\n     cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeStruct));"}, {"sha": "c5aece4ceacb199115544d9fe03ec23799eb2cf1", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -109,7 +109,7 @@ pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n                                        span_diagnostic_handler);\n \n     let mut cfg = config::build_configuration(&sess);\n-    for cfg_ in cfgs.move_iter() {\n+    for cfg_ in cfgs.into_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n         cfg.push(P(codemap::dummy_spanned(ast::MetaWord(cfg_))));\n     }"}, {"sha": "f05e8c7cd8bd275c90006307a38d28d60fa77047", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -192,10 +192,10 @@ mod imp {\n                                   libc::FILE_SHARE_READ |\n                                     libc::FILE_SHARE_DELETE |\n                                     libc::FILE_SHARE_WRITE,\n-                                  ptr::mut_null(),\n+                                  ptr::null_mut(),\n                                   libc::CREATE_ALWAYS,\n                                   libc::FILE_ATTRIBUTE_NORMAL,\n-                                  ptr::mut_null())\n+                                  ptr::null_mut())\n             };\n             if handle == libc::INVALID_HANDLE_VALUE {\n                 fail!(\"create file error: {}\", os::last_os_error());"}, {"sha": "66e93de995ee8f7a96e829daae92687c02eb80ad", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -25,7 +25,7 @@ pub trait DocFolder {\n             StructItem(mut i) => {\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.fields);\n                 let num_fields = foo.len();\n-                i.fields.extend(foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                i.fields.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 i.fields_stripped |= num_fields != i.fields.len();\n                 StructItem(i)\n             },\n@@ -35,7 +35,7 @@ pub trait DocFolder {\n             EnumItem(mut i) => {\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.variants);\n                 let num_variants = foo.len();\n-                i.variants.extend(foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                i.variants.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 i.variants_stripped |= num_variants != i.variants.len();\n                 EnumItem(i)\n             },\n@@ -58,12 +58,12 @@ pub trait DocFolder {\n                     }\n                 }\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.move_iter().filter_map(|x| vtrm(self, x)));\n+                i.items.extend(foo.into_iter().filter_map(|x| vtrm(self, x)));\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.move_iter()\n+                i.items.extend(foo.into_iter()\n                                   .filter_map(|x| self.fold_item(x)));\n                 ImplItem(i)\n             },\n@@ -74,7 +74,7 @@ pub trait DocFolder {\n                         let mut foo = Vec::new(); swap(&mut foo, &mut j.fields);\n                         let num_fields = foo.len();\n                         let c = |x| self.fold_item(x);\n-                        j.fields.extend(foo.move_iter().filter_map(c));\n+                        j.fields.extend(foo.into_iter().filter_map(c));\n                         j.fields_stripped |= num_fields != j.fields.len();\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n@@ -91,7 +91,7 @@ pub trait DocFolder {\n     fn fold_mod(&mut self, m: Module) -> Module {\n         Module {\n             is_crate: m.is_crate,\n-            items: m.items.move_iter().filter_map(|i| self.fold_item(i)).collect()\n+            items: m.items.into_iter().filter_map(|i| self.fold_item(i)).collect()\n         }\n     }\n "}, {"sha": "169446b0ac077ab9282cacff64338170a1bb0f95", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -299,7 +299,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.move_iter().map(|(k, (v, t))| {\n+        paths.into_iter().map(|(k, (v, t))| {\n             (k, (v, match t {\n                 clean::TypeStruct => item_type::Struct,\n                 clean::TypeEnum => item_type::Enum,\n@@ -950,7 +950,7 @@ impl DocFolder for Cache {\n                         use clean::{FixedVector, Slice, Tuple, PrimitiveTuple};\n \n                         // extract relevant documentation for this impl\n-                        let dox = match attrs.move_iter().find(|a| {\n+                        let dox = match attrs.into_iter().find(|a| {\n                             match *a {\n                                 clean::NameValue(ref x, _)\n                                         if \"doc\" == x.as_slice() => {\n@@ -1207,7 +1207,7 @@ impl Context {\n                         _ => unreachable!()\n                     };\n                     this.sidebar = build_sidebar(&m);\n-                    for item in m.items.move_iter() {\n+                    for item in m.items.into_iter() {\n                         f(this,item);\n                     }\n                     Ok(())\n@@ -2143,7 +2143,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n         v.push(myname);\n     }\n \n-    for (_, items) in map.mut_iter() {\n+    for (_, items) in map.iter_mut() {\n         items.as_mut_slice().sort();\n     }\n     return map;"}, {"sha": "4d2f23e1c314e7d173dbdb4f0876be5c5b03c2f5", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -167,7 +167,7 @@ impl TocBuilder {\n \n         // get the thing we just pushed, so we can borrow the string\n         // out of it with the right lifetime\n-        let just_inserted = self.chain.mut_last().unwrap();\n+        let just_inserted = self.chain.last_mut().unwrap();\n         just_inserted.sec_number.as_slice()\n     }\n }"}, {"sha": "f8eb40a3894522ed6d704d187166ffd86ddfa67d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -430,7 +430,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         pm.add_plugin(plugin);\n     }\n     info!(\"loading plugins...\");\n-    for pname in plugins.move_iter() {\n+    for pname in plugins.into_iter() {\n         pm.load_plugin(pname);\n     }\n \n@@ -494,7 +494,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     // }\n     let mut json = std::collections::TreeMap::new();\n     json.insert(\"schema\".to_string(), json::String(SCHEMA_VERSION.to_string()));\n-    let plugins_json = res.move_iter()\n+    let plugins_json = res.into_iter()\n                           .filter_map(|opt| {\n                               match opt {\n                                   None => None,"}, {"sha": "685d76bb5200b82f0252a5b29bddc15a6639e5ab", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -65,7 +65,7 @@ pub fn run(input: &str,\n                                       span_diagnostic_handler);\n \n     let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(cfgs.move_iter().map(|cfg_| {\n+    cfg.extend(cfgs.into_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n         P(dummy_spanned(ast::MetaWord(cfg_)))\n     }));\n@@ -104,7 +104,7 @@ pub fn run(input: &str,\n     test_args.insert(0, \"rustdoctest\".to_string());\n \n     testing::test_main(test_args.as_slice(),\n-                       collector.tests.move_iter().collect());\n+                       collector.tests.into_iter().collect());\n     0\n }\n "}, {"sha": "8854c33b169f2a15f4d5522f8f3ac7068b3fe39a", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -59,7 +59,7 @@ pub fn run() {\n         v\n     };\n \n-    for to_run in cur.move_iter() {\n+    for to_run in cur.into_iter() {\n         to_run();\n     }\n }"}, {"sha": "d40f149a2a1f8316a5cd4514efae81eb26d00d14", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -107,7 +107,7 @@ mod tests {\n                 });\n             };\n \n-            for f in futures.mut_iter() { f.recv() }\n+            for f in futures.iter_mut() { f.recv() }\n \n             assert_eq!(**total.lock(), num_tasks * count);\n         }"}, {"sha": "fe377d9e75b87c9bf83e92295263df7e8f1ca8fe", "filename": "src/librustrt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -39,7 +39,7 @@ impl LocalHeap {\n     pub fn new() -> LocalHeap {\n         LocalHeap {\n             memory_region: MemoryRegion { live_allocations: 0 },\n-            live_allocs: ptr::mut_null(),\n+            live_allocs: ptr::null_mut(),\n         }\n     }\n \n@@ -58,7 +58,7 @@ impl LocalHeap {\n             // allocations list\n             mybox.drop_glue = drop_glue;\n             mybox.ref_count = 1;\n-            mybox.prev = ptr::mut_null();\n+            mybox.prev = ptr::null_mut();\n             mybox.next = self.live_allocs;\n             if !self.live_allocs.is_null() {\n                 unsafe { (*self.live_allocs).prev = alloc; }\n@@ -165,7 +165,7 @@ impl LocalHeap {\n         //! Walks the internal list of allocations\n \n         let mut alloc = self.live_allocs;\n-        while alloc != ptr::mut_null() {\n+        while alloc != ptr::null_mut() {\n             let next_before = (*alloc).next;\n \n             f(self, alloc);"}, {"sha": "92a67da20b656cfd047d8f20c92db8aa39d11007", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -282,7 +282,7 @@ pub mod native {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n         let ptr: Box<T> = mem::transmute(void_ptr);\n-        tls::set(key, ptr::mut_null());\n+        tls::set(key, ptr::null_mut());\n         return ptr;\n     }\n \n@@ -300,7 +300,7 @@ pub mod native {\n                     None\n                 } else {\n                     let ptr: Box<T> = mem::transmute(void_ptr);\n-                    tls::set(key, ptr::mut_null());\n+                    tls::set(key, ptr::null_mut());\n                     Some(ptr)\n                 }\n             }"}, {"sha": "f4fff43fd7c4f6dad6d845834ffa64e9bf948fab", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -615,7 +615,7 @@ mod imp {\n     }\n \n     pub unsafe fn init_cond() -> uint {\n-        return CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+        return CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n                             ptr::null()) as uint;\n     }\n "}, {"sha": "bef799d4178aac773b12881ab799bf4be873fea1", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -171,8 +171,8 @@ mod imp {\n         // kernel does, might as well make it explicit.  With the current\n         // 20 kB red zone, that makes for a 64 kB minimum stack.\n         let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n-        let ret = CreateThread(ptr::mut_null(), stack_size as libc::size_t,\n-                               super::thread_start, arg, 0, ptr::mut_null());\n+        let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n+                               super::thread_start, arg, 0, ptr::null_mut());\n \n         if ret as uint == 0 {\n             // be sure to not leak the closure\n@@ -268,7 +268,7 @@ mod imp {\n     }\n \n     pub unsafe fn join(native: rust_thread) {\n-        assert_eq!(pthread_join(native, ptr::mut_null()), 0);\n+        assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n     }\n \n     pub unsafe fn detach(native: rust_thread) {"}, {"sha": "77e3e25eb0e7e9e60d310f6e6bf943f46cd6460c", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -62,7 +62,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf.mut_slice_from(self.pos);\n+            let left = self.buf.slice_from_mut(self.pos);\n             let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();"}, {"sha": "995f73af258fff40b5291219a33fb794a7746dd7", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -11,7 +11,7 @@\n use libc::c_int;\n use libc;\n use std::mem;\n-use std::ptr::{null, mut_null};\n+use std::ptr::{null, null_mut};\n use std::rt::task::BlockedTask;\n use std::rt::rtio;\n \n@@ -62,9 +62,9 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: mut_null(),\n-                ai_addr: mut_null(),\n-                ai_next: mut_null(),\n+                ai_canonname: null_mut(),\n+                ai_addr: null_mut(),\n+                ai_next: null_mut(),\n             }\n         });\n         let hint_ptr = hint.as_ref().map_or(null(), |x| {"}, {"sha": "7cbfac1cf45d6a2e444a567f9ac9cf8b169e95eb", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -168,7 +168,7 @@ pub trait UvHandle<T> {\n         }\n \n         unsafe {\n-            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::mut_null::<()>());\n+            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null_mut::<()>());\n             uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb)\n         }\n     }\n@@ -179,7 +179,7 @@ pub trait UvHandle<T> {\n         unsafe {\n             uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb);\n             uvll::set_data_for_uv_handle(self.uv_handle(),\n-                                         ptr::mut_null::<()>());\n+                                         ptr::null_mut::<()>());\n \n             wait_until_woken_after(&mut slot, &self.uv_loop(), || {\n                 uvll::set_data_for_uv_handle(self.uv_handle(), &mut slot);\n@@ -190,7 +190,7 @@ pub trait UvHandle<T> {\n             unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 uvll::free_handle(handle);\n-                if data == ptr::mut_null() { return }\n+                if data == ptr::null_mut() { return }\n                 let slot: &mut Option<BlockedTask> = mem::transmute(data);\n                 wakeup(slot);\n             }\n@@ -271,7 +271,7 @@ impl Request {\n     pub fn new(ty: uvll::uv_req_type) -> Request {\n         unsafe {\n             let handle = uvll::malloc_req(ty);\n-            uvll::set_data_for_req(handle, ptr::mut_null::<()>());\n+            uvll::set_data_for_req(handle, ptr::null_mut::<()>());\n             Request::wrap(handle)\n         }\n     }\n@@ -286,7 +286,7 @@ impl Request {\n \n     pub unsafe fn get_data<T>(&self) -> &'static mut T {\n         let data = uvll::get_data_for_req(self.handle);\n-        assert!(data != ptr::mut_null());\n+        assert!(data != ptr::null_mut());\n         mem::transmute(data)\n     }\n \n@@ -448,7 +448,7 @@ pub type Buf = uvll::uv_buf_t;\n \n pub fn empty_buf() -> Buf {\n     uvll::uv_buf_t {\n-        base: ptr::mut_null(),\n+        base: ptr::null_mut(),\n         len: 0,\n     }\n }"}, {"sha": "31c9fdde68cd02a127679c1d9d856cd412b00c65", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -60,7 +60,7 @@ impl Process {\n         let mut ret_io = Vec::with_capacity(io.len());\n         unsafe {\n             stdio.set_len(io.len());\n-            for (slot, other) in stdio.mut_iter().zip(io.iter()) {\n+            for (slot, other) in stdio.iter_mut().zip(io.iter()) {\n                 let io = set_stdio(slot as *mut uvll::uv_stdio_container_t, other,\n                                    io_loop);\n                 ret_io.push(io);"}, {"sha": "97bd9315a0a5cc932f116ebff808a921aa5a5e8d", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -136,7 +136,7 @@ impl StreamWatcher {\n         let mut req = match self.last_write_req.take() {\n             Some(req) => req, None => Request::new(uvll::UV_WRITE),\n         };\n-        req.set_data(ptr::mut_null::<()>());\n+        req.set_data(ptr::null_mut::<()>());\n \n         // And here's where timeouts get a little interesting. Currently, libuv\n         // does not support canceling an in-flight write request. Consequently,"}, {"sha": "43973f2fb8e50dceddad621ce5fd4b62133f1824", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -70,7 +70,7 @@ impl TtyWatcher {\n                 // handle, so our only cleanup is to free the handle itself\n                 if cfg!(windows) {\n                     unsafe { uvll::free_handle(handle); }\n-                    watcher.tty = ptr::mut_null();\n+                    watcher.tty = ptr::null_mut();\n                 }\n                 Err(UvError(n))\n             }"}, {"sha": "f2a2b5d2f1d3b4220080b9a5a8c27c44d9bd92f8", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -270,7 +270,7 @@ impl IoFactory for UvIoFactory {\n         match Process::spawn(self, cfg) {\n             Ok((p, io)) => {\n                 Ok((p as Box<rtio::RtioProcess + Send>,\n-                    io.move_iter().map(|i| i.map(|p| {\n+                    io.into_iter().map(|i| i.map(|p| {\n                         box p as Box<rtio::RtioPipe + Send>\n                     })).collect()))\n             }"}, {"sha": "5e8697ef0ade4d0a5683826ecb4023edebdc88bd", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -131,7 +131,7 @@ impl<'a> FromHex for &'a str {\n         }\n \n         match modulus {\n-            0 => Ok(b.move_iter().collect()),\n+            0 => Ok(b.into_iter().collect()),\n             _ => Err(InvalidHexLength),\n         }\n     }"}, {"sha": "e9c3a2afb038657ba04b8984e4718d4a598acb86", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1843,7 +1843,7 @@ impl<T: Iterator<char>> Builder<T> {\n \n         loop {\n             if self.token == Some(ListEnd) {\n-                return Ok(List(values.move_iter().collect()));\n+                return Ok(List(values.into_iter().collect()));\n             }\n             match self.build_value() {\n                 Ok(v) => values.push(v),\n@@ -2059,7 +2059,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 };\n                 match o.pop(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n-                        for field in l.move_iter().rev() {\n+                        for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n@@ -2186,7 +2186,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_seq()\");\n         let list = try!(expect!(self.pop(), List));\n         let len = list.len();\n-        for v in list.move_iter().rev() {\n+        for v in list.into_iter().rev() {\n             self.stack.push(v);\n         }\n         f(self, len)\n@@ -2203,7 +2203,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_map()\");\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n-        for (key, value) in obj.move_iter() {\n+        for (key, value) in obj.into_iter() {\n             self.stack.push(value);\n             self.stack.push(String(key));\n         }"}, {"sha": "fd8432ded8b50076fb75ef8c41d71ee9e9748ed3", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -464,15 +464,15 @@ impl<'a> AsciiExt<Vec<u8>> for &'a [u8] {\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_upper(mut self) -> Vec<u8> {\n-        for byte in self.mut_iter() {\n+        for byte in self.iter_mut() {\n             *byte = ASCII_UPPER_MAP[*byte as uint];\n         }\n         self\n     }\n \n     #[inline]\n     fn into_ascii_lower(mut self) -> Vec<u8> {\n-        for byte in self.mut_iter() {\n+        for byte in self.iter_mut() {\n             *byte = ASCII_LOWER_MAP[*byte as uint];\n         }\n         self"}, {"sha": "d8a7305810fe43165c7bf1fbf83c178140ea8892", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -73,7 +73,7 @@ impl<T> CVec<T> {\n     /// * base - A raw pointer to a buffer\n     /// * len - The number of elements in the buffer\n     pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> {\n-        assert!(base != ptr::mut_null());\n+        assert!(base != ptr::null_mut());\n         CVec {\n             base: base,\n             len: len,\n@@ -94,7 +94,7 @@ impl<T> CVec<T> {\n     ///          for freeing the buffer, etc.\n     pub unsafe fn new_with_dtor(base: *mut T, len: uint,\n                                 dtor: proc():Send) -> CVec<T> {\n-        assert!(base != ptr::mut_null());\n+        assert!(base != ptr::null_mut());\n         CVec {\n             base: base,\n             len: len,\n@@ -191,7 +191,7 @@ mod tests {\n     #[should_fail]\n     fn test_fail_at_null() {\n         unsafe {\n-            CVec::new(ptr::mut_null::<u8>(), 9);\n+            CVec::new(ptr::null_mut::<u8>(), 9);\n         }\n     }\n "}, {"sha": "e8c5eecc6f2e764c1dd8bc37f38b7542a50032fd", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -696,7 +696,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         if new_capacity < old_table.capacity() {\n             // Shrink the table. Naive algorithm for resizing:\n-            for (h, k, v) in old_table.move_iter() {\n+            for (h, k, v) in old_table.into_iter() {\n                 self.insert_hashed_nocheck(h, k, v);\n             }\n         } else {\n@@ -943,7 +943,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let new = vec![\"a key\", \"b key\", \"z key\"];\n     ///\n-    /// for k in new.move_iter() {\n+    /// for k in new.into_iter() {\n     ///     map.find_with_or_insert_with(\n     ///         k, \"new value\",\n     ///         // if the key does exist either prepend or append this\n@@ -1214,7 +1214,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.insert(\"c\", 3);\n     ///\n     /// // Update all values\n-    /// for (_, val) in map.mut_iter() {\n+    /// for (_, val) in map.iter_mut() {\n     ///     *val *= 2;\n     /// }\n     ///\n@@ -1223,7 +1223,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n-        MutEntries { inner: self.table.mut_iter() }\n+        MutEntries { inner: self.table.iter_mut() }\n     }\n \n     /// Deprecated: use `into_iter`.\n@@ -1247,11 +1247,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// map.insert(\"c\", 3);\n     ///\n     /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         MoveEntries {\n-            inner: self.table.move_iter().map(|(_, k, v)| (k, v))\n+            inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n         }\n     }\n }\n@@ -1573,7 +1573,7 @@ mod test_map {\n         drop(hm.clone());\n \n         {\n-            let mut half = hm.move_iter().take(50);\n+            let mut half = hm.into_iter().take(50);\n \n             let v = drop_vector.get().unwrap();\n             for i in range(0u, 200) {\n@@ -1797,7 +1797,7 @@ mod test_map {\n     #[test]\n     fn test_keys() {\n         let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.move_iter().collect::<HashMap<int, char>>();\n+        let map = vec.into_iter().collect::<HashMap<int, char>>();\n         let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n@@ -1808,7 +1808,7 @@ mod test_map {\n     #[test]\n     fn test_values() {\n         let vec = vec![(1i, 'a'), (2i, 'b'), (3i, 'c')];\n-        let map = vec.move_iter().collect::<HashMap<int, char>>();\n+        let map = vec.into_iter().collect::<HashMap<int, char>>();\n         let values = map.values().map(|&v| v).collect::<Vec<char>>();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n@@ -1997,7 +1997,7 @@ mod test_map {\n \n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n-        let mut iter = map.mut_iter();\n+        let mut iter = map.iter_mut();\n \n         for _ in iter.by_ref().take(3) {}\n "}, {"sha": "dde1f27c9a322dd54665d584c81224d6e63be61b", "filename": "src/libstd/collections/hashmap/set.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -245,6 +245,12 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         self.map.keys()\n     }\n \n+    /// Deprecated: use `into_iter`.\n+    #[deprecated = \"use into_iter\"]\n+    pub fn move_iter(self) -> SetMoveItems<T> {\n+        self.into_iter()\n+    }\n+\n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n@@ -258,15 +264,15 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(\"b\".to_string());\n     ///\n     /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n-    /// let v: Vec<String> = set.move_iter().collect();\n+    /// let v: Vec<String> = set.into_iter().collect();\n     ///\n     /// // Will print in an arbitrary order.\n     /// for x in v.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    pub fn move_iter(self) -> SetMoveItems<T> {\n-        self.map.move_iter().map(|(k, _)| k)\n+    pub fn into_iter(self) -> SetMoveItems<T> {\n+        self.map.into_iter().map(|(k, _)| k)\n     }\n \n     /// Visit the values representing the difference.\n@@ -661,7 +667,7 @@ mod test_set {\n             hs\n         };\n \n-        let v = hs.move_iter().collect::<Vec<char>>();\n+        let v = hs.into_iter().collect::<Vec<char>>();\n         assert!(['a', 'b'] == v.as_slice() || ['b', 'a'] == v.as_slice());\n     }\n "}, {"sha": "87a5cc1484a24b6dc390a8487aa18cf770e305df", "filename": "src/libstd/collections/hashmap/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -872,7 +872,7 @@ impl<K, V> Drop for RawTable<K, V> {\n             return;\n         }\n         // This is done in reverse because we've likely partially taken\n-        // some elements out with `.move_iter()` from the front.\n+        // some elements out with `.into_iter()` from the front.\n         // Check if the size is 0, so we don't do a useless scan when\n         // dropping empty tables such as on resize.\n         // Also avoid double drop of elements that have been already moved out."}, {"sha": "5408e50f2bda3d89715591340ac70297998d3f0a", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -84,8 +84,8 @@ impl<K, V> LruEntry<K, V> {\n         LruEntry {\n             key: k,\n             value: v,\n-            next: ptr::mut_null(),\n-            prev: ptr::mut_null(),\n+            next: ptr::null_mut(),\n+            prev: ptr::null_mut(),\n         }\n     }\n }"}, {"sha": "e929f140dbd28ced44de998e2cc7e2d2ea3c10ee", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -301,7 +301,7 @@ pub mod dl {\n     }\n \n     pub unsafe fn open_internal() -> *mut u8 {\n-        let mut handle = ptr::mut_null();\n+        let mut handle = ptr::null_mut();\n         GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &mut handle);\n         handle as *mut u8\n     }"}, {"sha": "a777a372ad14fb6879696f1d06dc541cc13074cf", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -195,7 +195,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.get_mut_ref().write(buf)\n         } else {\n-            let dst = self.buf.mut_slice_from(self.pos);\n+            let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -273,7 +273,7 @@ impl<W> InternalBufferedWriter<W> {\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.get_mut_ref().inner.get_mut_ref().read(buf)\n+        self.get_mut().inner.get_mut_ref().read(buf)\n     }\n }\n \n@@ -359,10 +359,10 @@ impl<S: Stream> Reader for BufferedStream<S> {\n \n impl<S: Stream> Writer for BufferedStream<S> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.inner.get_mut_ref().write(buf)\n+        self.inner.inner.get_mut().write(buf)\n     }\n     fn flush(&mut self) -> IoResult<()> {\n-        self.inner.inner.get_mut_ref().flush()\n+        self.inner.inner.get_mut().flush()\n     }\n }\n "}, {"sha": "f2ff5c7b5c2b453c83b684c1d6a836abf0b415d5", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -62,7 +62,7 @@ impl Reader for ChanReader {\n         loop {\n             match self.buf {\n                 Some(ref prev) => {\n-                    let dst = buf.mut_slice_from(num_read);\n+                    let dst = buf.slice_from_mut(num_read);\n                     let src = prev.slice_from(self.pos);\n                     let count = cmp::min(dst.len(), src.len());\n                     bytes::copy_memory(dst, src.slice_to(count));"}, {"sha": "f912b3ee38f100d8bdee02a5b21f96c75fa59a7f", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -652,7 +652,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// at a non-directory file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     let err = LocalIo::maybe_raise(|io| {\n-        Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).move_iter().map(|a| {\n+        Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).into_iter().map(|a| {\n             Path::new(a)\n         }).collect())\n     }).map_err(IoError::from_rtio_error);\n@@ -764,7 +764,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n \n         // delete all regular files in the way and push subdirs\n         // on the stack\n-        for child in children.move_iter() {\n+        for child in children.into_iter() {\n             // FIXME(#12795) we should use lstat in all cases\n             let child_type = match cfg!(windows) {\n                 true => try!(update_err(stat(&child), path)),\n@@ -1059,11 +1059,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem.mut_slice(0, 4);\n+                let read_buf = read_mem.slice_mut(0, 4);\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem.mut_slice(4, 8);\n+                let read_buf = read_mem.slice_mut(4, 8);\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "c826bd16715d6618f3c6f6d422702c676d563278", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -147,7 +147,7 @@ impl Reader for MemReader {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.mut_slice(0, write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -232,7 +232,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n+        slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -293,7 +293,7 @@ impl<'a> Reader for BufReader<'a> {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.mut_slice(0, write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -548,7 +548,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(0, buf.mut_slice_to(0)).is_ok());\n+        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "ff508c802d8455cc36209048bba9abdd4e27a615", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -578,7 +578,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf.mut_slice_from(read)) {\n+                match self.read(buf.slice_from_mut(read)) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1524,7 +1524,7 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf.mut_slice(start, width))) {\n+                match try!(self.read(buf.slice_mut(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),"}, {"sha": "867e8bcca826d25732c6c94692091667175435c6", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -76,7 +76,7 @@ pub struct Info {\n /// Easy name resolution. Given a hostname, returns the list of IP addresses for\n /// that hostname.\n pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n-    lookup(Some(host), None, None).map(|a| a.move_iter().map(|i| i.address.ip).collect())\n+    lookup(Some(host), None, None).map(|a| a.into_iter().map(|i| i.address.ip).collect())\n }\n \n /// Full-fledged resolution. This function will perform a synchronous call to\n@@ -105,7 +105,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n     match LocalIo::maybe_raise(|io| {\n         io.get_host_addresses(hostname, servname, hint)\n     }) {\n-        Ok(v) => Ok(v.move_iter().map(|info| {\n+        Ok(v) => Ok(v.into_iter().map(|info| {\n             Info {\n                 address: SocketAddr {\n                     ip: super::from_rtio(info.address.ip),"}, {"sha": "1141cd22eebb62edb7bc9c947d01d68429d4d742", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -109,7 +109,7 @@ impl<'a> Parser<'a> {\n     // Return result of first successful parser\n     fn read_or<T>(&mut self, parsers: &mut [|&mut Parser| -> Option<T>])\n                -> Option<T> {\n-        for pf in parsers.mut_iter() {\n+        for pf in parsers.iter_mut() {\n             match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n                 Some(r) => return Some(r),\n                 None => {}\n@@ -233,7 +233,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.copy_from(head);\n-            gs.mut_slice(8 - tail.len(), 8).copy_from(tail);\n+            gs.slice_mut(8 - tail.len(), 8).copy_from(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "6689615f01b222bae527fd9dbc50ac68de611c3a", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -48,7 +48,7 @@ use rt::rtio;\n /// match socket.recv_from(buf) {\n ///     Ok((amt, src)) => {\n ///         // Send a reply to the socket we received data from\n-///         let buf = buf.mut_slice_to(amt);\n+///         let buf = buf.slice_to_mut(amt);\n ///         buf.reverse();\n ///         socket.send_to(buf, src);\n ///     }"}, {"sha": "1225dcf1f4a10be4f295030c434c01aadfbb8e59", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -167,7 +167,7 @@ impl Command {\n             None => {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n-                self.env = Some(os::env_as_bytes().move_iter()\n+                self.env = Some(os::env_as_bytes().into_iter()\n                                    .map(|(k, v)| (k.as_slice().to_c_str(),\n                                                   v.as_slice().to_c_str()))\n                                    .collect());\n@@ -289,7 +289,7 @@ impl Command {\n                 detach: self.detach,\n             };\n             io.spawn(cfg).map(|(p, io)| {\n-                let mut io = io.move_iter().map(|p| {\n+                let mut io = io.into_iter().map(|p| {\n                     p.map(|p| io::PipeStream::new(p))\n                 });\n                 Process {"}, {"sha": "78d1a2f485afb873b2b75984cef6d813397eb95d", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -166,7 +166,7 @@ mod darwin_fd_limit {\n     pub unsafe fn raise_fd_limit() {\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::mut_null;\n+        use ptr::null_mut;\n         use mem::size_of_val;\n         use os::last_os_error;\n \n@@ -175,7 +175,7 @@ mod darwin_fd_limit {\n         let mut maxfiles: libc::c_int = 0;\n         let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n         if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n-                  mut_null(), 0) != 0 {\n+                  null_mut(), 0) != 0 {\n             let err = last_os_error();\n             fail!(\"raise_fd_limit: error calling sysctl: {}\", err);\n         }"}, {"sha": "16ac8c4c265fe09ce7c2edc16de233bd85bd63c5", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -47,7 +47,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf.mut_slice_to(len));\n+        let res = self.inner.read(buf.slice_to_mut(len));\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}\n@@ -139,15 +139,15 @@ impl MultiWriter {\n impl Writer for MultiWriter {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        for writer in self.writers.mut_iter() {\n+        for writer in self.writers.iter_mut() {\n             try!(writer.write(buf));\n         }\n         Ok(())\n     }\n \n     #[inline]\n     fn flush(&mut self) -> io::IoResult<()> {\n-        for writer in self.writers.mut_iter() {\n+        for writer in self.writers.iter_mut() {\n             try!(writer.flush());\n         }\n         Ok(())\n@@ -251,7 +251,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         let mut len = 0;\n-        for (slot, elt) in buf.mut_iter().zip(self.iter.by_ref()) {\n+        for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n             *slot = elt;\n             len += 1;\n         }\n@@ -364,7 +364,7 @@ mod test {\n     fn test_chained_reader() {\n         let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n                       MemReader::new(vec!(2, 3)));\n-        let mut r = ChainedReader::new(rs.move_iter());\n+        let mut r = ChainedReader::new(rs.into_iter());\n         assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n     }\n "}, {"sha": "f1480eb7d455ac894accf494e321ca83e6abf32e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -218,7 +218,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// }\n /// ```\n pub fn env() -> Vec<(String,String)> {\n-    env_as_bytes().move_iter().map(|(k,v)| {\n+    env_as_bytes().into_iter().map(|(k,v)| {\n         let k = String::from_utf8_lossy(k.as_slice()).into_string();\n         let v = String::from_utf8_lossy(v.as_slice()).into_string();\n         (k,v)\n@@ -663,14 +663,14 @@ pub fn self_exe_name() -> Option<Path> {\n                                -1 as c_int];\n             let mut sz: libc::size_t = 0;\n             let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::mut_null(), &mut sz, ptr::mut_null(),\n+                             ptr::null_mut(), &mut sz, ptr::null_mut(),\n                              0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n             let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                              v.as_mut_ptr() as *mut c_void, &mut sz,\n-                             ptr::mut_null(), 0u as libc::size_t);\n+                             ptr::null_mut(), 0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -695,7 +695,7 @@ pub fn self_exe_name() -> Option<Path> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n             let mut sz: u32 = 0;\n-            _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n+            _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n             if sz == 0 { return None; }\n             let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n@@ -1045,7 +1045,7 @@ pub fn error_string(errnum: uint) -> String {\n         unsafe {\n             let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n                                      FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                     ptr::mut_null(),\n+                                     ptr::null_mut(),\n                                      errnum as DWORD,\n                                      langId,\n                                      buf.as_mut_ptr(),\n@@ -1192,7 +1192,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n \n #[cfg(not(windows))]\n fn real_args() -> Vec<String> {\n-    real_args_as_bytes().move_iter()\n+    real_args_as_bytes().into_iter()\n                         .map(|v| {\n                             String::from_utf8_lossy(v.as_slice()).into_string()\n                         }).collect()\n@@ -1229,7 +1229,7 @@ fn real_args() -> Vec<String> {\n \n #[cfg(windows)]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    real_args().move_iter().map(|s| s.into_bytes()).collect()\n+    real_args().into_iter().map(|s| s.into_bytes()).collect()\n }\n \n type LPCWSTR = *const u16;\n@@ -1529,7 +1529,7 @@ impl MemoryMap {\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n-        let mut lpAddress: LPVOID = ptr::mut_null();\n+        let mut lpAddress: LPVOID = ptr::null_mut();\n         let mut readable = false;\n         let mut writable = false;\n         let mut executable = false;\n@@ -1589,12 +1589,12 @@ impl MemoryMap {\n             unsafe {\n                 let hFile = libc::get_osfhandle(fd) as HANDLE;\n                 let mapping = libc::CreateFileMappingW(hFile,\n-                                                       ptr::mut_null(),\n+                                                       ptr::null_mut(),\n                                                        flProtect,\n                                                        0,\n                                                        0,\n                                                        ptr::null());\n-                if mapping == ptr::mut_null() {\n+                if mapping == ptr::null_mut() {\n                     return Err(ErrCreateFileMappingW(errno()));\n                 }\n                 if errno() as c_int == libc::ERROR_ALREADY_EXISTS {"}, {"sha": "c654d3a668a7c2b64a6b6fcc5ef0148d89fcd409", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -382,7 +382,7 @@ impl Path {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n                         let mut v = Vec::with_capacity(n);\n-                        let mut it = comps.move_iter();\n+                        let mut it = comps.into_iter();\n                         if !is_abs {\n                             match it.next() {\n                                 None => (),\n@@ -1201,7 +1201,7 @@ mod tests {\n                     assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n                             comps, exps);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n-                    let exps = exps.move_iter().rev().collect::<Vec<&[u8]>>();\n+                    let exps = exps.into_iter().rev().collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n                             comps, exps);\n                 }"}, {"sha": "e68c8bdb07d200a87e6771ab161350f724fac4e5", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -832,7 +832,7 @@ impl Path {\n                             Some(_) => s.push_str(prefix_),\n                             None => ()\n                         }\n-                        let mut it = comps.move_iter();\n+                        let mut it = comps.into_iter();\n                         if !is_abs {\n                             match it.next() {\n                                 None => (),"}, {"sha": "4b3ddc2f953327945663433ef00ff4e7f8307e66", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -162,7 +162,7 @@\n //! // where the car is. The game host will never open the door with the car.\n //! fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n //!     let choices = free_doors(&[car, choice]);\n-//!     rand::sample(rng, choices.move_iter(), 1)[0]\n+//!     rand::sample(rng, choices.into_iter(), 1)[0]\n //! }\n //!\n //! // Returns the door we switch to, given our current choice and"}, {"sha": "5557ef9943b864d996a49a34824d7b3a9b9d4340", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -485,7 +485,7 @@ mod imp {\n                     let bytes = path.as_vec();\n                     if bytes.len() < LAST_FILENAME.len() {\n                         let i = bytes.iter();\n-                        for (slot, val) in LAST_FILENAME.mut_iter().zip(i) {\n+                        for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n                             *slot = *val as libc::c_char;\n                         }\n                         LAST_FILENAME.as_ptr()\n@@ -496,7 +496,7 @@ mod imp {\n                 None => ptr::null(),\n             };\n             STATE = backtrace_create_state(filename, 0, error_cb,\n-                                           ptr::mut_null());\n+                                           ptr::null_mut());\n             return STATE\n         }\n "}, {"sha": "23ba582ec0aa7c659c552897c936aa779108680d", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -31,7 +31,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn drop(&mut self) {\n-        for channel in self.channels.mut_iter() {\n+        for channel in self.channels.iter_mut() {\n             channel.send(Quit);\n         }\n     }"}, {"sha": "4e66dd69a607b932d357d04843d6a92293520402", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -654,7 +654,7 @@ impl<T: Send> Sender<T> {\n \n         unsafe {\n             let tmp = Sender::new(Stream(new_inner));\n-            mem::swap(self.mut_inner(), tmp.mut_inner());\n+            mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n         return ret;\n     }\n@@ -695,7 +695,7 @@ impl<T: Send> Clone for Sender<T> {\n             (*packet.get()).inherit_blocker(sleeper);\n \n             let tmp = Sender::new(Shared(packet.clone()));\n-            mem::swap(self.mut_inner(), tmp.mut_inner());\n+            mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n         Sender::new(Shared(packet))\n     }\n@@ -704,7 +704,7 @@ impl<T: Send> Clone for Sender<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.mut_inner() } {\n+        match *unsafe { self.inner_mut() } {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n@@ -895,8 +895,8 @@ impl<T: Send> Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(self.mut_inner(),\n-                          new_port.mut_inner());\n+                mem::swap(self.inner_mut(),\n+                          new_port.inner_mut());\n             }\n         }\n     }\n@@ -943,7 +943,7 @@ impl<T: Send> Receiver<T> {\n                 Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n-                mem::swap(self.mut_inner(), new_port.mut_inner());\n+                mem::swap(self.inner_mut(), new_port.inner_mut());\n             }\n         }\n     }\n@@ -980,8 +980,8 @@ impl<T: Send> select::Packet for Receiver<T> {\n                 }\n             };\n             unsafe {\n-                mem::swap(self.mut_inner(),\n-                          new_port.mut_inner());\n+                mem::swap(self.inner_mut(),\n+                          new_port.inner_mut());\n             }\n         }\n     }\n@@ -1012,8 +1012,8 @@ impl<T: Send> select::Packet for Receiver<T> {\n             };\n             task = t;\n             unsafe {\n-                mem::swap(self.mut_inner(),\n-                          new_port.mut_inner());\n+                mem::swap(self.inner_mut(),\n+                          new_port.inner_mut());\n             }\n         }\n     }\n@@ -1036,8 +1036,8 @@ impl<T: Send> select::Packet for Receiver<T> {\n             let new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n             unsafe {\n-                mem::swap(self.mut_inner(),\n-                          new_port.mut_inner());\n+                mem::swap(self.inner_mut(),\n+                          new_port.inner_mut());\n             }\n         }\n     }\n@@ -1051,7 +1051,7 @@ impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.mut_inner() } {\n+        match *unsafe { self.inner_mut() } {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n             Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },"}, {"sha": "6204b54fba4be48bb9799c5886d88adf27a8a3a5", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -513,7 +513,7 @@ mod tests {\n             }\n         }\n \n-        for thread in threads.move_iter() {\n+        for thread in threads.into_iter() {\n             thread.join();\n         }\n     }\n@@ -536,7 +536,7 @@ mod tests {\n             })\n         }).collect::<Vec<Thread<()>>>();\n \n-        for thread in threads.move_iter() {\n+        for thread in threads.into_iter() {\n             thread.join();\n         }\n     }\n@@ -592,7 +592,7 @@ mod tests {\n             DONE.store(true, SeqCst);\n         }\n \n-        for thread in threads.move_iter() {\n+        for thread in threads.into_iter() {\n             thread.join();\n         }\n \n@@ -657,7 +657,7 @@ mod tests {\n \n         unsafe { DONE.store(true, SeqCst); }\n \n-        for thread in threads.move_iter() {\n+        for thread in threads.into_iter() {\n             thread.join();\n         }\n     }"}, {"sha": "951a945f73a78853eb7d1ba7bef3fb8230a0ae37", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -636,7 +636,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for r in children.mut_iter() {\n+        for r in children.iter_mut() {\n             assert!(r.get_ref().is_ok());\n         }\n \n@@ -722,12 +722,12 @@ mod tests {\n         assert_eq!(*lock, 42);\n         *lock = 31337;\n         // send to other readers\n-        for &(ref mut rc, _) in reader_convos.mut_iter() {\n+        for &(ref mut rc, _) in reader_convos.iter_mut() {\n             rc.send(())\n         }\n         let lock = lock.downgrade();\n         // complete handshake with other readers\n-        for &(_, ref mut rp) in reader_convos.mut_iter() {\n+        for &(_, ref mut rp) in reader_convos.iter_mut() {\n             rp.recv()\n         }\n         tx1.send(()); // tell writer to try again"}, {"sha": "fa29bb6088ae1497a805cbbf771856169ffecc6a", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -210,7 +210,7 @@ mod tests {\n             });\n         }\n \n-        for rx in completion_rxs.mut_iter() {\n+        for rx in completion_rxs.iter_mut() {\n             assert_eq!(nmsgs, rx.recv());\n         }\n         for _ in range(0, nthreads) {"}, {"sha": "81ae8dbb98f1ae19e0ec452fafea19722b33c66d", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -804,14 +804,14 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for rx in rxs.mut_iter() { rx.recv(); }\n+        for rx in rxs.iter_mut() { rx.recv(); }\n         {\n             let lock = m.lock();\n             let num_woken = lock.cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for rx in rxs.mut_iter() { rx.recv(); }\n+        for rx in rxs.iter_mut() { rx.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -1058,13 +1058,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n+        for rx in rxs.iter_mut() { let _ = rx.recv(); }\n         lock_cond(&x, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n+        for rx in rxs.iter_mut() { let _ = rx.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "ed0b8700bf374dc5f7160426c778b80748bd3944", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -417,7 +417,7 @@ impl<'ast> Map<'ast> {\n \n     fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n         self.with_path(id, |path| {\n-            path_to_string(path.chain(Some(PathName(i.name)).move_iter()))\n+            path_to_string(path.chain(Some(PathName(i.name)).into_iter()))\n         })\n     }\n "}, {"sha": "ace1e1245c7180cedae6c690a253bd5668056c13", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -245,14 +245,14 @@ pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n-    let mut v = items.move_iter()\n+    let mut v = items.into_iter()\n         .map(|mi| (mi.name(), mi))\n         .collect::<Vec<(InternedString, P<MetaItem>)>>();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n-    v.move_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n+    v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n         Spanned {\n             node: match node {\n                 MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),"}, {"sha": "773daa4a4c5934fec269b0bd7f73ac091b6d0095", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -712,7 +712,7 @@ impl SyntaxEnv {\n     }\n \n     fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame {\n-        for (i, frame) in self.chain.mut_iter().enumerate().rev() {\n+        for (i, frame) in self.chain.iter_mut().enumerate().rev() {\n             if !frame.info.macros_escape || i == 0 {\n                 return frame\n             }"}, {"sha": "7b2613d4e8ba08e668e6394725e144187ac64679", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -301,7 +301,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 types: Vec<P<ast::Ty>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = idents.move_iter()\n+        let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n@@ -969,7 +969,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n-        let args = tys.move_iter().map(|ty| {\n+        let args = tys.into_iter().map(|ty| {\n             ast::VariantArg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n "}, {"sha": "cd3e247a80697bcd80d6e19f309c8ca3d1681bae", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -25,7 +25,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         None => return base::DummyResult::expr(sp)\n     };\n     let mut accumulator = String::new();\n-    for e in es.move_iter() {\n+    for e in es.into_iter() {\n         match e.node {\n             ast::ExprLit(ref lit) => {\n                 match lit.node {"}, {"sha": "ecee2008254ddb43dc460754863dbaadd05308ea", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`\n             // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.move_iter().map(|e| cx.stmt_expr(e)).collect();\n+            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n             let block = cx.block(span, stmts, None);\n             cx.expr_block(block)\n         },"}, {"sha": "ff249495bd7fd63bb2ab1da50018a4c43f80b9ee", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -468,7 +468,7 @@ impl<'a> TraitDef<'a> {\n             ast::ItemImpl(trait_generics,\n                           opt_trait_ref,\n                           self_type,\n-                          methods.move_iter()\n+                          methods.into_iter()\n                                  .map(|method| {\n                                      ast::MethodImplItem(method)\n                                  }).collect()))\n@@ -666,10 +666,10 @@ impl<'a> MethodDef<'a> {\n             _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable, special_idents::self_))\n         };\n         let args = {\n-            let args = arg_types.move_iter().map(|(name, ty)| {\n+            let args = arg_types.into_iter().map(|(name, ty)| {\n                     cx.arg(trait_.span, name, ty)\n                 });\n-            self_arg.move_iter().chain(args).collect()\n+            self_arg.into_iter().chain(args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -741,7 +741,7 @@ impl<'a> MethodDef<'a> {\n \n         // transpose raw_fields\n         let fields = if raw_fields.len() > 0 {\n-            let mut raw_fields = raw_fields.move_iter().map(|v| v.move_iter());\n+            let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n             let mut other_fields: Vec<vec::MoveItems<(Span, Option<Ident>, P<Expr>)>>\n                 = raw_fields.collect();\n@@ -750,7 +750,7 @@ impl<'a> MethodDef<'a> {\n                     span: span,\n                     name: opt_id,\n                     self_: field,\n-                    other: other_fields.mut_iter().map(|l| {\n+                    other: other_fields.iter_mut().map(|l| {\n                         match l.next().unwrap() {\n                             (_, _, ex) => ex\n                         }\n@@ -953,7 +953,7 @@ impl<'a> MethodDef<'a> {\n \n                 // The transposition is driven by walking across the\n                 // arg fields of the variant for the first self pat.\n-                let field_tuples = first_self_pat_idents.move_iter().enumerate()\n+                let field_tuples = first_self_pat_idents.into_iter().enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n                     .map(|(field_index, (sp, opt_ident, self_getter_expr))| {\n                         // ... but FieldInfo also wants getter expr\n@@ -1264,7 +1264,7 @@ impl<'a> TraitDef<'a> {\n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n         let pattern = if struct_type == Record {\n-            let field_pats = subpats.move_iter().zip(ident_expr.iter()).map(|(pat, &(_, id, _))| {\n+            let field_pats = subpats.into_iter().zip(ident_expr.iter()).map(|(pat, &(_, id, _))| {\n                 // id is guaranteed to be Some\n                 ast::FieldPat { ident: id.unwrap(), pat: pat }\n             }).collect();\n@@ -1418,11 +1418,11 @@ pub fn cs_same_method_fold(use_foldl: bool,\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                vals.move_iter().fold(base.clone(), |old, new| {\n+                vals.into_iter().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             } else {\n-                vals.move_iter().rev().fold(base.clone(), |old, new| {\n+                vals.into_iter().rev().fold(base.clone(), |old, new| {\n                     f(cx, span, old, new)\n                 })\n             }"}, {"sha": "87e257c52cd25d631ab116c62cb710bb928ca089", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -67,7 +67,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             return DummyResult::expr(sp);\n         }\n         None => return DummyResult::expr(sp),\n-        Some(exprs) => exprs.move_iter()\n+        Some(exprs) => exprs.into_iter()\n     };\n \n     let var = match expr_to_string(cx,"}, {"sha": "4ff9912645aa0bf01a6954a3b95bbd8d78ddf0b5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -271,8 +271,8 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n                     let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n                     dec.expand(fld.cx, attr.span, &*attr.node.value, &*it,\n                                |item| items.push(item));\n-                    decorator_items.extend(items.move_iter()\n-                        .flat_map(|item| expand_item(item, fld).move_iter()));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|item| expand_item(item, fld).into_iter()));\n \n                     fld.cx.bt_pop();\n                 }\n@@ -485,9 +485,9 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             SmallVector::zero()\n         }\n         Right(Some(items)) => {\n-            items.move_iter()\n+            items.into_iter()\n                 .map(|i| mark_item(i, fm))\n-                .flat_map(|i| fld.fold_item(i).move_iter())\n+                .flat_map(|i| fld.fold_item(i).into_iter())\n                 .collect()\n         }\n         Right(None) => {\n@@ -525,7 +525,7 @@ fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     fld.cx.bt_pop();\n \n     if semi {\n-        fully_expanded.move_iter().map(|s| s.map(|Spanned {node, span}| {\n+        fully_expanded.into_iter().map(|s| s.map(|Spanned {node, span}| {\n             Spanned {\n                 node: match node {\n                     StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n@@ -620,7 +620,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n     let idents = pattern_bindings(&**expanded_pats.get(0));\n-    let new_renames = idents.move_iter().map(|id| (id, fresh_name(&id))).collect();\n+    let new_renames = idents.into_iter().map(|id| (id, fresh_name(&id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n     let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n@@ -687,16 +687,16 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n     b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n-        let new_view_items = view_items.move_iter().map(|x| fld.fold_view_item(x)).collect();\n-        let new_stmts = stmts.move_iter().flat_map(|x| {\n+        let new_view_items = view_items.into_iter().map(|x| fld.fold_view_item(x)).collect();\n+        let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n                 let mut rename_fld = IdentRenamer{renames:pending_renames};\n                 rename_fld.fold_stmt(x).expect_one(\"rename_fold didn't return one value\")\n             };\n             // expand macros in the statement\n-            fld.fold_stmt(renamed_stmt).move_iter()\n+            fld.fold_stmt(renamed_stmt).into_iter()\n         }).collect();\n         let new_expr = expr.map(|x| {\n             let expr = {\n@@ -897,7 +897,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n             };\n \n             // expand again if necessary\n-            new_methods.move_iter().flat_map(|m| fld.fold_method(m).move_iter()).collect()\n+            new_methods.into_iter().flat_map(|m| fld.fold_method(m).into_iter()).collect()\n         }\n     })\n }\n@@ -994,11 +994,11 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n         cx: &mut cx,\n     };\n \n-    for ExportedMacros { crate_name, macros } in imported_macros.move_iter() {\n+    for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n         let name = format!(\"<{} macros>\", token::get_ident(crate_name))\n             .into_string();\n \n-        for source in macros.move_iter() {\n+        for source in macros.into_iter() {\n             let item = parse::parse_item_from_source_str(name.clone(),\n                                                          source,\n                                                          expander.cx.cfg(),\n@@ -1008,7 +1008,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n         }\n     }\n \n-    for (name, extension) in user_exts.move_iter() {\n+    for (name, extension) in user_exts.into_iter() {\n         expander.cx.syntax_env.insert(name, extension);\n     }\n "}, {"sha": "26586684309765d230b19a4f301bfef03a96493b", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -500,7 +500,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::new();\n \n         // First, declare all of our methods that are statics\n-        for method in self.method_statics.move_iter() {\n+        for method in self.method_statics.into_iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n             lets.push(P(respan(self.fmtsp,\n                                ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID))));\n@@ -543,7 +543,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // format! string are shoved into locals. Furthermore, we shove the address\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n-        for (i, e) in self.args.move_iter().enumerate() {\n+        for (i, e) in self.args.into_iter().enumerate() {\n             let arg_ty = match self.arg_types.get(i).as_ref() {\n                 Some(ty) => ty,\n                 None => continue // error already generated\n@@ -577,8 +577,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         // Now create a vector containing all the arguments\n         let slicename = self.ecx.ident_of(\"__args_vec\");\n         {\n-            let args = names.move_iter().map(|a| a.unwrap());\n-            let mut args = locals.move_iter().chain(args);\n+            let args = names.into_iter().map(|a| a.unwrap());\n+            let mut args = locals.into_iter().chain(args);\n             let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n             lets.push(self.ecx.stmt_let(self.fmtsp, false, slicename, args));\n         }"}, {"sha": "aa2a23dd2768aff621919e3cb8f973ed67a93156", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -54,7 +54,7 @@ pub mod rt {\n \n     impl<T: ToTokens> ToTokens for Vec<T> {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let a = self.iter().flat_map(|t| t.to_tokens(cx).move_iter());\n+            let a = self.iter().flat_map(|t| t.to_tokens(cx).into_iter());\n             FromIterator::from_iter(a)\n         }\n     }"}, {"sha": "090b39eee47145f2de9d9b1cff30a94d6680d2e5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -366,7 +366,7 @@ pub fn parse(sess: &ParseSess,\n         if token_name_eq(&tok, &EOF) {\n             if eof_eis.len() == 1u {\n                 let mut v = Vec::new();\n-                for dv in eof_eis.get_mut(0).matches.mut_iter() {\n+                for dv in eof_eis.get_mut(0).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, v.as_slice()));"}, {"sha": "1b9f6f16542f23d2d86351f8725e20dd50823758", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -164,7 +164,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         /* done with this set; pop or repeat? */\n         if should_pop {\n             let prev = r.stack.pop().unwrap();\n-            match r.stack.mut_last() {\n+            match r.stack.last_mut() {\n                 None => {\n                     r.cur_tok = EOF;\n                     return ret_val;\n@@ -178,8 +178,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.repeat_len.pop();\n             }\n         } else { /* repeat */\n-            *r.repeat_idx.mut_last().unwrap() += 1u;\n-            r.stack.mut_last().unwrap().idx = 0;\n+            *r.repeat_idx.last_mut().unwrap() += 1u;\n+            r.stack.last_mut().unwrap().idx = 0;\n             match r.stack.last().unwrap().sep.clone() {\n                 Some(tk) => {\n                     r.cur_tok = tk; /* repeat same span, I guess */\n@@ -209,7 +209,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             TTTok(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;\n-                r.stack.mut_last().unwrap().idx += 1;\n+                r.stack.last_mut().unwrap().idx += 1;\n                 return ret_val;\n             }\n             TTSeq(sp, tts, sep, zerok) => {\n@@ -234,7 +234,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                                      \"this must repeat at least once\");\n                             }\n \n-                            r.stack.mut_last().unwrap().idx += 1;\n+                            r.stack.last_mut().unwrap().idx += 1;\n                             return tt_next_token(r);\n                         }\n                         r.repeat_len.push(len);\n@@ -250,7 +250,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             }\n             // FIXME #2887: think about span stuff here\n             TTNonterminal(sp, ident) => {\n-                r.stack.mut_last().unwrap().idx += 1;\n+                r.stack.last_mut().unwrap().idx += 1;\n                 match *lookup_cur_matched(r, ident) {\n                     /* sidestep the interpolation tricks for ident because\n                        (a) idents can be in lots of places, so it'd be a pain"}, {"sha": "4806c5fa7c06221118d0dbba0d119461115403e8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -37,7 +37,7 @@ pub trait MoveMap<T> {\n impl<T> MoveMap<T> for Vec<T> {\n     fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n         use std::{mem, ptr};\n-        for p in self.mut_iter() {\n+        for p in self.iter_mut() {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n                 mem::move_val_init(p, f(ptr::read_and_zero(p)));\n@@ -351,7 +351,7 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>\n             node: DeclLocal(fld.fold_local(l)),\n             span: fld.new_span(span)\n         })),\n-        DeclItem(it) => fld.fold_item(it).move_iter().map(|i| P(Spanned {\n+        DeclItem(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n             node: DeclItem(i),\n             span: fld.new_span(span)\n         })).collect()\n@@ -819,7 +819,7 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n         view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n-        stmts: stmts.move_iter().flat_map(|s| folder.fold_stmt(s).move_iter()).collect(),\n+        stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n         expr: expr.map(|x| folder.fold_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n@@ -860,27 +860,27 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemImpl(folder.fold_generics(generics),\n                      ifce.map(|p| folder.fold_trait_ref(p)),\n                      folder.fold_ty(ty),\n-                     impl_items.move_iter().flat_map(|impl_item| match impl_item {\n+                     impl_items.into_iter().flat_map(|impl_item| match impl_item {\n                         MethodImplItem(x) => {\n-                            folder.fold_method(x).move_iter().map(|x| MethodImplItem(x))\n+                            folder.fold_method(x).into_iter().map(|x| MethodImplItem(x))\n                         }\n                      }).collect())\n         }\n         ItemTrait(generics, unbound, bounds, methods) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let methods = methods.move_iter().flat_map(|method| match method {\n+            let methods = methods.into_iter().flat_map(|method| match method {\n                 RequiredMethod(m) => {\n-                    SmallVector::one(RequiredMethod(folder.fold_type_method(m))).move_iter()\n+                    SmallVector::one(RequiredMethod(folder.fold_type_method(m))).into_iter()\n                 }\n                 ProvidedMethod(method) => {\n                     // the awkward collect/iter idiom here is because\n                     // even though an iter and a map satisfy the same trait bound,\n                     // they're not actually the same type, so the method arms\n                     // don't unify.\n                     let methods: SmallVector<ast::TraitItem> =\n-                        folder.fold_method(method).move_iter()\n+                        folder.fold_method(method).into_iter()\n                         .map(|m| ProvidedMethod(m)).collect();\n-                    methods.move_iter()\n+                    methods.into_iter()\n                 }\n             }).collect();\n             ItemTrait(folder.fold_generics(generics),\n@@ -912,7 +912,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mu\n     Mod {\n         inner: folder.new_span(inner),\n         view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n-        items: items.move_iter().flat_map(|x| folder.fold_item(x).move_iter()).collect(),\n+        items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n     }\n }\n \n@@ -1194,7 +1194,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n     match node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n-            folder.fold_decl(d).move_iter().map(|d| P(Spanned {\n+            folder.fold_decl(d).into_iter().map(|d| P(Spanned {\n                 node: StmtDecl(d, id),\n                 span: span\n             })).collect()"}, {"sha": "798a54c1062d4313354ef583f64881f6ea34a32b", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -49,7 +49,7 @@ impl<T> Drop for OwnedSlice<T> {\n \n impl<T> OwnedSlice<T> {\n     pub fn empty() -> OwnedSlice<T> {\n-        OwnedSlice  { data: ptr::mut_null(), len: 0 }\n+        OwnedSlice  { data: ptr::null_mut(), len: 0 }\n     }\n \n     #[inline(never)]\n@@ -106,7 +106,7 @@ impl<T> OwnedSlice<T> {\n     }\n \n     pub fn move_iter(self) -> vec::MoveItems<T> {\n-        self.into_vec().move_iter()\n+        self.into_vec().into_iter()\n     }\n \n     pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {"}, {"sha": "a6a2ecb199a3a74cd22d3bf26a8411b9f3431c90", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -1295,7 +1295,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let mut attrs = attrs;\n-                attrs.extend(inner_attrs.move_iter());\n+                attrs.extend(inner_attrs.into_iter());\n                 ProvidedMethod(P(ast::Method {\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n@@ -1404,7 +1404,7 @@ impl<'a> Parser<'a> {\n \n                 if ts.len() == 1 && !one_tuple {\n                     self.expect(&token::RPAREN);\n-                    TyParen(ts.move_iter().nth(0).unwrap())\n+                    TyParen(ts.into_iter().nth(0).unwrap())\n                 } else {\n                     let t = TyTup(ts);\n                     self.expect(&token::RPAREN);\n@@ -2011,7 +2011,7 @@ impl<'a> Parser<'a> {\n                 self.commit_expr_expecting(&**es.last().unwrap(), token::RPAREN);\n \n                 return if es.len() == 1 && !trailing_comma {\n-                   self.mk_expr(lo, hi, ExprParen(es.move_iter().nth(0).unwrap()))\n+                   self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n                 } else {\n                     self.mk_expr(lo, hi, ExprTup(es))\n                 }\n@@ -3500,7 +3500,7 @@ impl<'a> Parser<'a> {\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n-        for item in items.move_iter() {\n+        for item in items.into_iter() {\n             let span = item.span;\n             let decl = P(spanned(span.lo, span.hi, DeclItem(item)));\n             stmts.push(P(spanned(span.lo, span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))));\n@@ -3898,7 +3898,7 @@ impl<'a> Parser<'a> {\n                           \"variadic function must be declared with at least one named argument\");\n         }\n \n-        let args = args.move_iter().map(|x| x.unwrap()).collect();\n+        let args = args.into_iter().map(|x| x.unwrap()).collect();\n \n         (args, variadic)\n     }\n@@ -4958,7 +4958,7 @@ impl<'a> Parser<'a> {\n                     seq_sep_trailing_allowed(token::COMMA),\n                     |p| p.parse_ty(true)\n                 );\n-                for ty in arg_tys.move_iter() {\n+                for ty in arg_tys.into_iter() {\n                     args.push(ast::VariantArg {\n                         ty: ty,\n                         id: ast::DUMMY_NODE_ID,\n@@ -5057,7 +5057,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let mut attrs = attrs;\n                 mem::swap(&mut item.attrs, &mut attrs);\n-                item.attrs.extend(attrs.move_iter());\n+                item.attrs.extend(attrs.into_iter());\n                 return IoviItem(P(item));\n             }\n             None => {}\n@@ -5408,7 +5408,7 @@ impl<'a> Parser<'a> {\n             let path = ast::Path {\n                 span: span,\n                 global: false,\n-                segments: path.move_iter().map(|identifier| {\n+                segments: path.into_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n                         lifetimes: Vec::new(),\n@@ -5443,7 +5443,7 @@ impl<'a> Parser<'a> {\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n                         global: false,\n-                        segments: path.move_iter().map(|identifier| {\n+                        segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetimes: Vec::new(),\n@@ -5461,7 +5461,7 @@ impl<'a> Parser<'a> {\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n                         global: false,\n-                        segments: path.move_iter().map(|identifier| {\n+                        segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetimes: Vec::new(),\n@@ -5483,7 +5483,7 @@ impl<'a> Parser<'a> {\n         let path = ast::Path {\n             span: mk_sp(lo, self.span.hi),\n             global: false,\n-            segments: path.move_iter().map(|identifier| {\n+            segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n                     lifetimes: Vec::new(),"}, {"sha": "a3f081e7be4de5b7f79a495a732a3cbbe61f8b96", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -90,7 +90,7 @@ impl<T> SmallVector<T> {\n     }\n \n     pub fn push_all(&mut self, other: SmallVector<T>) {\n-        for v in other.move_iter() {\n+        for v in other.into_iter() {\n             self.push(v);\n         }\n     }\n@@ -108,7 +108,7 @@ impl<T> SmallVector<T> {\n             One(v) => v,\n             Many(v) => {\n                 if v.len() == 1 {\n-                    v.move_iter().next().unwrap()\n+                    v.into_iter().next().unwrap()\n                 } else {\n                     fail!(err)\n                 }\n@@ -117,11 +117,17 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n+    /// Deprecated: use `into_iter`.\n+    #[deprecated = \"use into_iter\"]\n     pub fn move_iter(self) -> MoveItems<T> {\n+        self.into_iter()\n+    }\n+\n+    pub fn into_iter(self) -> MoveItems<T> {\n         let repr = match self.repr {\n             Zero => ZeroIterator,\n             One(v) => OneIterator(v),\n-            Many(vs) => ManyIterator(vs.move_iter())\n+            Many(vs) => ManyIterator(vs.into_iter())\n         };\n         MoveItems { repr: repr }\n     }\n@@ -202,7 +208,7 @@ mod test {\n \n     #[test]\n     fn test_from_iter() {\n-        let v: SmallVector<int> = (vec!(1i, 2, 3)).move_iter().collect();\n+        let v: SmallVector<int> = (vec!(1i, 2, 3)).into_iter().collect();\n         assert_eq!(3, v.len());\n         assert_eq!(&1, v.get(0));\n         assert_eq!(&2, v.get(1));\n@@ -212,14 +218,14 @@ mod test {\n     #[test]\n     fn test_move_iter() {\n         let v = SmallVector::zero();\n-        let v: Vec<int> = v.move_iter().collect();\n+        let v: Vec<int> = v.into_iter().collect();\n         assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1i);\n-        assert_eq!(vec!(1i), v.move_iter().collect());\n+        assert_eq!(vec!(1i), v.into_iter().collect());\n \n         let v = SmallVector::many(vec!(1i, 2i, 3i));\n-        assert_eq!(vec!(1i, 2i, 3i), v.move_iter().collect());\n+        assert_eq!(vec!(1i, 2i, 3i), v.into_iter().collect());\n     }\n \n     #[test]"}, {"sha": "e6fc64cbd3b0c697174e32f75143a6968842fda4", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -102,7 +102,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         Number(0), Number(0), Number(0), Number(0), Number(0),\n         Number(0), Number(0), Number(0), Number(0),\n     ];\n-    for (dst, src) in mparams.mut_iter().zip(params.iter()) {\n+    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n         *dst = (*src).clone();\n     }\n \n@@ -501,7 +501,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                     return Err(\"non-number on stack with %s\".to_string())\n                 }\n             };\n-            let mut s: Vec<u8> = s.move_iter().collect();\n+            let mut s: Vec<u8> = s.into_iter().collect();\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n@@ -532,7 +532,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                          .to_ascii()\n                          .to_upper()\n                          .into_bytes()\n-                         .move_iter()\n+                         .into_iter()\n                          .collect();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));"}, {"sha": "758496fa2c244dc64dbfb2127af54b60dce6c77c", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -949,7 +949,7 @@ fn run_tests(opts: &TestOpts,\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n-    for b in filtered_benchs_and_metrics.move_iter() {\n+    for b in filtered_benchs_and_metrics.into_iter() {\n         try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(opts, !opts.run_benchmarks, b, tx.clone());\n         let (test, result, stdout) = rx.recv();\n@@ -981,7 +981,7 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     filtered = match opts.filter {\n         None => filtered,\n         Some(ref re) => {\n-            filtered.move_iter()\n+            filtered.into_iter()\n                 .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n         }\n     };\n@@ -1001,7 +1001,7 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n                 None\n             }\n         };\n-        filtered.move_iter().filter_map(|x| filter(x)).collect()\n+        filtered.into_iter().filter_map(|x| filter(x)).collect()\n     };\n \n     // Sort the tests alphabetically\n@@ -1011,7 +1011,7 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     match opts.test_shard {\n         None => filtered,\n         Some((a,b)) => {\n-            filtered.move_iter().enumerate()\n+            filtered.into_iter().enumerate()\n             // note: using a - 1 so that the valid shards, for example, are\n             // 1.2 and 2.2 instead of 0.2 and 1.2\n             .filter(|&(i,_)| i % b == (a - 1))\n@@ -1054,7 +1054,7 @@ pub fn run_test(opts: &TestOpts,\n             }\n             let result_future = task.try_future(testfn);\n \n-            let stdout = reader.read_to_end().unwrap().move_iter().collect();\n+            let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let task_result = result_future.unwrap();\n             let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n@@ -1328,15 +1328,15 @@ impl Bencher {\n         loop {\n             let loop_start = precise_time_ns();\n \n-            for p in samples.mut_iter() {\n+            for p in samples.iter_mut() {\n                 self.bench_n(n, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };\n \n             stats::winsorize(samples, 5.0);\n             let summ = stats::Summary::new(samples);\n \n-            for p in samples.mut_iter() {\n+            for p in samples.iter_mut() {\n                 self.bench_n(5 * n, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n             };"}, {"sha": "7087d4c4238380dc8f64439b4103a7c3ca8d0a7b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -323,7 +323,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n     let lo = percentile_of_sorted(tmp.as_slice(), pct);\n     let hundred: T = FromPrimitive::from_uint(100).unwrap();\n     let hi = percentile_of_sorted(tmp.as_slice(), hundred-pct);\n-    for samp in samples.mut_iter() {\n+    for samp in samples.iter_mut() {\n         if *samp > hi {\n             *samp = hi\n         } else if *samp < lo {"}, {"sha": "abf6fc5f2558cfb660bdf64797b106e981ec43d2", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -155,7 +155,7 @@ pub fn get_time() -> Timespec {\n     unsafe fn os_get_time() -> (i64, i32) {\n         use std::ptr;\n         let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        imp::gettimeofday(&mut tv, ptr::mut_null());\n+        imp::gettimeofday(&mut tv, ptr::null_mut());\n         (tv.tv_sec as i64, tv.tv_usec * 1000)\n     }\n "}, {"sha": "1f527e89eb23f815bd017c309b4182a4edf722f5", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"100000\".to_string())\n     } else {\n-        args.move_iter().collect()\n+        args.into_iter().collect()\n     };\n \n     let n = from_str::<uint>(args.get(1).as_slice()).unwrap();"}, {"sha": "3b39ce610a1f5a7622bb8517761e1ded983741cd", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -75,7 +75,7 @@ fn run(args: &[String]) {\n         server(&from_parent, &to_parent);\n     });\n \n-    for r in worker_results.move_iter() {\n+    for r in worker_results.into_iter() {\n         r.unwrap();\n     }\n \n@@ -99,7 +99,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.move_iter().map(|x| x.to_string()).collect()\n+        args.into_iter().map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{}\", args);"}, {"sha": "f103014ca88047c4daaa4382d02f1a308f0c5321", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -83,7 +83,7 @@ fn run(args: &[String]) {\n         server(&from_parent, &to_parent);\n     });\n \n-    for r in worker_results.move_iter() {\n+    for r in worker_results.into_iter() {\n         r.unwrap();\n     }\n \n@@ -107,7 +107,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.clone().move_iter().map(|x| x.to_string()).collect()\n+        args.clone().into_iter().map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{:?}\", args);"}, {"sha": "d1a2dcf6d558897b8f3cbc04bc44a614af52cfbc", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -69,7 +69,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n     } else {\n-        args.clone().move_iter().collect()\n+        args.clone().into_iter().collect()\n     };\n \n     let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n@@ -97,7 +97,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n-    for f in futures.mut_iter() {\n+    for f in futures.iter_mut() {\n         f.get()\n     }\n "}, {"sha": "c07656a5e4b6d0ba2794469edda62d0caee41af9", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -69,7 +69,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n     } else {\n-        args.clone().move_iter().collect()\n+        args.clone().into_iter().collect()\n     };\n \n     let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n@@ -97,7 +97,7 @@ fn main() {\n     thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n-    for f in futures.mut_iter() {\n+    for f in futures.iter_mut() {\n         let _ = f.get();\n     }\n "}, {"sha": "19ccf1b6caf721f47c84f2672077fdf1a739e20b", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -43,12 +43,12 @@ impl Noise2DContext {\n         let mut rng = StdRng::new().unwrap();\n \n         let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }, ..256];\n-        for x in rgradients.mut_iter() {\n+        for x in rgradients.iter_mut() {\n             *x = random_gradient(&mut rng);\n         }\n \n         let mut permutations = [0i32, ..256];\n-        for (i, x) in permutations.mut_iter().enumerate() {\n+        for (i, x) in permutations.iter_mut().enumerate() {\n             *x = i as i32;\n         }\n         rng.shuffle(permutations);"}, {"sha": "90d2c857858378749b5d0abdd10835ea46107435", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n-        args.move_iter().collect()\n+        args.into_iter().collect()\n     };\n     let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));"}, {"sha": "a0c69b3736d5bdbcc244e79c4271514440e7a94c", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -108,7 +108,7 @@ fn main() {\n             })\n         }).collect::<Vec<Future<String>>>();\n \n-    for message in messages.mut_iter() {\n+    for message in messages.iter_mut() {\n         println!(\"{}\", *message.get_ref());\n     }\n "}, {"sha": "5e812e500d6e81c6457db93de35e0e8725d73a76", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -43,14 +43,14 @@ use std::sync::Future;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n-    for place in x.mut_iter().rev() {\n+    for place in x.iter_mut().rev() {\n         prev = mem::replace(place, prev)\n     }\n }\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm.mut_slice_to(i + 1));\n+        rotate(perm.slice_to_mut(i + 1));\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -91,15 +91,15 @@ impl Perm {\n     fn get(&mut self, mut idx: i32) -> P {\n         let mut pp = [0u8, .. 16];\n         self.permcount = idx as u32;\n-        for (i, place) in self.perm.p.mut_iter().enumerate() {\n+        for (i, place) in self.perm.p.iter_mut().enumerate() {\n             *place = i as i32 + 1;\n         }\n \n         for i in range(1, self.n as uint).rev() {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.mut_iter().zip(self.perm.p.slice_to(i + 1).iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p.slice_to(i + 1).iter()) {\n                 *place = (*val) as u8\n             }\n \n@@ -125,7 +125,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm.mut_slice_to(k).reverse()\n+    tperm.slice_to_mut(k).reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n@@ -169,7 +169,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n-    for fut in futures.mut_iter() {\n+    for fut in futures.iter_mut() {\n         let (cs, mf) = fut.get();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);"}, {"sha": "8e10cb089fa30c1c743f89b5ffd036a4448c9754", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -94,7 +94,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf.mut_slice(alu_len, buf_len),\n+        copy_memory(buf.slice_mut(alu_len, buf_len),\n                     alu.slice_to(LINE_LEN));\n \n         let mut pos = 0;\n@@ -117,7 +117,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n     let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n     let mut j = 0;\n-    for (i, slot) in lookup.mut_iter().enumerate() {\n+    for (i, slot) in lookup.iter_mut().enumerate() {\n         while a[j].p < (i as f32) {\n             j += 1;\n         }"}, {"sha": "1f42cc6e00c5dcd580bcee0d292f7c2f2df576de", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"30\".to_string())\n     } else {\n-        args.move_iter().collect()\n+        args.into_iter().collect()\n     };\n     let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n     println!(\"{}\\n\", fib(n));"}, {"sha": "f4d1cee5fb4ca11434a1378e3e555e334aeaf161", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -157,7 +157,7 @@ fn main() {\n     let sizes = vec!(1u,2,3,4,6,12,18);\n     let mut streams = Vec::from_fn(sizes.len(), |_| Some(channel::<String>()));\n     let mut from_child = Vec::new();\n-    let to_child  = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n+    let to_child  = sizes.iter().zip(streams.iter_mut()).map(|(sz, stream_ref)| {\n         let sz = *sz;\n         let stream = replace(stream_ref, None);\n         let (to_parent_, from_child_) = stream.unwrap();"}, {"sha": "cecc95354afefece8445db9bfd3940562acc58c4", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -283,7 +283,7 @@ fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n     {\n         res.push_all(l.as_slice().trim().as_bytes());\n     }\n-    for b in res.mut_iter() {\n+    for b in res.iter_mut() {\n         *b = b.to_ascii().to_upper().to_byte();\n     }\n     res\n@@ -307,10 +307,10 @@ fn main() {\n         Future::spawn(proc() generate_frequencies(input.as_slice(), occ.len()))\n     }).collect();\n \n-    for (i, freq) in nb_freqs.move_iter() {\n+    for (i, freq) in nb_freqs.into_iter() {\n         print_frequencies(&freq.unwrap(), i);\n     }\n-    for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.move_iter()) {\n+    for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {\n         print_occurrences(&mut freq.unwrap(), occ);\n     }\n }"}, {"sha": "28db9ed14a77bf9db64a55cbc561d56f208be894", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -107,7 +107,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n         })\n     });\n \n-    for res in precalc_futures.move_iter() {\n+    for res in precalc_futures.into_iter() {\n         let (rs, is) = res.unwrap();\n         precalc_r.push_all_move(rs);\n         precalc_i.push_all_move(is);\n@@ -135,7 +135,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n     });\n \n     try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n-    for res in data.move_iter() {\n+    for res in data.into_iter() {\n         try!(out.write(res.unwrap().as_slice()));\n     }\n     out.flush()"}, {"sha": "9542a9a55ee5aa34408a2c6e6b4043d68b2c8d5d", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -114,9 +114,9 @@ fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n         }).collect();\n \n     // translating to (0, 0) as minimum coordinates.\n-    for cur_piece in res.mut_iter() {\n+    for cur_piece in res.iter_mut() {\n         let (dy, dx) = *cur_piece.iter().min_by(|e| *e).unwrap();\n-        for &(ref mut y, ref mut x) in cur_piece.mut_iter() {\n+        for &(ref mut y, ref mut x) in cur_piece.iter_mut() {\n             *y -= dy; *x -= dx;\n         }\n     }\n@@ -163,7 +163,7 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n     // transformation must be taken except for one piece (piece 3\n     // here).\n     let transforms: Vec<Vec<Vec<(int, int)>>> =\n-        pieces.move_iter().enumerate()\n+        pieces.into_iter().enumerate()\n         .map(|(id, p)| transform(p, id != 3))\n         .collect();\n "}, {"sha": "6a39d2fdbb1a3f8be6b6e28b28fdb3fd9a719078", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -106,7 +106,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: int) {\n                 Some(bi) => bi,\n                 None => break\n             };\n-            for bj in b_slice.mut_iter() {\n+            for bj in b_slice.iter_mut() {\n                 let dx = bi.x - bj.x;\n                 let dy = bi.y - bj.y;\n                 let dz = bi.z - bj.z;"}, {"sha": "516bd99ab550a645664fa54d45d89a8897a6bd56", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -82,7 +82,7 @@ fn stress(num_tasks: int) {\n             stress_task(i);\n         }));\n     }\n-    for r in results.move_iter() {\n+    for r in results.into_iter() {\n         r.unwrap();\n     }\n }\n@@ -94,7 +94,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n-        args.move_iter().map(|x| x.to_string()).collect()\n+        args.into_iter().map(|x| x.to_string()).collect()\n     };\n \n     let opts = parse_opts(args.clone());"}, {"sha": "0adb80c2689ba64a360700768729bb8738bfdbf6", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -87,7 +87,7 @@ fn main() {\n             (regex!(\"Y\"), \"(c|t)\"),\n         ];\n         let mut seq = seq;\n-        for (re, replacement) in substs.move_iter() {\n+        for (re, replacement) in substs.into_iter() {\n             seq = re.replace_all(seq.as_slice(), NoExpand(replacement));\n         }\n         seq.len()\n@@ -105,7 +105,7 @@ fn main() {\n         regex!(\"agggtaa[cgt]|[acg]ttaccct\"),\n     ];\n     let (mut variant_strs, mut counts) = (vec!(), vec!());\n-    for variant in variants.move_iter() {\n+    for variant in variants.into_iter() {\n         let seq_arc_copy = seq_arc.clone();\n         variant_strs.push(variant.to_string());\n         counts.push(Future::spawn(proc() {"}, {"sha": "e522bcaf4db7b6e286cdc7d1c925d1fbdfc78ef2", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -54,7 +54,7 @@ fn make_complements() -> [u8, ..256] {\n         ('H', 'D'), ('D', 'H'), ('B', 'V'), ('N', 'N'),\n         ('\\n', '\\n')];\n     let mut complements: [u8, ..256] = [0, ..256];\n-    for (i, c) in complements.mut_iter().enumerate() {\n+    for (i, c) in complements.iter_mut().enumerate() {\n         *c = i as u8;\n     }\n     let lower = 'A' as u8 - 'a' as u8;\n@@ -74,14 +74,14 @@ fn main() {\n     };\n     let mut data = data.unwrap();\n \n-    for seq in data.as_mut_slice().mut_split(|c| *c == '>' as u8) {\n+    for seq in data.as_mut_slice().split_mut(|c| *c == '>' as u8) {\n         // skip header and last \\n\n         let begin = match seq.iter().position(|c| *c == '\\n' as u8) {\n             None => continue,\n             Some(c) => c\n         };\n         let len = seq.len();\n-        let seq = seq.mut_slice(begin + 1, len - 1);\n+        let seq = seq.slice_mut(begin + 1, len - 1);\n \n         // arrange line breaks\n         let len = seq.len();\n@@ -94,9 +94,9 @@ fn main() {\n         }\n \n         // reverse complement, as\n-        //    seq.reverse(); for c in seq.mut_iter() {*c = complements[*c]}\n+        //    seq.reverse(); for c in seq.iter_mut() {*c = complements[*c]}\n         // but faster:\n-        let mut it = seq.mut_iter();\n+        let mut it = seq.iter_mut();\n         loop {\n             match (it.next(), it.next_back()) {\n                 (Some(front), Some(back)) => {"}, {"sha": "ba1bce2f834f9aabc828c20a2873c39649621945", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"50\".to_string())\n     } else {\n-        args.move_iter().collect()\n+        args.into_iter().collect()\n     };\n     let max = from_str::<uint>(args.get(1).as_slice()).unwrap();\n     let rep = from_str::<uint>(args.get(2).as_slice()).unwrap();"}, {"sha": "17e1ad423f9cc6d96aa208bf2953cd661acad825", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -45,7 +45,7 @@ fn main() {\n     } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"100\".to_string())\n     } else {\n-        args.clone().move_iter().collect()\n+        args.clone().into_iter().collect()\n     };\n \n     let (tx, rx) = channel();"}, {"sha": "0f903be39223d7fae5c92621f581e81e72579ab6", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -28,20 +28,20 @@ fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n     });\n \n     let child_start_chans: Vec<Sender<Sender<int>>> =\n-        wait_ports.move_iter().map(|port| port.recv()).collect();\n+        wait_ports.into_iter().map(|port| port.recv()).collect();\n \n     let (start_port, start_chan) = stream::<Sender<int>>();\n     parent_wait_chan.send(start_chan);\n     let parent_result_chan: Sender<int> = start_port.recv();\n \n     let child_sum_ports: Vec<Reciever<int>> =\n-        child_start_chans.move_iter().map(|child_start_chan| {\n+        child_start_chans.into_iter().map(|child_start_chan| {\n             let (child_sum_port, child_sum_chan) = stream::<int>();\n             child_start_chan.send(child_sum_chan);\n             child_sum_port\n     }).collect();\n \n-    let sum = child_sum_ports.move_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n+    let sum = child_sum_ports.into_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n \n     parent_result_chan.send(sum + 1);\n }"}, {"sha": "a871ac989f3fa78584d81a14e802e35d182698a5", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10\".to_string())\n     } else {\n-        args.move_iter().collect()\n+        args.into_iter().collect()\n     };\n     let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n     let mut i = 0u;"}, {"sha": "a6723a04611af3ed0ef87d9092bfc8507b0e2257", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -11,6 +11,6 @@\n use std::rc::Rc;\n \n pub fn main() {\n-    let _x = Rc::new(vec!(1i, 2)).move_iter();\n+    let _x = Rc::new(vec!(1i, 2)).into_iter();\n     //~^ ERROR cannot move out of dereference of `&`-pointer\n }"}, {"sha": "6214466cd49e71a0d3de43f10c7a8f4afaa9730d", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -19,7 +19,7 @@ fn touch<A>(_a: &A) {}\n \n fn f20() {\n     let x = vec!(\"hi\".to_string());\n-    consume(x.move_iter().next().unwrap());\n+    consume(x.into_iter().next().unwrap());\n     touch(x.get(0)); //~ ERROR use of moved value: `x`\n }\n "}, {"sha": "330fd9f1ff0a27097744b7587400953bcbded008", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -83,13 +83,13 @@ fn f80() {\n \n fn f100() {\n     let x = vec!(\"hi\".to_string());\n-    let _y = x.move_iter().next().unwrap();\n+    let _y = x.into_iter().next().unwrap();\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n     let x = vec!(\"hi\".to_string());\n-    let _y = [x.move_iter().next().unwrap(), ..1];\n+    let _y = [x.into_iter().next().unwrap(), ..1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n "}, {"sha": "0e8c2f38afbedf789fcf34af9430df73e39f898c", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x = INIT_ATOMIC_UINT; //~ ERROR cannot move out of static item\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x: AtomicPtr<uint> = AtomicPtr::new(ptr::mut_null());\n+    let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicOption<uint> = AtomicOption::empty();\n     let x = *&x; //~ ERROR: cannot move out of dereference"}, {"sha": "c03956c42cb3024c60f4f6f9dcfbcabd5cbdc948", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let mut xs: Vec<int> = vec!();\n \n-    for x in xs.mut_iter() {\n+    for x in xs.iter_mut() {\n         xs.push(1i) //~ ERROR cannot borrow `xs`\n     }\n }"}, {"sha": "2ea9ff7a2dd727ca65b3c275d253827dc155a78a", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -269,9 +269,9 @@ fn main() {\n     let mut_ref2 = (&mut mut_generic_struct, 0i32);\n \n     // Raw Pointers\n-    let mut_ptr1: (*mut Struct1, int) = (ptr::mut_null(), 0);\n-    let mut_ptr2: (*mut int, int) = (ptr::mut_null(), 0);\n-    let mut_ptr3: (*mut Mod1::Mod2::Enum3<Struct1>, int) = (ptr::mut_null(), 0);\n+    let mut_ptr1: (*mut Struct1, int) = (ptr::null_mut(), 0);\n+    let mut_ptr2: (*mut int, int) = (ptr::null_mut(), 0);\n+    let mut_ptr3: (*mut Mod1::Mod2::Enum3<Struct1>, int) = (ptr::null_mut(), 0);\n \n     let const_ptr1: (*const Struct1, int) = (ptr::null(), 0);\n     let const_ptr2: (*const int, int) = (ptr::null(), 0);"}, {"sha": "f5766ae1e53c291251d821a870f02038f99f90bf", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn f<T>(x: Vec<T>) -> T { return x.move_iter().next().unwrap(); }\n+fn f<T>(x: Vec<T>) -> T { return x.into_iter().next().unwrap(); }\n \n fn g(act: |Vec<int> | -> int) -> int { return act(vec!(1, 2, 3)); }\n "}, {"sha": "86cac14b4439defecd05882b8069af8ab9e760f9", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -23,7 +23,7 @@ static mut closures: &'static mut [S<'static>] = &mut [S(f), S(f)];\n pub fn main() {\n     unsafe {\n         for &bare_fn in bare_fns.iter() { bare_fn() }\n-        for closure in closures.mut_iter() {\n+        for closure in closures.iter_mut() {\n             let S(ref mut closure) = *closure;\n             (*closure)()\n         }"}, {"sha": "19af9fd7ea7b41ea88fafc26ba1c96d5c9497c6c", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -109,4 +109,4 @@ pub fn main() {\n         let len = (&*c).f.len();\n         assert!(len == 3);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5401d6a6fdcedb4fc3cb07d30335b87da3ce53b6", "filename": "src/test/run-pass/issue-16151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16151.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     {\n         let mut fragments = vec![Fragment, Fragment, Fragment];\n         let _new_fragments: Vec<Fragment> = mem::replace(&mut fragments, vec![])\n-            .move_iter()\n+            .into_iter()\n             .skip_while(|_fragment| {\n                 true\n             }).collect();"}, {"sha": "ef0bc75c32661551ccf1b3235d29860c825d72fd", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -16,7 +16,7 @@ fn test1() {\n \n fn test2() {\n     let mut ints = [0i, ..32];\n-    for i in ints.mut_iter() { *i += 22; }\n+    for i in ints.iter_mut() { *i += 22; }\n     for i in ints.iter() { assert!(*i == 22); }\n }\n "}, {"sha": "437f35d182bb3373dcffa441fa00f2a3cfacc63c", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -19,7 +19,7 @@ fn myvec_deref<X:Clone>(mv: myvec<X>) -> Vec<X> {\n \n fn myvec_elt<X>(mv: myvec<X>) -> X {\n     let myvec(v) = mv;\n-    return v.move_iter().next().unwrap();\n+    return v.into_iter().next().unwrap();\n }\n \n pub fn main() {"}, {"sha": "fa38d647c7c9460b17f4c1960adbc78ea30fbd0f", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -26,7 +26,7 @@ fn main() {\n \n unsafe fn test_triangle() -> bool {\n     static COUNT : uint = 16;\n-    let mut ascend = Vec::from_elem(COUNT, ptr::mut_null());\n+    let mut ascend = Vec::from_elem(COUNT, ptr::null_mut());\n     let ascend = ascend.as_mut_slice();\n     static ALIGN : uint = 1;\n "}, {"sha": "5de34dc2df5dfda40f0791fd26924b1076ef8f43", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -141,7 +141,7 @@ pub fn main() {\n         println!(\"type: {}\", (*s).clone());\n     }\n \n-    let vec_types: Vec<String> = v.types.clone().move_iter().collect();\n+    let vec_types: Vec<String> = v.types.clone().into_iter().collect();\n     assert_eq!(vec_types, vec!(\"bool\".to_string(), \"int\".to_string(),\n                                \"i8\".to_string(), \"i16\".to_string()));\n }"}, {"sha": "c6b872efa030c9f2c9004586c13abfcc2f630b6b", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -61,7 +61,7 @@ pub fn main() {\n     assert_eq!(map.find(&Owned(\"def\".to_string())), Some(&d));\n \n     assert!(map.pop(&Slice(\"foo\")).is_some());\n-    assert_eq!(map.move_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n+    assert_eq!(map.into_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n                               .collect::<Vec<String>>()\n                               .concat(),\n                \"abc50bcd51cde52def53\".to_string());"}, {"sha": "eb0449efa6a28a6ef71b129178c7f2bfb6e52dcf", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -62,7 +62,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for r in results.mut_iter() { r.get_ref(); }\n+    for r in results.iter_mut() { r.get_ref(); }\n \n     println!(\"Completed: Final number is: \");\n     println!(\"{:?}\", sum);"}, {"sha": "40c77850adc5ac5b1b831d15d89723e39243e89b", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc525eeb4ec3443d29bce677f589b19f31c189bb/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=fc525eeb4ec3443d29bce677f589b19f31c189bb", "patch": "@@ -78,11 +78,11 @@ fn reflect() {\n fn sub_expr() {\n     // Test for a &[T] => &&[T] coercion in sub-expression position\n     // (surpisingly, this can cause errors which are not caused by either of:\n-    //    `let x = vec.mut_slice(0, 2);`\n-    //    `foo(vec.mut_slice(0, 2));` ).\n+    //    `let x = vec.slice_mut(0, 2);`\n+    //    `foo(vec.slice_mut(0, 2));` ).\n     let mut vec: Vec<int> = vec!(1, 2, 3, 4);\n     let b: &mut [int] = [1, 2];\n-    assert!(vec.mut_slice(0, 2) == b);\n+    assert!(vec.slice_mut(0, 2) == b);\n }\n \n fn index() {"}]}