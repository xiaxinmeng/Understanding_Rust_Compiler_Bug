{"sha": "53d5261c696bac17cecfb029f8578ce41d66ef13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDUyNjFjNjk2YmFjMTdjZWNmYjAyOWY4NTc4Y2U0MWQ2NmVmMTM=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-17T09:14:28Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-18T08:36:21Z"}, "message": "Move unsafe code of slice `new` function of their Iterator structs\n\nInit false state in Split* constructors", "tree": {"sha": "cf67cf3741b1d43aa8fa0533b35904ea1dd330f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf67cf3741b1d43aa8fa0533b35904ea1dd330f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d5261c696bac17cecfb029f8578ce41d66ef13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d5261c696bac17cecfb029f8578ce41d66ef13", "html_url": "https://github.com/rust-lang/rust/commit/53d5261c696bac17cecfb029f8578ce41d66ef13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d5261c696bac17cecfb029f8578ce41d66ef13/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "html_url": "https://github.com/rust-lang/rust/commit/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e"}], "stats": {"total": 263, "additions": 122, "deletions": 141}, "files": [{"sha": "8c322c202783d97bfa694ed9ef92f969e6ffce9f", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 106, "deletions": 42, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/53d5261c696bac17cecfb029f8578ce41d66ef13/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d5261c696bac17cecfb029f8578ce41d66ef13/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=53d5261c696bac17cecfb029f8578ce41d66ef13", "patch": "@@ -82,8 +82,20 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n-    pub(super) fn new(ptr: NonNull<T>, end: *const T) -> Self {\n-        Self { ptr, end, _marker: PhantomData }\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let ptr = slice.as_ptr();\n+        // SAFETY: Similar to `IterMut::new`.\n+        unsafe {\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *const u8).wrapping_add(slice.len()) as *const T\n+            } else {\n+                ptr.add(slice.len())\n+            };\n+\n+            Self { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: PhantomData }\n+        }\n     }\n \n     /// Views the underlying data as a subslice of the original data.\n@@ -188,8 +200,35 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n-    pub(super) fn new(ptr: NonNull<T>, end: *mut T) -> Self {\n-        Self { ptr, end, _marker: PhantomData }\n+    pub(super) fn new(slice: &'a mut [T]) -> Self {\n+        let ptr = slice.as_mut_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `slice.as_ptr()` where `slice` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `slice.len()` to the starting pointer gives a pointer\n+        // at the end of `slice`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n+        unsafe {\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *mut u8).wrapping_add(slice.len()) as *mut T\n+            } else {\n+                ptr.add(slice.len())\n+            };\n+\n+            Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }\n+        }\n     }\n \n     /// Views the underlying data as a subslice of the original data.\n@@ -291,8 +330,8 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> Split<'a, T, P> {\n-    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n-        Self { v: slice, pred, finished }\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n     }\n }\n \n@@ -405,8 +444,9 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusive<'a, T, P> {\n-    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n-        Self { v: slice, pred, finished }\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n     }\n }\n \n@@ -509,8 +549,9 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitMut<'a, T, P> {\n-    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n-        Self { v: slice, pred, finished }\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n     }\n }\n \n@@ -630,8 +671,9 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusiveMut<'a, T, P> {\n-    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n-        Self { v: slice, pred, finished }\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n     }\n }\n \n@@ -742,8 +784,9 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplit<'a, T, P> {\n-    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n-        Self { inner: Split::new(slice, pred, finished) }\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { inner: Split::new(slice, pred) }\n     }\n }\n \n@@ -819,8 +862,9 @@ where\n }\n \n impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitMut<'a, T, P> {\n-    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n-        Self { inner: SplitMut::new(slice, pred, finished) }\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { inner: SplitMut::new(slice, pred) }\n     }\n }\n \n@@ -1516,13 +1560,15 @@ pub struct ChunksExact<'a, T: 'a> {\n     chunk_size: usize,\n }\n \n-impl<'a, T: 'a> ChunksExact<'a, T> {\n-    pub(super) fn new(slice: &'a [T], rem: &'a [T], size: usize) -> Self {\n-        Self { v: slice, rem, chunk_size: size }\n+impl<'a, T> ChunksExact<'a, T> {\n+    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        let fst_len = slice.len() - rem;\n+        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };\n+        Self { v: fst, rem: snd, chunk_size }\n     }\n-}\n \n-impl<'a, T> ChunksExact<'a, T> {\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -1662,13 +1708,15 @@ pub struct ChunksExactMut<'a, T: 'a> {\n     chunk_size: usize,\n }\n \n-impl<'a, T: 'a> ChunksExactMut<'a, T> {\n-    pub(super) fn new(slice: &'a mut [T], rem: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, rem, chunk_size: size }\n+impl<'a, T> ChunksExactMut<'a, T> {\n+    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        let fst_len = slice.len() - rem;\n+        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n+        Self { v: fst, rem: snd, chunk_size }\n     }\n-}\n \n-impl<'a, T> ChunksExactMut<'a, T> {\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -1801,8 +1849,9 @@ pub struct ArrayWindows<'a, T: 'a, const N: usize> {\n }\n \n impl<'a, T: 'a, const N: usize> ArrayWindows<'a, T, N> {\n-    pub(super) fn new(head: *const T, num: usize) -> Self {\n-        Self { slice_head: head, num, marker: PhantomData }\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let num_windows = slice.len().saturating_sub(N - 1);\n+        Self { slice_head: slice.as_ptr(), num: num_windows, marker: PhantomData }\n     }\n }\n \n@@ -1910,13 +1959,17 @@ pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n     rem: &'a [T],\n }\n \n-impl<'a, T: 'a, const N: usize> ArrayChunks<'a, T, N> {\n-    pub(super) fn new(iter: Iter<'a, [T; N]>, rem: &'a [T]) -> Self {\n-        Self { iter, rem }\n+impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let len = slice.len() / N;\n+        let (fst, snd) = slice.split_at(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n+\n+        Self { iter: array_slice.iter(), rem: snd }\n     }\n-}\n \n-impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n@@ -2023,13 +2076,18 @@ pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n     rem: &'a mut [T],\n }\n \n-impl<'a, T: 'a, const N: usize> ArrayChunksMut<'a, T, N> {\n-    pub(super) fn new(iter: IterMut<'a, [T; N]>, rem: &'a mut [T]) -> Self {\n-        Self { iter, rem }\n+impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n+    pub(super) fn new(slice: &'a mut [T]) -> Self {\n+        let len = slice.len() / N;\n+        let (fst, snd) = slice.split_at_mut(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        unsafe {\n+            let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n+            Self { iter: array_slice.iter_mut(), rem: snd }\n+        }\n     }\n-}\n \n-impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n@@ -2440,8 +2498,11 @@ pub struct RChunksExact<'a, T: 'a> {\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n-    pub(super) fn new(slice: &'a [T], rem: &'a [T], size: usize) -> Self {\n-        Self { v: slice, rem, chunk_size: size }\n+    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        // SAFETY: 0 <= rem <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_unchecked(rem) };\n+        Self { v: snd, rem: fst, chunk_size }\n     }\n \n     /// Returns the remainder of the original slice that is not going to be\n@@ -2589,8 +2650,11 @@ pub struct RChunksExactMut<'a, T: 'a> {\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n-    pub(super) fn new(slice: &'a mut [T], rem: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, rem, chunk_size: size }\n+    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        // SAFETY: 0 <= rem <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(rem) };\n+        Self { v: snd, rem: fst, chunk_size }\n     }\n \n     /// Returns the remainder of the original slice that is not going to be"}, {"sha": "fd98f60c3ddc6348cd0abfecb2047f7900043feb", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 99, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/53d5261c696bac17cecfb029f8578ce41d66ef13/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d5261c696bac17cecfb029f8578ce41d66ef13/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=53d5261c696bac17cecfb029f8578ce41d66ef13", "patch": "@@ -9,13 +9,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics::assume;\n use crate::marker::Copy;\n use crate::mem;\n use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n-use crate::ptr::{self, NonNull};\n+use crate::ptr;\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n \n@@ -679,34 +678,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        let ptr = self.as_ptr();\n-        // SAFETY: There are several things here:\n-        //\n-        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n-        // reference thus it is non-NUL and safe to use and pass to\n-        // `NonNull::new_unchecked` .\n-        //\n-        // Adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`. `end` will never be dereferenced, only checked\n-        // for direct pointer equality with `ptr` to check if the iterator is\n-        // done.\n-        //\n-        // In the case of a ZST, the end pointer is just the start pointer plus\n-        // the length, to also allows for the fast `ptr == end` check.\n-        //\n-        // See the `next_unchecked!` and `is_empty!` macros as well as the\n-        // `post_inc_start` method for more informations.\n-        unsafe {\n-            assume(!ptr.is_null());\n-\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *const u8).wrapping_add(self.len()) as *const T\n-            } else {\n-                ptr.add(self.len())\n-            };\n-\n-            Iter::new(NonNull::new_unchecked(ptr as *mut T), end)\n-        }\n+        Iter::new(self)\n     }\n \n     /// Returns an iterator that allows modifying each value.\n@@ -723,34 +695,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        let ptr = self.as_mut_ptr();\n-        // SAFETY: There are several things here:\n-        //\n-        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n-        // reference thus it is non-NUL and safe to use and pass to\n-        // `NonNull::new_unchecked` .\n-        //\n-        // Adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`. `end` will never be dereferenced, only checked\n-        // for direct pointer equality with `ptr` to check if the iterator is\n-        // done.\n-        //\n-        // In the case of a ZST, the end pointer is just the start pointer plus\n-        // the length, to also allows for the fast `ptr == end` check.\n-        //\n-        // See the `next_unchecked!` and `is_empty!` macros as well as the\n-        // `post_inc_start` method for more informations.\n-        unsafe {\n-            assume(!ptr.is_null());\n-\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *mut u8).wrapping_add(self.len()) as *mut T\n-            } else {\n-                ptr.add(self.len())\n-            };\n-\n-            IterMut::new(NonNull::new_unchecked(ptr), end)\n-        }\n+        IterMut::new(self)\n     }\n \n     /// Returns an iterator over all contiguous windows of length\n@@ -892,11 +837,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        let rem = self.len() % chunk_size;\n-        let fst_len = self.len() - rem;\n-        // SAFETY: 0 <= fst_len <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_unchecked(fst_len) };\n-        ChunksExact::new(fst, snd, chunk_size)\n+        ChunksExact::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -938,11 +879,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        let rem = self.len() % chunk_size;\n-        let fst_len = self.len() - rem;\n-        // SAFETY: 0 <= fst_len <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_mut_unchecked(fst_len) };\n-        ChunksExactMut::new(fst, snd, chunk_size)\n+        ChunksExactMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -976,12 +913,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n         assert_ne!(N, 0);\n-        let len = self.len() / N;\n-        let (fst, snd) = self.split_at(len * N);\n-        // SAFETY: We cast a slice of `len * N` elements into\n-        // a slice of `len` many `N` elements chunks.\n-        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n-        ArrayChunks::new(array_slice.iter(), snd)\n+        ArrayChunks::new(self)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -1017,14 +949,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n         assert_ne!(N, 0);\n-        let len = self.len() / N;\n-        let (fst, snd) = self.split_at_mut(len * N);\n-        // SAFETY: We cast a slice of `len * N` elements into\n-        // a slice of `len` many `N` elements chunks.\n-        unsafe {\n-            let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n-            ArrayChunksMut::new(array_slice.iter_mut(), snd)\n-        }\n+        ArrayChunksMut::new(self)\n     }\n \n     /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n@@ -1056,9 +981,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_windows<const N: usize>(&self) -> ArrayWindows<'_, T, N> {\n         assert_ne!(N, 0);\n-\n-        let num_windows = self.len().saturating_sub(N - 1);\n-        ArrayWindows::new(self.as_ptr(), num_windows)\n+        ArrayWindows::new(self)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1169,10 +1092,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n         assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        // SAFETY: 0 <= rem <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_unchecked(rem) };\n-        RChunksExact::new(snd, fst, chunk_size)\n+        RChunksExact::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1215,10 +1135,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n         assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        // SAFETY: 0 <= rem <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_mut_unchecked(rem) };\n-        RChunksExactMut::new(snd, fst, chunk_size)\n+        RChunksExactMut::new(self, chunk_size)\n     }\n \n     /// Divides one slice into two at an index.\n@@ -1437,7 +1354,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        Split::new(self, pred, false)\n+        Split::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1459,7 +1376,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitMut::new(self, pred, false)\n+        SplitMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1497,7 +1414,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusive::new(self, pred, false)\n+        SplitInclusive::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1522,7 +1439,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusiveMut::new(self, pred, false)\n+        SplitInclusiveMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1558,7 +1475,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplit::new(self, pred, false)\n+        RSplit::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1584,7 +1501,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitMut::new(self, pred, false)\n+        RSplitMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match"}]}