{"sha": "e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1M2FhZTQ3NzI0ZmI2Y2I1Y2QxMTA2YzFlZGFmZWVlNWI0Zjk2YTA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-21T19:41:32Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-24T15:21:39Z"}, "message": "Cleaned, documented, wrote tests for up std::bool\nRemoved unused import warning in std::mem and cleaned it up too\n\nRemoved is_true and is_false from std::bool\n\nRemoved freestanding functions in std::bool", "tree": {"sha": "f747f4a6141f3b05ada261ec9cea755492e111a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f747f4a6141f3b05ada261ec9cea755492e111a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "html_url": "https://github.com/rust-lang/rust/commit/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7075eb36254e673fad1055148ee1a02447371215", "url": "https://api.github.com/repos/rust-lang/rust/commits/7075eb36254e673fad1055148ee1a02447371215", "html_url": "https://github.com/rust-lang/rust/commit/7075eb36254e673fad1055148ee1a02447371215"}], "stats": {"total": 649, "additions": 347, "deletions": 302}, "files": [{"sha": "2eec6ff4cba43cb143aab179542d2b80c19ff478", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 321, "deletions": 269, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,193 +8,169 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n+//! The `bool` module contains useful code to help work with boolean values.\n+//!\n+//! A quick summary:\n+//!\n+//! ## Trait implementations for `bool`\n+//!\n+//! Implementations of the following traits:\n+//!\n+//! * `FromStr`\n+//! * `ToStr`\n+//! * `Not`\n+//! * `Ord`\n+//! * `TotalOrd`\n+//! * `Eq`\n+//! * `Default`\n+//! * `Zero`\n+//!\n+//! ## Various functions to compare `bool`s\n+//!\n+//! All of the standard comparison functions one would expect: `and`, `eq`, `or`,\n+//! and more.\n+//!\n+//! Also, a few conversion functions: `to_bit` and `to_str`.\n \n-The `bool` module contains useful code to help work with boolean values.\n-\n-A quick summary:\n-\n-## Trait implementations for `bool`\n+use option::{None, Option, Some};\n+use from_str::FromStr;\n+use to_str::ToStr;\n+use num::FromPrimitive;\n \n-Implementations of the following traits:\n+#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n+#[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))] use default::Default;\n+#[cfg(not(test))] use num::Zero;\n \n-* `FromStr`\n-* `ToStr`\n-* `Not`\n-* `Ord`\n-* `TotalOrd`\n-* `Eq`\n-* `Default`\n-* `Zero`\n+/////////////////////////////////////////////////////////////////////////////\n+// Freestanding functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Iterates over all truth values, passing them to the given block.\n+///\n+/// There are no guarantees about the order values will be given.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// do std::bool::all_values |x: bool| {\n+///     println(x.to_str());\n+/// }\n+/// ```\n+#[inline]\n+pub fn all_values(blk: &fn(v: bool)) {\n+    blk(true);\n+    blk(false);\n+}\n \n-## Various functions to compare `bool`s\n+/////////////////////////////////////////////////////////////////////////////\n+// Methods on `bool`\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Extension methods on a `bool`\n+pub trait Bool {\n+    /// Conjunction of two boolean values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.and(true), true);\n+    /// assert_eq!(true.and(false), false);\n+    /// assert_eq!(false.and(true), false);\n+    /// assert_eq!(false.and(false), false);\n+    /// ```\n+    fn and(self, b: bool) -> bool;\n+\n+    /// Disjunction of two boolean values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.or(true), true);\n+    /// assert_eq!(true.or(false), true);\n+    /// assert_eq!(false.or(true), true);\n+    /// assert_eq!(false.or(false), false);\n+    /// ```\n+    fn or(self, b: bool) -> bool;\n+\n+    /// An 'exclusive or' of two boolean values.\n+    ///\n+    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.xor(true), false);\n+    /// assert_eq!(true.xor(false), true);\n+    /// assert_eq!(false.xor(true), true);\n+    /// assert_eq!(false.xor(false), false);\n+    /// ```\n+    fn xor(self, b: bool) -> bool;\n+\n+    /// Implication between two boolean values.\n+    ///\n+    /// Implication is often phrased as 'if a then b.'\n+    ///\n+    /// 'if a then b' is equivalent to `!a || b`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.implies(true), true);\n+    /// assert_eq!(true.implies(false), false);\n+    /// assert_eq!(false.implies(true), true);\n+    /// assert_eq!(false.implies(false), true);\n+    /// ```\n+    fn implies(self, b: bool) -> bool;\n+\n+    /// Convert a `bool` to a `u8`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.to_bit::<u8>(), 1u8);\n+    /// assert_eq!(false.to_bit::<u8>(), 0u8);\n+    /// ```\n+    fn to_bit<N: FromPrimitive>(self) -> N;\n+}\n \n-All of the standard comparison functions one would expect: `and`, `eq`, `or`,\n-and more.\n+impl Bool for bool {\n+    #[inline]\n+    fn and(self, b: bool) -> bool { self && b }\n \n-Also, a few conversion functions: `to_bit` and `to_str`.\n+    #[inline]\n+    fn or(self, b: bool) -> bool { self || b }\n \n-Finally, some inquiries into the nature of truth: `is_true` and `is_false`.\n+    #[inline]\n+    fn xor(self, b: bool) -> bool { self ^ b }\n \n-*/\n+    #[inline]\n+    fn implies(self, b: bool) -> bool { !self || b }\n \n-use option::{None, Option, Some};\n-use from_str::FromStr;\n-use to_str::ToStr;\n+    #[inline]\n+    fn to_bit<N: FromPrimitive>(self) -> N {\n+        if self { FromPrimitive::from_u8(1).unwrap() }\n+        else    { FromPrimitive::from_u8(0).unwrap() }\n+    }\n+}\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n-#[cfg(not(test))] use ops::Not;\n-#[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n+/////////////////////////////////////////////////////////////////////////////\n+// Trait impls on `bool`\n+/////////////////////////////////////////////////////////////////////////////\n \n-/**\n-* Negation of a boolean value.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::not(true)\n-* false\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::not(false)\n-* true\n-* ```\n-*/\n-pub fn not(v: bool) -> bool { !v }\n-\n-/**\n-* Conjunction of two boolean values.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::and(true, false)\n-* false\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::and(true, true)\n-* true\n-* ```\n-*/\n-pub fn and(a: bool, b: bool) -> bool { a && b }\n-\n-/**\n-* Disjunction of two boolean values.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::or(true, false)\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::or(false, false)\n-* false\n-* ```\n-*/\n-pub fn or(a: bool, b: bool) -> bool { a || b }\n-\n-/**\n-* An 'exclusive or' of two boolean values.\n-*\n-* 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::xor(true, false)\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::xor(true, true)\n-* false\n-* ```\n-*/\n-pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n-\n-/**\n-* Implication between two boolean values.\n-*\n-* Implication is often phrased as 'if a then b.'\n-*\n-* 'if a then b' is equivalent to `!a || b`.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::implies(true, true)\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::implies(true, false)\n-* false\n-* ```\n-*/\n-pub fn implies(a: bool, b: bool) -> bool { !a || b }\n-\n-/**\n-* Is a given boolean value true?\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::is_true(true)\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::is_true(false)\n-* false\n-* ```\n-*/\n-pub fn is_true(v: bool) -> bool { v }\n-\n-/**\n-* Is a given boolean value false?\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::is_false(false)\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::is_false(true)\n-* false\n-* ```\n-*/\n-pub fn is_false(v: bool) -> bool { !v }\n-\n-/**\n-* Parse a `bool` from a `str`.\n-*\n-* Yields an `Option<bool>`, because `str` may or may not actually be parseable.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> FromStr::from_str::<bool>(\"true\")\n-* Some(true)\n-* ```\n-*\n-* ```rust\n-* rusti> FromStr::from_str::<bool>(\"false\")\n-* Some(false)\n-* ```\n-*\n-* ```rust\n-* rusti> FromStr::from_str::<bool>(\"not even a boolean\")\n-* None\n-* ```\n-*/\n impl FromStr for bool {\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// ```\n+    #[inline]\n     fn from_str(s: &str) -> Option<bool> {\n         match s {\n             \"true\"  => Some(true),\n@@ -204,121 +180,124 @@ impl FromStr for bool {\n     }\n }\n \n-/**\n-* Convert a `bool` to a `str`.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> true.to_str()\n-* \"true\"\n-* ```\n-*\n-* ```rust\n-* rusti> false.to_str()\n-* \"false\"\n-* ```\n-*/\n impl ToStr for bool {\n+    /// Convert a `bool` to a string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(true.to_str(), ~\"true\");\n+    /// assert_eq!(false.to_str(), ~\"false\");\n+    /// ```\n     #[inline]\n     fn to_str(&self) -> ~str {\n         if *self { ~\"true\" } else { ~\"false\" }\n     }\n }\n \n-/**\n-* Iterates over all truth values, passing them to the given block.\n-*\n-* There are no guarantees about the order values will be given.\n-*\n-* # Examples\n-* ```\n-* do std::bool::all_values |x: bool| {\n-*     println(x.to_str())\n-* }\n-* ```\n-*/\n-pub fn all_values(blk: &fn(v: bool)) {\n-    blk(true);\n-    blk(false);\n-}\n-\n-/**\n-* Convert a `bool` to a `u8`.\n-*\n-* # Examples\n-*\n-* ```rust\n-* rusti> std::bool::to_bit(true)\n-* 1\n-* ```\n-*\n-* ```rust\n-* rusti> std::bool::to_bit(false)\n-* 0\n-* ```\n-*/\n-#[inline]\n-pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n-\n-/**\n-* The logical complement of a boolean value.\n-*\n-* # Examples\n-*\n-* ~~~rust\n-* rusti> !true\n-* false\n-* ```\n-*\n-* ~~~rust\n-* rusti> !false\n-* true\n-* ```\n-*/\n #[cfg(not(test))]\n impl Not<bool> for bool {\n+    /// The logical complement of a boolean value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(!true, false);\n+    /// assert_eq!(!false, true);\n+    /// ```\n     #[inline]\n     fn not(&self) -> bool { !*self }\n }\n \n+#[cfg(not(test))]\n+impl BitAnd<bool, bool> for bool {\n+    /// Conjunction of two boolean values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(false.bitand(&false), false);\n+    /// assert_eq!(true.bitand(&false), false);\n+    /// assert_eq!(false.bitand(&true), false);\n+    /// assert_eq!(true.bitand(&true), true);\n+    ///\n+    /// assert_eq!(false & false, false);\n+    /// assert_eq!(true & false, false);\n+    /// assert_eq!(false & true, false);\n+    /// assert_eq!(true & true, true);\n+    /// ```\n+    #[inline]\n+    fn bitand(&self, b: &bool) -> bool { *self & *b }\n+}\n+\n+#[cfg(not(test))]\n+impl BitOr<bool, bool> for bool {\n+    /// Disjunction of two boolean values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(false.bitor(&false), false);\n+    /// assert_eq!(true.bitor(&false), true);\n+    /// assert_eq!(false.bitor(&true), true);\n+    /// assert_eq!(true.bitor(&true), true);\n+    ///\n+    /// assert_eq!(false | false, false);\n+    /// assert_eq!(true | false, true);\n+    /// assert_eq!(false | true, true);\n+    /// assert_eq!(true | true, true);\n+    /// ```\n+    #[inline]\n+    fn bitor(&self, b: &bool) -> bool { *self | *b }\n+}\n+\n+#[cfg(not(test))]\n+impl BitXor<bool, bool> for bool {\n+    /// An 'exclusive or' of two boolean values.\n+    ///\n+    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(false.bitxor(&false), false);\n+    /// assert_eq!(true.bitxor(&false), true);\n+    /// assert_eq!(false.bitxor(&true), true);\n+    /// assert_eq!(true.bitxor(&true), false);\n+    ///\n+    /// assert_eq!(false ^ false, false);\n+    /// assert_eq!(true ^ false, true);\n+    /// assert_eq!(false ^ true, true);\n+    /// assert_eq!(true ^ true, false);\n+    /// ```\n+    #[inline]\n+    fn bitxor(&self, b: &bool) -> bool { *self ^ *b }\n+}\n+\n #[cfg(not(test))]\n impl Ord for bool {\n     #[inline]\n-    fn lt(&self, other: &bool) -> bool { to_bit(*self) < to_bit(*other) }\n+    fn lt(&self, other: &bool) -> bool { self.to_bit::<u8>() < other.to_bit() }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for bool {\n     #[inline]\n-    fn cmp(&self, other: &bool) -> Ordering { to_bit(*self).cmp(&to_bit(*other)) }\n+    fn cmp(&self, other: &bool) -> Ordering { self.to_bit::<u8>().cmp(&other.to_bit()) }\n }\n \n-/**\n-* Equality between two boolean values.\n-*\n-* Two booleans are equal if they have the same value.\n-*\n-* ```rust\n-* rusti> false.eq(&true)\n-* false\n-* ```\n-*\n-* ```rust\n-* rusti> false == false\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> false != true\n-* true\n-* ```\n-*\n-* ```rust\n-* rusti> false.ne(&false)\n-* false\n-* ```\n-*/\n+/// Equality between two boolean values.\n+///\n+/// Two booleans are equal if they have the same value.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// assert_eq!(false.eq(&true), false);\n+/// assert_eq!(false == false, true);\n+/// assert_eq!(false != true, true);\n+/// assert_eq!(false.ne(&false), false);\n+/// ```\n #[cfg(not(test))]\n impl Eq for bool {\n     #[inline]\n@@ -341,6 +320,77 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    #[test]\n+    fn test_bool() {\n+        assert_eq!(false.eq(&true), false);\n+        assert_eq!(false == false, true);\n+        assert_eq!(false != true, true);\n+        assert_eq!(false.ne(&false), false);\n+\n+        assert_eq!(false.bitand(&false), false);\n+        assert_eq!(true.bitand(&false), false);\n+        assert_eq!(false.bitand(&true), false);\n+        assert_eq!(true.bitand(&true), true);\n+\n+        assert_eq!(false & false, false);\n+        assert_eq!(true & false, false);\n+        assert_eq!(false & true, false);\n+        assert_eq!(true & true, true);\n+\n+        assert_eq!(false.bitor(&false), false);\n+        assert_eq!(true.bitor(&false), true);\n+        assert_eq!(false.bitor(&true), true);\n+        assert_eq!(true.bitor(&true), true);\n+\n+        assert_eq!(false | false, false);\n+        assert_eq!(true | false, true);\n+        assert_eq!(false | true, true);\n+        assert_eq!(true | true, true);\n+\n+        assert_eq!(false.bitxor(&false), false);\n+        assert_eq!(true.bitxor(&false), true);\n+        assert_eq!(false.bitxor(&true), true);\n+        assert_eq!(true.bitxor(&true), false);\n+\n+        assert_eq!(false ^ false, false);\n+        assert_eq!(true ^ false, true);\n+        assert_eq!(false ^ true, true);\n+        assert_eq!(true ^ true, false);\n+\n+        assert_eq!(!true, false);\n+        assert_eq!(!false, true);\n+\n+        assert_eq!(true.to_str(), ~\"true\");\n+        assert_eq!(false.to_str(), ~\"false\");\n+\n+        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+\n+        assert_eq!(true.and(true), true);\n+        assert_eq!(true.and(false), false);\n+        assert_eq!(false.and(true), false);\n+        assert_eq!(false.and(false), false);\n+\n+        assert_eq!(true.or(true), true);\n+        assert_eq!(true.or(false), true);\n+        assert_eq!(false.or(true), true);\n+        assert_eq!(false.or(false), false);\n+\n+        assert_eq!(true.xor(true), false);\n+        assert_eq!(true.xor(false), true);\n+        assert_eq!(false.xor(true), true);\n+        assert_eq!(false.xor(false), false);\n+\n+        assert_eq!(true.implies(true), true);\n+        assert_eq!(true.implies(false), false);\n+        assert_eq!(false.implies(true), true);\n+        assert_eq!(false.implies(false), true);\n+\n+        assert_eq!(true.to_bit::<u8>(), 1u8);\n+        assert_eq!(false.to_bit::<u8>(), 0u8);\n+    }\n+\n     #[test]\n     fn test_bool_from_str() {\n         do all_values |v| {\n@@ -357,7 +407,9 @@ mod tests {\n     #[test]\n     fn test_bool_to_bit() {\n         do all_values |v| {\n-            assert_eq!(to_bit(v), if is_true(v) { 1u8 } else { 0u8 });\n+            assert_eq!(v.to_bit::<u8>(), if v { 1u8 } else { 0u8 });\n+            assert_eq!(v.to_bit::<uint>(), if v { 1u } else { 0u });\n+            assert_eq!(v.to_bit::<int>(), if v { 1i } else { 0i });\n         }\n     }\n "}, {"sha": "c4a546f71c315e88bb9df62bdcd46224607c7e57", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "patch": "@@ -24,11 +24,9 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n \n-/**\n- * Returns the size of a type, or 1 if the actual size is zero.\n- *\n- * Useful for building structures containing variable-length arrays.\n- */\n+/// Returns the size of a type, or 1 if the actual size is zero.\n+///\n+/// Useful for building structures containing variable-length arrays.\n #[inline]\n pub fn nonzero_size_of<T>() -> uint {\n     let s = size_of::<T>();\n@@ -41,13 +39,10 @@ pub fn nonzero_size_of_val<T>(_val: &T) -> uint {\n     nonzero_size_of::<T>()\n }\n \n-\n-/**\n- * Returns the ABI-required minimum alignment of a type\n- *\n- * This is the alignment used for struct fields. It may be smaller\n- * than the preferred alignment.\n- */\n+/// Returns the ABI-required minimum alignment of a type\n+///\n+/// This is the alignment used for struct fields. It may be smaller\n+/// than the preferred alignment.\n #[inline]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n@@ -75,7 +70,6 @@ pub fn pref_align_of_val<T>(_val: &T) -> uint {\n \n #[cfg(test)]\n mod tests {\n-    use cast;\n     use mem::*;\n \n     #[test]"}, {"sha": "886ad9995a15014a1ea24ddd404587c01debd648", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53aae47724fb6cb5cd1106c1edafeee5b4f96a0/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=e53aae47724fb6cb5cd1106c1edafeee5b4f96a0", "patch": "@@ -26,7 +26,6 @@ Rust's prelude has three main parts:\n \n */\n \n-\n // Reexported core operators\n pub use either::{Either, Left, Right};\n pub use kinds::Sized;\n@@ -39,48 +38,48 @@ pub use option::{Option, Some, None};\n pub use result::{Result, Ok, Err};\n \n // Reexported functions\n-pub use rt::io::stdio::{print, println};\n-pub use iter::range;\n pub use from_str::from_str;\n+pub use iter::range;\n+pub use rt::io::stdio::{print, println};\n \n // Reexported types and traits\n+pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n+pub use bool::Bool;\n pub use c_str::ToCStr;\n+pub use char::Char;\n pub use clone::{Clone, DeepClone};\n pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n-pub use char::Char;\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n+pub use default::Default;\n+pub use from_str::FromStr;\n pub use hash::Hash;\n-pub use num::Times;\n+pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, ClonableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::Times;\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n-pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n+pub use num::{Integer, Fractional, Real, RealExt};\n+pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n-pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n-pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple};\n-pub use tuple::{Tuple1, ImmutableTuple1};\n-pub use tuple::{Tuple2, Tuple3, Tuple4, Tuple5};\n-pub use tuple::{Tuple6, Tuple7, Tuple8, Tuple9};\n-pub use tuple::{Tuple10, Tuple11, Tuple12};\n-pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n-pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n-pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n-pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n+pub use tuple::{ImmutableTuple1, ImmutableTuple2, ImmutableTuple3, ImmutableTuple4};\n+pub use tuple::{ImmutableTuple5, ImmutableTuple6, ImmutableTuple7, ImmutableTuple8};\n+pub use tuple::{ImmutableTuple9, ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n+pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n+pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n+pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n-pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n-pub use default::Default;\n+pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types\n pub use comm::{stream, Port, Chan, GenericChan, GenericSmartChan, GenericPort, Peekable};"}]}