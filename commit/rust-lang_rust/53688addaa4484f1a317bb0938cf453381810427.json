{"sha": "53688addaa4484f1a317bb0938cf453381810427", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNjg4YWRkYWE0NDg0ZjFhMzE3YmIwOTM4Y2Y0NTMzODE4MTA0Mjc=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-01-30T17:56:33Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-01T07:05:12Z"}, "message": "test cases, cleanup", "tree": {"sha": "2c025b1dc64129e4651df886918a07af9896a14f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c025b1dc64129e4651df886918a07af9896a14f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53688addaa4484f1a317bb0938cf453381810427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53688addaa4484f1a317bb0938cf453381810427", "html_url": "https://github.com/rust-lang/rust/commit/53688addaa4484f1a317bb0938cf453381810427", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53688addaa4484f1a317bb0938cf453381810427/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e343abd0ed11227425eca16e186367eced39cd82", "url": "https://api.github.com/repos/rust-lang/rust/commits/e343abd0ed11227425eca16e186367eced39cd82", "html_url": "https://github.com/rust-lang/rust/commit/e343abd0ed11227425eca16e186367eced39cd82"}], "stats": {"total": 644, "additions": 398, "deletions": 246}, "files": [{"sha": "0a2544e4e18c6a799d3d0747e54d0449cbd4d137", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -851,6 +851,9 @@ mod quux {\n \n In this example, the module `quux` re-exports all of the public names defined in `foo`.\n \n+Also note that the paths contained in `use` items are relative to the crate root; so, in the previous\n+example, the use refers to `quux::foo::*`, and not simply to `foo::*`.\n+\n ### Functions\n \n A _function item_ defines a sequence of [statements](#statements) and an optional final [expression](#expressions), along with a name and a set of parameters."}, {"sha": "7310698e88f67d20410282b2882b60e506f51418", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -346,12 +346,12 @@ pub mod test {\n     use syntax::ast_util;\n \n     pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n-        ast_util::respan(ast_util::dummy_sp(), ast::attribute_ {\n+        ast_util::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n-            value: ast_util::respan(ast_util::dummy_sp(),\n+            value: ast_util::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n                     ~\"crate_type\",\n-                    ast_util::respan(ast_util::dummy_sp(),\n+                    ast_util::respan(codemap::dummy_sp(),\n                                      ast::lit_str(@t)))),\n             is_sugared_doc: false\n         })\n@@ -361,7 +361,7 @@ pub mod test {\n         let mut attrs = ~[];\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n-        @ast_util::respan(ast_util::dummy_sp(), ast::crate_ {\n+        @ast_util::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,\n             config: ~[]"}, {"sha": "143eb556f96de36f00b8038df1e7c03a69b098e4", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -17,6 +17,7 @@ use syntax::ast;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap;\n+use syntax::codemap::dummy_sp;\n use syntax::fold;\n \n const CORE_VERSION: &static/str = \"0.6\";\n@@ -36,8 +37,8 @@ fn use_core(crate: @ast::crate) -> bool {\n \n fn inject_libcore_ref(sess: Session,\n                       crate: @ast::crate) -> @ast::crate {\n-    fn spanned<T: Copy>(x: T) -> ast::spanned<T> {\n-        ast::spanned { node: x, span: dummy_sp() }\n+    fn spanned<T: Copy>(x: T) -> codemap::spanned<T> {\n+        codemap::spanned { node: x, span: dummy_sp() }\n     }\n \n     let precursor = @fold::AstFoldFns {"}, {"sha": "c660fa3ef805332aab2a105680b1b71a305a4e62", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use driver::session::Session;\n use syntax::parse;\n use syntax::ast;\n+use syntax::codemap::spanned;\n \n use core::vec;\n \n@@ -34,7 +35,7 @@ pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     let items = vec::append(~[item], crate.node.module.items);\n \n-    @ast::spanned {\n+    @spanned {\n         node: ast::crate_ {\n             module: ast::_mod {\n                 items: items,"}, {"sha": "91eb8148bb786eed01b1a857842778ee8c975fe1", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -21,7 +21,8 @@ use core::option;\n use core::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{dummy_sp, span};\n+use syntax::codemap;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -237,8 +238,8 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     return @item;\n }\n \n-fn nospan<T: Copy>(t: T) -> ast::spanned<T> {\n-    ast::spanned { node: t, span: dummy_sp() }\n+fn nospan<T: Copy>(t: T) -> codemap::spanned<T> {\n+    codemap::spanned { node: t, span: dummy_sp() }\n }\n \n fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n@@ -535,7 +536,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let body_: ast::blk_ =\n         default_block(~[], option::Some(test_main_call_expr),\n                       cx.sess.next_node_id());\n-    let body = ast::spanned { node: body_, span: dummy_sp() };\n+    let body = codemap::spanned { node: body_, span: dummy_sp() };\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item = ast::item {"}, {"sha": "f1430441ab8d6c092f15adcfb8cbeeec2a089d1c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -24,7 +24,7 @@ use core::either;\n use core::option;\n use core::vec;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n@@ -294,7 +294,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n-            let fake_span = ast_util::dummy_sp();\n+            let fake_span = dummy_sp();\n             let local_cnum = resolve_crate(e, cname, cmetas,\n                                            /*bad*/copy dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);"}, {"sha": "1204fdf1837aba0688044374e94873ee1a899f72", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -26,7 +26,7 @@ use std::ebml;\n use std::map::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::ast_util;\n use syntax::diagnostic::expect;\n use syntax::diagnostic::span_handler;"}, {"sha": "a293fc6a13dda5e08e3016b0f114ed0405decd29", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -45,6 +45,7 @@ use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n+use syntax::codemap;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -981,13 +982,13 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n-                ast::spanned {\n+                codemap::spanned {\n                     node: ast::attribute_ {\n                         style: ast::attr_outer,\n                         value: /*bad*/copy *meta_item,\n                         is_sugared_doc: false,\n                     },\n-                    span: ast_util::dummy_sp()\n+                    span: codemap::dummy_sp()\n                 });\n         };\n       }"}, {"sha": "56df92da9872ee7f211ff7cafc7eb4e3c86ec418", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -26,8 +26,7 @@ use core::uint;\n use core::vec;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::ast_util::respan;\n+use syntax::codemap::{respan, dummy_sp};\n use std::map::HashMap;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -114,7 +113,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n-                return @ast::path { span: ast_util::dummy_sp(),\n+                return @ast::path { span: dummy_sp(),\n                                     global: false,\n                                     idents: idents,\n                                     rp: None,"}, {"sha": "8ea3d8137526cbef59ff8330fd5de844d34e4792", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -220,7 +220,7 @@ impl extended_decode_ctxt {\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(_span: span) -> span {\n-        ast_util::dummy_sp() // FIXME (#1972): handle span properly\n+        codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n \n@@ -300,9 +300,9 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                              span: _}, _) => true,\n-              ast::stmt_decl(@ast::spanned { node: ast::decl_item(_),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_),\n                                              span: _}, _) => false,\n               ast::stmt_mac(*) => die!(~\"unexpanded macro in astencode\")\n             }\n@@ -336,7 +336,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n         ast::ii_dtor(\n-            ast::spanned {\n+            codemap::spanned {\n                 node: ast::struct_dtor_ { body: dtor_body,\n                                           .. /*bad*/copy (*dtor).node },\n                 .. (/*bad*/copy *dtor) },\n@@ -377,7 +377,7 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n         ast::ii_dtor(\n-            ast::spanned {\n+            codemap::spanned {\n                 node: ast::struct_dtor_ { id: dtor_id,\n                                           attrs: dtor_attrs,\n                                           self_id: new_self,"}, {"sha": "0ed3a1a849d96199969a80362ad1ea76ee0d0c04", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -20,6 +20,7 @@ use core::dvec::DVec;\n use core::option;\n use std::map::HashMap;\n use syntax::ast::*;\n+use syntax::codemap;\n use syntax::{visit, ast_util, ast_map};\n \n pub fn check_crate(sess: Session,\n@@ -64,7 +65,10 @@ pub fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n-                @expr { node: expr_lit(@spanned { node: lit_str(_), _}), _ },\n+                @expr { node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    _}),\n+                       _ },\n                 expr_vstore_uniq\n             ) => true,\n             _ => false\n@@ -96,7 +100,7 @@ pub fn check_expr(sess: Session,\n                           ~\"disallowed operator in constant expression\");\n             return;\n           }\n-          expr_lit(@spanned {node: lit_str(_), _}) => { }\n+          expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n             if method_map.contains_key(e.id) {\n                 sess.span_err(e.span, ~\"user-defined operators are not \\\n@@ -183,15 +187,15 @@ pub fn check_expr(sess: Session,\n         }\n     }\n     match e.node {\n-      expr_lit(@spanned {node: lit_int(v, t), _}) => {\n+      expr_lit(@codemap::spanned {node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, ~\"literal out of range for its type\");\n             }\n         }\n       }\n-      expr_lit(@spanned {node: lit_uint(v, t), _}) => {\n+      expr_lit(@codemap::spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, ~\"literal out of range for its type\");"}, {"sha": "3ce1e8598263cc52a605e841502c31c06888a9b6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -26,9 +26,8 @@ use core::vec;\n use std::map::HashMap;\n use std::sort;\n use syntax::ast::*;\n-use syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat, walk_pat};\n-use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::ast_util::{variant_def_ids, unguarded_pat, walk_pat};\n+use syntax::codemap::{span, dummy_sp, spanned};\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n@@ -464,7 +463,7 @@ pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n }\n \n pub fn wild() -> @pat {\n-    @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n+    @pat {id: 0, node: pat_wild, span: dummy_sp()}\n }\n \n pub fn specialize(cx: @MatchCheckCtxt,"}, {"sha": "767985b8fa3b2127e1261489fae5267eb63224a2", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -26,7 +26,7 @@ use core::str;\n use core::vec;\n use std::map::HashMap;\n use syntax::ast::*;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, spanned};\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_util};\n "}, {"sha": "bd02c49ccba780356e60e33a470b9cc1846f9aaf", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -39,6 +39,7 @@ use std::oldsmallintmap;\n use syntax::ast_util::{path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n+use syntax::codemap;\n use syntax::print::pprust::{expr_to_str, mode_to_str, pat_to_str};\n use syntax::{ast, ast_util, visit};\n \n@@ -453,7 +454,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n                 match e.node {\n                     ast::expr_while(cond, _) => {\n                         match cond.node {\n-                            ast::expr_lit(@ast::spanned {\n+                            ast::expr_lit(@codemap::spanned {\n                                 node: ast::lit_bool(true), _}) =>\n                             {\n                                 cx.sess.span_lint("}, {"sha": "9de3dd2455b9092b78f7796092781715fd5947e8", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -14,11 +14,10 @@ use middle::resolve;\n use middle::ty;\n \n use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::ast_util::{path_to_ident, respan, walk_pat};\n+use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::fold;\n use syntax::fold::*;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, respan};\n use std::map::HashMap;\n \n pub type PatIdMap = HashMap<ident, node_id>;"}, {"sha": "c47baa8f7a4e348dda9955b3570d6f376af0924e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -58,15 +58,15 @@ use syntax::ast::{variant, view_item, view_item_import};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n use syntax::ast::{unsafe_fn};\n-use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr::{attr_metas, contains_name, attrs_contains_name};\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{pat_to_str, path_to_str};\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::visit::{default_visitor, fk_method, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};"}, {"sha": "f394c98ab6f4b83ea4e871bcd3546006cf29ec61", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -1850,7 +1850,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n             ty: varg.ty,\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n-                ast_util::dummy_sp(),\n+                codemap::dummy_sp(),\n                 special_idents::arg),\n             id: varg.id,\n         }\n@@ -1913,7 +1913,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n             is_mutbl: false,\n             ty: field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n-                                        ast_util::dummy_sp(),\n+                                        codemap::dummy_sp(),\n                                         special_idents::arg),\n             id: field.node.id\n         }\n@@ -2044,7 +2044,7 @@ pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n-                  ast::stmt_decl(@ast::spanned { node: ast::decl_item(i),\n+                  ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n                     trans_item(ccx, *i);\n                   }"}, {"sha": "1bb74f265c31b7282c19125ecedd87b03917fdb2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -142,7 +142,7 @@ use util::ppaux::ty_to_str;\n \n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n-use syntax::ast::spanned;\n+use syntax::codemap::spanned;\n \n // Destinations\n \n@@ -552,7 +552,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_tup(ref args) => {\n             return trans_tup(bcx, *args, dest);\n         }\n-        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), _}) => {\n+        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_slice) |"}, {"sha": "b6e29b0d07a1d2ffe10b1fa0e220cbdd35ca2214", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -223,7 +223,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n \n fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n     visit::visit_mod(\n-        crate_mod, ast_util::dummy_sp(), 0, cx,\n+        crate_mod, codemap::dummy_sp(), 0, cx,\n         visit::mk_vt(@visit::Visitor {\n             visit_expr: |_e, _cx, _v| { },\n             visit_item: |i, cx, v| {"}, {"sha": "6d4ca428488532d75344b47b6fef1863117feb10", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -28,7 +28,7 @@ use core::option::is_some;\n use core::vec;\n use std::map::HashMap;\n use syntax::ast;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::codemap::span;\n use syntax::util::interner;\n "}, {"sha": "e103ae1559325a0319541c19fba8f386a304ab2a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -201,7 +201,7 @@ pub fn trans_slice_vstore(bcx: block,\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), span: _}) => {\n+        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -296,7 +296,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n     match heap {\n         heap_exchange => {\n             match content_expr.node {\n-                ast::expr_lit(@ast::spanned {\n+                ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), copy *s);\n@@ -354,7 +354,7 @@ pub fn write_content(bcx: block,\n     let _indenter = indenter();\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -461,7 +461,7 @@ pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             s.len() + 1\n         },\n         ast::expr_vec(es, _) => es.len(),"}, {"sha": "e0ac6fa759444c14f71830dcedc8ec26e2c529e8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -47,6 +47,7 @@ use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n use syntax::codemap::span;\n+use syntax::codemap;\n use syntax::print::pprust;\n use syntax::{ast, ast_map};\n use syntax;\n@@ -3166,7 +3167,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_block(*) |\n         ast::expr_copy(*) |\n         ast::expr_repeat(*) |\n-        ast::expr_lit(@ast::spanned {node: lit_str(_), _}) |\n+        ast::expr_lit(@codemap::spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_fixed(_)) |"}, {"sha": "51650804c505275c617e897cfed81c88866df2f1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -108,7 +108,7 @@ use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::codemap::span;\n \n pub fn lookup("}, {"sha": "b71bee74f9c8b4f7686389514bbc203199cff00b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -117,13 +117,13 @@ use core::vec;\n use std::list::Nil;\n use std::map::HashMap;\n use std::map;\n-use syntax::ast::{provided, required, spanned, ty_i};\n+use syntax::ast::{provided, required, ty_i};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{Private, Public, is_local, local_def, respan};\n+use syntax::ast_util::{Private, Public, is_local, local_def};\n use syntax::ast_util::{visibility_to_privacy};\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, spanned, respan};\n use syntax::codemap;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n@@ -528,7 +528,7 @@ pub fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                         def_id: local_def(id),\n                         explicit_self:\n                             spanned { node: ast::sty_by_ref,\n-                                      span: ast_util::dummy_sp() } };\n+                                      span: codemap::dummy_sp() } };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n         check_bare_fn(ccx, &dtor_dec,\n@@ -1919,7 +1919,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     match /*bad*/copy expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match /*bad*/copy ev.node {\n-          ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+          ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -2608,7 +2608,7 @@ pub fn check_block_with_expected(fcx0: @fn_ctxt,\n         for blk.node.stmts.each |s| {\n             if bot && !warned &&\n                 match s.node {\n-                  ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+                  ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n                     true"}, {"sha": "8ea35824e32a1ccfb136fc747f45119057f749da", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -22,6 +22,7 @@ use util::ppaux;\n \n use std::list::Cons;\n use syntax::ast;\n+use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n@@ -57,7 +58,7 @@ pub fn replace_bound_regions_in_fn_sig(\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n     match self_info {\n-      Some({explicit_self: ast::spanned { node: ast::sty_region(m),\n+      Some({explicit_self: codemap::spanned { node: ast::sty_region(m),\n                                           _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,"}, {"sha": "5be3414f24e18029abd687106efb02cb91bbd662", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -46,9 +46,9 @@ use syntax::ast::{trait_ref};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::parse;\n use syntax::visit::{default_simple_visitor, default_visitor};\n use syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};"}, {"sha": "d6146d94951abee487557c203f55ae98228a5a23", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -286,7 +286,8 @@ use syntax::ast::{ret_style, purity};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n use syntax::ast;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n+use syntax::codemap;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n@@ -389,7 +390,7 @@ pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n+            cx.sub(true, codemap::dummy_sp()).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -429,7 +430,7 @@ pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let span = ast_util::dummy_sp();\n+            let span = codemap::dummy_sp();\n             Coerce(cx.combine_fields(true, span)).tys(a, b)\n         }\n     }.to_ures()"}, {"sha": "eab7e80b3e6b1b525f127385237f0f5844c4cc57", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -31,7 +31,7 @@ use std::getopts::{opt_present};\n use std::getopts;\n use std::getopts;\n use std::map::HashMap;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::parse::parse_crate_from_source_str;\n use syntax::{ast, attr, parse};\n "}, {"sha": "2b230a30553179b69452421b0363fd9d5cccb0dd", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -70,10 +70,10 @@ use std::list;\n use std::map::HashMap;\n use std::map;\n use std::oldsmallintmap;\n-use syntax::ast::{provided, required, spanned};\n+use syntax::ast::{provided, required};\n use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::{local_def, respan, split_trait_methods};\n-use syntax::codemap::span;\n+use syntax::ast_util::{local_def, split_trait_methods};\n+use syntax::codemap::{span, spanned, respan};\n use syntax::print::pprust::*;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};"}, {"sha": "393020b664384cea034f22d5ff15e4c87dab29b8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -10,7 +10,7 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{span, FileName};\n+use codemap::{span, FileName, spanned};\n \n use core::cast;\n use core::cmp;\n@@ -21,10 +21,6 @@ use core::to_bytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-#[auto_encode]\n-#[auto_decode]\n-pub struct spanned<T> { node: T, span: span }\n-\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key ("}, {"sha": "26c06f8e05e5701eabb785947eae49ed1bb96c8d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use ast::*;\n use ast;\n use ast_util;\n-use codemap::{span, BytePos};\n+use codemap::{span, BytePos, dummy_sp};\n use parse::token;\n use visit;\n \n@@ -24,28 +24,6 @@ use core::str;\n use core::to_bytes;\n use core::vec;\n \n-pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n-    respan(mk_sp(lo, hi), move t)\n-}\n-\n-pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n-    spanned {node: t, span: sp}\n-}\n-\n-pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n-    respan(dummy_sp(), move t)\n-}\n-\n-/* assuming that we're not in macro expansion */\n-pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n-    span {lo: lo, hi: hi, expn_info: None}\n-}\n-\n-// make this a const, once the compiler supports it\n-pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n-\n-\n-\n pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n                      -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")"}, {"sha": "30bd23d593696dcd17c53e185c65a6068df266c7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::{spanned, dummy_spanned};\n+use codemap::{spanned, dummy_spanned};\n use attr;\n use codemap::BytePos;\n use diagnostic::span_handler;"}, {"sha": "31ed65d8065882ceebeacd489c9b69922ac97129", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 102, "deletions": 28, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -23,8 +23,6 @@ source code snippets, etc.\n \n use core::prelude::*;\n \n-use ast_util;\n-\n use core::cmp;\n use core::dvec::DVec;\n use core::str;\n@@ -130,6 +128,10 @@ pub struct span {\n     expn_info: Option<@ExpnInfo>\n }\n \n+#[auto_encode]\n+#[auto_decode]\n+pub struct spanned<T> { node: T, span: span }\n+\n pub impl span : cmp::Eq {\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n@@ -144,10 +146,32 @@ pub impl<S: Encoder> span: Encodable<S> {\n \n pub impl<D: Decoder> span: Decodable<D> {\n     static fn decode(_d: &D) -> span {\n-        ast_util::dummy_sp()\n+        dummy_sp()\n     }\n }\n \n+pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+    respan(mk_sp(lo, hi), move t)\n+}\n+\n+pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+    spanned {node: t, span: sp}\n+}\n+\n+pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+    respan(dummy_sp(), move t)\n+}\n+\n+/* assuming that we're not in macro expansion */\n+pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+    span {lo: lo, hi: hi, expn_info: None}\n+}\n+\n+// make this a const, once the compiler supports it\n+pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+\n+\n+\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n@@ -158,6 +182,20 @@ pub struct Loc {\n     col: CharPos\n }\n \n+/// A source code location used as the result of lookup_char_pos_adj\n+// Actually, *none* of the clients use the filename *or* file field;\n+// perhaps they should just be removed.\n+pub struct LocWithOpt {\n+    filename: ~str,\n+    line: uint,\n+    col: CharPos,\n+    file: Option<@FileMap>,\n+}\n+\n+// used to be structural records. Better names, anyone?\n+pub struct FileMapAndLine {fm: @FileMap, line: uint}\n+pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+\n /// Extra information for tracking macro expansion of spans\n pub enum ExpnInfo {\n     ExpandedFrom({call_site: span,\n@@ -204,10 +242,19 @@ pub struct FileMap {\n }\n \n pub impl FileMap {\n+    // EFFECT: register a start-of-line offset in the\n+    // table of line-beginnings.\n+    // UNCHECKED INVARIANT: these offsets must be added in the right\n+    // order and must be in the right places; there is shared knowledge\n+    // about what ends a line between this file and parse.rs\n     fn next_line(&self, +pos: BytePos) {\n+        // the new charpos must be > the last one (or it's the first one).\n+        assert ((self.lines.len() == 0)\n+                || (self.lines[self.lines.len() - 1] < pos));\n         self.lines.push(pos);\n     }\n \n+    // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n         unsafe {\n             let begin: BytePos = self.lines[line] - self.start_pos;\n@@ -279,27 +326,25 @@ pub impl CodeMap {\n         return self.lookup_pos(pos);\n     }\n \n-    pub fn lookup_char_pos_adj(&self, +pos: BytePos)\n-        -> {filename: ~str, line: uint, col: CharPos, file: Option<@FileMap>}\n+    pub fn lookup_char_pos_adj(&self, +pos: BytePos) -> LocWithOpt\n     {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n-            FssNone => {\n-                {filename: /* FIXME (#2543) */ copy loc.file.name,\n-                 line: loc.line,\n-                 col: loc.col,\n-                 file: Some(loc.file)}\n-            }\n-            FssInternal(sp) => {\n-                self.lookup_char_pos_adj(\n-                    sp.lo + (pos - loc.file.start_pos))\n-            }\n-            FssExternal(ref eloc) => {\n-                {filename: /* FIXME (#2543) */ copy (*eloc).filename,\n-                 line: (*eloc).line + loc.line - 1u,\n-                 col: if loc.line == 1 {eloc.col + loc.col} else {loc.col},\n-                 file: None}\n-            }\n+            FssNone =>\n+            LocWithOpt {\n+                filename: /* FIXME (#2543) */ copy loc.file.name,\n+                line: loc.line,\n+                col: loc.col,\n+                file: Some(loc.file)},\n+            FssInternal(sp) =>\n+            self.lookup_char_pos_adj(\n+                sp.lo + (pos - loc.file.start_pos)),\n+            FssExternal(ref eloc) =>\n+            LocWithOpt {\n+                filename: /* FIXME (#2543) */ copy (*eloc).filename,\n+                line: (*eloc).line + loc.line - 1u,\n+                col: if loc.line == 1 {eloc.col + loc.col} else {loc.col},\n+                file: None}\n         }\n     }\n \n@@ -319,7 +364,7 @@ pub impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: span) -> ~str {\n-        if self.files.len() == 0 && sp == ast_util::dummy_sp() {\n+        if self.files.len() == 0 && sp == dummy_sp() {\n             return ~\"no-location\";\n         }\n \n@@ -383,8 +428,7 @@ priv impl CodeMap {\n         return a;\n     }\n \n-    fn lookup_line(&self, +pos: BytePos)\n-        -> {fm: @FileMap, line: uint}\n+    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine\n     {\n         let idx = self.lookup_filemap_idx(pos);\n         let f = self.files[idx];\n@@ -394,11 +438,11 @@ priv impl CodeMap {\n             let m = (a + b) / 2u;\n             if f.lines[m] > pos { b = m; } else { a = m; }\n         }\n-        return {fm: f, line: a};\n+        return FileMapAndLine {fm: f, line: a};\n     }\n \n     fn lookup_pos(&self, +pos: BytePos) -> Loc {\n-        let {fm: f, line: a} = self.lookup_line(pos);\n+        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n         let linebpos = f.lines[a];\n@@ -424,11 +468,11 @@ priv impl CodeMap {\n     }\n \n     fn lookup_byte_offset(&self, +bpos: BytePos)\n-        -> {fm: @FileMap, pos: BytePos} {\n+        -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = self.files[idx];\n         let offset = bpos - fm.start_pos;\n-        return {fm: fm, pos: offset};\n+        return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n     // Converts an absolute BytePos to a CharPos relative to the file it is\n@@ -458,6 +502,36 @@ priv impl CodeMap {\n     }\n }\n \n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::testing::check_equal;\n+\n+    #[test]\n+    fn t1 () {\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        fm.next_line(BytePos(0));\n+        check_equal(&fm.get_line(0),&~\"first line.\");\n+        // TESTING BROKEN BEHAVIOR:\n+        fm.next_line(BytePos(10));\n+        check_equal(&fm.get_line(1),&~\".\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn t2 () {\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        // TESTING *REALLY* BROKEN BEHAVIOR:\n+        fm.next_line(BytePos(0));\n+        fm.next_line(BytePos(10));\n+        fm.next_line(BytePos(2));\n+    }\n+}\n+\n+\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "4dddb66995b4a026de69a1a53a766c462777bd2e", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -311,7 +311,7 @@ priv impl ext_ctxt {\n     }\n \n     fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @ast::spanned { node: ast::stmt_semi(expr, self.next_id()),\n+        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n                        span: expr.span }\n     }\n \n@@ -322,7 +322,7 @@ priv impl ext_ctxt {\n                 self.expr(\n                     span,\n                     ast::expr_lit(\n-                        @ast::spanned { node: ast::lit_str(s),\n+                        @codemap::spanned { node: ast::lit_str(s),\n                                         span: span})),\n                 ast::expr_vstore_uniq))\n     }\n@@ -331,7 +331,7 @@ priv impl ext_ctxt {\n         self.expr(\n             span,\n             ast::expr_lit(\n-                @ast::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n+                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n                                 span: span}))\n     }\n \n@@ -342,7 +342,7 @@ priv impl ext_ctxt {\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n                 stmts: stmts,\n@@ -355,7 +355,7 @@ priv impl ext_ctxt {\n     }\n \n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n                 stmts: ~[],\n@@ -593,7 +593,7 @@ fn mk_ser_method(\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: ast::spanned { node: ast::sty_region(ast::m_imm),\n+        self_ty: codemap::spanned { node: ast::sty_region(ast::m_imm),\n                                 span: span },\n         purity: ast::impure_fn,\n         decl: ser_decl,\n@@ -651,7 +651,7 @@ fn mk_deser_method(\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: ast::spanned { node: ast::sty_static, span: span },\n+        self_ty: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,\n@@ -762,7 +762,7 @@ fn mk_struct_deser_impl(\n             ]\n         );\n \n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::field_ {\n                 mutbl: field.mutbl,\n                 ident: field.ident,"}, {"sha": "a37ce512ac1c6ba182b76af5c9ee72cdd3e7f2c0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -11,9 +11,8 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::dummy_sp;\n use codemap;\n-use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n+use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom, dummy_sp};\n use diagnostic::span_handler;\n use ext;\n use parse;"}, {"sha": "4d8fd39c9609134f97141a050f9f517b353c8198", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -32,7 +32,7 @@ pub fn mk_expr(cx: ext_ctxt,\n }\n \n pub fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-    let sp_lit = @ast::spanned { node: lit, span: sp };\n+    let sp_lit = @codemap::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n pub fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n@@ -149,7 +149,7 @@ pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n }\n pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n              -> ast::field {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n         span: sp,\n     }\n@@ -188,7 +188,7 @@ pub fn mk_global_struct_e(cx: ext_ctxt,\n pub fn mk_glob_use(cx: ext_ctxt,\n                    sp: span,\n                    path: ~[ast::ident]) -> @ast::view_item {\n-    let glob = @ast::spanned {\n+    let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n     };\n@@ -209,7 +209,7 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n         span: sp,\n     };\n     let ty = @ast::Ty { id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local = @ast::spanned {\n+    let local = @codemap::spanned {\n         node: ast::local_ {\n             is_mutbl: mutbl,\n             ty: ty,\n@@ -219,14 +219,14 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n         },\n         span: sp,\n     };\n-    let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n-    @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n+    let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n+    @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: ext_ctxt, span: span,\n                 view_items: ~[@ast::view_item],\n                 stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = ast::spanned {\n+    let blk = codemap::spanned {\n         node: ast::blk_ {\n              view_items: view_items,\n              stmts: stmts,\n@@ -242,7 +242,7 @@ pub fn mk_block_(cx: ext_ctxt,\n                  span: span,\n                  +stmts: ~[@ast::stmt])\n               -> ast::blk {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -257,7 +257,7 @@ pub fn mk_simple_block(cx: ext_ctxt,\n                        span: span,\n                        expr: @ast::expr)\n                     -> ast::blk {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n             stmts: ~[],\n@@ -307,13 +307,14 @@ pub fn mk_pat_struct(cx: ext_ctxt,\n     mk_pat(cx, span, move pat)\n }\n pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n-    let lit_expr = ast::expr_lit(@ast::spanned { node: ast::lit_bool(value),\n-                                                 span: span });\n+    let lit_expr = ast::expr_lit(@codemap::spanned {\n+        node: ast::lit_bool(value),\n+        span: span });\n     build::mk_expr(cx, span, move lit_expr)\n }\n pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @ast::spanned { node: move stmt_, span: span }\n+    @codemap::spanned { node: move stmt_, span: span }\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,"}, {"sha": "8e87357f8b5b986243334a5fbbc2295e9a8c04a0", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -18,12 +18,12 @@ use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n use ast::{enum_variant_kind, expr, expr_match, ident, item, item_};\n use ast::{item_enum, item_impl, item_struct, m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n-use ast::{re_anon, spanned, stmt, struct_def, struct_variant_kind};\n+use ast::{re_anon, stmt, struct_def, struct_variant_kind};\n use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, ty_param};\n use ast::{ty_param_bound, ty_path, ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n-use codemap::span;\n+use codemap::{span, spanned};\n use parse::token::special_idents::clownshoes_extensions;\n \n use core::dvec;"}, {"sha": "be768650ef70e0e37457140c5c2a4b831d33eb3b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -154,7 +154,7 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n                        fld: ast_fold) -> Option<@ast::item> {\n \n     let (pth, tts) = match it.node {\n-        item_mac(ast::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+        item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n             (pth, (*tts))\n         }\n         _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n@@ -234,7 +234,7 @@ pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                 {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n-                    @ast::spanned { node: stmt_expr(e, cx.next_id()),\n+                    @codemap::spanned { node: stmt_expr(e, cx.next_id()),\n                                     span: e.span},\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal("}, {"sha": "58ab05987a60099d8afa9bd4c283006431b875f9", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -17,10 +17,11 @@ use core::prelude::*;\n \n use ast::{ident, node_id};\n use ast;\n-use ast_util::{ident_to_path, respan, dummy_sp};\n+use ast_util::{ident_to_path};\n use ast_util;\n use attr;\n-use codemap::span;\n+use codemap::{span, respan, dummy_sp};\n+use codemap;\n use ext::base::{ext_ctxt, mk_ctxt};\n use ext::quote::rt::*;\n \n@@ -310,7 +311,7 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_import(~[\n-            @ast::spanned {\n+            @codemap::spanned {\n                 node: ast::view_path_simple(\n                     self.ident_of(~\"Owned\"),\n                     path(\n@@ -319,19 +320,19 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n                             self.ident_of(~\"kinds\"),\n                             self.ident_of(~\"Owned\")\n                         ],\n-                        ast_util::dummy_sp()\n+                        codemap::dummy_sp()\n                     ),\n                     ast::type_value_ns,\n                     self.next_id()\n                 ),\n-                span: ast_util::dummy_sp()\n+                span: codemap::dummy_sp()\n             }\n         ]);\n         let vi = @ast::view_item {\n             node: vi,\n             attrs: ~[],\n             vis: ast::private,\n-            span: ast_util::dummy_sp()\n+            span: codemap::dummy_sp()\n         };\n \n         self.item("}, {"sha": "8c73dcfc04f66a6a3b55dc24ecaa2f3d16e048ab", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -11,7 +11,7 @@\n // A protocol compiler for Rust.\n \n use ast::ident;\n-use ast_util::dummy_sp;\n+use codemap::dummy_sp;\n use ext::base::ext_ctxt;\n use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n use ext::pipes::ast_builder::{path_global};"}, {"sha": "a31af36cc5442b0632e70d3968f2cd1e6642a24c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -10,8 +10,7 @@\n \n // Earley-like parser for macros.\n use ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n-use ast_util::mk_sp;\n-use codemap::BytePos;\n+use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::common::*; //resolve bug?\n use parse::lexer::*; //resolve bug?\n@@ -189,13 +188,13 @@ pub fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n-          ast::spanned {node: match_tok(_), _} => (),\n-          ast::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n+          codemap::spanned {node: match_tok(_), _} => (),\n+          codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n             for (*more_ms).each() |next_m| {\n                 n_rec(p_s, *next_m, res, ret_val)\n             };\n           }\n-          ast::spanned {\n+          codemap::spanned {\n                 node: match_nonterminal(bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n@@ -239,7 +238,7 @@ pub fn parse(sess: parse_sess,\n         let mut next_eis = ~[]; // or proceed normally\n         let mut eof_eis = ~[];\n \n-        let {tok: tok, sp: sp} = rdr.peek();\n+        let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n         /* we append new items to this while we go */\n         while cur_eis.len() > 0u { /* for each Earley Item */"}, {"sha": "115cb4f5f9482891e9fc1cb181f221cb37c61d1a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,8 +13,7 @@ use core::prelude::*;\n use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n-use ast_util::dummy_sp;\n-use codemap::span;\n+use codemap::{span, spanned, dummy_sp};\n use ext::base::{ext_ctxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n use ext::tt::macro_parser::{error};\n@@ -33,7 +32,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                          arg: ~[ast::token_tree]) -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        ast::spanned { node: m, span: dummy_sp() }\n+        spanned { node: m, span: dummy_sp() }\n     }\n \n     let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");"}, {"sha": "504a17237dc209a91bf11b132eeffcd43dd8557f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,10 +13,11 @@ use core::prelude::*;\n use ast;\n use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use ast_util;\n-use codemap::span;\n+use codemap::{span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n+use parse::lexer::TokenAndSpan;\n \n use core::option;\n use core::vec;\n@@ -69,7 +70,7 @@ pub fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n               mut repeat_len: ~[],\n               /* dummy values, never read: */\n               mut cur_tok: EOF,\n-              mut cur_span: ast_util::dummy_sp()\n+              mut cur_span: dummy_sp()\n              };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;\n@@ -149,8 +150,8 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n }\n \n \n-pub fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n-    let ret_val = { tok: r.cur_tok, sp: r.cur_span };\n+pub fn tt_next_token(&&r: tt_reader) -> TokenAndSpan {\n+    let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted"}, {"sha": "e6ba543cf790db280ee3e828ec50da5df57f2280", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::spanned;\n+use codemap::spanned;\n use codemap::BytePos;\n use parse::common::*; //resolve bug?\n use parse::token;"}, {"sha": "4ceb04c55d09a495cdc72a6a1d827cbdb1aa9d74", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -13,6 +13,7 @@\n  */\n \n use ast;\n+use codemap;\n use ast_util::operator_prec;\n \n pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n@@ -31,7 +32,8 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n         ast::expr_block(\n-            ast::spanned { node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n+            codemap::spanned {\n+                node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n         ) => true,\n       _ => false\n     }"}, {"sha": "d7640ce3a23f8c761e4dbdc035f667730d72a19a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -14,7 +14,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, FileMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, get_str_from, reader};\n-use parse::lexer::{string_reader, bump, is_eof, nextch};\n+use parse::lexer::{string_reader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer;\n use parse::token;\n use parse;\n@@ -334,7 +334,7 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let bstart = rdr.pos;\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n-        let {tok: tok, sp: sp} = rdr.peek();\n+        let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n             literals.push({lit: s, pos: sp.lo});"}, {"sha": "48ef6b873ecaa7b47c845c73ccb42b7b8afd2b55", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -11,8 +11,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::spanned;\n-use codemap::BytePos;\n+use codemap::{BytePos, spanned};\n use parse::lexer::reader;\n use parse::parser::Parser;\n use parse::token;\n@@ -190,7 +189,9 @@ pub impl Parser {\n         if self.token == token::GT {\n             self.bump();\n         } else if self.token == token::BINOP(token::SHR) {\n-            self.swap(token::GT, self.span.lo + BytePos(1u), self.span.hi);\n+            self.replace_token(token::GT,\n+                               self.span.lo + BytePos(1u),\n+                               self.span.hi);\n         } else {\n             let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, token::GT);\n@@ -229,7 +230,7 @@ pub impl Parser {\n     }\n \n     fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n+                                f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -277,7 +278,7 @@ pub impl Parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n-                          f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n+                          f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);"}, {"sha": "5decb2351e389a026d1c6e1c7e84a18ac89487a0", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -10,8 +10,7 @@\n \n use parser::Parser;\n use attr::parser_attr;\n-use ast_util::mk_sp;\n-use codemap::span;\n+use codemap::{span, mk_sp};\n \n type ctx =\n     @{sess: parse::parse_sess,\n@@ -75,7 +74,7 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n         // XXX: Using a dummy span, but this code will go away soon\n         let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n                                           modpath,\n-                                          ast_util::dummy_sp());\n+                                          codemap::dummy_sp());\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         return (m0.view_items, m0.items, inner_attrs.inner);"}, {"sha": "71e96699c3d542c2f8b93d746f4d5033167b78d2", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -30,14 +30,17 @@ use std;\n \n pub trait reader {\n     fn is_eof() -> bool;\n-    fn next_token() -> {tok: token::Token, sp: span};\n+    fn next_token() -> TokenAndSpan;\n     fn fatal(~str) -> !;\n     fn span_diag() -> span_handler;\n     pure fn interner() -> @token::ident_interner;\n-    fn peek() -> {tok: token::Token, sp: span};\n+    fn peek() -> TokenAndSpan;\n     fn dup() -> reader;\n }\n \n+#[deriving_eq]\n+pub struct TokenAndSpan {tok: token::Token, sp: span}\n+\n pub type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n@@ -79,11 +82,14 @@ pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n               filemap: filemap, interner: itr,\n               /* dummy values; not read */\n               mut peek_tok: token::EOF,\n-              mut peek_span: ast_util::dummy_sp()};\n+              mut peek_span: codemap::dummy_sp()};\n     bump(r);\n     return r;\n }\n \n+// duplicating the string reader is probably a bad idea, in\n+// that using them will cause interleaved pushes of line\n+// offsets to the underlying filemap...\n fn dup_string_reader(&&r: string_reader) -> string_reader {\n     @{span_diagnostic: r.span_diagnostic, src: r.src,\n       mut pos: r.pos,\n@@ -95,8 +101,9 @@ fn dup_string_reader(&&r: string_reader) -> string_reader {\n \n impl string_reader: reader {\n     fn is_eof() -> bool { is_eof(self) }\n-    fn next_token() -> {tok: token::Token, sp: span} {\n-        let ret_val = {tok: self.peek_tok, sp: self.peek_span};\n+    // return the next token. EFFECT: advances the string_reader.\n+    fn next_token() -> TokenAndSpan {\n+        let ret_val = TokenAndSpan {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n         return ret_val;\n     }\n@@ -105,15 +112,15 @@ impl string_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.span_diagnostic }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::Token, sp: span} {\n-        {tok: self.peek_tok, sp: self.peek_span}\n+    fn peek() -> TokenAndSpan {\n+        TokenAndSpan {tok: self.peek_tok, sp: self.peek_span}\n     }\n     fn dup() -> reader { dup_string_reader(self) as reader }\n }\n \n pub impl tt_reader: reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n-    fn next_token() -> {tok: token::Token, sp: span} {\n+    fn next_token() -> TokenAndSpan {\n         /* weird resolve bug: if the following `if`, or any of its\n         statements are removed, we get resolution errors */\n         if false {\n@@ -127,27 +134,29 @@ pub impl tt_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.sp_diag }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::Token, sp: span} {\n-        { tok: self.cur_tok, sp: self.cur_span }\n+    fn peek() -> TokenAndSpan {\n+        TokenAndSpan { tok: self.cur_tok, sp: self.cur_span }\n     }\n     fn dup() -> reader { dup_tt_reader(self) as reader }\n }\n \n+// EFFECT: advance peek_tok and peek_span to refer to the next token.\n fn string_advance_token(&&r: string_reader) {\n-    for consume_whitespace_and_comments(r).each |comment| {\n-        r.peek_tok = comment.tok;\n-        r.peek_span = comment.sp;\n-        return;\n+    match (consume_whitespace_and_comments(r)) {\n+        Some(comment) => {\n+            r.peek_tok = comment.tok;\n+            r.peek_span = comment.sp;\n+        },\n+        None => {\n+            if is_eof(r) {\n+                r.peek_tok = token::EOF;\n+            } else {\n+                let start_bytepos = r.last_pos;\n+                r.peek_tok = next_token_inner(r);\n+                r.peek_span = codemap::mk_sp(start_bytepos, r.last_pos);\n+            };\n+        }\n     }\n-\n-    if is_eof(r) {\n-        r.peek_tok = token::EOF;\n-    } else {\n-        let start_bytepos = r.last_pos;\n-        r.peek_tok = next_token_inner(r);\n-        r.peek_span = ast_util::mk_sp(start_bytepos, r.last_pos);\n-    };\n-\n }\n \n fn byte_offset(rdr: string_reader) -> BytePos {\n@@ -163,6 +172,8 @@ pub fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n     }\n }\n \n+// EFFECT: advance the StringReader by one character. If a newline is\n+// discovered, add it to the FileMap's list of line start offsets.\n pub fn bump(rdr: string_reader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n@@ -233,16 +244,19 @@ fn is_hex_digit(c: char) -> bool {\n \n fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n-// might return a sugared-doc-attr\n+// EFFECT: eats whitespace and comments.\n+// returns a Some(sugared-doc-attr) if one exists, None otherwise.\n fn consume_whitespace_and_comments(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+    -> Option<TokenAndSpan> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n-// might return a sugared-doc-attr\n+// PRECONDITION: rdr.curr is not whitespace\n+// EFFECT: eats any kind of comment.\n+// returns a Some(sugared-doc-attr) if one exists, None otherwise\n fn consume_any_line_comment(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+                                -> Option<TokenAndSpan> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n           '/' => {\n@@ -256,9 +270,9 @@ fn consume_any_line_comment(rdr: string_reader)\n                     str::push_char(&mut acc, rdr.curr);\n                     bump(rdr);\n                 }\n-                return Some({\n+                return Some(TokenAndSpan{\n                     tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                    sp: ast_util::mk_sp(start_bpos, rdr.pos)\n+                    sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             } else {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n@@ -285,7 +299,7 @@ fn consume_any_line_comment(rdr: string_reader)\n \n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+                                -> Option<TokenAndSpan> {\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n@@ -301,9 +315,9 @@ fn consume_block_comment(rdr: string_reader)\n             acc += ~\"*/\";\n             bump(rdr);\n             bump(rdr);\n-            return Some({\n+            return Some(TokenAndSpan{\n                 tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                sp: ast_util::mk_sp(start_bpos, rdr.pos)\n+                sp: codemap::mk_sp(start_bpos, rdr.pos)\n             });\n         }\n     } else {\n@@ -702,6 +716,41 @@ fn consume_whitespace(rdr: string_reader) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n }\n \n+#[cfg(test)]\n+pub mod test {\n+\n+    use super::*;\n+    use util::interner;\n+    use diagnostic;\n+    use util::testing::{check_equal, check_equal_ptr};\n+    #[test] fn t1 () {\n+        let teststr =\n+            @~\"/* my source file */\n+fn main() { io::println(~\\\"zebra\\\"); }\\n\";\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"zebra.rs\",teststr);\n+        let ident_interner = token::mk_ident_interner(); // interner::mk();\n+        let id = ident_interner.intern(@~\"fn\");\n+        let span_handler =\n+            diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n+        let string_reader = new_string_reader(span_handler,fm,ident_interner);\n+        let tok1 = string_reader.next_token();\n+        let tok2 = TokenAndSpan{\n+            tok:token::IDENT(id, false),\n+            sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n+        check_equal (tok1,tok2);\n+        // the 'main' id is already read:\n+        check_equal (string_reader.last_pos,BytePos(28));\n+        // read another token:\n+        let tok3 = string_reader.next_token();\n+        let tok4 = TokenAndSpan{\n+            tok:token::IDENT(ident_interner.intern (@~\"main\"), false),\n+            sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n+        check_equal (tok3,tok4);\n+        // the lparen is already read:\n+        check_equal (string_reader.last_pos,BytePos(29))\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "6169233c1b714dad0ff2266f0f90c68fd4cb770b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -10,6 +10,7 @@\n \n //! The main parser interface\n \n+\n use ast::node_id;\n use ast;\n use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n@@ -33,6 +34,7 @@ pub mod token;\n pub mod comments;\n pub mod attr;\n \n+\n /// Common routines shared by parser mods\n pub mod common;\n \n@@ -215,3 +217,4 @@ pub fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n                                     None, tts);\n     return Parser(sess, cfg, trdr as reader)\n }\n+"}, {"sha": "0c7a202dcd6703ac81543a51ed0a8c32140141ae", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -21,8 +21,7 @@ use core::prelude::*;\n \n use ast::{expr, expr_lit, lit_nil};\n use ast;\n-use ast_util::{respan};\n-use codemap::span;\n+use codemap::{span, respan};\n use parse::parser::Parser;\n use parse::token::Token;\n use parse::token;"}, {"sha": "2917ce433585e623147c32ec1c5b9d2b2d06fcd4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -55,15 +55,16 @@ use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::{visibility, vstore, vstore_box, vstore_fixed, vstore_slice};\n use ast::{vstore_uniq};\n use ast;\n-use ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n+use ast_util::{ident_to_path, operator_prec};\n use ast_util;\n use classify;\n-use codemap::{span,FssNone, BytePos};\n+use codemap::{span,FssNone, BytePos, spanned, respan, mk_sp};\n use codemap;\n use parse::attr::parser_attr;\n use parse::common::{seq_sep_none, token_to_str};\n use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::reader;\n+use parse::lexer::TokenAndSpan;\n use parse::obsolete::{ObsoleteClassTraits, ObsoleteModeInFnType};\n use parse::obsolete::{ObsoleteLet, ObsoleteFieldTerminator};\n use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove};\n@@ -193,7 +194,7 @@ pub fn Parser(sess: parse_sess,\n         token: tok0.tok,\n         span: span0,\n         last_span: span0,\n-        buffer: [mut {tok: tok0.tok, sp: span0}, ..4],\n+        buffer: [mut TokenAndSpan {tok: tok0.tok, sp: span0}, ..4],\n         buffer_start: 0,\n         buffer_end: 0,\n         tokens_consumed: 0u,\n@@ -213,7 +214,7 @@ pub struct Parser {\n     mut token: token::Token,\n     mut span: span,\n     mut last_span: span,\n-    mut buffer: [mut {tok: token::Token, sp: span} * 4],\n+    mut buffer: [mut TokenAndSpan * 4],\n     mut buffer_start: int,\n     mut buffer_end: int,\n     mut tokens_consumed: uint,\n@@ -234,6 +235,7 @@ pub struct Parser {\n }\n \n pub impl Parser {\n+    // advance the parser by one token\n     fn bump() {\n         self.last_span = self.span;\n         let next = if self.buffer_start == self.buffer_end {\n@@ -247,7 +249,8 @@ pub impl Parser {\n         self.span = next.sp;\n         self.tokens_consumed += 1u;\n     }\n-    fn swap(next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    // EFFECT: replace the current token and span with the given one\n+    fn replace_token(next: token::Token, +lo: BytePos, +hi: BytePos) {\n         self.token = next;\n         self.span = mk_sp(lo, hi);\n     }\n@@ -800,7 +803,7 @@ pub impl Parser {\n             self.bump();\n             self.lit_from_token(tok)\n         };\n-        ast::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n+        codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n     fn parse_path_without_tps() -> @path {\n@@ -875,7 +878,7 @@ pub impl Parser {\n                 self.parse_seq_lt_gt(Some(token::COMMA),\n                                      |p| p.parse_ty(false))\n             } else {\n-                ast::spanned {node: ~[], span: path.span}\n+                codemap::spanned {node: ~[], span: path.span}\n             }\n         };\n \n@@ -917,14 +920,14 @@ pub impl Parser {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n-            node: expr_mac(ast::spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: expr_mac(codemap::spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     fn mk_lit_u32(i: u32) -> @expr {\n         let span = self.span;\n-        let lv_lit = @ast::spanned { node: lit_uint(i as u64, ty_u32),\n+        let lv_lit = @codemap::spanned { node: lit_uint(i as u64, ty_u32),\n                                      span: span };\n \n         @expr {\n@@ -1404,7 +1407,7 @@ pub impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@ast::spanned {\n+                  expr_vec(*) | expr_lit(@codemap::spanned {\n                     node: lit_str(_), span: _\n                   })\n                   if m == m_imm => {\n@@ -1429,7 +1432,7 @@ pub impl Parser {\n               expr_vec(*) if m == m_mutbl =>\n                 expr_vstore(e, expr_vstore_mut_box),\n               expr_vec(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              expr_lit(@ast::spanned {\n+              expr_lit(@codemap::spanned {\n                   node: lit_str(_), span: _}) if m == m_imm =>\n                 expr_vstore(e, expr_vstore_box),\n               _ => expr_unary(box(m), e)\n@@ -1442,7 +1445,7 @@ pub impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              expr_vec(*) | expr_lit(@ast::spanned {\n+              expr_vec(*) | expr_lit(@codemap::spanned {\n                 node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n@@ -1496,6 +1499,7 @@ pub impl Parser {\n         return lhs;\n     }\n \n+    // parse an arbitrary expression.\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n@@ -1794,7 +1798,7 @@ pub impl Parser {\n                 self.eat(token::COMMA);\n             }\n \n-            let blk = ast::spanned {\n+            let blk = codemap::spanned {\n                 node: ast::blk_ {\n                     view_items: ~[],\n                     stmts: ~[],\n@@ -1812,10 +1816,12 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, expr_match(discriminant, arms));\n     }\n \n+    // parse an expression\n     fn parse_expr() -> @expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n+    // parse an expression, subject to the given restriction\n     fn parse_expr_res(r: restriction) -> @expr {\n         let old = self.restriction;\n         self.restriction = r;\n@@ -1943,7 +1949,9 @@ pub impl Parser {\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1963,7 +1971,9 @@ pub impl Parser {\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1985,7 +1995,7 @@ pub impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   pat_lit(e@@expr {\n-                      node: expr_lit(@ast::spanned {\n+                      node: expr_lit(@codemap::spanned {\n                             node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @expr {\n@@ -2011,7 +2021,9 @@ pub impl Parser {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @ast::spanned {node: lit_nil, span: mk_sp(lo, hi)};\n+                let lit = @codemap::spanned {\n+                    node: lit_nil,\n+                    span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n@@ -2381,7 +2393,7 @@ pub impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@ast::spanned {\n+                                    stmts.push(@codemap::spanned {\n                                         node: stmt_semi(e, stmt_id),\n                                         .. *stmt});\n                                 }\n@@ -2406,7 +2418,7 @@ pub impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@ast::spanned {\n+                                    stmts.push(@codemap::spanned {\n                                         node: stmt_mac((*m), true),\n                                         .. *stmt});\n                                 }\n@@ -2940,7 +2952,7 @@ pub impl Parser {\n \n         let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n                                                      body: d_body},\n@@ -3445,7 +3457,7 @@ pub impl Parser {\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n                                                      body: d_body },\n@@ -3737,7 +3749,7 @@ pub impl Parser {\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n             let m = ast::mac_invoc_tt(pth, tts);\n-            let m: ast::mac = ast::spanned { node: m,\n+            let m: ast::mac = codemap::spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = item_mac(m);"}, {"sha": "1b5c93984ee2bec2cb89341d27941f335d099997", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -575,7 +575,7 @@ pub fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(ast::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n@@ -2241,6 +2241,7 @@ pub mod test {\n     use parse;\n     use super::*;\n     //use util;\n+    use util::testing::check_equal;\n \n     fn string_check<T : Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n@@ -2257,19 +2258,19 @@ pub mod test {\n             inputs: ~[],\n             output: @ast::Ty {id: 0,\n                               node: ast::ty_nil,\n-                              span: ast_util::dummy_sp()},\n+                              span: codemap::dummy_sp()},\n             cf: ast::return_val\n         };\n-        assert fun_to_str(decl, abba_ident, ~[],mock_interner)\n-            == ~\"fn abba()\";\n+        check_equal (&fun_to_str(decl, abba_ident, ~[],mock_interner),\n+                     &~\"fn abba()\");\n     }\n \n     #[test]\n     fn test_variant_to_str() {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n         let ident = mock_interner.intern(@~\"principal_skinner\");\n \n-        let var = ast_util::respan(ast_util::dummy_sp(), ast::variant_ {\n+        let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n             name: ident,\n             attrs: ~[],\n             // making this up as I go.... ?\n@@ -2280,7 +2281,7 @@ pub mod test {\n         });\n \n         let varstr = variant_to_str(var,mock_interner);\n-        string_check(&varstr,&~\"pub principal_skinner\");\n+        check_equal(&varstr,&~\"pub principal_skinner\");\n     }\n }\n "}, {"sha": "a6d50b9cf0908760e4175d7d9d9a06697d51ac16", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -46,10 +46,11 @@ pub mod ast_map;\n pub mod visit;\n pub mod fold;\n pub mod util {\n-    #[path = \"interner.rs\"]\n     pub mod interner;\n+    pub mod testing;\n }\n \n+\n #[path = \"parse/mod.rs\"]\n pub mod parse;\n \n@@ -86,3 +87,4 @@ pub mod ext {\n \n     pub mod trace_macros;\n }\n+"}, {"sha": "d70e503a56877d96d1d510fba6fbedea8896fe13", "filename": "src/libsyntax/util/testing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Futil%2Ftesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53688addaa4484f1a317bb0938cf453381810427/src%2Flibsyntax%2Futil%2Ftesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Ftesting.rs?ref=53688addaa4484f1a317bb0938cf453381810427", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// support for test cases.\n+use core::cmp;\n+\n+pub pure fn check_equal_ptr<T : cmp::Eq> (given : &T, expected: &T) {\n+    if !((given == expected) && (expected == given )) {\n+        fail (fmt!(\"given %?, expected %?\",given,expected));\n+    }\n+}\n+\n+pub pure fn check_equal<T : cmp::Eq> (given : T, expected: T) {\n+    if !((given == expected) && (expected == given )) {\n+        fail (fmt!(\"given %?, expected %?\",given,expected));\n+    }\n+}"}]}