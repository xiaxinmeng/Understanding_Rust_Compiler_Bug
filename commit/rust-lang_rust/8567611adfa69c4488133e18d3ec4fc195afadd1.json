{"sha": "8567611adfa69c4488133e18d3ec4fc195afadd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1Njc2MTFhZGZhNjljNDQ4ODEzM2UxOGQzZWM0ZmMxOTVhZmFkZDE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-06T23:18:58Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-06T23:18:58Z"}, "message": "Merge commit 'd89ff7eef969aee6b493bc846b64d68358fafbcd' into remove-str-trailing-nulls", "tree": {"sha": "80e325db23f407d643e2ada480de23b1fb8b4fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80e325db23f407d643e2ada480de23b1fb8b4fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8567611adfa69c4488133e18d3ec4fc195afadd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8567611adfa69c4488133e18d3ec4fc195afadd1", "html_url": "https://github.com/rust-lang/rust/commit/8567611adfa69c4488133e18d3ec4fc195afadd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8567611adfa69c4488133e18d3ec4fc195afadd1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9b27910b41e714dfd6b3ccc48161260943c9cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9b27910b41e714dfd6b3ccc48161260943c9cf", "html_url": "https://github.com/rust-lang/rust/commit/fb9b27910b41e714dfd6b3ccc48161260943c9cf"}, {"sha": "d89ff7eef969aee6b493bc846b64d68358fafbcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d89ff7eef969aee6b493bc846b64d68358fafbcd", "html_url": "https://github.com/rust-lang/rust/commit/d89ff7eef969aee6b493bc846b64d68358fafbcd"}], "stats": {"total": 1214, "additions": 428, "deletions": 786}, "files": [{"sha": "6ee5420664d8e1c819efa0bfe8a000519b6a6a0d", "filename": "mk/platform.mk", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -241,7 +241,7 @@ CFG_RUN_TARG_i686-apple-darwin=$(call CFG_RUN_i686-apple-darwin,,$(2))\n # arm-linux-androideabi configuration\n CC_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n CXX_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-g++\n-CPP_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n+CPP_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc -E\n AR_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-ar\n CFG_LIB_NAME_arm-linux-androideabi=lib$(1).so\n CFG_LIB_GLOB_arm-linux-androideabi=lib$(1)-*.so\n@@ -272,7 +272,7 @@ AR_arm-unknown-linux-gnueabihf=arm-linux-gnueabihf-ar\n CFG_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).so\n CFG_LIB_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.dylib.dSYM\n-CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC\n+CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabihf := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabihf := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabihf := -Wl,--export-dynamic,--dynamic-list=\n@@ -290,6 +290,32 @@ CFG_RUN_arm-unknown-linux-gnueabihf=\n CFG_RUN_TARG_arm-unknown-linux-gnueabihf=\n RUSTC_FLAGS_arm-unknown-linux-gnueabihf := --linker=$(CC_arm-unknown-linux-gnueabihf)\n \n+# arm-unknown-linux-gnueabi configuration\n+CC_arm-unknown-linux-gnueabi=arm-linux-gnueabi-gcc\n+CXX_arm-unknown-linux-gnueabi=arm-linux-gnueabi-g++\n+CPP_arm-unknown-linux-gnueabi=arm-linux-gnueabi-gcc -E\n+AR_arm-unknown-linux-gnueabi=arm-linux-gnueabi-ar\n+CFG_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).so\n+CFG_LIB_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n+CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__\n+CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabi := -fno-rtti\n+CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabi := -shared -fPIC -g\n+CFG_GCCISH_DEF_FLAG_arm-unknown-linux-gnueabi := -Wl,--export-dynamic,--dynamic-list=\n+CFG_GCCISH_PRE_LIB_FLAGS_arm-unknown-linux-gnueabi := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_arm-unknown-linux-gnueabi := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_arm-unknown-linux-gnueabi := .linux.def\n+CFG_INSTALL_NAME_ar,-unknown-linux-gnueabi =\n+CFG_LIBUV_LINK_FLAGS_arm-unknown-linux-gnueabi =\n+CFG_EXE_SUFFIX_arm-unknown-linux-gnueabi :=\n+CFG_WINDOWSY_arm-unknown-linux-gnueabi :=\n+CFG_UNIXY_arm-unknown-linux-gnueabi := 1\n+CFG_PATH_MUNGE_arm-unknown-linux-gnueabi := true\n+CFG_LDPATH_arm-unknown-linux-gnueabi :=\n+CFG_RUN_arm-unknown-linux-gnueabi=\n+CFG_RUN_TARG_arm-unknown-linux-gnueabi=\n+RUSTC_FLAGS_arm-unknown-linux-gnueabi := --linker=$(CC_arm-unknown-linux-gnueabi)\n+\n # mips-unknown-linux-gnu configuration\n CC_mips-unknown-linux-gnu=mips-linux-gnu-gcc\n CXX_mips-unknown-linux-gnu=mips-linux-gnu-g++\n@@ -450,7 +476,7 @@ define CFG_MAKE_TOOLCHAIN\n         $$(CFG_GCCISH_DEF_FLAG_$(1))$$(3) $$(2)        \\\n         $$(call CFG_INSTALL_NAME_$(1),$$(4))\n \n-  ifneq ($(1),arm-linux-androideabi)\n+  ifneq ($(HOST_$(1)),arm)\n \n   # We're using llvm-mc as our assembler because it supports\n   # .cfi pseudo-ops on mac\n@@ -462,9 +488,9 @@ define CFG_MAKE_TOOLCHAIN\n                     -o=$$(1)\n   else\n \n-  # For the Android cross, use the Android assembler\n+  # For the ARM crosses, use the toolchain assembler\n   # XXX: We should be able to use the LLVM assembler\n-  CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)\n+  CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)\n \n   endif\n "}, {"sha": "ae4356eb4baccb163c586078b047c7bf8c26ccaf", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -67,17 +67,16 @@ pub struct Arena {\n     priv chunks: @mut MutList<Chunk>,\n }\n \n-#[unsafe_destructor]\n-impl Drop for Arena {\n-    fn drop(&self) {\n-        unsafe {\n-            destroy_chunk(&self.head);\n-            do self.chunks.each |chunk| {\n-                if !chunk.is_pod {\n-                    destroy_chunk(chunk);\n-                }\n-                true\n-            };\n+impl Arena {\n+    pub fn new() -> Arena {\n+        Arena::new_with_size(32u)\n+    }\n+\n+    pub fn new_with_size(initial_size: uint) -> Arena {\n+        Arena {\n+            head: chunk(initial_size, false),\n+            pod_head: chunk(initial_size, true),\n+            chunks: @mut MutNil,\n         }\n     }\n }\n@@ -92,18 +91,21 @@ fn chunk(size: uint, is_pod: bool) -> Chunk {\n     }\n }\n \n-pub fn arena_with_size(initial_size: uint) -> Arena {\n-    Arena {\n-        head: chunk(initial_size, false),\n-        pod_head: chunk(initial_size, true),\n-        chunks: @mut MutNil,\n+#[unsafe_destructor]\n+impl Drop for Arena {\n+    fn drop(&self) {\n+        unsafe {\n+            destroy_chunk(&self.head);\n+            do self.chunks.each |chunk| {\n+                if !chunk.is_pod {\n+                    destroy_chunk(chunk);\n+                }\n+                true\n+            };\n+        }\n     }\n }\n \n-pub fn Arena() -> Arena {\n-    arena_with_size(32u)\n-}\n-\n #[inline]\n fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n@@ -276,7 +278,7 @@ impl Arena {\n \n #[test]\n fn test_arena_destructors() {\n-    let arena = Arena();\n+    let arena = Arena::new();\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n@@ -291,7 +293,7 @@ fn test_arena_destructors() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n-    let arena = Arena();\n+    let arena = Arena::new();\n     // Put some stuff in the arena.\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it"}, {"sha": "776e25cac8908447988c204aca86bea7c717db87", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -18,9 +18,8 @@ Higher level communication abstractions.\n \n \n use std::comm::{GenericChan, GenericSmartChan, GenericPort};\n-use std::comm::{Chan, Port, Selectable, Peekable};\n+use std::comm::{Chan, Port, Peekable};\n use std::comm;\n-use std::pipes;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n@@ -75,12 +74,6 @@ impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Send,U:Send> Selectable for DuplexStream<T, U> {\n-    fn header(&mut self) -> *mut pipes::PacketHeader {\n-        self.port.header()\n-    }\n-}\n-\n /// Creates a bidirectional stream.\n pub fn DuplexStream<T:Send,U:Send>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)"}, {"sha": "75487a44f2600253e4d50091eaccc1517c299e06", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -92,6 +92,11 @@ impl<T> Rawlink<T> {\n             Some(unsafe { cast::transmute(self.p) })\n         }\n     }\n+\n+    /// Return the `Rawlink` and replace with `Rawlink::none()`\n+    fn take(&mut self) -> Rawlink<T> {\n+        util::replace(self, Rawlink::none())\n+    }\n }\n \n impl<T> Clone for Rawlink<T> {\n@@ -280,13 +285,16 @@ impl<T> DList<T> {\n     /// Add all elements from `other` to the end of the list\n     ///\n     /// O(1)\n-    pub fn append(&mut self, other: DList<T>) {\n+    pub fn append(&mut self, mut other: DList<T>) {\n         match self.list_tail.resolve() {\n             None => *self = other,\n             Some(tail) => {\n-                match other {\n-                    DList{list_head: None, _} => return,\n-                    DList{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n+                // Carefully empty `other`.\n+                let o_tail = other.list_tail.take();\n+                let o_length = other.length;\n+                match other.list_head.take() {\n+                    None => return,\n+                    Some(node) => {\n                         tail.next = link_with_prev(node, self.list_tail);\n                         self.list_tail = o_tail;\n                         self.length += o_length;\n@@ -404,6 +412,32 @@ impl<T: Ord> DList<T> {\n     }\n }\n \n+#[unsafe_destructor]\n+impl<T> Drop for DList<T> {\n+    fn drop(&self) {\n+        let mut_self = unsafe {\n+            cast::transmute_mut(self)\n+        };\n+        // Dissolve the dlist in backwards direction\n+        // Just dropping the list_head can lead to stack exhaustion\n+        // when length is >> 1_000_000\n+        let mut tail = mut_self.list_tail;\n+        loop {\n+            match tail.resolve() {\n+                None => break,\n+                Some(prev) => {\n+                    prev.next.take(); // release ~Node<T>\n+                    tail = prev.prev;\n+                }\n+            }\n+        }\n+        mut_self.length = 0;\n+        mut_self.list_head = None;\n+        mut_self.list_tail = Rawlink::none();\n+    }\n+}\n+\n+\n impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self A> {"}, {"sha": "487ad050e78643bf5bd759c7180d88a8375dd05c", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -184,7 +184,68 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root, remaining: self.length}\n+        TreeMapIterator {\n+            stack: ~[],\n+            node: &self.root,\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+\n+    /// Get a lazy iterator that should be initialized using\n+    /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n+    fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator {\n+            stack: ~[],\n+            node: &self.root,\n+            remaining_min: 0,\n+            remaining_max: self.length\n+        }\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n+    /// If all keys in map are less than `k` an empty iterator is returned.\n+    pub fn lower_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n+        loop {\n+            match *iter.node {\n+              Some(ref r) => {\n+                match k.cmp(&r.key) {\n+                  Less => iter_traverse_left(&mut iter),\n+                  Greater => iter_traverse_right(&mut iter),\n+                  Equal => {\n+                    iter_traverse_complete(&mut iter);\n+                    return iter;\n+                  }\n+                }\n+              }\n+              None => {\n+                iter_traverse_complete(&mut iter);\n+                return iter;\n+              }\n+            }\n+        }\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n+    /// If all keys in map are not greater than `k` an empty iterator is returned.\n+    pub fn upper_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n+        loop {\n+            match *iter.node {\n+              Some(ref r) => {\n+                match k.cmp(&r.key) {\n+                  Less => iter_traverse_left(&mut iter),\n+                  Greater => iter_traverse_right(&mut iter),\n+                  Equal => iter_traverse_right(&mut iter)\n+                }\n+              }\n+              None => {\n+                iter_traverse_complete(&mut iter);\n+                return iter;\n+              }\n+            }\n+        }\n     }\n \n     /// Get a lazy iterator that consumes the treemap.\n@@ -205,7 +266,8 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n pub struct TreeMapIterator<'self, K, V> {\n     priv stack: ~[&'self ~TreeNode<K, V>],\n     priv node: &'self Option<~TreeNode<K, V>>,\n-    priv remaining: uint\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n }\n \n impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n@@ -222,7 +284,10 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n               None => {\n                 let res = self.stack.pop();\n                 self.node = &res.right;\n-                self.remaining -= 1;\n+                self.remaining_max -= 1;\n+                if self.remaining_min > 0 {\n+                    self.remaining_min -= 1;\n+                }\n                 return Some((&res.key, &res.value));\n               }\n             }\n@@ -232,7 +297,46 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining, Some(self.remaining))\n+        (self.remaining_min, Some(self.remaining_max))\n+    }\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapIterator pointing to element inside tree structure.\n+///\n+/// They should be used in following manner:\n+///   - create iterator using TreeMap::iter_for_traversal\n+///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n+///     (current node is `TreeMapIterator::node` field)\n+///   - complete initialization with `iter_traverse_complete`\n+#[inline]\n+fn iter_traverse_left<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    let node = it.node.get_ref();\n+    it.stack.push(node);\n+    it.node = &node.left;\n+}\n+\n+#[inline]\n+fn iter_traverse_right<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    it.node = &(it.node.get_ref().right);\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapIterator pointing to element inside tree structure.\n+///\n+/// Completes traversal. Should be called before using iterator.\n+/// Iteration will start from `self.node`.\n+/// If `self.node` is None iteration will start from last node from which we\n+/// traversed left.\n+#[inline]\n+fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    static none: Option<~TreeNode<K, V>> = None;\n+    match *it.node {\n+        Some(ref n) => {\n+            it.stack.push(n);\n+            it.node = &none;\n+        }\n+        None => ()\n     }\n }\n \n@@ -417,6 +521,20 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n+    /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n+    /// If all elements in the set are less than `v` empty iterator is returned.\n+    #[inline]\n+    pub fn lower_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.lower_bound_iter(v)}\n+    }\n+\n+    /// Get a lazy iterator pointing to the first value greater than `v`.\n+    /// If all elements in the set are not greater than `v` empty iterator is returned.\n+    #[inline]\n+    pub fn upper_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.upper_bound_iter(v)}\n+    }\n+\n     /// Visit all values in reverse order\n     #[inline]\n     pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n@@ -983,6 +1101,31 @@ mod test_treemap {\n             assert_eq!(*v, n * 2);\n             n += 1;\n         }\n+        assert_eq!(n, 5);\n+    }\n+\n+    #[test]\n+    fn test_interval_iteration() {\n+        let mut m = TreeMap::new();\n+        for i in range(1, 100) {\n+            assert!(m.insert(i * 2, i * 4));\n+        }\n+\n+        for i in range(1, 198) {\n+            let mut lb_it = m.lower_bound_iter(&i);\n+            let (&k, &v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            assert_eq!(lb * 2, v);\n+\n+            let mut ub_it = m.upper_bound_iter(&i);\n+            let (&k, &v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            assert_eq!(ub * 2, v);\n+        }\n+        let mut end_it = m.lower_bound_iter(&199);\n+        assert_eq!(end_it.next(), None);\n     }\n \n     #[test]\n@@ -1256,7 +1399,6 @@ mod test_set {\n \n         let mut n = 0;\n         for x in m.iter() {\n-            printfln!(x);\n             assert_eq!(*x, n);\n             n += 1\n         }"}, {"sha": "3957551c846399df89eb2641051280f2d88d5a3b", "filename": "src/libextra/unicode.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibextra%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Funicode.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n #[allow(missing_doc)];\n \n pub mod icu {\n@@ -159,7 +158,10 @@ pub mod icu {\n     pub static UCHAR_INVALID_CODE : UProperty = -1;\n \n     pub mod libicu {\n-        #[link_name = \"icuuc\"]\n+        use unicode::icu::*;\n+\n+        // #[link_name = \"icuuc\"]\n+        #[link_args = \"-licuuc\"]\n         #[abi = \"cdecl\"]\n         extern {\n             pub fn u_hasBinaryProperty(c: UChar32, which: UProperty) -> UBool;\n@@ -174,13 +176,17 @@ pub mod icu {\n }\n \n pub fn is_XID_start(c: char) -> bool {\n-    return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n-        == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n+            == icu::TRUE;\n+    }\n }\n \n pub fn is_XID_continue(c: char) -> bool {\n-    return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n-        == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n+            == icu::TRUE;\n+    }\n }\n \n /*\n@@ -189,7 +195,9 @@ Function: is_digit\n Returns true if a character is a digit.\n */\n pub fn is_digit(c: char) -> bool {\n-    return icu::libicu::u_isdigit(c) == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_isdigit(c) == icu::TRUE;\n+    }\n }\n \n /*\n@@ -198,7 +206,9 @@ Function: is_lower\n Returns true if a character is a lowercase letter.\n */\n pub fn is_lower(c: char) -> bool {\n-    return icu::libicu::u_islower(c) == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_islower(c) == icu::TRUE;\n+    }\n }\n \n /*\n@@ -207,7 +217,9 @@ Function: is_space\n Returns true if a character is space.\n */\n pub fn is_space(c: char) -> bool {\n-    return icu::libicu::u_isspace(c) == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_isspace(c) == icu::TRUE;\n+    }\n }\n \n /*\n@@ -216,33 +228,36 @@ Function: is_upper\n Returns true if a character is an uppercase letter.\n */\n pub fn is_upper(c: char) -> bool {\n-    return icu::libicu::u_isupper(c) == icu::TRUE;\n+    unsafe {\n+        return icu::libicu::u_isupper(c) == icu::TRUE;\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n+    use unicode::*;\n \n     #[test]\n     fn test_is_digit() {\n-        assert!((unicode::icu::is_digit('0')));\n-        assert!((!unicode::icu::is_digit('m')));\n+        assert!((is_digit('0')));\n+        assert!((!is_digit('m')));\n     }\n \n     #[test]\n     fn test_is_lower() {\n-        assert!((unicode::icu::is_lower('m')));\n-        assert!((!unicode::icu::is_lower('M')));\n+        assert!((is_lower('m')));\n+        assert!((!is_lower('M')));\n     }\n \n     #[test]\n     fn test_is_space() {\n-        assert!((unicode::icu::is_space(' ')));\n-        assert!((!unicode::icu::is_space('m')));\n+        assert!((is_space(' ')));\n+        assert!((!is_space('m')));\n     }\n \n     #[test]\n     fn test_is_upper() {\n-        assert!((unicode::icu::is_upper('M')));\n-        assert!((!unicode::icu::is_upper('m')));\n+        assert!((is_upper('M')));\n+        assert!((!is_upper('m')));\n     }\n }"}, {"sha": "ea679d19f73b84edea738fed068e6748b38abd6d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -335,7 +335,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n                                outputs: &OutputFilenames) {\n \n     // NB: Android hack\n-    if sess.targ_cfg.arch == abi::Arm &&\n+    if sess.targ_cfg.os == session::os_android &&\n         (sess.opts.output_type == link::output_type_object ||\n          sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;"}, {"sha": "d725e2db1eba109474b71b0a65eaf6d655fd8e6c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -179,7 +179,8 @@ pub struct crate_metadata {\n #[deriving(Eq)]\n pub enum EntryFnType {\n     EntryMain,\n-    EntryStart\n+    EntryStart,\n+    EntryNone,\n }\n \n pub struct Session_ {"}, {"sha": "34aeaf8a6cebec8fdff7622bf60eee665d54b07c", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -50,6 +50,12 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n         return;\n     }\n \n+    // If the user wants no main function at all, then stop here.\n+    if attr::contains_name(crate.attrs, \"no_main\") {\n+        *session.entry_type = Some(session::EntryNone);\n+        return\n+    }\n+\n     let ctxt = @mut EntryContext {\n         session: session,\n         ast_map: ast_map,"}, {"sha": "83a5ef6e7ce0332718d0628de81cfb2922b56fe2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -2269,13 +2269,16 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n pub fn create_entry_wrapper(ccx: @mut CrateContext,\n-                           _sp: span, main_llfn: ValueRef) {\n+                           _sp: span,\n+                           main_llfn: ValueRef) {\n     let et = ccx.sess.entry_type.unwrap();\n-    if et == session::EntryMain {\n-        let llfn = create_main(ccx, main_llfn);\n-        create_entry_fn(ccx, llfn, true);\n-    } else {\n-        create_entry_fn(ccx, main_llfn, false);\n+    match et {\n+        session::EntryMain => {\n+            let llfn = create_main(ccx, main_llfn);\n+            create_entry_fn(ccx, llfn, true);\n+        }\n+        session::EntryStart => create_entry_fn(ccx, main_llfn, false),\n+        session::EntryNone => {}    // Do nothing.\n     }\n \n     fn create_main(ccx: @mut CrateContext, main_llfn: ValueRef) -> ValueRef {"}, {"sha": "e6c27fc8f836d1ee5db0a598ae661a551a939885", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -408,9 +408,10 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n           Some((id, sp)) => match *tcx.sess.entry_type {\n               Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n               Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),\n+              Some(session::EntryNone) => {}\n               None => tcx.sess.bug(\"entry function without a type\")\n           },\n-          None => tcx.sess.bug(\"type checking without entry function\")\n+          None => {}\n         }\n     }\n }"}, {"sha": "4356f1143da4668f760d598aa1f1d34d50cb8120", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 108, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -14,7 +14,6 @@ Message passing\n \n #[allow(missing_doc)];\n \n-use cast::transmute;\n use either::{Either, Left, Right};\n use kinds::Send;\n use option::{Option, Some};\n@@ -23,12 +22,6 @@ pub use rt::comm::SendDeferred;\n use rtcomm = rt::comm;\n use rt;\n \n-use pipes::{wait_many, PacketHeader};\n-\n-// FIXME #5160: Making this public exposes some plumbing from\n-// pipes. Needs some refactoring\n-pub use pipes::Selectable;\n-\n /// A trait for things that can send multiple messages.\n pub trait GenericChan<T> {\n     /// Sends a message.\n@@ -146,15 +139,6 @@ impl<T: Send> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T: Send> Selectable for Port<T> {\n-    fn header(&mut self) -> *mut PacketHeader {\n-        match self.inner {\n-            Left(ref mut port) => port.header(),\n-            Right(_) => fail!(\"can't select on newsched ports\")\n-        }\n-    }\n-}\n-\n /// A channel that can be shared between many senders.\n pub struct SharedChan<T> {\n     inner: Either<Exclusive<pipesy::Chan<T>>, rtcomm::SharedChan<T>>\n@@ -318,8 +302,8 @@ mod pipesy {\n \n     use kinds::Send;\n     use option::{Option, Some, None};\n-    use pipes::{recv, try_recv, peek, PacketHeader};\n-    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n+    use pipes::{recv, try_recv, peek};\n+    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n     use cast::transmute_mut;\n \n     /*proto! oneshot (\n@@ -651,103 +635,13 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Send> Selectable for Port<T> {\n-        fn header(&mut self) -> *mut PacketHeader {\n-            match self.endp {\n-                Some(ref mut endp) => endp.header(),\n-                None => fail!(\"peeking empty stream\")\n-            }\n-    }\n-}\n-\n-}\n-\n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable, B:Selectable>(a: &mut A, b: &mut B)\n-                                            -> Either<(), ()> {\n-    let mut endpoints = [ a.header(), b.header() ];\n-    match wait_many(endpoints) {\n-        0 => Left(()),\n-        1 => Right(()),\n-        _ => fail!(\"wait returned unexpected index\"),\n-    }\n-}\n-\n-/// Receive a message from one of two endpoints.\n-pub trait Select2<T: Send, U: Send> {\n-    /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&mut self) -> Either<Option<T>, Option<U>>;\n-    /// Receive a message or fail if a connection closes.\n-    fn select(&mut self) -> Either<T, U>;\n-}\n-\n-impl<T:Send,\n-     U:Send,\n-     Left:Selectable + GenericPort<T>,\n-     Right:Selectable + GenericPort<U>>\n-     Select2<T, U>\n-     for (Left, Right) {\n-    fn select(&mut self) -> Either<T, U> {\n-        // XXX: Bad borrow check workaround.\n-        unsafe {\n-            let this: &(Left, Right) = transmute(self);\n-            match *this {\n-                (ref lp, ref rp) => {\n-                    let lp: &mut Left = transmute(lp);\n-                    let rp: &mut Right = transmute(rp);\n-                    match select2i(lp, rp) {\n-                        Left(()) => Left(lp.recv()),\n-                        Right(()) => Right(rp.recv()),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn try_select(&mut self) -> Either<Option<T>, Option<U>> {\n-        // XXX: Bad borrow check workaround.\n-        unsafe {\n-            let this: &(Left, Right) = transmute(self);\n-            match *this {\n-                (ref lp, ref rp) => {\n-                    let lp: &mut Left = transmute(lp);\n-                    let rp: &mut Right = transmute(rp);\n-                    match select2i(lp, rp) {\n-                        Left(()) => Left (lp.try_recv()),\n-                        Right(()) => Right(rp.try_recv()),\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n #[cfg(test)]\n mod test {\n     use either::Right;\n     use super::{Chan, Port, oneshot, stream};\n \n-    #[test]\n-    fn test_select2() {\n-        let (p1, c1) = stream();\n-        let (p2, c2) = stream();\n-\n-        c1.send(~\"abc\");\n-\n-        let mut tuple = (p1, p2);\n-        match tuple.select() {\n-            Right(_) => fail!(),\n-            _ => (),\n-        }\n-\n-        c2.send(123);\n-    }\n-\n     #[test]\n     fn test_oneshot() {\n         let (p, c) = oneshot();"}, {"sha": "2e27f82f6f6efccc236b34253079245906b84376", "filename": "src/libstd/gc.rs", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=fb9b27910b41e714dfd6b3ccc48161260943c9cf", "patch": "@@ -1,358 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[doc(hidden)];\n-#[allow(non_uppercase_statics)];\n-\n-/*! Precise garbage collector\n-\n-The precise GC exposes two functions, gc and\n-cleanup_stack_for_failure. The gc function is the entry point to the\n-garbage collector itself. The cleanup_stack_for_failure is the entry\n-point for GC-based cleanup.\n-\n-Precise GC depends on changes to LLVM's GC which add support for\n-automatic rooting and addrspace-based metadata marking. Rather than\n-explicitly rooting pointers with LLVM's gcroot intrinsic, the GC\n-merely creates allocas for pointers, and allows an LLVM pass to\n-automatically infer roots based on the allocas present in a function\n-(and live at a given location). The compiler communicates the type of\n-the pointer to LLVM by setting the addrspace of the pointer type. The\n-compiler then emits a map from addrspace to tydesc, which LLVM then\n-uses to match pointers with their tydesc. The GC reads the metadata\n-table produced by LLVM, and uses it to determine which glue functions\n-to call to free objects on their respective heaps.\n-\n-GC-based cleanup is a replacement for landing pads which relies on the\n-GC infrastructure to find pointers on the stack to cleanup. Whereas\n-the normal GC needs to walk task-local heap allocations, the cleanup\n-code needs to walk exchange heap allocations and stack-allocations\n-with destructors.\n-\n-*/\n-\n-use cast;\n-use container::{Set, MutableSet};\n-use io;\n-use libc::{uintptr_t};\n-use option::{None, Option, Some};\n-use ptr;\n-use hashmap::HashSet;\n-use stackwalk::walk_stack;\n-use sys;\n-use unstable::intrinsics::{TyDesc};\n-\n-pub use stackwalk::Word;\n-\n-// Mirrors rust_stack.h stk_seg\n-pub struct StackSegment {\n-    prev: *StackSegment,\n-    next: *StackSegment,\n-    end: uintptr_t,\n-    // And other fields which we don't care about...\n-}\n-\n-pub mod rustrt {\n-    use stackwalk::Word;\n-    use super::StackSegment;\n-\n-    #[link_name = \"rustrt\"]\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_gc_metadata() -> *Word;\n-\n-        pub fn rust_get_stack_segment() -> *StackSegment;\n-        pub fn rust_get_c_stack() -> *StackSegment;\n-    }\n-}\n-\n-unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n-    return ptr::offset(ptr, count as int) as *U;\n-}\n-\n-unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n-    let align = sys::min_align_of::<*T>();\n-    let ptr = ptr as uint;\n-    let ptr = (ptr + (align - 1)) & -align;\n-    return ptr as *T;\n-}\n-\n-unsafe fn get_safe_point_count() -> uint {\n-    let module_meta = rustrt::rust_gc_metadata();\n-    return *module_meta;\n-}\n-\n-struct SafePoint {\n-    sp_meta: *Word,\n-    fn_meta: *Word,\n-}\n-\n-// Returns the safe point metadata for the given program counter, if\n-// any.\n-unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n-    let module_meta = rustrt::rust_gc_metadata();\n-    let num_safe_points = *module_meta;\n-    let safe_points: *Word = bump(module_meta, 1);\n-\n-    if ptr::is_null(pc) {\n-        return None;\n-    }\n-\n-    // FIXME (#2997): Use binary rather than linear search.\n-    let mut spi = 0;\n-    while spi < num_safe_points {\n-        let sp: **Word = bump(safe_points, spi*3);\n-        let sp_loc = *sp;\n-        if sp_loc == pc {\n-            return Some(SafePoint {\n-                sp_meta: *bump(sp, 1),\n-                fn_meta: *bump(sp, 2),\n-            });\n-        }\n-        spi += 1;\n-    }\n-    return None;\n-}\n-\n-type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc);\n-\n-// Walks the list of roots for the given safe point, and calls visitor\n-// on each root.\n-unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    let fp_bytes = fp as *u8;\n-    let sp_meta = sp.sp_meta as *u32;\n-\n-    let num_stack_roots = *sp_meta as uint;\n-    let num_reg_roots = *ptr::offset(sp_meta, 1) as uint;\n-\n-    let stack_roots: *u32 = bump(sp_meta, 2);\n-    let reg_roots: *u8 = bump(stack_roots, num_stack_roots);\n-    let addrspaces: *Word = align_to_pointer(bump(reg_roots, num_reg_roots));\n-    let tydescs: ***TyDesc = bump(addrspaces, num_stack_roots);\n-\n-    // Stack roots\n-    let mut sri = 0;\n-    while sri < num_stack_roots {\n-        if *ptr::offset(addrspaces, sri as int) >= 1 {\n-            let root =\n-                ptr::offset(fp_bytes, *ptr::offset(stack_roots, sri as int) as int)\n-                as **Word;\n-            let tydescpp = ptr::offset(tydescs, sri as int);\n-            let tydesc = if ptr::is_not_null(tydescpp) &&\n-                ptr::is_not_null(*tydescpp) {\n-                **tydescpp\n-            } else {\n-                ptr::null()\n-            };\n-            visitor(root, tydesc);\n-        }\n-        sri += 1;\n-    }\n-\n-    // Register roots\n-    let mut rri = 0;\n-    while rri < num_reg_roots {\n-        if *ptr::offset(addrspaces, (num_stack_roots + rri) as int) == 1 {\n-            // FIXME(#2997): Need to find callee saved registers on the stack.\n-        }\n-        rri += 1;\n-    }\n-}\n-\n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    _walk_safe_point(fp, sp, visitor)\n-}\n-\n-// Is fp contained in segment?\n-unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n-    let begin = segment as Word;\n-    let end = (*segment).end as Word;\n-    let frame = fp as Word;\n-\n-    return begin <= frame && frame <= end;\n-}\n-\n-struct Segment { segment: *StackSegment, boundary: bool }\n-\n-// Find and return the segment containing the given frame pointer. At\n-// stack segment boundaries, returns true for boundary, so that the\n-// caller can do any special handling to identify where the correct\n-// return address is in the stack frame.\n-unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n-    -> Segment {\n-    // Check if frame is in either current frame or previous frame.\n-    let in_segment = is_frame_in_segment(fp, segment);\n-    let in_prev_segment = ptr::is_not_null((*segment).prev) &&\n-        is_frame_in_segment(fp, (*segment).prev);\n-\n-    // If frame is not in either segment, walk down segment list until\n-    // we find the segment containing this frame.\n-    if !in_segment && !in_prev_segment {\n-        let mut segment = segment;\n-        while ptr::is_not_null((*segment).next) &&\n-            is_frame_in_segment(fp, (*segment).next) {\n-            segment = (*segment).next;\n-        }\n-        return Segment {segment: segment, boundary: false};\n-    }\n-\n-    // If frame is in previous frame, then we're at a boundary.\n-    if !in_segment && in_prev_segment {\n-        return Segment {segment: (*segment).prev, boundary: true};\n-    }\n-\n-    // Otherwise, we're somewhere on the inside of the frame.\n-    return Segment {segment: segment, boundary: false};\n-}\n-\n-type Memory = uint;\n-\n-static task_local_heap: Memory = 1;\n-static exchange_heap:   Memory = 2;\n-static stack:           Memory = 4;\n-\n-static need_cleanup:    Memory = exchange_heap | stack;\n-\n-// Walks stack, searching for roots of the requested type, and passes\n-// each root to the visitor.\n-unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n-    let mut segment = rustrt::rust_get_stack_segment();\n-    let mut last_ret: *Word = ptr::null();\n-    // To avoid collecting memory used by the GC itself, skip stack\n-    // frames until past the root GC stack frame. The root GC stack\n-    // frame is marked by a sentinel, which is a box pointer stored on\n-    // the stack.\n-    let mut reached_sentinel = ptr::is_null(sentinel);\n-    do walk_stack |frame| {\n-        let pc = last_ret;\n-        let Segment {segment: next_segment, boundary: boundary} =\n-            find_segment_for_frame(frame.fp, segment);\n-        segment = next_segment;\n-        // Each stack segment is bounded by a morestack frame. The\n-        // morestack frame includes two return addresses, one for\n-        // morestack itself, at the normal offset from the frame\n-        // pointer, and then a second return address for the\n-        // function prologue (which called morestack after\n-        // determining that it had hit the end of the stack).\n-        // Since morestack itself takes two parameters, the offset\n-        // for this second return address is 3 greater than the\n-        // return address for morestack.\n-        let ret_offset = if boundary { 4 } else { 1 };\n-        last_ret = *ptr::offset(frame.fp, ret_offset as int) as *Word;\n-\n-        if !ptr::is_null(pc) {\n-\n-            let mut delay_reached_sentinel = reached_sentinel;\n-            let sp = is_safe_point(pc);\n-            match sp {\n-                Some(sp_info) => {\n-                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                        // Skip roots until we see the sentinel.\n-                        if !reached_sentinel && root == sentinel {\n-                            delay_reached_sentinel = true;\n-                        }\n-\n-                        // Skip null pointers, which can occur when a\n-                        // unique pointer has already been freed.\n-                        if reached_sentinel && !ptr::is_null(*root) {\n-                            if ptr::is_null(tydesc) {\n-                                // Root is a generic box.\n-                                let refcount = **root;\n-                                if mem | task_local_heap != 0 && refcount != -1 {\n-                                    visitor(root, tydesc);\n-                                } else if mem | exchange_heap != 0 && refcount == -1 {\n-                                    visitor(root, tydesc);\n-                                }\n-                            } else {\n-                                // Root is a non-immediate.\n-                                if mem | stack != 0 {\n-                                    visitor(root, tydesc);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                None => ()\n-            }\n-            reached_sentinel = delay_reached_sentinel;\n-        }\n-    }\n-}\n-\n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n-    _walk_gc_roots(mem, sentinel, visitor)\n-}\n-pub fn gc() {\n-    unsafe {\n-        // Abort when GC is disabled.\n-        if get_safe_point_count() == 0 {\n-            return;\n-        }\n-\n-        do walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n-            // FIXME(#2997): Walk roots and mark them.\n-            io::stdout().write([46]); // .\n-        }\n-    }\n-}\n-\n-#[cfg(gc)]\n-fn expect_sentinel() -> bool { true }\n-\n-#[cfg(nogc)]\n-fn expect_sentinel() -> bool { false }\n-\n-// Entry point for GC-based cleanup. Walks stack looking for exchange\n-// heap and stack allocations requiring drop, and runs all\n-// destructors.\n-//\n-// This should only be called from fail!, as it will drop the roots\n-// which are *live* on the stack, rather than dropping those that are\n-// dead.\n-pub fn cleanup_stack_for_failure() {\n-    unsafe {\n-        // Abort when GC is disabled.\n-        if get_safe_point_count() == 0 {\n-            return;\n-        }\n-\n-        // Leave a sentinel on the stack to mark the current frame. The\n-        // stack walker will ignore any frames above the sentinel, thus\n-        // avoiding collecting any memory being used by the stack walker\n-        // itself.\n-        //\n-        // However, when core itself is not compiled with GC, then none of\n-        // the functions in core will have GC metadata, which means we\n-        // won't be able to find the sentinel root on the stack. In this\n-        // case, we can safely skip the sentinel since we won't find our\n-        // own stack roots on the stack anyway.\n-        let sentinel_box = ~0;\n-        let sentinel: **Word = if expect_sentinel() {\n-            cast::transmute(&sentinel_box)\n-        } else {\n-            ptr::null()\n-        };\n-\n-        let mut roots = HashSet::new();\n-        do walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n-            // Track roots to avoid double frees.\n-            if !roots.contains(&*root) {\n-                roots.insert(*root);\n-\n-                if ptr::is_null(tydesc) {\n-                    // FIXME #4420: Destroy this box\n-                    // FIXME #4330: Destroy this box\n-                } else {\n-                    ((*tydesc).drop_glue)(*root as *i8);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "6e11d14aea9a316d069403083e9e97af069a6115", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -85,16 +85,6 @@ pub fn log_type<T>(level: u32, object: &T) {\n fn newsched_log_str(msg: ~str) {\n     use rt::task::Task;\n     use rt::local::Local;\n-    use str::StrSlice;\n-    use container::Container;\n-\n-    // Truncate the string\n-    let buf_bytes = 256;\n-    let msg = if msg.len() > buf_bytes {\n-        msg.slice(0, buf_bytes) + \"[...]\"\n-    } else {\n-        msg\n-    };\n \n     unsafe {\n         match Local::try_unsafe_borrow::<Task>() {"}, {"sha": "78f937e058a41bb43bbd19d075f072c91ac2fb73", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -868,47 +868,3 @@ pub mod rt {\n     pub fn make_some<T>(val: T) -> Option<T> { Some(val) }\n     pub fn make_none<T>() -> Option<T> { None }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use either::Right;\n-    use comm::{Chan, Port, oneshot, recv_one, stream, Select2,\n-               GenericChan, Peekable};\n-\n-    #[test]\n-    fn test_select2() {\n-        let (p1, c1) = stream();\n-        let (p2, c2) = stream();\n-\n-        c1.send(~\"abc\");\n-\n-        let mut tuple = (p1, p2);\n-        match tuple.select() {\n-            Right(_) => fail!(),\n-            _ => (),\n-        }\n-\n-        c2.send(123);\n-    }\n-\n-    #[test]\n-    fn test_oneshot() {\n-        let (p, c) = oneshot();\n-\n-        c.send(());\n-\n-        recv_one(p)\n-    }\n-\n-    #[test]\n-    fn test_peek_terminated() {\n-        let (port, chan): (Port<int>, Chan<int>) = stream();\n-\n-        {\n-            // Destroy the channel\n-            let _chan = chan;\n-        }\n-\n-        assert!(!port.peek());\n-    }\n-}"}, {"sha": "131507196b1f2558e61d6d7276ba1ca613f827c3", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -126,63 +126,72 @@ impl Local for IoFactoryObject {\n \n #[cfg(test)]\n mod test {\n+    use unstable::run_in_bare_thread;\n     use rt::test::*;\n     use super::*;\n     use rt::task::Task;\n     use rt::local_ptr;\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n     }\n \n     #[test]\n     fn thread_local_task_two_instances() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n \n     }\n \n     #[test]\n     fn borrow_smoke_test() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-\n-        unsafe {\n-            let _task: *mut Task = Local::unsafe_borrow();\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+\n+            unsafe {\n+                let _task: *mut Task = Local::unsafe_borrow();\n+            }\n+            let task: ~Task = Local::take();\n+            cleanup_task(task);\n         }\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n     }\n \n     #[test]\n     fn borrow_with_return() {\n-        local_ptr::init_tls_key();\n-        let mut sched = ~new_test_uv_sched();\n-        let task = ~Task::new_root(&mut sched.stack_pool, || {});\n-        Local::put(task);\n-\n-        let res = do Local::borrow::<Task,bool> |_task| {\n-            true\n-        };\n-        assert!(res)\n-        let task: ~Task = Local::take();\n-        cleanup_task(task);\n+        do run_in_bare_thread {\n+            local_ptr::init_tls_key();\n+            let mut sched = ~new_test_uv_sched();\n+            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            Local::put(task);\n+\n+            let res = do Local::borrow::<Task,bool> |_task| {\n+                true\n+            };\n+            assert!(res)\n+                let task: ~Task = Local::take();\n+            cleanup_task(task);\n+        }\n     }\n \n }"}, {"sha": "652e39b05c7e0eb15e18a5ac1368d9697195ccc1", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -52,7 +52,9 @@ pub unsafe fn put<T>(sched: ~T) {\n pub unsafe fn take<T>() -> ~T {\n     let key = tls_key();\n     let void_ptr: *mut c_void = tls::get(key);\n-    rtassert!(void_ptr.is_not_null());\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n     let ptr: ~T = cast::transmute(void_ptr);\n     tls::set(key, ptr::mut_null());\n     return ptr;\n@@ -68,8 +70,8 @@ pub fn exists() -> bool {\n     }\n }\n \n-/// Borrow the thread-local scheduler from thread-local storage.\n-/// While the scheduler is borrowed it is not available in TLS.\n+/// Borrow the thread-local value from thread-local storage.\n+/// While the value is borrowed it is not available in TLS.\n ///\n /// # Safety note\n ///\n@@ -88,21 +90,23 @@ pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n     }\n }\n \n-/// Borrow a mutable reference to the thread-local Scheduler\n+/// Borrow a mutable reference to the thread-local value\n ///\n /// # Safety Note\n ///\n-/// Because this leaves the Scheduler in thread-local storage it is possible\n+/// Because this leaves the value in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n pub unsafe fn unsafe_borrow<T>() -> *mut T {\n     let key = tls_key();\n-    let mut void_sched: *mut c_void = tls::get(key);\n-    rtassert!(void_sched.is_not_null());\n+    let mut void_ptr: *mut c_void = tls::get(key);\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n     {\n-        let sched: *mut *mut c_void = &mut void_sched;\n-        let sched: *mut ~T = sched as *mut ~T;\n-        let sched: *mut T = &mut **sched;\n-        return sched;\n+        let ptr: *mut *mut c_void = &mut void_ptr;\n+        let ptr: *mut ~T = ptr as *mut ~T;\n+        let ptr: *mut T = &mut **ptr;\n+        return ptr;\n     }\n }\n "}, {"sha": "117795f6c90e0ab49860e92cd73c6277fceea12a", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -10,6 +10,7 @@\n \n use either::*;\n use libc;\n+use str::StrSlice;\n \n pub trait Logger {\n     fn log(&mut self, msg: Either<~str, &'static str>);\n@@ -35,10 +36,22 @@ impl Logger for StdErrLogger {\n                 s\n             }\n         };\n-        let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-        dbg.write_str(s);\n-        dbg.write_str(\"\\n\");\n-        dbg.flush();\n+\n+        // Truncate the string\n+        let buf_bytes = 256;\n+        if s.len() > buf_bytes {\n+            let s = s.slice(0, buf_bytes) + \"[...]\";\n+            print(s);\n+        } else {\n+            print(s)\n+        };\n+\n+        fn print(s: &str) {\n+            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+            dbg.write_str(s);\n+            dbg.write_str(\"\\n\");\n+            dbg.flush();\n+        }\n     }\n }\n "}, {"sha": "33e83fd9040412936dc0d28db05a3d7709f6e22a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -432,13 +432,3 @@ pub fn context() -> RuntimeContext {\n         pub fn rust_try_get_task() -> *rust_task;\n     }\n }\n-\n-#[test]\n-fn test_context() {\n-    use unstable::run_in_bare_thread;\n-\n-    assert_eq!(context(), OldTaskContext);\n-    do run_in_bare_thread {\n-        assert_eq!(context(), GlobalContext);\n-    }\n-}"}, {"sha": "1a75f2569b59ea073303e18ca98451ac2cae0004", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -172,6 +172,10 @@ impl Scheduler {\n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n+        // Should not have any messages\n+        let message = stask.sched.get_mut_ref().message_queue.pop();\n+        assert!(message.is_none());\n+\n         stask.destroyed = true;\n     }\n \n@@ -335,19 +339,24 @@ impl Scheduler {\n         let mut this = self;\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n+                rtdebug!(\"got a task from a friend. lovely!\");\n                 return this.sched_schedule_task(task);\n             }\n             Some(Wake) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n                 this.sleepy = false;\n                 return Some(this);\n             }\n             Some(Shutdown) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n@@ -395,6 +404,7 @@ impl Scheduler {\n     /// Take a non-homed task we aren't allowed to run here and send\n     /// it to the designated friend scheduler to execute.\n     fn send_to_friend(&mut self, task: ~Task) {\n+        rtdebug!(\"sending a task to friend\");\n         match self.friend_handle {\n             Some(ref mut handle) => {\n                 handle.send(TaskFromFriend(task));\n@@ -426,12 +436,14 @@ impl Scheduler {\n                             Scheduler::send_task_home(task);\n                             return Some(this);\n                         } else {\n+                            this.event_loop.callback(Scheduler::run_sched_once);\n                             task.give_home(Sched(home_handle));\n                             this.resume_task_immediately(task);\n                             return None;\n                         }\n                     }\n                     AnySched if this.run_anything => {\n+                        this.event_loop.callback(Scheduler::run_sched_once);\n                         task.give_home(AnySched);\n                         this.resume_task_immediately(task);\n                         return None;"}, {"sha": "cb949edd7bb4a76e1ca00e02e12baa9bfd1a8ceb", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -228,6 +228,19 @@ impl Task {\n                     _ => ()\n                 }\n \n+                // FIXME #8302: Dear diary. I'm so tired and confused.\n+                // There's some interaction in rustc between the box\n+                // annihilator and the TLS dtor by which TLS is\n+                // accessed from annihilated box dtors *after* TLS is\n+                // destroyed. Somehow setting TLS back to null, as the\n+                // old runtime did, makes this work, but I don't currently\n+                // understand how. I would expect that, if the annihilator\n+                // reinvokes TLS while TLS is uninitialized, that\n+                // TLS would be reinitialized but never destroyed,\n+                // but somehow this works. I have no idea what's going\n+                // on but this seems to make things magically work. FML.\n+                self.storage = LocalStorage(ptr::null(), None);\n+\n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }\n             }\n@@ -303,7 +316,7 @@ impl Task {\n impl Drop for Task {\n     fn drop(&self) {\n         rtdebug!(\"called drop for a task: %u\", borrow::to_uint(self));\n-        assert!(self.destroyed)\n+        rtassert!(self.destroyed)\n     }\n }\n \n@@ -313,7 +326,7 @@ impl Drop for Task {\n impl Coroutine {\n \n     pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        static MIN_STACK_SIZE: uint = 2000000; // XXX: Too much stack\n+        static MIN_STACK_SIZE: uint = 3000000; // XXX: Too much stack\n \n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);"}, {"sha": "cc516fb559ea8babc701a824cdee94641073ef8f", "filename": "src/libstd/stackwalk.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Flibstd%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Flibstd%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstackwalk.rs?ref=fb9b27910b41e714dfd6b3ccc48161260943c9cf", "patch": "@@ -1,80 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use cast::transmute;\n-use unstable::intrinsics;\n-\n-pub type Word = uint;\n-\n-pub struct Frame {\n-    fp: *Word\n-}\n-\n-pub fn Frame(fp: *Word) -> Frame {\n-    Frame {\n-        fp: fp\n-    }\n-}\n-\n-pub fn walk_stack(visit: &fn(Frame)) {\n-\n-    debug!(\"beginning stack walk\");\n-\n-    do frame_address |frame_pointer| {\n-        let mut frame_address: *Word = unsafe {\n-            transmute(frame_pointer)\n-        };\n-        loop {\n-            let fr = Frame(frame_address);\n-\n-            debug!(\"frame: %x\", unsafe { transmute(fr.fp) });\n-            visit(fr);\n-\n-            unsafe {\n-                let next_fp: **Word = transmute(frame_address);\n-                frame_address = *next_fp;\n-                if *frame_address == 0u {\n-                    debug!(\"encountered task_start_wrapper. ending walk\");\n-                    // This is the task_start_wrapper_frame. There is\n-                    // no stack beneath it and it is a foreign frame.\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple() {\n-    do walk_stack |_frame| {\n-    }\n-}\n-\n-#[test]\n-fn test_simple_deep() {\n-    fn run(i: int) {\n-        if i == 0 { return }\n-\n-        do walk_stack |_frame| {\n-            // Would be nice to test something here...\n-        }\n-        run(i - 1);\n-    }\n-\n-    run(10);\n-}\n-\n-fn frame_address(f: &fn(x: *u8)) {\n-    unsafe {\n-        intrinsics::frame_address(f)\n-    }\n-}"}, {"sha": "236103ec886521b236c52e08b2da14bbae77ec36", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -170,7 +170,6 @@ pub mod local_data;\n \n /* Runtime and platform support */\n \n-pub mod gc;\n pub mod libc;\n pub mod c_str;\n pub mod os;\n@@ -197,7 +196,6 @@ pub mod unstable;\n mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n-mod stackwalk;\n \n // XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub."}, {"sha": "a77371bbfc925d8b18cb6f79aea55f022e4dbf99", "filename": "src/libstd/str.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -1068,7 +1068,7 @@ pub mod raw {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n         do s.as_mut_buf |buf, len| {\n-            *ptr::mut_offset(buf, len as int) = b;\n+            *ptr::mut_offset(buf, (len-1) as int) = b;\n         }\n         set_len(&mut *s, new_len);\n     }\n@@ -3080,6 +3080,13 @@ mod tests {\n         assert!(!\"   _   \".is_whitespace());\n     }\n \n+    #[test]\n+    fn test_push_byte() {\n+        let mut s = ~\"ABC\";\n+        unsafe{raw::push_byte(&mut s, 'D' as u8)};\n+        assert_eq!(s, ~\"ABCD\");\n+    }\n+\n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";"}, {"sha": "83ee4cf07c6a348e54656b8873a9e9a651e66432", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -14,7 +14,6 @@\n \n use c_str::ToCStr;\n use cast;\n-use gc;\n use io;\n use libc;\n use libc::{c_char, size_t};\n@@ -147,7 +146,6 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     match context {\n         OldTaskContext => {\n             unsafe {\n-                gc::cleanup_stack_for_failure();\n                 rustrt::rust_upcall_fail(msg, file, line);\n                 cast::transmute(())\n             }\n@@ -180,8 +178,6 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                              msg, file, line as int);\n                 }\n \n-                gc::cleanup_stack_for_failure();\n-\n                 let task = Local::unsafe_borrow::<Task>();\n                 if (*task).unwinder.unwinding {\n                     rtabort!(\"unwinding again\");"}, {"sha": "3c5c7644bebf7ec00112c794b774cf4a1e9ed3f5", "filename": "src/rt/arch/arm/record_sp.S", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Frecord_sp.S?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -14,22 +14,36 @@\n .globl get_sp\n \n record_sp_limit:\n+\t// First, try to read TLS address from coprocessor\n \tmrc p15, #0, r3, c13, c0, #3\n+\tcmp r3, #0\n+\t// Otherwise, try to read from magic address 0xFFFF0FF0\n+\tmvneq r3, #0xF000\n+\tldreq r3, [r3, #-15]\n+\n #if __ANDROID__\n \tadd r3, r3, #252\n #elif __linux__\n \tadd r3, r3, #4\n #endif\n+\n \tstr r0, [r3]\n \tmov pc, lr\n \n get_sp_limit:\n+\t// First, try to read TLS address from coprocessor\n \tmrc p15, #0, r3, c13, c0, #3\n+\tcmp r3, #0\n+\t// Otherwise, try to read from magic address 0xFFFF0FF0\n+\tmvneq r3, #0xF000\n+\tldreq r3, [r3, #-15]\n+\n #if __ANDROID__\n \tadd r3, r3, #252\n #elif __linux__\n \tadd r3, r3, #4\n #endif\n+\n \tldr r0, [r3]\n \tmov pc, lr\n "}, {"sha": "57bf33fb2fdacdc26e8c7920dc4034a9b6294f30", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern mod extra;\n-use extra::arena;\n+use extra::arena::Arena;\n \n enum Tree<'self> {\n     Nil,\n@@ -25,7 +25,7 @@ fn item_check(t: &Tree) -> int {\n     }\n }\n \n-fn bottom_up_tree<'r>(arena: &'r arena::Arena, item: int, depth: int)\n+fn bottom_up_tree<'r>(arena: &'r Arena, item: int, depth: int)\n                    -> &'r Tree<'r> {\n     if depth > 0 {\n         return arena.alloc(\n@@ -57,15 +57,15 @@ fn main() {\n         max_depth = n;\n     }\n \n-    let stretch_arena = arena::Arena();\n+    let stretch_arena = Arena::new();\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(&stretch_arena, 0, stretch_depth);\n \n     printfln!(\"stretch tree of depth %d\\t check: %d\",\n               stretch_depth,\n               item_check(stretch_tree));\n \n-    let long_lived_arena = arena::Arena();\n+    let long_lived_arena = Arena::new();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n     let mut depth = min_depth;\n     while depth <= max_depth {"}, {"sha": "df242ee3d3059613093a971667f100ea3ca798de", "filename": "src/test/run-pass/issue-3176.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9b27910b41e714dfd6b3ccc48161260943c9cf/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=fb9b27910b41e714dfd6b3ccc48161260943c9cf", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// xfail-win32 #7999\n-\n-use std::comm::{Select2, Selectable};\n-use std::comm;\n-use std::task;\n-\n-pub fn main() {\n-    let (p,c) = comm::stream();\n-    do task::try || {\n-        let (p2,c2) = comm::stream();\n-        do task::spawn || {\n-            p2.recv();\n-            error!(\"sibling fails\");\n-            fail!();\n-        }\n-        let (p3,c3) = comm::stream();\n-        c.send(c3);\n-        c2.send(());\n-        error!(\"child blocks\");\n-        let (p, c) = comm::stream();\n-        let mut tuple = (p, p3);\n-        tuple.select();\n-        c.send(());\n-    };\n-    error!(\"parent tries\");\n-    assert!(!p.recv().try_send(()));\n-    error!(\"all done!\");\n-}"}, {"sha": "f2063b583e4f9b0cf6b7f7a0874dc1a8276a5e27", "filename": "src/test/run-pass/placement-new-arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8567611adfa69c4488133e18d3ec4fc195afadd1/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs?ref=8567611adfa69c4488133e18d3ec4fc195afadd1", "patch": "@@ -11,10 +11,10 @@\n // except according to those terms.\n \n extern mod extra;\n-use extra::arena;\n+use extra::arena::Arena;\n \n pub fn main() {\n-    let mut arena = arena::Arena();\n+    let mut arena = Arena::new();\n     let p = &mut arena;\n     let x = p.alloc(|| 4u);\n     printf!(\"%u\", *x);"}]}