{"sha": "ea07b969eacb4d932afba25ad64050719c7fe73a", "node_id": "C_kwDOAAsO6NoAKGVhMDdiOTY5ZWFjYjRkOTMyYWZiYTI1YWQ2NDA1MDcxOWM3ZmU3M2E", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-25T13:14:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-25T13:14:13Z"}, "message": "Rollup merge of #98429 - b-naber:use-correct-substs-discriminant-cast, r=lcnr\n\nUse correct substs in enum discriminant cast\n\nFixes https://github.com/rust-lang/rust/issues/97634\n\nr? ```@lcnr```", "tree": {"sha": "3ffa8b17834b14cf732e24ec2227872840cccce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ffa8b17834b14cf732e24ec2227872840cccce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea07b969eacb4d932afba25ad64050719c7fe73a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitwolCRBK7hj4Ov3rIwAAX04IADrgdw/ScdeeRZnzmbP6wweV\ntWZ22DqfRvJdFWhQOYwczqKAxMGYiE2H6YGiOerHYDgG+s+5AO9oLYqw/HTSRH2+\nICBA/FVMtzkgVztuji/l589toZT/j2s76ev3kqMbIjSoj2PeiLO03MdUXwzCS1xZ\n/1oKCZaHjEYVmPd72Me3ZCawvpWvQ7ivt5WfZft2ffbwsSep5t1kKKWWshEWoZkA\njy2jgRddfIH1YXmw5Kqemhj4Ec1JuVkJamSXJzZzDbwHUA4YwtSoyz6b/zyhmVwD\nAXYzxXtzC49jsdSp+pMGUEV4djrDh1XqB0SeL9O9WEa8fEkHcrzMss442LuHTf0=\n=nRHP\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ffa8b17834b14cf732e24ec2227872840cccce7\nparent 95ba108b6058791661870f7c3b8438164cf2ad35\nparent bf48b622a5ff7efc16ac099bbe8d272445a49d70\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656162853 +0200\ncommitter GitHub <noreply@github.com> 1656162853 +0200\n\nRollup merge of #98429 - b-naber:use-correct-substs-discriminant-cast, r=lcnr\n\nUse correct substs in enum discriminant cast\n\nFixes https://github.com/rust-lang/rust/issues/97634\n\nr? ```@lcnr```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea07b969eacb4d932afba25ad64050719c7fe73a", "html_url": "https://github.com/rust-lang/rust/commit/ea07b969eacb4d932afba25ad64050719c7fe73a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea07b969eacb4d932afba25ad64050719c7fe73a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95ba108b6058791661870f7c3b8438164cf2ad35", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ba108b6058791661870f7c3b8438164cf2ad35", "html_url": "https://github.com/rust-lang/rust/commit/95ba108b6058791661870f7c3b8438164cf2ad35"}, {"sha": "bf48b622a5ff7efc16ac099bbe8d272445a49d70", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf48b622a5ff7efc16ac099bbe8d272445a49d70", "html_url": "https://github.com/rust-lang/rust/commit/bf48b622a5ff7efc16ac099bbe8d272445a49d70"}], "stats": {"total": 196, "additions": 104, "deletions": 92}, "files": [{"sha": "08b66d0abc70241e3b01132f75e85dd6fb51437d", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 94, "deletions": 92, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ea07b969eacb4d932afba25ad64050719c7fe73a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea07b969eacb4d932afba25ad64050719c7fe73a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=ea07b969eacb4d932afba25ad64050719c7fe73a", "patch": "@@ -1,3 +1,4 @@\n+use crate::thir::cx::region::Scope;\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -158,6 +159,98 @@ impl<'tcx> Cx<'tcx> {\n         Expr { temp_lifetime, ty: adjustment.target, span, kind }\n     }\n \n+    /// Lowers a cast expression.\n+    ///\n+    /// Dealing with user type annotations is left to the caller.\n+    fn mirror_expr_cast(\n+        &mut self,\n+        source: &'tcx hir::Expr<'tcx>,\n+        temp_lifetime: Option<Scope>,\n+        span: Span,\n+    ) -> ExprKind<'tcx> {\n+        let tcx = self.tcx;\n+\n+        // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n+        // using a coercion (or is a no-op).\n+        if self.typeck_results().is_coercion_cast(source.hir_id) {\n+            // Convert the lexpr to a vexpr.\n+            ExprKind::Use { source: self.mirror_expr(source) }\n+        } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+            // Special cased so that we can type check that the element\n+            // type of the source matches the pointed to type of the\n+            // destination.\n+            ExprKind::Pointer {\n+                source: self.mirror_expr(source),\n+                cast: PointerCast::ArrayToPointer,\n+            }\n+        } else {\n+            // check whether this is casting an enum variant discriminant\n+            // to prevent cycles, we refer to the discriminant initializer\n+            // which is always an integer and thus doesn't need to know the\n+            // enum's layout (or its tag type) to compute it during const eval\n+            // Example:\n+            // enum Foo {\n+            //     A,\n+            //     B = A as isize + 4,\n+            // }\n+            // The correct solution would be to add symbolic computations to miri,\n+            // so we wouldn't have to compute and store the actual value\n+\n+            let hir::ExprKind::Path(ref qpath) = source.kind else {\n+                return ExprKind::Cast { source: self.mirror_expr(source)};\n+            };\n+\n+            let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n+            let ty = self.typeck_results().node_type(source.hir_id);\n+            let ty::Adt(adt_def, substs) = ty.kind() else {\n+                return ExprKind::Cast { source: self.mirror_expr(source)};\n+            };\n+\n+            let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), variant_ctor_id) = res else {\n+                return ExprKind::Cast { source: self.mirror_expr(source)};\n+            };\n+\n+            let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n+            let (discr_did, discr_offset) = adt_def.discriminant_def_for_variant(idx);\n+\n+            use rustc_middle::ty::util::IntTypeExt;\n+            let ty = adt_def.repr().discr_type();\n+            let discr_ty = ty.to_ty(tcx);\n+\n+            let param_env_ty = self.param_env.and(discr_ty);\n+            let size = tcx\n+                .layout_of(param_env_ty)\n+                .unwrap_or_else(|e| {\n+                    panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n+                })\n+                .size;\n+\n+            let lit = ScalarInt::try_from_uint(discr_offset as u128, size).unwrap();\n+            let kind = ExprKind::NonHirLiteral { lit, user_ty: None };\n+            let offset = self.thir.exprs.push(Expr { temp_lifetime, ty: discr_ty, span, kind });\n+\n+            let source = match discr_did {\n+                // in case we are offsetting from a computed discriminant\n+                // and not the beginning of discriminants (which is always `0`)\n+                Some(did) => {\n+                    let kind = ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n+                    let lhs =\n+                        self.thir.exprs.push(Expr { temp_lifetime, ty: discr_ty, span, kind });\n+                    let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n+                    self.thir.exprs.push(Expr {\n+                        temp_lifetime,\n+                        ty: discr_ty,\n+                        span: span,\n+                        kind: bin,\n+                    })\n+                }\n+                None => offset,\n+            };\n+\n+            ExprKind::Cast { source }\n+        }\n+    }\n+\n     fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n         let tcx = self.tcx;\n         let expr_ty = self.typeck_results().expr_ty(expr);\n@@ -604,98 +697,7 @@ impl<'tcx> Cx<'tcx> {\n                     expr, cast_ty.hir_id, user_ty,\n                 );\n \n-                // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n-                // using a coercion (or is a no-op).\n-                let cast = if self.typeck_results().is_coercion_cast(source.hir_id) {\n-                    // Convert the lexpr to a vexpr.\n-                    ExprKind::Use { source: self.mirror_expr(source) }\n-                } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n-                    // Special cased so that we can type check that the element\n-                    // type of the source matches the pointed to type of the\n-                    // destination.\n-                    ExprKind::Pointer {\n-                        source: self.mirror_expr(source),\n-                        cast: PointerCast::ArrayToPointer,\n-                    }\n-                } else {\n-                    // check whether this is casting an enum variant discriminant\n-                    // to prevent cycles, we refer to the discriminant initializer\n-                    // which is always an integer and thus doesn't need to know the\n-                    // enum's layout (or its tag type) to compute it during const eval\n-                    // Example:\n-                    // enum Foo {\n-                    //     A,\n-                    //     B = A as isize + 4,\n-                    // }\n-                    // The correct solution would be to add symbolic computations to miri,\n-                    // so we wouldn't have to compute and store the actual value\n-                    let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n-                        let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n-                        self.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(\n-                            |adt_def| match res {\n-                                Res::Def(\n-                                    DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n-                                    variant_ctor_id,\n-                                ) => {\n-                                    let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n-                                    let (d, o) = adt_def.discriminant_def_for_variant(idx);\n-                                    use rustc_middle::ty::util::IntTypeExt;\n-                                    let ty = adt_def.repr().discr_type();\n-                                    let ty = ty.to_ty(tcx);\n-                                    Some((d, o, ty))\n-                                }\n-                                _ => None,\n-                            },\n-                        )\n-                    } else {\n-                        None\n-                    };\n-\n-                    let source = if let Some((did, offset, var_ty)) = var {\n-                        let param_env_ty = self.param_env.and(var_ty);\n-                        let size = tcx\n-                            .layout_of(param_env_ty)\n-                            .unwrap_or_else(|e| {\n-                                panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n-                            })\n-                            .size;\n-                        let lit = ScalarInt::try_from_uint(offset as u128, size).unwrap();\n-                        let kind = ExprKind::NonHirLiteral { lit, user_ty: None };\n-                        let offset = self.thir.exprs.push(Expr {\n-                            temp_lifetime,\n-                            ty: var_ty,\n-                            span: expr.span,\n-                            kind,\n-                        });\n-                        match did {\n-                            Some(did) => {\n-                                // in case we are offsetting from a computed discriminant\n-                                // and not the beginning of discriminants (which is always `0`)\n-                                let substs = InternalSubsts::identity_for_item(tcx, did);\n-                                let kind =\n-                                    ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n-                                let lhs = self.thir.exprs.push(Expr {\n-                                    temp_lifetime,\n-                                    ty: var_ty,\n-                                    span: expr.span,\n-                                    kind,\n-                                });\n-                                let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n-                                self.thir.exprs.push(Expr {\n-                                    temp_lifetime,\n-                                    ty: var_ty,\n-                                    span: expr.span,\n-                                    kind: bin,\n-                                })\n-                            }\n-                            None => offset,\n-                        }\n-                    } else {\n-                        self.mirror_expr(source)\n-                    };\n-\n-                    ExprKind::Cast { source: source }\n-                };\n+                let cast = self.mirror_expr_cast(*source, temp_lifetime, expr.span);\n \n                 if let Some(user_ty) = user_ty {\n                     // NOTE: Creating a new Expr and wrapping a Cast inside of it may be"}, {"sha": "422e8de6856457d4cc70a9656abc501e2a218209", "filename": "src/test/ui/const-generics/issues/issue-97634.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea07b969eacb4d932afba25ad64050719c7fe73a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-97634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea07b969eacb4d932afba25ad64050719c7fe73a/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-97634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-97634.rs?ref=ea07b969eacb4d932afba25ad64050719c7fe73a", "patch": "@@ -0,0 +1,10 @@\n+// build-pass\n+\n+pub enum Register<const N: u16> {\n+    Field0 = 40,\n+    Field1,\n+}\n+\n+fn main() {\n+    let _b = Register::<0>::Field1 as u16;\n+}"}]}