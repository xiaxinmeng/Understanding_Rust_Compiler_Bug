{"sha": "b00050f4cf7d602566afd511b66ae6645f92987d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMDA1MGY0Y2Y3ZDYwMjU2NmFmZDUxMWI2NmFlNjY0NWY5Mjk4N2Q=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-01T16:56:06Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-02T18:44:27Z"}, "message": "Add more safeguards to \"missing binding mode\" errors", "tree": {"sha": "f68e58f06e1bf93534413f1f3f241f94a1d734b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f68e58f06e1bf93534413f1f3f241f94a1d734b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00050f4cf7d602566afd511b66ae6645f92987d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00050f4cf7d602566afd511b66ae6645f92987d", "html_url": "https://github.com/rust-lang/rust/commit/b00050f4cf7d602566afd511b66ae6645f92987d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00050f4cf7d602566afd511b66ae6645f92987d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998141f8ef8225704f8641ef0372c686bcbd2c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/998141f8ef8225704f8641ef0372c686bcbd2c5f", "html_url": "https://github.com/rust-lang/rust/commit/998141f8ef8225704f8641ef0372c686bcbd2c5f"}], "stats": {"total": 128, "additions": 67, "deletions": 61}, "files": [{"sha": "a83aa47fd4f13ff2826715f7a0e46f19ee38488c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b00050f4cf7d602566afd511b66ae6645f92987d", "patch": "@@ -840,6 +840,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n+        let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n@@ -849,34 +850,36 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     pat,\n                     match_mode,\n                 );\n-                let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n-                                                     .expect(\"missing binding mode\");\n-                debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-\n-                // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n-                debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n-\n-                // Each match binding is effectively an assignment to the\n-                // binding being produced.\n-                let def = Def::Local(canonical_id);\n-                if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n-                    delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n-                }\n+                if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n+                    debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+\n+                    // pat_ty: the type of the binding being produced.\n+                    let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n+                    debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n+\n+                    // Each match binding is effectively an assignment to the\n+                    // binding being produced.\n+                    let def = Def::Local(canonical_id);\n+                    if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                    }\n \n-                // It is also a borrow or copy/move of the value being matched.\n-                match bm {\n-                    ty::BindByReference(m) => {\n-                        if let ty::TyRef(r, _, _) = pat_ty.sty {\n-                            let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                    // It is also a borrow or copy/move of the value being matched.\n+                    match bm {\n+                        ty::BindByReference(m) => {\n+                            if let ty::TyRef(r, _, _) = pat_ty.sty {\n+                                let bk = ty::BorrowKind::from_mutbl(m);\n+                                delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                            }\n+                        }\n+                        ty::BindByValue(..) => {\n+                            let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n+                            debug!(\"walk_pat binding consuming pat\");\n+                            delegate.consume_pat(pat, &cmt_pat, mode);\n                         }\n                     }\n-                    ty::BindByValue(..) => {\n-                        let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n-                        debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, &cmt_pat, mode);\n-                    }\n+                } else {\n+                    tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));"}, {"sha": "475ff0b744349abfb01cd4ef6f959705fe0f864f", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=b00050f4cf7d602566afd511b66ae6645f92987d", "patch": "@@ -54,16 +54,16 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n \n                 // Skip anything that looks like `&foo` or `&mut foo`, only look\n                 // for by-value bindings\n-                let bm = match self.bccx.tables.pat_binding_modes().get(hir_id) {\n-                    Some(&bm) => bm,\n-                    None => span_bug!(span, \"missing binding mode\"),\n-                };\n-                match bm {\n-                    ty::BindByValue(hir::MutMutable) => {}\n-                    _ => return,\n+                if let Some(&bm) = self.bccx.tables.pat_binding_modes().get(hir_id) {\n+                    match bm {\n+                        ty::BindByValue(hir::MutMutable) => {}\n+                        _ => return,\n+                    }\n+\n+                    mutables.entry(ident.name).or_insert(Vec::new()).push((hir_id, span));\n+                } else {\n+                    tcx.sess.delay_span_bug(span, \"missing binding mode\");\n                 }\n-\n-                mutables.entry(ident.name).or_insert(Vec::new()).push((hir_id, span));\n             });\n         }\n "}, {"sha": "cdf0079e2ae83eb72d243258a4182401cefdd7f0", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b00050f4cf7d602566afd511b66ae6645f92987d", "patch": "@@ -541,13 +541,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n \n-                    let bm = *hir.tables.pat_binding_modes()\n-                                        .get(pat.hir_id)\n-                                        .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(hir::MutMutable) {\n-                        decl.mutability = Mutability::Mut;\n+                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                        if bm == ty::BindByValue(hir::MutMutable) {\n+                            decl.mutability = Mutability::Mut;\n+                        } else {\n+                            decl.mutability = Mutability::Not;\n+                        }\n                     } else {\n-                        decl.mutability = Mutability::Not;\n+                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n             }"}, {"sha": "18ae7c7745915ad4bab2c9cffceee4566089dc64", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b00050f4cf7d602566afd511b66ae6645f92987d", "patch": "@@ -516,12 +516,12 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     let mut by_ref_span = None;\n     for pat in pats {\n         pat.each_binding(|_, hir_id, span, _path| {\n-            let bm = *cx.tables\n-                        .pat_binding_modes()\n-                        .get(hir_id)\n-                        .expect(\"missing binding mode\");\n-            if let ty::BindByReference(..) = bm {\n-                by_ref_span = Some(span);\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n+                if let ty::BindByReference(..) = bm {\n+                    by_ref_span = Some(span);\n+                }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n         })\n     }\n@@ -552,18 +552,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                let bm = *cx.tables\n-                            .pat_binding_modes()\n-                            .get(p.hir_id)\n-                            .expect(\"missing binding mode\");\n-                match bm {\n-                    ty::BindByValue(..) => {\n-                        let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n-                        if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n-                            check_move(p, sub.as_ref().map(|p| &**p));\n+                if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                    match bm {\n+                        ty::BindByValue(..) => {\n+                            let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n+                            if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                                check_move(p, sub.as_ref().map(|p| &**p));\n+                            }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n+                } else {\n+                    cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n             true"}, {"sha": "68fcde0b1657aa5ed983e7fb371eec3fd1bb0b49", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00050f4cf7d602566afd511b66ae6645f92987d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b00050f4cf7d602566afd511b66ae6645f92987d", "patch": "@@ -1039,11 +1039,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n-                        let bm = *mc.tables.pat_binding_modes().get(sub_pat.hir_id)\n-                                                               .expect(\"missing binding mode\");\n-                        if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                            mutbl, &sub_cmt);\n+                        if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n+                            if let ty::BindByReference(mutbl) = bm {\n+                                self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n+                                                                mutbl, &sub_cmt);\n+                            }\n+                        } else {\n+                            self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n                         }\n                     }\n                     _ => {}"}]}