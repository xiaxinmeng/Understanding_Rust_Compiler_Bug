{"sha": "076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NmI5MWY4YWQ5Y2U1YmJlYmM1NjkwYjZlZjlhMWZmMTYyZjVlZmI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-07T19:40:09Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-11T06:51:20Z"}, "message": "add intrinsics for checked overflow add/sub/mul", "tree": {"sha": "e06a7814729ead789d15b647770a765660acd400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e06a7814729ead789d15b647770a765660acd400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "html_url": "https://github.com/rust-lang/rust/commit/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebcff1493a98524e72bbf0c79b004fc286d58d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eebcff1493a98524e72bbf0c79b004fc286d58d7", "html_url": "https://github.com/rust-lang/rust/commit/eebcff1493a98524e72bbf0c79b004fc286d58d7"}], "stats": {"total": 671, "additions": 663, "deletions": 8}, "files": [{"sha": "d1b8da85440214c0c49efdb47bccacb5ff660947", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -2740,6 +2740,60 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n     ifn!(\"llvm.bswap.i32\",[Type::i32()], Type::i32());\n     ifn!(\"llvm.bswap.i64\",[Type::i64()], Type::i64());\n \n+    ifn!(\"llvm.sadd.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.sadd.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.sadd.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.sadd.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.uadd.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.uadd.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.uadd.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.ssub.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.ssub.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.ssub.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.usub.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.usub.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.usub.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.smul.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.smul.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.smul.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\",\n+        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n+    ifn!(\"llvm.umul.with.overflow.i16\",\n+        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n+    ifn!(\"llvm.umul.with.overflow.i32\",\n+        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n+    ifn!(\"llvm.umul.with.overflow.i64\",\n+        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n+\n     return intrinsics;\n }\n "}, {"sha": "dab970569212e8568e0e336cb05659c122f7cc24", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -714,9 +714,11 @@ pub fn ExtractValue(cx: @mut Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     }\n }\n \n-pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) {\n-    if cx.unreachable { return; }\n-    B(cx).insert_value(AggVal, EltVal, Index)\n+pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n+    unsafe {\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        B(cx).insert_value(AggVal, EltVal, Index)\n+    }\n }\n \n pub fn IsNull(cx: @mut Block, Val: ValueRef) -> ValueRef {"}, {"sha": "5c216b2e14346684620185f0213be2666003b9b0", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -861,11 +861,11 @@ impl Builder {\n     }\n \n     pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: uint) {\n+                       idx: uint) -> ValueRef {\n         self.count_insn(\"insertvalue\");\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n-                                       noname());\n+                                       noname())\n         }\n     }\n "}, {"sha": "96616cbe533ba8fb5e9974ca42683ad5abc7a529", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -238,7 +238,7 @@ impl FunctionContext {\n     }\n \n     pub fn out_arg_pos(&self) -> uint {\n-        assert!(self.has_immediate_return_value);\n+        assert!(!self.has_immediate_return_value);\n         0u\n     }\n "}, {"sha": "2bf483ee3a019bd5f839c5b3f6150a42cb698aa6", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -550,6 +550,24 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n     }\n \n+    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let a = get_param(bcx.fcx.llfn, first_real_arg);\n+        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+\n+        // convert `i1` to a `bool`, and write to the out parameter\n+        let val = Call(bcx, llfn, [a, b]);\n+        let result = ExtractValue(bcx, val, 0);\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n+        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n+        let ret = Load(bcx, retptr);\n+        let ret = InsertValue(bcx, ret, result, 0);\n+        let ret = InsertValue(bcx, ret, overflow, 1);\n+        Store(bcx, ret, retptr);\n+        RetVoid(bcx)\n+    }\n+\n     fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -944,6 +962,37 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n         \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n         \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n+\n+        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n+        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n+        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n+        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n+\n+        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n+        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n+        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n+        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n+\n+        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n+        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n+        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n+        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n+\n+        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n+        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n+        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n+        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n+\n+        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n+        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n+        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n+        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n+\n+        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n+        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n+        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n+        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n+\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?"}, {"sha": "74661098348e671245ade9ace4f121a2503ed334", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -168,6 +168,22 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n \n                     \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n \n+\n+                    \"i8_add_with_overflow\"  | \"u8_add_with_overflow\" |\n+                    \"i16_add_with_overflow\" | \"u16_add_with_overflow\" |\n+                    \"i32_add_with_overflow\" | \"u32_add_with_overflow\" |\n+                    \"i64_add_with_overflow\" | \"u64_add_with_overflow\" => 0,\n+\n+                    \"i8_sub_with_overflow\"  | \"u8_sub_with_overflow\" |\n+                    \"i16_sub_with_overflow\" | \"u16_sub_with_overflow\" |\n+                    \"i32_sub_with_overflow\" | \"u32_sub_with_overflow\" |\n+                    \"i64_sub_with_overflow\" | \"u64_sub_with_overflow\" => 0,\n+\n+                    \"i8_mul_with_overflow\"  | \"u8_mul_with_overflow\" |\n+                    \"i16_mul_with_overflow\" | \"u16_mul_with_overflow\" |\n+                    \"i32_mul_with_overflow\" | \"u32_mul_with_overflow\" |\n+                    \"i64_mul_with_overflow\" | \"u64_mul_with_overflow\" => 0,\n+\n                     // would be cool to make these an enum instead of\n                     // strings!\n                     _ => fail!(\"unknown intrinsic in type_use\")"}, {"sha": "1b4d3ccbb34e27f9158592cb0746b1f890d5d4d9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -3647,6 +3647,39 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n             \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n             \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+\n+            \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n+                (0, ~[ty::mk_i8(), ty::mk_i8()],\n+                ty::mk_tup(tcx, ~[ty::mk_i8(), ty::mk_bool()])),\n+\n+            \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n+                (0, ~[ty::mk_i16(), ty::mk_i16()],\n+                ty::mk_tup(tcx, ~[ty::mk_i16(), ty::mk_bool()])),\n+\n+            \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n+                (0, ~[ty::mk_i32(), ty::mk_i32()],\n+                ty::mk_tup(tcx, ~[ty::mk_i32(), ty::mk_bool()])),\n+\n+            \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n+                (0, ~[ty::mk_i64(), ty::mk_i64()],\n+                ty::mk_tup(tcx, ~[ty::mk_i64(), ty::mk_bool()])),\n+\n+            \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n+                (0, ~[ty::mk_u8(), ty::mk_u8()],\n+                ty::mk_tup(tcx, ~[ty::mk_u8(), ty::mk_bool()])),\n+\n+            \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n+                (0, ~[ty::mk_u16(), ty::mk_u16()],\n+                ty::mk_tup(tcx, ~[ty::mk_u16(), ty::mk_bool()])),\n+\n+            \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n+                (0, ~[ty::mk_u32(), ty::mk_u32()],\n+                ty::mk_tup(tcx, ~[ty::mk_u32(), ty::mk_bool()])),\n+\n+            \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n+                (0, ~[ty::mk_u64(), ty::mk_u64()],\n+                ty::mk_tup(tcx, ~[ty::mk_u64(), ty::mk_bool()])),\n+\n             ref other => {\n                 tcx.sess.span_err(it.span,\n                                   fmt!(\"unrecognized intrinsic function: `%s`\","}, {"sha": "f0c432ce2ebb54b431b437cf6cb40d4f4900fceb", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 448, "deletions": 1, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -18,7 +18,9 @@\n use cmp::{Eq, ApproxEq, Ord};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-use option::Option;\n+use option::{Option, Some, None};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics;\n \n pub mod strconv;\n \n@@ -516,6 +518,414 @@ impl Saturating for u16 {}\n impl Saturating for u32 {}\n impl Saturating for u64 {}\n \n+pub trait CheckedAdd: Add<Self, Self> {\n+    fn checked_add(&self, v: &Self) -> Option<Self>;\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for i8 {\n+    #[inline]\n+    fn checked_add(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for i16 {\n+    #[inline]\n+    fn checked_add(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for i32 {\n+    #[inline]\n+    fn checked_add(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for i64 {\n+    #[inline]\n+    fn checked_add(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for u8 {\n+    #[inline]\n+    fn checked_add(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for u16 {\n+    #[inline]\n+    fn checked_add(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for u32 {\n+    #[inline]\n+    fn checked_add(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedAdd for u64 {\n+    #[inline]\n+    fn checked_add(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+pub trait CheckedSub: Sub<Self, Self> {\n+    fn checked_sub(&self, v: &Self) -> Option<Self>;\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for i8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for i16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for i32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for i64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for u8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for u16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for u32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedSub for u64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+pub trait CheckedMul: Mul<Self, Self> {\n+    fn checked_mul(&self, v: &Self) -> Option<Self>;\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for i8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for i16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for i32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for i64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for u8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for u16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for u32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl CheckedMul for u64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"32\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0), target_word_size = \"64\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n@@ -534,6 +944,8 @@ pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::*;\n+    use uint;\n     use super::*;\n \n     macro_rules! test_cast_20(\n@@ -639,4 +1051,39 @@ mod tests {\n         assert_eq!(max_value.saturating_sub(-max_value), max_value);\n         assert_eq!((max_value-2).saturating_sub(-1), max_value-1);\n     }\n+\n+    #[test]\n+    fn test_checked_add() {\n+        let five_less = uint::max_value - 5;\n+        assert_eq!(five_less.checked_add(&0), Some(uint::max_value - 5));\n+        assert_eq!(five_less.checked_add(&1), Some(uint::max_value - 4));\n+        assert_eq!(five_less.checked_add(&2), Some(uint::max_value - 3));\n+        assert_eq!(five_less.checked_add(&3), Some(uint::max_value - 2));\n+        assert_eq!(five_less.checked_add(&4), Some(uint::max_value - 1));\n+        assert_eq!(five_less.checked_add(&5), Some(uint::max_value));\n+        assert_eq!(five_less.checked_add(&6), None);\n+        assert_eq!(five_less.checked_add(&7), None);\n+    }\n+\n+    #[test]\n+    fn test_checked_sub() {\n+        assert_eq!(5u.checked_sub(&0), Some(5));\n+        assert_eq!(5u.checked_sub(&1), Some(4));\n+        assert_eq!(5u.checked_sub(&2), Some(3));\n+        assert_eq!(5u.checked_sub(&3), Some(2));\n+        assert_eq!(5u.checked_sub(&4), Some(1));\n+        assert_eq!(5u.checked_sub(&5), Some(0));\n+        assert_eq!(5u.checked_sub(&6), None);\n+        assert_eq!(5u.checked_sub(&7), None);\n+    }\n+\n+    #[test]\n+    fn test_checked_mul() {\n+        let third = uint::max_value / 3;\n+        assert_eq!(third.checked_mul(&0), Some(0));\n+        assert_eq!(third.checked_mul(&1), Some(third));\n+        assert_eq!(third.checked_mul(&2), Some(third * 2));\n+        assert_eq!(third.checked_mul(&3), Some(third * 3));\n+        assert_eq!(third.checked_mul(&4), None);\n+    }\n }"}, {"sha": "93e14be582b603147f489c2f319019fc37fd872b", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -53,7 +53,7 @@ pub use iter::Times;\n pub use iterator::Extendable;\n pub use iterator::{Iterator, DoubleEndedIterator};\n pub use iterator::{ClonableIterator, OrdIterator};\n-pub use num::{Num, NumCast};\n+pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n pub use num::{Integer, Fractional, Real, RealExt};"}, {"sha": "9f69ee47e9bd68f981367873dcf51fba07c0f346", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=076b91f8ad9ce5bbebc5690b6ef9a1ff162f5efb", "patch": "@@ -428,6 +428,60 @@ extern \"rust-intrinsic\" {\n     pub fn bswap16(x: i16) -> i16;\n     pub fn bswap32(x: i32) -> i32;\n     pub fn bswap64(x: i64) -> i64;\n+\n+    #[cfg(not(stage0))]\n+    pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);\n+\n+    #[cfg(not(stage0))]\n+    pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);\n+\n+    #[cfg(not(stage0))]\n+    pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);\n+\n+    #[cfg(not(stage0))]\n+    pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);\n+\n+    #[cfg(not(stage0))]\n+    pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);\n+\n+    #[cfg(not(stage0))]\n+    pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);\n+    #[cfg(not(stage0))]\n+    pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);\n }\n \n #[cfg(target_endian = \"little\")] pub fn to_le16(x: i16) -> i16 { x }"}]}