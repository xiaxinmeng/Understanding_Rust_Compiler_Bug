{"sha": "4c4ca60edd9775873e555dbb5928b000bd734403", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNGNhNjBlZGQ5Nzc1ODczZTU1NWRiYjU5MjhiMDAwYmQ3MzQ0MDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-18T18:35:11Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-04-19T17:13:45Z"}, "message": "remove duplicated code and simplify logic", "tree": {"sha": "36d0896b30261cfc9be79a761fc6c5a6fab55475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36d0896b30261cfc9be79a761fc6c5a6fab55475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c4ca60edd9775873e555dbb5928b000bd734403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4ca60edd9775873e555dbb5928b000bd734403", "html_url": "https://github.com/rust-lang/rust/commit/4c4ca60edd9775873e555dbb5928b000bd734403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c4ca60edd9775873e555dbb5928b000bd734403/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1be8d16c55990fff8c265352328fd90555feabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1be8d16c55990fff8c265352328fd90555feabd", "html_url": "https://github.com/rust-lang/rust/commit/f1be8d16c55990fff8c265352328fd90555feabd"}], "stats": {"total": 239, "additions": 145, "deletions": 94}, "files": [{"sha": "c89c222ad57fce9b8c6c61085fdba9d59d3eb499", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 59, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=4c4ca60edd9775873e555dbb5928b000bd734403", "patch": "@@ -328,7 +328,38 @@ impl<'a> Resolver<'a> {\n             _ => false,\n         };\n \n-        let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+        let mut bad_struct_syntax_suggestion = || {\n+            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+            let mut suggested = false;\n+            match source {\n+                PathSource::Expr(Some(parent)) => {\n+                    suggested = path_sep(err, &parent);\n+                }\n+                PathSource::Expr(None) if followed_by_brace == true => {\n+                    if let Some((sp, snippet)) = closing_brace {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"surround the struct literal with parenthesis\",\n+                            format!(\"({})\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_label(\n+                            span,  // Note the parenthesis surrounding the suggestion below\n+                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                        );\n+                    }\n+                    suggested = true;\n+                },\n+                _ => {}\n+            }\n+            if !suggested {\n+                err.span_label(\n+                    span,\n+                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                );\n+            }\n+        };\n \n         match (def, source) {\n             (Def::Macro(..), _) => {\n@@ -383,69 +414,13 @@ impl<'a> Resolver<'a> {\n                         );\n                     }\n                 } else {\n-                    match source {\n-                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        }\n-                        PathSource::Expr(None) if followed_by_brace == true => {\n-                            if let Some((sp, snippet)) = closing_brace {\n-                                err.span_suggestion(\n-                                    sp,\n-                                    \"surround the struct literal with parenthesis\",\n-                                    format!(\"({})\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                                );\n-                            }\n-                        },\n-                        _ => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        },\n-                    }\n+                    bad_struct_syntax_suggestion();\n                 }\n             }\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n             (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n-                    match source {\n-                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        }\n-                        PathSource::Expr(None) if followed_by_brace == true => {\n-                            if let Some((sp, snippet)) = closing_brace {\n-                                err.span_suggestion(\n-                                    sp,\n-                                    \"surround the struct literal with parenthesis\",\n-                                    format!(\"({})\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                                );\n-                            }\n-                        },\n-                        _ => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        },\n-                    }\n+                bad_struct_syntax_suggestion();\n             }\n             (Def::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);"}, {"sha": "a2a2c4637c5710a60c1855fe57da490bf380d7f1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4c4ca60edd9775873e555dbb5928b000bd734403", "patch": "@@ -2856,7 +2856,7 @@ impl<'a> Parser<'a> {\n                         hi = self.prev_span;\n                         ex = ExprKind::Mac(respan(lo.to(hi), Mac_ { path, tts, delim }));\n                     } else if self.check(&token::OpenDelim(token::Brace)) {\n-                        if let Some(expr) = self.should_parse_struct_expr(lo, &path, &attrs) {\n+                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n                             return expr;\n                         } else {\n                             hi = path.span;\n@@ -2904,47 +2904,48 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    fn should_parse_struct_expr(\n+    fn maybe_parse_struct_expr(\n         &mut self,\n         lo: Span,\n         path: &ast::Path,\n         attrs: &ThinVec<Attribute>,\n     ) -> Option<PResult<'a, P<Expr>>> {\n+        // We don't want to assume it's a struct when encountering `{ <ident>: <ident> }` because\n+        // it could be type ascription, like in `{ ident: u32 }`.\n+        let isnt_ascription = self.look_ahead(1, |t| t.is_ident()) &&\n+            self.look_ahead(2, |t| *t == token::Colon) && (\n+                (self.look_ahead(3, |t| t.is_ident()) &&\n+                 self.look_ahead(4, |t| *t == token::Comma)) ||\n+                self.look_ahead(3, |t| t.is_lit()) ||\n+                self.look_ahead(3, |t| *t == token::BinOp(token::Minus)) &&\n+                self.look_ahead(4, |t| t.is_lit())\n+            );\n         let could_be_struct = self.look_ahead(1, |t| t.is_ident()) && (\n-            self.look_ahead(2, |t| *t == token::Colon)\n+            self.look_ahead(2, |t| *t == token::Colon) && isnt_ascription\n             || self.look_ahead(2, |t| *t == token::Comma)\n             // We could also check for `token::CloseDelim(token::Brace)`, but that would\n             // have false positives in the case of `if x == y { z } { a }`.\n         );\n-        let mut bad_struct = false;\n-        let mut parse_struct = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n-        if self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL) && could_be_struct {\n+        let bad_struct = self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+        if !bad_struct || could_be_struct {\n             // This is a struct literal, but we don't can't accept them here\n-            bad_struct = true;\n-            parse_struct = true;\n-        }\n-        if parse_struct {\n-            match self.parse_struct_expr(lo, path.clone(), attrs.clone()) {\n-                Err(err) => return Some(Err(err)),\n-                Ok(expr) => {\n-                    if bad_struct {\n-                        let mut err = self.diagnostic().struct_span_err(\n-                            expr.span,\n-                            \"struct literals are not allowed here\",\n-                        );\n-                        err.multipart_suggestion(\n-                            \"surround the struct literal with parenthesis\",\n-                            vec![\n-                                (lo.shrink_to_lo(), \"(\".to_string()),\n-                                (expr.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                    }\n-                    return Some(Ok(expr));\n-                }\n+            let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n+            if let (Ok(expr), true) = (&expr, bad_struct) {\n+                let mut err = self.diagnostic().struct_span_err(\n+                    expr.span,\n+                    \"struct literals are not allowed here\",\n+                );\n+                err.multipart_suggestion(\n+                    \"surround the struct literal with parenthesis\",\n+                    vec![\n+                        (lo.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n             }\n+            return Some(expr);\n         }\n         None\n     }"}, {"sha": "8f2d50586c055289fb7652947322805ca9a39e58", "filename": "src/test/ui/struct-literal-variant-in-if.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs?ref=4c4ca60edd9775873e555dbb5928b000bd734403", "patch": "@@ -1,12 +1,25 @@\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n enum E {\n-    V { field: bool }\n+    V { field: bool },\n+    I { field1: bool, field2: usize },\n+    J { field: isize },\n+    K { field: &'static str},\n }\n fn test_E(x: E) {\n     let field = true;\n     if x == E::V { field } {}\n     //~^ ERROR expected value, found struct variant `E::V`\n     //~| ERROR mismatched types\n+    if x == E::I { field1: true, field2: 42 } {}\n+    //~^ ERROR struct literals are not allowed here\n+    if x == E::V { field: false } {}\n+    //~^ ERROR expected identifier, found keyword `false`\n+    //~| ERROR expected type, found keyword `false`\n+    //~| ERROR expected value, found struct variant `E::V`\n+    if x == E::J { field: -42 } {}\n+    //~^ ERROR struct literals are not allowed here\n+    if x == E::K { field: \"\" } {}\n+    //~^ ERROR struct literals are not allowed here\n     let y: usize = ();\n     //~^ ERROR mismatched types\n }"}, {"sha": "0af0c6aefaf40a7d41948c7685bd5094945d1908", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c4ca60edd9775873e555dbb5928b000bd734403/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=4c4ca60edd9775873e555dbb5928b000bd734403", "patch": "@@ -1,13 +1,75 @@\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:13:13\n+   |\n+LL |     if x == E::I { field1: true, field2: 42 } {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::I { field1: true, field2: 42 }) {}\n+   |             ^                                 ^\n+\n+error: expected identifier, found keyword `false`\n+  --> $DIR/struct-literal-variant-in-if.rs:15:27\n+   |\n+LL |     if x == E::V { field: false } {}\n+   |                           ^^^^^ expected identifier, found keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL |     if x == E::V { field: r#false } {}\n+   |                           ^^^^^^^\n+\n+error: expected type, found keyword `false`\n+  --> $DIR/struct-literal-variant-in-if.rs:15:27\n+   |\n+LL |     if x == E::V { field: false } {}\n+   |                           ^^^^^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/struct-literal-variant-in-if.rs:15:20\n+   |\n+LL |     if x == E::V { field: false } {}\n+   |                    ^^^^^\n+   = help: this might be indicative of a syntax error elsewhere\n+\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:19:13\n+   |\n+LL |     if x == E::J { field: -42 } {}\n+   |             ^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::J { field: -42 }) {}\n+   |             ^                   ^\n+\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:21:13\n+   |\n+LL |     if x == E::K { field: \"\" } {}\n+   |             ^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::K { field: \"\" }) {}\n+   |             ^                  ^\n+\n error[E0423]: expected value, found struct variant `E::V`\n-  --> $DIR/struct-literal-variant-in-if.rs:7:13\n+  --> $DIR/struct-literal-variant-in-if.rs:10:13\n    |\n LL |     if x == E::V { field } {}\n    |             ^^^^----------\n    |             |\n    |             help: surround the struct literal with parenthesis: `(E::V { field })`\n \n+error[E0423]: expected value, found struct variant `E::V`\n+  --> $DIR/struct-literal-variant-in-if.rs:15:13\n+   |\n+LL |     if x == E::V { field: false } {}\n+   |             ^^^^-----------------\n+   |             |\n+   |             help: surround the struct literal with parenthesis: `(E::V { field: false })`\n+\n error[E0308]: mismatched types\n-  --> $DIR/struct-literal-variant-in-if.rs:7:20\n+  --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n LL | fn test_E(x: E) {\n    |                 - help: try adding a return type: `-> bool`\n@@ -19,15 +81,15 @@ LL |     if x == E::V { field } {}\n               found type `bool`\n \n error[E0308]: mismatched types\n-  --> $DIR/struct-literal-variant-in-if.rs:10:20\n+  --> $DIR/struct-literal-variant-in-if.rs:23:20\n    |\n LL |     let y: usize = ();\n    |                    ^^ expected usize, found ()\n    |\n    = note: expected type `usize`\n               found type `()`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors occurred: E0308, E0423.\n For more information about an error, try `rustc --explain E0308`."}]}