{"sha": "6941b2569ae1643335462da5a70f1429bad2f2fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NDFiMjU2OWFlMTY0MzMzNTQ2MmRhNWE3MGYxNDI5YmFkMmYyZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-08T18:23:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-08T18:23:57Z"}, "message": "Auto merge of #29995 - DanielJCampbell:Expanded-Span-Printing, r=nrc\n\nr? @nrc", "tree": {"sha": "267c035b25d0d451a7d729dd36f7c8c823aac043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/267c035b25d0d451a7d729dd36f7c8c823aac043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6941b2569ae1643335462da5a70f1429bad2f2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6941b2569ae1643335462da5a70f1429bad2f2fb", "html_url": "https://github.com/rust-lang/rust/commit/6941b2569ae1643335462da5a70f1429bad2f2fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6941b2569ae1643335462da5a70f1429bad2f2fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acf4e0be22203213a5e42469deea4dc6e49da840", "url": "https://api.github.com/repos/rust-lang/rust/commits/acf4e0be22203213a5e42469deea4dc6e49da840", "html_url": "https://github.com/rust-lang/rust/commit/acf4e0be22203213a5e42469deea4dc6e49da840"}, {"sha": "6b6fb7bbcb3c164dc17236ce52022c0bed8e0cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b6fb7bbcb3c164dc17236ce52022c0bed8e0cd8", "html_url": "https://github.com/rust-lang/rust/commit/6b6fb7bbcb3c164dc17236ce52022c0bed8e0cd8"}], "stats": {"total": 204, "additions": 204, "deletions": 0}, "files": [{"sha": "18659cb2e78f18359f3a387c78130d0470060e46", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6941b2569ae1643335462da5a70f1429bad2f2fb/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6941b2569ae1643335462da5a70f1429bad2f2fb/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6941b2569ae1643335462da5a70f1429bad2f2fb", "patch": "@@ -807,6 +807,96 @@ impl CodeMap {\n                         hi.col.to_usize() + 1)).to_string()\n     }\n \n+    // Returns true if two spans have the same callee\n+    // (Assumes the same ExpnFormat implies same callee)\n+    fn match_callees(&self, sp_a: &Span, sp_b: &Span) -> bool {\n+        let fmt_a = self\n+            .with_expn_info(sp_a.expn_id,\n+                            |ei| ei.map(|ei| ei.callee.format.clone()));\n+\n+        let fmt_b = self\n+            .with_expn_info(sp_b.expn_id,\n+                            |ei| ei.map(|ei| ei.callee.format.clone()));\n+        fmt_a == fmt_b\n+    }\n+\n+    /// Returns a formatted string showing the expansion chain of a span\n+    ///\n+    /// Spans are printed in the following format:\n+    ///\n+    /// filename:start_line:col: end_line:col\n+    /// snippet\n+    ///   Callee:\n+    ///   Callee span\n+    ///   Callsite:\n+    ///   Callsite span\n+    ///\n+    /// Callees and callsites are printed recursively (if available, otherwise header\n+    /// and span is omitted), expanding into their own callee/callsite spans.\n+    /// Each layer of recursion has an increased indent, and snippets are truncated\n+    /// to at most 50 characters. Finally, recursive calls to the same macro are squashed,\n+    /// with '...' used to represent any number of recursive calls.\n+    pub fn span_to_expanded_string(&self, sp: Span) -> String {\n+        self.span_to_expanded_string_internal(sp, \"\")\n+    }\n+\n+    fn span_to_expanded_string_internal(&self, sp:Span, indent: &str) -> String {\n+        let mut indent = indent.to_owned();\n+        let mut output = \"\".to_owned();\n+        let span_str = self.span_to_string(sp);\n+        let mut span_snip = self.span_to_snippet(sp)\n+            .unwrap_or(\"Snippet unavailable\".to_owned());\n+        if span_snip.len() > 50 {\n+            span_snip.truncate(50);\n+            span_snip.push_str(\"...\");\n+        }\n+        output.push_str(&format!(\"{}{}\\n{}`{}`\\n\", indent, span_str, indent, span_snip));\n+\n+        if sp.expn_id == NO_EXPANSION || sp.expn_id == COMMAND_LINE_EXPN {\n+            return output;\n+        }\n+\n+        let mut callee = self.with_expn_info(sp.expn_id,\n+                                             |ei| ei.and_then(|ei| ei.callee.span.clone()));\n+        let mut callsite = self.with_expn_info(sp.expn_id,\n+                                               |ei| ei.map(|ei| ei.call_site.clone()));\n+\n+        indent.push_str(\"  \");\n+        let mut is_recursive = false;\n+\n+        while callee.is_some() && self.match_callees(&sp, &callee.unwrap()) {\n+            callee = self.with_expn_info(callee.unwrap().expn_id,\n+                                         |ei| ei.and_then(|ei| ei.callee.span.clone()));\n+            is_recursive = true;\n+        }\n+        if let Some(span) = callee {\n+            output.push_str(&indent);\n+            output.push_str(\"Callee:\\n\");\n+            if is_recursive {\n+                output.push_str(&indent);\n+                output.push_str(\"...\\n\");\n+            }\n+            output.push_str(&(self.span_to_expanded_string_internal(span, &indent)));\n+        }\n+\n+        is_recursive = false;\n+        while callsite.is_some() && self.match_callees(&sp, &callsite.unwrap()) {\n+            callsite = self.with_expn_info(callsite.unwrap().expn_id,\n+                                           |ei| ei.map(|ei| ei.call_site.clone()));\n+            is_recursive = true;\n+        }\n+        if let Some(span) = callsite {\n+            output.push_str(&indent);\n+            output.push_str(\"Callsite:\\n\");\n+            if is_recursive {\n+                output.push_str(&indent);\n+                output.push_str(\"...\\n\");\n+            }\n+            output.push_str(&(self.span_to_expanded_string_internal(span, &indent)));\n+        }\n+        output\n+    }\n+\n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n@@ -1274,4 +1364,118 @@ mod tests {\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n     }\n+\n+    #[test]\n+    fn t10() {\n+        // Test span_to_expanded_string works in base case (no expansion)\n+        let cm = init_code_map();\n+        let span = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n+        let sstr = cm.span_to_expanded_string(span);\n+        assert_eq!(sstr, \"blork.rs:1:1: 1:12\\n`first line.`\\n\");\n+\n+        let span = Span { lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION };\n+        let sstr =  cm.span_to_expanded_string(span);\n+        assert_eq!(sstr, \"blork.rs:2:1: 2:12\\n`second line`\\n\");\n+    }\n+\n+    #[test]\n+    fn t11() {\n+        // Test span_to_expanded_string works with expansion\n+        use ast::Name;\n+        let cm = init_code_map();\n+        let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n+        let format = ExpnFormat::MacroBang(Name(0u32));\n+        let callee = NameAndSpan { format: format,\n+                                   allow_internal_unstable: false,\n+                                   span: None };\n+\n+        let info = ExpnInfo { call_site: root, callee: callee };\n+        let id = cm.record_expansion(info);\n+        let sp = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id };\n+\n+        let sstr = cm.span_to_expanded_string(sp);\n+        assert_eq!(sstr,\n+                   \"blork.rs:2:1: 2:12\\n`second line`\\n  Callsite:\\n  \\\n+                    blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n+    }\n+\n+    fn init_expansion_chain(cm: &CodeMap) -> Span {\n+        // Creates an expansion chain containing two recursive calls\n+        // root -> expA -> expA -> expB -> expB -> end\n+        use ast::Name;\n+\n+        let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n+\n+        let format_root = ExpnFormat::MacroBang(Name(0u32));\n+        let callee_root = NameAndSpan { format: format_root,\n+                                        allow_internal_unstable: false,\n+                                        span: Some(root) };\n+\n+        let info_a1 = ExpnInfo { call_site: root, callee: callee_root };\n+        let id_a1 = cm.record_expansion(info_a1);\n+        let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n+\n+        let format_a = ExpnFormat::MacroBang(Name(1u32));\n+        let callee_a = NameAndSpan { format: format_a,\n+                                      allow_internal_unstable: false,\n+                                      span: Some(span_a1) };\n+\n+        let info_a2 = ExpnInfo { call_site: span_a1, callee: callee_a.clone() };\n+        let id_a2 = cm.record_expansion(info_a2);\n+        let span_a2 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a2 };\n+\n+        let info_b1 = ExpnInfo { call_site: span_a2, callee: callee_a };\n+        let id_b1 = cm.record_expansion(info_b1);\n+        let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n+\n+        let format_b = ExpnFormat::MacroBang(Name(2u32));\n+        let callee_b = NameAndSpan { format: format_b,\n+                                     allow_internal_unstable: false,\n+                                     span: None };\n+\n+        let info_b2 = ExpnInfo { call_site: span_b1, callee: callee_b.clone() };\n+        let id_b2 = cm.record_expansion(info_b2);\n+        let span_b2 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b2 };\n+\n+        let info_end = ExpnInfo { call_site: span_b2, callee: callee_b };\n+        let id_end = cm.record_expansion(info_end);\n+        Span { lo: BytePos(37), hi: BytePos(48), expn_id: id_end }\n+    }\n+\n+    #[test]\n+    fn t12() {\n+        // Test span_to_expanded_string collapses recursive macros and handles\n+        // recursive callsite and callee expansions\n+        let cm = init_code_map();\n+        let end = init_expansion_chain(&cm);\n+        let sstr = cm.span_to_expanded_string(end);\n+        let res_str =\n+r\"blork2.rs:2:1: 2:12\n+`second line`\n+  Callsite:\n+  ...\n+  blork2.rs:1:1: 1:12\n+  `first line.`\n+    Callee:\n+    blork.rs:2:1: 2:12\n+    `second line`\n+      Callee:\n+      blork.rs:1:1: 1:12\n+      `first line.`\n+      Callsite:\n+      blork.rs:1:1: 1:12\n+      `first line.`\n+    Callsite:\n+    ...\n+    blork.rs:2:1: 2:12\n+    `second line`\n+      Callee:\n+      blork.rs:1:1: 1:12\n+      `first line.`\n+      Callsite:\n+      blork.rs:1:1: 1:12\n+      `first line.`\n+\";\n+        assert_eq!(sstr, res_str);\n+    }\n }"}]}