{"sha": "409297f529dad4f297fd695b03bb63f191fe1ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwOTI5N2Y1MjlkYWQ0ZjI5N2ZkNjk1YjAzYmI2M2YxOTFmZTFjYTk=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-11-14T22:17:09Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-11-20T04:19:35Z"}, "message": "allow filtering analysis by reachability", "tree": {"sha": "b50cc7125ca7d77642a486bf65f2080626eb717d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b50cc7125ca7d77642a486bf65f2080626eb717d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/409297f529dad4f297fd695b03bb63f191fe1ca9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAloSV9cWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdMC/CACxURA0IoQd6+yXQnTCl73J1f2G\n86SJS0j08kp0xCP3hhtXRlZo0Sd8BoeVadPMiHpAWebQ0NzzA7iUR3keoGRV1SKA\n9rUDi065quobs7NQkghz8aLD4sEeuWvEcTKqv5qqcA4Wxi5DYGO2eJDK5MRI/baI\ntCk7B3tYdi0OYKDFMuLgkNii7koiCkrdbmI72mpdS1RoctyMvv6mYV1TX67U98EU\nsJrANFNXEExIg3qk2V2wkx15G3jyuNntjTjEgSOmsU70nwJO6YHy8TFzTlwCrZfq\nvRe3Gne06LqNhE0NM4Ch47e0PE1cw2fihWtANLLdqPhHyXXQ5zZ1Mz5i9Rhz\n=YZPi\n-----END PGP SIGNATURE-----", "payload": "tree b50cc7125ca7d77642a486bf65f2080626eb717d\nparent d08a1649607fb8b9a9ab4a030185d0f6b82f9a43\nauthor Andy Russell <arussell123@gmail.com> 1510697829 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1511151575 -0500\n\nallow filtering analysis by reachability\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/409297f529dad4f297fd695b03bb63f191fe1ca9", "html_url": "https://github.com/rust-lang/rust/commit/409297f529dad4f297fd695b03bb63f191fe1ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/409297f529dad4f297fd695b03bb63f191fe1ca9/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08a1649607fb8b9a9ab4a030185d0f6b82f9a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08a1649607fb8b9a9ab4a030185d0f6b82f9a43", "html_url": "https://github.com/rust-lang/rust/commit/d08a1649607fb8b9a9ab4a030185d0f6b82f9a43"}], "stats": {"total": 163, "additions": 119, "deletions": 44}, "files": [{"sha": "b1dec6d87372a77e9680937451b35a46b8e21113", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/409297f529dad4f297fd695b03bb63f191fe1ca9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409297f529dad4f297fd695b03bb63f191fe1ca9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=409297f529dad4f297fd695b03bb63f191fe1ca9", "patch": "@@ -42,7 +42,7 @@ use syntax::codemap::Spanned;\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n-use json_dumper::{DumpOutput, JsonDumper};\n+use json_dumper::{Access, DumpOutput, JsonDumper};\n use span_utils::SpanUtils;\n use sig;\n \n@@ -341,7 +341,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                     self.dumper.dump_def(\n-                        false,\n+                        &Access {\n+                            public: false,\n+                            reachable: false,\n+                        },\n                         Def {\n                             kind: DefKind::Local,\n                             id,\n@@ -387,8 +390,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n-            self.dumper\n-                .dump_def(vis == ast::Visibility::Public, method_data);\n+            self.dumper.dump_def(\n+                &Access {\n+                    public: vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n+                },\n+                method_data);\n         }\n \n         // walk arg and return types\n@@ -409,8 +416,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper\n-                .dump_def(field.vis == ast::Visibility::Public, field_data);\n+            self.dumper.dump_def(\n+                &Access {\n+                    public: field.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(field.id),\n+                },\n+                field_data,\n+            );\n         }\n     }\n \n@@ -432,7 +444,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 let span = self.span_from_span(param_ss);\n \n                 self.dumper.dump_def(\n-                    false,\n+                    &Access {\n+                        public: false,\n+                        reachable: false,\n+                    },\n                     Def {\n                         kind: DefKind::Type,\n                         id,\n@@ -467,8 +482,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-            self.dumper\n-                .dump_def(item.vis == ast::Visibility::Public, fn_data);\n+            self.dumper.dump_def(\n+                &Access {\n+                    public: item.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                },\n+                fn_data,\n+            );\n         }\n \n         for arg in &decl.inputs {\n@@ -491,8 +511,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper\n-                    .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                v.dumper.dump_def(\n+                    &Access {\n+                        public: item.vis == ast::Visibility::Public,\n+                        reachable: v.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                    },\n+                    var_data,\n+                );\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -516,14 +541,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         if !self.span.filter_generated(sub_span, span) {\n             let sig = sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt);\n-            let id = ::id_from_node_id(id, &self.save_ctxt);\n             let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n             self.dumper.dump_def(\n-                vis == ast::Visibility::Public,\n+                &Access {\n+                    public: vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n+                },\n                 Def {\n                     kind: DefKind::Const,\n-                    id,\n+                    id: ::id_from_node_id(id, &self.save_ctxt),\n                     span,\n                     name: name.to_string(),\n                     qualname,\n@@ -596,7 +623,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if !self.span.filter_generated(sub_span, item.span) {\n             let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n             self.dumper.dump_def(\n-                item.vis == ast::Visibility::Public,\n+                &Access {\n+                    public: item.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                },\n                 Def {\n                     kind,\n                     id: ::id_from_node_id(item.id, &self.save_ctxt),\n@@ -635,6 +665,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n+        let access = Access {\n+            public: item.vis == ast::Visibility::Public,\n+            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+        };\n+\n         for variant in &enum_definition.variants {\n             let name = variant.node.name.name.to_string();\n             let mut qualname = enum_data.qualname.clone();\n@@ -660,7 +695,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n-                            item.vis == ast::Visibility::Public,\n+                            &access,\n                             Def {\n                                 kind: DefKind::StructVariant,\n                                 id,\n@@ -700,7 +735,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n-                            item.vis == ast::Visibility::Public,\n+                            &access,\n                             Def {\n                                 kind: DefKind::TupleVariant,\n                                 id,\n@@ -730,8 +765,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n-        self.dumper\n-            .dump_def(item.vis == ast::Visibility::Public, enum_data);\n+        self.dumper.dump_def(&access, enum_data);\n     }\n \n     fn process_impl(\n@@ -783,7 +817,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n                 .collect();\n             self.dumper.dump_def(\n-                item.vis == ast::Visibility::Public,\n+                &Access {\n+                    public: item.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                },\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -846,8 +883,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper\n-                .dump_def(item.vis == ast::Visibility::Public, mod_data);\n+            self.dumper.dump_def(\n+                &Access {\n+                    public: item.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                },\n+                mod_data,\n+            );\n         }\n     }\n \n@@ -1038,7 +1080,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                 self.dumper.dump_def(\n-                    false,\n+                    &Access {\n+                        public: false,\n+                        reachable: false,\n+                    },\n                     Def {\n                         kind: DefKind::Local,\n                         id,\n@@ -1138,7 +1183,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        true,\n+                        &Access {\n+                            public: true,\n+                            reachable: true,\n+                        },\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1225,7 +1273,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         let span = self.span_from_span(span);\n \n         self.dumper.dump_def(\n-            true,\n+            &Access {\n+                public: true,\n+                reachable: true,\n+            },\n             Def {\n                 kind: DefKind::Mod,\n                 id: data_id,\n@@ -1249,6 +1300,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         self.process_macro_use(item.span);\n         match item.node {\n             Use(ref use_item) => {\n+                let access = Access {\n+                    public: item.vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                };\n+\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n@@ -1273,7 +1329,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use\"));\n                             self.dumper.import(\n-                                item.vis == ast::Visibility::Public,\n+                                &access,\n                                 Import {\n                                     kind: ImportKind::Use,\n                                     ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n@@ -1302,7 +1358,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n                             self.dumper.import(\n-                                item.vis == ast::Visibility::Public,\n+                                &access,\n                                 Import {\n                                     kind: ImportKind::GlobUse,\n                                     ref_id: None,\n@@ -1334,7 +1390,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let span =\n                         self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n                     self.dumper.import(\n-                        false,\n+                        &Access {\n+                            public: false,\n+                            reachable: false,\n+                        },\n                         Import {\n                             kind: ImportKind::ExternCrate,\n                             ref_id: None,\n@@ -1373,7 +1432,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        item.vis == ast::Visibility::Public,\n+                        &Access {\n+                            public: item.vis == ast::Visibility::Public,\n+                            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+                        },\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1596,7 +1658,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         let span = self.span_from_span(sp);\n \n                         self.dumper.dump_def(\n-                            false,\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n                             Def {\n                                 kind: DefKind::Local,\n                                 id,\n@@ -1662,6 +1727,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n+        let access = Access {\n+            public: item.vis == ast::Visibility::Public,\n+            reachable: self.save_ctxt.analysis.access_levels.is_reachable(item.id),\n+        };\n+\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n@@ -1672,8 +1742,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n                     );\n                     self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, fn_data);\n+                    self.dumper.dump_def(&access, fn_data);\n                 }\n \n                 for arg in &decl.inputs {\n@@ -1687,17 +1756,15 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             ast::ForeignItemKind::Static(ref ty, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper.dump_def(&access, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n             ast::ForeignItemKind::Ty => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper.dump_def(&access, var_data);\n                 }\n             }\n         }"}, {"sha": "2b35a4123836bbd41306567fb569f128a58450e9", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/409297f529dad4f297fd695b03bb63f191fe1ca9/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409297f529dad4f297fd695b03bb63f191fe1ca9/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=409297f529dad4f297fd695b03bb63f191fe1ca9", "patch": "@@ -17,6 +17,12 @@ use rls_data::{self, Analysis, CratePreludeData, Def, DefKind, Import, MacroRef,\n use rls_data::config::Config;\n use rls_span::{Column, Row};\n \n+#[derive(Debug)]\n+pub struct Access {\n+    pub reachable: bool,\n+    pub public: bool,\n+}\n+\n pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n     config: Config,\n@@ -84,33 +90,35 @@ impl<'b, O: DumpOutput + 'b> JsonDumper<O> {\n     }\n \n     pub fn macro_use(&mut self, data: MacroRef) {\n-        if self.config.pub_only {\n+        if self.config.pub_only || self.config.reachable_only {\n             return;\n         }\n         self.result.macro_refs.push(data);\n     }\n \n-    pub fn import(&mut self, public: bool, import: Import) {\n-        if !public && self.config.pub_only {\n+    pub fn import(&mut self, access: &Access, import: Import) {\n+        if !access.public && self.config.pub_only\n+            || !access.reachable && self.config.reachable_only {\n             return;\n         }\n         self.result.imports.push(import);\n     }\n \n     pub fn dump_ref(&mut self, data: Ref) {\n-        if self.config.pub_only {\n+        if self.config.pub_only || self.config.reachable_only {\n             return;\n         }\n         self.result.refs.push(data);\n     }\n \n-    pub fn dump_def(&mut self, public: bool, mut data: Def) {\n-        if !public && self.config.pub_only {\n+    pub fn dump_def(&mut self, access: &Access, mut data: Def) {\n+        if !access.public && self.config.pub_only\n+            || !access.reachable && self.config.reachable_only {\n             return;\n         }\n         if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n-            // If the module is an out-of-line defintion, then we'll make the\n-            // definition the first character in the module's file and turn the\n+            // If the module is an out-of-line definition, then we'll make the\n+            // definition the first character in the module's file and turn\n             // the declaration into a reference to it.\n             let rf = Ref {\n                 kind: RefKind::Mod,"}]}