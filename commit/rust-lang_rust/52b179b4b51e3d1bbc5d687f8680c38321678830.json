{"sha": "52b179b4b51e3d1bbc5d687f8680c38321678830", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjE3OWI0YjUxZTNkMWJiYzVkNjg3Zjg2ODBjMzgzMjE2Nzg4MzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T17:58:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-05T17:58:55Z"}, "message": "Auto merge of #75005 - adamreichold:limit-vector-count, r=Amanieu\n\nLimit I/O vector count on Unix\n\nUnix systems enforce limits on the vector count when performing vectored I/O via the readv and writev system calls and return EINVAL when these limits are exceeded. This changes the standard library to handle those limits as short reads and writes to avoid forcing its users to query these limits using platform specific mechanisms.\n\nFixes #68042", "tree": {"sha": "7fe2aa4e2c61b0b30438bd5569ba04b87f974555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fe2aa4e2c61b0b30438bd5569ba04b87f974555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b179b4b51e3d1bbc5d687f8680c38321678830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b179b4b51e3d1bbc5d687f8680c38321678830", "html_url": "https://github.com/rust-lang/rust/commit/52b179b4b51e3d1bbc5d687f8680c38321678830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b179b4b51e3d1bbc5d687f8680c38321678830/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db870ea71b6dcc7a91b999420b88f41d3cdd13e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/db870ea71b6dcc7a91b999420b88f41d3cdd13e1", "html_url": "https://github.com/rust-lang/rust/commit/db870ea71b6dcc7a91b999420b88f41d3cdd13e1"}, {"sha": "9073acdc9888acd2ba66601a77b96fbda67ac8c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9073acdc9888acd2ba66601a77b96fbda67ac8c7", "html_url": "https://github.com/rust-lang/rust/commit/9073acdc9888acd2ba66601a77b96fbda67ac8c7"}], "stats": {"total": 40, "additions": 38, "deletions": 2}, "files": [{"sha": "e36a53084bae1874a92be0ba1056e7edf691f899", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/52b179b4b51e3d1bbc5d687f8680c38321678830/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b179b4b51e3d1bbc5d687f8680c38321678830/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=52b179b4b51e3d1bbc5d687f8680c38321678830", "patch": "@@ -3,6 +3,8 @@\n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n+#[cfg(not(any(target_os = \"redox\", target_env = \"newlib\")))]\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n \n@@ -26,6 +28,27 @@ const READ_LIMIT: usize = c_int::MAX as usize - 1;\n #[cfg(not(target_os = \"macos\"))]\n const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n \n+#[cfg(not(any(target_os = \"redox\", target_env = \"newlib\")))]\n+fn max_iov() -> usize {\n+    static LIM: AtomicUsize = AtomicUsize::new(0);\n+\n+    let mut lim = LIM.load(Ordering::Relaxed);\n+    if lim == 0 {\n+        let ret = unsafe { libc::sysconf(libc::_SC_IOV_MAX) };\n+\n+        // 16 is the minimum value required by POSIX.\n+        lim = if ret > 0 { ret as usize } else { 16 };\n+        LIM.store(lim, Ordering::Relaxed);\n+    }\n+\n+    lim\n+}\n+\n+#[cfg(any(target_os = \"redox\", target_env = \"newlib\"))]\n+fn max_iov() -> usize {\n+    16 // The minimum value required by POSIX.\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd }\n@@ -54,7 +77,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -111,7 +134,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n+                cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -256,3 +279,16 @@ impl Drop for FileDesc {\n         let _ = unsafe { libc::close(self.fd) };\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{FileDesc, IoSlice};\n+\n+    #[test]\n+    fn limit_vector_count() {\n+        let stdout = FileDesc { fd: 1 };\n+        let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n+\n+        assert!(stdout.write_vectored(&bufs).is_ok());\n+    }\n+}"}]}