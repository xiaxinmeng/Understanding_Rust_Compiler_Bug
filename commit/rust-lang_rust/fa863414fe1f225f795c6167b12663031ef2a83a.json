{"sha": "fa863414fe1f225f795c6167b12663031ef2a83a", "node_id": "C_kwDOAAsO6NoAKGZhODYzNDE0ZmUxZjIyNWY3OTVjNjE2N2IxMjY2MzAzMWVmMmE4M2E", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-10-05T18:23:14Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-10-05T19:15:17Z"}, "message": "Add regression test for lifetimes in alloc internals autotraits\n\nCurrently pretty much all of the btree_map and btree_set ones fail, as\nwell as linked_list::DrainFilter.\n\n    error: higher-ranked lifetime error\n      --> library/alloc/tests/autotraits.rs:38:5\n       |\n    38 | /     require_send_sync(async {\n    39 | |         let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n    40 | |         async {}.await;\n    41 | |     });\n       | |______^\n       |\n       = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:56:5\n       |\n    56 | /     require_send_sync(async {\n    57 | |         let _v = None::<\n    58 | |             alloc::collections::btree_map::DrainFilter<\n    59 | |                 '_,\n    ...  |\n    65 | |         async {}.await;\n    66 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:68:5\n       |\n    68 | /     require_send_sync(async {\n    69 | |         let _v = None::<alloc::collections::btree_map::Entry<'_, &u32, &u32>>;\n    70 | |         async {}.await;\n    71 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n      --> library/alloc/tests/autotraits.rs:88:5\n       |\n    88 | /     require_send_sync(async {\n    89 | |         let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n    90 | |         async {}.await;\n    91 | |     });\n       | |______^\n       |\n       = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:93:5\n       |\n    93 | /     require_send_sync(async {\n    94 | |         let _v = None::<alloc::collections::btree_map::IterMut<'_, &u32, &u32>>;\n    95 | |         async {}.await;\n    96 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:98:5\n        |\n    98  | /     require_send_sync(async {\n    99  | |         let _v = None::<alloc::collections::btree_map::Keys<'_, &u32, &u32>>;\n    100 | |         async {}.await;\n    101 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:103:5\n        |\n    103 | /     require_send_sync(async {\n    104 | |         let _v = None::<alloc::collections::btree_map::OccupiedEntry<'_, &u32, &u32>>;\n    105 | |         async {}.await;\n    106 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:108:5\n        |\n    108 | /     require_send_sync(async {\n    109 | |         let _v = None::<alloc::collections::btree_map::OccupiedError<'_, &u32, &u32>>;\n    110 | |         async {}.await;\n    111 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:113:5\n        |\n    113 | /     require_send_sync(async {\n    114 | |         let _v = None::<alloc::collections::btree_map::Range<'_, &u32, &u32>>;\n    115 | |         async {}.await;\n    116 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:118:5\n        |\n    118 | /     require_send_sync(async {\n    119 | |         let _v = None::<alloc::collections::btree_map::RangeMut<'_, &u32, &u32>>;\n    120 | |         async {}.await;\n    121 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:123:5\n        |\n    123 | /     require_send_sync(async {\n    124 | |         let _v = None::<alloc::collections::btree_map::VacantEntry<'_, &u32, &u32>>;\n    125 | |         async {}.await;\n    126 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:128:5\n        |\n    128 | /     require_send_sync(async {\n    129 | |         let _v = None::<alloc::collections::btree_map::Values<'_, &u32, &u32>>;\n    130 | |         async {}.await;\n    131 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:133:5\n        |\n    133 | /     require_send_sync(async {\n    134 | |         let _v = None::<alloc::collections::btree_map::ValuesMut<'_, &u32, &u32>>;\n    135 | |         async {}.await;\n    136 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:146:5\n        |\n    146 | /     require_send_sync(async {\n    147 | |         let _v = None::<alloc::collections::btree_set::Difference<'_, &u32>>;\n    148 | |         async {}.await;\n    149 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:151:5\n        |\n    151 | /     require_send_sync(async {\n    152 | |         let _v = None::<alloc::collections::btree_set::DrainFilter<'_, &u32, fn(&&u32) -> bool>>;\n    153 | |         async {}.await;\n    154 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:156:5\n        |\n    156 | /     require_send_sync(async {\n    157 | |         let _v = None::<alloc::collections::btree_set::Intersection<'_, &u32>>;\n    158 | |         async {}.await;\n    159 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:166:5\n        |\n    166 | /     require_send_sync(async {\n    167 | |         let _v = None::<alloc::collections::btree_set::Iter<'_, &u32>>;\n    168 | |         async {}.await;\n    169 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:171:5\n        |\n    171 | /     require_send_sync(async {\n    172 | |         let _v = None::<alloc::collections::btree_set::Range<'_, &u32>>;\n    173 | |         async {}.await;\n    174 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:176:5\n        |\n    176 | /     require_send_sync(async {\n    177 | |         let _v = None::<alloc::collections::btree_set::SymmetricDifference<'_, &u32>>;\n    178 | |         async {}.await;\n    179 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:181:5\n        |\n    181 | /     require_send_sync(async {\n    182 | |         let _v = None::<alloc::collections::btree_set::Union<'_, &u32>>;\n    183 | |         async {}.await;\n    184 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: future cannot be sent between threads safely\n       --> library/alloc/tests/autotraits.rs:243:23\n        |\n    243 |       require_send_sync(async {\n        |  _______________________^\n    244 | |         let _v =\n    245 | |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 | |         async {}.await;\n    247 | |     });\n        | |_____^ future created by async block is not `Send`\n        |\n        = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NonNull<std::collections::linked_list::Node<&u32>>`\n    note: future is not `Send` as this value is used across an await\n       --> library/alloc/tests/autotraits.rs:246:17\n        |\n    244 |         let _v =\n        |             -- has type `Option<std::collections::linked_list::DrainFilter<'_, &u32, for<'a, 'b> fn(&'a mut &'b u32) -> bool>>` which is not `Send`\n    245 |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 |         async {}.await;\n        |                 ^^^^^^ await occurs here, with `_v` maybe used later\n    247 |     });\n        |     - `_v` is later dropped here\n    note: required by a bound in `require_send_sync`\n       --> library/alloc/tests/autotraits.rs:3:25\n        |\n    3   | fn require_send_sync<T: Send + Sync>(_: T) {}\n        |                         ^^^^ required by this bound in `require_send_sync`\n\n    error: future cannot be shared between threads safely\n       --> library/alloc/tests/autotraits.rs:243:23\n        |\n    243 |       require_send_sync(async {\n        |  _______________________^\n    244 | |         let _v =\n    245 | |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 | |         async {}.await;\n    247 | |     });\n        | |_____^ future created by async block is not `Sync`\n        |\n        = help: within `impl Future<Output = ()>`, the trait `Sync` is not implemented for `NonNull<std::collections::linked_list::Node<&u32>>`\n    note: future is not `Sync` as this value is used across an await\n       --> library/alloc/tests/autotraits.rs:246:17\n        |\n    244 |         let _v =\n        |             -- has type `Option<std::collections::linked_list::DrainFilter<'_, &u32, for<'a, 'b> fn(&'a mut &'b u32) -> bool>>` which is not `Sync`\n    245 |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 |         async {}.await;\n        |                 ^^^^^^ await occurs here, with `_v` maybe used later\n    247 |     });\n        |     - `_v` is later dropped here\n    note: required by a bound in `require_send_sync`\n       --> library/alloc/tests/autotraits.rs:3:32\n        |\n    3   | fn require_send_sync<T: Send + Sync>(_: T) {}\n        |                                ^^^^ required by this bound in `require_send_sync`", "tree": {"sha": "a9cc709c3134fd9f44e3f31d917a0cf03260bb55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9cc709c3134fd9f44e3f31d917a0cf03260bb55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa863414fe1f225f795c6167b12663031ef2a83a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmM91/8ACgkQ+boUO5X/\nbYLdERAAx3d7nFPjNbiClEG+eNuZLdfDWwGRbbu78rYdfTM4nX4gX7itQtCVoAMf\nhxW/p0bmTrJ70HLLEkgLC4f1QWnnAgAP5MyL6rFDT2Vhx7EZu5Cvxiqxssh4tlr9\nNcym4wbIQLwniQ+cCwPwsmVfErUlzSB6lo6L3ZOGDVUrL08S0pgxDzikYXkH6tl5\nh/2pHcvXSGdQyT6HGXShV8DO+k469Dtpi4DCWyrRs7awkiD2cNMbGC+lZ4uIRjuw\n0XNOE3D+sVeffZmwBP8tegu9/jyFDCCx3S955JxDjmvbBnlCJ+IhCdBpVZWgMjoA\nkImhwOWusmgaq/Fr/ofFYaOQ8DwCxZxpksE+SV7QhS4cZxWc5WQNt9o/vMp9wgNN\n/5T8eNyKcTiNp9Q0kF9PrSMqAWF7Pha99eCcjaitjQ/7VoM9JwZYeYlc3zG/Haao\n24X9zL7HWskWoeNXI/jkn5vELLu7swaFS+IwpoYk89mQ3eJ7pMkjPSo/rKv2hPcH\nGF6ZYbIFtVi70bYqn5+gw9E4Gg2jKeHT8UOEvFKMYXML3jVKl3O+coxGrtiwIKH3\nUR1/HPRTQolul/+GjpDZ+fl1gDizf6jW2rxJxUhjsrQp4MSnSEsy20lahU1HzyB3\noRsDX/js5DiLYfoi9bDb6V2h999I/znpdVms/DdCVae00LzhmJU=\n=1Y5x\n-----END PGP SIGNATURE-----", "payload": "tree a9cc709c3134fd9f44e3f31d917a0cf03260bb55\nparent 01af5040fdada6ef8f1b749cda798d80a8590b2c\nauthor David Tolnay <dtolnay@gmail.com> 1664994194 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1664997317 -0700\n\nAdd regression test for lifetimes in alloc internals autotraits\n\nCurrently pretty much all of the btree_map and btree_set ones fail, as\nwell as linked_list::DrainFilter.\n\n    error: higher-ranked lifetime error\n      --> library/alloc/tests/autotraits.rs:38:5\n       |\n    38 | /     require_send_sync(async {\n    39 | |         let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n    40 | |         async {}.await;\n    41 | |     });\n       | |______^\n       |\n       = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:56:5\n       |\n    56 | /     require_send_sync(async {\n    57 | |         let _v = None::<\n    58 | |             alloc::collections::btree_map::DrainFilter<\n    59 | |                 '_,\n    ...  |\n    65 | |         async {}.await;\n    66 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:68:5\n       |\n    68 | /     require_send_sync(async {\n    69 | |         let _v = None::<alloc::collections::btree_map::Entry<'_, &u32, &u32>>;\n    70 | |         async {}.await;\n    71 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n      --> library/alloc/tests/autotraits.rs:88:5\n       |\n    88 | /     require_send_sync(async {\n    89 | |         let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n    90 | |         async {}.await;\n    91 | |     });\n       | |______^\n       |\n       = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n      --> library/alloc/tests/autotraits.rs:93:5\n       |\n    93 | /     require_send_sync(async {\n    94 | |         let _v = None::<alloc::collections::btree_map::IterMut<'_, &u32, &u32>>;\n    95 | |         async {}.await;\n    96 | |     });\n       | |______^ implementation of `Send` is not general enough\n       |\n       = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n       = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:98:5\n        |\n    98  | /     require_send_sync(async {\n    99  | |         let _v = None::<alloc::collections::btree_map::Keys<'_, &u32, &u32>>;\n    100 | |         async {}.await;\n    101 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:103:5\n        |\n    103 | /     require_send_sync(async {\n    104 | |         let _v = None::<alloc::collections::btree_map::OccupiedEntry<'_, &u32, &u32>>;\n    105 | |         async {}.await;\n    106 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:108:5\n        |\n    108 | /     require_send_sync(async {\n    109 | |         let _v = None::<alloc::collections::btree_map::OccupiedError<'_, &u32, &u32>>;\n    110 | |         async {}.await;\n    111 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:113:5\n        |\n    113 | /     require_send_sync(async {\n    114 | |         let _v = None::<alloc::collections::btree_map::Range<'_, &u32, &u32>>;\n    115 | |         async {}.await;\n    116 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:118:5\n        |\n    118 | /     require_send_sync(async {\n    119 | |         let _v = None::<alloc::collections::btree_map::RangeMut<'_, &u32, &u32>>;\n    120 | |         async {}.await;\n    121 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:123:5\n        |\n    123 | /     require_send_sync(async {\n    124 | |         let _v = None::<alloc::collections::btree_map::VacantEntry<'_, &u32, &u32>>;\n    125 | |         async {}.await;\n    126 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:128:5\n        |\n    128 | /     require_send_sync(async {\n    129 | |         let _v = None::<alloc::collections::btree_map::Values<'_, &u32, &u32>>;\n    130 | |         async {}.await;\n    131 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:133:5\n        |\n    133 | /     require_send_sync(async {\n    134 | |         let _v = None::<alloc::collections::btree_map::ValuesMut<'_, &u32, &u32>>;\n    135 | |         async {}.await;\n    136 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:146:5\n        |\n    146 | /     require_send_sync(async {\n    147 | |         let _v = None::<alloc::collections::btree_set::Difference<'_, &u32>>;\n    148 | |         async {}.await;\n    149 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: implementation of `Send` is not general enough\n       --> library/alloc/tests/autotraits.rs:151:5\n        |\n    151 | /     require_send_sync(async {\n    152 | |         let _v = None::<alloc::collections::btree_set::DrainFilter<'_, &u32, fn(&&u32) -> bool>>;\n    153 | |         async {}.await;\n    154 | |     });\n        | |______^ implementation of `Send` is not general enough\n        |\n        = note: `Send` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n        = note: ...but `Send` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:156:5\n        |\n    156 | /     require_send_sync(async {\n    157 | |         let _v = None::<alloc::collections::btree_set::Intersection<'_, &u32>>;\n    158 | |         async {}.await;\n    159 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:166:5\n        |\n    166 | /     require_send_sync(async {\n    167 | |         let _v = None::<alloc::collections::btree_set::Iter<'_, &u32>>;\n    168 | |         async {}.await;\n    169 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:171:5\n        |\n    171 | /     require_send_sync(async {\n    172 | |         let _v = None::<alloc::collections::btree_set::Range<'_, &u32>>;\n    173 | |         async {}.await;\n    174 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:176:5\n        |\n    176 | /     require_send_sync(async {\n    177 | |         let _v = None::<alloc::collections::btree_set::SymmetricDifference<'_, &u32>>;\n    178 | |         async {}.await;\n    179 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: higher-ranked lifetime error\n       --> library/alloc/tests/autotraits.rs:181:5\n        |\n    181 | /     require_send_sync(async {\n    182 | |         let _v = None::<alloc::collections::btree_set::Union<'_, &u32>>;\n    183 | |         async {}.await;\n    184 | |     });\n        | |______^\n        |\n        = note: could not prove `impl Future<Output = ()>: Send`\n\n    error: future cannot be sent between threads safely\n       --> library/alloc/tests/autotraits.rs:243:23\n        |\n    243 |       require_send_sync(async {\n        |  _______________________^\n    244 | |         let _v =\n    245 | |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 | |         async {}.await;\n    247 | |     });\n        | |_____^ future created by async block is not `Send`\n        |\n        = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NonNull<std::collections::linked_list::Node<&u32>>`\n    note: future is not `Send` as this value is used across an await\n       --> library/alloc/tests/autotraits.rs:246:17\n        |\n    244 |         let _v =\n        |             -- has type `Option<std::collections::linked_list::DrainFilter<'_, &u32, for<'a, 'b> fn(&'a mut &'b u32) -> bool>>` which is not `Send`\n    245 |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 |         async {}.await;\n        |                 ^^^^^^ await occurs here, with `_v` maybe used later\n    247 |     });\n        |     - `_v` is later dropped here\n    note: required by a bound in `require_send_sync`\n       --> library/alloc/tests/autotraits.rs:3:25\n        |\n    3   | fn require_send_sync<T: Send + Sync>(_: T) {}\n        |                         ^^^^ required by this bound in `require_send_sync`\n\n    error: future cannot be shared between threads safely\n       --> library/alloc/tests/autotraits.rs:243:23\n        |\n    243 |       require_send_sync(async {\n        |  _______________________^\n    244 | |         let _v =\n    245 | |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 | |         async {}.await;\n    247 | |     });\n        | |_____^ future created by async block is not `Sync`\n        |\n        = help: within `impl Future<Output = ()>`, the trait `Sync` is not implemented for `NonNull<std::collections::linked_list::Node<&u32>>`\n    note: future is not `Sync` as this value is used across an await\n       --> library/alloc/tests/autotraits.rs:246:17\n        |\n    244 |         let _v =\n        |             -- has type `Option<std::collections::linked_list::DrainFilter<'_, &u32, for<'a, 'b> fn(&'a mut &'b u32) -> bool>>` which is not `Sync`\n    245 |             None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n    246 |         async {}.await;\n        |                 ^^^^^^ await occurs here, with `_v` maybe used later\n    247 |     });\n        |     - `_v` is later dropped here\n    note: required by a bound in `require_send_sync`\n       --> library/alloc/tests/autotraits.rs:3:32\n        |\n    3   | fn require_send_sync<T: Send + Sync>(_: T) {}\n        |                                ^^^^ required by this bound in `require_send_sync`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa863414fe1f225f795c6167b12663031ef2a83a", "html_url": "https://github.com/rust-lang/rust/commit/fa863414fe1f225f795c6167b12663031ef2a83a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa863414fe1f225f795c6167b12663031ef2a83a/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01af5040fdada6ef8f1b749cda798d80a8590b2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/01af5040fdada6ef8f1b749cda798d80a8590b2c", "html_url": "https://github.com/rust-lang/rust/commit/01af5040fdada6ef8f1b749cda798d80a8590b2c"}], "stats": {"total": 297, "additions": 297, "deletions": 0}, "files": [{"sha": "8ff5f0abe73dd013aa31bc76d3d03f6475c97816", "filename": "library/alloc/tests/autotraits.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/fa863414fe1f225f795c6167b12663031ef2a83a/library%2Falloc%2Ftests%2Fautotraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa863414fe1f225f795c6167b12663031ef2a83a/library%2Falloc%2Ftests%2Fautotraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fautotraits.rs?ref=fa863414fe1f225f795c6167b12663031ef2a83a", "patch": "@@ -0,0 +1,293 @@\n+fn require_sync<T: Sync>(_: T) {}\n+fn require_send_sync<T: Send + Sync>(_: T) {}\n+\n+struct NotSend(*const ());\n+unsafe impl Sync for NotSend {}\n+\n+#[test]\n+fn test_btree_map() {\n+    // Tests of this form are prone to https://github.com/rust-lang/rust/issues/64552.\n+    //\n+    // In theory the async block's future would be Send if the value we hold\n+    // across the await point is Send, and Sync if the value we hold across the\n+    // await point is Sync.\n+    //\n+    // We test autotraits in this convoluted way, instead of a straightforward\n+    // `require_send_sync::<TypeIWantToTest>()`, because the interaction with\n+    // generators exposes some current limitations in rustc's ability to prove a\n+    // lifetime bound on the erased generator witness types. See the above link.\n+    //\n+    // A typical way this would surface in real code is:\n+    //\n+    //     fn spawn<T: Future + Send>(_: T) {}\n+    //\n+    //     async fn f() {\n+    //         let map = BTreeMap::<u32, Box<dyn Send + Sync>>::new();\n+    //         for _ in &map {\n+    //             async {}.await;\n+    //         }\n+    //     }\n+    //\n+    //     fn main() {\n+    //         spawn(f());\n+    //     }\n+    //\n+    // where with some unintentionally overconstrained Send impls in liballoc's\n+    // internals, the future might incorrectly not be Send even though every\n+    // single type involved in the program is Send and Sync.\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    // Testing like this would not catch all issues that the above form catches.\n+    require_send_sync(None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>);\n+\n+    require_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, u32, NotSend>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::BTreeMap<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<\n+            alloc::collections::btree_map::DrainFilter<\n+                '_,\n+                &u32,\n+                &u32,\n+                fn(&&u32, &mut &u32) -> bool,\n+            >,\n+        >;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Entry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoIter<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoKeys<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoValues<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IterMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Keys<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::OccupiedEntry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::OccupiedError<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Range<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::RangeMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::VacantEntry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Values<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::ValuesMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_btree_set() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::BTreeSet<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Difference<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::DrainFilter<'_, &u32, fn(&&u32) -> bool>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Intersection<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Range<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::SymmetricDifference<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Union<'_, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_binary_heap() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::BinaryHeap<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::Drain<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::DrainSorted<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::IntoIterSorted<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::PeekMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_linked_list() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::Cursor<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::CursorMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    // FIXME\n+    /*\n+    require_send_sync(async {\n+        let _v =\n+            None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n+        async {}.await;\n+    });\n+    */\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::IterMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::LinkedList<&u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_vec_deque() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::Drain<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::IterMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::VecDeque<&u32>>;\n+        async {}.await;\n+    });\n+}"}, {"sha": "ffc5ca7a5c6cc1de574f8a80a86b302c15603014", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa863414fe1f225f795c6167b12663031ef2a83a/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa863414fe1f225f795c6167b12663031ef2a83a/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=fa863414fe1f225f795c6167b12663031ef2a83a", "patch": "@@ -2,6 +2,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(cow_is_borrowed)]\n #![feature(const_box)]\n #![feature(const_convert)]\n@@ -14,6 +15,8 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(linked_list_cursors)]\n+#![feature(map_try_insert)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(trusted_len)]\n@@ -49,6 +52,7 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n \n mod arc;\n+mod autotraits;\n mod borrow;\n mod boxed;\n mod btree_set_hash;"}]}