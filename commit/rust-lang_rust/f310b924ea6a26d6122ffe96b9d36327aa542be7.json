{"sha": "f310b924ea6a26d6122ffe96b9d36327aa542be7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTBiOTI0ZWE2YTI2ZDYxMjJmZmU5NmI5ZDM2MzI3YWE1NDJiZTc=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-23T16:05:19Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-23T16:05:19Z"}, "message": "Format lazy_static! macro\n\nSome macros like `lazy_static!` cannot be parsed as a valid AST. Therefore, we\nneed to parse them manually to be able to format them. Obviously this method\nwill not scale, we will never be able to cover every macro in the entire\necosystem. That being said, I think it will not hurt to be able to format macros\nthat are popular (such as `lazy_static!`) as long as rustfmt will not produce\nbroken code when the macro has syntax that is not expected.", "tree": {"sha": "31d89efcf1030d0c9ef23f42a62203f202d6eda0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d89efcf1030d0c9ef23f42a62203f202d6eda0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f310b924ea6a26d6122ffe96b9d36327aa542be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f310b924ea6a26d6122ffe96b9d36327aa542be7", "html_url": "https://github.com/rust-lang/rust/commit/f310b924ea6a26d6122ffe96b9d36327aa542be7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f310b924ea6a26d6122ffe96b9d36327aa542be7/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebfc3af92a33b2eeed543a55fbf4929946fbe3a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebfc3af92a33b2eeed543a55fbf4929946fbe3a2", "html_url": "https://github.com/rust-lang/rust/commit/ebfc3af92a33b2eeed543a55fbf4929946fbe3a2"}], "stats": {"total": 86, "additions": 85, "deletions": 1}, "files": [{"sha": "6d65cd76eba0858ac3c03023bde280e891772d7f", "filename": "rustfmt-core/src/macros.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f310b924ea6a26d6122ffe96b9d36327aa542be7/rustfmt-core%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f310b924ea6a26d6122ffe96b9d36327aa542be7/rustfmt-core%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fmacros.rs?ref=f310b924ea6a26d6122ffe96b9d36327aa542be7", "patch": "@@ -155,7 +155,8 @@ pub fn rewrite_macro(\n     };\n \n     let ts: TokenStream = mac.node.stream();\n-    if ts.is_empty() && !contains_comment(context.snippet(mac.span)) {\n+    let has_comment = contains_comment(context.snippet(mac.span));\n+    if ts.is_empty() && !has_comment {\n         return match style {\n             MacroStyle::Parens if position == MacroPosition::Item => {\n                 Some(format!(\"{}();\", macro_name))\n@@ -165,6 +166,13 @@ pub fn rewrite_macro(\n             MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n         };\n     }\n+    // Format well-known macros which cannot be parsed as a valid AST.\n+    // TODO: Maybe add more macros?\n+    if macro_name == \"lazy_static!\" && !has_comment {\n+        if let success @ Some(..) = format_lazy_static(context, shape, &ts) {\n+            return success;\n+        }\n+    }\n \n     let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n     let mut arg_vec = Vec::new();\n@@ -848,6 +856,82 @@ impl MacroBranch {\n     }\n }\n \n+/// Format `lazy_static!` from https://crates.io/crates/lazy_static.\n+///\n+/// # Expected syntax\n+///\n+/// ```\n+/// lazy_static! {\n+///     [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n+///     [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n+///     ...\n+///     [pub] static ref NAME_N: TYPE_N = EXPR_N;\n+/// }\n+/// ```\n+fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream) -> Option<String> {\n+    let mut result = String::with_capacity(1024);\n+    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let nested_shape = shape.block_indent(context.config.tab_spaces());\n+\n+    result.push_str(\"lazy_static! {\");\n+    result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n+\n+    macro parse_or($method:ident $(,)* $($arg:expr),* $(,)*) {\n+        match parser.$method($($arg,)*) {\n+            Ok(val) => {\n+                if parser.sess.span_diagnostic.has_errors() {\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    return None;\n+                } else {\n+                    val\n+                }\n+            }\n+            Err(mut err) => {\n+                err.cancel();\n+                parser.sess.span_diagnostic.reset_err_count();\n+                return None;\n+            }\n+        }\n+    }\n+\n+    while parser.token != Token::Eof {\n+        // Parse a `lazy_static!` item.\n+        let vis = ::utils::format_visibility(&parse_or!(parse_visibility, false));\n+        parser.eat_keyword(symbol::keywords::Static);\n+        parser.eat_keyword(symbol::keywords::Ref);\n+        let id = parse_or!(parse_ident);\n+        parser.eat(&Token::Colon);\n+        let ty = parse_or!(parse_ty);\n+        parser.eat(&Token::Eq);\n+        let expr = parse_or!(parse_expr);\n+        parser.eat(&Token::Semi);\n+\n+        // Rewrite as a static item.\n+        let mut stmt = String::with_capacity(128);\n+        stmt.push_str(&format!(\n+            \"{}static ref {}: {} =\",\n+            vis,\n+            id,\n+            ty.rewrite(context, shape)?\n+        ));\n+        result.push_str(&::expr::rewrite_assign_rhs(\n+            context,\n+            stmt,\n+            &*expr,\n+            nested_shape.sub_width(1)?,\n+        )?);\n+        result.push(';');\n+        if parser.token != Token::Eof {\n+            result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n+        }\n+    }\n+\n+    result.push_str(&shape.indent.to_string_with_newline(context.config));\n+    result.push('}');\n+\n+    Some(result)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}]}