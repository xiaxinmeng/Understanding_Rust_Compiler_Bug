{"sha": "6bd782c4ca40482937bb5253a2d3e96548ab5021", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZDc4MmM0Y2E0MDQ4MjkzN2JiNTI1M2EyZDNlOTY1NDhhYjUwMjE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-27T20:49:18Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-31T19:42:27Z"}, "message": "Try to run compiler callbacks when we error out", "tree": {"sha": "18ddf29417b83b84bb963557c68b8744f66583ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ddf29417b83b84bb963557c68b8744f66583ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bd782c4ca40482937bb5253a2d3e96548ab5021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd782c4ca40482937bb5253a2d3e96548ab5021", "html_url": "https://github.com/rust-lang/rust/commit/6bd782c4ca40482937bb5253a2d3e96548ab5021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bd782c4ca40482937bb5253a2d3e96548ab5021/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e4f18e55e042ff7d1962280106e38050af2361", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e4f18e55e042ff7d1962280106e38050af2361", "html_url": "https://github.com/rust-lang/rust/commit/b6e4f18e55e042ff7d1962280106e38050af2361"}], "stats": {"total": 181, "additions": 106, "deletions": 75}, "files": [{"sha": "c189df18a82e1ab93ec205a81ba33f4df04519eb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 93, "deletions": 67, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6bd782c4ca40482937bb5253a2d3e96548ab5021", "patch": "@@ -16,10 +16,11 @@ use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{stability, ty, reachable};\n-use rustc::middle::dependency_format;\n+use rustc::middle::{dependency_format, stability, ty, reachable};\n+use rustc::middle::privacy::AccessLevels;\n use rustc::middle;\n use rustc::util::common::time;\n+use rustc::util::nodemap::NodeSet;\n use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n use rustc_metadata::macro_import;\n@@ -57,15 +58,6 @@ use syntax::visit;\n use syntax;\n use syntax_ext;\n \n-macro_rules! throw_if_errors {\n-    ($tsess: expr) => {{\n-        let err_count = $tsess.err_count();\n-        if err_count > 0 {\n-            return Err(err_count);\n-        }\n-    }}\n-}\n-\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      cfg: ast::CrateConfig,\n@@ -74,14 +66,19 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: CompileController) -> CompileResult {\n-    macro_rules! controller_entry_point{($point: ident, $tsess: expr, $make_state: expr) => ({\n-        let state = $make_state;\n-        (control.$point.callback)(state);\n+    macro_rules! controller_entry_point {\n+        ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n+            let state = $make_state;\n+            let phase_result: &CompileResult = &$phase_result;\n+            if phase_result.is_ok() || control.$point.run_callback_on_error {\n+                (control.$point.callback)(state);\n+            }\n \n-        if control.$point.stop == Compilation::Stop {\n-            return compile_result_from_err_count($tsess.err_count());\n-        }\n-    })}\n+            if control.$point.stop == Compilation::Stop {\n+                return compile_result_from_err_count($tsess.err_count());\n+            }\n+        }}\n+    }\n \n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n@@ -92,7 +89,8 @@ pub fn compile_input(sess: &Session,\n \n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input, sess, outdir, &krate));\n+                                    CompileState::state_after_parse(input, sess, outdir, &krate),\n+                                    Ok(()));\n \n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n@@ -111,7 +109,8 @@ pub fn compile_input(sess: &Session,\n                                                                  sess,\n                                                                  outdir,\n                                                                  &expanded_crate,\n-                                                                 &id[..]));\n+                                                                 &id[..]),\n+                                Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         // Lower ast -> hir.\n@@ -140,7 +139,8 @@ pub fn compile_input(sess: &Session,\n                                                                      &expanded_crate,\n                                                                      &hir_map.krate(),\n                                                                      &id[..],\n-                                                                     &lcx));\n+                                                                     &lcx),\n+                                Ok(()));\n \n         time(sess.time_passes(), \"attribute checking\", || {\n             front::check_attr::check_crate(sess, &expanded_crate);\n@@ -159,38 +159,38 @@ pub fn compile_input(sess: &Session,\n         };\n \n         try!(try!(phase_3_run_analysis_passes(sess,\n-                                         &cstore,\n-                                         hir_map,\n-                                         &arenas,\n-                                         &id,\n-                                         control.make_glob_map,\n-                                         |tcx, mir_map, analysis| {\n+                                              &cstore,\n+                                              hir_map,\n+                                              &arenas,\n+                                              &id,\n+                                              control.make_glob_map,\n+                                              |tcx, mir_map, analysis, result| {\n             {\n-                let state =\n-                    CompileState::state_after_analysis(input,\n-                                                       &tcx.sess,\n-                                                       outdir,\n-                                                       opt_crate,\n-                                                       tcx.map.krate(),\n-                                                       &analysis,\n-                                                       &mir_map,\n-                                                       tcx,\n-                                                       &lcx,\n-                                                       &id);\n+                let state = CompileState::state_after_analysis(input,\n+                                                               &tcx.sess,\n+                                                               outdir,\n+                                                               opt_crate,\n+                                                               tcx.map.krate(),\n+                                                               &analysis,\n+                                                               mir_map.as_ref(),\n+                                                               tcx,\n+                                                               &lcx,\n+                                                               &id);\n                 (control.after_analysis.callback)(state);\n \n-                throw_if_errors!(tcx.sess);\n                 if control.after_analysis.stop == Compilation::Stop {\n                     return Err(0usize);\n                 }\n             }\n \n+            try!(result);\n+\n             if log_enabled!(::log::INFO) {\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n             let trans = phase_4_translate_to_llvm(tcx,\n-                                                  mir_map,\n+                                                  mir_map.unwrap(),\n                                                   analysis);\n \n             if log_enabled!(::log::INFO) {\n@@ -205,17 +205,20 @@ pub fn compile_input(sess: &Session,\n         })))\n     };\n \n-    try!(phase_5_run_llvm_passes(sess, &trans, &outputs));\n+    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, &trans));\n+                            CompileState::state_after_llvm(input, sess, outdir, &trans),\n+                            phase5_result);\n+    try!(phase5_result);\n \n     phase_6_link_output(sess, &trans, &outputs);\n \n     Ok(())\n }\n \n+\n /// The name used for source code that doesn't originate in a file\n /// (e.g. source from stdin or a string)\n pub fn anon_src() -> String {\n@@ -269,13 +272,17 @@ impl<'a> CompileController<'a> {\n \n pub struct PhaseController<'a> {\n     pub stop: Compilation,\n+    // If true then the compiler will try to run the callback even if the phase\n+    // ends with an error. Note that this is not always possible.\n+    pub run_callback_on_error: bool,\n     pub callback: Box<Fn(CompileState) -> () + 'a>,\n }\n \n impl<'a> PhaseController<'a> {\n     pub fn basic() -> PhaseController<'a> {\n         PhaseController {\n             stop: Compilation::Continue,\n+            run_callback_on_error: false,\n             callback: box |_| {},\n         }\n     }\n@@ -372,14 +379,14 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis,\n-                            mir_map: &'a MirMap<'tcx>,\n+                            mir_map: Option<&'a MirMap<'tcx>>,\n                             tcx: &'a ty::ctxt<'tcx>,\n                             lcx: &'a LoweringContext<'a>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n-            mir_map: Some(mir_map),\n+            mir_map: mir_map,\n             tcx: Some(tcx),\n             krate: krate,\n             hir_crate: Some(hir_crate),\n@@ -713,8 +720,20 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> Result<R, usize>\n-    where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>, MirMap<'tcx>, ty::CrateAnalysis) -> R\n+    where F: FnOnce(&ty::ctxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n {\n+    macro_rules! try_with_f {\n+        ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n+            match $e {\n+                Ok(x) => x,\n+                Err(x) => {\n+                    f($t, $m, $a, Err(x));\n+                    return Err(x);\n+                }\n+            }\n+        }\n+    }\n+\n     let time_passes = sess.time_passes();\n     let krate = hir_map.krate();\n \n@@ -739,6 +758,14 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"resolution\",\n              || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n \n+    let mut analysis = ty::CrateAnalysis {\n+        export_map: export_map,\n+        access_levels: AccessLevels::default(),\n+        reachable: NodeSet(),\n+        name: name,\n+        glob_map: glob_map,\n+    };\n+\n     let named_region_map = try!(time(time_passes,\n                                      \"lifetime resolution\",\n                                      || middle::resolve_lifetime::krate(sess,\n@@ -776,22 +803,22 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                stability::Index::new(krate),\n                                |tcx| {\n         // passes are timed inside typeck\n-        try!(typeck::check_crate(tcx, trait_map));\n+        try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n \n         time(time_passes,\n              \"const checking\",\n              || consts::check_crate(tcx));\n \n-        let access_levels =\n+        analysis.access_levels =\n             time(time_passes, \"privacy checking\", || {\n                 rustc_privacy::check_crate(tcx,\n-                                           &export_map,\n+                                           &analysis.export_map,\n                                            external_exports)\n             });\n \n         // Do not move this check past lint\n         time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx, krate, &access_levels)\n+            tcx.stability.borrow_mut().build(tcx, krate, &analysis.access_levels)\n         });\n \n         time(time_passes,\n@@ -829,15 +856,17 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lot of annoying errors in the compile-fail tests (basically,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n-        throw_if_errors!(tcx.sess);\n+        if sess.err_count() > 0 {\n+            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+        }\n \n-        let reachable_map =\n+        analysis.reachable =\n             time(time_passes,\n                  \"reachability checking\",\n-                 || reachable::find_reachable(tcx, &access_levels));\n+                 || reachable::find_reachable(tcx, &analysis.access_levels));\n \n         time(time_passes, \"death checking\", || {\n-            middle::dead::check_crate(tcx, &access_levels);\n+            middle::dead::check_crate(tcx, &analysis.access_levels);\n         });\n \n         let ref lib_features_used =\n@@ -852,20 +881,14 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes,\n              \"lint checking\",\n-             || lint::check_crate(tcx, &access_levels));\n+             || lint::check_crate(tcx, &analysis.access_levels));\n \n         // The above three passes generate errors w/o aborting\n-        throw_if_errors!(tcx.sess);\n-\n-        Ok(f(tcx,\n-          mir_map,\n-          ty::CrateAnalysis {\n-              export_map: export_map,\n-              access_levels: access_levels,\n-              reachable: reachable_map,\n-              name: name,\n-              glob_map: glob_map,\n-          }))\n+        if sess.err_count() > 0 {\n+            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+        }\n+\n+        Ok(f(tcx, Some(mir_map), analysis, Ok(())))\n     })\n }\n \n@@ -915,8 +938,11 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n-    throw_if_errors!(sess);\n-    Ok(())\n+    if sess.err_count() > 0 {\n+        Err(sess.err_count())\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Run the linker on any artifacts that resulted from the LLVM run."}, {"sha": "70bd938321a8e70250ebed79c08188ad570e4610", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6bd782c4ca40482937bb5253a2d3e96548ab5021", "patch": "@@ -134,7 +134,7 @@ pub fn run(args: Vec<String>) -> isize {\n                         let mut emitter =\n                             errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n                         emitter.emit(None, &abort_msg(err_count), None, errors::Level::Fatal);\n-                        panic!(errors::FatalError);\n+                        exit_on_err();\n                     }\n                 }\n             }\n@@ -450,6 +450,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                         state.out_dir)\n                 });\n             };\n+            control.after_analysis.run_callback_on_error = true;\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }\n \n@@ -935,15 +936,19 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n             }\n \n-            // Panic so the process returns a failure code, but don't pollute the\n-            // output with some unnecessary panic messages, we've already\n-            // printed everything that we needed to.\n-            io::set_panic(box io::sink());\n-            panic!();\n+            exit_on_err();\n         }\n     }\n }\n \n+fn exit_on_err() -> ! {\n+    // Panic so the process returns a failure code, but don't pollute the\n+    // output with some unnecessary panic messages, we've already\n+    // printed everything that we needed to.\n+    io::set_panic(box io::sink());\n+    panic!();\n+}\n+\n pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n "}, {"sha": "91af78a5bd4fbaaf92ac171aec970f67cb98bbde", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd782c4ca40482937bb5253a2d3e96548ab5021/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6bd782c4ca40482937bb5253a2d3e96548ab5021", "patch": "@@ -200,7 +200,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  resolve::MakeGlobMap::No,\n-                                                                 |tcx, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -824,7 +824,7 @@ pub fn pretty_print_input(sess: Session,\n                                                                      &arenas,\n                                                                      &id,\n                                                                      resolve::MakeGlobMap::No,\n-                                                                     |tcx, _, _| {\n+                                                                     |tcx, _, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n                                         code,"}]}