{"sha": "c5082fe801d8704a9c33a706daf63d1abfdfca90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDgyZmU4MDFkODcwNGE5YzMzYTcwNmRhZjYzZDFhYmZkZmNhOTA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-31T20:48:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-31T20:48:27Z"}, "message": "Rollup merge of #40871 - projektir:atomic_links, r=steveklabnik\n\nAdding links for Atomics docs #29377\n\nr? @steveklabnik\n\nThis should be good for `std::sync::atomic`. The other pages still need more (examples, etc.).", "tree": {"sha": "c816b902eb5b54bc52d94df0a0abbdf349a52c9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c816b902eb5b54bc52d94df0a0abbdf349a52c9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5082fe801d8704a9c33a706daf63d1abfdfca90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5082fe801d8704a9c33a706daf63d1abfdfca90", "html_url": "https://github.com/rust-lang/rust/commit/c5082fe801d8704a9c33a706daf63d1abfdfca90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5082fe801d8704a9c33a706daf63d1abfdfca90/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6edab01499c2af1b04e5914a64f0e66ae50253c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6edab01499c2af1b04e5914a64f0e66ae50253c3", "html_url": "https://github.com/rust-lang/rust/commit/6edab01499c2af1b04e5914a64f0e66ae50253c3"}, {"sha": "4ea03c876ba864946ed50fde7788cfe2383027f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ea03c876ba864946ed50fde7788cfe2383027f1", "html_url": "https://github.com/rust-lang/rust/commit/4ea03c876ba864946ed50fde7788cfe2383027f1"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "ae47e6fdfa928ee6b037d9d7e1c1e80cd74bfdfc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c5082fe801d8704a9c33a706daf63d1abfdfca90/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5082fe801d8704a9c33a706daf63d1abfdfca90/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=c5082fe801d8704a9c33a706daf63d1abfdfca90", "patch": "@@ -15,27 +15,37 @@\n //! types.\n //!\n //! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicIsize`, and `AtomicUsize`.\n+//! types, including [`AtomicBool`], [`AtomicIsize`], and [`AtomicUsize`].\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!\n-//! Each method takes an `Ordering` which represents the strength of\n+//! [`AtomicBool`]: struct.AtomicBool.html\n+//! [`AtomicIsize`]: struct.AtomicIsize.html\n+//! [`AtomicUsize`]: struct.AtomicUsize.html\n+//!\n+//! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n //! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n //!\n+//! [`Ordering`]: enum.Ordering.html\n+//!\n //! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //! [2]: ../../../nomicon/atomics.html\n //!\n-//! Atomic variables are safe to share between threads (they implement `Sync`)\n+//! Atomic variables are safe to share between threads (they implement [`Sync`])\n //! but they do not themselves provide the mechanism for sharing and follow the\n //! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n-//! The most common way to share an atomic variable is to put it into an `Arc` (an\n+//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n+//! [`Sync`]: ../../marker/trait.Sync.html\n+//! [arc]: ../../../std/sync/struct.Arc.html\n+//!\n //! Most atomic types may be stored in static variables, initialized using\n-//! the provided static initializers like `ATOMIC_BOOL_INIT`. Atomic statics\n+//! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n //! are often used for lazy global initialization.\n //!\n+//! [`ATOMIC_BOOL_INIT`]: constant.ATOMIC_BOOL_INIT.html\n //!\n //! # Examples\n //!\n@@ -148,22 +158,32 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n-    /// No ordering constraints, only atomic operations. Corresponds to LLVM's\n-    /// `Monotonic` ordering.\n+    /// No ordering constraints, only atomic operations.\n+    ///\n+    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    ///\n+    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with `Acquire` ordering\n+    /// to the other threads that perform a load with [`Acquire`] ordering\n     /// on the same value.\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n+    /// written before a store with [`Release`] ordering on the same value\n     /// in other threads.\n+    ///\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering.\n+    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n+    /// [`Release`] ordering.\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n@@ -176,7 +196,9 @@ pub enum Ordering {\n     __Nonexhaustive,\n }\n \n-/// An `AtomicBool` initialized to `false`.\n+/// An [`AtomicBool`] initialized to `false`.\n+///\n+/// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n@@ -250,7 +272,7 @@ impl AtomicBool {\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -287,7 +309,10 @@ impl AtomicBool {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n@@ -404,7 +429,7 @@ impl AtomicBool {\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n@@ -415,6 +440,7 @@ impl AtomicBool {\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n+    /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -694,7 +720,10 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -1008,7 +1037,10 @@ macro_rules! atomic_int {\n             ///\n             /// # Panics\n             ///\n-            /// Panics if `order` is `Acquire` or `AcqRel`.\n+            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+            ///\n+            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             #[inline]\n             #[$stable]\n             pub fn store(&self, val: $int_type, order: Ordering) {"}]}