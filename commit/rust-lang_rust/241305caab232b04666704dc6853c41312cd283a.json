{"sha": "241305caab232b04666704dc6853c41312cd283a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MTMwNWNhYWIyMzJiMDQ2NjY3MDRkYzY4NTNjNDEzMTJjZDI4M2E=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-06-25T07:47:23Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-06-25T07:47:23Z"}, "message": "Resolve and typecheck patterns in pattern alt redux.  This time featuring way more correctness.", "tree": {"sha": "9a8cd9ef0573d15477927afb02620c723745ddcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a8cd9ef0573d15477927afb02620c723745ddcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/241305caab232b04666704dc6853c41312cd283a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/241305caab232b04666704dc6853c41312cd283a", "html_url": "https://github.com/rust-lang/rust/commit/241305caab232b04666704dc6853c41312cd283a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/241305caab232b04666704dc6853c41312cd283a/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d9565a4c144c07dab052161eb5fa3815dcd7f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9565a4c144c07dab052161eb5fa3815dcd7f06", "html_url": "https://github.com/rust-lang/rust/commit/0d9565a4c144c07dab052161eb5fa3815dcd7f06"}], "stats": {"total": 223, "additions": 142, "deletions": 81}, "files": [{"sha": "770b57bf82bb3e1d3949234f2393e51dc0fbc4b0", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -299,9 +299,14 @@ and domain =\n     DOMAIN_local\n   | DOMAIN_thread\n \n+(*\n+ * PAT_tag uses lval for the tag constructor so that we can reuse our lval\n+ * resolving machinery.  The lval is restricted during parsing to have only\n+ * named components.\n+ *)\n and pat =\n     PAT_lit of lit\n-  | PAT_tag of ((name identified) * (pat array))\n+  | PAT_tag of (lval * (pat array))\n   | PAT_slot of ((slot identified) * ident)\n   | PAT_wild\n \n@@ -331,6 +336,7 @@ and lval_component =\n   | COMP_atom of atom\n \n \n+(* identifying the name_base here is sufficient to identify the full lval *)\n and lval =\n     LVAL_base of name_base identified\n   | LVAL_ext of (lval * lval_component)"}, {"sha": "031b9e49441310990c687af8b1e9bc7081d52d41", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -127,6 +127,16 @@ and parse_auto_slot_and_init\n \n and parse_stmts (ps:pstate) : Ast.stmt array =\n   let apos = lexpos ps in\n+\n+  let rec name_to_lval (apos:pos) (bpos:pos) (name:Ast.name)\n+      : Ast.lval =\n+    match name with\n+        Ast.NAME_base nb ->\n+          Ast.LVAL_base (span ps apos bpos nb)\n+      | Ast.NAME_ext (n, nc) ->\n+          Ast.LVAL_ext (name_to_lval apos bpos n, Ast.COMP_named nc)\n+  in\n+\n     match peek ps with\n \n         LOG ->\n@@ -139,15 +149,6 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n           bump ps;\n           begin\n \n-            let rec name_to_lval (bpos:pos) (name:Ast.name)\n-                : Ast.lval =\n-              match name with\n-                  Ast.NAME_base nb ->\n-                    Ast.LVAL_base (span ps apos bpos nb)\n-                | Ast.NAME_ext (n, nc) ->\n-                    Ast.LVAL_ext (name_to_lval bpos n, Ast.COMP_named nc)\n-            in\n-\n             let rec carg_path_to_lval (bpos:pos) (path:Ast.carg_path)\n                 : Ast.lval =\n               match path with\n@@ -171,7 +172,7 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n \n             let synthesise_check_call (bpos:pos) (constr:Ast.constr)\n                 : (Ast.lval * (Ast.atom array)) =\n-              let lval = name_to_lval bpos constr.Ast.constr_name in\n+              let lval = name_to_lval apos bpos constr.Ast.constr_name in\n               let args =\n                 Array.map (carg_to_atom bpos) constr.Ast.constr_args\n               in\n@@ -243,13 +244,14 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n                                 |_ -> raise (unexpected ps)\n                             end\n                           else\n-                            let pats =\n-                              paren_comma_list parse_pat ps\n-                            in\n-                            Ast.PAT_tag ((span ps apos bpos name), pats)\n+                            let lv = name_to_lval apos bpos name in\n+                              Ast.PAT_tag (lv, paren_comma_list parse_pat ps)\n+\n                       | LIT_INT _ | LIT_CHAR _ | LIT_BOOL _ ->\n                           Ast.PAT_lit (Pexp.parse_lit ps)\n+\n                       | UNDERSCORE -> bump ps; Ast.PAT_wild\n+\n                       | tok -> raise (Parse_err (ps,\n                           \"Expected pattern but found '\" ^\n                             (string_of_tok tok) ^ \"'\"))"}, {"sha": "6c4810404b282d232f226d5482e6f06226af0a28", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -868,56 +868,57 @@ let resolve_recursion\n \n let pattern_resolving_visitor\n     (cx:ctxt)\n-    (scopes:scope list ref)\n     (inner:Walk.visitor) : Walk.visitor =\n \n-  let not_tag_ctor (nid:Ast.name identified) : unit =\n-    err (Some nid.id) \"'%s' is not a tag constructor\"\n-      (string_of_name nid.node)\n+  let not_tag_ctor nm id : unit =\n+    err (Some id) \"'%s' is not a tag constructor\" (string_of_name nm)\n   in\n \n   let resolve_pat_tag\n-      (namei:Ast.name identified)\n+      (name:Ast.name)\n+      (id:node_id)\n       (pats:Ast.pat array)\n       (tag_ctor_id:node_id)\n       : unit =\n \n+    (* NB this isn't really the proper tag type, since we aren't applying any\n+     * type parameters from the tag constructor in the pattern, but since we\n+     * are only looking at the fact that it's a tag-like type at all, and\n+     * asking for its arity, it doesn't matter that the possibly parametric\n+     * tag type has its parameters unbound here. *)\n     let tag_ty = \n-      fn_output_ty\n-        (Hashtbl.find cx.ctxt_all_item_types tag_ctor_id)\n+      fn_output_ty (Hashtbl.find cx.ctxt_all_item_types tag_ctor_id)\n     in\n       begin\n         match tag_ty with\n             Ast.TY_tag _\n           | Ast.TY_iso _ ->\n-              let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty namei.node in\n+              let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty name in\n               let arity = Array.length tag_ty_tup in\n-                if (Array.length pats) == arity\n-                then Hashtbl.add cx.ctxt_pattag_to_item namei.id tag_ctor_id\n-                else err (Some namei.id)\n-                  \"tag pattern '%s' with wrong number of components\"\n-                  (string_of_name namei.node)\n-          | _ -> not_tag_ctor namei\n+                if (Array.length pats) != arity\n+                then\n+                  err (Some id)\n+                    \"tag pattern '%s' with wrong number of components\"\n+                    (string_of_name name)\n+                else ()\n+          | _ -> not_tag_ctor name id\n       end\n   in\n \n   let resolve_arm { node = arm } =\n     match fst arm with\n-        Ast.PAT_tag (namei, pats) ->\n-          begin\n-            match lookup_by_name cx !scopes namei.node with\n-                None ->\n-                  err (Some namei.id) \"unresolved tag constructor '%s'\"\n-                    (string_of_name namei.node)\n-              | Some (_, tag_ctor_id) when referent_is_item cx tag_ctor_id ->\n-                  (*\n-                   * FIXME we should actually check here that the function\n-                   * is a tag value-ctor.  For now this actually allows any\n-                   * function returning a tag type to pass as a tag pattern.\n-                   *)\n-                  resolve_pat_tag namei pats tag_ctor_id\n-              |_ -> not_tag_ctor namei\n-          end\n+        Ast.PAT_tag (lval, pats) ->\n+          let lval_nm = lval_to_name lval in\n+          let lval_id = lval_base_id lval in\n+          let tag_ctor_id = lval_to_referent cx lval_id in\n+            if referent_is_item cx tag_ctor_id\n+              (*\n+               * FIXME we should actually check here that the function\n+               * is a tag value-ctor.  For now this actually allows any\n+               * function returning a tag type to pass as a tag pattern.\n+               *)\n+            then resolve_pat_tag lval_nm lval_id pats tag_ctor_id\n+            else not_tag_ctor lval_nm lval_id\n       | _ -> ()\n   in\n \n@@ -968,8 +969,8 @@ let process_crate\n   let passes_2 =\n     [|\n       (scope_stack_managing_visitor scopes\n-        (pattern_resolving_visitor cx scopes\n-          Walk.empty_visitor))\n+         (pattern_resolving_visitor cx\n+            Walk.empty_visitor))\n     |]\n   in\n     log cx \"running primary resolve passes\";"}, {"sha": "b2ce7b793e091f03041a1979db67b9d70a22ece0", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -102,7 +102,6 @@ type ctxt =\n \n       (* reference id --> definition id *)\n       ctxt_lval_to_referent: (node_id,node_id) Hashtbl.t;\n-      ctxt_pattag_to_item: (node_id,node_id) Hashtbl.t;\n \n       ctxt_required_items: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n       ctxt_required_syms: (node_id, string) Hashtbl.t;\n@@ -187,7 +186,6 @@ let new_ctxt sess abi crate =\n     ctxt_all_lvals = Hashtbl.create 0;\n     ctxt_all_defns = Hashtbl.create 0;\n     ctxt_lval_to_referent = Hashtbl.create 0;\n-    ctxt_pattag_to_item = Hashtbl.create 0;\n     ctxt_required_items = crate.Ast.crate_required;\n     ctxt_required_syms = crate.Ast.crate_required_syms;\n \n@@ -409,14 +407,29 @@ let fn_output_ty (fn_ty:Ast.ty) : Ast.ty =\n     | _ -> bug () \"fn_output_ty on non-TY_fn\"\n ;;\n \n+(* name of tag constructor function -> name for indexing in the ty_tag *)\n+let rec tag_ctor_name_to_tag_name (name:Ast.name) : Ast.name =\n+  match name with\n+      Ast.NAME_base nb ->\n+        begin\n+          match nb with\n+              Ast.BASE_ident _ -> name\n+            | Ast.BASE_app (id, _) -> Ast.NAME_base (Ast.BASE_ident id)\n+            | _ ->\n+                bug () \"tag_or_iso_ty_tup_by_name with non-tag-ctor name\"\n+        end\n+    | Ast.NAME_ext (inner_name, _) -> tag_ctor_name_to_tag_name inner_name\n+;;\n+\n let tag_or_iso_ty_tup_by_name (ty:Ast.ty) (name:Ast.name) : Ast.ty_tup =\n-  match ty with\n-      Ast.TY_tag tags ->\n-        Hashtbl.find tags name\n-    | Ast.TY_iso { Ast.iso_index = i; Ast.iso_group = gp } ->\n-        Hashtbl.find gp.(i) name\n-    | _ ->\n-        bug () \"tag_or_iso_ty_tup_by_name called with non-tag or -iso type\"\n+  let tagname = tag_ctor_name_to_tag_name name in\n+    match ty with\n+        Ast.TY_tag tags ->\n+          Hashtbl.find tags tagname\n+      | Ast.TY_iso { Ast.iso_index = i; Ast.iso_group = gp } ->\n+          Hashtbl.find gp.(i) tagname\n+      | _ ->\n+          bug () \"tag_or_iso_ty_tup_by_name called with non-tag or -iso type\"\n ;;\n \n let defn_is_slot (d:defn) : bool =\n@@ -499,6 +512,22 @@ let atoms_to_names (atoms:Ast.atom array)\n     atoms\n ;;\n \n+let rec lval_to_name (lv:Ast.lval) : Ast.name =\n+  match lv with\n+      Ast.LVAL_base { node = nb } ->\n+        Ast.NAME_base nb\n+    | Ast.LVAL_ext (lv, lv_comp) ->\n+        let comp =\n+          begin\n+            match lv_comp with\n+                Ast.COMP_named comp -> comp\n+              | _ -> bug ()\n+                  \"lval_to_name with lval that contains non-name components\"\n+          end\n+        in\n+          Ast.NAME_ext (lval_to_name lv, comp)\n+;;\n+\n let rec lval_base_id (lv:Ast.lval) : node_id =\n   match lv with\n       Ast.LVAL_base nbi -> nbi.id"}, {"sha": "02b8e3f709fae5a9bedd81ba5839a941847e0ed5", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -3761,8 +3761,8 @@ let trans_visitor\n             Ast.PAT_lit lit ->\n               trans_compare Il.JNE (trans_lit lit) (Il.Cell src_cell)\n \n-          | Ast.PAT_tag (tag_namei, pats) ->\n-              let tag_name = tag_namei.node in\n+          | Ast.PAT_tag (lval, pats) ->\n+              let tag_name = tag_ctor_name_to_tag_name (lval_to_name lval) in\n               let ty_tag =\n                 match slot_ty src_slot with\n                     Ast.TY_tag tag_ty -> tag_ty"}, {"sha": "01438142831d00509288eb84b7ac6d133aac407b", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -881,7 +881,7 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n       in\n         match lval with\n             Ast.LVAL_base nbi ->\n-              let referent = Hashtbl.find cx.ctxt_lval_to_referent nbi.id in\n+              let referent = lval_to_referent cx nbi.id in\n                 begin\n                   match Hashtbl.find cx.ctxt_all_defns referent with\n                       DEFN_slot slot ->\n@@ -1196,33 +1196,54 @@ let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n         | _ -> ()\n     in\n \n+    (*\n+     * Tag patterns give us the type of every sub-pattern in the tag tuple, so\n+     * we can \"expect\" those types by pushing them on a stack.  Checking a\n+     * pattern therefore involves seeing that it matches the \"expected\" type,\n+     * and in turn setting any expectations for the inner descent.\n+     *)\n     let visit_pat_pre (pat:Ast.pat) : unit =\n       let expected = pat_tv() in\n         match pat with\n             Ast.PAT_lit lit -> unify_lit lit expected\n \n-          | Ast.PAT_tag (namei, _) ->\n+          | Ast.PAT_tag (lval, _) ->\n               let expect ty =\n                 let tv = ref TYSPEC_all in\n                   unify_ty ty tv;\n                   push_pat_tv tv;\n               in\n-              let item_id = Hashtbl.find cx.ctxt_pattag_to_item namei.id in\n-              let tag_ty =\n-                fn_output_ty (Hashtbl.find cx.ctxt_all_item_types item_id)\n-              in\n-              let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty namei.node in\n-              let tag_tv = ref TYSPEC_all in\n-                unify_ty tag_ty tag_tv;\n-                unify_tyvars expected tag_tv;\n-                List.iter\n-                  begin\n-                    fun slot ->\n-                      match slot.Ast.slot_ty with\n+\n+              let lval_nm = lval_to_name lval in\n+\n+              (* The lval here is our tag constructor, which we've already\n+               * resolved (in Resolve) to have a the actual tag constructor\n+               * function item as its referent.  It should hence unify\n+               * exactly to that function type, rebuilt under any latent type\n+               * parameters applied in the lval. *)\n+              let lval_tv = ref TYSPEC_all in\n+                unify_lval lval lval_tv;\n+                let tag_ctor_ty =\n+                  match !(resolve_tyvar lval_tv) with\n+                      TYSPEC_resolved (_, ty) -> ty\n+                    | _ ->\n+                        bug () \"tag constructor is not a fully resolved type.\"\n+                in\n+\n+                let tag_ty = fn_output_ty tag_ctor_ty in\n+                let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty lval_nm in\n+\n+                let tag_tv = ref TYSPEC_all in\n+                  unify_ty tag_ty tag_tv;\n+                  unify_tyvars expected tag_tv;\n+                  List.iter\n+                    begin\n+                      fun slot ->\n+                        match slot.Ast.slot_ty with\n                           Some ty -> expect ty\n-                        | None -> bug () \"no slot type in tag slot tuple\"\n-                  end\n-                  (List.rev (Array.to_list tag_ty_tup));\n+                          | None -> bug () \"no slot type in tag slot tuple\"\n+                    end\n+                    (List.rev (Array.to_list tag_ty_tup));\n \n           | Ast.PAT_slot (sloti, _) ->\n               unify_slot sloti.node (Some sloti.id) expected"}, {"sha": "57864f99149c9e5a276a6901f98130ba7da01947", "filename": "src/boot/me/walk.ml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -655,15 +655,17 @@ and walk_pat\n   let walk p =\n     match p with\n         Ast.PAT_lit lit -> walk_lit v lit\n-      | Ast.PAT_tag (_, pats) -> Array.iter (walk_pat v) pats\n+      | Ast.PAT_tag (lv, pats) ->\n+          walk_lval v lv;\n+          Array.iter (walk_pat v) pats\n       | Ast.PAT_slot (si, _) -> walk_slot_identified v si\n       | Ast.PAT_wild -> ()\n   in\n-  walk_bracketed\n-    v.visit_pat_pre\n-    (fun _ -> walk p)\n-    v.visit_pat_post\n-    p\n+    walk_bracketed\n+      v.visit_pat_pre\n+      (fun _ -> walk p)\n+      v.visit_pat_post\n+      p\n \n \n and walk_block"}, {"sha": "1f4c5465157e42a97112a4ca3bba4fcf9bad8cc0", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/241305caab232b04666704dc6853c41312cd283a/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241305caab232b04666704dc6853c41312cd283a/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=241305caab232b04666704dc6853c41312cd283a", "patch": "@@ -3,7 +3,7 @@ type foo[T] = tag(arm(T));\n fn altfoo[T](foo[T] f) {\n   auto hit = false;\n   alt (f) {\n-    case (arm(x)) {\n+    case (arm[T](x)) {\n       log \"in arm\";\n       hit = true;\n     }"}]}