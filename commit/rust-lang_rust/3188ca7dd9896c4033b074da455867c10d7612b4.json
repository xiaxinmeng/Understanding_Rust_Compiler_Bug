{"sha": "3188ca7dd9896c4033b074da455867c10d7612b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxODhjYTdkZDk4OTZjNDAzM2IwNzRkYTQ1NTg2N2MxMGQ3NjEyYjQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-04-05T18:36:39Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-19T08:25:13Z"}, "message": "update `discriminant_value` usage in the compiler", "tree": {"sha": "064d0335e22823a6e87ed4a73ab7886e613fd271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064d0335e22823a6e87ed4a73ab7886e613fd271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3188ca7dd9896c4033b074da455867c10d7612b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3188ca7dd9896c4033b074da455867c10d7612b4", "html_url": "https://github.com/rust-lang/rust/commit/3188ca7dd9896c4033b074da455867c10d7612b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3188ca7dd9896c4033b074da455867c10d7612b4/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25930e47ba0f53b6ff3bd439f6478747884a05b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/25930e47ba0f53b6ff3bd439f6478747884a05b2", "html_url": "https://github.com/rust-lang/rust/commit/25930e47ba0f53b6ff3bd439f6478747884a05b2"}], "stats": {"total": 87, "additions": 16, "deletions": 71}, "files": [{"sha": "a9567f20d6925ea0dd1f6a4a2fa2ed9887942304", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 70, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=3188ca7dd9896c4033b074da455867c10d7612b4", "patch": "@@ -187,7 +187,6 @@ use rustc_ast::ptr::P;\n use rustc_attr as attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_session::parse::ParseSess;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -437,14 +436,7 @@ impl<'a> TraitDef<'a> {\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it\n                         // is fine.\n-                        self.expand_enum_def(\n-                            cx,\n-                            enum_def,\n-                            &item.attrs,\n-                            item.ident,\n-                            generics,\n-                            from_scratch,\n-                        )\n+                        self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n@@ -769,7 +761,6 @@ impl<'a> TraitDef<'a> {\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         enum_def: &'a EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n@@ -801,7 +792,6 @@ impl<'a> TraitDef<'a> {\n                         cx,\n                         self,\n                         enum_def,\n-                        type_attrs,\n                         type_ident,\n                         self_args,\n                         &nonself_args[..],\n@@ -816,38 +806,6 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(sess: &ParseSess, type_attrs: &[ast::Attribute]) -> &'static str {\n-    let mut repr_type_name = \"isize\";\n-    for a in type_attrs {\n-        for r in &attr::find_repr_attrs(sess, a) {\n-            repr_type_name = match *r {\n-                attr::ReprPacked(_)\n-                | attr::ReprSimd\n-                | attr::ReprAlign(_)\n-                | attr::ReprTransparent\n-                | attr::ReprNoNiche => continue,\n-\n-                attr::ReprC => \"i32\",\n-\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::Isize)) => \"isize\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I128)) => \"i128\",\n-\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::Usize)) => \"usize\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U128)) => \"u128\",\n-            }\n-        }\n-    }\n-    repr_type_name\n-}\n-\n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(\n         &self,\n@@ -1148,20 +1106,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n-        self.build_enum_match_tuple(\n-            cx,\n-            trait_,\n-            enum_def,\n-            type_attrs,\n-            type_ident,\n-            self_args,\n-            nonself_args,\n-        )\n+        self.build_enum_match_tuple(cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n \n     /// Creates a match for a tuple of all `self_args`, where either all\n@@ -1181,11 +1130,11 @@ impl<'a> MethodDef<'a> {\n \n     /// ```{.text}\n     /// let __self0_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&self) } as i32;\n+    ///     std::intrinsics::discriminant_value(&self) };\n     /// let __self1_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg1) } as i32;\n+    ///     std::intrinsics::discriminant_value(&arg1) };\n     /// let __self2_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg2) } as i32;\n+    ///     std::intrinsics::discriminant_value(&arg2) };\n     ///\n     /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n     ///     match (...) {\n@@ -1204,7 +1153,6 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n@@ -1392,39 +1340,31 @@ impl<'a> MethodDef<'a> {\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n             // Build a series of let statements mapping each self_arg\n-            // to its discriminant value. If this is a C-style enum\n-            // with a specific repr type, then casts the values to\n-            // that type.  Otherwise casts to `i32` (the default repr\n-            // type).\n+            // to its discriminant value.\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //\n             // ```\n             // let __self0_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&self) } as i32;\n+            //     std::intrinsics::discriminant_value(&self) };\n             // let __self1_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg1) } as i32;\n+            //     std::intrinsics::discriminant_value(&arg1) };\n             // let __self2_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg2) } as i32;\n+            //     std::intrinsics::discriminant_value(&arg2) };\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n             // We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n-            let target_type_name = find_repr_type_name(&cx.parse_sess, type_attrs);\n-\n             let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n-\n-                let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name, sp));\n-                let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n                 match first_ident {"}, {"sha": "7c433574d1843cc3ebcf2b2b9c124da92844fc99", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=3188ca7dd9896c4033b074da455867c10d7612b4", "patch": "@@ -32,6 +32,7 @@\n #![feature(const_panic)]\n #![feature(const_transmute)]\n #![feature(core_intrinsics)]\n+#![feature(discriminant_kind)]\n #![feature(drain_filter)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]"}, {"sha": "1cd4af45f29569cb9ef7ec98ec1448d4065bf6b8", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3188ca7dd9896c4033b074da455867c10d7612b4/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=3188ca7dd9896c4033b074da455867c10d7612b4", "patch": "@@ -15,8 +15,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n+use std::convert::{TryFrom, TryInto};\n use std::hash::Hash;\n use std::intrinsics;\n+use std::marker::DiscriminantKind;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -60,6 +62,7 @@ where\n     E: TyEncoder,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n     T: EncodableWithShorthand,\n+    <T::Variant as DiscriminantKind>::Discriminant: Ord + TryFrom<usize>,\n {\n     let existing_shorthand = cache(encoder).get(value).cloned();\n     if let Some(shorthand) = existing_shorthand {\n@@ -75,7 +78,8 @@ where\n     // The shorthand encoding uses the same usize as the\n     // discriminant, with an offset so they can't conflict.\n     let discriminant = intrinsics::discriminant_value(variant);\n-    assert!(discriminant < SHORTHAND_OFFSET as u64);\n+    assert!(discriminant < SHORTHAND_OFFSET.try_into().ok().unwrap());\n+\n     let shorthand = start + SHORTHAND_OFFSET;\n \n     // Get the number of bits that leb128 could fit"}]}