{"sha": "790759fb11164676593f40e85e346cea551bcc4a", "node_id": "C_kwDOAAsO6NoAKDc5MDc1OWZiMTExNjQ2NzY1OTNmNDBlODVlMzQ2Y2VhNTUxYmNjNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-02T13:07:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-02T13:07:42Z"}, "message": "Auto merge of #13854 - lowr:fix/mbe-glue-punct, r=Veykril\n\nSupport multi-character punct tokens in MBE\n\nFixes #11497\n\nIn the context of MBE, consecutive puncts are parsed as multi-character punct tokens whenever possible. For example, `:::` is parsed as ``[Punct(`::`), Punct(`:`)]`` and shouldn't get matched to patterns like `: : :` or `: ::`.\n\nWe have implemented this behavior only for when we match puncts against `tt` fragments, but not when we match puncts literally. This PR extracts the multi-character punct handling procedure into a separate method and extends its support for literal matching.\n\nFor good measure, this PR adds support for `<-` token, which is still [considered as one token in rustc](https://github.com/rust-lang/rust/blob/e3961864075eaa9e855e5eec6b4f148029684539/compiler/rustc_ast/src/token.rs#L249) despite the placement syntax having been removed.", "tree": {"sha": "ee1dadbb0379b82ca910d335c0620561c63abe8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee1dadbb0379b82ca910d335c0620561c63abe8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790759fb11164676593f40e85e346cea551bcc4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790759fb11164676593f40e85e346cea551bcc4a", "html_url": "https://github.com/rust-lang/rust/commit/790759fb11164676593f40e85e346cea551bcc4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790759fb11164676593f40e85e346cea551bcc4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e986de0b288b1544349f20a445df25e6265594b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e986de0b288b1544349f20a445df25e6265594b4", "html_url": "https://github.com/rust-lang/rust/commit/e986de0b288b1544349f20a445df25e6265594b4"}, {"sha": "a7d411425c10261bd1535d0e98cbe2e7181b9553", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d411425c10261bd1535d0e98cbe2e7181b9553", "html_url": "https://github.com/rust-lang/rust/commit/a7d411425c10261bd1535d0e98cbe2e7181b9553"}], "stats": {"total": 378, "additions": 255, "deletions": 123}, "files": [{"sha": "2d5f2a692e5daab8674568717eb561a205a57012", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -1630,3 +1630,48 @@ const _: i32 = -0--1--2;\n     \"#]],\n     );\n }\n+\n+#[test]\n+fn test_punct_without_space() {\n+    // Puncts are \"glued\" greedily.\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    foo!(:::);\n+    foo!(: :::);\n+    foo!(::::);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    \"2 1\";\n+    \"1 2 1\";\n+    \"2 2\";\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "4b7500250187815e8b2a6611a40d8785a23f855f", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -141,7 +141,13 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 None => (),\n                 Some(kind) => panic!(\"Unhandled kind {kind:?}\"),\n             },\n-            Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n+            Op::Literal(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    parent.token_trees.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Repeat { tokens, kind, separator } => {\n                 let max = 10;\n                 let cnt = match kind {"}, {"sha": "88eae136f7329654857a25f94f2a72798de7e84e", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 116, "deletions": 99, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -68,7 +68,7 @@ use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n-    ExpandError, MetaTemplate,\n+    ExpandError, MetaTemplate, ValueResult,\n };\n \n impl Bindings {\n@@ -321,8 +321,8 @@ struct MatchState<'t> {\n     /// The KleeneOp of this sequence if we are in a repetition.\n     sep_kind: Option<RepeatKind>,\n \n-    /// Number of tokens of separator parsed\n-    sep_parsed: Option<usize>,\n+    /// Whether we already matched separator token.\n+    sep_matched: bool,\n \n     /// Matched meta variables bindings\n     bindings: BindingsIdx,\n@@ -387,7 +387,7 @@ fn match_loop_inner<'t>(\n             None => {\n                 // We are at or past the end of the matcher of `item`.\n                 if let Some(up) = &item.up {\n-                    if item.sep_parsed.is_none() {\n+                    if !item.sep_matched {\n                         // Get the `up` matcher\n                         let mut new_pos = (**up).clone();\n                         new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n@@ -401,22 +401,25 @@ fn match_loop_inner<'t>(\n                     }\n \n                     // Check if we need a separator.\n-                    // We check the separator one by one\n-                    let sep_idx = item.sep_parsed.unwrap_or(0);\n-                    let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n-                    if item.sep.is_some() && sep_idx != sep_len {\n+                    if item.sep.is_some() && !item.sep_matched {\n                         let sep = item.sep.as_ref().unwrap();\n-                        if src.clone().expect_separator(sep, sep_idx) {\n+                        let mut fork = src.clone();\n+                        if fork.expect_separator(sep) {\n+                            // HACK: here we use `meta_result` to pass `TtIter` back to caller because\n+                            // it might have been advanced multiple times. `ValueResult` is\n+                            // insignificant.\n+                            item.meta_result = Some((fork, ValueResult::ok(None)));\n                             item.dot.next();\n-                            item.sep_parsed = Some(sep_idx + 1);\n+                            // item.sep_parsed = Some(sep_len);\n+                            item.sep_matched = true;\n                             try_push!(next_items, item);\n                         }\n                     }\n                     // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n                     // and try to match again UNLESS we are only allowed to have _one_ repetition.\n                     else if item.sep_kind != Some(RepeatKind::ZeroOrOne) {\n                         item.dot = item.dot.reset();\n-                        item.sep_parsed = None;\n+                        item.sep_matched = false;\n                         bindings_builder.push_default(&mut item.bindings);\n                         cur_items.push(item);\n                     }\n@@ -451,7 +454,7 @@ fn match_loop_inner<'t>(\n                     up: Some(Box::new(item)),\n                     sep: separator.clone(),\n                     sep_kind: Some(*kind),\n-                    sep_parsed: None,\n+                    sep_matched: false,\n                     bindings: bindings_builder.alloc(),\n                     meta_result: None,\n                     is_error: false,\n@@ -500,18 +503,69 @@ fn match_loop_inner<'t>(\n                     }\n                 }\n             }\n-            OpDelimited::Op(Op::Leaf(leaf)) => {\n-                if let Err(err) = match_leaf(leaf, &mut src.clone()) {\n-                    res.add_err(err);\n+            OpDelimited::Op(Op::Literal(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Literal(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n+                } else {\n+                    res.add_err(ExpandError::binding_error(format!(\"expected literal: `{lhs}`\")));\n                     item.is_error = true;\n+                }\n+                try_push!(next_items, item);\n+            }\n+            OpDelimited::Op(Op::Ident(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Ident(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n                 } else {\n-                    item.dot.next();\n+                    res.add_err(ExpandError::binding_error(format!(\"expected ident: `{lhs}`\")));\n+                    item.is_error = true;\n                 }\n                 try_push!(next_items, item);\n             }\n+            OpDelimited::Op(Op::Punct(lhs)) => {\n+                let mut fork = src.clone();\n+                let error = if let Ok(rhs) = fork.expect_glued_punct() {\n+                    let first_is_single_quote = rhs[0].char == '\\'';\n+                    let lhs = lhs.iter().map(|it| it.char);\n+                    let rhs = rhs.iter().map(|it| it.char);\n+                    if lhs.clone().eq(rhs) {\n+                        // HACK: here we use `meta_result` to pass `TtIter` back to caller because\n+                        // it might have been advanced multiple times. `ValueResult` is\n+                        // insignificant.\n+                        item.meta_result = Some((fork, ValueResult::ok(None)));\n+                        item.dot.next();\n+                        next_items.push(item);\n+                        continue;\n+                    }\n+\n+                    if first_is_single_quote {\n+                        // If the first punct token is a single quote, that's a part of a lifetime\n+                        // ident, not a punct.\n+                        ExpandError::UnexpectedToken\n+                    } else {\n+                        let lhs: SmolStr = lhs.collect();\n+                        ExpandError::binding_error(format!(\"expected punct: `{lhs}`\"))\n+                    }\n+                } else {\n+                    ExpandError::UnexpectedToken\n+                };\n+\n+                res.add_err(error);\n+                item.is_error = true;\n+                error_items.push(item);\n+            }\n             OpDelimited::Op(Op::Ignore { .. } | Op::Index { .. }) => {}\n             OpDelimited::Open => {\n-                if matches!(src.clone().next(), Some(tt::TokenTree::Subtree(..))) {\n+                if matches!(src.peek_n(0), Some(tt::TokenTree::Subtree(..))) {\n                     item.dot.next();\n                     try_push!(next_items, item);\n                 }\n@@ -541,7 +595,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         up: None,\n         sep: None,\n         sep_kind: None,\n-        sep_parsed: None,\n+        sep_matched: false,\n         bindings: bindings_builder.alloc(),\n         is_error: false,\n         meta_result: None,\n@@ -616,21 +670,33 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n-            // Now process the next token\n-            cur_items.extend(next_items.drain(..));\n-\n-            match src.next() {\n-                Some(tt::TokenTree::Subtree(subtree)) => {\n-                    stack.push(src.clone());\n-                    src = TtIter::new(subtree);\n+            if let Some((iter, _)) = next_items[0].meta_result.take() {\n+                // We've matched a possibly \"glued\" punct. The matched punct (hence\n+                // `meta_result` also) must be the same for all items.\n+                // FIXME: If there are multiple items, it's definitely redundant (and it's hacky!\n+                // `meta_result` isn't supposed to be used this way).\n+\n+                // We already bumped, so no need to call `.next()` like in the other branch.\n+                src = iter;\n+                for item in next_items.iter_mut() {\n+                    item.meta_result = None;\n                 }\n-                None => {\n-                    if let Some(iter) = stack.pop() {\n-                        src = iter;\n+            } else {\n+                match src.next() {\n+                    Some(tt::TokenTree::Subtree(subtree)) => {\n+                        stack.push(src.clone());\n+                        src = TtIter::new(subtree);\n                     }\n+                    None => {\n+                        if let Some(iter) = stack.pop() {\n+                            src = iter;\n+                        }\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n+            // Now process the next token\n+            cur_items.extend(next_items.drain(..));\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -663,27 +729,6 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     }\n }\n \n-fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n-    let rhs = src\n-        .expect_leaf()\n-        .map_err(|()| ExpandError::binding_error(format!(\"expected leaf: `{lhs}`\")))?;\n-    match (lhs, rhs) {\n-        (\n-            tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n-            tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n-            tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n-            tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        _ => Err(ExpandError::UnexpectedToken),\n-    }\n-}\n-\n fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n@@ -756,10 +801,10 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n     for op in pattern.iter() {\n         match op {\n             Op::Var { name, .. } => collector_fun(name.clone()),\n-            Op::Leaf(_) => (),\n             Op::Subtree { tokens, .. } => collect_vars(collector_fun, tokens),\n             Op::Repeat { tokens, .. } => collect_vars(collector_fun, tokens),\n-            Op::Ignore { .. } | Op::Index { .. } => {}\n+            Op::Ignore { .. } | Op::Index { .. } | Op::Literal(_) | Op::Ident(_) | Op::Punct(_) => {\n+            }\n         }\n     }\n }\n@@ -822,26 +867,29 @@ impl<'a> Iterator for OpDelimitedIter<'a> {\n }\n \n impl<'a> TtIter<'a> {\n-    fn expect_separator(&mut self, separator: &Separator, idx: usize) -> bool {\n+    fn expect_separator(&mut self, separator: &Separator) -> bool {\n         let mut fork = self.clone();\n         let ok = match separator {\n-            Separator::Ident(lhs) if idx == 0 => match fork.expect_ident_or_underscore() {\n+            Separator::Ident(lhs) => match fork.expect_ident_or_underscore() {\n                 Ok(rhs) => rhs.text == lhs.text,\n                 Err(_) => false,\n             },\n-            Separator::Literal(lhs) if idx == 0 => match fork.expect_literal() {\n+            Separator::Literal(lhs) => match fork.expect_literal() {\n                 Ok(rhs) => match rhs {\n                     tt::Leaf::Literal(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Ident(rhs) => rhs.text == lhs.text,\n                     tt::Leaf::Punct(_) => false,\n                 },\n                 Err(_) => false,\n             },\n-            Separator::Puncts(lhss) if idx < lhss.len() => match fork.expect_punct() {\n-                Ok(rhs) => rhs.char == lhss[idx].char,\n+            Separator::Puncts(lhs) => match fork.expect_glued_punct() {\n+                Ok(rhs) => {\n+                    let lhs = lhs.iter().map(|it| it.char);\n+                    let rhs = rhs.iter().map(|it| it.char);\n+                    lhs.eq(rhs)\n+                }\n                 Err(_) => false,\n             },\n-            _ => false,\n         };\n         if ok {\n             *self = fork;\n@@ -850,52 +898,21 @@ impl<'a> TtIter<'a> {\n     }\n \n     fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n-        match self.peek_n(0) {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n-                return self.expect_lifetime();\n-            }\n-            _ => (),\n-        }\n-\n-        let tt = self.next().ok_or(())?.clone();\n-        let punct = match tt {\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.spacing == tt::Spacing::Joint => {\n-                punct\n-            }\n-            _ => return Ok(tt),\n-        };\n-\n-        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n-            (\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n-            ) if p2.spacing == tt::Spacing::Joint => (p2.char, Some(p3.char)),\n-            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2.char, None),\n-            _ => return Ok(tt),\n-        };\n-\n-        match (punct.char, second, third) {\n-            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n-                let tt2 = self.next().unwrap().clone();\n-                let tt3 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2, tt3] }.into())\n-            }\n-            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n-            | ('-' | '=' | '>', '>', _)\n-            | (':', ':', _)\n-            | ('.', '.', _)\n-            | ('&', '&', _)\n-            | ('<', '<', _)\n-            | ('|', '|', _) => {\n-                let tt2 = self.next().unwrap().clone();\n-                Ok(tt::Subtree { delimiter: None, token_trees: vec![tt, tt2] }.into())\n+        if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = self.peek_n(0) {\n+            if punct.char == '\\'' {\n+                self.expect_lifetime()\n+            } else {\n+                let puncts = self.expect_glued_punct()?;\n+                let token_trees = puncts.into_iter().map(|p| tt::Leaf::Punct(p).into()).collect();\n+                Ok(tt::TokenTree::Subtree(tt::Subtree { delimiter: None, token_trees }))\n             }\n-            _ => Ok(tt),\n+        } else {\n+            self.next().ok_or(()).cloned()\n         }\n     }\n \n     fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n-        let punct = self.expect_punct()?;\n+        let punct = self.expect_single_punct()?;\n         if punct.char != '\\'' {\n             return Err(());\n         }"}, {"sha": "db0d327bf409b2752b641ec653a1e6a13075de23", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -134,7 +134,13 @@ fn expand_subtree(\n     let mut err = None;\n     for op in template.iter() {\n         match op {\n-            Op::Leaf(tt) => arena.push(tt.clone().into()),\n+            Op::Literal(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    arena.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Subtree { tokens, delimiter } => {\n                 let ExpandResult { value: tt, err: e } =\n                     expand_subtree(ctx, tokens, *delimiter, arena);"}, {"sha": "3d9a61dbc866e5235b40d3d3ea4f81522ee54776", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -1,7 +1,7 @@\n //! Parser recognizes special macro syntax, `$var` and `$(repeat)*`, in token\n //! trees.\n \n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{tt_iter::TtIter, ParseError};\n@@ -39,7 +39,7 @@ impl MetaTemplate {\n         let mut src = TtIter::new(tt);\n \n         let mut res = Vec::new();\n-        while let Some(first) = src.next() {\n+        while let Some(first) = src.peek_n(0) {\n             let op = next_op(first, &mut src, mode)?;\n             res.push(op);\n         }\n@@ -54,8 +54,10 @@ pub(crate) enum Op {\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n-    Leaf(tt::Leaf),\n     Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n+    Literal(tt::Literal),\n+    Punct(SmallVec<[tt::Punct; 3]>),\n+    Ident(tt::Ident),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -108,28 +110,23 @@ impl PartialEq for Separator {\n     }\n }\n \n-impl Separator {\n-    pub(crate) fn tt_count(&self) -> usize {\n-        match self {\n-            Separator::Literal(_) => 1,\n-            Separator::Ident(_) => 1,\n-            Separator::Puncts(it) => it.len(),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy)]\n enum Mode {\n     Pattern,\n     Template,\n }\n \n-fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n-    let res = match first {\n-        tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+fn next_op<'a>(\n+    first_peeked: &tt::TokenTree,\n+    src: &mut TtIter<'a>,\n+    mode: Mode,\n+) -> Result<Op, ParseError> {\n+    let res = match first_peeked {\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(p @ tt::Punct { char: '$', .. })) => {\n+            src.next().expect(\"first token already peeked\");\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::Leaf(leaf.clone())),\n+                None => return Ok(Op::Punct(smallvec![p.clone()])),\n                 Some(it) => it,\n             };\n             match second {\n@@ -160,7 +157,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-                        Op::Leaf(tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: ident.id }))\n+                        Op::Ident(tt::Ident { text: \"$crate\".into(), id: ident.id })\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n@@ -180,16 +177,33 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                                 \"`$$` is not allowed on the pattern side\",\n                             ))\n                         }\n-                        Mode::Template => Op::Leaf(tt::Leaf::Punct(*punct)),\n+                        Mode::Template => Op::Punct(smallvec![*punct]),\n                     },\n                     tt::Leaf::Punct(_) | tt::Leaf::Literal(_) => {\n                         return Err(ParseError::expected(\"expected ident\"))\n                     }\n                 },\n             }\n         }\n-        tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Literal(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Literal(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Ident(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Ident(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => {\n+            // There's at least one punct so this shouldn't fail.\n+            let puncts = src.expect_glued_punct().unwrap();\n+            Op::Punct(puncts)\n+        }\n+\n         tt::TokenTree::Subtree(subtree) => {\n+            src.next().expect(\"first token already peeked\");\n             let tokens = MetaTemplate::parse(subtree, mode)?;\n             Op::Subtree { tokens, delimiter: subtree.delimiter }\n         }"}, {"sha": "bee7b5de6ac31c6908e7ebed878492d987357aab", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790759fb11164676593f40e85e346cea551bcc4a/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=790759fb11164676593f40e85e346cea551bcc4a", "patch": "@@ -1,6 +1,7 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n+use smallvec::{smallvec, SmallVec};\n use syntax::SyntaxKind;\n use tt::buffer::TokenBuffer;\n \n@@ -80,13 +81,56 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n+    pub(crate) fn expect_single_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n         match self.expect_leaf()? {\n             tt::Leaf::Punct(it) => Ok(it),\n             _ => Err(()),\n         }\n     }\n \n+    /// Returns consecutive `Punct`s that can be glued together.\n+    ///\n+    /// This method currently may return a single quotation, which is part of lifetime ident and\n+    /// conceptually not a punct in the context of mbe. Callers should handle this.\n+    pub(crate) fn expect_glued_punct(&mut self) -> Result<SmallVec<[tt::Punct; 3]>, ()> {\n+        let tt::TokenTree::Leaf(tt::Leaf::Punct(first)) = self.next().ok_or(())?.clone() else {\n+            return Err(());\n+        };\n+\n+        if first.spacing == tt::Spacing::Alone {\n+            return Ok(smallvec![first]);\n+        }\n+\n+        let (second, third) = match (self.peek_n(0), self.peek_n(1)) {\n+            (\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))),\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p3))),\n+            ) if p2.spacing == tt::Spacing::Joint => (p2, Some(p3)),\n+            (Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p2))), _) => (p2, None),\n+            _ => return Ok(smallvec![first]),\n+        };\n+\n+        match (first.char, second.char, third.map(|it| it.char)) {\n+            ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n+                let _ = self.next().unwrap();\n+                let _ = self.next().unwrap();\n+                Ok(smallvec![first, second.clone(), third.unwrap().clone()])\n+            }\n+            ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n+            | ('-' | '=' | '>', '>', _)\n+            | ('<', '-', _)\n+            | (':', ':', _)\n+            | ('.', '.', _)\n+            | ('&', '&', _)\n+            | ('<', '<', _)\n+            | ('|', '|', _) => {\n+                let _ = self.next().unwrap();\n+                Ok(smallvec![first, second.clone()])\n+            }\n+            _ => Ok(smallvec![first]),\n+        }\n+    }\n+\n     pub(crate) fn expect_fragment(\n         &mut self,\n         entry_point: parser::PrefixEntryPoint,\n@@ -141,7 +185,7 @@ impl<'a> TtIter<'a> {\n         ExpandResult { value: res, err }\n     }\n \n-    pub(crate) fn peek_n(&self, n: usize) -> Option<&tt::TokenTree> {\n+    pub(crate) fn peek_n(&self, n: usize) -> Option<&'a tt::TokenTree> {\n         self.inner.as_slice().get(n)\n     }\n }"}]}