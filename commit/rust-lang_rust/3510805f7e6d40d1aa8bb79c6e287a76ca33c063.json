{"sha": "3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MTA4MDVmN2U2ZDQwZDFhYThiYjc5YzZlMjg3YTc2Y2EzM2MwNjM=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-31T21:07:54Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-13T11:28:43Z"}, "message": "Provide program clauses for builtin types", "tree": {"sha": "544a5fee441c2b2995d16d3412bbe6f94858614c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544a5fee441c2b2995d16d3412bbe6f94858614c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "html_url": "https://github.com/rust-lang/rust/commit/3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ba84fa79959b3e4b1143861c0ae5d256f8a049", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ba84fa79959b3e4b1143861c0ae5d256f8a049", "html_url": "https://github.com/rust-lang/rust/commit/79ba84fa79959b3e4b1143861c0ae5d256f8a049"}], "stats": {"total": 741, "additions": 512, "deletions": 229}, "files": [{"sha": "0c08e35c18df33d53a1ea3b6a82480ca1da76423", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -2419,6 +2419,7 @@ dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_target 0.0.0\",\n  \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "f057cbb50334eb07fbc804f4b05cbea288b0fc00", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -14,6 +14,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n chalk-engine = { version = \"0.8.0\", default-features=false }"}, {"sha": "611cace45df8d4b0a25c90d4b5b1c6a89dc17b3c", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "renamed", "additions": 3, "deletions": 226, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -8,30 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod program_clauses;\n+\n use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n use rustc::infer::canonical::{\n     Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n-    WellFormed,\n-    FromEnv,\n     DomainGoal,\n     ExClauseFold,\n     ExClauseLift,\n     Goal,\n     GoalKind,\n     Clause,\n-    ProgramClauseCategory,\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n-use rustc::hir::def_id::DefId;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -335,228 +333,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n-        use rustc::traits::WhereClause::*;\n-\n-        fn assemble_clauses_from_impls<'tcx>(\n-            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-            trait_def_id: DefId,\n-            clauses: &mut Vec<Clause<'tcx>>\n-        ) {\n-            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-                clauses.extend(\n-                    tcx.program_clauses_for(impl_def_id)\n-                        .into_iter()\n-                        .cloned()\n-                );\n-            });\n-        }\n-\n-        fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-            trait_def_id: DefId,\n-            clauses: &mut Vec<Clause<'tcx>>\n-        ) {\n-            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-                for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n-                    clauses.extend(\n-                        tcx.program_clauses_for(*def_id)\n-                            .into_iter()\n-                            .cloned()\n-                    );\n-                }\n-            });\n-        }\n-\n-        let mut clauses = match goal {\n-            DomainGoal::Holds(Implemented(trait_predicate)) => {\n-                // These come from:\n-                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n-                // * the trait decl (rule `Implemented-From-Env`)\n-\n-                let mut clauses = vec![];\n-                assemble_clauses_from_impls(\n-                    self.infcx.tcx,\n-                    trait_predicate.def_id(),\n-                    &mut clauses\n-                );\n-\n-                // FIXME: we need to add special rules for builtin impls:\n-                // * `Copy` / `Clone`\n-                // * `Sized`\n-                // * `Unsize`\n-                // * `Generator`\n-                // * `FnOnce` / `FnMut` / `Fn`\n-                // * trait objects\n-                // * auto traits\n-\n-                // Rule `Implemented-From-Env` will be computed from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n-                // These come from:\n-                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n-                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                let clauses = self.infcx.tcx.program_clauses_for(\n-                    projection_predicate.projection_ty.item_def_id\n-                ).into_iter()\n-\n-                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n-\n-                    .cloned()\n-                    .collect::<Vec<_>>();\n-\n-                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n-                // from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(RegionOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::Holds(TypeOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n-                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n-                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n-                    .into_iter()\n-\n-                    // only select `WellFormed-TraitRef`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n-                // These come from:\n-                // * the associated type definition if `ty` refers to an unnormalized\n-                //   associated type (rule `WellFormed-AssocTy`)\n-                // * custom rules for built-in types\n-                // * the type definition otherwise (rule `WellFormed-Type`)\n-                let clauses = match ty.sty {\n-                    ty::Projection(data) => {\n-                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n-                    }\n-\n-                    // These types are always WF (recall that we do not check\n-                    // for parameters to be WF)\n-                    ty::Bool |\n-                    ty::Char |\n-                    ty::Int(..) |\n-                    ty::Uint(..) |\n-                    ty::Float(..) |\n-                    ty::Str |\n-                    ty::RawPtr(..) |\n-                    ty::FnPtr(..) |\n-                    ty::Param(..) |\n-                    ty::Never => {\n-                        ty::List::empty()\n-                    }\n-\n-                    // WF if inner type is `Sized`\n-                    ty::Slice(..) |\n-                    ty::Array(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Tuple(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    // WF if `sub_ty` outlives `region`\n-                    ty::Ref(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Dynamic(..) => {\n-                        // FIXME: no rules yet for trait objects\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Adt(def, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def.did)\n-                    }\n-\n-                    ty::Foreign(def_id) |\n-                    ty::FnDef(def_id, ..) |\n-                    ty::Closure(def_id, ..) |\n-                    ty::Generator(def_id, ..) |\n-                    ty::Opaque(def_id, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def_id)\n-                    }\n-\n-                    ty::GeneratorWitness(..) |\n-                    ty::UnnormalizedProjection(..) |\n-                    ty::Infer(..) |\n-                    ty::Bound(..) |\n-                    ty::Error => {\n-                        bug!(\"unexpected type {:?}\", ty)\n-                    }\n-                };\n-\n-                clauses.into_iter()\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n-                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n-                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n-                // comes from the environment).\n-                vec![]\n-            }\n-\n-            DomainGoal::Normalize(projection_predicate) => {\n-                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_assoc_ty_values(\n-                    self.infcx.tcx,\n-                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n-                    &mut clauses\n-                );\n-\n-                clauses\n-            }\n-        };\n-\n-        let environment = self.infcx.tcx.lift_to_global(environment)\n-            .expect(\"environment is not global\");\n-        clauses.extend(\n-            self.infcx.tcx.program_clauses_for_env(environment)\n-                .into_iter()\n-                .cloned()\n-        );\n-        clauses\n+        self.program_clauses_impl(environment, goal)\n     }\n \n     fn instantiate_binders_universally(", "previous_filename": "src/librustc_traits/chalk_context.rs"}, {"sha": "20d23a5bd2857a86e962059ba53fa9a9c6a32184", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -0,0 +1,476 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{\n+    WellFormed,\n+    FromEnv,\n+    DomainGoal,\n+    GoalKind,\n+    Clause,\n+    Clauses,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+    Environment,\n+};\n+use rustc::ty;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc_target::spec::abi;\n+use super::ChalkInferenceContext;\n+use crate::lowering::Lower;\n+use std::iter;\n+\n+fn assemble_clauses_from_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        clauses.extend(\n+            tcx.program_clauses_for(impl_def_id)\n+                .into_iter()\n+                .cloned()\n+        );\n+    });\n+}\n+\n+fn assemble_clauses_from_assoc_ty_values<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n+            clauses.extend(\n+                tcx.program_clauses_for(*def_id)\n+                    .into_iter()\n+                    .cloned()\n+            );\n+        }\n+    });\n+}\n+\n+fn program_clauses_for_raw_ptr<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n+        ty,\n+        mutbl: hir::Mutability::MutImmutable,\n+    });\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed(*const T). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_fn_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity_and_output: usize,\n+    variadic: bool,\n+    unsafety: hir::Unsafety,\n+    abi: abi::Abi\n+) -> Clauses<'tcx> {\n+    let inputs_and_output = tcx.mk_type_list(\n+        (0..arity_and_output).into_iter()\n+            // DebruijnIndex(1) because we are going to inject these in a `PolyFnSig`\n+            .map(|i| ty::BoundTy::new(ty::DebruijnIndex::from(1usize), ty::BoundVar::from(i)))\n+            .map(|t| tcx.mk_ty(ty::Bound(t)))\n+    );\n+\n+    let fn_sig = ty::Binder::bind(ty::FnSig {\n+        inputs_and_output,\n+        variadic,\n+        unsafety,\n+        abi,\n+    });\n+    let fn_ptr = tcx.mk_fn_ptr(fn_sig);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `n + 1` == `arity_and_output`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let slice_ty = tcx.mk_slice(ty);\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_array<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    length: &'tcx ty::Const<'tcx>\n+) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_tuple<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity: usize\n+) -> Clauses<'tcx> {\n+    let type_list = tcx.mk_type_list(\n+        (0..arity).into_iter()\n+            .map(|i| ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from(i)))\n+            .map(|t| tcx.mk_ty(ty::Bound(t)))\n+    );\n+    \n+    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = type_list[0..arity - 1].iter()\n+        .map(|ty| ty::TraitRef {\n+            def_id: sized_trait,\n+            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n+        })\n+        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+        .map(|predicate| predicate.lower());\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n+        hypotheses: tcx.mk_goals(\n+            sized_implemented.map(|domain_goal| {\n+                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n+            })\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // ```\n+    // forall<T1, ..., Tn-1, Tn> {\n+    //     WellFormed((T1, ..., Tn)) :-\n+    //         Implemented(T1: Sized),\n+    //         ...\n+    //         Implemented(Tn-1: Sized).\n+    // }\n+    // ```\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_ref<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let region = tcx.mk_region(\n+        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+    );\n+    let ty = tcx.mk_ty(\n+        ty::Bound(ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(1)))\n+    );\n+\n+    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty,\n+        mutbl: hir::Mutability::MutImmutable,\n+    });\n+\n+    let outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(outlives.into_goal()))\n+        ),\n+        category: ProgramClauseCategory::ImpliedBound,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+    pub(super) fn program_clauses_impl(\n+        &self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+    ) -> Vec<Clause<'tcx>> {\n+        use rustc::traits::WhereClause::*;\n+\n+        let mut clauses = match goal {\n+            DomainGoal::Holds(Implemented(trait_predicate)) => {\n+                // These come from:\n+                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n+                // * the trait decl (rule `Implemented-From-Env`)\n+\n+                let mut clauses = vec![];\n+                assemble_clauses_from_impls(\n+                    self.infcx.tcx,\n+                    trait_predicate.def_id(),\n+                    &mut clauses\n+                );\n+\n+                // FIXME: we need to add special rules for builtin impls:\n+                // * `Copy` / `Clone`\n+                // * `Sized`\n+                // * `Unsize`\n+                // * `Generator`\n+                // * `FnOnce` / `FnMut` / `Fn`\n+                // * trait objects\n+                // * auto traits\n+\n+                // Rule `Implemented-From-Env` will be computed from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n+                // These come from:\n+                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n+                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                let clauses = self.infcx.tcx.program_clauses_for(\n+                    projection_predicate.projection_ty.item_def_id\n+                ).into_iter()\n+\n+                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n+\n+                    .cloned()\n+                    .collect::<Vec<_>>();\n+\n+                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n+                // from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(RegionOutlives(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::Holds(TypeOutlives(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n+                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n+                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n+                    .into_iter()\n+\n+                    // only select `WellFormed-TraitRef`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n+                // These come from:\n+                // * the associated type definition if `ty` refers to an unnormalized\n+                //   associated type (rule `WellFormed-AssocTy`)\n+                // * custom rules for built-in types\n+                // * the type definition otherwise (rule `WellFormed-Type`)\n+                let clauses = match ty.sty {\n+                    ty::Projection(data) => {\n+                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n+                    }\n+\n+                    // These types are always WF and non-parametric.\n+                    ty::Bool |\n+                    ty::Char |\n+                    ty::Int(..) |\n+                    ty::Uint(..) |\n+                    ty::Float(..) |\n+                    ty::Str |\n+                    ty::Never => {\n+                        let wf_clause = ProgramClause {\n+                            goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+                            hypotheses: ty::List::empty(),\n+                            category: ProgramClauseCategory::WellFormed,\n+                        };\n+                        let wf_clause = Clause::ForAll(ty::Binder::dummy(wf_clause));\n+\n+                        self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n+                    }\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::RawPtr(..) => program_clauses_for_raw_ptr(self.infcx.tcx),\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::FnPtr(fn_ptr) => {\n+                        let fn_ptr = fn_ptr.skip_binder();\n+                        program_clauses_for_fn_ptr(\n+                            self.infcx.tcx,\n+                            fn_ptr.inputs_and_output.len(),\n+                            fn_ptr.variadic,\n+                            fn_ptr.unsafety,\n+                            fn_ptr.abi\n+                        )\n+                    }\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Slice(..) => program_clauses_for_slice(self.infcx.tcx),\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Array(_, length) => program_clauses_for_array(self.infcx.tcx, length),\n+\n+                    // WF if all types but the last one are `Sized`.\n+                    ty::Tuple(types) => program_clauses_for_tuple(\n+                        self.infcx.tcx,\n+                        types.len()\n+                    ),\n+\n+                    // WF if `sub_ty` outlives `region`.\n+                    ty::Ref(..) => program_clauses_for_ref(self.infcx.tcx),\n+\n+                    ty::Dynamic(..) => {\n+                        // FIXME: no rules yet for trait objects\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Adt(def, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def.did)\n+                    }\n+\n+                    ty::Foreign(def_id) |\n+                    ty::FnDef(def_id, ..) |\n+                    ty::Closure(def_id, ..) |\n+                    ty::Generator(def_id, ..) |\n+                    ty::Opaque(def_id, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def_id)\n+                    }\n+\n+                    ty::GeneratorWitness(..) |\n+                    ty::UnnormalizedProjection(..) |\n+                    ty::Infer(..) |\n+                    ty::Bound(..) |\n+                    ty::Param(..) |\n+                    ty::Error => {\n+                        bug!(\"unexpected type {:?}\", ty)\n+                    }\n+                };\n+\n+                clauses.into_iter()\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n+                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n+                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n+                // comes from the environment).\n+                vec![]\n+            }\n+\n+            DomainGoal::Normalize(projection_predicate) => {\n+                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n+                let mut clauses = vec![];\n+\n+                assemble_clauses_from_assoc_ty_values(\n+                    self.infcx.tcx,\n+                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n+                    &mut clauses\n+                );\n+\n+                clauses\n+            }\n+        };\n+\n+        let environment = self.infcx.tcx.lift_to_global(environment)\n+            .expect(\"environment is not global\");\n+        clauses.extend(\n+            self.infcx.tcx.program_clauses_for_env(environment)\n+                .into_iter()\n+                .cloned()\n+        );\n+        clauses\n+    }\n+}"}, {"sha": "4a3806d6cb68074a23998da7cb9bf26025a08a4f", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -23,6 +23,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_target;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate smallvec;"}, {"sha": "54f0c6e8da78a5e984bc8e986bc48ae6dd71f960", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -20,6 +20,8 @@ use rustc::traits::{\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n+use super::Lower;\n+use std::iter;\n \n struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -45,9 +47,32 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n                 );\n             }\n \n-            // forall<'a, T> { `Outlives(T, 'a) :- FromEnv(&'a T)` }\n-            ty::Ref(_region, _sub_ty, ..) => {\n-                // FIXME: we'd need bound tys in order to properly write the above rule\n+            // forall<'a, T> { `Outlives(T: 'a) :- FromEnv(&'a T)` }\n+            ty::Ref(..) => {\n+                use rustc::hir;\n+\n+                let region = self.tcx.mk_region(\n+                    ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+                );\n+                let ty = self.tcx.mk_ty(\n+                    ty::Bound(ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(1)))\n+                );\n+\n+                let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                    ty,\n+                    mutbl: hir::Mutability::MutImmutable,\n+                });\n+                let from_env = DomainGoal::FromEnv(FromEnv::Ty(ref_ty));\n+\n+                let clause = ProgramClause {\n+                    goal: ty::OutlivesPredicate(ty, region).lower(),\n+                    hypotheses: self.tcx.mk_goals(\n+                        iter::once(self.tcx.mk_goal(from_env.into_goal()))\n+                    ),\n+                    category: ProgramClauseCategory::ImpliedBound,\n+                };\n+                let clause = Clause::ForAll(ty::Binder::bind(clause));\n+                self.round.insert(clause);\n             }\n \n             ty::Dynamic(..) => {"}, {"sha": "7c59b9046f5495f7bda27f3024a4ac70bda71883", "filename": "src/test/ui/chalkify/lower_env3.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3510805f7e6d40d1aa8bb79c6e287a76ca33c063/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr?ref=3510805f7e6d40d1aa8bb79c6e287a76ca33c063", "patch": "@@ -4,6 +4,7 @@ error: program clause dump\n LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: forall<?'0, ?1> { TypeOutlives(?1 : ) :- FromEnv(&?1). }\n    = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n \n error: program clause dump\n@@ -12,6 +13,7 @@ error: program clause dump\n LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: forall<?'0, ?1> { TypeOutlives(?1 : ) :- FromEnv(&?1). }\n    = note: forall<Self> { FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone). }\n    = note: forall<Self> { Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone). }\n    = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }"}]}