{"sha": "f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YzE0YWM3MjA0YzM4NjMzZTcwYjNlZmQ0N2E1YjFmOTA1NmFmZDA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-07T17:52:37Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-09T22:42:20Z"}, "message": "Move most of the logic into the completion module", "tree": {"sha": "60d375f39f4737630e9a8166975c71f3ec5f2f9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d375f39f4737630e9a8166975c71f3ec5f2f9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "html_url": "https://github.com/rust-lang/rust/commit/f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ba479cd058aa54a9f161085c7ff9ac1f12d8df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba479cd058aa54a9f161085c7ff9ac1f12d8df3", "html_url": "https://github.com/rust-lang/rust/commit/6ba479cd058aa54a9f161085c7ff9ac1f12d8df3"}], "stats": {"total": 225, "additions": 107, "deletions": 118}, "files": [{"sha": "9a61f1d5660877d40c6215a4fda547f7b59c0be7", "filename": "crates/base_db/src/input.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -12,7 +12,7 @@ use cfg::CfgOptions;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::SmolStr;\n use tt::TokenExpander;\n-use vfs::file_set::FileSet;\n+use vfs::{file_set::FileSet, VfsPath};\n \n pub use vfs::FileId;\n \n@@ -43,6 +43,12 @@ impl SourceRoot {\n     pub fn new_library(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: true, file_set }\n     }\n+    pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n+        self.file_set.path_for_file(file)\n+    }\n+    pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n+        self.file_set.file_for_path(path)\n+    }\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.file_set.iter()\n     }"}, {"sha": "ee3415850654d4b2739985290e0b9f4da2d89922", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -96,7 +96,6 @@ pub trait FileLoader {\n     /// `#[path = \"C://no/way\"]`\n     fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId>;\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String>;\n }\n \n /// Database which stores all significant input facts: source code and project\n@@ -156,92 +155,13 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n     fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n         // FIXME: this *somehow* should be platform agnostic...\n-        // self.source_root(anchor)\n-        let source_root = self.source_root(anchor);\n+        let source_root = self.0.file_source_root(anchor);\n+        let source_root = self.0.source_root(source_root);\n         source_root.file_set.resolve_path(anchor, path)\n     }\n \n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)\n     }\n-\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        possible_sudmobule_names(&self.source_root(module_file).file_set, module_file)\n-    }\n-}\n-\n-impl<T: SourceDatabaseExt> FileLoaderDelegate<&'_ T> {\n-    fn source_root(&self, anchor: FileId) -> Arc<SourceRoot> {\n-        let source_root = self.0.file_source_root(anchor);\n-        self.0.source_root(source_root)\n-    }\n-}\n-\n-fn possible_sudmobule_names(module_files: &FileSet, module_file: FileId) -> Vec<String> {\n-    let directory_to_look_for_submodules = match module_files\n-        .path_for_file(&module_file)\n-        .and_then(|module_file_path| get_directory_with_submodules(module_file_path))\n-    {\n-        Some(directory) => directory,\n-        None => return Vec::new(),\n-    };\n-    module_files\n-        .iter()\n-        .filter(|submodule_file| submodule_file != &module_file)\n-        .filter_map(|submodule_file| {\n-            let submodule_path = module_files.path_for_file(&submodule_file)?;\n-            if submodule_path.parent()? == directory_to_look_for_submodules {\n-                submodule_path.file_name_and_extension()\n-            } else {\n-                None\n-            }\n-        })\n-        .filter_map(|file_name_and_extension| {\n-            match file_name_and_extension {\n-                // TODO kb wrong resolution for nested non-file modules (mod tests { mod <|> })\n-                // TODO kb in src/bin when a module is included into another,\n-                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n-                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n-                (subdirectory_name, None) => {\n-                    let mod_rs_path =\n-                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n-                    if module_files.file_for_path(&mod_rs_path).is_some() {\n-                        Some(subdirectory_name.to_owned())\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn get_directory_with_submodules(module_file_path: &VfsPath) -> Option<VfsPath> {\n-    let module_directory_path = module_file_path.parent()?;\n-    match module_file_path.file_name_and_extension()? {\n-        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n-            Some(module_directory_path)\n-        }\n-        (regular_rust_file_name, Some(\"rs\")) => {\n-            if matches!(\n-                (\n-                    module_directory_path\n-                        .parent()\n-                        .as_ref()\n-                        .and_then(|path| path.file_name_and_extension()),\n-                    module_directory_path.file_name_and_extension(),\n-                ),\n-                (Some((\"src\", None)), Some((\"bin\", None)))\n-            ) {\n-                // files in /src/bin/ can import each other directly\n-                Some(module_directory_path)\n-            } else {\n-                module_directory_path.join(regular_rust_file_name)\n-            }\n-        }\n-        _ => None,\n-    }\n }"}, {"sha": "42a762936dd461e32fd4b26957f208ddb95b3117", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -63,9 +63,6 @@ impl FileLoader for TestDB {\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        FileLoaderDelegate(self).possible_sudmobule_names(module_file)\n-    }\n }\n \n impl TestDB {"}, {"sha": "86a5d867e6808f5d1090e3c068d8e4bcbc4e277a", "filename": "crates/hir_expand/src/test_db.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -46,7 +46,4 @@ impl FileLoader for TestDB {\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        FileLoaderDelegate(self).possible_sudmobule_names(module_file)\n-    }\n }"}, {"sha": "15b8435e9213427e492212e7c753b94da8808027", "filename": "crates/hir_ty/src/test_db.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -73,9 +73,6 @@ impl FileLoader for TestDB {\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        FileLoaderDelegate(self).possible_sudmobule_names(module_file)\n-    }\n }\n \n impl TestDB {"}, {"sha": "da3d93bada8fba954a16c485a0150674d080e4e0", "filename": "crates/ide/src/completion/complete_mod.rs", "status": "modified", "additions": 95, "deletions": 21, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -1,39 +1,113 @@\n //! Completes mod declarations.\n \n-use base_db::FileLoader;\n-use hir::ModuleSource;\n+use base_db::{SourceDatabaseExt, VfsPath};\n+use hir::{Module, ModuleSource};\n+use ide_db::RootDatabase;\n \n use super::{completion_context::CompletionContext, completion_item::Completions};\n \n /// Complete mod declaration, i.e. `mod <|> ;`\n pub(super) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) {\n     let module_names_for_import = ctx\n-        .sema\n-        // TODO kb this is wrong, since we need not the file module\n-        .to_module_def(ctx.position.file_id)\n+        .scope\n+        .module()\n         .and_then(|current_module| {\n-            dbg!(current_module.name(ctx.db));\n-            dbg!(current_module.definition_source(ctx.db));\n-            dbg!(current_module.declaration_source(ctx.db));\n-            let mut zz = Vec::new();\n-            let mut vv = Some(current_module);\n-            while let Some(ModuleSource::Module(_)) =\n-                vv.map(|vv| vv.definition_source(ctx.db).value)\n-            {\n-                zz.push(current_module.name(ctx.db));\n-                vv = current_module.parent(ctx.db);\n-            }\n-            dbg!(zz);\n-            let definition_source = current_module.definition_source(ctx.db);\n+            let module_path = path_to_closest_containing_module_file(current_module, ctx.db);\n             // TODO kb filter out declarations in possible_sudmobule_names\n             // let declaration_source = current_module.declaration_source(ctx.db);\n-            let module_definition_source_file = definition_source.file_id.original_file(ctx.db);\n-            let mod_declaration_candidates =\n-                ctx.db.possible_sudmobule_names(module_definition_source_file);\n+            let module_definition_source_file =\n+                current_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n+\n+            let source_root_id = ctx.db.file_source_root(module_definition_source_file);\n+            let source_root = ctx.db.source_root(source_root_id);\n+            let directory_to_look_for_submodules = source_root\n+                .path_for_file(&module_definition_source_file)\n+                .and_then(|module_file_path| get_directory_with_submodules(module_file_path))?;\n+\n+            let mod_declaration_candidates = source_root\n+                .iter()\n+                .filter(|submodule_file| submodule_file != &module_definition_source_file)\n+                .filter_map(|submodule_file| {\n+                    let submodule_path = source_root.path_for_file(&submodule_file)?;\n+                    if submodule_path.parent()? == directory_to_look_for_submodules {\n+                        submodule_path.file_name_and_extension()\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .filter_map(|file_name_and_extension| {\n+                    match file_name_and_extension {\n+                        // TODO kb wrong resolution for nested non-file modules (mod tests { mod <|> })\n+                        // TODO kb in src/bin when a module is included into another,\n+                        // the included file gets \"moved\" into a directory below and now cannot add any other modules\n+                        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n+                        (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n+                        (subdirectory_name, None) => {\n+                            let mod_rs_path = directory_to_look_for_submodules\n+                                .join(subdirectory_name)?\n+                                .join(\"mod.rs\")?;\n+                            if source_root.file_for_path(&mod_rs_path).is_some() {\n+                                Some(subdirectory_name.to_owned())\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                })\n+                .collect::<Vec<_>>();\n             dbg!(mod_declaration_candidates);\n             // TODO kb exlude existing children from the candidates\n             let existing_children = current_module.children(ctx.db).collect::<Vec<_>>();\n             None::<Vec<String>>\n         })\n         .unwrap_or_default();\n }\n+\n+fn path_to_closest_containing_module_file(\n+    current_module: Module,\n+    db: &RootDatabase,\n+) -> Vec<Module> {\n+    let mut path = Vec::new();\n+\n+    let mut current_module = Some(current_module);\n+    while let Some(ModuleSource::Module(_)) =\n+        current_module.map(|module| module.definition_source(db).value)\n+    {\n+        if let Some(module) = current_module {\n+            path.insert(0, module);\n+            current_module = module.parent(db);\n+        } else {\n+            current_module = None;\n+        }\n+    }\n+\n+    path\n+}\n+\n+fn get_directory_with_submodules(module_file_path: &VfsPath) -> Option<VfsPath> {\n+    let module_directory_path = module_file_path.parent()?;\n+    match module_file_path.file_name_and_extension()? {\n+        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n+            Some(module_directory_path)\n+        }\n+        (regular_rust_file_name, Some(\"rs\")) => {\n+            if matches!(\n+                (\n+                    module_directory_path\n+                        .parent()\n+                        .as_ref()\n+                        .and_then(|path| path.file_name_and_extension()),\n+                    module_directory_path.file_name_and_extension(),\n+                ),\n+                (Some((\"src\", None)), Some((\"bin\", None)))\n+            ) {\n+                // files in /src/bin/ can import each other directly\n+                Some(module_directory_path)\n+            } else {\n+                module_directory_path.join(regular_rust_file_name)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "47355d5dcba3ae91d1d99e32bf89576e5f721624", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n-use base_db::{FileLoader, SourceDatabase};\n-use hir::{ModuleSource, Semantics, SemanticsScope, Type};\n+use base_db::SourceDatabase;\n+use hir::{Semantics, SemanticsScope, Type};\n use ide_db::RootDatabase;\n use syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n@@ -112,6 +112,7 @@ impl<'a> CompletionContext<'a> {\n         };\n         let fake_ident_token =\n             file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n+\n         let krate = sema.to_module_def(position.file_id).map(|m| m.krate());\n         let original_token =\n             original_file.syntax().token_at_offset(position.offset).left_biased()?;"}, {"sha": "70ada02f3121ef0b03cf489ea2c35e7eaf659320", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c14ac7204c38633e70b3efd47a5b1f9056afd0/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "patch": "@@ -74,9 +74,6 @@ impl FileLoader for RootDatabase {\n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        FileLoaderDelegate(self).possible_sudmobule_names(module_file)\n-    }\n }\n \n impl salsa::Database for RootDatabase {"}]}