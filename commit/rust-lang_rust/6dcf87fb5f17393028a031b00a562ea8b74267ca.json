{"sha": "6dcf87fb5f17393028a031b00a562ea8b74267ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkY2Y4N2ZiNWYxNzM5MzAyOGEwMzFiMDBhNTYyZWE4Yjc0MjY3Y2E=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-23T17:55:23Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-23T17:55:23Z"}, "message": "Start join-lines", "tree": {"sha": "05de66dc2944ca78e34b507f80e7e12056d4f867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05de66dc2944ca78e34b507f80e7e12056d4f867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dcf87fb5f17393028a031b00a562ea8b74267ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dcf87fb5f17393028a031b00a562ea8b74267ca", "html_url": "https://github.com/rust-lang/rust/commit/6dcf87fb5f17393028a031b00a562ea8b74267ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dcf87fb5f17393028a031b00a562ea8b74267ca/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec706175645172ee4bd5d3d4c0645ffb45d79bbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec706175645172ee4bd5d3d4c0645ffb45d79bbf", "html_url": "https://github.com/rust-lang/rust/commit/ec706175645172ee4bd5d3d4c0645ffb45d79bbf"}], "stats": {"total": 135, "additions": 134, "deletions": 1}, "files": [{"sha": "c25ee973c9e7e6e9757d6df9ba2fa770836d5e88", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=6dcf87fb5f17393028a031b00a562ea8b74267ca", "patch": "@@ -14,6 +14,7 @@ use libsyntax2::{\n \n use {TextUnit, EditBuilder, Edit};\n \n+#[derive(Debug)]\n pub struct ActionResult {\n     pub edit: Edit,\n     pub cursor_position: Option<TextUnit>,"}, {"sha": "f8bc73ae9fa119569012fe6eb5f3bf85b7174035", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=6dcf87fb5f17393028a031b00a562ea8b74267ca", "patch": "@@ -7,11 +7,12 @@ mod symbols;\n mod line_index;\n mod edit;\n mod code_actions;\n+mod typing;\n \n use libsyntax2::{\n     ast::{self, NameOwner},\n     AstNode,\n-    algo::{walk, find_leaf_at_offset},\n+    algo::{walk, find_leaf_at_offset, find_covering_node},\n     SyntaxKind::{self, *},\n };\n pub use libsyntax2::{ParsedFile, TextRange, TextUnit};\n@@ -24,6 +25,7 @@ pub use self::{\n         ActionResult, find_node,\n         flip_comma, add_derive, add_impl,\n     },\n+    typing::join_lines,\n };\n \n #[derive(Debug)]"}, {"sha": "f49dd0fdc6abbaeb21410bfd8572647f1a68bae5", "filename": "crates/libeditor/src/typing.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftyping.rs?ref=6dcf87fb5f17393028a031b00a562ea8b74267ca", "patch": "@@ -0,0 +1,81 @@\n+use libsyntax2::{\n+    TextUnit, TextRange, SyntaxNodeRef,\n+    ast,\n+    algo::{\n+        walk::preorder,\n+        find_covering_node,\n+    },\n+};\n+\n+use {ActionResult, EditBuilder};\n+\n+pub fn join_lines(file: &ast::ParsedFile, range: TextRange) -> ActionResult {\n+    let range = if range.is_empty() {\n+        let text = file.syntax().text();\n+        let text = &text[TextRange::from_to(range.start(), TextUnit::of_str(&text))];\n+        let pos = text.bytes().take_while(|&b| b != b'\\n').count();\n+        if pos == text.len() {\n+            return ActionResult {\n+                edit: EditBuilder::new().finish(),\n+                cursor_position: None\n+            };\n+        }\n+        let pos: TextUnit = (pos as u32).into();\n+        TextRange::offset_len(\n+            range.start() + pos,\n+            TextUnit::of_char('\\n'),\n+        )\n+    } else {\n+        range\n+    };\n+    let node = find_covering_node(file.syntax(), range);\n+    let mut edit = EditBuilder::new();\n+    for node in preorder(node) {\n+        let text = match node.leaf_text() {\n+            Some(text) => text,\n+            None => continue,\n+        };\n+        let range = match intersect(range, node.range()) {\n+            Some(range) => range,\n+            None => continue,\n+        } - node.range().start();\n+        for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n+            let pos: TextUnit = (pos as u32).into();\n+            let off = node.range().start() + range.start() + pos;\n+            remove_newline(&mut edit, node, text.as_str(), off);\n+        }\n+    }\n+\n+    ActionResult {\n+        edit: edit.finish(),\n+        cursor_position: None,\n+    }\n+}\n+\n+fn intersect(r1: TextRange, r2: TextRange) -> Option<TextRange> {\n+    let start = r1.start().max(r2.start());\n+    let end = r1.end().min(r2.end());\n+    if start <= end {\n+        Some(TextRange::from_to(start, end))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn remove_newline(\n+    edit: &mut EditBuilder,\n+    node: SyntaxNodeRef,\n+    node_text: &str,\n+    offset: TextUnit,\n+) {\n+    let suff = &node_text[TextRange::from_to(\n+        offset - node.range().start() + TextUnit::of_char('\\n'),\n+        TextUnit::of_str(node_text),\n+    )];\n+    let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n+\n+    edit.replace(\n+        TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n+        \" \".to_string(),\n+    );\n+}"}, {"sha": "6aa260a861e8e7935cda30bb60fd79d2fc60332c", "filename": "crates/libeditor/tests/test.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcf87fb5f17393028a031b00a562ea8b74267ca/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=6dcf87fb5f17393028a031b00a562ea8b74267ca", "patch": "@@ -8,6 +8,7 @@ use libeditor::{\n     ParsedFile, TextUnit, TextRange, ActionResult,\n     highlight, runnables, extend_selection, file_structure,\n     flip_comma, add_derive, add_impl, matching_brace,\n+    join_lines,\n };\n \n #[test]\n@@ -177,6 +178,54 @@ fn test_matching_brace() {\n     );\n }\n \n+#[test]\n+fn test_join_lines_cursor() {\n+    fn do_check(before: &str, after: &str) {\n+        check_action(before, after, |file, offset| {\n+            let range = TextRange::offset_len(offset, 0.into());\n+            let res = join_lines(file, range);\n+            Some(res)\n+        })\n+    }\n+\n+    do_check(r\"\n+fn foo() {\n+    <|>foo(1,\n+    )\n+}\n+\", r\"\n+fn foo() {\n+    <|>foo(1, )\n+}\n+\");\n+}\n+\n+#[test]\n+fn test_join_lines_selection() {\n+    fn do_check(before: &str, after: &str) {\n+        let (sel_start, before) = extract_cursor(before);\n+        let (sel_end, before) = extract_cursor(&before);\n+        let sel = TextRange::from_to(sel_start, sel_end);\n+        let file = file(&before);\n+        let result = join_lines(&file, sel);\n+        let actual = result.edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    do_check(r\"\n+fn foo() {\n+    <|>foo(1,\n+        2,\n+        3,\n+    <|>)\n+}\n+\", r\"\n+fn foo() {\n+    foo(1, 2, 3, )\n+}\n+\");\n+}\n+\n fn file(text: &str) -> ParsedFile {\n     ParsedFile::parse(text)\n }"}]}