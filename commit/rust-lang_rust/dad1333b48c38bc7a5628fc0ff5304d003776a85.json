{"sha": "dad1333b48c38bc7a5628fc0ff5304d003776a85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZDEzMzNiNDhjMzhiYzdhNTYyOGZjMGZmNTMwNGQwMDM3NzZhODU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-11T09:04:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-23T15:51:06Z"}, "message": "New VFS", "tree": {"sha": "29be52a980b4cae72f46a48c48135a15e31641e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29be52a980b4cae72f46a48c48135a15e31641e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dad1333b48c38bc7a5628fc0ff5304d003776a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dad1333b48c38bc7a5628fc0ff5304d003776a85", "html_url": "https://github.com/rust-lang/rust/commit/dad1333b48c38bc7a5628fc0ff5304d003776a85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dad1333b48c38bc7a5628fc0ff5304d003776a85/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7aa66371ee3e8b31217513204c8b4f683584419d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa66371ee3e8b31217513204c8b4f683584419d", "html_url": "https://github.com/rust-lang/rust/commit/7aa66371ee3e8b31217513204c8b4f683584419d"}], "stats": {"total": 2025, "additions": 1026, "deletions": 999}, "files": [{"sha": "f2069c55e36b4d6b6603bd7904f358e86f549122", "filename": "Cargo.lock", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -354,19 +354,19 @@ checksum = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \n [[package]]\n name = \"fsevent\"\n-version = \"0.4.0\"\n+version = \"2.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ab7d1bd1bd33cc98b0889831b72da23c0aa4df9cec7e0702f46ecea04b35db6\"\n+checksum = \"97f347202c95c98805c216f9e1df210e8ebaec9fdb2365700a43c10797a35e63\"\n dependencies = [\n  \"bitflags\",\n  \"fsevent-sys\",\n ]\n \n [[package]]\n name = \"fsevent-sys\"\n-version = \"2.0.1\"\n+version = \"3.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f41b048a94555da0f42f1d632e2e19510084fb8e303b0daa2816e733fb3644a0\"\n+checksum = \"77a29c77f1ca394c3e73a9a5d24cfcabb734682d9634fc398f2204a63c994120\"\n dependencies = [\n  \"libc\",\n ]\n@@ -483,9 +483,9 @@ dependencies = [\n \n [[package]]\n name = \"inotify\"\n-version = \"0.7.1\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4816c66d2c8ae673df83366c18341538f234a26d65a9ecea5c348b453ac1d02f\"\n+checksum = \"46dd0a94b393c730779ccfd2a872b67b1eb67be3fc33082e733bdb38b5fde4d4\"\n dependencies = [\n  \"bitflags\",\n  \"inotify-sys\",\n@@ -766,11 +766,13 @@ dependencies = [\n \n [[package]]\n name = \"notify\"\n-version = \"4.0.15\"\n+version = \"5.0.0-pre.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80ae4a7688d1fab81c5bf19c64fc8db920be8d519ce6336ed4e7efe024724dbd\"\n+checksum = \"77d03607cf88b4b160ba0e9ed425fff3cee3b55ac813f0c685b3a3772da37d0e\"\n dependencies = [\n+ \"anymap\",\n  \"bitflags\",\n+ \"crossbeam-channel\",\n  \"filetime\",\n  \"fsevent\",\n  \"fsevent-sys\",\n@@ -952,7 +954,9 @@ dependencies = [\n  \"relative-path\",\n  \"rustc-hash\",\n  \"salsa\",\n+ \"stdx\",\n  \"test_utils\",\n+ \"vfs\",\n ]\n \n [[package]]\n@@ -1232,22 +1236,6 @@ dependencies = [\n  \"smol_str\",\n ]\n \n-[[package]]\n-name = \"ra_vfs\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cbf31a173fc77ec59c27cf39af6baa137b40f4dbd45a8b3eccb1b2e4cfc922c1\"\n-dependencies = [\n- \"crossbeam-channel\",\n- \"jod-thread\",\n- \"log\",\n- \"notify\",\n- \"parking_lot\",\n- \"relative-path\",\n- \"rustc-hash\",\n- \"walkdir\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n@@ -1405,7 +1393,6 @@ dependencies = [\n  \"ra_syntax\",\n  \"ra_text_edit\",\n  \"ra_tt\",\n- \"ra_vfs\",\n  \"rand\",\n  \"rustc-hash\",\n  \"serde\",\n@@ -1414,6 +1401,8 @@ dependencies = [\n  \"tempfile\",\n  \"test_utils\",\n  \"threadpool\",\n+ \"vfs\",\n+ \"vfs-notify\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -1763,12 +1752,23 @@ dependencies = [\n [[package]]\n name = \"vfs\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"paths\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"vfs-notify\"\n+version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"globset\",\n  \"jod-thread\",\n+ \"log\",\n+ \"notify\",\n  \"paths\",\n  \"rustc-hash\",\n+ \"vfs\",\n  \"walkdir\",\n ]\n "}, {"sha": "45b19c45a0d8620794a736f14c5b1799cde340b7", "filename": "crates/paths/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -2,7 +2,7 @@\n //! relative paths.\n use std::{\n     convert::{TryFrom, TryInto},\n-    io, ops,\n+    ops,\n     path::{Component, Path, PathBuf},\n };\n \n@@ -46,9 +46,6 @@ impl TryFrom<&str> for AbsPathBuf {\n }\n \n impl AbsPathBuf {\n-    pub fn canonicalized(path: &Path) -> io::Result<AbsPathBuf> {\n-        path.canonicalize().map(|it| AbsPathBuf::try_from(it).unwrap())\n-    }\n     pub fn as_path(&self) -> &AbsPath {\n         AbsPath::new_unchecked(self.0.as_path())\n     }"}, {"sha": "55576813fc5bb4e8f9081b03d659bdd3d150e9d1", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,10 +1,8 @@\n mod generated;\n \n-use std::sync::Arc;\n-\n use hir::Semantics;\n use ra_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n-use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n+use ra_ide_db::RootDatabase;\n use ra_syntax::TextRange;\n use test_utils::{\n     assert_eq_text, extract_offset, extract_range, extract_range_or_offset, RangeOrOffset,\n@@ -13,11 +11,7 @@ use test_utils::{\n use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, Assists};\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n-    let (mut db, file_id) = RootDatabase::with_single_file(text);\n-    // FIXME: ideally, this should be done by the above `RootDatabase::with_single_file`,\n-    // but it looks like this might need specialization? :(\n-    db.set_local_roots(Arc::new(vec![db.file_source_root(file_id)]));\n-    (db, file_id)\n+    RootDatabase::with_single_file(text)\n }\n \n pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_after: &str) {\n@@ -72,8 +66,7 @@ enum ExpectedResult<'a> {\n \n fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let (text_without_caret, file_with_caret_id, range_or_offset, db) = if before.contains(\"//-\") {\n-        let (mut db, position) = RootDatabase::with_position(before);\n-        db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n+        let (db, position) = RootDatabase::with_position(before);\n         (\n             db.file_text(position.file_id).as_ref().to_owned(),\n             position.file_id,"}, {"sha": "372fb242b10c49980523f58a7b9977b2c3ac78db", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -17,3 +17,5 @@ ra_cfg = { path = \"../ra_cfg\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_tt = { path = \"../ra_tt\" }\n test_utils = { path = \"../test_utils\" }\n+vfs = { path = \"../vfs\" }\n+stdx = { path = \"../stdx\" }"}, {"sha": "f7d9118a9a3f0045bc62ba73c23f38c763180514", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -57,17 +57,16 @@\n //! fn insert_source_code_here() {}\n //! \"\n //! ```\n-\n-use std::str::FromStr;\n-use std::sync::Arc;\n+use std::{str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use test_utils::{extract_offset, parse_fixture, parse_single_fixture, FixtureMeta, CURSOR_MARKER};\n+use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n-    input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf,\n-    SourceDatabaseExt, SourceRoot, SourceRootId,\n+    input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, SourceDatabaseExt,\n+    SourceRoot, SourceRootId,\n };\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n@@ -105,10 +104,10 @@ impl<DB: SourceDatabaseExt + Default + 'static> WithFixture for DB {}\n \n fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId {\n     let file_id = FileId(0);\n-    let rel_path: RelativePathBuf = \"/main.rs\".into();\n+    let mut file_set = vfs::file_set::FileSet::default();\n+    file_set.insert(file_id, vfs::VfsPath::new_virtual_path(\"/main.rs\".to_string()));\n \n-    let mut source_root = SourceRoot::new_local();\n-    source_root.insert_file(rel_path.clone(), file_id);\n+    let source_root = SourceRoot::new_local(file_set);\n \n     let fixture = parse_single_fixture(ra_fixture);\n \n@@ -128,7 +127,6 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId\n             meta.cfg,\n             meta.env,\n             Default::default(),\n-            Default::default(),\n         );\n         crate_graph\n     } else {\n@@ -140,13 +138,11 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         crate_graph\n     };\n \n     db.set_file_text(file_id, Arc::new(ra_fixture.to_string()));\n-    db.set_file_relative_path(file_id, rel_path);\n     db.set_file_source_root(file_id, WORKSPACE);\n     db.set_source_root(WORKSPACE, Arc::new(source_root));\n     db.set_crate_graph(Arc::new(crate_graph));\n@@ -162,7 +158,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n     let mut crate_deps = Vec::new();\n     let mut default_crate_root: Option<FileId> = None;\n \n-    let mut source_root = SourceRoot::new_local();\n+    let mut file_set = FileSet::default();\n     let mut source_root_id = WORKSPACE;\n     let mut source_root_prefix = \"/\".to_string();\n     let mut file_id = FileId(0);\n@@ -172,8 +168,8 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n     for entry in fixture.iter() {\n         let meta = match ParsedMeta::from(&entry.meta) {\n             ParsedMeta::Root { path } => {\n-                let source_root = std::mem::replace(&mut source_root, SourceRoot::new_local());\n-                db.set_source_root(source_root_id, Arc::new(source_root));\n+                let file_set = std::mem::replace(&mut file_set, FileSet::default());\n+                db.set_source_root(source_root_id, Arc::new(SourceRoot::new_local(file_set)));\n                 source_root_id.0 += 1;\n                 source_root_prefix = path;\n                 continue;\n@@ -190,7 +186,6 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n                 meta.cfg,\n                 meta.env,\n                 Default::default(),\n-                Default::default(),\n             );\n             let prev = crates.insert(krate.clone(), crate_id);\n             assert!(prev.is_none());\n@@ -212,9 +207,9 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n         };\n \n         db.set_file_text(file_id, Arc::new(text));\n-        db.set_file_relative_path(file_id, meta.path.clone().into());\n         db.set_file_source_root(file_id, source_root_id);\n-        source_root.insert_file(meta.path.into(), file_id);\n+        let path = VfsPath::new_virtual_path(meta.path);\n+        file_set.insert(file_id, path.into());\n \n         file_id.0 += 1;\n     }\n@@ -228,7 +223,6 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n     } else {\n         for (from, to) in crate_deps {\n@@ -238,7 +232,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n         }\n     }\n \n-    db.set_source_root(source_root_id, Arc::new(source_root));\n+    db.set_source_root(source_root_id, Arc::new(SourceRoot::new_local(file_set)));\n     db.set_crate_graph(Arc::new(crate_graph));\n \n     file_position"}, {"sha": "7f366011853ea61947997ffbf5f811044f3bc12d", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 10, "deletions": 69, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -6,27 +6,15 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{\n-    fmt, ops,\n-    path::{Path, PathBuf},\n-    str::FromStr,\n-    sync::Arc,\n-};\n+use std::{fmt, ops, str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n use ra_tt::TokenExpander;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use vfs::file_set::FileSet;\n \n-use crate::{RelativePath, RelativePathBuf};\n-\n-/// `FileId` is an integer which uniquely identifies a file. File paths are\n-/// messy and system-dependent, so most of the code should work directly with\n-/// `FileId`, without inspecting the path. The mapping between `FileId` and path\n-/// and `SourceRoot` is constant. A file rename is represented as a pair of\n-/// deletion/creation.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct FileId(pub u32);\n+pub use vfs::FileId;\n \n /// Files are grouped into source roots. A source root is a directory on the\n /// file systems which is watched for changes. Typically it corresponds to a\n@@ -45,27 +33,18 @@ pub struct SourceRoot {\n     /// Libraries are considered mostly immutable, this assumption is used to\n     /// optimize salsa's query structure\n     pub is_library: bool,\n-    files: FxHashMap<RelativePathBuf, FileId>,\n+    pub(crate) file_set: FileSet,\n }\n \n impl SourceRoot {\n-    pub fn new_local() -> SourceRoot {\n-        SourceRoot { is_library: false, files: Default::default() }\n-    }\n-    pub fn new_library() -> SourceRoot {\n-        SourceRoot { is_library: true, files: Default::default() }\n-    }\n-    pub fn insert_file(&mut self, path: RelativePathBuf, file_id: FileId) {\n-        self.files.insert(path, file_id);\n+    pub fn new_local(file_set: FileSet) -> SourceRoot {\n+        SourceRoot { is_library: false, file_set }\n     }\n-    pub fn remove_file(&mut self, path: &RelativePath) {\n-        self.files.remove(path);\n+    pub fn new_library(file_set: FileSet) -> SourceRoot {\n+        SourceRoot { is_library: true, file_set }\n     }\n-    pub fn walk(&self) -> impl Iterator<Item = FileId> + '_ {\n-        self.files.values().copied()\n-    }\n-    pub fn file_by_relative_path(&self, path: &RelativePath) -> Option<FileId> {\n-        self.files.get(path).copied()\n+    pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n+        self.file_set.iter()\n     }\n }\n \n@@ -141,7 +120,6 @@ pub struct CrateData {\n     pub display_name: Option<CrateName>,\n     pub cfg_options: CfgOptions,\n     pub env: Env,\n-    pub extern_source: ExternSource,\n     pub dependencies: Vec<Dependency>,\n     pub proc_macro: Vec<ProcMacro>,\n }\n@@ -152,22 +130,11 @@ pub enum Edition {\n     Edition2015,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ExternSourceId(pub u32);\n-\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct Env {\n     entries: FxHashMap<String, String>,\n }\n \n-// FIXME: Redesign vfs for solve the following limitation ?\n-// Note: Some env variables (e.g. OUT_DIR) are located outside of the\n-// crate. We store a map to allow remap it to ExternSourceId\n-#[derive(Default, Debug, Clone, PartialEq, Eq)]\n-pub struct ExternSource {\n-    extern_paths: FxHashMap<PathBuf, ExternSourceId>,\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Dependency {\n     pub crate_id: CrateId,\n@@ -182,7 +149,6 @@ impl CrateGraph {\n         display_name: Option<CrateName>,\n         cfg_options: CfgOptions,\n         env: Env,\n-        extern_source: ExternSource,\n         proc_macro: Vec<(SmolStr, Arc<dyn ra_tt::TokenExpander>)>,\n     ) -> CrateId {\n         let proc_macro =\n@@ -194,7 +160,6 @@ impl CrateGraph {\n             display_name,\n             cfg_options,\n             env,\n-            extern_source,\n             proc_macro,\n             dependencies: Vec::new(),\n         };\n@@ -334,20 +299,6 @@ impl Env {\n     }\n }\n \n-impl ExternSource {\n-    pub fn extern_path(&self, path: &Path) -> Option<(ExternSourceId, RelativePathBuf)> {\n-        self.extern_paths.iter().find_map(|(root_path, id)| {\n-            let rel_path = path.strip_prefix(root_path).ok()?;\n-            let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-            Some((*id, rel_path))\n-        })\n-    }\n-\n-    pub fn set_extern_path(&mut self, root_path: &Path, root: ExternSourceId) {\n-        self.extern_paths.insert(root_path.to_path_buf(), root);\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct ParseEditionError {\n     invalid_input: String,\n@@ -378,7 +329,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -387,7 +337,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -396,7 +345,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         assert!(graph.add_dep(crate1, CrateName::new(\"crate2\").unwrap(), crate2).is_ok());\n         assert!(graph.add_dep(crate2, CrateName::new(\"crate3\").unwrap(), crate3).is_ok());\n@@ -413,7 +361,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -422,7 +369,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         assert!(graph.add_dep(crate1, CrateName::new(\"crate2\").unwrap(), crate2).is_ok());\n         assert!(graph.add_dep(crate2, CrateName::new(\"crate2\").unwrap(), crate2).is_err());\n@@ -438,7 +384,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -447,7 +392,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -456,7 +400,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         assert!(graph.add_dep(crate1, CrateName::new(\"crate2\").unwrap(), crate2).is_ok());\n         assert!(graph.add_dep(crate2, CrateName::new(\"crate3\").unwrap(), crate3).is_ok());\n@@ -472,7 +415,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -481,7 +423,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         assert!(graph\n             .add_dep(crate1, CrateName::normalize_dashes(\"crate-name-with-dashes\"), crate2)"}, {"sha": "875290259bef23342378af517a089ddb7eb4d6c2", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -12,12 +12,13 @@ use rustc_hash::FxHashSet;\n pub use crate::{\n     cancellation::Canceled,\n     input::{\n-        CrateData, CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource,\n-        ExternSourceId, FileId, ProcMacroId, SourceRoot, SourceRootId,\n+        CrateData, CrateGraph, CrateId, CrateName, Dependency, Edition, Env, FileId, ProcMacroId,\n+        SourceRoot, SourceRootId,\n     },\n };\n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n+pub use vfs::{file_set::FileSet, AbsPathBuf, VfsPath};\n \n #[macro_export]\n macro_rules! impl_intern_key {\n@@ -125,8 +126,6 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n     /// Path to a file, relative to the root of its source root.\n-    #[salsa::input]\n-    fn file_relative_path(&self, file_id: FileId) -> RelativePathBuf;\n     /// Source root of the file.\n     #[salsa::input]\n     fn file_source_root(&self, file_id: FileId) -> SourceRootId;\n@@ -161,24 +160,9 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n     fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n         // FIXME: this *somehow* should be platform agnostic...\n-        if std::path::Path::new(path).is_absolute() {\n-            let krate = *self.relevant_crates(anchor).iter().next()?;\n-            let (extern_source_id, relative_file) =\n-                self.0.crate_graph()[krate].extern_source.extern_path(path.as_ref())?;\n-\n-            let source_root = self.0.source_root(SourceRootId(extern_source_id.0));\n-            source_root.file_by_relative_path(&relative_file)\n-        } else {\n-            let rel_path = {\n-                let mut rel_path = self.0.file_relative_path(anchor);\n-                assert!(rel_path.pop());\n-                rel_path.push(path);\n-                rel_path.normalize()\n-            };\n-            let source_root = self.0.file_source_root(anchor);\n-            let source_root = self.0.source_root(source_root);\n-            source_root.file_by_relative_path(&rel_path)\n-        }\n+        let source_root = self.0.file_source_root(anchor);\n+        let source_root = self.0.source_root(source_root);\n+        source_root.file_set.resolve_path(anchor, path)\n     }\n \n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {"}, {"sha": "76c32fc17aab08fc35720241b61677669642dd62", "filename": "crates/ra_hir/src/has_source.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fhas_source.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -2,7 +2,7 @@\n \n use either::Either;\n use hir_def::{\n-    nameres::ModuleSource,\n+    nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource as _},\n     Lookup, VariantId,\n };\n@@ -29,6 +29,14 @@ impl Module {\n         def_map[self.id.local_id].definition_source(db.upcast())\n     }\n \n+    pub fn is_mod_rs(self, db: &dyn HirDatabase) -> bool {\n+        let def_map = db.crate_def_map(self.id.krate);\n+        match def_map[self.id.local_id].origin {\n+            ModuleOrigin::File { is_mod_rs, .. } => is_mod_rs,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n     /// `None` for the crate root.\n     pub fn declaration_source(self, db: &dyn HirDatabase) -> Option<InFile<ast::Module>> {"}, {"sha": "060273db400dbf2879bb061c816e5a9e1e9337b8", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -104,6 +104,7 @@ pub enum ModuleOrigin {\n     },\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n     File {\n+        is_mod_rs: bool,\n         declaration: AstId<ast::Module>,\n         definition: FileId,\n     },"}, {"sha": "cbce04315971c1f1cc02680b32fd9eb1c7c1f3b8", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -777,11 +777,11 @@ impl ModCollector<'_, '_> {\n                     name,\n                     path_attr,\n                 ) {\n-                    Ok((file_id, mod_dir)) => {\n+                    Ok((file_id, is_mod_rs, mod_dir)) => {\n                         let module_id = self.push_child_module(\n                             name.clone(),\n                             ast_id,\n-                            Some(file_id),\n+                            Some((file_id, is_mod_rs)),\n                             &visibility,\n                         );\n                         let raw_items = self.def_collector.db.raw_items(file_id.into());\n@@ -814,7 +814,7 @@ impl ModCollector<'_, '_> {\n         &mut self,\n         name: Name,\n         declaration: AstId<ast::Module>,\n-        definition: Option<FileId>,\n+        definition: Option<(FileId, bool)>,\n         visibility: &crate::visibility::RawVisibility,\n     ) -> LocalModuleId {\n         let vis = self\n@@ -827,7 +827,9 @@ impl ModCollector<'_, '_> {\n         modules[res].parent = Some(self.module_id);\n         modules[res].origin = match definition {\n             None => ModuleOrigin::Inline { definition: declaration },\n-            Some(definition) => ModuleOrigin::File { declaration, definition },\n+            Some((definition, is_mod_rs)) => {\n+                ModuleOrigin::File { declaration, definition, is_mod_rs }\n+            }\n         };\n         for (name, mac) in modules[self.module_id].scope.collect_legacy_macros() {\n             modules[res].scope.define_legacy_macro(name, mac)"}, {"sha": "39e9a6d9778fbb44c01503664acbee0fa09caff1", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -44,7 +44,7 @@ impl ModDir {\n         file_id: HirFileId,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n-    ) -> Result<(FileId, ModDir), String> {\n+    ) -> Result<(FileId, bool, ModDir), String> {\n         let file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = Vec::new();\n@@ -64,11 +64,12 @@ impl ModDir {\n             if let Some(file_id) = db.resolve_path(file_id, candidate.as_str()) {\n                 let mut root_non_dir_owner = false;\n                 let mut mod_path = RelativePathBuf::new();\n-                if !(candidate.ends_with(\"mod.rs\") || attr_path.is_some()) {\n+                let is_mod_rs = candidate.ends_with(\"mod.rs\");\n+                if !(is_mod_rs || attr_path.is_some()) {\n                     root_non_dir_owner = true;\n                     mod_path.push(&name.to_string());\n                 }\n-                return Ok((file_id, ModDir { path: mod_path, root_non_dir_owner }));\n+                return Ok((file_id, is_mod_rs, ModDir { path: mod_path, root_non_dir_owner }));\n             }\n         }\n         Err(candidate_files.remove(0))"}, {"sha": "ecac5134e6970e599a410210b8eb7a46a42ec903", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -47,7 +47,7 @@ use std::sync::Arc;\n use ra_cfg::CfgOptions;\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n-    CheckCanceled, Env, FileLoader, SourceDatabase,\n+    CheckCanceled, Env, FileLoader, FileSet, SourceDatabase, VfsPath,\n };\n use ra_ide_db::{\n     symbol_index::{self, FileSymbol},\n@@ -78,7 +78,8 @@ pub use crate::{\n pub use hir::Documentation;\n pub use ra_assists::{Assist, AssistConfig, AssistId, ResolvedAssist};\n pub use ra_db::{\n-    Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n+    Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRoot,\n+    SourceRootId,\n };\n pub use ra_ide_db::{\n     change::AnalysisChange,\n@@ -212,11 +213,14 @@ impl Analysis {\n     // `AnalysisHost` for creating a fully-featured analysis.\n     pub fn from_single_file(text: String) -> (Analysis, FileId) {\n         let mut host = AnalysisHost::default();\n-        let source_root = SourceRootId(0);\n+        let file_id = FileId(0);\n+        let mut file_set = FileSet::default();\n+        file_set.insert(file_id, VfsPath::new_virtual_path(\"/main.rs\".to_string()));\n+        let source_root = SourceRoot::new_local(file_set);\n+\n         let mut change = AnalysisChange::new();\n-        change.add_root(source_root, true);\n+        change.set_roots(vec![source_root]);\n         let mut crate_graph = CrateGraph::default();\n-        let file_id = FileId(0);\n         // FIXME: cfg options\n         // Default to enable test for single file.\n         let mut cfg_options = CfgOptions::default();\n@@ -228,9 +232,8 @@ impl Analysis {\n             cfg_options,\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n-        change.add_file(source_root, file_id, \"main.rs\".into(), Arc::new(text));\n+        change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);\n         (host.analysis(), file_id)"}, {"sha": "58fafecab0c97850c0b68a6f4cd2ab5ee48c3227", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,15 +1,12 @@\n //! FIXME: write short doc here\n-\n-use std::str::FromStr;\n-use std::sync::Arc;\n+use std::{str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n-use ra_db::{CrateName, Env};\n+use ra_db::{CrateName, Env, FileSet, SourceRoot, VfsPath};\n use test_utils::{extract_offset, extract_range, parse_fixture, FixtureEntry, CURSOR_MARKER};\n \n use crate::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition, FileId, FilePosition, FileRange,\n-    SourceRootId,\n };\n \n #[derive(Debug)]\n@@ -159,9 +156,8 @@ impl MockAnalysis {\n     }\n     pub fn analysis_host(self) -> AnalysisHost {\n         let mut host = AnalysisHost::default();\n-        let source_root = SourceRootId(0);\n         let mut change = AnalysisChange::new();\n-        change.add_root(source_root, true);\n+        let mut file_set = FileSet::default();\n         let mut crate_graph = CrateGraph::default();\n         let mut root_crate = None;\n         for (i, data) in self.files.into_iter().enumerate() {\n@@ -179,7 +175,6 @@ impl MockAnalysis {\n                     cfg_options,\n                     env,\n                     Default::default(),\n-                    Default::default(),\n                 ));\n             } else if path.ends_with(\"/lib.rs\") {\n                 let base = &path[..path.len() - \"/lib.rs\".len()];\n@@ -191,17 +186,19 @@ impl MockAnalysis {\n                     cfg_options,\n                     env,\n                     Default::default(),\n-                    Default::default(),\n                 );\n                 if let Some(root_crate) = root_crate {\n                     crate_graph\n                         .add_dep(root_crate, CrateName::new(crate_name).unwrap(), other_crate)\n                         .unwrap();\n                 }\n             }\n-            change.add_file(source_root, file_id, path.into(), Arc::new(data.content().to_owned()));\n+            let path = VfsPath::new_virtual_path(path.to_string());\n+            file_set.insert(file_id, path);\n+            change.change_file(file_id, Some(Arc::new(data.content().to_owned())));\n         }\n         change.set_crate_graph(crate_graph);\n+        change.set_roots(vec![SourceRoot::new_local(file_set)]);\n         host.apply_change(change);\n         host\n     }"}, {"sha": "bc7f65470042b87567072188d3389b465d1736ad", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -145,7 +145,6 @@ mod tests {\n             CfgOptions::default(),\n             Env::default(),\n             Default::default(),\n-            Default::default(),\n         );\n         let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);"}, {"sha": "6edf565b536c3f2264e0d06c405286b6d08ff783", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n-use ra_db::{RelativePathBuf, SourceDatabaseExt};\n+use ra_db::SourceDatabaseExt;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n@@ -109,9 +109,8 @@ fn rename_mod(\n     let file_id = src.file_id.original_file(db);\n     match src.value {\n         ModuleSource::SourceFile(..) => {\n-            let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n             // mod is defined in path/to/dir/mod.rs\n-            let dst = if mod_path.file_stem() == Some(\"mod\") {\n+            let dst = if module.is_mod_rs(db) {\n                 format!(\"../{}/mod.rs\", new_name)\n             } else {\n                 format!(\"{}.rs\", new_name)"}, {"sha": "6cb96608bed85755c96af848e45bbf001db243b8", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -41,7 +41,7 @@ pub fn parse_search_replace(\n     match_finder.add_rule(rule);\n     for &root in db.local_roots().iter() {\n         let sr = db.source_root(root);\n-        for file_id in sr.walk() {\n+        for file_id in sr.iter() {\n             if let Some(edit) = match_finder.edits_for_file(file_id) {\n                 edits.push(SourceFileEdit { file_id, edit });\n             }"}, {"sha": "a95f6c13c1fb4d4362506d3e0d6692c103d87d95", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -9,26 +9,22 @@ use ra_db::{\n     SourceRootId,\n };\n use ra_prof::{memory_usage, profile, Bytes};\n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n \n use crate::{symbol_index::SymbolsDatabase, RootDatabase};\n \n #[derive(Default)]\n pub struct AnalysisChange {\n-    new_roots: Vec<(SourceRootId, bool)>,\n-    roots_changed: FxHashMap<SourceRootId, RootChange>,\n-    files_changed: Vec<(FileId, Arc<String>)>,\n+    roots: Option<Vec<SourceRoot>>,\n+    files_changed: Vec<(FileId, Option<Arc<String>>)>,\n     crate_graph: Option<CrateGraph>,\n }\n \n impl fmt::Debug for AnalysisChange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut d = fmt.debug_struct(\"AnalysisChange\");\n-        if !self.new_roots.is_empty() {\n-            d.field(\"new_roots\", &self.new_roots);\n-        }\n-        if !self.roots_changed.is_empty() {\n-            d.field(\"roots_changed\", &self.roots_changed);\n+        if let Some(roots) = &self.roots {\n+            d.field(\"roots\", roots);\n         }\n         if !self.files_changed.is_empty() {\n             d.field(\"files_changed\", &self.files_changed.len());\n@@ -45,30 +41,14 @@ impl AnalysisChange {\n         AnalysisChange::default()\n     }\n \n-    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n-        self.new_roots.push((root_id, is_local));\n-    }\n-\n-    pub fn add_file(\n-        &mut self,\n-        root_id: SourceRootId,\n-        file_id: FileId,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-    ) {\n-        let file = AddFile { file_id, path, text };\n-        self.roots_changed.entry(root_id).or_default().added.push(file);\n+    pub fn set_roots(&mut self, roots: Vec<SourceRoot>) {\n+        self.roots = Some(roots);\n     }\n \n-    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Option<Arc<String>>) {\n         self.files_changed.push((file_id, new_text))\n     }\n \n-    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n-        let file = RemoveFile { file_id, path };\n-        self.roots_changed.entry(root_id).or_default().removed.push(file);\n-    }\n-\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n@@ -114,58 +94,39 @@ impl RootDatabase {\n         let _p = profile(\"RootDatabase::apply_change\");\n         self.request_cancellation();\n         log::info!(\"apply_change {:?}\", change);\n-        if !change.new_roots.is_empty() {\n-            let mut local_roots = Vec::clone(&self.local_roots());\n-            let mut libraries = Vec::clone(&self.library_roots());\n-            for (root_id, is_local) in change.new_roots {\n-                let root =\n-                    if is_local { SourceRoot::new_local() } else { SourceRoot::new_library() };\n+        if let Some(roots) = change.roots {\n+            let mut local_roots = FxHashSet::default();\n+            let mut library_roots = FxHashSet::default();\n+            for (idx, root) in roots.into_iter().enumerate() {\n+                let root_id = SourceRootId(idx as u32);\n                 let durability = durability(&root);\n-                self.set_source_root_with_durability(root_id, Arc::new(root), durability);\n-                if is_local {\n-                    local_roots.push(root_id);\n+                if root.is_library {\n+                    library_roots.insert(root_id);\n                 } else {\n-                    libraries.push(root_id)\n+                    local_roots.insert(root_id);\n+                }\n+                for file_id in root.iter() {\n+                    self.set_file_source_root_with_durability(file_id, root_id, durability);\n                 }\n+                self.set_source_root_with_durability(root_id, Arc::new(root), durability);\n             }\n             self.set_local_roots_with_durability(Arc::new(local_roots), Durability::HIGH);\n-            self.set_library_roots_with_durability(Arc::new(libraries), Durability::HIGH);\n+            self.set_library_roots_with_durability(Arc::new(library_roots), Durability::HIGH);\n         }\n \n-        for (root_id, root_change) in change.roots_changed {\n-            self.apply_root_change(root_id, root_change);\n-        }\n         for (file_id, text) in change.files_changed {\n             let source_root_id = self.file_source_root(file_id);\n             let source_root = self.source_root(source_root_id);\n             let durability = durability(&source_root);\n+            // XXX: can't actually remove the file, just reset the text\n+            let text = text.unwrap_or_default();\n             self.set_file_text_with_durability(file_id, text, durability)\n         }\n         if let Some(crate_graph) = change.crate_graph {\n             self.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH)\n         }\n     }\n \n-    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n-        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n-        let durability = durability(&source_root);\n-        for add_file in root_change.added {\n-            self.set_file_text_with_durability(add_file.file_id, add_file.text, durability);\n-            self.set_file_relative_path_with_durability(\n-                add_file.file_id,\n-                add_file.path.clone(),\n-                durability,\n-            );\n-            self.set_file_source_root_with_durability(add_file.file_id, root_id, durability);\n-            source_root.insert_file(add_file.path, add_file.file_id);\n-        }\n-        for remove_file in root_change.removed {\n-            self.set_file_text_with_durability(remove_file.file_id, Default::default(), durability);\n-            source_root.remove_file(&remove_file.path);\n-        }\n-        self.set_source_root_with_durability(root_id, Arc::new(source_root), durability);\n-    }\n-\n     pub fn maybe_collect_garbage(&mut self) {\n         if cfg!(feature = \"wasm\") {\n             return;"}, {"sha": "44d5c35e684cdf85e5eff35c9d910838bf951cbb", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -157,14 +157,14 @@ impl Definition {\n         if let Some(Visibility::Public) = vis {\n             let source_root_id = db.file_source_root(file_id);\n             let source_root = db.source_root(source_root_id);\n-            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n+            let mut res = source_root.iter().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n \n             let krate = module.krate();\n             for rev_dep in krate.reverse_dependencies(db) {\n                 let root_file = rev_dep.root_file(db);\n                 let source_root_id = db.file_source_root(root_file);\n                 let source_root = db.source_root(source_root_id);\n-                res.extend(source_root.walk().map(|id| (id, None)));\n+                res.extend(source_root.iter().map(|id| (id, None)));\n             }\n             return SearchScope::new(res);\n         }"}, {"sha": "6929055b26e7ed101e4d04fdc86baa3301d97210", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -42,7 +42,7 @@ use ra_syntax::{\n     SyntaxNode, SyntaxNodePtr, TextRange, WalkEvent,\n };\n use rayon::prelude::*;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::RootDatabase;\n \n@@ -93,11 +93,11 @@ pub trait SymbolsDatabase: hir::db::HirDatabase + SourceDatabaseExt + ParallelDa\n     /// The set of \"local\" (that is, from the current workspace) roots.\n     /// Files in local roots are assumed to change frequently.\n     #[salsa::input]\n-    fn local_roots(&self) -> Arc<Vec<SourceRootId>>;\n+    fn local_roots(&self) -> Arc<FxHashSet<SourceRootId>>;\n     /// The set of roots for crates.io libraries.\n     /// Files in libraries are assumed to never change.\n     #[salsa::input]\n-    fn library_roots(&self) -> Arc<Vec<SourceRootId>>;\n+    fn library_roots(&self) -> Arc<FxHashSet<SourceRootId>>;\n }\n \n fn library_symbols(\n@@ -111,7 +111,7 @@ fn library_symbols(\n         .map(|&root_id| {\n             let root = db.source_root(root_id);\n             let files = root\n-                .walk()\n+                .iter()\n                 .map(|it| (it, SourceDatabaseExt::file_text(db, it)))\n                 .collect::<Vec<_>>();\n             let symbol_index = SymbolIndex::for_files(\n@@ -175,7 +175,7 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n         let mut files = Vec::new();\n         for &root in db.local_roots().iter() {\n             let sr = db.source_root(root);\n-            files.extend(sr.walk())\n+            files.extend(sr.iter())\n         }\n \n         let snap = Snap(db.snapshot());"}, {"sha": "fe3e816894326020b7c6a4b9e4e92c5903232d58", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -13,7 +13,7 @@ use std::{\n \n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n-use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n+use ra_db::{CrateGraph, CrateName, Edition, Env, FileId};\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde_json::from_reader;\n \n@@ -246,7 +246,6 @@ impl ProjectWorkspace {\n     pub fn to_crate_graph(\n         &self,\n         target: Option<&str>,\n-        extern_source_roots: &FxHashMap<PathBuf, ExternSourceId>,\n         proc_macro_client: &ProcMacroClient,\n         load: &mut dyn FnMut(&Path) -> Option<FileId>,\n     ) -> CrateGraph {\n@@ -280,15 +279,11 @@ impl ProjectWorkspace {\n                         };\n \n                         let mut env = Env::default();\n-                        let mut extern_source = ExternSource::default();\n                         if let Some(out_dir) = &krate.out_dir {\n                             // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n                             if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n                                 env.set(\"OUT_DIR\", out_dir);\n                             }\n-                            if let Some(&extern_source_id) = extern_source_roots.get(out_dir) {\n-                                extern_source.set_extern_path(&out_dir, extern_source_id);\n-                            }\n                         }\n                         let proc_macro = krate\n                             .proc_macro_dylib_path\n@@ -304,7 +299,6 @@ impl ProjectWorkspace {\n                                 None,\n                                 cfg_options,\n                                 env,\n-                                extern_source,\n                                 proc_macro.unwrap_or_default(),\n                             ),\n                         ))\n@@ -341,7 +335,6 @@ impl ProjectWorkspace {\n                         let file_id = load(&sysroot[krate].root)?;\n \n                         let env = Env::default();\n-                        let extern_source = ExternSource::default();\n                         let proc_macro = vec![];\n                         let crate_name = CrateName::new(&sysroot[krate].name)\n                             .expect(\"Sysroot crate names should not contain dashes\");\n@@ -352,7 +345,6 @@ impl ProjectWorkspace {\n                             Some(crate_name),\n                             cfg_options.clone(),\n                             env,\n-                            extern_source,\n                             proc_macro,\n                         );\n                         Some((krate, crate_id))\n@@ -409,15 +401,11 @@ impl ProjectWorkspace {\n                                 opts\n                             };\n                             let mut env = Env::default();\n-                            let mut extern_source = ExternSource::default();\n                             if let Some(out_dir) = &cargo[pkg].out_dir {\n                                 // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n                                 if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n                                     env.set(\"OUT_DIR\", out_dir);\n                                 }\n-                                if let Some(&extern_source_id) = extern_source_roots.get(out_dir) {\n-                                    extern_source.set_extern_path(&out_dir, extern_source_id);\n-                                }\n                             }\n                             let proc_macro = cargo[pkg]\n                                 .proc_macro_dylib_path\n@@ -431,7 +419,6 @@ impl ProjectWorkspace {\n                                 Some(CrateName::normalize_dashes(&cargo[pkg].name)),\n                                 cfg_options,\n                                 env,\n-                                extern_source,\n                                 proc_macro.clone(),\n                             );\n                             if cargo[tgt].kind == TargetKind::Lib {"}, {"sha": "68d04f3e32cac74870c29800172e61e084c5db96", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -38,7 +38,8 @@ ra_prof = { path = \"../ra_prof\" }\n ra_project_model = { path = \"../ra_project_model\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_vfs = \"0.6.0\"\n+vfs = { path = \"../vfs\" }\n+vfs-notify = { path = \"../vfs-notify\" }\n ra_cfg = { path = \"../ra_cfg\"}\n \n # This should only be used in CLI"}, {"sha": "65f90c83c04f791126f861920e5abcc82099cafe", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,5 +1,7 @@\n //! See `CargoTargetSpec`\n \n+use std::path::PathBuf;\n+\n use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, TargetKind};\n@@ -12,6 +14,7 @@ use crate::{global_state::GlobalStateSnapshot, Result};\n /// build/test/run the target.\n #[derive(Clone)]\n pub(crate) struct CargoTargetSpec {\n+    pub(crate) workspace_root: PathBuf,\n     pub(crate) package: String,\n     pub(crate) target: String,\n     pub(crate) target_kind: TargetKind,\n@@ -101,6 +104,7 @@ impl CargoTargetSpec {\n             None => return Ok(None),\n         };\n         let res = CargoTargetSpec {\n+            workspace_root: cargo_ws.workspace_root().to_path_buf(),\n             package: cargo_ws.package_flag(&cargo_ws[cargo_ws[target].package]),\n             target: cargo_ws[target].name.clone(),\n             target_kind: cargo_ws[target].kind,"}, {"sha": "4fe99ff6805a3c01c2d39046558c6214fded6bb3", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,6 +1,7 @@\n //! Benchmark operations like highlighting or goto definition.\n \n use std::{\n+    convert::TryFrom,\n     path::{Path, PathBuf},\n     str::FromStr,\n     sync::Arc,\n@@ -10,7 +11,7 @@ use std::{\n use anyhow::{format_err, Result};\n use ra_db::{\n     salsa::{Database, Durability},\n-    FileId, SourceDatabaseExt,\n+    AbsPathBuf, FileId,\n };\n use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CompletionConfig, FilePosition, LineCol};\n \n@@ -53,31 +54,17 @@ pub fn analysis_bench(\n \n     let start = Instant::now();\n     eprint!(\"loading: \");\n-    let (mut host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n-    let db = host.raw_database();\n+    let (mut host, vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     eprintln!(\"{:?}\\n\", start.elapsed());\n \n     let file_id = {\n         let path = match &what {\n             BenchWhat::Highlight { path } => path,\n             BenchWhat::Complete(pos) | BenchWhat::GotoDef(pos) => &pos.path,\n         };\n-        let path = std::env::current_dir()?.join(path).canonicalize()?;\n-        roots\n-            .iter()\n-            .find_map(|(source_root_id, project_root)| {\n-                if project_root.is_member() {\n-                    for file_id in db.source_root(*source_root_id).walk() {\n-                        let rel_path = db.file_relative_path(file_id);\n-                        let abs_path = rel_path.to_path(project_root.path());\n-                        if abs_path == path {\n-                            return Some(file_id);\n-                        }\n-                    }\n-                }\n-                None\n-            })\n-            .ok_or_else(|| format_err!(\"Can't find {}\", path.display()))?\n+        let path = AbsPathBuf::try_from(path.clone()).unwrap();\n+        let path = path.into();\n+        vfs.file_id(&path).ok_or_else(|| format_err!(\"Can't find {}\", path))?\n     };\n \n     match &what {\n@@ -149,7 +136,7 @@ fn do_work<F: Fn(&Analysis) -> T, T>(host: &mut AnalysisHost, file_id: FileId, w\n             let mut text = host.analysis().file_text(file_id).unwrap().to_string();\n             text.push_str(\"\\n/* Hello world */\\n\");\n             let mut change = AnalysisChange::new();\n-            change.change_file(file_id, Arc::new(text));\n+            change.change_file(file_id, Some(Arc::new(text)));\n             host.apply_change(change);\n         }\n         work(&host.analysis());"}, {"sha": "90868760b9b3d573834dac8d5ac697c59b85c7ad", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -28,34 +28,25 @@ pub fn analysis_stats(\n     with_proc_macro: bool,\n ) -> Result<()> {\n     let db_load_time = Instant::now();\n-    let (mut host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n+    let (mut host, vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     let db = host.raw_database();\n-    println!(\"Database loaded, {} roots, {:?}\", roots.len(), db_load_time.elapsed());\n+    println!(\"Database loaded {:?}\", db_load_time.elapsed());\n     let analysis_time = Instant::now();\n     let mut num_crates = 0;\n     let mut visited_modules = HashSet::new();\n     let mut visit_queue = Vec::new();\n \n-    let members =\n-        roots\n-            .into_iter()\n-            .filter_map(|(source_root_id, project_root)| {\n-                if with_deps || project_root.is_member() {\n-                    Some(source_root_id)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect::<HashSet<_>>();\n-\n     let mut krates = Crate::all(db);\n     if randomize {\n         krates.shuffle(&mut thread_rng());\n     }\n     for krate in krates {\n         let module = krate.root_module(db).expect(\"crate without root module\");\n         let file_id = module.definition_source(db).file_id;\n-        if members.contains(&db.file_source_root(file_id.original_file(db))) {\n+        let file_id = file_id.original_file(db);\n+        let source_root = db.file_source_root(file_id);\n+        let source_root = db.source_root(source_root);\n+        if !source_root.is_library || with_deps {\n             num_crates += 1;\n             visit_queue.push(module);\n         }\n@@ -128,7 +119,7 @@ pub fn analysis_stats(\n         if verbosity.is_verbose() {\n             let src = f.source(db);\n             let original_file = src.file_id.original_file(db);\n-            let path = db.file_relative_path(original_file);\n+            let path = vfs.file_path(original_file);\n             let syntax_range = src.value.syntax().text_range();\n             format_to!(msg, \" ({:?} {:?})\", path, syntax_range);\n         }\n@@ -196,7 +187,7 @@ pub fn analysis_stats(\n                         let root = db.parse_or_expand(src.file_id).unwrap();\n                         let node = src.map(|e| e.to_node(&root).syntax().clone());\n                         let original_range = original_range(db, node.as_ref());\n-                        let path = db.file_relative_path(original_range.file_id);\n+                        let path = vfs.file_path(original_range.file_id);\n                         let line_index =\n                             host.analysis().file_line_index(original_range.file_id).unwrap();\n                         let text_range = original_range.range;"}, {"sha": "82b3a8a53261b72d2caca96f98750c0f3f37e104", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -2,68 +2,57 @@\n //! code if any errors are found.\n \n use anyhow::anyhow;\n+use hir::Crate;\n use ra_db::SourceDatabaseExt;\n use ra_ide::Severity;\n use std::{collections::HashSet, path::Path};\n \n use crate::cli::{load_cargo::load_cargo, Result};\n-use hir::Semantics;\n \n pub fn diagnostics(\n     path: &Path,\n     load_output_dirs: bool,\n     with_proc_macro: bool,\n-    all: bool,\n+    _all: bool,\n ) -> Result<()> {\n-    let (host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n+    let (host, _vfs) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     let db = host.raw_database();\n     let analysis = host.analysis();\n-    let semantics = Semantics::new(db);\n-    let members = roots\n-        .into_iter()\n-        .filter_map(|(source_root_id, project_root)| {\n-            // filter out dependencies\n-            if project_root.is_member() {\n-                Some(source_root_id)\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<HashSet<_>>();\n \n     let mut found_error = false;\n     let mut visited_files = HashSet::new();\n-    for source_root_id in members {\n-        for file_id in db.source_root(source_root_id).walk() {\n-            // Filter out files which are not actually modules (unless `--all` flag is\n-            // passed). In the rust-analyzer repository this filters out the parser test files.\n-            if semantics.to_module_def(file_id).is_some() || all {\n-                if !visited_files.contains(&file_id) {\n-                    let crate_name = if let Some(module) = semantics.to_module_def(file_id) {\n-                        if let Some(name) = module.krate().display_name(db) {\n-                            format!(\"{}\", name)\n-                        } else {\n-                            String::from(\"unknown\")\n-                        }\n-                    } else {\n-                        String::from(\"unknown\")\n-                    };\n-                    println!(\n-                        \"processing crate: {}, module: {}\",\n-                        crate_name,\n-                        db.file_relative_path(file_id)\n-                    );\n-                    for diagnostic in analysis.diagnostics(file_id).unwrap() {\n-                        if matches!(diagnostic.severity, Severity::Error) {\n-                            found_error = true;\n-                        }\n \n-                        println!(\"{:?}\", diagnostic);\n-                    }\n+    let mut work = Vec::new();\n+    let krates = Crate::all(db);\n+    for krate in krates {\n+        let module = krate.root_module(db).expect(\"crate without root module\");\n+        let file_id = module.definition_source(db).file_id;\n+        let file_id = file_id.original_file(db);\n+        let source_root = db.file_source_root(file_id);\n+        let source_root = db.source_root(source_root);\n+        if !source_root.is_library {\n+            work.push(module);\n+        }\n+    }\n \n-                    visited_files.insert(file_id);\n+    for module in work {\n+        let file_id = module.definition_source(db).file_id.original_file(db);\n+        if !visited_files.contains(&file_id) {\n+            let crate_name = if let Some(name) = module.krate().display_name(db) {\n+                format!(\"{}\", name)\n+            } else {\n+                String::from(\"unknown\")\n+            };\n+            println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n+            for diagnostic in analysis.diagnostics(file_id).unwrap() {\n+                if matches!(diagnostic.severity, Severity::Error) {\n+                    found_error = true;\n                 }\n+\n+                println!(\"{:?}\", diagnostic);\n             }\n+\n+            visited_files.insert(file_id);\n         }\n     }\n "}, {"sha": "00bbbaf4078c494d03ff8259cc8fa048dc3bb973", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 53, "deletions": 113, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,32 +1,21 @@\n //! Loads a Cargo project into a static instance of analysis, without support\n //! for incorporating changes.\n-\n-use std::path::{Path, PathBuf};\n+use std::{convert::TryFrom, path::Path, sync::Arc};\n \n use anyhow::Result;\n use crossbeam_channel::{unbounded, Receiver};\n-use ra_db::{ExternSourceId, FileId, SourceRootId};\n+use ra_db::{AbsPathBuf, CrateGraph};\n use ra_ide::{AnalysisChange, AnalysisHost};\n-use ra_project_model::{\n-    CargoConfig, PackageRoot, ProcMacroClient, ProjectManifest, ProjectWorkspace,\n-};\n-use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use crate::vfs_glob::RustPackageFilterBuilder;\n+use ra_project_model::{CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace};\n+use vfs::loader::Handle;\n \n-fn vfs_file_to_id(f: ra_vfs::VfsFile) -> FileId {\n-    FileId(f.0)\n-}\n-fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n-    SourceRootId(r.0)\n-}\n+use crate::global_state::{ProjectFolders, SourceRootConfig};\n \n pub fn load_cargo(\n     root: &Path,\n     load_out_dirs_from_check: bool,\n     with_proc_macro: bool,\n-) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n+) -> Result<(AnalysisHost, vfs::Vfs)> {\n     let root = std::env::current_dir()?.join(root);\n     let root = ProjectManifest::discover_single(&root)?;\n     let ws = ProjectWorkspace::load(\n@@ -35,123 +24,74 @@ pub fn load_cargo(\n         true,\n     )?;\n \n-    let mut extern_dirs = FxHashSet::default();\n-\n     let (sender, receiver) = unbounded();\n-    let sender = Box::new(move |t| sender.send(t).unwrap());\n-\n-    let mut roots = Vec::new();\n-    let project_roots = ws.to_roots();\n-    for root in &project_roots {\n-        roots.push(RootEntry::new(\n-            root.path().to_owned(),\n-            RustPackageFilterBuilder::default().set_member(root.is_member()).into_vfs_filter(),\n-        ));\n-\n-        if let Some(out_dir) = root.out_dir() {\n-            extern_dirs.insert(out_dir.to_path_buf());\n-            roots.push(RootEntry::new(\n-                out_dir.to_owned(),\n-                RustPackageFilterBuilder::default().set_member(root.is_member()).into_vfs_filter(),\n-            ))\n-        }\n-    }\n-\n-    let (mut vfs, roots) = Vfs::new(roots, sender, Watch(false));\n-\n-    let source_roots = roots\n-        .into_iter()\n-        .map(|vfs_root| {\n-            let source_root_id = vfs_root_to_id(vfs_root);\n-            let project_root = project_roots\n-                .iter()\n-                .find(|it| it.path() == vfs.root2path(vfs_root))\n-                .unwrap()\n-                .clone();\n-            (source_root_id, project_root)\n-        })\n-        .collect::<FxHashMap<_, _>>();\n+    let mut vfs = vfs::Vfs::default();\n+    let mut loader = {\n+        let loader =\n+            vfs_notify::LoaderHandle::spawn(Box::new(move |msg| sender.send(msg).unwrap()));\n+        Box::new(loader)\n+    };\n \n-    let proc_macro_client = if !with_proc_macro {\n-        ProcMacroClient::dummy()\n-    } else {\n+    let proc_macro_client = if with_proc_macro {\n         let path = std::env::current_exe()?;\n         ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap()\n+    } else {\n+        ProcMacroClient::dummy()\n     };\n-    let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs, &proc_macro_client);\n-    Ok((host, source_roots))\n+\n+    let crate_graph = ws.to_crate_graph(None, &proc_macro_client, &mut |path: &Path| {\n+        let path = AbsPathBuf::try_from(path.to_path_buf()).unwrap();\n+        let contents = loader.load_sync(&path);\n+        let path = vfs::VfsPath::from(path);\n+        vfs.set_file_contents(path.clone(), contents);\n+        vfs.file_id(&path)\n+    });\n+\n+    let project_folders = ProjectFolders::new(&[ws]);\n+    loader.set_config(vfs::loader::Config { load: project_folders.load, watch: vec![] });\n+\n+    log::debug!(\"crate graph: {:?}\", crate_graph);\n+    let host = load(crate_graph, project_folders.source_root_config, &mut vfs, &receiver);\n+    Ok((host, vfs))\n }\n \n pub(crate) fn load(\n-    source_roots: &FxHashMap<SourceRootId, PackageRoot>,\n-    ws: ProjectWorkspace,\n-    vfs: &mut Vfs,\n-    receiver: Receiver<VfsTask>,\n-    extern_dirs: FxHashSet<PathBuf>,\n-    proc_macro_client: &ProcMacroClient,\n+    crate_graph: CrateGraph,\n+    source_root_config: SourceRootConfig,\n+    vfs: &mut vfs::Vfs,\n+    receiver: &Receiver<vfs::loader::Message>,\n ) -> AnalysisHost {\n     let lru_cap = std::env::var(\"RA_LRU_CAP\").ok().and_then(|it| it.parse::<usize>().ok());\n     let mut host = AnalysisHost::new(lru_cap);\n     let mut analysis_change = AnalysisChange::new();\n \n     // wait until Vfs has loaded all roots\n-    let mut roots_loaded = FxHashSet::default();\n-    let mut extern_source_roots = FxHashMap::default();\n     for task in receiver {\n-        vfs.handle_task(task);\n-        let mut done = false;\n-        for change in vfs.commit_changes() {\n-            match change {\n-                VfsChange::AddRoot { root, files } => {\n-                    let source_root_id = vfs_root_to_id(root);\n-                    let is_local = source_roots[&source_root_id].is_member();\n-                    log::debug!(\n-                        \"loaded source root {:?} with path {:?}\",\n-                        source_root_id,\n-                        vfs.root2path(root)\n-                    );\n-                    analysis_change.add_root(source_root_id, is_local);\n-\n-                    let vfs_root_path = vfs.root2path(root);\n-                    if extern_dirs.contains(&vfs_root_path) {\n-                        extern_source_roots.insert(vfs_root_path, ExternSourceId(root.0));\n-                    }\n-\n-                    let mut file_map = FxHashMap::default();\n-                    for (vfs_file, path, text) in files {\n-                        let file_id = vfs_file_to_id(vfs_file);\n-                        analysis_change.add_file(source_root_id, file_id, path.clone(), text);\n-                        file_map.insert(path, file_id);\n-                    }\n-                    roots_loaded.insert(source_root_id);\n-                    if roots_loaded.len() == vfs.n_roots() {\n-                        done = true;\n-                    }\n-                }\n-                VfsChange::AddFile { root, file, path, text } => {\n-                    let source_root_id = vfs_root_to_id(root);\n-                    let file_id = vfs_file_to_id(file);\n-                    analysis_change.add_file(source_root_id, file_id, path, text);\n+        match task {\n+            vfs::loader::Message::Progress { n_entries_done, n_entries_total } => {\n+                if n_entries_done == n_entries_total {\n+                    break;\n                 }\n-                VfsChange::RemoveFile { .. } | VfsChange::ChangeFile { .. } => {\n-                    // We just need the first scan, so just ignore these\n+            }\n+            vfs::loader::Message::Loaded { files } => {\n+                for (path, contents) in files {\n+                    vfs.set_file_contents(path.into(), contents)\n                 }\n             }\n         }\n-        if done {\n-            break;\n+    }\n+    let changes = vfs.take_changes();\n+    for file in changes {\n+        if file.exists() {\n+            let contents = vfs.file_contents(file.file_id).to_vec();\n+            if let Ok(text) = String::from_utf8(contents) {\n+                analysis_change.change_file(file.file_id, Some(Arc::new(text)))\n+            }\n         }\n     }\n+    let source_roots = source_root_config.partition(&vfs);\n+    analysis_change.set_roots(source_roots);\n \n-    let crate_graph =\n-        ws.to_crate_graph(None, &extern_source_roots, proc_macro_client, &mut |path: &Path| {\n-            // Some path from metadata will be non canonicalized, e.g. /foo/../bar/lib.rs\n-            let path = path.canonicalize().ok()?;\n-            let vfs_file = vfs.load(&path);\n-            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n-            vfs_file.map(vfs_file_to_id)\n-        });\n-    log::debug!(\"crate graph: {:?}\", crate_graph);\n     analysis_change.set_crate_graph(crate_graph);\n \n     host.apply_change(analysis_change);\n@@ -167,7 +107,7 @@ mod tests {\n     #[test]\n     fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n-        let (host, _roots) = load_cargo(path, false, false).unwrap();\n+        let (host, _vfs) = load_cargo(path, false, false).unwrap();\n         let n_crates = Crate::all(host.raw_database()).len();\n         // RA has quite a few crates, but the exact count doesn't matter\n         assert!(n_crates > 20);"}, {"sha": "40d440c67f733a6ec71cf56aeb355314884a5adc", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -1,10 +1,22 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n+use std::convert::TryFrom;\n+\n use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide::{LineCol, LineIndex};\n use ra_syntax::{TextRange, TextSize};\n+use vfs::AbsPathBuf;\n \n use crate::{global_state::GlobalStateSnapshot, Result};\n \n+pub(crate) fn abs_path(url: &lsp_types::Url) -> Result<AbsPathBuf> {\n+    let path = url.to_file_path().map_err(|()| \"url is not a file\")?;\n+    Ok(AbsPathBuf::try_from(path).unwrap())\n+}\n+\n+pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n+    abs_path(url).map(vfs::VfsPath::from)\n+}\n+\n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n     let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n     line_index.offset(line_col)"}, {"sha": "e2ddb79332a546880975f874df0ca9e7996b9d72", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 165, "deletions": 116, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -3,30 +3,28 @@\n //!\n //! Each tick provides an immutable snapshot of the state as `WorldSnapshot`.\n \n-use std::{\n-    path::{Path, PathBuf},\n-    sync::Arc,\n-};\n+use std::{convert::TryFrom, path::Path, sync::Arc};\n \n use crossbeam_channel::{unbounded, Receiver};\n use lsp_types::Url;\n use parking_lot::RwLock;\n+use ra_db::{CrateId, SourceRoot, VfsPath};\n use ra_flycheck::{Flycheck, FlycheckConfig};\n-use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, SourceRootId};\n+use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId};\n use ra_project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n-use ra_vfs::{LineEndings, RootEntry, Vfs, VfsChange, VfsFile, VfsTask, Watch};\n use stdx::format_to;\n+use vfs::{file_set::FileSetConfig, loader::Handle, AbsPathBuf};\n \n use crate::{\n     config::{Config, FilesWatcher},\n     diagnostics::{CheckFixes, DiagnosticCollection},\n+    from_proto,\n+    line_endings::LineEndings,\n     main_loop::request_metrics::{LatestRequests, RequestMetrics},\n     to_proto::url_from_abs_path,\n-    vfs_glob::{Glob, RustPackageFilterBuilder},\n-    LspError, Result,\n+    Result,\n };\n-use ra_db::{CrateId, ExternSourceId};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n@@ -50,15 +48,16 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n #[derive(Debug)]\n pub struct GlobalState {\n     pub config: Config,\n-    pub local_roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n-    pub vfs: Arc<RwLock<Vfs>>,\n-    pub task_receiver: Receiver<VfsTask>,\n+    pub loader: Box<dyn vfs::loader::Handle>,\n+    pub task_receiver: Receiver<vfs::loader::Message>,\n     pub flycheck: Option<Flycheck>,\n     pub diagnostics: DiagnosticCollection,\n     pub proc_macro_client: ProcMacroClient,\n+    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n+    source_root_config: SourceRootConfig,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -68,62 +67,21 @@ pub struct GlobalStateSnapshot {\n     pub analysis: Analysis,\n     pub check_fixes: CheckFixes,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n-    vfs: Arc<RwLock<Vfs>>,\n+    vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n }\n \n impl GlobalState {\n     pub fn new(\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n-        exclude_globs: &[Glob],\n         config: Config,\n     ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n-        let mut extern_dirs: FxHashSet<PathBuf> = FxHashSet::default();\n-\n-        let mut local_roots = Vec::new();\n-        let roots: Vec<_> = {\n-            let create_filter = |is_member| {\n-                RustPackageFilterBuilder::default()\n-                    .set_member(is_member)\n-                    .exclude(exclude_globs.iter().cloned())\n-                    .into_vfs_filter()\n-            };\n-            let mut roots = Vec::new();\n-            for root in workspaces.iter().flat_map(ProjectWorkspace::to_roots) {\n-                let path = root.path().to_owned();\n-                if root.is_member() {\n-                    local_roots.push(path.clone());\n-                }\n-                roots.push(RootEntry::new(path, create_filter(root.is_member())));\n-                if let Some(out_dir) = root.out_dir() {\n-                    extern_dirs.insert(out_dir.to_path_buf());\n-                    roots.push(RootEntry::new(\n-                        out_dir.to_path_buf(),\n-                        create_filter(root.is_member()),\n-                    ))\n-                }\n-            }\n-            roots\n-        };\n-\n-        let (task_sender, task_receiver) = unbounded();\n-        let task_sender = Box::new(move |t| task_sender.send(t).unwrap());\n-        let watch = Watch(matches!(config.files.watcher, FilesWatcher::Notify));\n-        let (mut vfs, vfs_roots) = Vfs::new(roots, task_sender, watch);\n+        let project_folders = ProjectFolders::new(&workspaces);\n \n-        let mut extern_source_roots = FxHashMap::default();\n-        for r in vfs_roots {\n-            let vfs_root_path = vfs.root2path(r);\n-            let is_local = local_roots.iter().any(|it| vfs_root_path.starts_with(it));\n-            change.add_root(SourceRootId(r.0), is_local);\n-\n-            // FIXME: add path2root in vfs to simpily this logic\n-            if extern_dirs.contains(&vfs_root_path) {\n-                extern_source_roots.insert(vfs_root_path, ExternSourceId(r.0));\n-            }\n-        }\n+        let (task_sender, task_receiver) = unbounded::<vfs::loader::Message>();\n+        let mut vfs = vfs::Vfs::default();\n \n         let proc_macro_client = match &config.proc_macro_srv {\n             None => ProcMacroClient::dummy(),\n@@ -140,18 +98,30 @@ impl GlobalState {\n             },\n         };\n \n+        let mut loader = {\n+            let loader = vfs_notify::LoaderHandle::spawn(Box::new(move |msg| {\n+                task_sender.send(msg).unwrap()\n+            }));\n+            Box::new(loader)\n+        };\n+        let watch = match config.files.watcher {\n+            FilesWatcher::Client => vec![],\n+            FilesWatcher::Notify => project_folders.watch,\n+        };\n+        loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n+\n         // Create crate graph from all the workspaces\n         let mut crate_graph = CrateGraph::default();\n         let mut load = |path: &Path| {\n-            // Some path from metadata will be non canonicalized, e.g. /foo/../bar/lib.rs\n-            let path = path.canonicalize().ok()?;\n-            let vfs_file = vfs.load(&path);\n-            vfs_file.map(|f| FileId(f.0))\n+            let path = AbsPathBuf::try_from(path.to_path_buf()).ok()?;\n+            let contents = loader.load_sync(&path);\n+            let path = vfs::VfsPath::from(path);\n+            vfs.set_file_contents(path.clone(), contents);\n+            vfs.file_id(&path)\n         };\n         for ws in workspaces.iter() {\n             crate_graph.extend(ws.to_crate_graph(\n                 config.cargo.target.as_deref(),\n-                &extern_source_roots,\n                 &proc_macro_client,\n                 &mut load,\n             ));\n@@ -162,18 +132,21 @@ impl GlobalState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n-        GlobalState {\n+        let mut res = GlobalState {\n             config,\n-            local_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n-            vfs: Arc::new(RwLock::new(vfs)),\n+            loader,\n+            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n             task_receiver,\n             latest_requests: Default::default(),\n             flycheck,\n             diagnostics: Default::default(),\n             proc_macro_client,\n-        }\n+            source_root_config: project_folders.source_root_config,\n+        };\n+        res.process_changes();\n+        res\n     }\n \n     pub fn update_configuration(&mut self, config: Config) {\n@@ -186,33 +159,40 @@ impl GlobalState {\n         self.config = config;\n     }\n \n-    /// Returns a vec of libraries\n-    /// FIXME: better API here\n-    pub fn process_changes(&mut self, roots_scanned: &mut usize) -> bool {\n-        let changes = self.vfs.write().commit_changes();\n-        if changes.is_empty() {\n-            return false;\n-        }\n-        let mut change = AnalysisChange::new();\n-        for c in changes {\n-            match c {\n-                VfsChange::AddRoot { root, files } => {\n-                    *roots_scanned += 1;\n-                    for (file, path, text) in files {\n-                        change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+    pub fn process_changes(&mut self) -> bool {\n+        let change = {\n+            let mut change = AnalysisChange::new();\n+            let (vfs, line_endings_map) = &mut *self.vfs.write();\n+            let changed_files = vfs.take_changes();\n+            if changed_files.is_empty() {\n+                return false;\n+            }\n+\n+            let fs_op = changed_files.iter().any(|it| it.is_created_or_deleted());\n+            if fs_op {\n+                let roots = self.source_root_config.partition(&vfs);\n+                change.set_roots(roots)\n+            }\n+\n+            for file in changed_files {\n+                let text = if file.exists() {\n+                    let bytes = vfs.file_contents(file.file_id).to_vec();\n+                    match String::from_utf8(bytes).ok() {\n+                        Some(text) => {\n+                            let (text, line_endings) = LineEndings::normalize(text);\n+                            line_endings_map.insert(file.file_id, line_endings);\n+                            Some(Arc::new(text))\n+                        }\n+                        None => None,\n                     }\n-                }\n-                VfsChange::AddFile { root, file, path, text } => {\n-                    change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n-                }\n-                VfsChange::RemoveFile { root, file, path } => {\n-                    change.remove_file(SourceRootId(root.0), FileId(file.0), path)\n-                }\n-                VfsChange::ChangeFile { file, text } => {\n-                    change.change_file(FileId(file.0), text);\n-                }\n+                } else {\n+                    None\n+                };\n+                change.change_file(file.file_id, text);\n             }\n-        }\n+            change\n+        };\n+\n         self.analysis_host.apply_change(change);\n         true\n     }\n@@ -242,35 +222,31 @@ impl GlobalState {\n }\n \n impl GlobalStateSnapshot {\n-    pub fn analysis(&self) -> &Analysis {\n+    pub(crate) fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }\n \n-    pub fn url_to_file_id(&self, url: &Url) -> Result<FileId> {\n-        let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-        let file = self.vfs.read().path2file(&path).ok_or_else(|| {\n-            // Show warning as this file is outside current workspace\n-            // FIXME: just handle such files, and remove `LspError::UNKNOWN_FILE`.\n-            LspError {\n-                code: LspError::UNKNOWN_FILE,\n-                message: \"Rust file outside current workspace is not supported yet.\".to_string(),\n-            }\n-        })?;\n-        Ok(FileId(file.0))\n+    pub(crate) fn url_to_file_id(&self, url: &Url) -> Result<FileId> {\n+        let path = from_proto::abs_path(url)?;\n+        let path = path.into();\n+        let res =\n+            self.vfs.read().0.file_id(&path).ok_or_else(|| format!(\"file not found: {}\", path))?;\n+        Ok(res)\n     }\n \n-    pub fn file_id_to_url(&self, id: FileId) -> Url {\n-        file_id_to_url(&self.vfs.read(), id)\n+    pub(crate) fn file_id_to_url(&self, id: FileId) -> Url {\n+        file_id_to_url(&self.vfs.read().0, id)\n     }\n \n-    pub fn file_line_endings(&self, id: FileId) -> LineEndings {\n-        self.vfs.read().file_line_endings(VfsFile(id.0))\n+    pub(crate) fn file_line_endings(&self, id: FileId) -> LineEndings {\n+        self.vfs.read().1[&id]\n     }\n \n     pub fn anchored_path(&self, file_id: FileId, path: &str) -> Url {\n-        let mut base = self.vfs.read().file2path(VfsFile(file_id.0));\n+        let mut base = self.vfs.read().0.file_path(file_id);\n         base.pop();\n         let path = base.join(path);\n+        let path = path.as_path().unwrap();\n         url_from_abs_path(&path)\n     }\n \n@@ -279,7 +255,8 @@ impl GlobalStateSnapshot {\n         crate_id: CrateId,\n     ) -> Option<(&CargoWorkspace, Target)> {\n         let file_id = self.analysis().crate_root(crate_id).ok()?;\n-        let path = self.vfs.read().file2path(VfsFile(file_id.0));\n+        let path = self.vfs.read().0.file_path(file_id);\n+        let path = path.as_path()?;\n         self.workspaces.iter().find_map(|ws| match ws {\n             ProjectWorkspace::Cargo { cargo, .. } => {\n                 cargo.target_by_root(&path).map(|it| (cargo, it))\n@@ -307,14 +284,86 @@ impl GlobalStateSnapshot {\n         );\n         buf\n     }\n+}\n+\n+pub(crate) fn file_id_to_url(vfs: &vfs::Vfs, id: FileId) -> Url {\n+    let path = vfs.file_path(id);\n+    let path = path.as_path().unwrap();\n+    url_from_abs_path(&path)\n+}\n+\n+#[derive(Default)]\n+pub(crate) struct ProjectFolders {\n+    pub(crate) load: Vec<vfs::loader::Entry>,\n+    pub(crate) watch: Vec<usize>,\n+    pub(crate) source_root_config: SourceRootConfig,\n+}\n+\n+impl ProjectFolders {\n+    pub(crate) fn new(workspaces: &[ProjectWorkspace]) -> ProjectFolders {\n+        let mut res = ProjectFolders::default();\n+        let mut fsc = FileSetConfig::builder();\n+        let mut local_filesets = vec![];\n+\n+        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n+            let path = root.path().to_owned();\n+\n+            let mut file_set_roots: Vec<VfsPath> = vec![];\n+\n+            let path = AbsPathBuf::try_from(path).unwrap();\n+            let entry = if root.is_member() {\n+                vfs::loader::Entry::local_cargo_package(path.clone())\n+            } else {\n+                vfs::loader::Entry::cargo_package_dependency(path.clone())\n+            };\n+            res.load.push(entry);\n+            if root.is_member() {\n+                res.watch.push(res.load.len() - 1);\n+            }\n+\n+            if let Some(out_dir) = root.out_dir() {\n+                let out_dir = AbsPathBuf::try_from(out_dir.to_path_buf()).unwrap();\n+                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n+                if root.is_member() {\n+                    res.watch.push(res.load.len() - 1);\n+                }\n+                file_set_roots.push(out_dir.into());\n+            }\n+            file_set_roots.push(path.into());\n+\n+            if root.is_member() {\n+                local_filesets.push(fsc.len());\n+            }\n+            fsc.add_file_set(file_set_roots)\n+        }\n+\n+        let fsc = fsc.build();\n+        res.source_root_config = SourceRootConfig { fsc, local_filesets };\n \n-    pub fn workspace_root_for(&self, file_id: FileId) -> Option<&Path> {\n-        let path = self.vfs.read().file2path(VfsFile(file_id.0));\n-        self.workspaces.iter().find_map(|ws| ws.workspace_root_for(&path))\n+        res\n     }\n }\n \n-pub(crate) fn file_id_to_url(vfs: &Vfs, id: FileId) -> Url {\n-    let path = vfs.file2path(VfsFile(id.0));\n-    url_from_abs_path(&path)\n+#[derive(Default, Debug)]\n+pub(crate) struct SourceRootConfig {\n+    pub(crate) fsc: FileSetConfig,\n+    pub(crate) local_filesets: Vec<usize>,\n+}\n+\n+impl SourceRootConfig {\n+    pub fn partition(&self, vfs: &vfs::Vfs) -> Vec<SourceRoot> {\n+        self.fsc\n+            .partition(vfs)\n+            .into_iter()\n+            .enumerate()\n+            .map(|(idx, file_set)| {\n+                let is_local = self.local_filesets.contains(&idx);\n+                if is_local {\n+                    SourceRoot::new_local(file_set)\n+                } else {\n+                    SourceRoot::new_library(file_set)\n+                }\n+            })\n+            .collect()\n+    }\n }"}, {"sha": "b38067079fc5fb7e889e09e74b53f2ae334cf659", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -17,7 +17,6 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-mod vfs_glob;\n mod caps;\n mod cargo_target_spec;\n mod to_proto;\n@@ -29,6 +28,7 @@ pub mod config;\n mod global_state;\n mod diagnostics;\n mod semantic_tokens;\n+mod line_endings;\n \n use serde::de::DeserializeOwned;\n "}, {"sha": "7e6db954e47ec19885468d17ea14a2c3af2245ea", "filename": "crates/rust-analyzer/src/line_endings.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fline_endings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fline_endings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fline_endings.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -0,0 +1,64 @@\n+//! We maintain invariant that all internal strings use `\\n` as line separator.\n+//! This module does line ending conversion and detection (so that we can\n+//! convert back to `\\r\\n` on the way out).\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) enum LineEndings {\n+    Unix,\n+    Dos,\n+}\n+\n+impl LineEndings {\n+    /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n+    pub(crate) fn normalize(src: String) -> (String, LineEndings) {\n+        if !src.as_bytes().contains(&b'\\r') {\n+            return (src, LineEndings::Unix);\n+        }\n+\n+        // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n+        // While we *can* call `as_mut_vec` and do surgery on the live string\n+        // directly, let's rather steal the contents of `src`. This makes the code\n+        // safe even if a panic occurs.\n+\n+        let mut buf = src.into_bytes();\n+        let mut gap_len = 0;\n+        let mut tail = buf.as_mut_slice();\n+        loop {\n+            let idx = match find_crlf(&tail[gap_len..]) {\n+                None => tail.len(),\n+                Some(idx) => idx + gap_len,\n+            };\n+            tail.copy_within(gap_len..idx, 0);\n+            tail = &mut tail[idx - gap_len..];\n+            if tail.len() == gap_len {\n+                break;\n+            }\n+            gap_len += 1;\n+        }\n+\n+        // Account for removed `\\r`.\n+        // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n+        let new_len = buf.len() - gap_len;\n+        let src = unsafe {\n+            buf.set_len(new_len);\n+            String::from_utf8_unchecked(buf)\n+        };\n+        return (src, LineEndings::Dos);\n+\n+        fn find_crlf(src: &[u8]) -> Option<usize> {\n+            let mut search_idx = 0;\n+            while let Some(idx) = find_cr(&src[search_idx..]) {\n+                if src[search_idx..].get(idx + 1) != Some(&b'\\n') {\n+                    search_idx += idx + 1;\n+                    continue;\n+                }\n+                return Some(search_idx + idx);\n+            }\n+            None\n+        }\n+\n+        fn find_cr(src: &[u8]) -> Option<usize> {\n+            src.iter().enumerate().find_map(|(idx, &b)| if b == b'\\r' { Some(idx) } else { None })\n+        }\n+    }\n+}"}, {"sha": "b9d2968562497f772f3b7dc05431458e25089e2f", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 166, "deletions": 164, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -2,11 +2,9 @@\n //! requests/replies and notifications back to the client.\n \n mod handlers;\n-mod subscriptions;\n pub(crate) mod request_metrics;\n \n use std::{\n-    borrow::Cow,\n     env,\n     error::Error,\n     fmt,\n@@ -20,16 +18,12 @@ use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use lsp_server::{\n     Connection, ErrorCode, Message, Notification, ReqQueue, Request, RequestId, Response,\n };\n-use lsp_types::{\n-    request::Request as _, DidChangeTextDocumentParams, NumberOrString,\n-    TextDocumentContentChangeEvent, WorkDoneProgress, WorkDoneProgressBegin,\n-    WorkDoneProgressCreateParams, WorkDoneProgressEnd, WorkDoneProgressReport,\n-};\n-use ra_flycheck::{CheckTask, Status};\n+use lsp_types::{request::Request as _, NumberOrString, TextDocumentContentChangeEvent};\n+use ra_flycheck::CheckTask;\n use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use ra_vfs::VfsTask;\n+use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n@@ -39,9 +33,10 @@ use crate::{\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot},\n     lsp_ext,\n-    main_loop::{request_metrics::RequestMetrics, subscriptions::Subscriptions},\n+    main_loop::request_metrics::RequestMetrics,\n     Result,\n };\n+use ra_db::VfsPath;\n \n #[derive(Debug)]\n pub struct LspError {\n@@ -128,13 +123,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 .collect::<Vec<_>>()\n         };\n \n-        let globs = config\n-            .files\n-            .exclude\n-            .iter()\n-            .map(|glob| crate::vfs_glob::Glob::new(glob))\n-            .collect::<std::result::Result<Vec<_>, _>>()?;\n-\n         if let FilesWatcher::Client = config.files.watcher {\n             let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n@@ -159,11 +147,9 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        GlobalState::new(workspaces, config.lru_capacity, &globs, config)\n+        GlobalState::new(workspaces, config.lru_capacity, config)\n     };\n \n-    loop_state.roots_total = global_state.vfs.read().n_roots();\n-\n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n \n@@ -192,7 +178,9 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                     break;\n                 };\n             }\n+            assert!(!global_state.vfs.read().0.has_changes());\n             loop_turn(&pool, &task_sender, &connection, &mut global_state, &mut loop_state, event)?;\n+            assert!(!global_state.vfs.read().0.has_changes());\n         }\n     }\n     global_state.analysis_host.request_cancellation();\n@@ -222,7 +210,7 @@ enum Task {\n enum Event {\n     Msg(Message),\n     Task(Task),\n-    Vfs(VfsTask),\n+    Vfs(vfs::loader::Message),\n     CheckWatcher(CheckTask),\n }\n \n@@ -270,11 +258,20 @@ type Incoming = lsp_server::Incoming<(&'static str, Instant)>;\n #[derive(Default)]\n struct LoopState {\n     req_queue: ReqQueue<(&'static str, Instant), ReqHandler>,\n-    subscriptions: Subscriptions,\n-    workspace_loaded: bool,\n-    roots_progress_reported: Option<usize>,\n-    roots_scanned: usize,\n-    roots_total: usize,\n+    mem_docs: FxHashSet<VfsPath>,\n+    status: Status,\n+}\n+\n+#[derive(Eq, PartialEq)]\n+enum Status {\n+    Loading,\n+    Ready,\n+}\n+\n+impl Default for Status {\n+    fn default() -> Self {\n+        Status::Loading\n+    }\n }\n \n fn loop_turn(\n@@ -295,14 +292,36 @@ fn loop_turn(\n         log::info!(\"queued count = {}\", queue_count);\n     }\n \n+    let mut became_ready = false;\n     match event {\n         Event::Task(task) => {\n             on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, global_state);\n             global_state.maybe_collect_garbage();\n         }\n-        Event::Vfs(task) => {\n-            global_state.vfs.write().handle_task(task);\n-        }\n+        Event::Vfs(task) => match task {\n+            vfs::loader::Message::Loaded { files } => {\n+                let vfs = &mut global_state.vfs.write().0;\n+                for (path, contents) in files {\n+                    let path = VfsPath::from(path);\n+                    if !loop_state.mem_docs.contains(&path) {\n+                        vfs.set_file_contents(path, contents)\n+                    }\n+                }\n+            }\n+            vfs::loader::Message::Progress { n_entries_total, n_entries_done } => {\n+                if n_entries_done == n_entries_done {\n+                    loop_state.status = Status::Ready;\n+                    became_ready = true;\n+                }\n+                report_progress(\n+                    loop_state,\n+                    &connection.sender,\n+                    n_entries_done,\n+                    n_entries_total,\n+                    \"roots scanned\",\n+                )\n+            }\n+        },\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n@@ -324,32 +343,29 @@ fn loop_turn(\n         },\n     };\n \n-    let mut state_changed = global_state.process_changes(&mut loop_state.roots_scanned);\n+    let state_changed = global_state.process_changes();\n \n-    let show_progress =\n-        !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n-\n-    if !loop_state.workspace_loaded && loop_state.roots_scanned == loop_state.roots_total {\n-        state_changed = true;\n-        loop_state.workspace_loaded = true;\n+    if became_ready {\n         if let Some(flycheck) = &global_state.flycheck {\n             flycheck.update();\n         }\n     }\n \n-    if show_progress {\n-        send_startup_progress(&connection.sender, loop_state);\n-    }\n+    if loop_state.status == Status::Ready && (state_changed || became_ready) {\n+        let subscriptions = loop_state\n+            .mem_docs\n+            .iter()\n+            .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n+            .collect::<Vec<_>>();\n \n-    if state_changed && loop_state.workspace_loaded {\n         update_file_notifications_on_threadpool(\n             pool,\n             global_state.snapshot(),\n             task_sender.clone(),\n-            loop_state.subscriptions.subscriptions(),\n+            subscriptions.clone(),\n         );\n         pool.execute({\n-            let subs = loop_state.subscriptions.subscriptions();\n+            let subs = subscriptions;\n             let snap = global_state.snapshot();\n             move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n@@ -465,7 +481,7 @@ fn on_request(\n \n fn on_notification(\n     msg_sender: &Sender<Message>,\n-    state: &mut GlobalState,\n+    global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n@@ -484,56 +500,64 @@ fn on_notification(\n     };\n     let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n         Ok(params) => {\n-            let uri = params.text_document.uri;\n-            let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-            if let Some(file_id) =\n-                state.vfs.write().add_file_overlay(&path, params.text_document.text)\n-            {\n-                loop_state.subscriptions.add_sub(FileId(file_id.0));\n+            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                if !loop_state.mem_docs.insert(path.clone()) {\n+                    log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n+                }\n+                global_state\n+                    .vfs\n+                    .write()\n+                    .0\n+                    .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n             }\n             return Ok(());\n         }\n         Err(not) => not,\n     };\n     let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n         Ok(params) => {\n-            let DidChangeTextDocumentParams { text_document, content_changes } = params;\n-            let world = state.snapshot();\n-            let file_id = from_proto::file_id(&world, &text_document.uri)?;\n-            let line_index = world.analysis().file_line_index(file_id)?;\n-            let uri = text_document.uri;\n-            let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-            state.vfs.write().change_file_overlay(&path, |old_text| {\n-                apply_document_changes(old_text, Cow::Borrowed(&line_index), content_changes);\n-            });\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n-        Ok(_params) => {\n-            if let Some(flycheck) = &state.flycheck {\n-                flycheck.update();\n+            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                assert!(loop_state.mem_docs.contains(&path));\n+                let vfs = &mut global_state.vfs.write().0;\n+                let file_id = vfs.file_id(&path).unwrap();\n+                let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n+                apply_document_changes(&mut text, params.content_changes);\n+                vfs.set_file_contents(path, Some(text.into_bytes()))\n             }\n             return Ok(());\n         }\n         Err(not) => not,\n     };\n     let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n         Ok(params) => {\n-            let uri = params.text_document.uri;\n-            let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-            if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n-                loop_state.subscriptions.remove_sub(FileId(file_id.0));\n+            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                if !loop_state.mem_docs.remove(&path) {\n+                    log::error!(\"orphan DidCloseTextDocument: {}\", path)\n+                }\n+                if let Some(path) = path.as_path() {\n+                    global_state.loader.invalidate(path.to_path_buf());\n+                }\n             }\n-            let params =\n-                lsp_types::PublishDiagnosticsParams { uri, diagnostics: Vec::new(), version: None };\n+            let params = lsp_types::PublishDiagnosticsParams {\n+                uri: params.text_document.uri,\n+                diagnostics: Vec::new(),\n+                version: None,\n+            };\n             let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n             msg_sender.send(not.into()).unwrap();\n             return Ok(());\n         }\n         Err(not) => not,\n     };\n+    let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n+        Ok(_params) => {\n+            if let Some(flycheck) = &global_state.flycheck {\n+                flycheck.update();\n+            }\n+            return Ok(());\n+        }\n+        Err(not) => not,\n+    };\n     let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n         Ok(_) => {\n             // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n@@ -575,11 +599,10 @@ fn on_notification(\n     };\n     let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n         Ok(params) => {\n-            let mut vfs = state.vfs.write();\n             for change in params.changes {\n-                let uri = change.uri;\n-                let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-                vfs.notify_changed(path)\n+                if let Ok(path) = from_proto::abs_path(&change.uri) {\n+                    global_state.loader.invalidate(path)\n+                }\n             }\n             return Ok(());\n         }\n@@ -594,9 +617,9 @@ fn on_notification(\n \n fn apply_document_changes(\n     old_text: &mut String,\n-    mut line_index: Cow<'_, LineIndex>,\n     content_changes: Vec<TextDocumentContentChangeEvent>,\n ) {\n+    let mut line_index = LineIndex::new(old_text);\n     // The changes we got must be applied sequentially, but can cross lines so we\n     // have to keep our line index updated.\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n@@ -621,7 +644,7 @@ fn apply_document_changes(\n         match change.range {\n             Some(range) => {\n                 if !index_valid.covers(range.end.line) {\n-                    line_index = Cow::Owned(LineIndex::new(&old_text));\n+                    line_index = LineIndex::new(&old_text);\n                 }\n                 index_valid = IndexValid::UpToLineExclusive(range.start.line);\n                 let range = from_proto::text_range(&line_index, range);\n@@ -652,18 +675,11 @@ fn on_check_task(\n                 &workspace_root,\n             );\n             for diag in diagnostics {\n-                let path = diag\n-                    .location\n-                    .uri\n-                    .to_file_path()\n-                    .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n-                let file_id = match global_state.vfs.read().path2file(&path) {\n+                let path = from_proto::vfs_path(&diag.location.uri)?;\n+                let file_id = match global_state.vfs.read().0.file_id(&path) {\n                     Some(file) => FileId(file.0),\n                     None => {\n-                        log::error!(\n-                            \"File with cargo diagnostic not found in VFS: {}\",\n-                            path.display()\n-                        );\n+                        log::error!(\"File with cargo diagnostic not found in VFS: {}\", path);\n                         return Ok(());\n                     }\n                 };\n@@ -679,22 +695,22 @@ fn on_check_task(\n         CheckTask::Status(status) => {\n             if global_state.config.client_caps.work_done_progress {\n                 let progress = match status {\n-                    Status::Being => {\n+                    ra_flycheck::Status::Being => {\n                         lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n                             title: \"Running `cargo check`\".to_string(),\n                             cancellable: Some(false),\n                             message: None,\n                             percentage: None,\n                         })\n                     }\n-                    Status::Progress(target) => {\n+                    ra_flycheck::Status::Progress(target) => {\n                         lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n                             cancellable: Some(false),\n                             message: Some(target),\n                             percentage: None,\n                         })\n                     }\n-                    Status::End => {\n+                    ra_flycheck::Status::End => {\n                         lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd {\n                             message: None,\n                         })\n@@ -720,65 +736,54 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n-        let url = file_id_to_url(&state.vfs.read(), file_id);\n+        let url = file_id_to_url(&state.vfs.read().0, file_id);\n         let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n         let params = lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n         let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n         msg_sender.send(not.into()).unwrap();\n     }\n }\n \n-fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n-    let total: usize = loop_state.roots_total;\n-    let prev = loop_state.roots_progress_reported;\n-    let progress = loop_state.roots_scanned;\n-    loop_state.roots_progress_reported = Some(progress);\n-\n-    match (prev, loop_state.workspace_loaded) {\n-        (None, false) => {\n-            let request = loop_state.req_queue.outgoing.register(\n-                lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n-                WorkDoneProgressCreateParams {\n-                    token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n-                },\n-                DO_NOTHING,\n-            );\n-            sender.send(request.into()).unwrap();\n-            send_startup_progress_notif(\n-                sender,\n-                WorkDoneProgress::Begin(WorkDoneProgressBegin {\n-                    title: \"rust-analyzer\".into(),\n-                    cancellable: None,\n-                    message: Some(format!(\"{}/{} packages\", progress, total)),\n-                    percentage: Some(100.0 * progress as f64 / total as f64),\n-                }),\n-            );\n-        }\n-        (Some(prev), false) if progress != prev => send_startup_progress_notif(\n-            sender,\n-            WorkDoneProgress::Report(WorkDoneProgressReport {\n-                cancellable: None,\n-                message: Some(format!(\"{}/{} packages\", progress, total)),\n-                percentage: Some(100.0 * progress as f64 / total as f64),\n-            }),\n-        ),\n-        (_, true) => send_startup_progress_notif(\n-            sender,\n-            WorkDoneProgress::End(WorkDoneProgressEnd {\n-                message: Some(format!(\"rust-analyzer loaded, {} packages\", progress)),\n-            }),\n-        ),\n-        _ => {}\n-    }\n+fn report_progress(\n+    loop_state: &mut LoopState,\n+    sender: &Sender<Message>,\n+    done: usize,\n+    total: usize,\n+    message: &str,\n+) {\n+    let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", message));\n+    let message = Some(format!(\"{}/{} {}\", done, total, message));\n+    let percentage = Some(100.0 * done as f64 / total.max(1) as f64);\n+    let work_done_progress = if done == 0 {\n+        let work_done_progress_create = loop_state.req_queue.outgoing.register(\n+            lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n+            lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n+            DO_NOTHING,\n+        );\n+        sender.send(work_done_progress_create.into()).unwrap();\n \n-    fn send_startup_progress_notif(sender: &Sender<Message>, work_done_progress: WorkDoneProgress) {\n-        let notif =\n-            notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n-                token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n-                value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n-            });\n-        sender.send(notif.into()).unwrap();\n-    }\n+        lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+            title: \"rust-analyzer\".into(),\n+            cancellable: None,\n+            message,\n+            percentage,\n+        })\n+    } else if done < total {\n+        lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+            cancellable: None,\n+            message,\n+            percentage,\n+        })\n+    } else {\n+        assert!(done == total);\n+        lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n+    };\n+    let notification =\n+        notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n+            token,\n+            value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n+        });\n+    sender.send(notification.into()).unwrap();\n }\n \n struct PoolDispatcher<'a> {\n@@ -976,18 +981,12 @@ where\n \n #[cfg(test)]\n mod tests {\n-    use std::borrow::Cow;\n-\n     use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n-    use ra_ide::LineIndex;\n \n-    #[test]\n-    fn apply_document_changes() {\n-        fn run(text: &mut String, changes: Vec<TextDocumentContentChangeEvent>) {\n-            let line_index = Cow::Owned(LineIndex::new(&text));\n-            super::apply_document_changes(text, line_index, changes);\n-        }\n+    use super::*;\n \n+    #[test]\n+    fn test_apply_document_changes() {\n         macro_rules! c {\n             [$($sl:expr, $sc:expr; $el:expr, $ec:expr => $text:expr),+] => {\n                 vec![$(TextDocumentContentChangeEvent {\n@@ -1002,9 +1001,9 @@ mod tests {\n         }\n \n         let mut text = String::new();\n-        run(&mut text, vec![]);\n+        apply_document_changes(&mut text, vec![]);\n         assert_eq!(text, \"\");\n-        run(\n+        apply_document_changes(\n             &mut text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n@@ -1013,36 +1012,39 @@ mod tests {\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        run(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        run(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        run(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        run(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n-        run(&mut text, c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"]);\n+        apply_document_changes(\n+            &mut text,\n+            c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n+        );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        run(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        run(\n+        apply_document_changes(\n             &mut text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        run(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n         text = String::from(\"\u2764\ufe0f\");\n-        run(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n         text = String::from(\"a\\nb\");\n-        run(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n         text = String::from(\"a\\nb\");\n-        run(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n }"}, {"sha": "a44959abe7dd6e53a206f9a74d34caa9ce79be0a", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -396,7 +396,6 @@ pub fn handle_runnables(\n     let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n-    let workspace_root = snap.workspace_root_for(file_id);\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n     for runnable in snap.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n@@ -420,7 +419,7 @@ pub fn handle_runnables(\n                     location: None,\n                     kind: lsp_ext::RunnableKind::Cargo,\n                     args: lsp_ext::CargoRunnable {\n-                        workspace_root: workspace_root.map(|root| root.to_owned()),\n+                        workspace_root: Some(spec.workspace_root.clone()),\n                         cargo_args: vec![\n                             cmd.to_string(),\n                             \"--package\".to_string(),\n@@ -437,7 +436,7 @@ pub fn handle_runnables(\n                 location: None,\n                 kind: lsp_ext::RunnableKind::Cargo,\n                 args: lsp_ext::CargoRunnable {\n-                    workspace_root: workspace_root.map(|root| root.to_owned()),\n+                    workspace_root: None,\n                     cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n                     executable_args: Vec::new(),\n                 },"}, {"sha": "2c76418be09a950f2adbd1e2e15938e5c95a1783", "filename": "crates/rust-analyzer/src/main_loop/subscriptions.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=7aa66371ee3e8b31217513204c8b4f683584419d", "patch": "@@ -1,22 +0,0 @@\n-//! Keeps track of file subscriptions -- the set of currently opened files for\n-//! which we want to publish diagnostics, syntax highlighting, etc.\n-\n-use ra_ide::FileId;\n-use rustc_hash::FxHashSet;\n-\n-#[derive(Default, Debug)]\n-pub(crate) struct Subscriptions {\n-    subs: FxHashSet<FileId>,\n-}\n-\n-impl Subscriptions {\n-    pub(crate) fn add_sub(&mut self, file_id: FileId) {\n-        self.subs.insert(file_id);\n-    }\n-    pub(crate) fn remove_sub(&mut self, file_id: FileId) {\n-        self.subs.remove(&file_id);\n-    }\n-    pub(crate) fn subscriptions(&self) -> Vec<FileId> {\n-        self.subs.iter().copied().collect()\n-    }\n-}"}, {"sha": "7b45b169d6dcac6039b9e4e22a5271f14835cd7d", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -10,11 +10,10 @@ use ra_ide::{\n     ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n-use ra_vfs::LineEndings;\n \n use crate::{\n-    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot, lsp_ext,\n-    semantic_tokens, Result,\n+    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot,\n+    line_endings::LineEndings, lsp_ext, semantic_tokens, Result,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n@@ -650,6 +649,7 @@ pub(crate) fn runnable(\n     runnable: Runnable,\n ) -> Result<lsp_ext::Runnable> {\n     let spec = CargoTargetSpec::for_file(snap, file_id)?;\n+    let workspace_root = spec.as_ref().map(|it| it.workspace_root.clone());\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n         CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n@@ -661,7 +661,7 @@ pub(crate) fn runnable(\n         location: Some(location),\n         kind: lsp_ext::RunnableKind::Cargo,\n         args: lsp_ext::CargoRunnable {\n-            workspace_root: snap.workspace_root_for(file_id).map(|root| root.to_owned()),\n+            workspace_root: workspace_root,\n             cargo_args,\n             executable_args,\n         },"}, {"sha": "ff37a70080dc2e3ed9e86509f729790305c57b19", "filename": "crates/rust-analyzer/src/vfs_glob.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fvfs_glob.rs?ref=7aa66371ee3e8b31217513204c8b4f683584419d", "patch": "@@ -1,98 +0,0 @@\n-//! Exclusion rules for vfs.\n-//!\n-//! By default, we include only `.rs` files, and skip some know offenders like\n-//! `/target` or `/node_modules` altogether.\n-//!\n-//! It's also possible to add custom exclusion globs.\n-\n-use globset::{GlobSet, GlobSetBuilder};\n-use ra_vfs::{Filter, RelativePath};\n-\n-pub use globset::{Glob, GlobBuilder};\n-\n-const ALWAYS_IGNORED: &[&str] = &[\"target/**\", \"**/node_modules/**\", \"**/.git/**\"];\n-const IGNORED_FOR_NON_MEMBERS: &[&str] = &[\"examples/**\", \"tests/**\", \"benches/**\"];\n-\n-pub struct RustPackageFilterBuilder {\n-    is_member: bool,\n-    exclude: GlobSetBuilder,\n-}\n-\n-impl Default for RustPackageFilterBuilder {\n-    fn default() -> RustPackageFilterBuilder {\n-        RustPackageFilterBuilder { is_member: false, exclude: GlobSetBuilder::new() }\n-    }\n-}\n-\n-impl RustPackageFilterBuilder {\n-    pub fn set_member(mut self, is_member: bool) -> RustPackageFilterBuilder {\n-        self.is_member = is_member;\n-        self\n-    }\n-\n-    pub fn exclude(mut self, globs: impl IntoIterator<Item = Glob>) -> RustPackageFilterBuilder {\n-        for glob in globs.into_iter() {\n-            self.exclude.add(glob);\n-        }\n-        self\n-    }\n-\n-    pub fn into_vfs_filter(self) -> Box<dyn Filter> {\n-        let RustPackageFilterBuilder { is_member, mut exclude } = self;\n-        for &glob in ALWAYS_IGNORED {\n-            exclude.add(Glob::new(glob).unwrap());\n-        }\n-        if !is_member {\n-            for &glob in IGNORED_FOR_NON_MEMBERS {\n-                exclude.add(Glob::new(glob).unwrap());\n-            }\n-        }\n-        Box::new(RustPackageFilter { exclude: exclude.build().unwrap() })\n-    }\n-}\n-\n-struct RustPackageFilter {\n-    exclude: GlobSet,\n-}\n-\n-impl Filter for RustPackageFilter {\n-    fn include_dir(&self, dir_path: &RelativePath) -> bool {\n-        !self.exclude.is_match(dir_path.as_str())\n-    }\n-\n-    fn include_file(&self, file_path: &RelativePath) -> bool {\n-        file_path.extension() == Some(\"rs\")\n-    }\n-}\n-\n-#[test]\n-fn test_globs() {\n-    let filter = RustPackageFilterBuilder::default().set_member(true).into_vfs_filter();\n-\n-    assert!(filter.include_dir(RelativePath::new(\"src/tests\")));\n-    assert!(filter.include_dir(RelativePath::new(\"src/target\")));\n-    assert!(filter.include_dir(RelativePath::new(\"tests\")));\n-    assert!(filter.include_dir(RelativePath::new(\"benches\")));\n-\n-    assert!(!filter.include_dir(RelativePath::new(\"target\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"src/foo/.git\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"foo/node_modules\")));\n-\n-    let filter = RustPackageFilterBuilder::default().set_member(false).into_vfs_filter();\n-\n-    assert!(filter.include_dir(RelativePath::new(\"src/tests\")));\n-    assert!(filter.include_dir(RelativePath::new(\"src/target\")));\n-\n-    assert!(!filter.include_dir(RelativePath::new(\"target\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"src/foo/.git\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"foo/node_modules\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"tests\")));\n-    assert!(!filter.include_dir(RelativePath::new(\"benches\")));\n-\n-    let filter = RustPackageFilterBuilder::default()\n-        .set_member(true)\n-        .exclude(std::iter::once(Glob::new(\"src/llvm-project/**\").unwrap()))\n-        .into_vfs_filter();\n-\n-    assert!(!filter.include_dir(RelativePath::new(\"src/llvm-project/clang\")));\n-}"}, {"sha": "e0de377b443623bc4cc0ee7bd382b15c6ebe456a", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -52,7 +52,7 @@ use std::collections::Spam;\n         partial_result_params: PartialResultParams::default(),\n         work_done_progress_params: WorkDoneProgressParams::default(),\n     });\n-    assert!(format!(\"{}\", res).contains(\"HashMap\"));\n+    assert!(res.to_string().contains(\"HashMap\"));\n     eprintln!(\"completion took {:?}\", completion_start.elapsed());\n }\n "}, {"sha": "bb85853552ce4d3311ebc13eaff2a6851be22834", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -212,7 +212,7 @@ impl Server {\n                     ProgressParams {\n                         token: lsp_types::ProgressToken::String(ref token),\n                         value: ProgressParamsValue::WorkDone(WorkDoneProgress::End(_)),\n-                    } if token == \"rustAnalyzer/startup\" => true,\n+                    } if token == \"rustAnalyzer/roots scanned\" => true,\n                     _ => false,\n                 }\n             }"}, {"sha": "4737a52a7448b88edc1ca406c7e997b70f4132f9", "filename": "crates/vfs-notify/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"vfs-notify\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+log = \"0.4.8\"\n+rustc-hash = \"1.0\"\n+jod-thread = \"0.1.0\"\n+walkdir = \"2.3.1\"\n+globset = \"0.4.5\"\n+crossbeam-channel = \"0.4.0\"\n+notify = \"5.0.0-pre.3\"\n+\n+vfs = { path = \"../vfs\" }\n+paths = { path = \"../paths\" }"}, {"sha": "7378766f51dad47be6d1b1f0957847165d5ba851", "filename": "crates/vfs-notify/src/include.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2Fsrc%2Finclude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2Fsrc%2Finclude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Finclude.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -0,0 +1,43 @@\n+//! See `Include`.\n+\n+use std::convert::TryFrom;\n+\n+use globset::{Glob, GlobSet, GlobSetBuilder};\n+use paths::{RelPath, RelPathBuf};\n+\n+/// `Include` is the opposite of .gitignore.\n+///\n+/// It describes the set of files inside some directory.\n+///\n+/// The current implementation is very limited, it allows white-listing file\n+/// globs and black-listing directories.\n+#[derive(Debug, Clone)]\n+pub(crate) struct Include {\n+    include_files: GlobSet,\n+    exclude_dirs: Vec<RelPathBuf>,\n+}\n+\n+impl Include {\n+    pub(crate) fn new(include: Vec<String>) -> Include {\n+        let mut include_files = GlobSetBuilder::new();\n+        let mut exclude_dirs = Vec::new();\n+\n+        for glob in include {\n+            if glob.starts_with(\"!/\") {\n+                if let Ok(path) = RelPathBuf::try_from(&glob[\"!/\".len()..]) {\n+                    exclude_dirs.push(path)\n+                }\n+            } else {\n+                include_files.add(Glob::new(&glob).unwrap());\n+            }\n+        }\n+        let include_files = include_files.build().unwrap();\n+        Include { include_files, exclude_dirs }\n+    }\n+    pub(crate) fn include_file(&self, path: &RelPath) -> bool {\n+        self.include_files.is_match(path)\n+    }\n+    pub(crate) fn exclude_dir(&self, path: &RelPath) -> bool {\n+        self.exclude_dirs.iter().any(|excluded| path.starts_with(excluded))\n+    }\n+}"}, {"sha": "baee6ddc868adfd45773de1211872f0609257593", "filename": "crates/vfs-notify/src/lib.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -0,0 +1,247 @@\n+//! An implementation of `loader::Handle`, based on `walkdir` and `notify`.\n+//!\n+//! The file watching bits here are untested and quite probably buggy. For this\n+//! reason, by default we don't watch files and rely on editor's file watching\n+//! capabilities.\n+//!\n+//! Hopefully, one day a reliable file watching/walking crate appears on\n+//! crates.io, and we can reduce this to trivial glue code.\n+mod include;\n+\n+use std::convert::{TryFrom, TryInto};\n+\n+use crossbeam_channel::{select, unbounded, Receiver};\n+use notify::{RecommendedWatcher, RecursiveMode, Watcher};\n+use paths::{AbsPath, AbsPathBuf};\n+use rustc_hash::FxHashSet;\n+use vfs::loader;\n+use walkdir::WalkDir;\n+\n+use crate::include::Include;\n+\n+#[derive(Debug)]\n+pub struct LoaderHandle {\n+    // Relative order of fields below is significant.\n+    sender: crossbeam_channel::Sender<Message>,\n+    _thread: jod_thread::JoinHandle,\n+}\n+\n+#[derive(Debug)]\n+enum Message {\n+    Config(loader::Config),\n+    Invalidate(AbsPathBuf),\n+}\n+\n+impl loader::Handle for LoaderHandle {\n+    fn spawn(sender: loader::Sender) -> LoaderHandle {\n+        let actor = LoaderActor::new(sender);\n+        let (sender, receiver) = unbounded::<Message>();\n+        let thread = jod_thread::spawn(move || actor.run(receiver));\n+        LoaderHandle { sender, _thread: thread }\n+    }\n+    fn set_config(&mut self, config: loader::Config) {\n+        self.sender.send(Message::Config(config)).unwrap()\n+    }\n+    fn invalidate(&mut self, path: AbsPathBuf) {\n+        self.sender.send(Message::Invalidate(path)).unwrap();\n+    }\n+    fn load_sync(&mut self, path: &AbsPathBuf) -> Option<Vec<u8>> {\n+        read(path)\n+    }\n+}\n+\n+type NotifyEvent = notify::Result<notify::Event>;\n+\n+struct LoaderActor {\n+    config: Vec<(AbsPathBuf, Include, bool)>,\n+    watched_paths: FxHashSet<AbsPathBuf>,\n+    sender: loader::Sender,\n+    // Drop order of fields bellow is significant,\n+    watcher: Option<RecommendedWatcher>,\n+    watcher_receiver: Receiver<NotifyEvent>,\n+}\n+\n+#[derive(Debug)]\n+enum Event {\n+    Message(Message),\n+    NotifyEvent(NotifyEvent),\n+}\n+\n+impl LoaderActor {\n+    fn new(sender: loader::Sender) -> LoaderActor {\n+        let (watcher_sender, watcher_receiver) = unbounded();\n+        let watcher = log_notify_error(Watcher::new_immediate(move |event| {\n+            watcher_sender.send(event).unwrap()\n+        }));\n+\n+        LoaderActor {\n+            watcher,\n+            watcher_receiver,\n+            watched_paths: FxHashSet::default(),\n+            sender,\n+            config: Vec::new(),\n+        }\n+    }\n+\n+    fn run(mut self, receiver: Receiver<Message>) {\n+        while let Some(event) = self.next_event(&receiver) {\n+            log::debug!(\"vfs-notify event: {:?}\", event);\n+            match event {\n+                Event::Message(msg) => match msg {\n+                    Message::Config(config) => {\n+                        let n_entries_total = config.load.len();\n+                        self.send(loader::Message::Progress { n_entries_total, n_entries_done: 0 });\n+\n+                        self.unwatch_all();\n+                        self.config.clear();\n+\n+                        for (i, entry) in config.load.into_iter().enumerate() {\n+                            let watch = config.watch.contains(&i);\n+                            let files = self.load_entry(entry, watch);\n+                            self.send(loader::Message::Loaded { files });\n+                            self.send(loader::Message::Progress {\n+                                n_entries_total,\n+                                n_entries_done: i + 1,\n+                            });\n+                        }\n+                        self.config.sort_by(|x, y| x.0.cmp(&y.0));\n+                    }\n+                    Message::Invalidate(path) => {\n+                        let contents = read(path.as_path());\n+                        let files = vec![(path, contents)];\n+                        self.send(loader::Message::Loaded { files });\n+                    }\n+                },\n+                Event::NotifyEvent(event) => {\n+                    if let Some(event) = log_notify_error(event) {\n+                        let files = event\n+                            .paths\n+                            .into_iter()\n+                            .map(|path| AbsPathBuf::try_from(path).unwrap())\n+                            .filter_map(|path| {\n+                                let is_dir = path.is_dir();\n+                                let is_file = path.is_file();\n+\n+                                let config_idx =\n+                                    match self.config.binary_search_by(|it| it.0.cmp(&path)) {\n+                                        Ok(it) => it,\n+                                        Err(it) => it.saturating_sub(1),\n+                                    };\n+                                let include = self.config.get(config_idx).and_then(|it| {\n+                                    let rel_path = path.strip_prefix(&it.0)?;\n+                                    Some((rel_path, &it.1))\n+                                });\n+\n+                                if let Some((rel_path, include)) = include {\n+                                    if is_dir && include.exclude_dir(&rel_path)\n+                                        || is_file && !include.include_file(&rel_path)\n+                                    {\n+                                        return None;\n+                                    }\n+                                }\n+\n+                                if is_dir {\n+                                    self.watch(path);\n+                                    return None;\n+                                }\n+                                if !is_file {\n+                                    return None;\n+                                }\n+                                let contents = read(&path);\n+                                Some((path, contents))\n+                            })\n+                            .collect();\n+                        self.send(loader::Message::Loaded { files })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n+        select! {\n+            recv(receiver) -> it => it.ok().map(Event::Message),\n+            recv(&self.watcher_receiver) -> it => Some(Event::NotifyEvent(it.unwrap())),\n+        }\n+    }\n+    fn load_entry(\n+        &mut self,\n+        entry: loader::Entry,\n+        watch: bool,\n+    ) -> Vec<(AbsPathBuf, Option<Vec<u8>>)> {\n+        match entry {\n+            loader::Entry::Files(files) => files\n+                .into_iter()\n+                .map(|file| {\n+                    if watch {\n+                        self.watch(file.clone())\n+                    }\n+                    let contents = read(file.as_path());\n+                    (file, contents)\n+                })\n+                .collect::<Vec<_>>(),\n+            loader::Entry::Directory { path, include } => {\n+                let include = Include::new(include);\n+                self.config.push((path.clone(), include.clone(), watch));\n+\n+                let files = WalkDir::new(&path)\n+                    .into_iter()\n+                    .filter_entry(|entry| {\n+                        let abs_path: &AbsPath = entry.path().try_into().unwrap();\n+                        match abs_path.strip_prefix(&path) {\n+                            Some(rel_path) => {\n+                                !(entry.file_type().is_dir() && include.exclude_dir(rel_path))\n+                            }\n+                            None => false,\n+                        }\n+                    })\n+                    .filter_map(|entry| entry.ok())\n+                    .filter_map(|entry| {\n+                        let is_dir = entry.file_type().is_dir();\n+                        let is_file = entry.file_type().is_file();\n+                        let abs_path = AbsPathBuf::try_from(entry.into_path()).unwrap();\n+                        if is_dir {\n+                            self.watch(abs_path.clone());\n+                        }\n+                        let rel_path = abs_path.strip_prefix(&path)?;\n+                        if is_file && include.include_file(&rel_path) {\n+                            Some(abs_path)\n+                        } else {\n+                            None\n+                        }\n+                    });\n+\n+                files\n+                    .map(|file| {\n+                        let contents = read(file.as_path());\n+                        (file, contents)\n+                    })\n+                    .collect()\n+            }\n+        }\n+    }\n+\n+    fn watch(&mut self, path: AbsPathBuf) {\n+        if let Some(watcher) = &mut self.watcher {\n+            log_notify_error(watcher.watch(&path, RecursiveMode::NonRecursive));\n+            self.watched_paths.insert(path);\n+        }\n+    }\n+    fn unwatch_all(&mut self) {\n+        if let Some(watcher) = &mut self.watcher {\n+            for path in self.watched_paths.drain() {\n+                log_notify_error(watcher.unwatch(path));\n+            }\n+        }\n+    }\n+    fn send(&mut self, msg: loader::Message) {\n+        (self.sender)(msg)\n+    }\n+}\n+\n+fn read(path: &AbsPath) -> Option<Vec<u8>> {\n+    std::fs::read(path).ok()\n+}\n+\n+fn log_notify_error<T>(res: notify::Result<T>) -> Option<T> {\n+    res.map_err(|err| log::warn!(\"notify error: {}\", err)).ok()\n+}"}, {"sha": "2630690027f63e803b8d38818e43a0a1f83a3dc8", "filename": "crates/vfs/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2FCargo.toml?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -6,9 +6,5 @@ edition = \"2018\"\n \n [dependencies]\n rustc-hash = \"1.0\"\n-jod-thread = \"0.1.0\"\n-walkdir = \"2.3.1\"\n-globset = \"0.4.5\"\n-crossbeam-channel = \"0.4.0\"\n \n paths = { path = \"../paths\" }"}, {"sha": "0173f746499cea2171a290f52e7510c70471ea3d", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -4,7 +4,6 @@\n //! the default `FileSet`.\n use std::{fmt, iter};\n \n-use paths::AbsPathBuf;\n use rustc_hash::FxHashMap;\n \n use crate::{FileId, Vfs, VfsPath};\n@@ -41,7 +40,7 @@ impl fmt::Debug for FileSet {\n #[derive(Debug)]\n pub struct FileSetConfig {\n     n_file_sets: usize,\n-    roots: Vec<(AbsPathBuf, usize)>,\n+    roots: Vec<(VfsPath, usize)>,\n }\n \n impl Default for FileSetConfig {\n@@ -66,11 +65,7 @@ impl FileSetConfig {\n         self.n_file_sets\n     }\n     fn classify(&self, path: &VfsPath) -> usize {\n-        let path = match path.as_path() {\n-            Some(it) => it,\n-            None => return self.len() - 1,\n-        };\n-        let idx = match self.roots.binary_search_by(|(p, _)| p.as_path().cmp(path)) {\n+        let idx = match self.roots.binary_search_by(|(p, _)| p.cmp(path)) {\n             Ok(it) => it,\n             Err(it) => it.saturating_sub(1),\n         };\n@@ -83,7 +78,7 @@ impl FileSetConfig {\n }\n \n pub struct FileSetConfigBuilder {\n-    roots: Vec<Vec<AbsPathBuf>>,\n+    roots: Vec<Vec<VfsPath>>,\n }\n \n impl Default for FileSetConfigBuilder {\n@@ -96,12 +91,12 @@ impl FileSetConfigBuilder {\n     pub fn len(&self) -> usize {\n         self.roots.len()\n     }\n-    pub fn add_file_set(&mut self, roots: Vec<AbsPathBuf>) {\n+    pub fn add_file_set(&mut self, roots: Vec<VfsPath>) {\n         self.roots.push(roots)\n     }\n     pub fn build(self) -> FileSetConfig {\n         let n_file_sets = self.roots.len() + 1;\n-        let mut roots: Vec<(AbsPathBuf, usize)> = self\n+        let mut roots: Vec<(VfsPath, usize)> = self\n             .roots\n             .into_iter()\n             .enumerate()"}, {"sha": "024e5801875836bdd54c908eaab068995621da6c", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -38,7 +38,6 @@ mod vfs_path;\n mod path_interner;\n pub mod file_set;\n pub mod loader;\n-pub mod walkdir_loader;\n \n use std::{fmt, mem};\n "}, {"sha": "a216b5f130ba95a250b48141ada0bcac8af5aa84", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -3,19 +3,20 @@ use std::fmt;\n \n use paths::AbsPathBuf;\n \n+#[derive(Debug)]\n pub enum Entry {\n     Files(Vec<AbsPathBuf>),\n-    Directory { path: AbsPathBuf, globs: Vec<String> },\n+    Directory { path: AbsPathBuf, include: Vec<String> },\n }\n \n+#[derive(Debug)]\n pub struct Config {\n     pub load: Vec<Entry>,\n     pub watch: Vec<usize>,\n }\n \n pub enum Message {\n-    DidSwitchConfig { n_entries: usize },\n-    DidLoadAllEntries,\n+    Progress { n_entries_total: usize, n_entries_done: usize },\n     Loaded { files: Vec<(AbsPathBuf, Option<Vec<u8>>)> },\n }\n \n@@ -32,15 +33,15 @@ pub trait Handle: fmt::Debug {\n \n impl Entry {\n     pub fn rs_files_recursively(base: AbsPathBuf) -> Entry {\n-        Entry::Directory { path: base, globs: globs(&[\"*.rs\"]) }\n+        Entry::Directory { path: base, include: globs(&[\"*.rs\", \"!/.git/\"]) }\n     }\n     pub fn local_cargo_package(base: AbsPathBuf) -> Entry {\n-        Entry::Directory { path: base, globs: globs(&[\"*.rs\", \"!/target/\"]) }\n+        Entry::Directory { path: base, include: globs(&[\"*.rs\", \"!/target/\", \"!/.git/\"]) }\n     }\n     pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {\n         Entry::Directory {\n             path: base,\n-            globs: globs(&[\"*.rs\", \"!/tests/\", \"!/examples/\", \"!/benches/\"]),\n+            include: globs(&[\"*.rs\", \"!/tests/\", \"!/examples/\", \"!/benches/\", \"!/.git/\"]),\n         }\n     }\n }\n@@ -55,10 +56,11 @@ impl fmt::Debug for Message {\n             Message::Loaded { files } => {\n                 f.debug_struct(\"Loaded\").field(\"n_files\", &files.len()).finish()\n             }\n-            Message::DidSwitchConfig { n_entries } => {\n-                f.debug_struct(\"DidSwitchConfig\").field(\"n_entries\", n_entries).finish()\n-            }\n-            Message::DidLoadAllEntries => f.debug_struct(\"DidLoadAllEntries\").finish(),\n+            Message::Progress { n_entries_total, n_entries_done } => f\n+                .debug_struct(\"Progress\")\n+                .field(\"n_entries_total\", n_entries_total)\n+                .field(\"n_entries_done\", n_entries_done)\n+                .finish(),\n         }\n     }\n }"}, {"sha": "0a8a86c6214eee2d004c61022bc77749e6f118cb", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad1333b48c38bc7a5628fc0ff5304d003776a85/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=dad1333b48c38bc7a5628fc0ff5304d003776a85", "patch": "@@ -9,9 +9,17 @@ use paths::{AbsPath, AbsPathBuf};\n pub struct VfsPath(VfsPathRepr);\n \n impl VfsPath {\n+    /// Creates an \"in-memory\" path from `/`-separates string.\n+    /// This is most useful for testing, to avoid windows/linux differences\n+    pub fn new_virtual_path(path: String) -> VfsPath {\n+        assert!(path.starts_with('/'));\n+        VfsPath(VfsPathRepr::VirtualPath(VirtualPath(path)))\n+    }\n+\n     pub fn as_path(&self) -> Option<&AbsPath> {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => Some(it.as_path()),\n+            VfsPathRepr::VirtualPath(_) => None,\n         }\n     }\n     pub fn join(&self, path: &str) -> VfsPath {\n@@ -20,30 +28,71 @@ impl VfsPath {\n                 let res = it.join(path).normalize();\n                 VfsPath(VfsPathRepr::PathBuf(res))\n             }\n+            VfsPathRepr::VirtualPath(it) => {\n+                let res = it.join(path);\n+                VfsPath(VfsPathRepr::VirtualPath(res))\n+            }\n         }\n     }\n     pub fn pop(&mut self) -> bool {\n         match &mut self.0 {\n             VfsPathRepr::PathBuf(it) => it.pop(),\n+            VfsPathRepr::VirtualPath(it) => it.pop(),\n+        }\n+    }\n+    pub fn starts_with(&self, other: &VfsPath) -> bool {\n+        match (&self.0, &other.0) {\n+            (VfsPathRepr::PathBuf(lhs), VfsPathRepr::PathBuf(rhs)) => lhs.starts_with(rhs),\n+            (VfsPathRepr::PathBuf(_), _) => false,\n+            (VfsPathRepr::VirtualPath(lhs), VfsPathRepr::VirtualPath(rhs)) => lhs.starts_with(rhs),\n+            (VfsPathRepr::VirtualPath(_), _) => false,\n         }\n     }\n }\n \n #[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n enum VfsPathRepr {\n     PathBuf(AbsPathBuf),\n+    VirtualPath(VirtualPath),\n }\n \n impl From<AbsPathBuf> for VfsPath {\n     fn from(v: AbsPathBuf) -> Self {\n-        VfsPath(VfsPathRepr::PathBuf(v))\n+        VfsPath(VfsPathRepr::PathBuf(v.normalize()))\n     }\n }\n \n impl fmt::Display for VfsPath {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match &self.0 {\n             VfsPathRepr::PathBuf(it) => fmt::Display::fmt(&it.display(), f),\n+            VfsPathRepr::VirtualPath(VirtualPath(it)) => fmt::Display::fmt(it, f),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+struct VirtualPath(String);\n+\n+impl VirtualPath {\n+    fn starts_with(&self, other: &VirtualPath) -> bool {\n+        self.0.starts_with(&other.0)\n+    }\n+    fn pop(&mut self) -> bool {\n+        let pos = match self.0.rfind('/') {\n+            Some(pos) => pos,\n+            None => return false,\n+        };\n+        self.0 = self.0[..pos].to_string();\n+        true\n+    }\n+    fn join(&self, mut path: &str) -> VirtualPath {\n+        let mut res = self.clone();\n+        while path.starts_with(\"../\") {\n+            assert!(res.pop());\n+            path = &path[\"../\".len()..]\n         }\n+        res.0 = format!(\"{}/{}\", res.0, path);\n+        res\n     }\n }"}, {"sha": "13e59e3f3435252001a7386f26da8f40ba332110", "filename": "crates/vfs/src/walkdir_loader.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa66371ee3e8b31217513204c8b4f683584419d/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs?ref=7aa66371ee3e8b31217513204c8b4f683584419d", "patch": "@@ -1,108 +0,0 @@\n-//! A walkdir-based implementation of `loader::Handle`, which doesn't try to\n-//! watch files.\n-use std::convert::TryFrom;\n-\n-use globset::{Glob, GlobSetBuilder};\n-use paths::{AbsPath, AbsPathBuf};\n-use walkdir::WalkDir;\n-\n-use crate::loader;\n-\n-#[derive(Debug)]\n-pub struct WalkdirLoaderHandle {\n-    // Relative order of fields below is significant.\n-    sender: crossbeam_channel::Sender<Message>,\n-    _thread: jod_thread::JoinHandle,\n-}\n-\n-enum Message {\n-    Config(loader::Config),\n-    Invalidate(AbsPathBuf),\n-}\n-\n-impl loader::Handle for WalkdirLoaderHandle {\n-    fn spawn(sender: loader::Sender) -> WalkdirLoaderHandle {\n-        let actor = WalkdirLoaderActor { sender };\n-        let (sender, receiver) = crossbeam_channel::unbounded::<Message>();\n-        let thread = jod_thread::spawn(move || actor.run(receiver));\n-        WalkdirLoaderHandle { sender, _thread: thread }\n-    }\n-    fn set_config(&mut self, config: loader::Config) {\n-        self.sender.send(Message::Config(config)).unwrap()\n-    }\n-    fn invalidate(&mut self, path: AbsPathBuf) {\n-        self.sender.send(Message::Invalidate(path)).unwrap();\n-    }\n-    fn load_sync(&mut self, path: &AbsPathBuf) -> Option<Vec<u8>> {\n-        read(path)\n-    }\n-}\n-\n-struct WalkdirLoaderActor {\n-    sender: loader::Sender,\n-}\n-\n-impl WalkdirLoaderActor {\n-    fn run(mut self, receiver: crossbeam_channel::Receiver<Message>) {\n-        for msg in receiver {\n-            match msg {\n-                Message::Config(config) => {\n-                    self.send(loader::Message::DidSwitchConfig { n_entries: config.load.len() });\n-                    for entry in config.load.into_iter() {\n-                        let files = self.load_entry(entry);\n-                        self.send(loader::Message::Loaded { files });\n-                    }\n-                    drop(config.watch);\n-                    self.send(loader::Message::DidLoadAllEntries);\n-                }\n-                Message::Invalidate(path) => {\n-                    let contents = read(path.as_path());\n-                    let files = vec![(path, contents)];\n-                    self.send(loader::Message::Loaded { files });\n-                }\n-            }\n-        }\n-    }\n-    fn load_entry(&mut self, entry: loader::Entry) -> Vec<(AbsPathBuf, Option<Vec<u8>>)> {\n-        match entry {\n-            loader::Entry::Files(files) => files\n-                .into_iter()\n-                .map(|file| {\n-                    let contents = read(file.as_path());\n-                    (file, contents)\n-                })\n-                .collect::<Vec<_>>(),\n-            loader::Entry::Directory { path, globs } => {\n-                let globset = {\n-                    let mut builder = GlobSetBuilder::new();\n-                    for glob in &globs {\n-                        builder.add(Glob::new(glob).unwrap());\n-                    }\n-                    builder.build().unwrap()\n-                };\n-\n-                let files = WalkDir::new(path)\n-                    .into_iter()\n-                    .filter_map(|it| it.ok())\n-                    .filter(|it| it.file_type().is_file())\n-                    .map(|it| it.into_path())\n-                    .map(|it| AbsPathBuf::try_from(it).unwrap())\n-                    .filter(|it| globset.is_match(&it));\n-\n-                files\n-                    .map(|file| {\n-                        let contents = read(file.as_path());\n-                        (file, contents)\n-                    })\n-                    .collect()\n-            }\n-        }\n-    }\n-    fn send(&mut self, msg: loader::Message) {\n-        (self.sender)(msg)\n-    }\n-}\n-\n-fn read(path: &AbsPath) -> Option<Vec<u8>> {\n-    std::fs::read(path).ok()\n-}"}]}