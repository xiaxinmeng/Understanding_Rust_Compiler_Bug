{"sha": "e31898b02409b8ce5db32761d45c78f9f74dbdc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTg5OGIwMjQwOWI4Y2U1ZGIzMjc2MWQ0NWM3OGY5Zjc0ZGJkYzY=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-07-12T14:46:00Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-07-12T14:51:04Z"}, "message": "Reduce unsafe scope", "tree": {"sha": "e9568998e3d54c85dd314614e7dd215371d0a19e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9568998e3d54c85dd314614e7dd215371d0a19e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e31898b02409b8ce5db32761d45c78f9f74dbdc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e31898b02409b8ce5db32761d45c78f9f74dbdc6", "html_url": "https://github.com/rust-lang/rust/commit/e31898b02409b8ce5db32761d45c78f9f74dbdc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e31898b02409b8ce5db32761d45c78f9f74dbdc6/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0281a05f66aada7afc3e5b665b4c48a44abbc517", "url": "https://api.github.com/repos/rust-lang/rust/commits/0281a05f66aada7afc3e5b665b4c48a44abbc517", "html_url": "https://github.com/rust-lang/rust/commit/0281a05f66aada7afc3e5b665b4c48a44abbc517"}], "stats": {"total": 97, "additions": 48, "deletions": 49}, "files": [{"sha": "dda3ed68cfc95aac651c2d65f27ecf6abf77a68f", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e31898b02409b8ce5db32761d45c78f9f74dbdc6/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31898b02409b8ce5db32761d45c78f9f74dbdc6/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=e31898b02409b8ce5db32761d45c78f9f74dbdc6", "patch": "@@ -8,6 +8,10 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n+// The unsafety here stems from converting between `&OsStr` and `&[u8]`\n+// and back. This is safe to do because (1) we only look at ASCII\n+// contents of the encoding and (2) new &OsStr values are produced\n+// only from ASCII-bounded slices of existing &OsStr values.\n fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { mem::transmute(s) }\n }\n@@ -33,62 +37,57 @@ pub fn is_valid_drive_letter(disk: u8) -> bool {\n \n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n     use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n-    unsafe {\n-        // The unsafety here stems from converting between &OsStr and &[u8]\n-        // and back. This is safe to do because (1) we only look at ASCII\n-        // contents of the encoding and (2) new &OsStr values are produced\n-        // only from ASCII-bounded slices of existing &OsStr values.\n-        let path = os_str_as_u8_slice(path);\n \n-        // \\\\\n-        if let Some(path) = path.strip_prefix(br\"\\\\\") {\n-            // \\\\?\\\n-            if let Some(path) = path.strip_prefix(br\"?\\\") {\n-                // \\\\?\\UNC\\server\\share\n-                if let Some(path) = path.strip_prefix(br\"UNC\\\") {\n-                    let (server, share) = match get_first_two_components(path, is_verbatim_sep) {\n-                        Some((server, share)) => {\n-                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n-                        }\n-                        None => (u8_slice_as_os_str(path), OsStr::new(\"\")),\n-                    };\n-                    return Some(VerbatimUNC(server, share));\n-                } else {\n-                    // \\\\?\\path\n-                    match path {\n-                        // \\\\?\\C:\\path\n-                        [c, b':', b'\\\\', ..] if is_valid_drive_letter(*c) => {\n-                            return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                        }\n-                        // \\\\?\\cat_pics\n-                        _ => {\n-                            let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n-                            let slice = &path[..idx];\n-                            return Some(Verbatim(u8_slice_as_os_str(slice)));\n-                        }\n+    let path = os_str_as_u8_slice(path);\n+\n+    // \\\\\n+    if let Some(path) = path.strip_prefix(br\"\\\\\") {\n+        // \\\\?\\\n+        if let Some(path) = path.strip_prefix(br\"?\\\") {\n+            // \\\\?\\UNC\\server\\share\n+            if let Some(path) = path.strip_prefix(br\"UNC\\\") {\n+                let (server, share) = match get_first_two_components(path, is_verbatim_sep) {\n+                    Some((server, share)) => unsafe {\n+                        (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n+                    },\n+                    None => (unsafe { u8_slice_as_os_str(path) }, OsStr::new(\"\")),\n+                };\n+                return Some(VerbatimUNC(server, share));\n+            } else {\n+                // \\\\?\\path\n+                match path {\n+                    // \\\\?\\C:\\path\n+                    [c, b':', b'\\\\', ..] if is_valid_drive_letter(*c) => {\n+                        return Some(VerbatimDisk(c.to_ascii_uppercase()));\n+                    }\n+                    // \\\\?\\cat_pics\n+                    _ => {\n+                        let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+                        let slice = &path[..idx];\n+                        return Some(Verbatim(unsafe { u8_slice_as_os_str(slice) }));\n                     }\n                 }\n-            } else if let Some(path) = path.strip_prefix(b\".\\\\\") {\n-                // \\\\.\\COM42\n-                let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n-                let slice = &path[..idx];\n-                return Some(DeviceNS(u8_slice_as_os_str(slice)));\n-            }\n-            match get_first_two_components(path, is_sep_byte) {\n-                Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n-                    // \\\\server\\share\n-                    return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n-                }\n-                _ => {}\n             }\n-        } else if let [c, b':', ..] = path {\n-            // C:\n-            if is_valid_drive_letter(*c) {\n-                return Some(Disk(c.to_ascii_uppercase()));\n+        } else if let Some(path) = path.strip_prefix(b\".\\\\\") {\n+            // \\\\.\\COM42\n+            let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+            let slice = &path[..idx];\n+            return Some(DeviceNS(unsafe { u8_slice_as_os_str(slice) }));\n+        }\n+        match get_first_two_components(path, is_sep_byte) {\n+            Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+                // \\\\server\\share\n+                return Some(unsafe { UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)) });\n             }\n+            _ => {}\n+        }\n+    } else if let [c, b':', ..] = path {\n+        // C:\n+        if is_valid_drive_letter(*c) {\n+            return Some(Disk(c.to_ascii_uppercase()));\n         }\n-        return None;\n     }\n+    None\n }\n \n /// Returns the first two path components with predicate `f`."}]}