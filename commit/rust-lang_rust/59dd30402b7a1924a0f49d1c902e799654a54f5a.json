{"sha": "59dd30402b7a1924a0f49d1c902e799654a54f5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZGQzMDQwMmI3YTE5MjRhMGY0OWQxYzkwMmU3OTk2NTRhNTRmNWE=", "commit": {"author": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2019-08-17T06:12:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-25T09:56:23Z"}, "message": "Specify cursor position in ok-wrapping tests, and switch to using analysis_and_position function", "tree": {"sha": "e363618e31e86a4642bec39d3342e5b909c6f5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e363618e31e86a4642bec39d3342e5b909c6f5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59dd30402b7a1924a0f49d1c902e799654a54f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59dd30402b7a1924a0f49d1c902e799654a54f5a", "html_url": "https://github.com/rust-lang/rust/commit/59dd30402b7a1924a0f49d1c902e799654a54f5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59dd30402b7a1924a0f49d1c902e799654a54f5a/comments", "author": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6620949caee25128416acf285590b0d5558e4597", "url": "https://api.github.com/repos/rust-lang/rust/commits/6620949caee25128416acf285590b0d5558e4597", "html_url": "https://github.com/rust-lang/rust/commit/6620949caee25128416acf285590b0d5558e4597"}], "stats": {"total": 66, "additions": 31, "deletions": 35}, "files": [{"sha": "4e1f47db6b53a51080c909c23bbd9fb73fdf2926", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/59dd30402b7a1924a0f49d1c902e799654a54f5a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dd30402b7a1924a0f49d1c902e799654a54f5a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=59dd30402b7a1924a0f49d1c902e799654a54f5a", "patch": "@@ -187,7 +187,7 @@ mod tests {\n     use ra_syntax::SourceFile;\n     use test_utils::assert_eq_text;\n \n-    use crate::mock_analysis::{fixture_with_target_file, single_file};\n+    use crate::mock_analysis::{analysis_and_position, single_file};\n \n     use super::*;\n \n@@ -216,14 +216,25 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n-    fn check_apply_diagnostic_fix_for_target_file(target_file: &str, fixture: &str, after: &str) {\n-        let (analysis, file_id, target_file_contents) =\n-            fixture_with_target_file(fixture, target_file);\n-        let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n+    /// Takes a multi-file input fixture with annotated cursor positions,\n+    /// and checks that:\n+    ///  * a diagnostic is produced\n+    ///  * this diagnostic touches the input cursor position\n+    ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n+    fn check_apply_diagnostic_fix_from_position(fixture: &str, after: &str) {\n+        let (analysis, file_position) = analysis_and_position(fixture);\n+        let diagnostic = analysis.diagnostics(file_position.file_id).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n         let actual = edit.apply(&target_file_contents);\n         assert_eq_text!(after, &actual);\n+        assert!(\n+            diagnostic.range.start() <= file_position.offset && diagnostic.range.end() >= file_position.offset,\n+            \"diagnostic range {} does not touch cursor position {}\",\n+            diagnostic.range,\n+            file_position.offset\n+        );\n     }\n \n     fn check_apply_diagnostic_fix(before: &str, after: &str) {\n@@ -235,9 +246,11 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n-    fn check_no_diagnostic_for_target_file(target_file: &str, fixture: &str) {\n-        let (analysis, file_id, _) = fixture_with_target_file(fixture, target_file);\n-        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+    /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n+    /// apply to the file containing the cursor.\n+    fn check_no_diagnostic_for_target_file(fixture: &str) {\n+        let (analysis, file_position) = analysis_and_position(fixture);\n+        let diagnostics = analysis.diagnostics(file_position.file_id).unwrap();\n         assert_eq!(diagnostics.len(), 0);\n     }\n \n@@ -257,7 +270,7 @@ mod tests {\n                 if y == 0 {\n                     return Err(\"div by zero\".into());\n                 }\n-                x / y\n+                x / y<|>\n             }\n \n             //- /std/lib.rs\n@@ -279,7 +292,7 @@ fn div(x: i32, y: i32) -> Result<i32, String> {\n     Ok(x / y)\n }\n \"#;\n-        check_apply_diagnostic_fix_for_target_file(\"/main.rs\", before, after);\n+        check_apply_diagnostic_fix_from_position(before, after);\n     }\n \n     #[test]\n@@ -292,7 +305,7 @@ fn div(x: i32, y: i32) -> Result<i32, String> {\n                 if x == 0 {\n                     return Err(7);\n                 }\n-                x\n+                <|>x\n             }\n \n             //- /std/lib.rs\n@@ -311,7 +324,7 @@ fn div<T>(x: T) -> Result<T, i32> {\n     Ok(x)\n }\n \"#;\n-        check_apply_diagnostic_fix_for_target_file(\"/main.rs\", before, after);\n+        check_apply_diagnostic_fix_from_position(before, after);\n     }\n \n     #[test]\n@@ -326,7 +339,7 @@ fn div<T>(x: T) -> Result<T, i32> {\n                 if y == 0 {\n                     return Err(\"div by zero\".into());\n                 }\n-                x / y\n+                x <|>/ y\n             }\n \n             //- /std/lib.rs\n@@ -349,7 +362,7 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n     Ok(x / y)\n }\n \"#;\n-        check_apply_diagnostic_fix_for_target_file(\"/main.rs\", before, after);\n+        check_apply_diagnostic_fix_from_position(before, after);\n     }\n \n     #[test]\n@@ -359,7 +372,7 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n             use std::{string::String, result::Result::{self, Ok, Err}};\n \n             fn foo() -> Result<String, i32> {\n-                0\n+                0<|>\n             }\n \n             //- /std/lib.rs\n@@ -370,7 +383,7 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n-        check_no_diagnostic_for_target_file(\"/main.rs\", content);\n+        check_no_diagnostic_for_target_file(content);\n     }\n \n     #[test]\n@@ -385,7 +398,7 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n             }\n \n             fn foo() -> SomeOtherEnum {\n-                0\n+                0<|>\n             }\n \n             //- /std/lib.rs\n@@ -396,7 +409,7 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n-        check_no_diagnostic_for_target_file(\"/main.rs\", content);\n+        check_no_diagnostic_for_target_file(content);\n     }\n \n     #[test]"}, {"sha": "132f6f875b7eebff692374d57dc636116c059b4d", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59dd30402b7a1924a0f49d1c902e799654a54f5a/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59dd30402b7a1924a0f49d1c902e799654a54f5a/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=59dd30402b7a1924a0f49d1c902e799654a54f5a", "patch": "@@ -80,15 +80,6 @@ impl MockAnalysis {\n             .expect(\"no file in this mock\");\n         FileId(idx as u32 + 1)\n     }\n-    pub fn id_and_contents_of(&self, path: &str) -> (FileId, String) {\n-        let (idx, contents) = self\n-            .files\n-            .iter()\n-            .enumerate()\n-            .find(|(_, (p, _text))| path == p)\n-            .expect(\"no file in this mock\");\n-        (FileId(idx as u32 + 1), contents.1.to_string())\n-    }\n     pub fn analysis_host(self) -> AnalysisHost {\n         let mut host = AnalysisHost::default();\n         let source_root = SourceRootId(0);\n@@ -133,14 +124,6 @@ pub fn single_file(code: &str) -> (Analysis, FileId) {\n     (mock.analysis(), file_id)\n }\n \n-/// Creates analysis from a fixture with multiple files\n-/// and returns the file id and contents of the target file.\n-pub fn fixture_with_target_file(fixture: &str, target_file: &str) -> (Analysis, FileId, String) {\n-    let mock = MockAnalysis::with_files(fixture);\n-    let (target_file_id, target_file_contents) = mock.id_and_contents_of(target_file);\n-    (mock.analysis(), target_file_id, target_file_contents)\n-}\n-\n /// Creates analysis for a single file, returns position marked with <|>.\n pub fn single_file_with_position(code: &str) -> (Analysis, FilePosition) {\n     let mut mock = MockAnalysis::new();"}]}