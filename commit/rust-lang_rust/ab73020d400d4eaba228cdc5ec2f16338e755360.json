{"sha": "ab73020d400d4eaba228cdc5ec2f16338e755360", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNzMwMjBkNDAwZDRlYWJhMjI4Y2RjNWVjMmYxNjMzOGU3NTUzNjA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-08-02T23:52:16Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-05-12T04:51:31Z"}, "message": "Implement span quoting for proc-macros\n\nThis PR implements span quoting, allowing proc-macros to produce spans\npointing *into their own crate*. This is used by the unstable\n`proc_macro::quote!` macro, allowing us to get error messages like this:\n\n```\nerror[E0412]: cannot find type `MissingType` in this scope\n  --> $DIR/auxiliary/span-from-proc-macro.rs:37:20\n   |\nLL | pub fn error_from_attribute(_args: TokenStream, _input: TokenStream) -> TokenStream {\n   | ----------------------------------------------------------------------------------- in this expansion of procedural macro `#[error_from_attribute]`\n...\nLL |             field: MissingType\n   |                    ^^^^^^^^^^^ not found in this scope\n   |\n  ::: $DIR/span-from-proc-macro.rs:8:1\n   |\nLL | #[error_from_attribute]\n   | ----------------------- in this macro invocation\n```\n\nHere, `MissingType` occurs inside the implementation of the proc-macro\n`#[error_from_attribute]`. Previosuly, this would always result in a\nspan pointing at `#[error_from_attribute]`\n\nThis will make many proc-macro-related error message much more useful -\nwhen a proc-macro generates code containing an error, users will get an\nerror message pointing directly at that code (within the macro\ndefinition), instead of always getting a span pointing at the macro\ninvocation site.\n\nThis is implemented as follows:\n* When a proc-macro crate is being *compiled*, it causes the `quote!`\n  macro to get run. This saves all of the sapns in the input to `quote!`\n  into the metadata of *the proc-macro-crate* (which we are currently\n  compiling). The `quote!` macro then expands to a call to\n  `proc_macro::Span::recover_proc_macro_span(id)`, where `id` is an\nopaque identifier for the span in the crate metadata.\n* When the same proc-macro crate is *run* (e.g. it is loaded from disk\n  and invoked by some consumer crate), the call to\n`proc_macro::Span::recover_proc_macro_span` causes us to load the span\nfrom the proc-macro crate's metadata. The proc-macro then produces a\n`TokenStream` containing a `Span` pointing into the proc-macro crate\nitself.\n\nThe recursive nature of 'quote!' can be difficult to understand at\nfirst. The file `src/test/ui/proc-macro/quote-debug.stdout` shows\nthe output of the `quote!` macro, which should make this eaier to\nunderstand.\n\nThis PR also supports custom quoting spans in custom quote macros (e.g.\nthe `quote` crate). All span quoting goes through the\n`proc_macro::quote_span` method, which can be called by a custom quote\nmacro to perform span quoting. An example of this usage is provided in\n`src/test/ui/proc-macro/auxiliary/custom-quote.rs`\n\nCustom quoting currently has a few limitations:\n\nIn order to quote a span, we need to generate a call to\n`proc_macro::Span::recover_proc_macro_span`. However, proc-macros\nsupport renaming the `proc_macro` crate, so we can't simply hardcode\nthis path. Previously, the `quote_span` method used the path\n`crate::Span` - however, this only works when it is called by the\nbuiltin `quote!` macro in the same crate. To support being called from\narbitrary crates, we need access to the name of the `proc_macro` crate\nto generate a path. This PR adds an additional argument to `quote_span`\nto specify the name of the `proc_macro` crate. Howver, this feels kind\nof hacky, and we may want to change this before stabilizing anything\nquote-related.\n\nAdditionally, using `quote_span` currently requires enabling the\n`proc_macro_internals` feature. The builtin `quote!` macro\nhas an `#[allow_internal_unstable]` attribute, but this won't work for\ncustom quote implementations. This will likely require some additional\ntricks to apply `allow_internal_unstable` to the span of\n`proc_macro::Span::recover_proc_macro_span`.", "tree": {"sha": "422829e6b2eacba67b7a440e24c71ebed5f42b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/422829e6b2eacba67b7a440e24c71ebed5f42b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab73020d400d4eaba228cdc5ec2f16338e755360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab73020d400d4eaba228cdc5ec2f16338e755360", "html_url": "https://github.com/rust-lang/rust/commit/ab73020d400d4eaba228cdc5ec2f16338e755360", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab73020d400d4eaba228cdc5ec2f16338e755360/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918a1a20b1d10e2cc28cf27a56d43574cd09d79f", "url": "https://api.github.com/repos/rust-lang/rust/commits/918a1a20b1d10e2cc28cf27a56d43574cd09d79f", "html_url": "https://github.com/rust-lang/rust/commit/918a1a20b1d10e2cc28cf27a56d43574cd09d79f"}], "stats": {"total": 8, "additions": 4, "deletions": 4}, "files": [{"sha": "6966d798c537a8e963cac529d724f22e072142a0", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ab73020d400d4eaba228cdc5ec2f16338e755360", "patch": "@@ -660,7 +660,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n+        matches!(data.kind, ExpnKind::Macro { kind: MacroKind::Attr, name: _, proc_macro: _ })\n     } else {\n         false\n     }"}, {"sha": "d22f7d9a96bf112b59baef5c1ae5ad4c863ec8f4", "filename": "clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=ab73020d400d4eaba228cdc5ec2f16338e755360", "patch": "@@ -8,7 +8,7 @@ use super::UNIT_CMP;\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n         if let Some(callee) = expr.span.source_callee() {\n-            if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n+            if let ExpnKind::Macro { kind: MacroKind::Bang, name: symbol, proc_macro: _ } = callee.kind {\n                 if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n                     let op = cmp.node;\n                     if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {"}, {"sha": "9a0b72f06bbc939f7a4cb2f8f3938c3de91d25fe", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab73020d400d4eaba228cdc5ec2f16338e755360/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=ab73020d400d4eaba228cdc5ec2f16338e755360", "patch": "@@ -947,7 +947,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n             let data = span.ctxt().outer_expn_data();\n             let new_span = data.call_site;\n \n-            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+            if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n                 if mac_name.as_str() == name {\n                     return Some(new_span);\n                 }\n@@ -975,7 +975,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n         let data = span.ctxt().outer_expn_data();\n         let new_span = data.call_site;\n \n-        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+        if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n             if mac_name.as_str() == name {\n                 return Some(new_span);\n             }"}]}