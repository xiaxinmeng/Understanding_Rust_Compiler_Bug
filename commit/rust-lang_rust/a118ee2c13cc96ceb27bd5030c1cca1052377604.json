{"sha": "a118ee2c13cc96ceb27bd5030c1cca1052377604", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMThlZTJjMTNjYzk2Y2ViMjdiZDUwMzBjMWNjYTEwNTIzNzc2MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-12T06:34:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-12T06:34:21Z"}, "message": "Auto merge of #81486 - ssomers:btree_separate_drop, r=Mark-Simulacrum\n\nBTreeMap: disentangle Drop implementation from IntoIter\n\nNo longer require every `BTreeMap` to dig up its last leaf edge before dying. This speeds up the `clone_` benchmarks by 25% for normal keys and values (far less for huge values).\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "0064f78771edee2e67a1982468f23362c85bee7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0064f78771edee2e67a1982468f23362c85bee7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a118ee2c13cc96ceb27bd5030c1cca1052377604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a118ee2c13cc96ceb27bd5030c1cca1052377604", "html_url": "https://github.com/rust-lang/rust/commit/a118ee2c13cc96ceb27bd5030c1cca1052377604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a118ee2c13cc96ceb27bd5030c1cca1052377604/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9920ef7749d11fc71cc32ca4ba055bcfeaab945", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9920ef7749d11fc71cc32ca4ba055bcfeaab945", "html_url": "https://github.com/rust-lang/rust/commit/e9920ef7749d11fc71cc32ca4ba055bcfeaab945"}, {"sha": "3045b75c6d5fb5011fd9cc3a4146bb984a037ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3045b75c6d5fb5011fd9cc3a4146bb984a037ca4", "html_url": "https://github.com/rust-lang/rust/commit/3045b75c6d5fb5011fd9cc3a4146bb984a037ca4"}], "stats": {"total": 171, "additions": 106, "deletions": 65}, "files": [{"sha": "bea83a37d531b58d8f88ec9c83fc4f9b02b28533", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a118ee2c13cc96ceb27bd5030c1cca1052377604/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a118ee2c13cc96ceb27bd5030c1cca1052377604/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=a118ee2c13cc96ceb27bd5030c1cca1052377604", "patch": "@@ -145,8 +145,8 @@ pub struct BTreeMap<K, V> {\n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n     fn drop(&mut self) {\n-        unsafe {\n-            drop(ptr::read(self).into_iter());\n+        if let Some(root) = self.root.take() {\n+            Dropper { front: root.into_dying().first_leaf_edge(), remaining_length: self.length };\n         }\n     }\n }\n@@ -332,6 +332,14 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     }\n }\n \n+/// A simplified version of `IntoIter` that is not double-ended and has only one\n+/// purpose: to drop the remainder of an `IntoIter`. Therefore it also serves to\n+/// drop an entire tree without the need to first look up a `back` leaf edge.\n+struct Dropper<K, V> {\n+    front: Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n+    remaining_length: usize,\n+}\n+\n /// An iterator over the keys of a `BTreeMap`.\n ///\n /// This `struct` is created by the [`keys`] method on [`BTreeMap`]. See its\n@@ -1410,42 +1418,42 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-impl<K, V> Drop for IntoIter<K, V> {\n+impl<K, V> Drop for Dropper<K, V> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, K, V>(&'a mut IntoIter<K, V>);\n+        // Similar to advancing a non-fusing iterator.\n+        fn next_or_end<K, V>(this: &mut Dropper<K, V>) -> Option<(K, V)> {\n+            if this.remaining_length == 0 {\n+                unsafe { ptr::read(&this.front).deallocating_end() }\n+                None\n+            } else {\n+                this.remaining_length -= 1;\n+                Some(unsafe { this.front.deallocating_next_unchecked() })\n+            }\n+        }\n+\n+        struct DropGuard<'a, K, V>(&'a mut Dropper<K, V>);\n \n         impl<'a, K, V> Drop for DropGuard<'a, K, V> {\n             fn drop(&mut self) {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n-                while let Some(_) = self.0.next() {}\n-\n-                unsafe {\n-                    let mut node =\n-                        ptr::read(&self.0.front).unwrap_unchecked().into_node().forget_type();\n-                    while let Some(parent) = node.deallocate_and_ascend() {\n-                        node = parent.into_node().forget_type();\n-                    }\n-                }\n+                while let Some(_pair) = next_or_end(&mut self.0) {}\n             }\n         }\n \n-        while let Some(pair) = self.next() {\n+        while let Some(pair) = next_or_end(self) {\n             let guard = DropGuard(self);\n             drop(pair);\n             mem::forget(guard);\n         }\n+    }\n+}\n \n-        unsafe {\n-            if let Some(front) = ptr::read(&self.front) {\n-                let mut node = front.into_node().forget_type();\n-                // Most of the nodes have been deallocated while traversing\n-                // but one pile from a leaf up to the root is left standing.\n-                while let Some(parent) = node.deallocate_and_ascend() {\n-                    node = parent.into_node().forget_type();\n-                }\n-            }\n+#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n+impl<K, V> Drop for IntoIter<K, V> {\n+    fn drop(&mut self) {\n+        if let Some(front) = self.front.take() {\n+            Dropper { front, remaining_length: self.length };\n         }\n     }\n }\n@@ -1459,7 +1467,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.front.as_mut().unwrap().next_unchecked() })\n+            Some(unsafe { self.front.as_mut().unwrap().deallocating_next_unchecked() })\n         }\n     }\n \n@@ -1475,7 +1483,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.back.as_mut().unwrap().next_back_unchecked() })\n+            Some(unsafe { self.back.as_mut().unwrap().deallocating_next_back_unchecked() })\n         }\n     }\n }"}, {"sha": "43838578ca21f5d9ac3164349b56a95f81ad93a5", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 72, "deletions": 39, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a118ee2c13cc96ceb27bd5030c1cca1052377604/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a118ee2c13cc96ceb27bd5030c1cca1052377604/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=a118ee2c13cc96ceb27bd5030c1cca1052377604", "patch": "@@ -289,37 +289,76 @@ impl<BorrowType: marker::BorrowType, K, V>\n     }\n }\n \n-macro_rules! def_next_kv_uncheched_dealloc {\n-    { unsafe fn $name:ident : $adjacent_kv:ident } => {\n-        /// Given a leaf edge handle into an owned tree, returns a handle to the next KV,\n-        /// while deallocating any node left behind yet leaving the corresponding edge\n-        /// in its parent node dangling.\n-        ///\n-        /// # Safety\n-        /// - The leaf edge must not be the last one in the direction travelled.\n-        /// - The node carrying the next KV returned must not have been deallocated by a\n-        ///   previous call on any handle obtained for this tree.\n-        unsafe fn $name <K, V>(\n-            leaf_edge: Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n-            let mut edge = leaf_edge.forget_node_type();\n-            loop {\n-                edge = match edge.$adjacent_kv() {\n-                    Ok(internal_kv) => return internal_kv,\n-                    Err(last_edge) => {\n-                        unsafe {\n-                            let parent_edge = last_edge.into_node().deallocate_and_ascend();\n-                            parent_edge.unwrap_unchecked().forget_node_type()\n-                        }\n-                    }\n+impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n+    /// Given a leaf edge handle into a dying tree, returns the next leaf edge\n+    /// on the right side, and the key-value pair in between, which is either\n+    /// in the same leaf node, in an ancestor node, or non-existent.\n+    ///\n+    /// This method also deallocates any node(s) it reaches the end of. This\n+    /// implies that if no more key-value pair exists, the entire remainder of\n+    /// the tree will have been deallocated and there is nothing left to return.\n+    ///\n+    /// # Safety\n+    /// The given edge must not have been previously returned by counterpart\n+    /// `deallocating_next_back`.\n+    unsafe fn deallocating_next(self) -> Option<(Self, (K, V))> {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.right_kv() {\n+                Ok(kv) => {\n+                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                    return Some((kv.next_leaf_edge(), (k, v)));\n                 }\n+                Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n+                    Some(parent_edge) => parent_edge.forget_node_type(),\n+                    None => return None,\n+                },\n             }\n         }\n-    };\n-}\n+    }\n \n-def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n-def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n+    /// Given a leaf edge handle into a dying tree, returns the next leaf edge\n+    /// on the left side, and the key-value pair in between, which is either\n+    /// in the same leaf node, in an ancestor node, or non-existent.\n+    ///\n+    /// This method also deallocates any node(s) it reaches the end of. This\n+    /// implies that if no more key-value pair exists, the entire remainder of\n+    /// the tree will have been deallocated and there is nothing left to return.\n+    ///\n+    /// # Safety\n+    /// The given edge must not have been previously returned by counterpart\n+    /// `deallocating_next`.\n+    unsafe fn deallocating_next_back(self) -> Option<(Self, (K, V))> {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.left_kv() {\n+                Ok(kv) => {\n+                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                    return Some((kv.next_back_leaf_edge(), (k, v)));\n+                }\n+                Err(last_edge) => match unsafe { last_edge.into_node().deallocate_and_ascend() } {\n+                    Some(parent_edge) => parent_edge.forget_node_type(),\n+                    None => return None,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Deallocates a pile of nodes from the leaf up to the root.\n+    /// This is the only way to deallocate the remainder of a tree after\n+    /// `deallocating_next` and `deallocating_next_back` have been nibbling at\n+    /// both sides of the tree, and have hit the same edge. As it is intended\n+    /// only to be called when all keys and values have been returned,\n+    /// no cleanup is done on any of the keys or values.\n+    pub fn deallocating_end(self) {\n+        let mut edge = self.forget_node_type();\n+        while let Some(parent_edge) = unsafe { edge.into_node().deallocate_and_ascend() } {\n+            edge = parent_edge.forget_node_type();\n+        }\n+    }\n+}\n \n impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n@@ -394,12 +433,9 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// call this method again subject to its safety conditions, or call counterpart\n     /// `next_back_unchecked` subject to its safety conditions.\n-    pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        super::mem::replace(self, |leaf_edge| {\n-            let kv = unsafe { next_kv_unchecked_dealloc(leaf_edge) };\n-            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-            (kv.next_leaf_edge(), (k, v))\n+    pub unsafe fn deallocating_next_unchecked(&mut self) -> (K, V) {\n+        super::mem::replace(self, |leaf_edge| unsafe {\n+            leaf_edge.deallocating_next().unwrap_unchecked()\n         })\n     }\n \n@@ -415,12 +451,9 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// call this method again subject to its safety conditions, or call counterpart\n     /// `next_unchecked` subject to its safety conditions.\n-    pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        super::mem::replace(self, |leaf_edge| {\n-            let kv = unsafe { next_back_kv_unchecked_dealloc(leaf_edge) };\n-            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-            (kv.next_back_leaf_edge(), (k, v))\n+    pub unsafe fn deallocating_next_back_unchecked(&mut self) -> (K, V) {\n+        super::mem::replace(self, |leaf_edge| unsafe {\n+            leaf_edge.deallocating_next_back().unwrap_unchecked()\n         })\n     }\n }"}]}