{"sha": "37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTFmMmUzYWNjNzVlOGEzZDBmZDQ3YmIzNDViMmNkODgwYjI5Mzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:07Z"}, "message": "rollup merge of #24487: erickt/syntax\n\nThis removes the usage of `#[feature(into_cow, slice_patterns, box_syntax, box_patterns, quote, unsafe_destructor)]` from being used in libsyntax. My main desire for this is that it brings me one step closer to letting [syntex](https://github.com/erickt/rust-syntex) compile with stable rust. Hopefully this doesn't inconvenience rust development.", "tree": {"sha": "0e9af466fc2c1f4185b87f29ffe71a86ad5bcaa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e9af466fc2c1f4185b87f29ffe71a86ad5bcaa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "html_url": "https://github.com/rust-lang/rust/commit/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957cb422a98585568558ad88ec5a0841c43961ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/957cb422a98585568558ad88ec5a0841c43961ae", "html_url": "https://github.com/rust-lang/rust/commit/957cb422a98585568558ad88ec5a0841c43961ae"}, {"sha": "19c8d701743922a709a4eb6554f562996b7baa27", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c8d701743922a709a4eb6554f562996b7baa27", "html_url": "https://github.com/rust-lang/rust/commit/19c8d701743922a709a4eb6554f562996b7baa27"}], "stats": {"total": 436, "additions": 258, "deletions": 178}, "files": [{"sha": "488a4a8082f9dc8b24d41a323d73f851a2dafb2c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -348,7 +348,7 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n \n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n-            sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n+            sess.codemap().with_expn_info(ExpnId::from_u32(cookie), |info| match info {\n                 Some(ei) => sess.span_err(ei.call_site, msg),\n                 None     => sess.err(msg),\n             });"}, {"sha": "27128827e267603e0a9b90c155647755093b7dd8", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -138,7 +138,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx().llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.to_llvm_cookie());\n+        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.into_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bcx.ccx().llcx(), &val, 1));"}, {"sha": "78f06ce5fd5d07f8025a4c5e1b688d0ce32afbcb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -238,7 +238,7 @@ pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident {\n     let mut pretty = match ty {\n         Some(t) => pprust::ty_to_string(t),\n-        None => String::from_str(\"..\")\n+        None => String::from(\"..\")\n     };\n \n     match *trait_ref {"}, {"sha": "a0c29a2371b407bdb6529f30be3bb79ae4b26188", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -26,7 +26,6 @@ use std::rc::Rc;\n \n use std::fmt;\n \n-use libc::c_uint;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n \n@@ -287,13 +286,12 @@ pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n \n impl ExpnId {\n-    pub fn from_llvm_cookie(cookie: c_uint) -> ExpnId {\n-        ExpnId(cookie)\n+    pub fn from_u32(id: u32) -> ExpnId {\n+        ExpnId(id)\n     }\n \n-    pub fn to_llvm_cookie(self) -> i32 {\n-        let ExpnId(cookie) = self;\n-        cookie as i32\n+    pub fn into_u32(self) -> u32 {\n+        self.0\n     }\n }\n \n@@ -557,9 +555,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from_str(&src[3..])\n+            String::from(&src[3..])\n         } else {\n-            String::from_str(&src[..])\n+            String::from(&src[..])\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -594,8 +592,8 @@ impl CodeMap {\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n                                 source_len: usize,\n-                                file_local_lines: Vec<BytePos>,\n-                                file_local_multibyte_chars: Vec<MultiByteChar>)\n+                                mut file_local_lines: Vec<BytePos>,\n+                                mut file_local_multibyte_chars: Vec<MultiByteChar>)\n                                 -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n@@ -606,19 +604,21 @@ impl CodeMap {\n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);\n \n-        let lines = file_local_lines.map_in_place(|pos| pos + start_pos);\n-        let multibyte_chars = file_local_multibyte_chars.map_in_place(|mbc| MultiByteChar {\n-            pos: mbc.pos + start_pos,\n-            bytes: mbc.bytes\n-        });\n+        for pos in &mut file_local_lines {\n+            *pos = *pos + start_pos;\n+        }\n+\n+        for mbc in &mut file_local_multibyte_chars {\n+            mbc.pos = mbc.pos + start_pos;\n+        }\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n-            lines: RefCell::new(lines),\n-            multibyte_chars: RefCell::new(multibyte_chars),\n+            lines: RefCell::new(file_local_lines),\n+            multibyte_chars: RefCell::new(file_local_multibyte_chars),\n         });\n \n         files.push(filemap.clone());"}, {"sha": "366806bc19b4962882552eb27725679acb9d1177", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -284,8 +284,15 @@ impl<'a> fold::Folder for CfgAttrFolder<'a> {\n             return fold::noop_fold_attribute(attr, self);\n         }\n \n-        let (cfg, mi) = match attr.meta_item_list() {\n-            Some([ref cfg, ref mi]) => (cfg, mi),\n+        let attr_list = match attr.meta_item_list() {\n+            Some(attr_list) => attr_list,\n+            None => {\n+                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                return None;\n+            }\n+        };\n+        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n+            (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n                 self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n                 return None;"}, {"sha": "a7453636c445c6c6d7d546e022d5f06b68760dee", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -644,7 +644,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n \n             try!(write!(&mut err.dst, \"{}\", s));\n-            let mut s = String::from_str(\"^\");\n+            let mut s = String::from(\"^\");\n             let count = match lastc {\n                 // Most terminals have a tab stop every eight columns by default\n                 '\\t' => 8 - col%8,"}, {"sha": "6de4edafa0bf5cafaadd4457d54aeca6d6093bcd", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -54,8 +54,8 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<MacResult+'cx> {\n-    let code = match token_tree {\n-        [ast::TtToken(_, token::Ident(code, _))] => code,\n+    let code = match (token_tree.len(), token_tree.get(0)) {\n+        (1, Some(&ast::TtToken(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n     };\n     with_used_diagnostics(|diagnostics| {\n@@ -77,20 +77,25 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    MacEager::expr(quote_expr!(ecx, ()))\n+    MacEager::expr(ecx.expr_tuple(span, Vec::new()))\n }\n \n pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<MacResult+'cx> {\n-    let (code, description) = match token_tree {\n-        [ast::TtToken(_, token::Ident(ref code, _))] => {\n+    let (code, description) = match (\n+        token_tree.len(),\n+        token_tree.get(0),\n+        token_tree.get(1),\n+        token_tree.get(2)\n+    ) {\n+        (1, Some(&ast::TtToken(_, token::Ident(ref code, _))), None, None) => {\n             (code, None)\n         },\n-        [ast::TtToken(_, token::Ident(ref code, _)),\n-         ast::TtToken(_, token::Comma),\n-         ast::TtToken(_, token::Literal(token::StrRaw(description, _), None))] => {\n+        (3, Some(&ast::TtToken(_, token::Ident(ref code, _))),\n+            Some(&ast::TtToken(_, token::Comma)),\n+            Some(&ast::TtToken(_, token::Literal(token::StrRaw(description, _), None)))) => {\n             (code, Some(description))\n         }\n         _ => unreachable!()\n@@ -123,15 +128,23 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     let sym = Ident::new(token::gensym(&(\n         \"__register_diagnostic_\".to_string() + &token::get_ident(*code)\n     )));\n-    MacEager::items(SmallVector::many(vec![quote_item!(ecx, mod $sym {}).unwrap()]))\n+    MacEager::items(SmallVector::many(vec![\n+        ecx.item_mod(\n+            span,\n+            span,\n+            sym,\n+            Vec::new(),\n+            Vec::new()\n+        )\n+    ]))\n }\n \n pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n-    let name = match token_tree {\n-        [ast::TtToken(_, token::Ident(ref name, _))] => name,\n+    let name = match (token_tree.len(), token_tree.get(0)) {\n+        (1, Some(&ast::TtToken(_, token::Ident(ref name, _)))) => name,\n         _ => unreachable!()\n     };\n \n@@ -148,7 +161,37 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    MacEager::items(SmallVector::many(vec![quote_item!(ecx,\n-        pub static $name: [(&'static str, &'static str); $count] = $expr;\n-    ).unwrap()]))\n+    let static_ = ecx.lifetime(span, ecx.name_of(\"'static\"));\n+    let ty_str = ecx.ty_rptr(\n+        span,\n+        ecx.ty_ident(span, ecx.ident_of(\"str\")),\n+        Some(static_),\n+        ast::MutImmutable,\n+    );\n+\n+    let ty = ecx.ty(\n+        span,\n+        ast::TyFixedLengthVec(\n+            ecx.ty(\n+                span,\n+                ast::TyTup(vec![ty_str.clone(), ty_str])\n+            ),\n+            ecx.expr_usize(span, count),\n+        ),\n+    );\n+\n+    MacEager::items(SmallVector::many(vec![\n+        P(ast::Item {\n+            ident: name.clone(),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::ItemStatic(\n+                ty,\n+                ast::MutImmutable,\n+                expr,\n+            ),\n+            vis: ast::Public,\n+            span: span,\n+        })\n+    ]))\n }"}, {"sha": "50ab430f148ca7ece5e5f4468913e78b6ab95586", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -262,10 +262,10 @@ macro_rules! make_MacEager {\n         impl MacEager {\n             $(\n                 pub fn $fld(v: $t) -> Box<MacResult> {\n-                    box MacEager {\n+                    Box::new(MacEager {\n                         $fld: Some(v),\n                         ..Default::default()\n-                    }\n+                    })\n                 }\n             )*\n         }\n@@ -331,7 +331,7 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: false, span: sp }\n+        Box::new(DummyResult { expr_only: false, span: sp })\n     }\n \n     /// Create a default MacResult that can only be an expression.\n@@ -340,7 +340,7 @@ impl DummyResult {\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n     pub fn expr(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: true, span: sp }\n+        Box::new(DummyResult { expr_only: true, span: sp })\n     }\n \n     /// A plain dummy expression."}, {"sha": "94cc0d9c493f21dc0abfe6e09b1082138fb26f27", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -106,8 +106,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n                 };\n "}, {"sha": "61eb81c6755e2663e37baf05b61c1804dd5f6902", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -29,8 +29,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         cs_fold(\n             true,  // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n@@ -46,8 +46,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         cs_fold(\n             true,  // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n "}, {"sha": "dbb779decace27715f6eab03ff5ac36299a91a58", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -47,7 +47,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n     let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n     let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                     None,\n-                                    vec![box ordering_ty],\n+                                    vec![Box::new(ordering_ty)],\n                                     true));\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -150,8 +150,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n                 };\n \n@@ -208,8 +208,8 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n             get use the binops to avoid auto-deref dereferencing too many\n             layers of pointers, if the type includes pointers.\n             */\n-            let other_f = match other_fs {\n-                [ref o_f] => o_f,\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             };\n "}, {"sha": "0b31f06f87d0676c19615d079c461f87ef4fe30f", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -68,14 +68,14 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                     vec!(), true))))\n                 },\n                 explicit_self: None,\n-                args: vec!(Ptr(box Literal(Path::new_local(\"__D\")),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__D\"))),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(box Self_, box Literal(Path::new_(\n+                    vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n                         vec![\"__D\", \"Error\"], None, vec![], false\n-                    ))),\n+                    )))),\n                     true\n                 )),\n                 attributes: Vec::new(),"}, {"sha": "92944d649332f04617e1dea75f8cd75d10687090", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -144,14 +144,14 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                     vec!(), true))))\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(box Literal(Path::new_local(\"__S\")),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__S\"))),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(box Tuple(Vec::new()), box Literal(Path::new_(\n+                    vec!(Box::new(Tuple(Vec::new())), Box::new(Literal(Path::new_(\n                         vec![\"__S\", \"Error\"], None, vec![], false\n-                    ))),\n+                    )))),\n                     true\n                 )),\n                 attributes: Vec::new(),"}, {"sha": "4c05cd973ff6f3252751ee7c2a96e644010b9840", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -807,7 +807,7 @@ impl<'a> MethodDef<'a> {\n                 Self_ if nonstatic  => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(box Self_, _) if nonstatic => {\n+                Ptr(ref ty, _) if **ty == Self_ && nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {\n@@ -1103,7 +1103,7 @@ impl<'a> MethodDef<'a> {\n                     subpats.push(p);\n                     idents\n                 };\n-                for self_arg_name in self_arg_names.tail() {\n+                for self_arg_name in &self_arg_names[1..] {\n                     let (p, idents) = mk_self_pat(cx, &self_arg_name[..]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);"}, {"sha": "9e8e68c0b8cce1e49c80434939b7bc42dba67984", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -24,7 +24,7 @@ use parse::token::special_idents;\n use ptr::P;\n \n /// The types of pointers\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n@@ -34,7 +34,7 @@ pub enum PtrTy<'a> {\n \n /// A path, e.g. `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub struct Path<'a> {\n     pub path: Vec<&'a str> ,\n     pub lifetime: Option<&'a str>,\n@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n }\n \n /// A type. Supports pointers, Self, and literals\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum Ty<'a> {\n     Self_,\n     /// &/Box/ Ty\n@@ -109,7 +109,7 @@ pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n }\n \n pub fn borrowed_self<'r>() -> Ty<'r> {\n-    borrowed(box Self_)\n+    borrowed(Box::new(Self_))\n }\n \n pub fn nil_ty<'r>() -> Ty<'r> {"}, {"sha": "b9835eda791f7f004589c170bc7b600d76eb1fab", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                                   vec![path_std!(cx, core::hash::Hasher)])],\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(box Literal(arg), Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(Box::new(Literal(arg)), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 attributes: vec![],\n                 combine_substructure: combine_substructure(Box::new(|a, b, c| {\n@@ -56,8 +56,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n }\n \n fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let state_expr = match substr.nonself_args {\n-        [ref state_expr] => state_expr,\n+    let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n+        (1, Some(o_f)) => o_f,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\")\n     };\n     let call_hash = |span, thing_expr| {"}, {"sha": "a972cfe135511d99f6961edc9bc6fc37ad5a4dd7", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -40,7 +40,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path_local!(i64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self_),\n+                                           vec!(Box::new(Self_)),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n@@ -55,7 +55,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path_local!(u64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self_),\n+                                           vec!(Box::new(Self_)),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,\n@@ -71,8 +71,8 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let n = match substr.nonself_args {\n-        [ref n] => n,\n+    let n = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n+        (1, Some(o_f)) => o_f,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(FromPrimitive)`\")\n     };\n "}, {"sha": "3ce1f6f12ceab58ac7cbf5a01cc3d4bd2a3764ef", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -25,7 +25,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             push: &mut FnMut(P<Item>))\n {\n     // &mut ::std::fmt::Formatter\n-    let fmtr = Ptr(box Literal(path_std!(cx, core::fmt::Formatter)),\n+    let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {"}, {"sha": "d1db956adb3f5a13f28576ff6ac5ceab1802a800", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -1962,8 +1962,8 @@ foo_module!();\n                 \"xx\" == string\n             }).collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[..];\n-        let cxbind = match cxbinds {\n-            [b] => b,\n+        let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n+            (1, Some(b)) => *b,\n             _ => panic!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt::resolve(*cxbind);"}, {"sha": "08bb4ca106486207cc377ed8c57175b1832b5101", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -128,7 +128,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n         }\n     }\n \n-    box ExpandResult { p: p }\n+    Box::new(ExpandResult { p: p })\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "646e6fec405534de3f62a18ae55dc8f57b6ff83c", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -28,12 +28,11 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n         return base::DummyResult::any(sp);\n     }\n \n-\n-    match tt {\n-        [ast::TtToken(_, ref tok)] if tok.is_keyword(keywords::True) => {\n+    match (tt.len(), tt.first()) {\n+        (1, Some(&ast::TtToken(_, ref tok))) if tok.is_keyword(keywords::True) => {\n             cx.set_trace_macros(true);\n         }\n-        [ast::TtToken(_, ref tok)] if tok.is_keyword(keywords::False) => {\n+        (1, Some(&ast::TtToken(_, ref tok))) if tok.is_keyword(keywords::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}, {"sha": "5521c68e75c6950f513c3519411d009983f1f490", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -165,7 +165,7 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(&ms[..]);\n     let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n-    box MatcherPos {\n+    Box::new(MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n@@ -176,7 +176,7 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         match_cur: 0,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n-    }\n+    })\n }\n \n /// NamedMatch is a pattern-match result for a single token::MATCH_NONTERMINAL:\n@@ -396,7 +396,7 @@ pub fn parse(sess: &ParseSess,\n                         let matches: Vec<_> = (0..ei.matches.len())\n                             .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n-                        cur_eis.push(box MatcherPos {\n+                        cur_eis.push(Box::new(MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n                             idx: 0,\n@@ -407,7 +407,7 @@ pub fn parse(sess: &ParseSess,\n                             up: Some(ei_t),\n                             sp_lo: sp.lo,\n                             top_elts: Tt(TtSequence(sp, seq)),\n-                        });\n+                        }));\n                     }\n                     TtToken(_, MatchNt(..)) => {\n                         // Built-in nonterminals never start with these tokens,\n@@ -533,15 +533,15 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n       \"ty\" => token::NtTy(p.parse_ty()),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n-        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(box sn,b) }\n+        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             panic!(p.fatal(&format!(\"expected ident, found {}\",\n                              &token_str[..])))\n         }\n       },\n       \"path\" => {\n-        token::NtPath(box panictry!(p.parse_path(LifetimeAndTypesWithoutColons)))\n+        token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       _ => {"}, {"sha": "27a00290ee01ea81e8502b256102eca808ec7f17", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -192,15 +192,15 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 panictry!(p.check_unknown_macro_variable());\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n-                return box ParserAnyMacro {\n+                return Box::new(ParserAnyMacro {\n                     parser: RefCell::new(p),\n \n                     // Pass along the original expansion site and the name of the macro\n                     // so we can print a useful error message if the parse of the expanded\n                     // macro leaves unparsed tokens.\n                     site_span: sp,\n                     macro_ident: name\n-                }\n+                })\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -281,12 +281,12 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n-    let exp: Box<_> = box MacroRulesMacroExpander {\n+    let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n-    };\n+    });\n \n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }"}, {"sha": "368a9f0c27e56fd3e721693bd308702c82d5c75f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -294,9 +294,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             // sidestep the interpolation tricks for ident because\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n-                            MatchedNonterminal(NtIdent(box sn, b)) => {\n+                            MatchedNonterminal(NtIdent(ref sn, b)) => {\n                                 r.cur_span = sp;\n-                                r.cur_tok = token::Ident(sn, b);\n+                                r.cur_tok = token::Ident(**sn, b);\n                                 return ret_val;\n                             }\n                             MatchedNonterminal(ref other_whole_nt) => {"}, {"sha": "8ba36cefc65dd49bf80d897d6d8d0ae1399dadc6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -677,10 +677,10 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(box id, is_mod_name) =>\n-            token::NtIdent(box fld.fold_ident(id), is_mod_name),\n+        token::NtIdent(id, is_mod_name) =>\n+            token::NtIdent(Box::new(fld.fold_ident(*id)), is_mod_name),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n-        token::NtPath(box path) => token::NtPath(box fld.fold_path(path)),\n+        token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n     }\n }"}, {"sha": "d8beeb6a5503b2e9599de4369d7571536a8cb60e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -25,19 +25,13 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(libc)]\n-#![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(slice_patterns)]\n \n extern crate arena;\n extern crate fmt_macros;\n@@ -98,6 +92,7 @@ pub mod parse;\n pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n+pub mod str;\n pub mod test;\n pub mod visit;\n "}, {"sha": "fb3a96f4c2887fdbd2b5c2875d239f50a37c9dc5", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -13,11 +13,12 @@ pub use self::CommentStyle::*;\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n-use parse::lexer::{is_whitespace, Reader};\n-use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::is_block_doc_comment;\n+use parse::lexer::{StringReader, TokenAndSpan};\n+use parse::lexer::{is_whitespace, Reader};\n use parse::lexer;\n use print::pprust;\n+use str::char_at;\n \n use std::io::Read;\n use std::usize;\n@@ -209,7 +210,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let mut col = col.to_usize();\n     let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n-        let ch = s.char_at(cursor);\n+        let ch = char_at(s, cursor);\n         if !ch.is_whitespace() {\n             return None;\n         }\n@@ -246,7 +247,7 @@ fn read_block_comment(rdr: &mut StringReader,\n     rdr.bump();\n     rdr.bump();\n \n-    let mut curr_line = String::from_str(\"/*\");\n+    let mut curr_line = String::from(\"/*\");\n \n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !rdr.nextch_is('*')) || rdr.curr_is('!') {"}, {"sha": "8e37b983e21e0425e845223056e33dcecdd6b097", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -13,10 +13,11 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use diagnostic::SpanHandler;\n use ext::tt::transcribe::tt_next_token;\n-use parse::token;\n use parse::token::str_to_ident;\n+use parse::token;\n+use str::char_at;\n \n-use std::borrow::{IntoCow, Cow};\n+use std::borrow::Cow;\n use std::char;\n use std::fmt;\n use std::mem::replace;\n@@ -289,31 +290,31 @@ impl<'a> StringReader<'a> {\n                           s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n-            let ch = s.char_at(i);\n+            let ch = char_at(s, i);\n             let next = i + ch.len_utf8();\n             if ch == '\\r' {\n-                if next < s.len() && s.char_at(next) == '\\n' {\n-                    return translate_crlf_(self, start, s, errmsg, i).into_cow();\n+                if next < s.len() && char_at(s, next) == '\\n' {\n+                    return translate_crlf_(self, start, s, errmsg, i).into();\n                 }\n                 let pos = start + BytePos(i as u32);\n                 let end_pos = start + BytePos(next as u32);\n                 self.err_span_(pos, end_pos, errmsg);\n             }\n             i = next;\n         }\n-        return s.into_cow();\n+        return s.into();\n \n         fn translate_crlf_(rdr: &StringReader, start: BytePos,\n                         s: &str, errmsg: &str, mut i: usize) -> String {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n-                let ch = s.char_at(i);\n+                let ch = char_at(s, i);\n                 let next = i + ch.len_utf8();\n                 if ch == '\\r' {\n                     if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n-                    if next >= s.len() || s.char_at(next) != '\\n' {\n+                    if next >= s.len() || char_at(s, next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n                         let end_pos = start + BytePos(next as u32);\n                         rdr.err_span_(pos, end_pos, errmsg);\n@@ -335,7 +336,7 @@ impl<'a> StringReader<'a> {\n         if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let ch = self.source_text.char_at(current_byte_offset);\n+            let ch = char_at(&self.source_text, current_byte_offset);\n             let next = current_byte_offset + ch.len_utf8();\n             let byte_offset_diff = next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n@@ -357,7 +358,7 @@ impl<'a> StringReader<'a> {\n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         if offset < self.source_text.len() {\n-            Some(self.source_text.char_at(offset))\n+            Some(char_at(&self.source_text, offset))\n         } else {\n             None\n         }\n@@ -371,9 +372,9 @@ impl<'a> StringReader<'a> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n-        let next = offset + s.char_at(offset).len_utf8();\n+        let next = offset + char_at(s, offset).len_utf8();\n         if next < s.len() {\n-            Some(s.char_at(next))\n+            Some(char_at(s, next))\n         } else {\n             None\n         }\n@@ -564,7 +565,7 @@ impl<'a> StringReader<'a> {\n                 let string = if has_cr {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n-                } else { string.into_cow() };\n+                } else { string.into() };\n                 token::DocComment(token::intern(&string[..]))\n             } else {\n                 token::Comment"}, {"sha": "1333e27058f1db90e6a857ed567b2b1c91fc5db8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -16,7 +16,7 @@ use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto, FatalError\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use ptr::P;\n-\n+use str::char_at;\n \n use std::cell::{Cell, RefCell};\n use std::fs::File;\n@@ -288,7 +288,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n     let srdr = lexer::StringReader::new(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser::new(sess, cfg, box srdr);\n+    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n     panictry!(p1.parse_all_token_trees())\n }\n \n@@ -297,7 +297,7 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n-    let mut p = Parser::new(sess, cfg, box trdr);\n+    let mut p = Parser::new(sess, cfg, Box::new(trdr));\n     panictry!(p.check_unknown_macro_variable());\n     p\n }\n@@ -360,7 +360,7 @@ pub mod with_hygiene {\n         use super::lexer::make_reader_with_embedded_idents as make_reader;\n         let cfg = Vec::new();\n         let srdr = make_reader(&sess.span_diagnostic, filemap);\n-        let mut p1 = Parser::new(sess, cfg, box srdr);\n+        let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n         panictry!(p1.parse_all_token_trees())\n     }\n }\n@@ -536,7 +536,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n // check if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n-        first_chars.contains(&s.char_at(0)) &&\n+        first_chars.contains(&char_at(s, 0)) &&\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n@@ -673,8 +673,8 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     let orig = s;\n     let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n \n-    if s.char_at(0) == '0' && s.len() > 1 {\n-        match s.char_at(1) {\n+    if char_at(s, 0) == '0' && s.len() > 1 {\n+        match char_at(s, 1) {\n             'x' => base = 16,\n             'o' => base = 8,\n             'b' => base = 2,\n@@ -834,28 +834,44 @@ mod test {\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n         let tts: &[ast::TokenTree] = &tts[..];\n-        match tts {\n-            [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n-             ast::TtToken(_, token::Not),\n-             ast::TtToken(_, token::Ident(name_zip, token::Plain)),\n-             ast::TtDelimited(_, ref macro_delimed)]\n+\n+        match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n+            (\n+                4,\n+                Some(&ast::TtToken(_, token::Ident(name_macro_rules, token::Plain))),\n+                Some(&ast::TtToken(_, token::Not)),\n+                Some(&ast::TtToken(_, token::Ident(name_zip, token::Plain))),\n+                Some(&ast::TtDelimited(_, ref macro_delimed)),\n+            )\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match &macro_delimed.tts[..] {\n-                    [ast::TtDelimited(_, ref first_delimed),\n-                     ast::TtToken(_, token::FatArrow),\n-                     ast::TtDelimited(_, ref second_delimed)]\n+                let tts = &macro_delimed.tts[..];\n+                match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n+                    (\n+                        3,\n+                        Some(&ast::TtDelimited(_, ref first_delimed)),\n+                        Some(&ast::TtToken(_, token::FatArrow)),\n+                        Some(&ast::TtDelimited(_, ref second_delimed)),\n+                    )\n                     if macro_delimed.delim == token::Paren => {\n-                        match &first_delimed.tts[..] {\n-                            [ast::TtToken(_, token::Dollar),\n-                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                        let tts = &first_delimed.tts[..];\n+                        match (tts.len(), tts.get(0), tts.get(1)) {\n+                            (\n+                                2,\n+                                Some(&ast::TtToken(_, token::Dollar)),\n+                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                            )\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n-                        match &second_delimed.tts[..] {\n-                            [ast::TtToken(_, token::Dollar),\n-                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                        let tts = &second_delimed.tts[..];\n+                        match (tts.len(), tts.get(0), tts.get(1)) {\n+                            (\n+                                2,\n+                                Some(&ast::TtToken(_, token::Dollar)),\n+                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                            )\n                             if second_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),"}, {"sha": "796bc2a3513f3d02a972b312c541971c9ea3c5f1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -78,6 +78,7 @@ use parse::PResult;\n use diagnostic::FatalError;\n \n use std::collections::HashSet;\n+use std::fs;\n use std::io::prelude::*;\n use std::mem;\n use std::path::{Path, PathBuf};\n@@ -436,10 +437,11 @@ impl<'a> Parser<'a> {\n             // leave it in the input\n             Ok(())\n         } else {\n-            let mut expected = edible.iter().map(|x| TokenType::Token(x.clone()))\n-                                            .collect::<Vec<_>>();\n-            expected.extend(inedible.iter().map(|x| TokenType::Token(x.clone())));\n-            expected.push_all(&*self.expected_tokens);\n+            let mut expected = edible.iter()\n+                .map(|x| TokenType::Token(x.clone()))\n+                .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n+                .chain(self.expected_tokens.iter().cloned())\n+                .collect::<Vec<_>>();\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n             let expect = tokens_to_string(&expected[..]);\n@@ -490,8 +492,10 @@ impl<'a> Parser<'a> {\n         debug!(\"commit_expr {:?}\", e);\n         if let ExprPath(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n-            let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n-            expected.push_all(inedible);\n+            let expected = edible.iter()\n+                .cloned()\n+                .chain(inedible.iter().cloned())\n+                .collect::<Vec<_>>();\n             try!(self.check_for_erroneous_unit_struct_expecting(&expected[..]));\n         }\n         self.expect_one_of(edible, inedible)\n@@ -509,8 +513,10 @@ impl<'a> Parser<'a> {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n-            let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n-            expected.push_all(&inedible);\n+            let expected = edible.iter()\n+                .cloned()\n+                .chain(inedible.iter().cloned())\n+                .collect::<Vec<_>>();\n             try!(self.check_for_erroneous_unit_struct_expecting(&expected));\n         }\n         self.expect_one_of(edible, inedible)\n@@ -897,7 +903,7 @@ impl<'a> Parser<'a> {\n         self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         self.last_token = if self.token.is_ident() || self.token.is_path() {\n-            Some(box self.token.clone())\n+            Some(Box::new(self.token.clone()))\n         } else {\n             None\n         };\n@@ -1187,7 +1193,7 @@ impl<'a> Parser<'a> {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         try!(p.parse_inner_attrs_and_block());\n-                    attrs.push_all(&inner_attrs[..]);\n+                    attrs.extend(inner_attrs.iter().cloned());\n                     Some(body)\n                   }\n \n@@ -1578,8 +1584,8 @@ impl<'a> Parser<'a> {\n             token::Interpolated(token::NtPath(_)) => Some(try!(self.bump_and_get())),\n             _ => None,\n         };\n-        if let Some(token::Interpolated(token::NtPath(box path))) = found {\n-            return Ok(path);\n+        if let Some(token::Interpolated(token::NtPath(path))) = found {\n+            return Ok(*path);\n         }\n \n         let lo = self.span.lo;\n@@ -4770,8 +4776,8 @@ impl<'a> Parser<'a> {\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(&default_path_str[..]);\n                 let secondary_path = dir_path.join(&secondary_path_str[..]);\n-                let default_exists = default_path.exists();\n-                let secondary_exists = secondary_path.exists();\n+                let default_exists = fs::metadata(&default_path).is_ok();\n+                let secondary_exists = fs::metadata(&secondary_path).is_ok();\n \n                 if !self.owns_directory {\n                     self.span_err(id_sp,\n@@ -4834,7 +4840,7 @@ impl<'a> Parser<'a> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n-                let mut err = String::from_str(\"circular modules: \");\n+                let mut err = String::from(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in &included_mod_stack[i.. len] {\n                     err.push_str(&p.to_string_lossy());"}, {"sha": "15aaf9cf390fd18c0110aed288fdec802858cc29", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -131,7 +131,7 @@ pub fn buf_str(toks: &[Token],\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = string::String::from_str(\"[\");\n+    let mut s = string::String::from(\"[\");\n     while i != right && l != 0 {\n         l -= 1;\n         if i != left {"}, {"sha": "5a57e09fcfff2a4fb5b9625da34a5db36e085271", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -28,7 +28,7 @@ use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n \n-use std::{ascii, mem};\n+use std::ascii;\n use std::io::{self, Write, Read};\n use std::iter;\n \n@@ -187,18 +187,13 @@ impl<'a> State<'a> {\n pub fn to_string<F>(f: F) -> String where\n     F: FnOnce(&mut State) -> io::Result<()>,\n {\n-    use std::raw::TraitObject;\n-    let mut s = rust_printer(box Vec::new());\n-    f(&mut s).unwrap();\n-    eof(&mut s.s).unwrap();\n-    let wr = unsafe {\n-        // FIXME(pcwalton): A nasty function to extract the string from an `Write`\n-        // that we \"know\" to be a `Vec<u8>` that works around the lack of checked\n-        // downcasts.\n-        let obj: &TraitObject = mem::transmute(&s.s.out);\n-        mem::transmute::<*mut (), &Vec<u8>>(obj.data)\n-    };\n-    String::from_utf8(wr.clone()).unwrap()\n+    let mut wr = Vec::new();\n+    {\n+        let mut printer = rust_printer(Box::new(&mut wr));\n+        f(&mut printer).unwrap();\n+        eof(&mut printer.s).unwrap();\n+    }\n+    String::from_utf8(wr).unwrap()\n }\n \n pub fn binop_to_string(op: BinOpToken) -> &'static str {\n@@ -2799,13 +2794,13 @@ impl<'a> State<'a> {\n         match lit.node {\n             ast::LitStr(ref st, style) => self.print_string(&st, style),\n             ast::LitByte(byte) => {\n-                let mut res = String::from_str(\"b'\");\n+                let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n                 word(&mut self.s, &res[..])\n             }\n             ast::LitChar(ch) => {\n-                let mut res = String::from_str(\"'\");\n+                let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n                 word(&mut self.s, &res[..])"}, {"sha": "83e321f110c5875dfb39694307fbde3afd1f94f1", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -52,7 +52,7 @@ pub struct P<T> {\n /// Construct a `P<T>` from a `T` value.\n pub fn P<T: 'static>(value: T) -> P<T> {\n     P {\n-        ptr: box value\n+        ptr: Box::new(value)\n     }\n }\n "}, {"sha": "d0f47629b10e5b42fd877c563c6d299e9097b85f", "filename": "src/libsyntax/str.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstr.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn char_at(s: &str, byte: usize) -> char {\n+    s[byte..].chars().next().unwrap()\n+}"}, {"sha": "6adeb30a94ec4d3c68f8a8af5bfe2d3f2e218edc", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -15,6 +15,7 @@ use parse::new_parser_from_source_str;\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n+use str::char_at;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n@@ -96,24 +97,24 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n         else if idx_a == a.len() {return false;}\n         else if idx_b == b.len() {\n             // maybe the stuff left in a is all ws?\n-            if is_whitespace(a.char_at(idx_a)) {\n+            if is_whitespace(char_at(a, idx_a)) {\n                 return scan_for_non_ws_or_end(a,idx_a) == a.len();\n             } else {\n                 return false;\n             }\n         }\n         // ws in both given and pattern:\n-        else if is_whitespace(a.char_at(idx_a))\n-           && is_whitespace(b.char_at(idx_b)) {\n+        else if is_whitespace(char_at(a, idx_a))\n+           && is_whitespace(char_at(b, idx_b)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n             idx_b = scan_for_non_ws_or_end(b,idx_b);\n         }\n         // ws in given only:\n-        else if is_whitespace(a.char_at(idx_a)) {\n+        else if is_whitespace(char_at(a, idx_a)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n         }\n         // *don't* silently eat ws in expected only.\n-        else if a.char_at(idx_a) == b.char_at(idx_b) {\n+        else if char_at(a, idx_a) == char_at(b, idx_b) {\n             idx_a += 1;\n             idx_b += 1;\n         }\n@@ -129,7 +130,7 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n     let mut i = idx;\n     let len = a.len();\n-    while (i < len) && (is_whitespace(a.char_at(i))) {\n+    while (i < len) && (is_whitespace(char_at(a, i))) {\n         i += 1;\n     }\n     i"}, {"sha": "153f9d4a26df155dd4773cb2a22ecdc4a32ae985", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=37a1f2e3acc75e8a3d0fd47bb345b2cd880b2937", "patch": "@@ -64,7 +64,10 @@ impl<T> SmallVector<T> {\n                 let result: &[T] = &[];\n                 result\n             }\n-            One(ref v) => slice::ref_slice(v),\n+            One(ref v) => {\n+                // FIXME: Could be replaced with `slice::ref_slice(v)` when it is stable.\n+                unsafe { slice::from_raw_parts(v, 1) }\n+            }\n             Many(ref vs) => vs\n         }\n     }"}]}