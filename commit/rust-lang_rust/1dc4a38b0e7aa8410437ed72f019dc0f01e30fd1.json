{"sha": "1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzRhMzhiMGU3YWE4NDEwNDM3ZWQ3MmYwMTlkYzBmMDFlMzBmZDE=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-05-03T01:15:44Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-05-03T01:15:44Z"}, "message": "Fix potential integer overflow in SGX memory range calculation.\n\nThanks to Eduard Marin and David Oswald at the University of Burmingham,\nand Jo Van Bulck at KU Leuven for discovering this issue.", "tree": {"sha": "8bd3b9e69af211fe3d95371f7bfc6cbc26728dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd3b9e69af211fe3d95371f7bfc6cbc26728dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "html_url": "https://github.com/rust-lang/rust/commit/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1/comments", "author": null, "committer": null, "parents": [{"sha": "08bfe16129b0621bc90184f8704523d4929695ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/08bfe16129b0621bc90184f8704523d4929695ef", "html_url": "https://github.com/rust-lang/rust/commit/08bfe16129b0621bc90184f8704523d4929695ef"}], "stats": {"total": 24, "additions": 17, "deletions": 7}, "files": [{"sha": "d9051733da24dace89662b70f3fd479bdfbfc1a8", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "patch": "@@ -27,19 +27,23 @@ pub fn image_base() -> u64 {\n }\n \n /// Returns `true` if the specified memory range is in the enclave.\n+///\n+/// `p + len` must not overflow.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n-    let start=p as u64;\n-    let end=start + (len as u64);\n+    let start = p as u64;\n+    let end = start + (len as u64);\n     start >= image_base() &&\n         end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n }\n \n /// Returns `true` if the specified memory range is in userspace.\n+///\n+/// `p + len` must not overflow.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n-    let start=p as u64;\n-    let end=start + (len as u64);\n+    let start = p as u64;\n+    let end = start + (len as u64);\n     end <= image_base() ||\n         start >= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n }"}, {"sha": "c9ff53d0a4fd656497a932681dba9cb0ead346fc", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=1dc4a38b0e7aa8410437ed72f019dc0f01e30fd1", "patch": "@@ -85,8 +85,10 @@ pub unsafe trait UserSafe {\n     ///\n     /// * the pointer is not aligned.\n     /// * the pointer is null.\n+    /// * the pointed-to range does not fit in the address space.\n     /// * the pointed-to range is not in user memory.\n     unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n+        assert!(ptr.wrapping_add(size) >= ptr);\n         let ret = Self::from_raw_sized_unchecked(ptr, size);\n         Self::check_ptr(ret);\n         NonNull::new_unchecked(ret as _)\n@@ -268,6 +270,7 @@ impl<T> User<[T]> where [T]: UserSafe {\n     ///\n     /// * The pointer is not aligned\n     /// * The pointer is null\n+    /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n         User(NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>())))\n@@ -372,6 +375,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     ///\n     /// * The pointer is not aligned\n     /// * The pointer is null\n+    /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n         &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n@@ -389,6 +393,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     ///\n     /// * The pointer is not aligned\n     /// * The pointer is null\n+    /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n         &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n@@ -552,10 +557,11 @@ impl UserRef<super::raw::ByteBuffer> {\n     /// enclave memory.\n     ///\n     /// # Panics\n-    /// This function panics if:\n+    /// This function panics if, in the user `ByteBuffer`:\n     ///\n-    /// * The pointer in the user `ByteBuffer` is null\n-    /// * The pointed-to range in the user `ByteBuffer` is not in user memory\n+    /// * The pointer is null\n+    /// * The pointed-to range does not fit in the address space\n+    /// * The pointed-to range is not in user memory\n     pub fn copy_user_buffer(&self) -> Vec<u8> {\n         unsafe {\n             let buf = self.to_enclave();"}]}