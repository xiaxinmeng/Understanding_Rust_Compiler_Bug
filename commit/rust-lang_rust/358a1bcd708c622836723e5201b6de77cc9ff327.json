{"sha": "358a1bcd708c622836723e5201b6de77cc9ff327", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1OGExYmNkNzA4YzYyMjgzNjcyM2U1MjAxYjZkZTc3Y2M5ZmYzMjc=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-21T00:11:41Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-21T00:11:41Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "aeff9c96a6059fa2b02e7c87ec88753bc7993d8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeff9c96a6059fa2b02e7c87ec88753bc7993d8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/358a1bcd708c622836723e5201b6de77cc9ff327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/358a1bcd708c622836723e5201b6de77cc9ff327", "html_url": "https://github.com/rust-lang/rust/commit/358a1bcd708c622836723e5201b6de77cc9ff327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/358a1bcd708c622836723e5201b6de77cc9ff327/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e2d090ab8a9bda18f148b894b7948eb05b976e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2d090ab8a9bda18f148b894b7948eb05b976e6", "html_url": "https://github.com/rust-lang/rust/commit/1e2d090ab8a9bda18f148b894b7948eb05b976e6"}, {"sha": "612a72fc4ea4376920f2a7da7b3c334227c1716c", "url": "https://api.github.com/repos/rust-lang/rust/commits/612a72fc4ea4376920f2a7da7b3c334227c1716c", "html_url": "https://github.com/rust-lang/rust/commit/612a72fc4ea4376920f2a7da7b3c334227c1716c"}], "stats": {"total": 2518, "additions": 1451, "deletions": 1067}, "files": [{"sha": "560ab30752c57e17e0c9f3f40340f4dda6c2a51b", "filename": ".cargo/config", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -2,3 +2,4 @@\n xtask = \"run --package xtask --bin xtask --\"\n install-ra = \"run --package xtask --bin xtask -- install\" # for backwards compat\n tq = \"test -- -q\"\n+qt = \"tq\""}, {"sha": "ea1c25d7f129eb9ed1830e4747c3b4d62bd6bb73", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -58,6 +58,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n * API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/\n \n+\n ## License\n \n Rust analyzer is primarily distributed under the terms of both the MIT"}, {"sha": "cef669cb5ca0192f625f72d4aac7ee9d13cd396d", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -174,7 +174,7 @@ fn resolve_target_trait_def(\n         .path()?;\n \n     match analyzer.resolve_path(db, &ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).ast),\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).value),\n         _ => None,\n     }\n }"}, {"sha": "b5f8afb4e77070331e826f3f34b29a260a0231f3", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -141,7 +141,7 @@ fn find_struct_impl(\n     })?;\n \n     let struct_ty = {\n-        let src = hir::Source { file_id: ctx.frange.file_id.into(), ast: strukt.clone() };\n+        let src = hir::Source { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n         hir::Struct::from_source(db, src).unwrap().ty(db)\n     };\n \n@@ -152,7 +152,7 @@ fn find_struct_impl(\n             return false;\n         }\n \n-        let src = hir::Source { file_id: ctx.frange.file_id.into(), ast: impl_blk.clone() };\n+        let src = hir::Source { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n         let blk = hir::ImplBlock::from_source(db, src).unwrap();\n \n         let same_ty = blk.target_ty(db) == struct_ty;"}, {"sha": "9354466d9640ea3f766148eb9d827885a2e95310", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -84,7 +84,7 @@ fn resolve_enum_def(\n     let expr_ty = analyzer.type_of(db, &expr)?;\n \n     analyzer.autoderef(db, expr_ty).find_map(|ty| match ty.as_adt() {\n-        Some((Adt::Enum(e), _)) => Some(e.source(db).ast),\n+        Some((Adt::Enum(e), _)) => Some(e.source(db).value),\n         _ => None,\n     })\n }"}, {"sha": "3272801ff81081738ae1eb5310051b53d187968a", "filename": "crates/ra_assists/src/assists/replace_if_let_with_match.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -66,8 +66,8 @@ fn build_match_expr(\n \n fn format_arm(block: &ast::BlockExpr) -> String {\n     match extract_trivial_expression(block) {\n-        None => block.syntax().text().to_string(),\n-        Some(e) => format!(\"{},\", e.syntax().text()),\n+        Some(e) if !e.syntax().text().contains_char('\\n') => format!(\"{},\", e.syntax().text()),\n+        _ => block.syntax().text().to_string(),\n     }\n }\n \n@@ -102,6 +102,34 @@ impl VariantData {\n         )\n     }\n \n+    #[test]\n+    fn test_replace_if_let_with_match_doesnt_unwrap_multiline_expressions() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            \"\n+fn foo() {\n+    if <|>let VariantData::Struct(..) = a {\n+        bar(\n+            123\n+        )\n+    } else {\n+        false\n+    }\n+}           \",\n+            \"\n+fn foo() {\n+    <|>match a {\n+        VariantData::Struct(..) => {\n+            bar(\n+                123\n+            )\n+        }\n+        _ => false,\n+    }\n+}           \",\n+        )\n+    }\n+\n     #[test]\n     fn replace_if_let_with_match_target() {\n         check_assist_target("}, {"sha": "9cd21e4b6ef5eb019daa391aed91e389b58062dd", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -98,7 +98,7 @@ pub fn run(\n             let src = f.source(db);\n             let original_file = src.file_id.original_file(db);\n             let path = db.file_relative_path(original_file);\n-            let syntax_range = src.ast.syntax().text_range();\n+            let syntax_range = src.value.syntax().text_range();\n             write!(msg, \" ({:?} {})\", path, syntax_range).unwrap();\n         }\n         bar.set_message(&msg);\n@@ -135,7 +135,7 @@ pub fn run(\n                         let path = db.file_relative_path(original_file);\n                         let line_index = host.analysis().file_line_index(original_file).unwrap();\n                         let text_range = src\n-                            .ast\n+                            .value\n                             .either(|it| it.syntax().text_range(), |it| it.syntax().text_range());\n                         let (start, end) = (\n                             line_index.line_col(text_range.start()),"}, {"sha": "10f592257c13ecaee117a95cf9377b97b73a31e3", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -38,9 +38,6 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n pub fn extract_trivial_expression(expr: &ast::BlockExpr) -> Option<ast::Expr> {\n     let block = expr.block()?;\n     let expr = block.expr()?;\n-    if expr.syntax().text().contains_char('\\n') {\n-        return None;\n-    }\n     let non_trivial_children = block.syntax().children().filter(|it| match it.kind() {\n         WHITESPACE | T!['{'] | T!['}'] => false,\n         _ => it != expr.syntax(),"}, {"sha": "945f236c22e7ac2a5ed1f472e2c3468564a44628", "filename": "crates/ra_hir/src/adt.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1e2d090ab8a9bda18f148b894b7948eb05b976e6/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2d090ab8a9bda18f148b894b7948eb05b976e6/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=1e2d090ab8a9bda18f148b894b7948eb05b976e6", "patch": "@@ -1,54 +0,0 @@\n-//! This module contains the implementation details of the HIR for ADTs, i.e.\n-//! structs and enums (and unions).\n-\n-use std::sync::Arc;\n-\n-use hir_def::adt::VariantData;\n-\n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    EnumVariant, Module, Name, Struct, StructField,\n-};\n-\n-impl Struct {\n-    pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n-        db.struct_data(self.id.into()).variant_data.clone()\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum VariantDef {\n-    Struct(Struct),\n-    EnumVariant(EnumVariant),\n-}\n-impl_froms!(VariantDef: Struct, EnumVariant);\n-\n-impl VariantDef {\n-    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n-        match self {\n-            VariantDef::Struct(it) => it.fields(db),\n-            VariantDef::EnumVariant(it) => it.fields(db),\n-        }\n-    }\n-\n-    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n-        match self {\n-            VariantDef::Struct(it) => it.field(db, name),\n-            VariantDef::EnumVariant(it) => it.field(db, name),\n-        }\n-    }\n-\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n-        match self {\n-            VariantDef::Struct(it) => it.module(db),\n-            VariantDef::EnumVariant(it) => it.module(db),\n-        }\n-    }\n-\n-    pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n-        match self {\n-            VariantDef::Struct(it) => it.variant_data(db),\n-            VariantDef::EnumVariant(it) => it.variant_data(db),\n-        }\n-    }\n-}"}, {"sha": "a132d128b57162abe5e640cccdcbb4f490e90594", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 106, "deletions": 172, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -10,8 +10,10 @@ use hir_def::{\n     adt::VariantData,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n+    traits::TraitData,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+    AssocItemId, ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId,\n+    LocalStructFieldId, Lookup, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -21,16 +23,14 @@ use ra_db::{CrateId, Edition};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n-    adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     generics::{GenericDef, HasGenericParams},\n     ids::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n         TypeAliasId,\n     },\n-    resolve::{Resolver, Scope, TypeNs},\n-    traits::TraitData,\n+    resolve::{HasResolver, TypeNs},\n     ty::{InferenceResult, Namespace, TraitRef},\n     Either, HasSource, ImportId, Name, ScopeDef, Source, Ty,\n };\n@@ -139,7 +139,7 @@ impl Module {\n     ) -> Either<ast::UseTree, ast::ExternCrateItem> {\n         let src = self.definition_source(db);\n         let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n-        source_map.get(&src.ast, import)\n+        source_map.get(&src.value, import)\n     }\n \n     /// Returns the crate this module is part of.\n@@ -206,7 +206,7 @@ impl Module {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n                 crate::ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n-                    if let ModuleSource::Module(_) = m.definition_source(db).ast {\n+                    if let ModuleSource::Module(_) = m.definition_source(db).value {\n                         m.diagnostics(db, sink)\n                     }\n                 }\n@@ -223,22 +223,9 @@ impl Module {\n         }\n     }\n \n-    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.id.krate);\n-        Resolver::default().push_module_scope(def_map, self.id.module_id)\n-    }\n-\n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.module_id]\n-            .scope\n-            .entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n-            .map(ModuleDef::from)\n-            .collect()\n+        def_map[self.id.module_id].scope.declarations().map(ModuleDef::from).collect()\n     }\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n@@ -323,15 +310,8 @@ impl Struct {\n         db.type_for_def(self.into(), Namespace::Values)\n     }\n \n-    // FIXME move to a more general type\n-    /// Builds a resolver for type references inside this struct.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self.module(db).resolver(db);\n-        // ...and add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r\n+    fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+        db.struct_data(self.id.into()).variant_data.clone()\n     }\n }\n \n@@ -345,24 +325,13 @@ impl Union {\n         db.struct_data(self.id.into()).name.clone()\n     }\n \n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         Module { id: self.id.0.module(db) }\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def(self.into(), Namespace::Types)\n     }\n-\n-    // FIXME move to a more general type\n-    /// Builds a resolver for type references inside this union.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self.module(db).resolver(db);\n-        // ...and add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -402,17 +371,6 @@ impl Enum {\n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def(self.into(), Namespace::Types)\n     }\n-\n-    // FIXME: move to a more general type\n-    /// Builds a resolver for type references inside this struct.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self.module(db).resolver(db);\n-        // ...and add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r.push_scope(Scope::AdtScope(self.into()))\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -474,22 +432,52 @@ impl Adt {\n         }\n     }\n \n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n+        match self {\n+            Adt::Struct(s) => s.module(db),\n+            Adt::Union(s) => s.module(db),\n+            Adt::Enum(e) => e.module(db),\n+        }\n+    }\n+\n     pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        Some(\n-            match self {\n-                Adt::Struct(s) => s.module(db),\n-                Adt::Union(s) => s.module(db),\n-                Adt::Enum(e) => e.module(db),\n-            }\n-            .krate(),\n-        )\n+        Some(self.module(db).krate())\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum VariantDef {\n+    Struct(Struct),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(VariantDef: Struct, EnumVariant);\n+\n+impl VariantDef {\n+    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+        match self {\n+            VariantDef::Struct(it) => it.fields(db),\n+            VariantDef::EnumVariant(it) => it.fields(db),\n+        }\n+    }\n+\n+    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        match self {\n+            VariantDef::Struct(it) => it.field(db, name),\n+            VariantDef::EnumVariant(it) => it.field(db, name),\n+        }\n+    }\n+\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n+        match self {\n+            VariantDef::Struct(it) => it.module(db),\n+            VariantDef::EnumVariant(it) => it.module(db),\n+        }\n     }\n \n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n+    pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         match self {\n-            Adt::Struct(it) => it.resolver(db),\n-            Adt::Union(it) => it.resolver(db),\n-            Adt::Enum(it) => it.resolver(db),\n+            VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::EnumVariant(it) => it.variant_data(db),\n         }\n     }\n }\n@@ -505,15 +493,6 @@ pub enum DefWithBody {\n impl_froms!(DefWithBody: Function, Const, Static);\n \n impl DefWithBody {\n-    /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        match self {\n-            DefWithBody::Const(c) => c.resolver(db),\n-            DefWithBody::Function(f) => f.resolver(db),\n-            DefWithBody::Static(s) => s.resolver(db),\n-        }\n-    }\n-\n     pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n         match self {\n             DefWithBody::Const(c) => c.krate(db),\n@@ -598,10 +577,10 @@ impl FnData {\n         func: Function,\n     ) -> Arc<FnData> {\n         let src = func.source(db);\n-        let name = src.ast.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n+        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n         let mut params = Vec::new();\n         let mut has_self_param = false;\n-        if let Some(param_list) = src.ast.param_list() {\n+        if let Some(param_list) = src.value.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n@@ -625,7 +604,7 @@ impl FnData {\n                 params.push(type_ref);\n             }\n         }\n-        let ret_type = if let Some(type_ref) = src.ast.ret_type().and_then(|rt| rt.type_ref()) {\n+        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n             TypeRef::from_ast(type_ref)\n         } else {\n             TypeRef::unit()\n@@ -655,7 +634,7 @@ impl FnData {\n \n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        self.id.lookup(db).module(db).into()\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n@@ -688,35 +667,28 @@ impl Function {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        ImplBlock::containing(db, self.into())\n+        match self.container(db) {\n+            Some(Container::ImplBlock(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     /// The containing trait, if this is a trait method definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        match self.container(db) {\n+            Some(Container::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        if let Some(impl_block) = self.impl_block(db) {\n-            Some(impl_block.into())\n-        } else if let Some(trait_) = self.parent_trait(db) {\n-            Some(trait_.into())\n-        } else {\n-            None\n+        match self.id.lookup(db).container {\n+            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n+            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n+            ContainerId::ModuleId(_) => None,\n         }\n     }\n \n-    // FIXME: move to a more general type for 'body-having' items\n-    /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self.container(db).map_or_else(|| self.module(db).resolver(db), |c| c.resolver(db));\n-        // ...and add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r\n-    }\n-\n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n         let infer = self.infer(db);\n         infer.add_diagnostics(db, self, sink);\n@@ -732,7 +704,7 @@ pub struct Const {\n \n impl Const {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n@@ -751,35 +723,29 @@ impl Const {\n         db.infer(self.into())\n     }\n \n-    /// The containing impl block, if this is a method.\n+    /// The containing impl block, if this is a type alias.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        ImplBlock::containing(db, self.into())\n+        match self.container(db) {\n+            Some(Container::ImplBlock(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n+    /// The containing trait, if this is a trait type alias definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        match self.container(db) {\n+            Some(Container::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        if let Some(impl_block) = self.impl_block(db) {\n-            Some(impl_block.into())\n-        } else if let Some(trait_) = self.parent_trait(db) {\n-            Some(trait_.into())\n-        } else {\n-            None\n+        match self.id.lookup(db).container {\n+            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n+            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n+            ContainerId::ModuleId(_) => None,\n         }\n     }\n-\n-    // FIXME: move to a more general type for 'body-having' items\n-    /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self\n-            .impl_block(db)\n-            .map(|ib| ib.resolver(db))\n-            .unwrap_or_else(|| self.module(db).resolver(db));\n-        r\n-    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -801,15 +767,15 @@ impl ConstData {\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Const,\n     ) -> Arc<ConstData> {\n-        let node = konst.source(db).ast;\n+        let node = konst.source(db).value;\n         const_data_for(&node)\n     }\n \n     pub(crate) fn static_data_query(\n         db: &(impl DefDatabase + AstDatabase),\n         konst: Static,\n     ) -> Arc<ConstData> {\n-        let node = konst.source(db).ast;\n+        let node = konst.source(db).value;\n         const_data_for(&node)\n     }\n }\n@@ -839,12 +805,6 @@ impl Static {\n         db.static_data(self)\n     }\n \n-    /// Builds a resolver for code inside this item.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        self.module(db).resolver(db)\n-    }\n-\n     pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.into())\n     }\n@@ -861,11 +821,11 @@ impl Trait {\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        self.trait_data(db).name().clone()\n+        self.trait_data(db).name.clone()\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        self.trait_data(db).items().to_vec()\n+        self.trait_data(db).items.iter().map(|it| (*it).into()).collect()\n     }\n \n     fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n@@ -912,10 +872,10 @@ impl Trait {\n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = self.trait_data(db);\n         trait_data\n-            .items()\n+            .items\n             .iter()\n             .filter_map(|item| match item {\n-                AssocItem::TypeAlias(t) => Some(*t),\n+                AssocItemId::TypeAliasId(t) => Some(TypeAlias::from(*t)),\n                 _ => None,\n             })\n             .find(|t| &t.name(db) == name)\n@@ -930,23 +890,15 @@ impl Trait {\n     }\n \n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n-        db.trait_data(self)\n+        db.trait_data(self.id)\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n         TraitRef::for_trait(db, self)\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n-        self.trait_data(db).is_auto()\n-    }\n-\n-    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let r = self.module(db).resolver(db);\n-        // add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r\n+        self.trait_data(db).auto\n     }\n }\n \n@@ -957,30 +909,34 @@ pub struct TypeAlias {\n \n impl TypeAlias {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        Module { id: self.id.lookup(db).module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n \n-    /// The containing impl block, if this is a method.\n+    /// The containing impl block, if this is a type alias.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        ImplBlock::containing(db, self.into())\n+        match self.container(db) {\n+            Some(Container::ImplBlock(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n-    /// The containing trait, if this is a trait method definition.\n+    /// The containing trait, if this is a trait type alias definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        match self.container(db) {\n+            Some(Container::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        if let Some(impl_block) = self.impl_block(db) {\n-            Some(impl_block.into())\n-        } else if let Some(trait_) = self.parent_trait(db) {\n-            Some(trait_.into())\n-        } else {\n-            None\n+        match self.id.lookup(db).container {\n+            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n+            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n+            ContainerId::ModuleId(_) => None,\n         }\n     }\n \n@@ -995,19 +951,6 @@ impl TypeAlias {\n     pub fn name(self, db: &impl DefDatabase) -> Name {\n         db.type_alias_data(self).name.clone()\n     }\n-\n-    /// Builds a resolver for the type references in this type alias.\n-    pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n-        // take the outer scope...\n-        let r = self\n-            .impl_block(db)\n-            .map(|ib| ib.resolver(db))\n-            .unwrap_or_else(|| self.module(db).resolver(db));\n-        // ...and add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        r\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -1023,15 +966,6 @@ pub enum Container {\n }\n impl_froms!(Container: Trait, ImplBlock);\n \n-impl Container {\n-    pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        match self {\n-            Container::Trait(trait_) => trait_.resolver(db),\n-            Container::ImplBlock(impl_block) => impl_block.resolver(db),\n-        }\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     Function(Function),"}, {"sha": "9e304217c53d36082843e87401e6ffc7fc1f87c4", "filename": "crates/ra_hir/src/code_model/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fattrs.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -49,9 +49,9 @@ pub(crate) fn attributes_query(\n         AttrDef::Module(it) => {\n             let src = it.declaration_source(db)?;\n             let hygiene = Hygiene::new(db, src.file_id);\n-            Attr::from_attrs_owner(&src.ast, &hygiene)\n+            Attr::from_attrs_owner(&src.value, &hygiene)\n         }\n-        AttrDef::StructField(it) => match it.source(db).ast {\n+        AttrDef::StructField(it) => match it.source(db).value {\n             FieldSource::Named(named) => {\n                 let src = it.source(db);\n                 let hygiene = Hygiene::new(db, src.file_id);\n@@ -82,7 +82,7 @@ where\n {\n     let src = node.source(db);\n     let hygiene = Hygiene::new(db, src.file_id);\n-    Attr::from_attrs_owner(&src.ast, &hygiene)\n+    Attr::from_attrs_owner(&src.value, &hygiene)\n }\n \n impl<T: Into<AttrDef> + Copy> Attrs for T {"}, {"sha": "e40efef34aeb55fef5bd03fc82b3e77a0251068c", "filename": "crates/ra_hir/src/code_model/docs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fdocs.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -70,23 +70,23 @@ pub(crate) fn documentation_query(\n     def: DocDef,\n ) -> Option<Documentation> {\n     match def {\n-        DocDef::Module(it) => docs_from_ast(&it.declaration_source(db)?.ast),\n-        DocDef::StructField(it) => match it.source(db).ast {\n+        DocDef::Module(it) => docs_from_ast(&it.declaration_source(db)?.value),\n+        DocDef::StructField(it) => match it.source(db).value {\n             FieldSource::Named(named) => docs_from_ast(&named),\n             FieldSource::Pos(..) => None,\n         },\n         DocDef::Adt(it) => match it {\n-            Adt::Struct(it) => docs_from_ast(&it.source(db).ast),\n-            Adt::Enum(it) => docs_from_ast(&it.source(db).ast),\n-            Adt::Union(it) => docs_from_ast(&it.source(db).ast),\n+            Adt::Struct(it) => docs_from_ast(&it.source(db).value),\n+            Adt::Enum(it) => docs_from_ast(&it.source(db).value),\n+            Adt::Union(it) => docs_from_ast(&it.source(db).value),\n         },\n-        DocDef::EnumVariant(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::Static(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::Const(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::Function(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::Trait(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::TypeAlias(it) => docs_from_ast(&it.source(db).ast),\n-        DocDef::MacroDef(it) => docs_from_ast(&it.source(db).ast),\n+        DocDef::EnumVariant(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::Static(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::Const(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::Function(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::Trait(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::TypeAlias(it) => docs_from_ast(&it.source(db).value),\n+        DocDef::MacroDef(it) => docs_from_ast(&it.source(db).value),\n     }\n }\n "}, {"sha": "4aa427de43bd3f0e6e1985cac882ef1e9f2743f1", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n+use hir_def::{HasSource as _, Lookup};\n use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n-    adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::AstItemDef,\n     Const, Either, Enum, EnumVariant, FieldSource, Function, HasBody, HirFileId, MacroDef, Module,\n-    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n pub use hir_expand::Source;\n@@ -25,9 +25,9 @@ impl Module {\n         let def_map = db.crate_def_map(self.id.krate);\n         let decl_id = def_map[self.id.module_id].declaration;\n         let file_id = def_map[self.id.module_id].definition;\n-        let ast = ModuleSource::new(db, file_id, decl_id);\n+        let value = ModuleSource::new(db, file_id, decl_id);\n         let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n-        Source { file_id, ast }\n+        Source { file_id, value }\n     }\n \n     /// Returns a node which declares this module, either a `mod foo;` or a `mod foo {}`.\n@@ -38,8 +38,8 @@ impl Module {\n     ) -> Option<Source<ast::Module>> {\n         let def_map = db.crate_def_map(self.id.krate);\n         let decl = def_map[self.id.module_id].declaration?;\n-        let ast = decl.to_node(db);\n-        Some(Source { file_id: decl.file_id(), ast })\n+        let value = decl.to_node(db);\n+        Some(Source { file_id: decl.file_id(), value })\n     }\n }\n \n@@ -53,11 +53,11 @@ impl HasSource for StructField {\n         let (file_id, struct_kind) = match self.parent {\n             VariantDef::Struct(s) => {\n                 ss = s.source(db);\n-                (ss.file_id, ss.ast.kind())\n+                (ss.file_id, ss.value.kind())\n             }\n             VariantDef::EnumVariant(e) => {\n                 es = e.source(db);\n-                (es.file_id, es.ast.kind())\n+                (es.file_id, es.value.kind())\n             }\n         };\n \n@@ -66,13 +66,13 @@ impl HasSource for StructField {\n             ast::StructKind::Named(fl) => fl.fields().map(|it| FieldSource::Named(it)).collect(),\n             ast::StructKind::Unit => Vec::new(),\n         };\n-        let ast = field_sources\n+        let value = field_sources\n             .into_iter()\n             .zip(fields.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n             .0;\n-        Source { file_id, ast }\n+        Source { file_id, value }\n     }\n }\n impl HasSource for Struct {\n@@ -98,28 +98,28 @@ impl HasSource for EnumVariant {\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::EnumVariant> {\n         let enum_data = db.enum_data(self.parent.id);\n         let src = self.parent.id.source(db);\n-        let ast = src\n-            .ast\n+        let value = src\n+            .value\n             .variant_list()\n             .into_iter()\n             .flat_map(|it| it.variants())\n             .zip(enum_data.variants.iter())\n             .find(|(_syntax, (id, _))| *id == self.id)\n             .unwrap()\n             .0;\n-        Source { file_id: src.file_id, ast }\n+        Source { file_id: src.file_id, value }\n     }\n }\n impl HasSource for Function {\n     type Ast = ast::FnDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::FnDef> {\n-        self.id.source(db)\n+        self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Const {\n     type Ast = ast::ConstDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ConstDef> {\n-        self.id.source(db)\n+        self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Static {\n@@ -137,13 +137,13 @@ impl HasSource for Trait {\n impl HasSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::TypeAliasDef> {\n-        self.id.source(db)\n+        self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for MacroDef {\n     type Ast = ast::MacroCall;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::MacroCall> {\n-        Source { file_id: self.id.ast_id.file_id(), ast: self.id.ast_id.to_node(db) }\n+        Source { file_id: self.id.ast_id.file_id(), value: self.id.ast_id.to_node(db) }\n     }\n }\n "}, {"sha": "a9982a70f6d5e96416d17aeb8e610f0696246300", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -8,10 +8,9 @@ use ra_syntax::SmolStr;\n \n use crate::{\n     debug::HirDebugDatabase,\n-    generics::{GenericDef, GenericParams},\n+    generics::GenericDef,\n     ids,\n     lang_item::{LangItemTarget, LangItems},\n-    traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks,\n         traits::{AssocTyValue, Impl},\n@@ -25,8 +24,9 @@ use crate::{\n \n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n-    EnumDataQuery, ExprScopesQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n-    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    EnumDataQuery, ExprScopesQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n+    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    TraitDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -37,15 +37,6 @@ pub use hir_expand::db::{\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n-    #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n-    fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n-\n-    #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n-    fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n-\n-    #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n-    fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n-\n     #[salsa::invoke(FnData::fn_data_query)]\n     fn fn_data(&self, func: Function) -> Arc<FnData>;\n "}, {"sha": "7d1b648589efba85ce73c886a9af3af137756baa", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -21,7 +21,7 @@ impl Diagnostic for NoSuchField {\n     }\n \n     fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.field.into() }\n+        Source { file_id: self.file, value: self.field.into() }\n     }\n \n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -41,7 +41,7 @@ impl Diagnostic for MissingFields {\n         \"fill structure fields\".to_string()\n     }\n     fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.field_list.into() }\n+        Source { file_id: self.file, value: self.field_list.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -53,7 +53,7 @@ impl AstDiagnostic for MissingFields {\n \n     fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().ast.to_node(&root);\n+        let node = self.source().value.to_node(&root);\n         ast::RecordFieldList::cast(node).unwrap()\n     }\n }\n@@ -69,7 +69,7 @@ impl Diagnostic for MissingOkInTailExpr {\n         \"wrap return expression in Ok\".to_string()\n     }\n     fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.expr.into() }\n+        Source { file_id: self.file, value: self.expr.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -81,7 +81,7 @@ impl AstDiagnostic for MissingOkInTailExpr {\n \n     fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n         let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().ast.to_node(&root);\n+        let node = self.source().value.to_node(&root);\n         ast::Expr::cast(node).unwrap()\n     }\n }"}, {"sha": "869879bdfa44e052858635883a35e01422feb95a", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -11,6 +11,7 @@ use rustc_hash::FxHashSet;\n use crate::{\n     db::HirDatabase,\n     diagnostics::{MissingFields, MissingOkInTailExpr},\n+    resolve::HasResolver,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n     Adt, DefWithBody, Function, HasBody, Name, Path, Resolver,\n };\n@@ -116,7 +117,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let source_map = self.func.body_source_map(db);\n \n         if let Some(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.ast.a() {\n+            if let Some(expr) = source_ptr.value.a() {\n                 let root = source_ptr.file_syntax(db);\n                 if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n                     if let Some(field_list) = record_lit.record_field_list() {\n@@ -161,7 +162,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             let source_map = self.func.body_source_map(db);\n \n             if let Some(source_ptr) = source_map.expr_syntax(id) {\n-                if let Some(expr) = source_ptr.ast.a() {\n+                if let Some(expr) = source_ptr.value.a() {\n                     self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n                 }\n             }"}, {"sha": "b7692d407330ba179e152ea0896f2057b7c7daf2", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -3,9 +3,9 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, ModuleDefId};\n+use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId};\n \n-use crate::{Adt, AssocItem, DefWithBody, EnumVariant, ModuleDef};\n+use crate::{Adt, AssocItem, DefWithBody, EnumVariant, GenericDef, ModuleDef};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -41,6 +41,16 @@ impl From<AdtId> for Adt {\n     }\n }\n \n+impl From<Adt> for AdtId {\n+    fn from(id: Adt) -> Self {\n+        match id {\n+            Adt::Struct(it) => AdtId::StructId(it.id),\n+            Adt::Union(it) => AdtId::UnionId(it.id),\n+            Adt::Enum(it) => AdtId::EnumId(it.id),\n+        }\n+    }\n+}\n+\n impl From<EnumVariantId> for EnumVariant {\n     fn from(id: EnumVariantId) -> Self {\n         EnumVariant { parent: id.parent.into(), id: id.local_id }\n@@ -82,3 +92,33 @@ impl From<AssocItemId> for AssocItem {\n         }\n     }\n }\n+\n+impl From<GenericDef> for GenericDefId {\n+    fn from(def: GenericDef) -> Self {\n+        match def {\n+            GenericDef::Function(it) => GenericDefId::FunctionId(it.id),\n+            GenericDef::Adt(it) => GenericDefId::AdtId(it.into()),\n+            GenericDef::Trait(it) => GenericDefId::TraitId(it.id),\n+            GenericDef::TypeAlias(it) => GenericDefId::TypeAliasId(it.id),\n+            GenericDef::ImplBlock(it) => GenericDefId::ImplId(it.id),\n+            GenericDef::EnumVariant(it) => {\n+                GenericDefId::EnumVariantId(EnumVariantId { parent: it.parent.id, local_id: it.id })\n+            }\n+            GenericDef::Const(it) => GenericDefId::ConstId(it.id),\n+        }\n+    }\n+}\n+\n+impl From<GenericDefId> for GenericDef {\n+    fn from(def: GenericDefId) -> Self {\n+        match def {\n+            GenericDefId::FunctionId(it) => GenericDef::Function(it.into()),\n+            GenericDefId::AdtId(it) => GenericDef::Adt(it.into()),\n+            GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n+            GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n+            GenericDefId::ImplId(it) => GenericDef::ImplBlock(it.into()),\n+            GenericDefId::EnumVariantId(it) => GenericDef::EnumVariant(it.into()),\n+            GenericDefId::ConstId(it) => GenericDef::Const(it.into()),\n+        }\n+    }\n+}"}, {"sha": "b86307c58acfc3e2a1949abbf0106dbc1bce1d6d", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 130, "deletions": 30, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -4,15 +4,15 @@ use hir_def::{ModuleId, StructId, StructOrUnionId, UnionId};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    match_ast,\n+    match_ast, AstPtr, SyntaxNode,\n };\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource, ImplBlock,\n-    Local, MacroDef, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n-    Union, VariantDef,\n+    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource,\n+    ImplBlock, Local, MacroDef, Module, ModuleDef, ModuleSource, Source, Static, Struct,\n+    StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -52,15 +52,54 @@ impl FromSource for Trait {\n impl FromSource for Function {\n     type Ast = ast::FnDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Function { id })\n+        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.items(db),\n+            Container::ImplBlock(it) => it.items(db),\n+            Container::Module(m) => {\n+                return m\n+                    .declarations(db)\n+                    .into_iter()\n+                    .filter_map(|it| match it {\n+                        ModuleDef::Function(it) => Some(it),\n+                        _ => None,\n+                    })\n+                    .find(|it| same_source(&it.source(db), &src))\n+            }\n+        };\n+        items\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                AssocItem::Function(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|it| same_source(&it.source(db), &src))\n     }\n }\n+\n impl FromSource for Const {\n     type Ast = ast::ConstDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Const { id })\n+        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.items(db),\n+            Container::ImplBlock(it) => it.items(db),\n+            Container::Module(m) => {\n+                return m\n+                    .declarations(db)\n+                    .into_iter()\n+                    .filter_map(|it| match it {\n+                        ModuleDef::Const(it) => Some(it),\n+                        _ => None,\n+                    })\n+                    .find(|it| same_source(&it.source(db), &src))\n+            }\n+        };\n+        items\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                AssocItem::Const(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|it| same_source(&it.source(db), &src))\n     }\n }\n impl FromSource for Static {\n@@ -73,8 +112,27 @@ impl FromSource for Static {\n impl FromSource for TypeAlias {\n     type Ast = ast::TypeAliasDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(TypeAlias { id })\n+        let items = match Container::find(db, src.as_ref().map(|it| it.syntax()))? {\n+            Container::Trait(it) => it.items(db),\n+            Container::ImplBlock(it) => it.items(db),\n+            Container::Module(m) => {\n+                return m\n+                    .declarations(db)\n+                    .into_iter()\n+                    .filter_map(|it| match it {\n+                        ModuleDef::TypeAlias(it) => Some(it),\n+                        _ => None,\n+                    })\n+                    .find(|it| same_source(&it.source(db), &src))\n+            }\n+        };\n+        items\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                AssocItem::TypeAlias(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|it| same_source(&it.source(db), &src))\n     }\n }\n \n@@ -87,7 +145,7 @@ impl FromSource for MacroDef {\n         let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n         let krate = module.krate().crate_id();\n \n-        let ast_id = AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.ast));\n+        let ast_id = AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value));\n \n         let id: MacroDefId = MacroDefId { krate, ast_id, kind };\n         Some(MacroDef { id })\n@@ -105,26 +163,26 @@ impl FromSource for ImplBlock {\n impl FromSource for EnumVariant {\n     type Ast = ast::EnumVariant;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let parent_enum = src.ast.parent_enum();\n-        let src_enum = Source { file_id: src.file_id, ast: parent_enum };\n+        let parent_enum = src.value.parent_enum();\n+        let src_enum = Source { file_id: src.file_id, value: parent_enum };\n         let variants = Enum::from_source(db, src_enum)?.variants(db);\n-        variants.into_iter().find(|v| v.source(db) == src)\n+        variants.into_iter().find(|v| same_source(&v.source(db), &src))\n     }\n }\n \n impl FromSource for StructField {\n     type Ast = FieldSource;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let variant_def: VariantDef = match src.ast {\n+        let variant_def: VariantDef = match src.value {\n             FieldSource::Named(ref field) => {\n-                let ast = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n-                let src = Source { file_id: src.file_id, ast };\n+                let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n+                let src = Source { file_id: src.file_id, value };\n                 let def = Struct::from_source(db, src)?;\n                 VariantDef::from(def)\n             }\n             FieldSource::Pos(ref field) => {\n-                let ast = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n-                let src = Source { file_id: src.file_id, ast };\n+                let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n+                let src = Source { file_id: src.file_id, value };\n                 let def = EnumVariant::from_source(db, src)?;\n                 VariantDef::from(def)\n             }\n@@ -142,12 +200,12 @@ impl FromSource for StructField {\n impl Local {\n     pub fn from_source(db: &impl HirDatabase, src: Source<ast::BindPat>) -> Option<Self> {\n         let file_id = src.file_id;\n-        let parent: DefWithBody = src.ast.syntax().ancestors().find_map(|it| {\n+        let parent: DefWithBody = src.value.syntax().ancestors().find_map(|it| {\n             let res = match_ast! {\n                 match it {\n-                    ast::ConstDef(ast) => { Const::from_source(db, Source { ast, file_id})?.into() },\n-                    ast::StaticDef(ast) => { Static::from_source(db, Source { ast, file_id})?.into() },\n-                    ast::FnDef(ast) => { Function::from_source(db, Source { ast, file_id})?.into() },\n+                    ast::ConstDef(value) => { Const::from_source(db, Source { value, file_id})?.into() },\n+                    ast::StaticDef(value) => { Static::from_source(db, Source { value, file_id})?.into() },\n+                    ast::FnDef(value) => { Function::from_source(db, Source { value, file_id})?.into() },\n                     _ => return None,\n                 }\n             };\n@@ -162,33 +220,33 @@ impl Local {\n \n impl Module {\n     pub fn from_declaration(db: &impl DefDatabase, src: Source<ast::Module>) -> Option<Self> {\n-        let parent_declaration = src.ast.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n+        let parent_declaration = src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n \n         let parent_module = match parent_declaration {\n             Some(parent_declaration) => {\n-                let src_parent = Source { file_id: src.file_id, ast: parent_declaration };\n+                let src_parent = Source { file_id: src.file_id, value: parent_declaration };\n                 Module::from_declaration(db, src_parent)\n             }\n             _ => {\n                 let src_parent = Source {\n                     file_id: src.file_id,\n-                    ast: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n+                    value: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n                 };\n                 Module::from_definition(db, src_parent)\n             }\n         }?;\n \n-        let child_name = src.ast.name()?;\n+        let child_name = src.value.name()?;\n         parent_module.child(db, &child_name.as_name())\n     }\n \n     pub fn from_definition(db: &impl DefDatabase, src: Source<ModuleSource>) -> Option<Self> {\n-        match src.ast {\n+        match src.value {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n                 return Module::from_declaration(\n                     db,\n-                    Source { file_id: src.file_id, ast: module.clone() },\n+                    Source { file_id: src.file_id, value: module.clone() },\n                 );\n             }\n             ModuleSource::SourceFile(_) => (),\n@@ -214,5 +272,47 @@ where\n     let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n     let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n     let ctx = LocationCtx::new(db, module.id, src.file_id);\n-    Some(DEF::from_ast(ctx, &src.ast))\n+    Some(DEF::from_ast(ctx, &src.value))\n+}\n+\n+enum Container {\n+    Trait(Trait),\n+    ImplBlock(ImplBlock),\n+    Module(Module),\n+}\n+\n+impl Container {\n+    fn find(db: &impl DefDatabase, src: Source<&SyntaxNode>) -> Option<Container> {\n+        // FIXME: this doesn't try to handle nested declarations\n+        for container in src.value.ancestors() {\n+            let res = match_ast! {\n+                match container {\n+                    ast::TraitDef(it) => {\n+                        let c = Trait::from_source(db, src.with_value(it))?;\n+                        Container::Trait(c)\n+                    },\n+                    ast::ImplBlock(it) => {\n+                        let c = ImplBlock::from_source(db, src.with_value(it))?;\n+                        Container::ImplBlock(c)\n+                     },\n+                    _ => { continue },\n+                }\n+            };\n+            return Some(res);\n+        }\n+\n+        let module_source = ModuleSource::from_child_node(db, src);\n+        let c = Module::from_definition(db, src.with_value(module_source))?;\n+        Some(Container::Module(c))\n+    }\n+}\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+fn same_source<N: AstNode>(s1: &Source<N>, s2: &Source<N>) -> bool {\n+    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n }"}, {"sha": "f1bf2ee9d19b823ad677142e48366324e5bc6599", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 4, "deletions": 186, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -1,50 +1,12 @@\n-//! Many kinds of items or constructs can have generic parameters: functions,\n-//! structs, impls, traits, etc. This module provides a common HIR for these\n-//! generic parameters. See also the `Generics` type and the `generics_of` query\n-//! in rustc.\n-\n+//! Temp module to wrap hir_def::generics\n use std::sync::Arc;\n \n-use hir_def::{\n-    path::Path,\n-    type_ref::{TypeBound, TypeRef},\n-};\n-use hir_expand::name::{self, AsName};\n-use ra_syntax::ast::{self, DefaultTypeParamOwner, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n-\n use crate::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n-    Adt, Const, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct, Trait,\n+    db::DefDatabase, Adt, Const, Container, Enum, EnumVariant, Function, ImplBlock, Struct, Trait,\n     TypeAlias, Union,\n };\n \n-/// Data about a generic parameter (to a function, struct, impl, ...).\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParam {\n-    // FIXME: give generic params proper IDs\n-    pub idx: u32,\n-    pub name: Name,\n-    pub default: Option<Path>,\n-}\n-\n-/// Data about the generic parameters of a function, struct, impl, etc.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParams {\n-    pub(crate) def: GenericDef,\n-    pub(crate) parent_params: Option<Arc<GenericParams>>,\n-    pub(crate) params: Vec<GenericParam>,\n-    pub(crate) where_predicates: Vec<WherePredicate>,\n-}\n-\n-/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n-/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n-/// It might still result in multiple actual predicates though, because of\n-/// associated type bindings like `Iterator<Item = u32>`.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct WherePredicate {\n-    pub(crate) type_ref: TypeRef,\n-    pub(crate) bound: TypeBound,\n-}\n+pub use hir_def::generics::{GenericParam, GenericParams, WherePredicate};\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n@@ -69,150 +31,6 @@ impl_froms!(\n     Const\n );\n \n-impl GenericParams {\n-    pub(crate) fn generic_params_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        def: GenericDef,\n-    ) -> Arc<GenericParams> {\n-        let parent = match def {\n-            GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::Const(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n-            GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n-            GenericDef::ImplBlock(_) => None,\n-        };\n-        let mut generics = GenericParams {\n-            def,\n-            params: Vec::new(),\n-            parent_params: parent.map(|p| db.generic_params(p)),\n-            where_predicates: Vec::new(),\n-        };\n-        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n-        // FIXME: add `: Sized` bound for everything except for `Self` in traits\n-        match def {\n-            GenericDef::Function(it) => generics.fill(&it.source(db).ast, start),\n-            GenericDef::Adt(Adt::Struct(it)) => generics.fill(&it.source(db).ast, start),\n-            GenericDef::Adt(Adt::Union(it)) => generics.fill(&it.source(db).ast, start),\n-            GenericDef::Adt(Adt::Enum(it)) => generics.fill(&it.source(db).ast, start),\n-            GenericDef::Trait(it) => {\n-                // traits get the Self type as an implicit first type parameter\n-                generics.params.push(GenericParam {\n-                    idx: start,\n-                    name: name::SELF_TYPE,\n-                    default: None,\n-                });\n-                generics.fill(&it.source(db).ast, start + 1);\n-                // add super traits as bounds on Self\n-                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n-                generics.fill_bounds(&it.source(db).ast, self_param);\n-            }\n-            GenericDef::TypeAlias(it) => generics.fill(&it.source(db).ast, start),\n-            // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n-            // type-parameter, but rather is a type-alias for impl's target\n-            // type, so this is handled by the resolver.\n-            GenericDef::ImplBlock(it) => generics.fill(&it.source(db).ast, start),\n-            GenericDef::EnumVariant(_) | GenericDef::Const(_) => {}\n-        }\n-\n-        Arc::new(generics)\n-    }\n-\n-    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n-        if let Some(params) = node.type_param_list() {\n-            self.fill_params(params, start)\n-        }\n-        if let Some(where_clause) = node.where_clause() {\n-            self.fill_where_predicates(where_clause);\n-        }\n-    }\n-\n-    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n-        for bound in\n-            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n-        {\n-            self.add_where_predicate_from_bound(bound, type_ref.clone());\n-        }\n-    }\n-\n-    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n-        for (idx, type_param) in params.type_params().enumerate() {\n-            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n-            // FIXME: Use `Path::from_src`\n-            let default = type_param.default_type().and_then(|t| t.path()).and_then(Path::from_ast);\n-\n-            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n-            self.params.push(param);\n-\n-            let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(&type_param, type_ref);\n-        }\n-    }\n-\n-    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n-        for pred in where_clause.predicates() {\n-            let type_ref = match pred.type_ref() {\n-                Some(type_ref) => type_ref,\n-                None => continue,\n-            };\n-            let type_ref = TypeRef::from_ast(type_ref);\n-            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                self.add_where_predicate_from_bound(bound, type_ref.clone());\n-            }\n-        }\n-    }\n-\n-    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n-        if bound.has_question_mark() {\n-            // FIXME: remove this bound\n-            return;\n-        }\n-        let bound = TypeBound::from_ast(bound);\n-        self.where_predicates.push(WherePredicate { type_ref, bound });\n-    }\n-\n-    pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n-        self.params.iter().find(|p| &p.name == name)\n-    }\n-\n-    pub fn count_parent_params(&self) -> usize {\n-        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n-    }\n-\n-    pub fn count_params_including_parent(&self) -> usize {\n-        let parent_count = self.count_parent_params();\n-        parent_count + self.params.len()\n-    }\n-\n-    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n-        if let Some(parent) = &self.parent_params {\n-            parent.for_each_param(f);\n-        }\n-        self.params.iter().for_each(f);\n-    }\n-\n-    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n-        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n-        self.for_each_param(&mut |p| vec.push(p));\n-        vec\n-    }\n-}\n-\n-impl GenericDef {\n-    pub(crate) fn resolver(&self, db: &impl HirDatabase) -> crate::Resolver {\n-        match self {\n-            GenericDef::Function(inner) => inner.resolver(db),\n-            GenericDef::Adt(adt) => adt.resolver(db),\n-            GenericDef::Trait(inner) => inner.resolver(db),\n-            GenericDef::TypeAlias(inner) => inner.resolver(db),\n-            GenericDef::ImplBlock(inner) => inner.resolver(db),\n-            GenericDef::EnumVariant(inner) => inner.parent_enum(db).resolver(db),\n-            GenericDef::Const(inner) => inner.resolver(db),\n-        }\n-    }\n-}\n-\n impl From<Container> for GenericDef {\n     fn from(c: Container) -> Self {\n         match c {\n@@ -231,6 +49,6 @@ where\n     T: Into<GenericDef> + Copy,\n {\n     fn generic_params(self, db: &impl DefDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.into())\n+        db.generic_params(self.into().into())\n     }\n }"}, {"sha": "964a3da8c0810ccd30e18bd6c03fed563f81c205", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -5,8 +5,7 @@ use ra_syntax::ast::{self};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    generics::HasGenericParams,\n-    resolve::Resolver,\n+    resolve::HasResolver,\n     ty::Ty,\n     AssocItem, Crate, HasSource, ImplBlock, Module, Source, TraitRef,\n };\n@@ -19,14 +18,6 @@ impl HasSource for ImplBlock {\n }\n \n impl ImplBlock {\n-    pub(crate) fn containing(db: &impl DefDatabase, item: AssocItem) -> Option<ImplBlock> {\n-        let module = item.module(db);\n-        let crate_def_map = db.crate_def_map(module.id.krate);\n-        crate_def_map[module.id.module_id].impls.iter().copied().map(ImplBlock::from).find(|it| {\n-            db.impl_data(it.id).items().iter().copied().map(AssocItem::from).any(|it| it == item)\n-        })\n-    }\n-\n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait().cloned()\n     }\n@@ -59,13 +50,4 @@ impl ImplBlock {\n     pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n         Crate { crate_id: self.module(db).id.krate }\n     }\n-\n-    pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n-        let r = self.module(db).resolver(db);\n-        // add generic params, if present\n-        let p = self.generic_params(db);\n-        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n-        let r = r.push_impl_block_scope(self.clone());\n-        r\n-    }\n }"}, {"sha": "89fd85f59f959d0931a1f82c0d402de65a5e66eb", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -97,7 +97,7 @@ impl LangItems {\n         // Look for impl targets\n         for impl_block in module.impl_blocks(db) {\n             let src = impl_block.source(db);\n-            if let Some(lang_item_name) = lang_item_name(&src.ast) {\n+            if let Some(lang_item_name) = lang_item_name(&src.value) {\n                 self.items\n                     .entry(lang_item_name)\n                     .or_insert_with(|| LangItemTarget::ImplBlock(impl_block));\n@@ -144,7 +144,7 @@ impl LangItems {\n         T: Copy + HasSource<Ast = N>,\n         N: AttrsOwner,\n     {\n-        let node = item.source(db).ast;\n+        let node = item.source(db).value;\n         if let Some(lang_item_name) = lang_item_name(&node) {\n             self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }"}, {"sha": "31da74d2f3b66312def365ddfd630adc346739d6", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -32,8 +32,6 @@ pub mod db;\n pub mod source_binder;\n \n mod ids;\n-mod adt;\n-mod traits;\n mod type_alias;\n mod ty;\n mod impl_block;\n@@ -57,15 +55,14 @@ mod marks;\n use crate::resolve::Resolver;\n \n pub use crate::{\n-    adt::VariantDef,\n-    code_model::ImplBlock,\n     code_model::{\n         attrs::{AttrDef, Attrs},\n         docs::{DocDef, Docs, Documentation},\n         src::{HasBodySource, HasSource},\n         Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n-        EnumVariant, FieldSource, FnData, Function, GenericParam, HasBody, Local, MacroDef, Module,\n-        ModuleDef, ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n+        EnumVariant, FieldSource, FnData, Function, GenericParam, HasBody, ImplBlock, Local,\n+        MacroDef, Module, ModuleDef, ModuleSource, Static, Struct, StructField, Trait, TypeAlias,\n+        Union, VariantDef,\n     },\n     expr::ExprScopes,\n     from_source::FromSource,"}, {"sha": "eca8e05969baf9a2778d19bcd446953cba07451b", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 124, "deletions": 15, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -14,9 +14,9 @@ use crate::{\n     code_model::Crate,\n     db::{DefDatabase, HirDatabase},\n     expr::{ExprScopes, PatId, ScopeId},\n-    generics::GenericParams,\n-    Adt, Const, DefWithBody, Enum, EnumVariant, Function, ImplBlock, Local, MacroDef, ModuleDef,\n-    PerNs, Static, Struct, Trait, TypeAlias,\n+    generics::{GenericParams, HasGenericParams},\n+    Adt, Const, Container, DefWithBody, Enum, EnumVariant, Function, GenericDef, ImplBlock, Local,\n+    MacroDef, Module, ModuleDef, PerNs, Static, Struct, Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -43,7 +43,7 @@ pub(crate) enum Scope {\n     /// All the items and imported names of a module\n     ModuleScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n-    GenericParams(Arc<GenericParams>),\n+    GenericParams { def: GenericDef, params: Arc<GenericParams> },\n     /// Brings `Self` in `impl` block into scope\n     ImplBlockScope(ImplBlock),\n     /// Brings `Self` in enum, struct and union definitions into scope\n@@ -141,9 +141,9 @@ impl Resolver {\n         for scope in self.scopes.iter().rev() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams(_) | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n+                Scope::GenericParams { .. } | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n \n-                Scope::GenericParams(params) => {\n+                Scope::GenericParams { params, .. } => {\n                     if let Some(param) = params.find_by_name(first_name) {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::GenericParam(param.idx), idx));\n@@ -212,7 +212,7 @@ impl Resolver {\n             match scope {\n                 Scope::AdtScope(_)\n                 | Scope::ExprScope(_)\n-                | Scope::GenericParams(_)\n+                | Scope::GenericParams { .. }\n                 | Scope::ImplBlockScope(_)\n                     if skip_to_mod =>\n                 {\n@@ -232,13 +232,13 @@ impl Resolver {\n                 }\n                 Scope::ExprScope(_) => continue,\n \n-                Scope::GenericParams(params) if n_segments > 1 => {\n+                Scope::GenericParams { params, .. } if n_segments > 1 => {\n                     if let Some(param) = params.find_by_name(first_name) {\n                         let ty = TypeNs::GenericParam(param.idx);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n-                Scope::GenericParams(_) => continue,\n+                Scope::GenericParams { .. } => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n                     if first_name == &name::SELF_TYPE {\n@@ -361,15 +361,15 @@ impl Resolver {\n         self.scopes\n             .iter()\n             .filter_map(|scope| match scope {\n-                Scope::GenericParams(params) => Some(params),\n+                Scope::GenericParams { params, .. } => Some(params),\n                 _ => None,\n             })\n             .flat_map(|params| params.where_predicates.iter())\n     }\n \n     pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n         self.scopes.iter().find_map(|scope| match scope {\n-            Scope::GenericParams(params) => Some(params.def),\n+            Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n         })\n     }\n@@ -381,8 +381,17 @@ impl Resolver {\n         self\n     }\n \n-    pub(crate) fn push_generic_params_scope(self, params: Arc<GenericParams>) -> Resolver {\n-        self.push_scope(Scope::GenericParams(params))\n+    pub(crate) fn push_generic_params_scope(\n+        self,\n+        db: &impl DefDatabase,\n+        def: GenericDef,\n+    ) -> Resolver {\n+        let params = def.generic_params(db);\n+        if params.params.is_empty() {\n+            self\n+        } else {\n+            self.push_scope(Scope::GenericParams { def, params })\n+        }\n     }\n \n     pub(crate) fn push_impl_block_scope(self, impl_block: ImplBlock) -> Resolver {\n@@ -457,8 +466,8 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::GenericParams(gp) => {\n-                for param in &gp.params {\n+            Scope::GenericParams { params, .. } => {\n+                for param in params.params.iter() {\n                     f(param.name.clone(), ScopeDef::GenericParam(param.idx))\n                 }\n             }\n@@ -477,3 +486,103 @@ impl Scope {\n         }\n     }\n }\n+\n+pub(crate) trait HasResolver {\n+    /// Builds a resolver for type references inside this def.\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver;\n+}\n+\n+impl HasResolver for Module {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        let def_map = db.crate_def_map(self.id.krate);\n+        Resolver::default().push_module_scope(def_map, self.id.module_id)\n+    }\n+}\n+\n+impl HasResolver for Trait {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.module(db).resolver(db).push_generic_params_scope(db, self.into())\n+    }\n+}\n+\n+impl<T: Into<Adt>> HasResolver for T {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        let def = self.into();\n+        def.module(db)\n+            .resolver(db)\n+            .push_generic_params_scope(db, def.into())\n+            .push_scope(Scope::AdtScope(def))\n+    }\n+}\n+\n+impl HasResolver for Function {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.container(db)\n+            .map(|c| c.resolver(db))\n+            .unwrap_or_else(|| self.module(db).resolver(db))\n+            .push_generic_params_scope(db, self.into())\n+    }\n+}\n+\n+impl HasResolver for DefWithBody {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            DefWithBody::Const(c) => c.resolver(db),\n+            DefWithBody::Function(f) => f.resolver(db),\n+            DefWithBody::Static(s) => s.resolver(db),\n+        }\n+    }\n+}\n+\n+impl HasResolver for Const {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.container(db).map(|c| c.resolver(db)).unwrap_or_else(|| self.module(db).resolver(db))\n+    }\n+}\n+\n+impl HasResolver for Static {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.module(db).resolver(db)\n+    }\n+}\n+\n+impl HasResolver for TypeAlias {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.container(db)\n+            .map(|ib| ib.resolver(db))\n+            .unwrap_or_else(|| self.module(db).resolver(db))\n+            .push_generic_params_scope(db, self.into())\n+    }\n+}\n+\n+impl HasResolver for Container {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        match self {\n+            Container::Trait(trait_) => trait_.resolver(db),\n+            Container::ImplBlock(impl_block) => impl_block.resolver(db),\n+        }\n+    }\n+}\n+\n+impl HasResolver for GenericDef {\n+    fn resolver(self, db: &impl DefDatabase) -> crate::Resolver {\n+        match self {\n+            GenericDef::Function(inner) => inner.resolver(db),\n+            GenericDef::Adt(adt) => adt.resolver(db),\n+            GenericDef::Trait(inner) => inner.resolver(db),\n+            GenericDef::TypeAlias(inner) => inner.resolver(db),\n+            GenericDef::ImplBlock(inner) => inner.resolver(db),\n+            GenericDef::EnumVariant(inner) => inner.parent_enum(db).resolver(db),\n+            GenericDef::Const(inner) => inner.resolver(db),\n+        }\n+    }\n+}\n+\n+impl HasResolver for ImplBlock {\n+    fn resolver(self, db: &impl DefDatabase) -> Resolver {\n+        self.module(db)\n+            .resolver(db)\n+            .push_generic_params_scope(db, self.into())\n+            .push_impl_block_scope(self)\n+    }\n+}"}, {"sha": "727310f0662ce57fc4597d3c72765ac4cbe191da", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -23,32 +23,32 @@ use crate::{\n     db::HirDatabase,\n     expr::{self, BodySourceMap, ExprScopes, ScopeId},\n     ids::LocationCtx,\n-    resolve::{ScopeDef, TypeNs, ValueNs},\n+    resolve::{HasResolver, ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},\n     AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, GenericParam, HasBody,\n     HirFileId, Local, MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n     match_ast! {\n-        match (node.ast) {\n+        match (node.value) {\n             ast::Module(it) => {\n-                let src = node.with_ast(it);\n+                let src = node.with_value(it);\n                 Some(crate::Module::from_declaration(db, src)?.resolver(db))\n             },\n              ast::SourceFile(it) => {\n-                let src = node.with_ast(crate::ModuleSource::SourceFile(it));\n+                let src = node.with_value(crate::ModuleSource::SourceFile(it));\n                 Some(crate::Module::from_definition(db, src)?.resolver(db))\n             },\n             ast::StructDef(it) => {\n-                let src = node.with_ast(it);\n+                let src = node.with_value(it);\n                 Some(Struct::from_source(db, src)?.resolver(db))\n             },\n             ast::EnumDef(it) => {\n-                let src = node.with_ast(it);\n+                let src = node.with_value(it);\n                 Some(Enum::from_source(db, src)?.resolver(db))\n             },\n-            _ => match node.ast.kind() {\n+            _ => match node.value.kind() {\n                 FN_DEF | CONST_DEF | STATIC_DEF => {\n                     Some(def_with_body_from_child_node(db, node)?.resolver(db))\n                 }\n@@ -67,11 +67,11 @@ fn def_with_body_from_child_node(\n     let module = Module::from_definition(db, Source::new(child.file_id, module_source))?;\n     let ctx = LocationCtx::new(db, module.id, child.file_id);\n \n-    child.ast.ancestors().find_map(|node| {\n+    child.value.ancestors().find_map(|node| {\n         match_ast! {\n             match node {\n-                ast::FnDef(def)  => { Some(Function {id: ctx.to_def(&def) }.into()) },\n-                ast::ConstDef(def) => { Some(Const { id: ctx.to_def(&def) }.into()) },\n+                ast::FnDef(def)  => { return Function::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n+                ast::ConstDef(def) => { return Const::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n                 ast::StaticDef(def) => { Some(Static { id: ctx.to_def(&def) }.into()) },\n                 _ => { None },\n             }\n@@ -157,7 +157,7 @@ impl SourceAnalyzer {\n             let scopes = def.expr_scopes(db);\n             let scope = match offset {\n                 None => scope_for(&scopes, &source_map, node),\n-                Some(offset) => scope_for_offset(&scopes, &source_map, node.with_ast(offset)),\n+                Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n             };\n             let resolver = expr::resolver_for_scope(db, def, scope);\n             SourceAnalyzer {\n@@ -171,9 +171,9 @@ impl SourceAnalyzer {\n         } else {\n             SourceAnalyzer {\n                 resolver: node\n-                    .ast\n+                    .value\n                     .ancestors()\n-                    .find_map(|it| try_get_resolver_for_node(db, node.with_ast(&it)))\n+                    .find_map(|it| try_get_resolver_for_node(db, node.with_value(&it)))\n                     .unwrap_or_default(),\n                 body_owner: None,\n                 body_source_map: None,\n@@ -185,12 +185,12 @@ impl SourceAnalyzer {\n     }\n \n     fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n-        let src = Source { file_id: self.file_id, ast: expr };\n+        let src = Source { file_id: self.file_id, value: expr };\n         self.body_source_map.as_ref()?.node_expr(src)\n     }\n \n     fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n-        let src = Source { file_id: self.file_id, ast: pat };\n+        let src = Source { file_id: self.file_id, value: pat };\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n \n@@ -302,7 +302,7 @@ impl SourceAnalyzer {\n         let entry = scopes.resolve_name_in_scope(scope, &name)?;\n         Some(ScopeEntryWithSyntax {\n             name: entry.name().clone(),\n-            ptr: source_map.pat_syntax(entry.pat())?.ast,\n+            ptr: source_map.pat_syntax(entry.pat())?.value,\n         })\n     }\n \n@@ -405,9 +405,16 @@ impl SourceAnalyzer {\n         implements_trait(&canonical_ty, db, &self.resolver, krate, std_future_trait)\n     }\n \n-    pub fn expand(&self, db: &impl HirDatabase, macro_call: &ast::MacroCall) -> Option<Expansion> {\n-        let def = self.resolve_macro_call(db, macro_call)?.id;\n-        let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(macro_call));\n+    pub fn expand(\n+        &self,\n+        db: &impl HirDatabase,\n+        macro_call: Source<&ast::MacroCall>,\n+    ) -> Option<Expansion> {\n+        let def = self.resolve_macro_call(db, macro_call.value)?.id;\n+        let ast_id = AstId::new(\n+            macro_call.file_id,\n+            db.ast_id_map(macro_call.file_id).ast_id(macro_call.value),\n+        );\n         let macro_call_loc = MacroCallLoc { def, ast_id };\n         Some(Expansion { macro_call_id: db.intern_macro(macro_call_loc) })\n     }\n@@ -421,14 +428,19 @@ impl SourceAnalyzer {\n     pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n         self.infer.clone().unwrap()\n     }\n+\n+    #[cfg(test)]\n+    pub(crate) fn analyzed_declaration(&self) -> Option<DefWithBody> {\n+        self.body_owner\n+    }\n }\n \n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     node: Source<&SyntaxNode>,\n ) -> Option<ScopeId> {\n-    node.ast\n+    node.value\n         .ancestors()\n         .filter_map(ast::Expr::cast)\n         .filter_map(|it| source_map.node_expr(Source::new(node.file_id, &it)))\n@@ -450,18 +462,18 @@ fn scope_for_offset(\n                 return None;\n             }\n             let syntax_node_ptr =\n-                source.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+                source.value.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n             Some((syntax_node_ptr, scope))\n         })\n         // find containing scope\n         .min_by_key(|(ptr, _scope)| {\n             (\n-                !(ptr.range().start() <= offset.ast && offset.ast <= ptr.range().end()),\n+                !(ptr.range().start() <= offset.value && offset.value <= ptr.range().end()),\n                 ptr.range().len(),\n             )\n         })\n         .map(|(ptr, scope)| {\n-            adjust(scopes, source_map, ptr, offset.file_id, offset.ast).unwrap_or(*scope)\n+            adjust(scopes, source_map, ptr, offset.file_id, offset.value).unwrap_or(*scope)\n         })\n }\n \n@@ -485,7 +497,7 @@ fn adjust(\n                 return None;\n             }\n             let syntax_node_ptr =\n-                source.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+                source.value.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n             Some((syntax_node_ptr, scope))\n         })\n         .map(|(ptr, scope)| (ptr.range(), scope))"}, {"sha": "1a45dacba92d837acd0232bab31f263d0005f79d", "filename": "crates/ra_hir/src/traits.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1e2d090ab8a9bda18f148b894b7948eb05b976e6/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2d090ab8a9bda18f148b894b7948eb05b976e6/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=1e2d090ab8a9bda18f148b894b7948eb05b976e6", "patch": "@@ -1,82 +0,0 @@\n-//! HIR for trait definitions.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::name::AsName;\n-\n-use ra_syntax::ast::{self, NameOwner};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase},\n-    ids::LocationCtx,\n-    AssocItem, Const, Function, HasSource, Module, Name, Trait, TypeAlias,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitData {\n-    name: Option<Name>,\n-    items: Vec<AssocItem>,\n-    auto: bool,\n-}\n-\n-impl TraitData {\n-    pub(crate) fn trait_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        tr: Trait,\n-    ) -> Arc<TraitData> {\n-        let src = tr.source(db);\n-        let name = src.ast.name().map(|n| n.as_name());\n-        let module = tr.module(db);\n-        let ctx = LocationCtx::new(db, module.id, src.file_id);\n-        let auto = src.ast.is_auto();\n-        let items = if let Some(item_list) = src.ast.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TraitData { name, items, auto })\n-    }\n-\n-    pub(crate) fn name(&self) -> &Option<Name> {\n-        &self.name\n-    }\n-\n-    pub(crate) fn items(&self) -> &[AssocItem] {\n-        &self.items\n-    }\n-\n-    pub(crate) fn is_auto(&self) -> bool {\n-        self.auto\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitItemsIndex {\n-    traits_by_def: FxHashMap<AssocItem, Trait>,\n-}\n-\n-impl TraitItemsIndex {\n-    pub(crate) fn trait_items_index(db: &impl DefDatabase, module: Module) -> TraitItemsIndex {\n-        let mut index = TraitItemsIndex { traits_by_def: FxHashMap::default() };\n-        for decl in module.declarations(db) {\n-            if let crate::ModuleDef::Trait(tr) = decl {\n-                for item in tr.trait_data(db).items() {\n-                    index.traits_by_def.insert(*item, tr);\n-                }\n-            }\n-        }\n-        index\n-    }\n-\n-    pub(crate) fn get_parent_trait(&self, item: AssocItem) -> Option<Trait> {\n-        self.traits_by_def.get(&item).cloned()\n-    }\n-}"}, {"sha": "36ece723f237adeec3b9bac5fc39972ddac49ade", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -3,15 +3,16 @@\n \n mod autoderef;\n pub(crate) mod primitive;\n-#[cfg(test)]\n-mod tests;\n pub(crate) mod traits;\n pub(crate) mod method_resolution;\n mod op;\n mod lower;\n mod infer;\n pub(crate) mod display;\n \n+#[cfg(test)]\n+mod tests;\n+\n use std::ops::Deref;\n use std::sync::Arc;\n use std::{fmt, iter, mem};\n@@ -800,6 +801,10 @@ impl HirDisplay for &Ty {\n \n impl HirDisplay for ApplicationTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n         match self.ctor {\n             TypeCtor::Bool => write!(f, \"bool\")?,\n             TypeCtor::Char => write!(f, \"char\")?,\n@@ -901,6 +906,10 @@ impl HirDisplay for ApplicationTy {\n \n impl HirDisplay for ProjectionTy {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n         let trait_name = self\n             .associated_ty\n             .parent_trait(f.db)\n@@ -919,6 +928,10 @@ impl HirDisplay for ProjectionTy {\n \n impl HirDisplay for Ty {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n@@ -1001,6 +1014,10 @@ impl HirDisplay for Ty {\n \n impl TraitRef {\n     fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n         self.substs[0].hir_fmt(f)?;\n         if use_as {\n             write!(f, \" as \")?;\n@@ -1031,6 +1048,10 @@ impl HirDisplay for &GenericPredicate {\n \n impl HirDisplay for GenericPredicate {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"\u2026\");\n+        }\n+\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n             GenericPredicate::Projection(projection_pred) => {"}, {"sha": "9bb3ece6c8db60e301a885d568e7323ca3ae6d49", "filename": "crates/ra_hir/src/ty/display.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fdisplay.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -7,15 +7,30 @@ use crate::db::HirDatabase;\n pub struct HirFormatter<'a, 'b, DB> {\n     pub db: &'a DB,\n     fmt: &'a mut fmt::Formatter<'b>,\n+    buf: String,\n+    curr_size: usize,\n+    max_size: Option<usize>,\n }\n \n pub trait HirDisplay {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result;\n+\n     fn display<'a, DB>(&'a self, db: &'a DB) -> HirDisplayWrapper<'a, DB, Self>\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self)\n+        HirDisplayWrapper(db, self, None)\n+    }\n+\n+    fn display_truncated<'a, DB>(\n+        &'a self,\n+        db: &'a DB,\n+        max_size: Option<usize>,\n+    ) -> HirDisplayWrapper<'a, DB, Self>\n+    where\n+        Self: Sized,\n+    {\n+        HirDisplayWrapper(db, self, max_size)\n     }\n }\n \n@@ -41,18 +56,38 @@ where\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n     pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n-        fmt::write(self.fmt, args)\n+        // We write to a buffer first to track output size\n+        self.buf.clear();\n+        fmt::write(&mut self.buf, args)?;\n+        self.curr_size += self.buf.len();\n+\n+        // Then we write to the internal formatter from the buffer\n+        self.fmt.write_str(&self.buf)\n+    }\n+\n+    pub fn should_truncate(&self) -> bool {\n+        if let Some(max_size) = self.max_size {\n+            self.curr_size >= max_size\n+        } else {\n+            false\n+        }\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T);\n+pub struct HirDisplayWrapper<'a, DB, T>(&'a DB, &'a T, Option<usize>);\n \n impl<'a, DB, T> fmt::Display for HirDisplayWrapper<'a, DB, T>\n where\n     DB: HirDatabase,\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.1.hir_fmt(&mut HirFormatter { db: self.0, fmt: f })\n+        self.1.hir_fmt(&mut HirFormatter {\n+            db: self.0,\n+            fmt: f,\n+            buf: String::with_capacity(20),\n+            curr_size: 0,\n+            max_size: self.2,\n+        })\n     }\n }"}, {"sha": "7f9e81d6492b203f781fb66f135876c8be779827", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -37,14 +37,13 @@ use super::{\n     TypeCtor, TypeWalk, Uncertain,\n };\n use crate::{\n-    adt::VariantDef,\n     code_model::TypeAlias,\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n-    resolve::{Resolver, TypeNs},\n+    resolve::{HasResolver, Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n-    StructField,\n+    StructField, VariantDef,\n };\n \n macro_rules! ty_app {"}, {"sha": "397ee7d5fc365b1fab35d121d5e8e1eb18a31c7f", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -19,18 +19,17 @@ use super::{\n     TypeWalk,\n };\n use crate::{\n-    adt::VariantDef,\n     db::HirDatabase,\n     generics::HasGenericParams,\n     generics::{GenericDef, WherePredicate},\n-    resolve::{Resolver, TypeNs},\n+    resolve::{HasResolver, Resolver, TypeNs},\n     ty::{\n         primitive::{FloatTy, IntTy, Uncertain},\n         Adt,\n     },\n     util::make_mut_slice,\n     Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n-    TypeAlias, Union,\n+    TypeAlias, Union, VariantDef,\n };\n \n // FIXME: this is only really used in `type_for_def`, which contains a bunch of\n@@ -611,9 +610,7 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n     let defaults = generic_params\n         .params_including_parent()\n         .into_iter()\n-        .map(|p| {\n-            p.default.as_ref().map_or(Ty::Unknown, |path| Ty::from_hir_path(db, &resolver, path))\n-        })\n+        .map(|p| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n         .collect();\n \n     Substs(defaults)"}, {"sha": "f377fca48a69fbe7874107a46735e0897047ed18", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -232,8 +232,8 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for &item in data.items() {\n-            if !is_valid_candidate(db, name, mode, item) {\n+        for &item in data.items.iter() {\n+            if !is_valid_candidate(db, name, mode, item.into()) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -243,7 +243,7 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, item) {\n+            if let Some(result) = callback(&ty.value, item.into()) {\n                 return Some(result);\n             }\n         }"}, {"sha": "74c12a0a2d5a53cfe138c7386ba184cd2e0d60f1", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -11,6 +11,7 @@ use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::*,\n };\n+use rustc_hash::FxHashSet;\n use test_utils::covers;\n \n use crate::{\n@@ -1979,6 +1980,30 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_associated_method_generics_with_default_tuple_param() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct Gen<T=()> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make();\n+    a.val<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n #[test]\n fn infer_associated_method_generics_without_args() {\n     assert_snapshot!(\n@@ -2494,7 +2519,6 @@ fn test() {\n     [167; 179) 'GLOBAL_CONST': u32\n     [189; 191) 'id': u32\n     [194; 210) 'Foo::A..._CONST': u32\n-    [126; 128) '99': u32\n     \"###\n     );\n }\n@@ -4694,14 +4718,16 @@ fn infer(content: &str) -> String {\n         }\n \n         // sort ranges for consistency\n-        types.sort_by_key(|(src_ptr, _)| (src_ptr.ast.range().start(), src_ptr.ast.range().end()));\n+        types.sort_by_key(|(src_ptr, _)| {\n+            (src_ptr.value.range().start(), src_ptr.value.range().end())\n+        });\n         for (src_ptr, ty) in &types {\n-            let node = src_ptr.ast.to_node(&src_ptr.file_syntax(&db));\n+            let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n                 (self_param.self_kw_token().text_range(), \"self\".to_string())\n             } else {\n-                (src_ptr.ast.range(), node.text().to_string().replace(\"\\n\", \" \"))\n+                (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };\n             let macro_prefix = if src_ptr.file_id != file_id.into() { \"!\" } else { \"\" };\n             write!(\n@@ -4716,10 +4742,13 @@ fn infer(content: &str) -> String {\n         }\n     };\n \n+    let mut analyzed = FxHashSet::default();\n     for node in source_file.syntax().descendants() {\n         if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n             let analyzer = SourceAnalyzer::new(&db, Source::new(file_id.into(), &node), None);\n-            infer_def(analyzer.inference_result(), analyzer.body_source_map());\n+            if analyzed.insert(analyzer.analyzed_declaration()) {\n+                infer_def(analyzer.inference_result(), analyzer.body_source_map());\n+            }\n         }\n     }\n "}, {"sha": "392f244cf17d872cc4bddff3e44c666cd4230afd", "filename": "crates/ra_hir/src/type_alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -23,7 +23,7 @@ impl TypeAliasData {\n         db: &(impl DefDatabase + AstDatabase),\n         typ: TypeAlias,\n     ) -> Arc<TypeAliasData> {\n-        let node = typ.source(db).ast;\n+        let node = typ.source(db).value;\n         let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n         let type_ref = node.type_ref().map(TypeRef::from_ast);\n         Arc::new(TypeAliasData { name, type_ref })"}, {"sha": "d04f54e15a4ad67163fb3032d5c32e4f44060018", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -54,8 +54,8 @@ impl StructData {\n         id: StructOrUnionId,\n     ) -> Arc<StructData> {\n         let src = id.source(db);\n-        let name = src.ast.name().map(|n| n.as_name());\n-        let variant_data = VariantData::new(src.ast.kind());\n+        let name = src.value.name().map(|n| n.as_name());\n+        let variant_data = VariantData::new(src.value.kind());\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n@@ -64,9 +64,9 @@ impl StructData {\n impl EnumData {\n     pub(crate) fn enum_data_query(db: &impl DefDatabase2, e: EnumId) -> Arc<EnumData> {\n         let src = e.source(db);\n-        let name = src.ast.name().map(|n| n.as_name());\n+        let name = src.value.name().map(|n| n.as_name());\n         let variants = src\n-            .ast\n+            .value\n             .variant_list()\n             .into_iter()\n             .flat_map(|it| it.variants())"}, {"sha": "dfb79a30acaee6574c496ae5dc07cfe84878201c", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::CrateDefMap,\n     path::Path,\n-    AstItemDef, DefWithBodyId, ModuleId,\n+    AstItemDef, DefWithBodyId, HasModule, HasSource, Lookup, ModuleId,\n };\n \n pub struct Expander {\n@@ -73,8 +73,8 @@ impl Expander {\n         std::mem::forget(mark);\n     }\n \n-    fn to_source<T>(&self, ast: T) -> Source<T> {\n-        Source { file_id: self.current_file_id, ast }\n+    fn to_source<T>(&self, value: T) -> Source<T> {\n+        Source { file_id: self.current_file_id, value }\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n@@ -149,17 +149,19 @@ impl Body {\n \n         let (file_id, module, body) = match def {\n             DefWithBodyId::FunctionId(f) => {\n+                let f = f.lookup(db);\n                 let src = f.source(db);\n-                params = src.ast.param_list();\n-                (src.file_id, f.module(db), src.ast.body().map(ast::Expr::from))\n+                params = src.value.param_list();\n+                (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))\n             }\n             DefWithBodyId::ConstId(c) => {\n+                let c = c.lookup(db);\n                 let src = c.source(db);\n-                (src.file_id, c.module(db), src.ast.body())\n+                (src.file_id, c.module(db), src.value.body())\n             }\n             DefWithBodyId::StaticId(s) => {\n                 let src = s.source(db);\n-                (src.file_id, s.module(db), src.ast.body())\n+                (src.file_id, s.module(db), src.value.body())\n             }\n         };\n         let expander = Expander::new(db, file_id, module);"}, {"sha": "aeb71ff229ff9aa7a85a46f06aac6143e623c024", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -210,8 +210,9 @@ mod tests {\n         let scopes = db.expr_scopes(function.into());\n         let (_body, source_map) = db.body_with_source_map(function.into());\n \n-        let expr_id =\n-            source_map.node_expr(Source { file_id: file_id.into(), ast: &marker.into() }).unwrap();\n+        let expr_id = source_map\n+            .node_expr(Source { file_id: file_id.into(), value: &marker.into() })\n+            .unwrap();\n         let scope = scopes.scope_for(expr_id);\n \n         let actual = scopes\n@@ -317,14 +318,14 @@ mod tests {\n         let expr_scope = {\n             let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n             let expr_id =\n-                source_map.node_expr(Source { file_id: file_id.into(), ast: &expr_ast }).unwrap();\n+                source_map.node_expr(Source { file_id: file_id.into(), value: &expr_ast }).unwrap();\n             scopes.scope_for(expr_id).unwrap()\n         };\n \n         let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n         let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n \n-        let local_name = pat_src.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+        let local_name = pat_src.value.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().text_range());\n     }\n "}, {"sha": "844f8bbe88bab24df14e069a695509ea95b3b83f", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -8,30 +8,32 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n-    imp::ImplData,\n+    generics::GenericParams,\n+    impls::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    DefWithBodyId, EnumId, ImplId, ItemLoc, StructOrUnionId,\n+    traits::TraitData,\n+    DefWithBodyId, EnumId, GenericDefId, ImplId, ItemLoc, StructOrUnionId, TraitId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n-    fn intern_function(&self, loc: ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    fn intern_function(&self, loc: crate::FunctionLoc) -> crate::FunctionId;\n     #[salsa::interned]\n     fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> crate::StructOrUnionId;\n     #[salsa::interned]\n     fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> crate::EnumId;\n     #[salsa::interned]\n-    fn intern_const(&self, loc: ItemLoc<ast::ConstDef>) -> crate::ConstId;\n+    fn intern_const(&self, loc: crate::ConstLoc) -> crate::ConstId;\n     #[salsa::interned]\n     fn intern_static(&self, loc: ItemLoc<ast::StaticDef>) -> crate::StaticId;\n     #[salsa::interned]\n     fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> crate::TraitId;\n     #[salsa::interned]\n-    fn intern_type_alias(&self, loc: ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+    fn intern_type_alias(&self, loc: crate::TypeAliasLoc) -> crate::TypeAliasId;\n     #[salsa::interned]\n     fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> crate::ImplId;\n }\n@@ -59,6 +61,9 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n+    #[salsa::invoke(TraitData::trait_data_query)]\n+    fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n \n@@ -67,4 +72,7 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n \n     #[salsa::invoke(ExprScopes::expr_scopes_query)]\n     fn expr_scopes(&self, def: DefWithBodyId) -> Arc<ExprScopes>;\n+\n+    #[salsa::invoke(GenericParams::generic_params_query)]\n+    fn generic_params(&self, def: GenericDefId) -> Arc<GenericParams>;\n }"}, {"sha": "eda9b2269a45a4b83a51dcba8e13edc25a7645ad", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -20,7 +20,7 @@ impl Diagnostic for UnresolvedModule {\n         \"unresolved module\".to_string()\n     }\n     fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.decl.into() }\n+        Source { file_id: self.file, value: self.decl.into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self"}, {"sha": "9e2e4c3cc311b0657d5d2dc9e7862ef40f5b58c4", "filename": "crates/ra_hir_def/src/generics.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -0,0 +1,185 @@\n+//! Many kinds of items or constructs can have generic parameters: functions,\n+//! structs, impls, traits, etc. This module provides a common HIR for these\n+//! generic parameters. See also the `Generics` type and the `generics_of` query\n+//! in rustc.\n+use std::sync::Arc;\n+\n+use hir_expand::name::{self, AsName, Name};\n+use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n+\n+use crate::{\n+    db::DefDatabase2,\n+    type_ref::{TypeBound, TypeRef},\n+    AdtId, AstItemDef, ContainerId, GenericDefId, HasSource, Lookup,\n+};\n+\n+/// Data about a generic parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParam {\n+    // FIXME: give generic params proper IDs\n+    pub idx: u32,\n+    pub name: Name,\n+    pub default: Option<TypeRef>,\n+}\n+\n+/// Data about the generic parameters of a function, struct, impl, etc.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParams {\n+    pub parent_params: Option<Arc<GenericParams>>,\n+    pub params: Vec<GenericParam>,\n+    pub where_predicates: Vec<WherePredicate>,\n+}\n+\n+/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n+/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+/// It might still result in multiple actual predicates though, because of\n+/// associated type bindings like `Iterator<Item = u32>`.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct WherePredicate {\n+    pub type_ref: TypeRef,\n+    pub bound: TypeBound,\n+}\n+\n+impl GenericParams {\n+    pub(crate) fn generic_params_query(\n+        db: &impl DefDatabase2,\n+        def: GenericDefId,\n+    ) -> Arc<GenericParams> {\n+        let parent_generics = parent_generic_def(db, def).map(|it| db.generic_params(it));\n+        Arc::new(GenericParams::new(db, def.into(), parent_generics))\n+    }\n+\n+    fn new(\n+        db: &impl DefDatabase2,\n+        def: GenericDefId,\n+        parent_params: Option<Arc<GenericParams>>,\n+    ) -> GenericParams {\n+        let mut generics =\n+            GenericParams { params: Vec::new(), parent_params, where_predicates: Vec::new() };\n+        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n+        // FIXME: add `: Sized` bound for everything except for `Self` in traits\n+        match def {\n+            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n+            GenericDefId::AdtId(AdtId::StructId(it)) => {\n+                generics.fill(&it.0.source(db).value, start)\n+            }\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.0.source(db).value, start),\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::TraitId(it) => {\n+                // traits get the Self type as an implicit first type parameter\n+                generics.params.push(GenericParam {\n+                    idx: start,\n+                    name: name::SELF_TYPE,\n+                    default: None,\n+                });\n+                generics.fill(&it.source(db).value, start + 1);\n+                // add super traits as bounds on Self\n+                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n+                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n+                generics.fill_bounds(&it.source(db).value, self_param);\n+            }\n+            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n+            // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n+            // type-parameter, but rather is a type-alias for impl's target\n+            // type, so this is handled by the resolver.\n+            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n+        }\n+\n+        generics\n+    }\n+\n+    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n+        if let Some(params) = node.type_param_list() {\n+            self.fill_params(params, start)\n+        }\n+        if let Some(where_clause) = node.where_clause() {\n+            self.fill_where_predicates(where_clause);\n+        }\n+    }\n+\n+    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n+        for bound in\n+            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n+        {\n+            self.add_where_predicate_from_bound(bound, type_ref.clone());\n+        }\n+    }\n+\n+    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n+        for (idx, type_param) in params.type_params().enumerate() {\n+            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+            // FIXME: Use `Path::from_src`\n+            let default = type_param.default_type().map(TypeRef::from_ast);\n+            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n+            self.params.push(param);\n+\n+            let type_ref = TypeRef::Path(name.into());\n+            self.fill_bounds(&type_param, type_ref);\n+        }\n+    }\n+\n+    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n+        for pred in where_clause.predicates() {\n+            let type_ref = match pred.type_ref() {\n+                Some(type_ref) => type_ref,\n+                None => continue,\n+            };\n+            let type_ref = TypeRef::from_ast(type_ref);\n+            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            }\n+        }\n+    }\n+\n+    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n+        if bound.has_question_mark() {\n+            // FIXME: remove this bound\n+            return;\n+        }\n+        let bound = TypeBound::from_ast(bound);\n+        self.where_predicates.push(WherePredicate { type_ref, bound });\n+    }\n+\n+    pub fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n+        self.params.iter().find(|p| &p.name == name)\n+    }\n+\n+    pub fn count_parent_params(&self) -> usize {\n+        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n+    }\n+\n+    pub fn count_params_including_parent(&self) -> usize {\n+        let parent_count = self.count_parent_params();\n+        parent_count + self.params.len()\n+    }\n+\n+    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n+        if let Some(parent) = &self.parent_params {\n+            parent.for_each_param(f);\n+        }\n+        self.params.iter().for_each(f);\n+    }\n+\n+    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n+        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n+        self.for_each_param(&mut |p| vec.push(p));\n+        vec\n+    }\n+}\n+\n+fn parent_generic_def(db: &impl DefDatabase2, def: GenericDefId) -> Option<GenericDefId> {\n+    let container = match def {\n+        GenericDefId::FunctionId(it) => it.lookup(db).container,\n+        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n+        GenericDefId::ConstId(it) => it.lookup(db).container,\n+        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n+        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n+    };\n+\n+    match container {\n+        ContainerId::ImplId(it) => Some(it.into()),\n+        ContainerId::TraitId(it) => Some(it.into()),\n+        ContainerId::ModuleId(_) => None,\n+    }\n+}"}, {"sha": "750a869f256fa9cc02e5669ec5094d91bb7a716e", "filename": "crates/ra_hir_def/src/impls.rs", "status": "renamed", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -5,11 +5,12 @@\n \n use std::sync::Arc;\n \n+use hir_expand::AstId;\n use ra_syntax::ast;\n \n use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstId, FunctionId, ImplId,\n-    LocationCtx, TypeAliasId,\n+    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstLoc, ContainerId,\n+    FunctionLoc, ImplId, Intern, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -25,23 +26,37 @@ impl ImplData {\n         let src = id.source(db);\n         let items = db.ast_id_map(src.file_id);\n \n-        let target_trait = src.ast.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.ast.target_type());\n-        let negative = src.ast.is_negative();\n+        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let negative = src.value.is_negative();\n \n-        let items = if let Some(item_list) = src.ast.item_list() {\n-            let ctx = LocationCtx::new(db, id.module(db), src.file_id);\n+        let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node {\n                     ast::ImplItem::FnDef(it) => {\n-                        FunctionId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                        let def = FunctionLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n                     }\n                     ast::ImplItem::ConstDef(it) => {\n-                        ConstId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                        let def = ConstLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n                     }\n                     ast::ImplItem::TypeAliasDef(it) => {\n-                        TypeAliasId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                        let def = TypeAliasLoc {\n+                            container: ContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        def.into()\n                     }\n                 })\n                 .collect()", "previous_filename": "crates/ra_hir_def/src/imp.rs"}, {"sha": "0af41de879b09ee449709fd31ed60545949728f2", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 161, "deletions": 19, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -13,10 +13,12 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n-pub mod imp;\n+pub mod impls;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n+pub mod generics;\n+pub mod traits;\n \n #[cfg(test)]\n mod test_db;\n@@ -80,7 +82,7 @@ impl ModuleSource {\n \n     pub fn from_child_node(db: &impl db::DefDatabase2, child: Source<&SyntaxNode>) -> ModuleSource {\n         if let Some(m) =\n-            child.ast.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n+            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n         {\n             ModuleSource::Module(m)\n         } else {\n@@ -184,8 +186,8 @@ pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n     }\n     fn source(self, db: &(impl AstDatabase + InternDatabase)) -> Source<N> {\n         let loc = self.lookup_intern(db);\n-        let ast = loc.ast_id.to_node(db);\n-        Source { file_id: loc.ast_id.file_id(), ast }\n+        let value = loc.ast_id.to_node(db);\n+        Source { file_id: loc.ast_id.file_id(), value }\n     }\n     fn module(self, db: &impl InternDatabase) -> ModuleId {\n         let loc = self.lookup_intern(db);\n@@ -197,12 +199,23 @@ pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n pub struct FunctionId(salsa::InternId);\n impl_intern_key!(FunctionId);\n \n-impl AstItemDef<ast::FnDef> for FunctionId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n-        db.intern_function(loc)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FunctionLoc {\n+    pub container: ContainerId,\n+    pub ast_id: AstId<ast::FnDef>,\n+}\n+\n+impl Intern for FunctionLoc {\n+    type ID = FunctionId;\n+    fn intern(self, db: &impl db::DefDatabase2) -> FunctionId {\n+        db.intern_function(self)\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::FnDef> {\n-        db.lookup_intern_function(self)\n+}\n+\n+impl Lookup for FunctionId {\n+    type Data = FunctionLoc;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> FunctionLoc {\n+        db.lookup_intern_function(*self)\n     }\n }\n \n@@ -276,12 +289,23 @@ impl_arena_id!(LocalStructFieldId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n impl_intern_key!(ConstId);\n-impl AstItemDef<ast::ConstDef> for ConstId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ConstDef>) -> Self {\n-        db.intern_const(loc)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstLoc {\n+    pub container: ContainerId,\n+    pub ast_id: AstId<ast::ConstDef>,\n+}\n+\n+impl Intern for ConstLoc {\n+    type ID = ConstId;\n+    fn intern(self, db: &impl db::DefDatabase2) -> ConstId {\n+        db.intern_const(self)\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ConstDef> {\n-        db.lookup_intern_const(self)\n+}\n+\n+impl Lookup for ConstId {\n+    type Data = ConstLoc;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> ConstLoc {\n+        db.lookup_intern_const(*self)\n     }\n }\n \n@@ -312,12 +336,24 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n impl_intern_key!(TypeAliasId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TypeAliasDef>) -> Self {\n-        db.intern_type_alias(loc)\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeAliasLoc {\n+    pub container: ContainerId,\n+    pub ast_id: AstId<ast::TypeAliasDef>,\n+}\n+\n+impl Intern for TypeAliasLoc {\n+    type ID = TypeAliasId;\n+    fn intern(self, db: &impl db::DefDatabase2) -> TypeAliasId {\n+        db.intern_type_alias(self)\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TypeAliasDef> {\n-        db.lookup_intern_type_alias(self)\n+}\n+\n+impl Lookup for TypeAliasId {\n+    type Data = TypeAliasLoc;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> TypeAliasLoc {\n+        db.lookup_intern_type_alias(*self)\n     }\n }\n \n@@ -352,6 +388,13 @@ macro_rules! impl_froms {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ContainerId {\n+    ModuleId(ModuleId),\n+    ImplId(ImplId),\n+    TraitId(TraitId),\n+}\n+\n /// A Data Type\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AdtId {\n@@ -408,3 +451,102 @@ pub enum AssocItemId {\n // require not implementing From, and instead having some checked way of\n // casting them, and somehow making the constructors private, which would be annoying.\n impl_froms!(AssocItemId: FunctionId, ConstId, TypeAliasId);\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericDefId {\n+    FunctionId(FunctionId),\n+    AdtId(AdtId),\n+    TraitId(TraitId),\n+    TypeAliasId(TypeAliasId),\n+    ImplId(ImplId),\n+    // enum variants cannot have generics themselves, but their parent enums\n+    // can, and this makes some code easier to write\n+    EnumVariantId(EnumVariantId),\n+    // consts can have type parameters from their parents (i.e. associated consts of traits)\n+    ConstId(ConstId),\n+}\n+impl_froms!(\n+    GenericDefId: FunctionId,\n+    AdtId(StructId, EnumId, UnionId),\n+    TraitId,\n+    TypeAliasId,\n+    ImplId,\n+    EnumVariantId,\n+    ConstId\n+);\n+\n+trait Intern {\n+    type ID;\n+    fn intern(self, db: &impl db::DefDatabase2) -> Self::ID;\n+}\n+\n+pub trait Lookup {\n+    type Data;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> Self::Data;\n+}\n+\n+pub trait HasModule {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId;\n+}\n+\n+impl HasModule for FunctionLoc {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+        match self.container {\n+            ContainerId::ModuleId(it) => it,\n+            ContainerId::ImplId(it) => it.module(db),\n+            ContainerId::TraitId(it) => it.module(db),\n+        }\n+    }\n+}\n+\n+impl HasModule for TypeAliasLoc {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+        match self.container {\n+            ContainerId::ModuleId(it) => it,\n+            ContainerId::ImplId(it) => it.module(db),\n+            ContainerId::TraitId(it) => it.module(db),\n+        }\n+    }\n+}\n+\n+impl HasModule for ConstLoc {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+        match self.container {\n+            ContainerId::ModuleId(it) => it,\n+            ContainerId::ImplId(it) => it.module(db),\n+            ContainerId::TraitId(it) => it.module(db),\n+        }\n+    }\n+}\n+\n+pub trait HasSource {\n+    type Value;\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<Self::Value>;\n+}\n+\n+impl HasSource for FunctionLoc {\n+    type Value = ast::FnDef;\n+\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::FnDef> {\n+        let node = self.ast_id.to_node(db);\n+        Source::new(self.ast_id.file_id(), node)\n+    }\n+}\n+\n+impl HasSource for TypeAliasLoc {\n+    type Value = ast::TypeAliasDef;\n+\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::TypeAliasDef> {\n+        let node = self.ast_id.to_node(db);\n+        Source::new(self.ast_id.file_id(), node)\n+    }\n+}\n+\n+impl HasSource for ConstLoc {\n+    type Value = ast::ConstDef;\n+\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::ConstDef> {\n+        let node = self.ast_id.to_node(db);\n+        Source::new(self.ast_id.file_id(), node)\n+    }\n+}"}, {"sha": "c01e020ef12e00b6d8789019c778edf9938162ce", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -165,6 +165,14 @@ impl ModuleScope {\n         self.items.iter().chain(BUILTIN_SCOPE.iter())\n     }\n \n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.entries()\n+            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n+            .flat_map(|per_ns| {\n+                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n+            })\n+    }\n+\n     /// Iterate over all module scoped macros\n     pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n         self.items"}, {"sha": "aae3dcadf7befd73871dfcc0e080773b60031bcb", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -19,9 +19,9 @@ use crate::{\n         per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId, ImplId,\n-    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, StructOrUnionId, TraitId, TypeAliasId,\n-    UnionId,\n+    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, CrateModuleId, EnumId, EnumVariantId,\n+    FunctionLoc, ImplId, Intern, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n+    StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -673,8 +673,13 @@ where\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n             raw::DefKind::Function(ast_id) => {\n-                let f = FunctionId::from_ast_id(ctx, ast_id);\n-                PerNs::values(f.into())\n+                let def = FunctionLoc {\n+                    container: ContainerId::ModuleId(module),\n+                    ast_id: AstId::new(self.file_id, ast_id),\n+                }\n+                .intern(self.def_collector.db);\n+\n+                PerNs::values(def.into())\n             }\n             raw::DefKind::Struct(ast_id) => {\n                 let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();\n@@ -687,13 +692,27 @@ where\n                 PerNs::both(u, u)\n             }\n             raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n-            raw::DefKind::Const(ast_id) => PerNs::values(ConstId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::Const(ast_id) => {\n+                let def = ConstLoc {\n+                    container: ContainerId::ModuleId(module),\n+                    ast_id: AstId::new(self.file_id, ast_id),\n+                }\n+                .intern(self.def_collector.db);\n+\n+                PerNs::values(def.into())\n+            }\n             raw::DefKind::Static(ast_id) => {\n                 PerNs::values(StaticId::from_ast_id(ctx, ast_id).into())\n             }\n             raw::DefKind::Trait(ast_id) => PerNs::types(TraitId::from_ast_id(ctx, ast_id).into()),\n             raw::DefKind::TypeAlias(ast_id) => {\n-                PerNs::types(TypeAliasId::from_ast_id(ctx, ast_id).into())\n+                let def = TypeAliasLoc {\n+                    container: ContainerId::ModuleId(module),\n+                    ast_id: AstId::new(self.file_id, ast_id),\n+                }\n+                .intern(self.def_collector.db);\n+\n+                PerNs::types(def.into())\n             }\n         };\n         let resolution = Resolution { def, import: None };"}, {"sha": "7c68fd63803dd79ade2ac14d12427c3d25087a4b", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -327,7 +327,7 @@ impl RawItemsCollector {\n \n         let mut buf = Vec::new();\n         Path::expand_use_item(\n-            Source { ast: use_item, file_id: self.file_id },\n+            Source { value: use_item, file_id: self.file_id },\n             &self.hygiene,\n             |path, use_tree, is_glob, alias| {\n                 let import_data = ImportData {"}, {"sha": "626ebffdc8989f4339a299ff3c3c230cf64bbf59", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -71,7 +71,7 @@ impl Path {\n         hygiene: &Hygiene,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n-        if let Some(tree) = item_src.ast.use_tree() {\n+        if let Some(tree) = item_src.value.use_tree() {\n             expand_use_tree(None, tree, hygiene, &mut cb);\n         }\n     }"}, {"sha": "877d73d666d7b5fbcc405a18c3beb431400485b3", "filename": "crates/ra_hir_def/src/traits.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -0,0 +1,59 @@\n+//! HIR for trait definitions.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{\n+    name::{AsName, Name},\n+    AstId,\n+};\n+\n+use ra_syntax::ast::{self, NameOwner};\n+\n+use crate::{\n+    db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n+    TypeAliasLoc,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Option<Name>,\n+    pub items: Vec<AssocItemId>,\n+    pub auto: bool,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n+        let src = tr.source(db);\n+        let name = src.value.name().map(|n| n.as_name());\n+        let auto = src.value.is_auto();\n+        let ast_id_map = db.ast_id_map(src.file_id);\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => FunctionLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::ConstDef(it) => ConstLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n+                        container: ContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items, auto })\n+    }\n+}"}, {"sha": "3d37e933583fa5188c82c966bad3875cb30a9f47", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -24,7 +24,7 @@ pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n     fn source(&self) -> Source<SyntaxNodePtr>;\n     fn highlight_range(&self) -> TextRange {\n-        self.source().ast.range()\n+        self.source().value.range()\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n }\n@@ -37,7 +37,7 @@ pub trait AstDiagnostic {\n impl dyn Diagnostic {\n     pub fn syntax_node(&self, db: &impl AstDatabase) -> SyntaxNode {\n         let node = db.parse_or_expand(self.source().file_id).unwrap();\n-        self.source().ast.to_node(&node)\n+        self.source().value.to_node(&node)\n     }\n \n     pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {"}, {"sha": "1389f64ce96123b39c8bc61314240cab189f04fd", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -166,19 +166,19 @@ impl ExpansionInfo {\n     pub fn map_token_down(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>> {\n         assert_eq!(token.file_id, self.arg.file_id);\n         let range =\n-            token.ast.text_range().checked_sub(self.arg.ast.syntax().text_range().start())?;\n+            token.value.text_range().checked_sub(self.arg.value.syntax().text_range().start())?;\n         let token_id = self.macro_arg.1.token_by_range(range)?;\n         let token_id = self.macro_def.0.map_id_down(token_id);\n \n         let range = self.exp_map.range_by_token(token_id)?;\n \n-        let token = algo::find_covering_element(&self.expanded.ast, range).into_token()?;\n+        let token = algo::find_covering_element(&self.expanded.value, range).into_token()?;\n \n-        Some(self.expanded.with_ast(token))\n+        Some(self.expanded.with_value(token))\n     }\n \n     pub fn map_token_up(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>> {\n-        let token_id = self.exp_map.token_by_range(token.ast.text_range())?;\n+        let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n@@ -188,11 +188,11 @@ impl ExpansionInfo {\n \n         let range = token_map.range_by_token(token_id)?;\n         let token = algo::find_covering_element(\n-            tt.ast.syntax(),\n-            range + tt.ast.syntax().text_range().start(),\n+            tt.value.syntax(),\n+            range + tt.value.syntax().text_range().start(),\n         )\n         .into_token()?;\n-        Some(tt.with_ast(token))\n+        Some(tt.with_value(token))\n     }\n }\n \n@@ -240,30 +240,34 @@ impl<N: AstNode> AstId<N> {\n     }\n }\n \n-/// FIXME: https://github.com/matklad/with ?\n+/// `Source<T>` stores a value of `T` inside a particular file/syntax tree.\n+///\n+/// Typical usages are:\n+///\n+/// * `Source<SyntaxNode>` -- syntax node in a file\n+/// * `Source<ast::FnDef>` -- ast node in a file\n+/// * `Source<TextUnit>` -- offset in a file\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n pub struct Source<T> {\n     pub file_id: HirFileId,\n-    // FIXME: this stores all kind of things, not only `ast`.\n-    // There should be a better name...\n-    pub ast: T,\n+    pub value: T,\n }\n \n impl<T> Source<T> {\n-    pub fn new(file_id: HirFileId, ast: T) -> Source<T> {\n-        Source { file_id, ast }\n+    pub fn new(file_id: HirFileId, value: T) -> Source<T> {\n+        Source { file_id, value }\n     }\n \n     // Similarly, naming here is stupid...\n-    pub fn with_ast<U>(&self, ast: U) -> Source<U> {\n-        Source::new(self.file_id, ast)\n+    pub fn with_value<U>(&self, value: U) -> Source<U> {\n+        Source::new(self.file_id, value)\n     }\n \n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source::new(self.file_id, f(self.ast))\n+        Source::new(self.file_id, f(self.value))\n     }\n     pub fn as_ref(&self) -> Source<&T> {\n-        self.with_ast(&self.ast)\n+        self.with_value(&self.value)\n     }\n     pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")"}, {"sha": "3c607d5b53c40c7a03e90014dd1bff3f5cb46cb7", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -309,7 +309,6 @@ impl RootDatabase {\n             hir::db::StructDataQuery\n             hir::db::EnumDataQuery\n             hir::db::TraitDataQuery\n-            hir::db::TraitItemsIndexQuery\n             hir::db::RawItemsWithSourceMapQuery\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery"}, {"sha": "d5739b58a6d759741360c196397b18821c332fc5", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -304,6 +304,13 @@ mod tests {\n             ),\n             @r###\"\n         [\n+            CompletionItem {\n+                label: \"Self\",\n+                source_range: [54; 54),\n+                delete: [54; 54),\n+                insert: \"Self\",\n+                kind: TypeParam,\n+            },\n             CompletionItem {\n                 label: \"T\",\n                 source_range: [54; 54),"}, {"sha": "b8345c91d521b7d45cbbacf96fcd6caae4b37b88", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -54,7 +54,7 @@ impl<'a> CompletionContext<'a> {\n         let src = hir::ModuleSource::from_position(db, position);\n         let module = hir::Module::from_definition(\n             db,\n-            hir::Source { file_id: position.file_id.into(), ast: src },\n+            hir::Source { file_id: position.file_id.into(), value: src },\n         );\n         let token =\n             original_parse.tree().syntax().token_at_offset(position.offset).left_biased()?;"}, {"sha": "b20329459c8f36cd2c0af8ffebf7275e5c8e5541", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -169,7 +169,7 @@ impl Completions {\n             None => return,\n         };\n \n-        let ast_node = macro_.source(ctx.db).ast;\n+        let ast_node = macro_.source(ctx.db).value;\n         let detail = macro_label(&ast_node);\n \n         let docs = macro_.docs(ctx.db);\n@@ -201,7 +201,7 @@ impl Completions {\n     ) {\n         let data = func.data(ctx.db);\n         let name = name.unwrap_or_else(|| data.name().to_string());\n-        let ast_node = func.source(ctx.db).ast;\n+        let ast_node = func.source(ctx.db).value;\n         let detail = function_label(&ast_node);\n \n         let mut builder =\n@@ -234,7 +234,7 @@ impl Completions {\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n-        let ast_node = constant.source(ctx.db).ast;\n+        let ast_node = constant.source(ctx.db).value;\n         let name = match ast_node.name() {\n             Some(name) => name,\n             _ => return,\n@@ -250,7 +250,7 @@ impl Completions {\n     }\n \n     pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n-        let type_def = type_alias.source(ctx.db).ast;\n+        let type_def = type_alias.source(ctx.db).value;\n         let name = match type_def.name() {\n             Some(name) => name,\n             _ => return,"}, {"sha": "cc1ccab4b5fa39325f02117ef83130eee3783f63", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -96,7 +96,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     });\n     let source_file = db.parse(file_id).tree();\n     let src =\n-        hir::Source { file_id: file_id.into(), ast: hir::ModuleSource::SourceFile(source_file) };\n+        hir::Source { file_id: file_id.into(), value: hir::ModuleSource::SourceFile(source_file) };\n     if let Some(m) = hir::Module::from_definition(db, src) {\n         m.diagnostics(db, &mut sink);\n     };"}, {"sha": "f42dffc876d4fd5ac3a0ab3c52ef272fa3d91476", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -48,12 +48,12 @@ impl FunctionSignature {\n \n     pub(crate) fn from_hir(db: &db::RootDatabase, function: hir::Function) -> Self {\n         let doc = function.docs(db);\n-        let ast_node = function.source(db).ast;\n+        let ast_node = function.source(db).value;\n         FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n \n     pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Option<Self> {\n-        let node: ast::StructDef = st.source(db).ast;\n+        let node: ast::StructDef = st.source(db).value;\n         match node.kind() {\n             ast::StructKind::Named(_) => return None,\n             _ => (),\n@@ -87,7 +87,7 @@ impl FunctionSignature {\n         db: &db::RootDatabase,\n         variant: hir::EnumVariant,\n     ) -> Option<Self> {\n-        let node: ast::EnumVariant = variant.source(db).ast;\n+        let node: ast::EnumVariant = variant.source(db).value;\n         match node.kind() {\n             ast::StructKind::Named(_) | ast::StructKind::Unit => return None,\n             _ => (),\n@@ -126,7 +126,7 @@ impl FunctionSignature {\n     }\n \n     pub(crate) fn from_macro(db: &db::RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n-        let node: ast::MacroCall = macro_def.source(db).ast;\n+        let node: ast::MacroCall = macro_def.source(db).value;\n \n         let params = vec![];\n "}, {"sha": "6ac60722b9a00a37afa32776b8515e3052091426", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -86,9 +86,9 @@ impl NavigationTarget {\n                 name,\n                 None,\n                 frange.range,\n-                src.ast.syntax().kind(),\n-                src.ast.doc_comment_text(),\n-                src.ast.short_label(),\n+                src.value.syntax().kind(),\n+                src.value.doc_comment_text(),\n+                src.value.short_label(),\n             );\n         }\n         module.to_nav(db)\n@@ -146,17 +146,17 @@ impl NavigationTarget {\n         description: Option<String>,\n     ) -> NavigationTarget {\n         //FIXME: use `_` instead of empty string\n-        let name = node.ast.name().map(|it| it.text().clone()).unwrap_or_default();\n+        let name = node.value.name().map(|it| it.text().clone()).unwrap_or_default();\n         let focus_range =\n-            node.ast.name().map(|it| original_range(db, node.with_ast(it.syntax())).range);\n+            node.value.name().map(|it| original_range(db, node.with_value(it.syntax())).range);\n         let frange = original_range(db, node.map(|it| it.syntax()));\n \n         NavigationTarget::from_syntax(\n             frange.file_id,\n             name,\n             focus_range,\n             frange.range,\n-            node.ast.syntax().kind(),\n+            node.value.syntax().kind(),\n             docs,\n             description,\n         )\n@@ -220,8 +220,8 @@ where\n         NavigationTarget::from_named(\n             db,\n             src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.ast.doc_comment_text(),\n-            src.ast.short_label(),\n+            src.value.doc_comment_text(),\n+            src.value.short_label(),\n         )\n     }\n }\n@@ -230,9 +230,9 @@ impl ToNav for hir::Module {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.definition_source(db);\n         let name = self.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n-        match &src.ast {\n+        match &src.value {\n             ModuleSource::SourceFile(node) => {\n-                let frange = original_range(db, src.with_ast(node.syntax()));\n+                let frange = original_range(db, src.with_value(node.syntax()));\n \n                 NavigationTarget::from_syntax(\n                     frange.file_id,\n@@ -245,7 +245,7 @@ impl ToNav for hir::Module {\n                 )\n             }\n             ModuleSource::Module(node) => {\n-                let frange = original_range(db, src.with_ast(node.syntax()));\n+                let frange = original_range(db, src.with_value(node.syntax()));\n \n                 NavigationTarget::from_syntax(\n                     frange.file_id,\n@@ -271,7 +271,7 @@ impl ToNav for hir::ImplBlock {\n             \"impl\".into(),\n             None,\n             frange.range,\n-            src.ast.syntax().kind(),\n+            src.value.syntax().kind(),\n             None,\n             None,\n         )\n@@ -282,15 +282,15 @@ impl ToNav for hir::StructField {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n \n-        match &src.ast {\n+        match &src.value {\n             FieldSource::Named(it) => NavigationTarget::from_named(\n                 db,\n-                src.with_ast(it),\n+                src.with_value(it),\n                 it.doc_comment_text(),\n                 it.short_label(),\n             ),\n             FieldSource::Pos(it) => {\n-                let frange = original_range(db, src.with_ast(it.syntax()));\n+                let frange = original_range(db, src.with_value(it.syntax()));\n                 NavigationTarget::from_syntax(\n                     frange.file_id,\n                     \"\".into(),\n@@ -308,11 +308,11 @@ impl ToNav for hir::StructField {\n impl ToNav for hir::MacroDef {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        log::debug!(\"nav target {:#?}\", src.ast.syntax());\n+        log::debug!(\"nav target {:#?}\", src.value.syntax());\n         NavigationTarget::from_named(\n             db,\n             src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.ast.doc_comment_text(),\n+            src.value.doc_comment_text(),\n             None,\n         )\n     }\n@@ -341,7 +341,7 @@ impl ToNav for hir::AssocItem {\n impl ToNav for hir::Local {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        let (full_range, focus_range) = match src.ast {\n+        let (full_range, focus_range) = match src.value {\n             Either::A(it) => {\n                 (it.syntax().text_range(), it.name().map(|it| it.syntax().text_range()))\n             }"}, {"sha": "2f1abf509a00549b1359cef237341023a30ec8b9", "filename": "crates/ra_ide_api/src/expand.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fexpand.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -12,7 +12,7 @@ pub(crate) fn original_range(db: &RootDatabase, node: Source<&SyntaxNode>) -> Fi\n         None => {\n             return FileRange {\n                 file_id: node.file_id.original_file(db),\n-                range: node.ast.text_range(),\n+                range: node.value.text_range(),\n             }\n         }\n         Some(it) => it,\n@@ -25,14 +25,18 @@ pub(crate) fn original_range(db: &RootDatabase, node: Source<&SyntaxNode>) -> Fi\n     // *Second*, we should handle recurside macro expansions\n \n     let token = node\n-        .ast\n+        .value\n         .descendants_with_tokens()\n         .filter_map(|it| it.into_token())\n-        .find_map(|it| expansion.map_token_up(node.with_ast(&it)));\n+        .find_map(|it| expansion.map_token_up(node.with_value(&it)));\n \n     match token {\n-        Some(it) => FileRange { file_id: it.file_id.original_file(db), range: it.ast.text_range() },\n-        None => FileRange { file_id: node.file_id.original_file(db), range: node.ast.text_range() },\n+        Some(it) => {\n+            FileRange { file_id: it.file_id.original_file(db), range: it.value.text_range() }\n+        }\n+        None => {\n+            FileRange { file_id: node.file_id.original_file(db), range: node.value.text_range() }\n+        }\n     }\n }\n \n@@ -44,14 +48,14 @@ pub(crate) fn descend_into_macros(\n     let src = Source::new(file_id.into(), token);\n \n     successors(Some(src), |token| {\n-        let macro_call = token.ast.ancestors().find_map(ast::MacroCall::cast)?;\n+        let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n         let tt = macro_call.token_tree()?;\n-        if !token.ast.text_range().is_subrange(&tt.syntax().text_range()) {\n+        if !token.value.text_range().is_subrange(&tt.syntax().text_range()) {\n             return None;\n         }\n         let source_analyzer =\n-            hir::SourceAnalyzer::new(db, token.with_ast(token.ast.parent()).as_ref(), None);\n-        let exp = source_analyzer.expand(db, &macro_call)?;\n+            hir::SourceAnalyzer::new(db, token.with_value(token.value.parent()).as_ref(), None);\n+        let exp = source_analyzer.expand(db, token.with_value(&macro_call))?;\n         exp.map_token_down(db, token.as_ref())\n     })\n     .last()"}, {"sha": "7f39262dc93697592a3a1b45128c40eb976efed8", "filename": "crates/ra_ide_api/src/expand_macro.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fexpand_macro.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     let mac = name_ref.syntax().ancestors().find_map(ast::MacroCall::cast)?;\n \n     let source = hir::Source::new(position.file_id.into(), mac.syntax());\n-    let expanded = expand_macro_recur(db, source, &mac)?;\n+    let expanded = expand_macro_recur(db, source, source.with_value(&mac))?;\n \n     // FIXME:\n     // macro expansion may lose all white space information\n@@ -35,19 +35,19 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n fn expand_macro_recur(\n     db: &RootDatabase,\n     source: hir::Source<&SyntaxNode>,\n-    macro_call: &ast::MacroCall,\n+    macro_call: hir::Source<&ast::MacroCall>,\n ) -> Option<SyntaxNode> {\n     let analyzer = hir::SourceAnalyzer::new(db, source, None);\n-    let expansion = analyzer.expand(db, &macro_call)?;\n+    let expansion = analyzer.expand(db, macro_call)?;\n     let macro_file_id = expansion.file_id();\n     let expanded: SyntaxNode = db.parse_or_expand(macro_file_id)?;\n \n     let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n     let mut replaces = FxHashMap::default();\n \n     for child in children.into_iter() {\n-        let source = hir::Source::new(macro_file_id, source.ast);\n-        let new_node = expand_macro_recur(db, source, &child)?;\n+        let node = hir::Source::new(macro_file_id, &child);\n+        let new_node = expand_macro_recur(db, source, node)?;\n \n         replaces.insert(child.syntax().clone().into(), new_node.into());\n     }\n@@ -139,7 +139,7 @@ mod tests {\n         }\n         macro_rules! baz {\n             () => { foo!(); }\n-        }        \n+        }\n         f<|>oo!();\n         \"#,\n         );\n@@ -156,7 +156,7 @@ fn b(){}\n             r#\"\n         //- /lib.rs\n         macro_rules! foo {\n-            () => { \n+            () => {\n                 fn some_thing() -> u32 {\n                     let a = 0;\n                     a + 10\n@@ -172,7 +172,7 @@ fn b(){}\n fn some_thing() -> u32 {\n   let a = 0;\n   a+10\n-}        \n+}\n \"###);\n     }\n }"}, {"sha": "b6c72efdfff7ab2e2909d606f3ded824c83070dc", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -23,13 +23,13 @@ pub(crate) fn goto_definition(\n     let token = descend_into_macros(db, position.file_id, token);\n \n     let res = match_ast! {\n-        match (token.ast.parent()) {\n+        match (token.value.parent()) {\n             ast::NameRef(name_ref) => {\n-                let navs = reference_definition(db, token.with_ast(&name_ref)).to_vec();\n+                let navs = reference_definition(db, token.with_value(&name_ref)).to_vec();\n                 RangeInfo::new(name_ref.syntax().text_range(), navs.to_vec())\n             },\n             ast::Name(name) => {\n-                let navs = name_definition(db, token.with_ast(&name))?;\n+                let navs = name_definition(db, token.with_value(&name))?;\n                 RangeInfo::new(name.syntax().text_range(), navs)\n \n             },\n@@ -84,7 +84,7 @@ pub(crate) fn reference_definition(\n     };\n \n     // Fallback index based approach:\n-    let navs = crate::symbol_index::index_resolve(db, name_ref.ast)\n+    let navs = crate::symbol_index::index_resolve(db, name_ref.value)\n         .into_iter()\n         .map(|s| s.to_nav(db))\n         .collect();\n@@ -95,19 +95,19 @@ pub(crate) fn name_definition(\n     db: &RootDatabase,\n     name: Source<&ast::Name>,\n ) -> Option<Vec<NavigationTarget>> {\n-    let parent = name.ast.syntax().parent()?;\n+    let parent = name.value.syntax().parent()?;\n \n     if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n-            let src = name.with_ast(module);\n+            let src = name.with_value(module);\n             if let Some(child_module) = hir::Module::from_declaration(db, src) {\n                 let nav = child_module.to_nav(db);\n                 return Some(vec![nav]);\n             }\n         }\n     }\n \n-    if let Some(nav) = named_target(db, name.with_ast(&parent)) {\n+    if let Some(nav) = named_target(db, name.with_value(&parent)) {\n         return Some(vec![nav]);\n     }\n \n@@ -116,91 +116,91 @@ pub(crate) fn name_definition(\n \n fn named_target(db: &RootDatabase, node: Source<&SyntaxNode>) -> Option<NavigationTarget> {\n     match_ast! {\n-        match (node.ast) {\n+        match (node.value) {\n             ast::StructDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::EnumVariant(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::FnDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TypeAliasDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::ConstDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::StaticDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::TraitDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::RecordFieldDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::Module(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     it.short_label(),\n                 ))\n             },\n             ast::MacroCall(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    node.with_ast(&it),\n+                    node.with_value(&it),\n                     it.doc_comment_text(),\n                     None,\n                 ))"}, {"sha": "28a83a3e2a31522d61b000bc36d6ca4e0c8b6195", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -16,13 +16,13 @@ pub(crate) fn goto_type_definition(\n     let token = file.token_at_offset(position.offset).filter(|it| !it.kind().is_trivia()).next()?;\n     let token = descend_into_macros(db, position.file_id, token);\n \n-    let node = token.ast.ancestors().find_map(|token| {\n+    let node = token.value.ancestors().find_map(|token| {\n         token\n             .ancestors()\n             .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())\n     })?;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, token.with_ast(&node), None);\n+    let analyzer = hir::SourceAnalyzer::new(db, token.with_value(&node), None);\n \n     let ty: hir::Ty = if let Some(ty) =\n         ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))"}, {"sha": "9839be985f4895dbd3b2f8ddc3e08ba4b45b95a1", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -101,11 +101,11 @@ fn hover_text_from_name_kind(\n     return match name_kind {\n         Macro(it) => {\n             let src = it.source(db);\n-            hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast)))\n+            hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)))\n         }\n         Field(it) => {\n             let src = it.source(db);\n-            match src.ast {\n+            match src.value {\n                 hir::FieldSource::Named(it) => hover_text(it.doc_comment_text(), it.short_label()),\n                 _ => None,\n             }\n@@ -116,7 +116,7 @@ fn hover_text_from_name_kind(\n             hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n         },\n         Def(it) => match it {\n-            hir::ModuleDef::Module(it) => match it.definition_source(db).ast {\n+            hir::ModuleDef::Module(it) => match it.definition_source(db).value {\n                 hir::ModuleSource::Module(it) => {\n                     hover_text(it.doc_comment_text(), it.short_label())\n                 }\n@@ -158,7 +158,7 @@ fn hover_text_from_name_kind(\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n     {\n         let src = def.source(db);\n-        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n+        hover_text(src.value.doc_comment_text(), src.value.short_label())\n     }\n }\n \n@@ -170,11 +170,11 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     let mut res = HoverResult::new();\n \n     let mut range = match_ast! {\n-        match (token.ast.parent()) {\n+        match (token.value.parent()) {\n             ast::NameRef(name_ref) => {\n                 let mut no_fallback = false;\n                 if let Some(name_kind) =\n-                    classify_name_ref(db, token.with_ast(&name_ref)).map(|d| d.kind)\n+                    classify_name_ref(db, token.with_value(&name_ref)).map(|d| d.kind)\n                 {\n                     res.extend(hover_text_from_name_kind(db, name_kind, &mut no_fallback))\n                 }\n@@ -196,7 +196,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n                 }\n             },\n             ast::Name(name) => {\n-                if let Some(name_kind) = classify_name(db, token.with_ast(&name)).map(|d| d.kind) {\n+                if let Some(name_kind) = classify_name(db, token.with_value(&name)).map(|d| d.kind) {\n                     res.extend(hover_text_from_name_kind(db, name_kind, &mut true));\n                 }\n \n@@ -211,7 +211,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     };\n \n     if range.is_none() {\n-        let node = token.ast.ancestors().find(|n| {\n+        let node = token.value.ancestors().find(|n| {\n             ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some()\n         })?;\n         let frange = FileRange { file_id: position.file_id, range: node.text_range() };\n@@ -404,19 +404,15 @@ mod tests {\n         check_hover_result(\n             r#\"\n             //- /main.rs\n-            fn main() {\n-                const foo<|>: u32 = 0;\n-            }\n+            const foo<|>: u32 = 0;\n         \"#,\n             &[\"const foo: u32\"],\n         );\n \n         check_hover_result(\n             r#\"\n             //- /main.rs\n-            fn main() {\n-                static foo<|>: u32 = 0;\n-            }\n+            static foo<|>: u32 = 0;\n         \"#,\n             &[\"static foo: u32\"],\n         );"}, {"sha": "3e3012559bb5292253c8e01b96be710f73db1776", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -16,7 +16,7 @@ pub(crate) fn goto_implementation(\n     let src = hir::ModuleSource::from_position(db, position);\n     let module = hir::Module::from_definition(\n         db,\n-        hir::Source { file_id: position.file_id.into(), ast: src },\n+        hir::Source { file_id: position.file_id.into(), value: src },\n     )?;\n \n     if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n@@ -42,11 +42,11 @@ fn impls_for_def(\n ) -> Option<Vec<NavigationTarget>> {\n     let ty = match node {\n         ast::NominalDef::StructDef(def) => {\n-            let src = hir::Source { file_id: position.file_id.into(), ast: def.clone() };\n+            let src = hir::Source { file_id: position.file_id.into(), value: def.clone() };\n             hir::Struct::from_source(db, src)?.ty(db)\n         }\n         ast::NominalDef::EnumDef(def) => {\n-            let src = hir::Source { file_id: position.file_id.into(), ast: def.clone() };\n+            let src = hir::Source { file_id: position.file_id.into(), value: def.clone() };\n             hir::Enum::from_source(db, src)?.ty(db)\n         }\n     };\n@@ -69,7 +69,7 @@ fn impls_for_trait(\n     node: &ast::TraitDef,\n     module: hir::Module,\n ) -> Option<Vec<NavigationTarget>> {\n-    let src = hir::Source { file_id: position.file_id.into(), ast: node.clone() };\n+    let src = hir::Source { file_id: position.file_id.into(), value: node.clone() };\n     let tr = hir::Trait::from_source(db, src)?;\n \n     let krate = module.krate();"}, {"sha": "24a7ca5e710d5e2dd466bb29a416f04962d4cb67", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -19,10 +19,15 @@ pub struct InlayHint {\n     pub label: SmolStr,\n }\n \n-pub(crate) fn inlay_hints(db: &RootDatabase, file_id: FileId, file: &SourceFile) -> Vec<InlayHint> {\n+pub(crate) fn inlay_hints(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    file: &SourceFile,\n+    max_inlay_hint_length: Option<usize>,\n+) -> Vec<InlayHint> {\n     file.syntax()\n         .descendants()\n-        .map(|node| get_inlay_hints(db, file_id, &node).unwrap_or_default())\n+        .map(|node| get_inlay_hints(db, file_id, &node, max_inlay_hint_length).unwrap_or_default())\n         .flatten()\n         .collect()\n }\n@@ -31,6 +36,7 @@ fn get_inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,\n     node: &SyntaxNode,\n+    max_inlay_hint_length: Option<usize>,\n ) -> Option<Vec<InlayHint>> {\n     let analyzer = SourceAnalyzer::new(db, hir::Source::new(file_id.into(), node), None);\n     match_ast! {\n@@ -40,38 +46,38 @@ fn get_inlay_hints(\n                     return None;\n                 }\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false))\n+                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n             },\n             ast::LambdaExpr(it) => {\n                 it.param_list().map(|param_list| {\n                     param_list\n                         .params()\n                         .filter(|closure_param| closure_param.ascribed_type().is_none())\n                         .filter_map(|closure_param| closure_param.pat())\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false))\n+                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false, max_inlay_hint_length))\n                         .flatten()\n                         .collect()\n                 })\n             },\n             ast::ForExpr(it) => {\n                 let pat = it.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, false))\n+                Some(get_pat_type_hints(db, &analyzer, pat, false, max_inlay_hint_length))\n             },\n             ast::IfExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true))\n+                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n             },\n             ast::WhileExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                Some(get_pat_type_hints(db, &analyzer, pat, true))\n+                Some(get_pat_type_hints(db, &analyzer, pat, true, max_inlay_hint_length))\n             },\n             ast::MatchArmList(it) => {\n                 Some(\n                     it\n                         .arms()\n                         .map(|match_arm| match_arm.pats())\n                         .flatten()\n-                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true))\n+                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true, max_inlay_hint_length))\n                         .flatten()\n                         .collect(),\n                 )\n@@ -86,6 +92,7 @@ fn get_pat_type_hints(\n     analyzer: &SourceAnalyzer,\n     root_pat: ast::Pat,\n     skip_root_pat_hint: bool,\n+    max_inlay_hint_length: Option<usize>,\n ) -> Vec<InlayHint> {\n     let original_pat = &root_pat.clone();\n \n@@ -99,7 +106,7 @@ fn get_pat_type_hints(\n         .map(|(range, pat_type)| InlayHint {\n             range,\n             kind: InlayKind::TypeHint,\n-            label: pat_type.display(db).to_string().into(),\n+            label: pat_type.display_truncated(db, max_inlay_hint_length).to_string().into(),\n         })\n         .collect()\n }\n@@ -209,7 +216,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [193; 197),\n@@ -278,7 +285,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [21; 30),\n@@ -307,7 +314,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [21; 30),\n@@ -355,7 +362,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [166; 170),\n@@ -418,7 +425,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [166; 170),\n@@ -481,7 +488,7 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n                 range: [311; 315),\n@@ -507,4 +514,41 @@ fn main() {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn hint_truncation() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+struct Smol<T>(T);\n+\n+struct VeryLongOuterName<T>(T);\n+\n+fn main() {\n+    let a = Smol(0u32);\n+    let b = VeryLongOuterName(0usize);\n+    let c = Smol(Smol(0u32))\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, Some(8)).unwrap(), @r###\"\n+        [\n+            InlayHint {\n+                range: [74; 75),\n+                kind: TypeHint,\n+                label: \"Smol<u32>\",\n+            },\n+            InlayHint {\n+                range: [98; 99),\n+                kind: TypeHint,\n+                label: \"VeryLongOuterName<\u2026>\",\n+            },\n+            InlayHint {\n+                range: [137; 138),\n+                kind: TypeHint,\n+                label: \"Smol<Smol<\u2026>>\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "7deeb34947aceea7eb5a0fca825560d7f1d368d6", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -243,6 +243,34 @@ fn foo(e: Result<U, V>) {\n         );\n     }\n \n+    #[test]\n+    fn join_lines_multiline_in_block() {\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    match ty {\n+        <|> Some(ty) => {\n+            match ty {\n+                _ => false,\n+            }\n+        }\n+        _ => true,\n+    }\n+}\n+\",\n+            r\"\n+fn foo() {\n+    match ty {\n+        <|> Some(ty) => match ty {\n+                _ => false,\n+            },\n+        _ => true,\n+    }\n+}\n+\",\n+        );\n+    }\n+\n     #[test]\n     fn join_lines_keeps_comma_for_block_in_match_arm() {\n         // We already have a comma"}, {"sha": "62ad996bce53c6d25fb357106c7b2065543874a0", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -344,8 +344,14 @@ impl Analysis {\n     }\n \n     /// Returns a list of the places in the file where type hints can be displayed.\n-    pub fn inlay_hints(&self, file_id: FileId) -> Cancelable<Vec<InlayHint>> {\n-        self.with_db(|db| inlay_hints::inlay_hints(db, file_id, &db.parse(file_id).tree()))\n+    pub fn inlay_hints(\n+        &self,\n+        file_id: FileId,\n+        max_inlay_hint_length: Option<usize>,\n+    ) -> Cancelable<Vec<InlayHint>> {\n+        self.with_db(|db| {\n+            inlay_hints::inlay_hints(db, file_id, &db.parse(file_id).tree(), max_inlay_hint_length)\n+        })\n     }\n \n     /// Returns the set of folding ranges."}, {"sha": "fa232a379f8aa68a360a1929a5b1020008e77661", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -10,7 +10,7 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n     let src = hir::ModuleSource::from_position(db, position);\n     let module = match hir::Module::from_definition(\n         db,\n-        hir::Source { file_id: position.file_id.into(), ast: src },\n+        hir::Source { file_id: position.file_id.into(), value: src },\n     ) {\n         None => return Vec::new(),\n         Some(it) => it,\n@@ -23,7 +23,8 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n     let src = hir::ModuleSource::from_file_id(db, file_id);\n     let module =\n-        match hir::Module::from_definition(db, hir::Source { file_id: file_id.into(), ast: src }) {\n+        match hir::Module::from_definition(db, hir::Source { file_id: file_id.into(), value: src })\n+        {\n             Some(it) => it,\n             None => return Vec::new(),\n         };"}, {"sha": "4a4b030f89d353bd4f5894afec9bb7a49cb98dff", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -13,12 +13,12 @@ use crate::db::RootDatabase;\n \n pub(crate) fn classify_name(db: &RootDatabase, name: Source<&ast::Name>) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name\");\n-    let parent = name.ast.syntax().parent()?;\n+    let parent = name.value.syntax().parent()?;\n \n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let local = hir::Local::from_source(db, src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n@@ -28,50 +28,50 @@ pub(crate) fn classify_name(db: &RootDatabase, name: Source<&ast::Name>) -> Opti\n             },\n             ast::RecordFieldDef(it) => {\n                 let ast = hir::FieldSource::Named(it);\n-                let src = name.with_ast(ast);\n+                let src = name.with_value(ast);\n                 let field = hir::StructField::from_source(db, src)?;\n                 Some(from_struct_field(db, field))\n             },\n             ast::Module(it) => {\n                 let def = {\n                     if !it.has_semi() {\n                         let ast = hir::ModuleSource::Module(it);\n-                        let src = name.with_ast(ast);\n+                        let src = name.with_value(ast);\n                         hir::Module::from_definition(db, src)\n                     } else {\n-                        let src = name.with_ast(it);\n+                        let src = name.with_value(it);\n                         hir::Module::from_declaration(db, src)\n                     }\n                 }?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::StructDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Struct::from_source(db, src)?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::EnumDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Enum::from_source(db, src)?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::TraitDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Trait::from_source(db, src)?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::StaticDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Static::from_source(db, src)?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::EnumVariant(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::EnumVariant::from_source(db, src)?;\n                 Some(from_module_def(db, def.into(), None))\n             },\n             ast::FnDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Function::from_source(db, src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n                     Some(from_assoc_item(db, def.into()))\n@@ -80,7 +80,7 @@ pub(crate) fn classify_name(db: &RootDatabase, name: Source<&ast::Name>) -> Opti\n                 }\n             },\n             ast::ConstDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::Const::from_source(db, src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n                     Some(from_assoc_item(db, def.into()))\n@@ -89,7 +89,7 @@ pub(crate) fn classify_name(db: &RootDatabase, name: Source<&ast::Name>) -> Opti\n                 }\n             },\n             ast::TypeAliasDef(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::TypeAlias::from_source(db, src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n                     Some(from_assoc_item(db, def.into()))\n@@ -98,11 +98,11 @@ pub(crate) fn classify_name(db: &RootDatabase, name: Source<&ast::Name>) -> Opti\n                 }\n             },\n             ast::MacroCall(it) => {\n-                let src = name.with_ast(it);\n+                let src = name.with_value(it);\n                 let def = hir::MacroDef::from_source(db, src.clone())?;\n \n                 let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-                let module = Module::from_definition(db, src.with_ast(module_src))?;\n+                let module = Module::from_definition(db, src.with_value(module_src))?;\n \n                 Some(NameDefinition {\n                     visibility: None,\n@@ -121,7 +121,7 @@ pub(crate) fn classify_name_ref(\n ) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name_ref\");\n \n-    let parent = name_ref.ast.syntax().parent()?;\n+    let parent = name_ref.value.syntax().parent()?;\n     let analyzer = SourceAnalyzer::new(db, name_ref.map(|it| it.syntax()), None);\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n@@ -142,16 +142,16 @@ pub(crate) fn classify_name_ref(\n         tested_by!(goto_definition_works_for_record_fields);\n         if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n             let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-            let hir_path = Path::from_name_ref(name_ref.ast);\n+            let hir_path = Path::from_name_ref(name_ref.value);\n             let hir_name = hir_path.as_ident()?;\n             let field = variant_def.field(db, hir_name)?;\n             return Some(from_struct_field(db, field));\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(db, name_ref.with_ast(&parent));\n+    let ast = ModuleSource::from_child_node(db, name_ref.with_value(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(db, name_ref.with_ast(ast))?;\n+    let container = Module::from_definition(db, name_ref.with_value(ast))?;\n     let visibility = None;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n@@ -162,7 +162,7 @@ pub(crate) fn classify_name_ref(\n         }\n     }\n \n-    let path = name_ref.ast.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(db, &path)?;\n     match resolved {\n         PathResolution::Def(def) => Some(from_module_def(db, def, Some(container))),"}, {"sha": "aca23f79e24b6f5f09c35d34ccca54f8ce285d31", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -32,9 +32,9 @@ pub(crate) struct NameDefinition {\n pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n     let container = item.module(db);\n     let visibility = match item {\n-        AssocItem::Function(f) => f.source(db).ast.visibility(),\n-        AssocItem::Const(c) => c.source(db).ast.visibility(),\n-        AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n+        AssocItem::Function(f) => f.source(db).value.visibility(),\n+        AssocItem::Const(c) => c.source(db).value.visibility(),\n+        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n     };\n     let kind = NameKind::AssocItem(item);\n     NameDefinition { kind, container, visibility }\n@@ -45,8 +45,8 @@ pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDe\n     let parent = field.parent_def(db);\n     let container = parent.module(db);\n     let visibility = match parent {\n-        VariantDef::Struct(s) => s.source(db).ast.visibility(),\n-        VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+        VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n     };\n     NameDefinition { kind, container, visibility }\n }\n@@ -60,22 +60,22 @@ pub(super) fn from_module_def(\n     let (container, visibility) = match def {\n         ModuleDef::Module(it) => {\n             let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-            let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n+            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n             (container, visibility)\n         }\n         ModuleDef::EnumVariant(it) => {\n             let container = it.module(db);\n-            let visibility = it.source(db).ast.parent_enum().visibility();\n+            let visibility = it.source(db).value.parent_enum().visibility();\n             (container, visibility)\n         }\n-        ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n-        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n         ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n     };\n     NameDefinition { kind, container, visibility }"}, {"sha": "d58496049e21a9125d479f5ff72e73df9da18f1d", "filename": "crates/ra_ide_api/src/references/rename.rs", "status": "modified", "additions": 2, "deletions": 134, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -55,11 +55,11 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n+    let module_src = hir::Source { file_id: position.file_id.into(), value: ast_module.clone() };\n     if let Some(module) = hir::Module::from_declaration(db, module_src) {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.original_file(db);\n-        match src.ast {\n+        match src.value {\n             ModuleSource::SourceFile(..) => {\n                 let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n                 // mod is defined in path/to/dir/mod.rs\n@@ -121,140 +121,8 @@ mod tests {\n \n     use crate::{\n         mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n-        ReferenceSearchResult,\n     };\n \n-    #[test]\n-    fn test_find_all_refs_for_local() {\n-        let code = r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 5);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_for_param_inside() {\n-        let code = r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_for_fn_param() {\n-        let code = r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_field_name() {\n-        let code = r#\"\n-            //- /lib.rs\n-            struct Foo {\n-                pub spam<|>: u32,\n-            }\n-\n-            fn main(s: Foo) {\n-                let f = s.spam;\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_impl_item_name() {\n-        let code = r#\"\n-            //- /lib.rs\n-            struct Foo;\n-            impl Foo {\n-                fn f<|>(&self) {  }\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_enum_var_name() {\n-        let code = r#\"\n-            //- /lib.rs\n-            enum Foo {\n-                A,\n-                B<|>,\n-                C,\n-            }\n-        \"#;\n-\n-        let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_find_all_refs_modules() {\n-        let code = r#\"\n-            //- /lib.rs\n-            pub mod foo;\n-            pub mod bar;\n-\n-            fn f() {\n-                let i = foo::Foo { n: 5 };\n-            }\n-\n-            //- /foo.rs\n-            use crate::bar;\n-\n-            pub struct Foo {\n-                pub n: u32,\n-            }\n-\n-            fn f() {\n-                let i = bar::Bar { n: 5 };\n-            }\n-\n-            //- /bar.rs\n-            use crate::foo;\n-\n-            pub struct Bar {\n-                pub n: u32,\n-            }\n-\n-            fn f() {\n-                let i = foo::Foo<|> { n: 5 };\n-            }\n-        \"#;\n-\n-        let (analysis, pos) = analysis_and_position(code);\n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        assert_eq!(refs.len(), 3);\n-    }\n-\n-    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n-        let (analysis, position) = single_file_with_position(text);\n-        analysis.find_all_refs(position, None).unwrap().unwrap()\n-    }\n-\n     #[test]\n     fn test_rename_for_local() {\n         test_rename("}, {"sha": "f5c9589f4d17257f17c34caa4c7bc45c51aea20c", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -73,9 +73,9 @@ impl NameDefinition {\n \n         if let NameKind::Local(var) = self.kind {\n             let range = match var.parent(db) {\n-                DefWithBody::Function(f) => f.source(db).ast.syntax().text_range(),\n-                DefWithBody::Const(c) => c.source(db).ast.syntax().text_range(),\n-                DefWithBody::Static(s) => s.source(db).ast.syntax().text_range(),\n+                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n+                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n+                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n             };\n             let mut res = FxHashMap::default();\n             res.insert(file_id, Some(range));\n@@ -91,7 +91,7 @@ impl NameDefinition {\n                 let parent_src = parent_module.definition_source(db);\n                 let file_id = parent_src.file_id.original_file(db);\n \n-                match parent_src.ast {\n+                match parent_src.value {\n                     ModuleSource::Module(m) => {\n                         let range = Some(m.syntax().text_range());\n                         res.insert(file_id, range);\n@@ -135,7 +135,7 @@ impl NameDefinition {\n         }\n \n         let mut res = FxHashMap::default();\n-        let range = match module_src.ast {\n+        let range = match module_src.value {\n             ModuleSource::Module(m) => Some(m.syntax().text_range()),\n             ModuleSource::SourceFile(_) => None,\n         };"}, {"sha": "8045f3d60d1cb6f3a3e7247040c35fe8f9973d0b", "filename": "crates/ra_lsp_server/src/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -29,6 +29,8 @@ pub struct ServerConfig {\n \n     pub lru_capacity: Option<usize>,\n \n+    pub max_inlay_hint_length: Option<usize>,\n+\n     /// For internal usage to make integrated tests faster.\n     #[serde(deserialize_with = \"nullable_bool_true\")]\n     pub with_sysroot: bool,\n@@ -44,6 +46,7 @@ impl Default for ServerConfig {\n             exclude_globs: Vec::new(),\n             use_client_watching: false,\n             lru_capacity: None,\n+            max_inlay_hint_length: None,\n             with_sysroot: true,\n             feature_flags: FxHashMap::default(),\n         }"}, {"sha": "0dc0aeee8649390834ac80c6ac5fd4ce8ce7f583", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -123,6 +123,7 @@ pub fn main_loop(\n                     .and_then(|it| it.folding_range.as_ref())\n                     .and_then(|it| it.line_folding_only)\n                     .unwrap_or(false),\n+                max_inlay_hint_length: config.max_inlay_hint_length,\n             }\n         };\n "}, {"sha": "e552f2106deda752e68492e2d3f2d1f2f5d35191", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -888,7 +888,7 @@ pub fn handle_inlay_hints(\n     let analysis = world.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n-        .inlay_hints(file_id)?\n+        .inlay_hints(file_id, world.options.max_inlay_hint_length)?\n         .into_iter()\n         .map(|api_type| InlayHint {\n             label: api_type.label.to_string(),"}, {"sha": "9bdea70c7457c31499e495d80c4e46e24ad633aa", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -28,6 +28,7 @@ pub struct Options {\n     pub publish_decorations: bool,\n     pub supports_location_link: bool,\n     pub line_folding_only: bool,\n+    pub max_inlay_hint_length: Option<usize>,\n }\n \n /// `WorldState` is the primary mutable state of the language server"}, {"sha": "de506d7cdacf80a84de1fa600c8114ad00c08d76", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -3625,8 +3625,11 @@ impl AstNode for TypeParam {\n impl ast::NameOwner for TypeParam {}\n impl ast::AttrsOwner for TypeParam {}\n impl ast::TypeBoundsOwner for TypeParam {}\n-impl ast::DefaultTypeParamOwner for TypeParam {}\n-impl TypeParam {}\n+impl TypeParam {\n+    pub fn default_type(&self) -> Option<TypeRef> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParamList {\n     pub(crate) syntax: SyntaxNode,"}, {"sha": "f99984fe0f69c44f984ae2016b37829422dd949c", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -163,9 +163,3 @@ impl Iterator for CommentIter {\n         self.iter.by_ref().find_map(|el| el.into_token().and_then(ast::Comment::cast))\n     }\n }\n-\n-pub trait DefaultTypeParamOwner: AstNode {\n-    fn default_type(&self) -> Option<ast::PathType> {\n-        child_opt(self)\n-    }\n-}"}, {"sha": "88d1dc109bbc10395944221fbbca0817b068df7b", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -587,7 +587,10 @@ Grammar(\n                 (\"lifetime_params\", \"LifetimeParam\" ),\n             ]\n         ),\n-        \"TypeParam\": ( traits: [\"NameOwner\", \"AttrsOwner\", \"TypeBoundsOwner\", \"DefaultTypeParamOwner\"] ),\n+        \"TypeParam\": (\n+            options: [(\"default_type\", \"TypeRef\")],\n+            traits: [\"NameOwner\", \"AttrsOwner\", \"TypeBoundsOwner\"],\n+        ),\n         \"LifetimeParam\": (\n             traits: [\"AttrsOwner\"],\n         ),"}, {"sha": "e049fce611a06cdc19dd0f4665637890eb719c7f", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -43,7 +43,7 @@ impl SyntaxNodePtr {\n }\n \n /// Like `SyntaxNodePtr`, but remembers the type of node\n-#[derive(Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug, Hash)]\n pub struct AstPtr<N: AstNode> {\n     raw: SyntaxNodePtr,\n     _ty: PhantomData<fn() -> N>,\n@@ -56,6 +56,14 @@ impl<N: AstNode> Clone for AstPtr<N> {\n     }\n }\n \n+impl<N: AstNode> Eq for AstPtr<N> {}\n+\n+impl<N: AstNode> PartialEq for AstPtr<N> {\n+    fn eq(&self, other: &AstPtr<N>) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+\n impl<N: AstNode> AstPtr<N> {\n     pub fn new(node: &N) -> AstPtr<N> {\n         AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }"}, {"sha": "235676850bd546dc9ac93b0226041d7c8f344828", "filename": "docs/user/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -136,7 +136,7 @@ Installation:\n [ra-emacs-lsp.el](https://github.com/rust-analyzer/rust-analyzer/blob/69ee5c9c5ef212f7911028c9ddf581559e6565c3/editors/emacs/ra-emacs-lsp.el)\n to load path and require it in `init.el`\n * run `lsp` in a rust buffer\n-* (Optionally) bind commands like `rust-analyzer-join-lines` or `rust-analyzer-extend-selection` to keys, and enable `rust-analyzer-inlay-hints-mode` to get inline type hints\n+* (Optionally) bind commands like `rust-analyzer-join-lines`, `rust-analyzer-extend-selection` and `rust-analyzer-expand-macro` to keys, and enable `rust-analyzer-inlay-hints-mode` to get inline type hints\n \n \n ## Vim and NeoVim"}, {"sha": "0dbdd94fbacffb019cbcd0fbd9eb1148cdd7873b", "filename": "editors/code/src/commands/inlay_hints.ts", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Finlay_hints.ts?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -87,7 +87,7 @@ export class HintsUpdater {\n                 range: hint.range,\n                 renderOptions: {\n                     after: {\n-                        contentText: `: ${this.truncateHint(hint.label)}`\n+                        contentText: `: ${hint.label}`\n                     }\n                 }\n             }));\n@@ -98,18 +98,6 @@ export class HintsUpdater {\n         }\n     }\n \n-    private truncateHint(label: string): string {\n-        if (!Server.config.maxInlayHintLength) {\n-            return label;\n-        }\n-\n-        let newLabel = label.substring(0, Server.config.maxInlayHintLength);\n-        if (label.length > Server.config.maxInlayHintLength) {\n-            newLabel += '\u2026';\n-        }\n-        return newLabel;\n-    }\n-\n     private async queryHints(documentUri: string): Promise<InlayHint[] | null> {\n         const request: InlayHintsParams = {\n             textDocument: { uri: documentUri }"}, {"sha": "7907b70bc5185d0127be9415c36f2fd3e57dc458", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -43,6 +43,7 @@ export class Server {\n             initializationOptions: {\n                 publishDecorations: true,\n                 lruCapacity: Server.config.lruCapacity,\n+                maxInlayHintLength: Server.config.maxInlayHintLength,\n                 excludeGlobs: Server.config.excludeGlobs,\n                 useClientWatching: Server.config.useClientWatching,\n                 featureFlags: Server.config.featureFlags"}, {"sha": "fafb9cbe733413578f1aca28d09890e51d0e8780", "filename": "editors/emacs/ra-emacs-lsp.el", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Femacs%2Fra-emacs-lsp.el", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/editors%2Femacs%2Fra-emacs-lsp.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Femacs%2Fra-emacs-lsp.el?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -16,6 +16,7 @@\n ;;  - implements joinLines (you need to bind rust-analyzer-join-lines to a key)\n ;;  - implements selectionRanges (either bind lsp-extend-selection to a key, or use expand-region)\n ;;  - provides rust-analyzer-inlay-hints-mode for inline type hints\n+;;  - provides rust-analyzer-expand-macro to expand macros\n \n ;; What's missing:\n ;;  - file system changes in apply-source-change\n@@ -247,5 +248,32 @@\n     (remove-hook 'after-change-functions #'rust-analyzer--inlay-hints-change-handler t))))\n \n \n+\n+;; expand macros\n+(defun rust-analyzer-expand-macro ()\n+  \"Expands the macro call at point recursively.\"\n+  (interactive)\n+  (when (eq 'rust-mode major-mode)\n+    (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n+           (params (list :textDocument (lsp--text-document-identifier)\n+                         :position (lsp--cur-position))))\n+      (when workspace\n+        (let* ((response (with-lsp-workspace workspace\n+                           (lsp-send-request (lsp-make-request\n+                                              \"rust-analyzer/expandMacro\"\n+                                              params))))\n+               (result (when response (ht-get response \"expansion\"))))\n+          (if result\n+            (let ((buf (get-buffer-create (concat \"*rust-analyzer macro expansion \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n+              (with-current-buffer buf\n+                (let ((inhibit-read-only t))\n+                  (erase-buffer)\n+                  (insert result)\n+                  (setq buffer-read-only t)\n+                  (special-mode)))\n+              (pop-to-buffer buf))\n+            (message \"No macro found at point, or it could not be expanded\")))))))\n+\n+\n (provide 'ra-emacs-lsp)\n ;;; ra-emacs-lsp.el ends here"}, {"sha": "65cabf00533eb18b2ffdfe963c2133f1ccb68feb", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -5,6 +5,9 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n walkdir = \"2.1.3\"\n pico-args = \"0.3.0\""}, {"sha": "c97bfec977ae2b6a336529ec42b6d32827be231d", "filename": "xtask/src/main.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/358a1bcd708c622836723e5201b6de77cc9ff327/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1bcd708c622836723e5201b6de77cc9ff327/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=358a1bcd708c622836723e5201b6de77cc9ff327", "patch": "@@ -9,11 +9,10 @@\n //! `.cargo/config`.\n mod help;\n \n+use std::{env, fmt::Write, path::PathBuf, str};\n+\n use anyhow::Context;\n-use core::fmt::Write;\n-use core::str;\n use pico_args::Arguments;\n-use std::{env, path::PathBuf};\n use xtask::{\n     codegen::{self, Mode},\n     install_pre_commit_hook, reformat_staged_files, run, run_clippy, run_fuzzer, run_rustfmt,\n@@ -37,7 +36,7 @@ struct ServerOpt {\n }\n \n fn main() -> Result<()> {\n-    if std::env::args().next().map(|it| it.contains(\"pre-commit\")) == Some(true) {\n+    if env::args().next().map(|it| it.contains(\"pre-commit\")) == Some(true) {\n         return reformat_staged_files();\n     }\n \n@@ -174,7 +173,7 @@ fn fix_path_for_mac() -> Result<()> {\n fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n     let npm_version = Cmd {\n         unix: r\"npm --version\",\n-        windows: r\"cmd.exe /c npm.cmd --version\",\n+        windows: r\"cmd.exe /c npm --version\",\n         work_dir: \"./editors/code\",\n     }\n     .run();\n@@ -183,10 +182,10 @@ fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n         eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n     }\n \n-    Cmd { unix: r\"npm ci\", windows: r\"cmd.exe /c npm.cmd ci\", work_dir: \"./editors/code\" }.run()?;\n+    Cmd { unix: r\"npm ci\", windows: r\"cmd.exe /c npm ci\", work_dir: \"./editors/code\" }.run()?;\n     Cmd {\n         unix: r\"npm run package --scripts-prepend-node-path\",\n-        windows: r\"cmd.exe /c npm.cmd run package\",\n+        windows: r\"cmd.exe /c npm run package\",\n         work_dir: \"./editors/code\",\n     }\n     .run()?;"}]}