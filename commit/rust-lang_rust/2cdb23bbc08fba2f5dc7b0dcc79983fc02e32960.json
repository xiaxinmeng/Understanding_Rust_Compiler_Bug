{"sha": "2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZGIyM2JiYzA4ZmJhMmY1ZGM3YjBkY2M3OTk4M2ZjMDJlMzI5NjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-18T18:17:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-18T18:31:57Z"}, "message": "Replace uses of 'unchecked' with 'unsafe'", "tree": {"sha": "683f1e841f369e737e6d0c26fcafe5057531566c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/683f1e841f369e737e6d0c26fcafe5057531566c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "html_url": "https://github.com/rust-lang/rust/commit/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa6675f1d632f5d524f4a7a18838c6ee1c0c447", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa6675f1d632f5d524f4a7a18838c6ee1c0c447", "html_url": "https://github.com/rust-lang/rust/commit/efa6675f1d632f5d524f4a7a18838c6ee1c0c447"}], "stats": {"total": 214, "additions": 107, "deletions": 107}, "files": [{"sha": "cdb43b198113a45f2f6528acff5746db6c561134", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -92,7 +92,7 @@ pure fn DList<T>() -> DList<T> {\n /// Creates a new dlist with a single element\n pure fn from_elem<T>(+data: T) -> DList<T> {\n     let list = DList();\n-    unchecked { list.push(move data); }\n+    unsafe { list.push(move data); }\n     list\n }\n \n@@ -435,7 +435,7 @@ impl<T: Copy> DList<T> {\n     /// Get the elements of the list as a vector. O(n).\n     pure fn to_vec() -> ~[mut T] {\n         let mut v = ~[mut];\n-        unchecked {\n+        unsafe {\n             vec::reserve(v, self.size);\n             // Take this out of the unchecked when iter's functions are pure\n             for self.eachi |index,data| {"}, {"sha": "6f0f5c6bb0695000d56e31a3f58267ff7cded417", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -140,7 +140,7 @@ impl<A> DVec<A> {\n \n     /// Returns the number of elements currently in the dvec\n     pure fn len() -> uint {\n-        unchecked {\n+        unsafe {\n             do self.check_out |v| {\n                 let l = v.len();\n                 self.give_back(move v);\n@@ -280,7 +280,7 @@ impl<A: Copy> DVec<A> {\n      * See `unwrap()` if you do not wish to copy the contents.\n      */\n     pure fn get() -> ~[A] {\n-        unchecked {\n+        unsafe {\n             do self.check_out |v| {\n                 let w = copy v;\n                 self.give_back(move v);"}, {"sha": "74d651472e12d6d4267082fe1bae853040d58927", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -291,12 +291,12 @@ mod rt {\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                unchecked { str::unshift_char(s, '+') };\n+                unsafe { str::unshift_char(s, '+') };\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unchecked { str::unshift_char(s, ' ') };\n+                unsafe { str::unshift_char(s, ' ') };\n             }\n         }\n-        return unchecked { pad(cv, s, PadSigned) };\n+        return unsafe { pad(cv, s, PadSigned) };\n     }\n     pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -308,7 +308,7 @@ mod rt {\n               TyBits => uint_to_str_prec(u, 2u, prec),\n               TyOctal => uint_to_str_prec(u, 8u, prec)\n             };\n-        return unchecked { pad(cv, rs, PadUnsigned) };\n+        return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n     pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -318,7 +318,7 @@ mod rt {\n     }\n     pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unchecked { pad(cv, s, PadNozero) };\n+        return unsafe { pad(cv, s, PadNozero) };\n     }\n     pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -331,22 +331,22 @@ mod rt {\n             s.to_unique()\n           }\n         };\n-        return unchecked { pad(cv, unpadded, PadNozero) };\n+        return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n     pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n         };\n-        let mut s = unchecked { to_str(f, digits) };\n+        let mut s = unsafe { to_str(f, digits) };\n         if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = ~\"+\" + s;\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unchecked { pad(cv, s, PadFloat) };\n+        return unsafe { pad(cv, s, PadFloat) };\n     }\n     pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n         let s = sys::log_str(v);\n@@ -479,12 +479,12 @@ mod rt2 {\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                unchecked { str::unshift_char(s, '+') };\n+                unsafe { str::unshift_char(s, '+') };\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unchecked { str::unshift_char(s, ' ') };\n+                unsafe { str::unshift_char(s, ' ') };\n             }\n         }\n-        return unchecked { pad(cv, s, PadSigned) };\n+        return unsafe { pad(cv, s, PadSigned) };\n     }\n     pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -496,7 +496,7 @@ mod rt2 {\n               TyBits => uint_to_str_prec(u, 2u, prec),\n               TyOctal => uint_to_str_prec(u, 8u, prec)\n             };\n-        return unchecked { pad(cv, rs, PadUnsigned) };\n+        return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n     pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -506,7 +506,7 @@ mod rt2 {\n     }\n     pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unchecked { pad(cv, s, PadNozero) };\n+        return unsafe { pad(cv, s, PadNozero) };\n     }\n     pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -519,22 +519,22 @@ mod rt2 {\n             s.to_unique()\n           }\n         };\n-        return unchecked { pad(cv, unpadded, PadNozero) };\n+        return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n     pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n         };\n-        let mut s = unchecked { to_str(f, digits) };\n+        let mut s = unsafe { to_str(f, digits) };\n         if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = ~\"+\" + s;\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unchecked { pad(cv, s, PadFloat) };\n+        return unsafe { pad(cv, s, PadFloat) };\n     }\n     pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n         let s = sys::log_str(v);"}, {"sha": "d9832036a88b021a2345f4d1bbc698946d72034e", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -85,7 +85,7 @@ trait Streaming {\n impl <A: IterBytes> A: Hash {\n     #[inline(always)]\n     pure fn hash_keyed(k0: u64, k1: u64) -> u64 {\n-        unchecked {\n+        unsafe {\n             let s = &State(k0, k1);\n             for self.iter_bytes(true) |bytes| {\n                 s.input(bytes);\n@@ -100,7 +100,7 @@ impl <A: IterBytes> A: Hash {\n pure fn hash_keyed_2<A: IterBytes,\n                      B: IterBytes>(a: &A, b: &B,\n                                    k0: u64, k1: u64) -> u64 {\n-    unchecked {\n+    unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n         for b.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -112,7 +112,7 @@ pure fn hash_keyed_3<A: IterBytes,\n                      B: IterBytes,\n                      C: IterBytes>(a: &A, b: &B, c: &C,\n                                    k0: u64, k1: u64) -> u64 {\n-    unchecked {\n+    unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n         for b.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -126,7 +126,7 @@ pure fn hash_keyed_4<A: IterBytes,\n                      C: IterBytes,\n                      D: IterBytes>(a: &A, b: &B, c: &C, d: &D,\n                                    k0: u64, k1: u64) -> u64 {\n-    unchecked {\n+    unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n         for b.iter_bytes(true) |bytes| { s.input(bytes); }\n@@ -142,7 +142,7 @@ pure fn hash_keyed_5<A: IterBytes,\n                      D: IterBytes,\n                      E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n                                    k0: u64, k1: u64) -> u64 {\n-    unchecked {\n+    unsafe {\n         let s = &State(k0, k1);\n         for a.iter_bytes(true) |bytes| { s.input(bytes); }\n         for b.iter_bytes(true) |bytes| { s.input(bytes); }"}, {"sha": "b6854ea7ea4f0d5bb63997a15380b0744a7f8a66", "filename": "src/libcore/path.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -94,7 +94,7 @@ impl PosixPath : GenericPath {\n     }\n \n     pure fn dirname() -> ~str {\n-        unchecked {\n+        unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n                 ~\".\"\n@@ -144,7 +144,7 @@ impl PosixPath : GenericPath {\n     }\n \n     pure fn with_filename(f: &str) -> PosixPath {\n-        unchecked {\n+        unsafe {\n             assert ! str::any(f, |c| windows::is_sep(c as u8));\n             self.dir_path().push(f)\n         }\n@@ -198,22 +198,22 @@ impl PosixPath : GenericPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(e, |c| windows::is_sep(c as u8));\n-            unchecked { vec::push_all_move(v, move ss); }\n+            unsafe { vec::push_all_move(v, move ss); }\n         }\n         PosixPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unchecked { vec::push_all_move(v, move ss); }\n+        unsafe { vec::push_all_move(v, move ss); }\n         PosixPath { components: move v, ..self }\n     }\n \n     pure fn pop() -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unchecked { vec::pop(cs); }\n+            unsafe { vec::pop(cs); }\n         }\n         return PosixPath { components: move cs, ..self }\n     }\n@@ -285,7 +285,7 @@ impl WindowsPath : GenericPath {\n     }\n \n     pure fn dirname() -> ~str {\n-        unchecked {\n+        unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n                 ~\".\"\n@@ -390,22 +390,22 @@ impl WindowsPath : GenericPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(e, |c| windows::is_sep(c as u8));\n-            unchecked { vec::push_all_move(v, move ss); }\n+            unsafe { vec::push_all_move(v, move ss); }\n         }\n         return WindowsPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unchecked { vec::push_all_move(v, move ss); }\n+        unsafe { vec::push_all_move(v, move ss); }\n         return WindowsPath { components: move v, ..self }\n     }\n \n     pure fn pop() -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unchecked { vec::pop(cs); }\n+            unsafe { vec::pop(cs); }\n         }\n         return WindowsPath { components: move cs, ..self }\n     }\n@@ -421,9 +421,9 @@ impl WindowsPath : GenericPath {\n \n pure fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    unchecked {\n+    unsafe {\n         for components.each |c| {\n-            unchecked {\n+            unsafe {\n                 if c == ~\".\" && components.len() > 1 { loop; }\n                 if c == ~\"\" { loop; }\n                 if c == ~\"..\" && cs.len() != 0 {\n@@ -566,7 +566,7 @@ mod windows {\n     }\n \n     pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n-        unchecked {\n+        unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&\n                 s[1] == ':' as u8) {"}, {"sha": "26bb1c9f471ed1548e48881a7e18e3ab3917dcc0", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -1026,7 +1026,7 @@ impl<T: Send> Port<T>: Recv<T> {\n         }\n     }\n \n-    pure fn peek() -> bool unchecked {\n+    pure fn peek() -> bool unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n         let peek = match endp {\n@@ -1039,7 +1039,7 @@ impl<T: Send> Port<T>: Recv<T> {\n }\n \n impl<T: Send> Port<T>: Selectable {\n-    pure fn header() -> *PacketHeader unchecked {\n+    pure fn header() -> *PacketHeader unsafe {\n         match self.endp {\n           Some(endp) => endp.header(),\n           None => fail ~\"peeking empty stream\""}, {"sha": "58ccc89e88f7b0807c0bd572345c3fd85a5827f2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -47,7 +47,7 @@ extern mod rusti {\n \n /// Get an unsafe pointer to a value\n #[inline(always)]\n-pure fn addr_of<T>(val: T) -> *T { unchecked { rusti::addr_of(val) } }\n+pure fn addr_of<T>(val: T) -> *T { unsafe { rusti::addr_of(val) } }\n \n /// Get an unsafe mut pointer to a value\n #[inline(always)]"}, {"sha": "ece79ce078e127af8333c05a2044ace91275c748", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -21,7 +21,7 @@ enum Result<T, U> {\n pure fn get<T: Copy, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n-      Err(the_err) => unchecked {\n+      Err(the_err) => unsafe {\n         fail fmt!(\"get called on error result: %?\", the_err)\n       }\n     }\n@@ -37,7 +37,7 @@ pure fn get<T: Copy, U>(res: Result<T, U>) -> T {\n pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n         Ok(ref t) => t,\n-        Err(ref the_err) => unchecked {\n+        Err(ref the_err) => unsafe {\n             fail fmt!(\"get_ref called on error result: %?\", the_err)\n         }\n     }"}, {"sha": "b582c3102cb7fdecc5d993d61c114291c5891f7d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -226,14 +226,14 @@ fn push_char(&s: ~str, ch: char) {\n /// Convert a char to a string\n pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n-    unchecked { push_char(buf, ch); }\n+    unsafe { push_char(buf, ch); }\n     move buf\n }\n \n /// Convert a vector of chars to a string\n pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n-    unchecked {\n+    unsafe {\n         reserve(buf, chs.len());\n         for vec::each(chs) |ch| { push_char(buf, ch); }\n     }\n@@ -279,7 +279,7 @@ fn push_str(&lhs: ~str, rhs: &str) {\n #[inline(always)]\n pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n-    unchecked {\n+    unsafe {\n         push_str_no_overallocate(v, rhs);\n     }\n     move v\n@@ -289,16 +289,16 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n /// Concatenate a vector of strings\n pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n-    for vec::each(v) |ss| { unchecked { push_str(s, ss) }; }\n+    for vec::each(v) |ss| { unsafe { push_str(s, ss) }; }\n     move s\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unchecked { push_str(s, sep); } }\n-        unchecked { push_str(s, ss) };\n+        if first { first = false; } else { unsafe { push_str(s, sep); } }\n+        unsafe { push_str(s, ss) };\n     }\n     move s\n }\n@@ -457,7 +457,7 @@ pure fn chars(s: &str) -> ~[char] {\n     let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n-        unchecked { vec::push(buf, ch); }\n+        unsafe { vec::push(buf, ch); }\n         i = next;\n     }\n     move buf\n@@ -525,7 +525,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n-                if allow_empty || start < i unchecked {\n+                if allow_empty || start < i unsafe {\n                     vec::push(result,\n                               unsafe { raw::slice_bytes(s, start, i) });\n                 }\n@@ -569,15 +569,15 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n-            if allow_empty || start < i unchecked {\n+            if allow_empty || start < i unsafe {\n                 vec::push(result, unsafe { raw::slice_bytes(s, start, i)});\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n-    if allow_empty || start < l unchecked {\n+    if allow_empty || start < l unsafe {\n         vec::push(result, unsafe { raw::slice_bytes(s, start, l) });\n     }\n     move result\n@@ -675,14 +675,14 @@ pure fn words(s: &str) -> ~[~str] {\n /// Convert a string to lowercase. ASCII only\n pure fn to_lower(s: &str) -> ~str {\n     map(s,\n-        |c| unchecked{(libc::tolower(c as libc::c_char)) as char}\n+        |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n pure fn to_upper(s: &str) -> ~str {\n     map(s,\n-        |c| unchecked{(libc::toupper(c as libc::c_char)) as char}\n+        |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n     )\n }\n \n@@ -702,7 +702,7 @@ pure fn to_upper(s: &str) -> ~str {\n pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n-        if first { first = false; } else { unchecked {push_str(result, to); }}\n+        if first { first = false; } else { unsafe {push_str(result, to); }}\n         unsafe { push_str(result, raw::slice_bytes(s, start, end)); }\n     }\n     move result\n@@ -877,7 +877,7 @@ pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n /// Apply a function to each character\n pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n-    unchecked {\n+    unsafe {\n         reserve(result, len(ss));\n         do chars_iter(ss) |cc| {\n             str::push_char(result, ff(cc));\n@@ -1522,11 +1522,11 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n-        if (ch & 0xFFFF_u32) == ch unchecked {\n+        if (ch & 0xFFFF_u32) == ch unsafe {\n             // The BMP falls through (assuming non-surrogate, as it should)\n             assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n             vec::push(u, ch as u16)\n-        } else unchecked {\n+        } else unsafe {\n             // Supplementary planes break into surrogates.\n             assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n             ch -= 0x1_0000_u32;\n@@ -1565,7 +1565,7 @@ pure fn utf16_chars(v: &[u16], f: fn(char)) {\n \n pure fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n-    unchecked {\n+    unsafe {\n         reserve(buf, vec::len(v));\n         utf16_chars(v, |ch| push_char(buf, ch));\n     }\n@@ -1945,7 +1945,7 @@ pure fn capacity(&&s: ~str) -> uint {\n /// Escape each char in `s` with char::escape_default.\n pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unchecked {\n+    unsafe {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_default(c)));\n     }\n@@ -1955,7 +1955,7 @@ pure fn escape_default(s: &str) -> ~str {\n /// Escape each char in `s` with char::escape_unicode.\n pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unchecked {\n+    unsafe {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_unicode(c)));\n     }"}, {"sha": "5d5ccf5e42ca39e5e4ef07fbbf1b06d08770f0b3", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -62,13 +62,13 @@ pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n  */\n #[inline(always)]\n pure fn get_type_desc<T>() -> *TypeDesc {\n-    unchecked { rusti::get_tydesc::<T>() as *TypeDesc }\n+    unsafe { rusti::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns the size of a type\n #[inline(always)]\n pure fn size_of<T>() -> uint {\n-    unchecked { rusti::size_of::<T>() }\n+    unsafe { rusti::size_of::<T>() }\n }\n \n /**\n@@ -79,13 +79,13 @@ pure fn size_of<T>() -> uint {\n  */\n #[inline(always)]\n pure fn min_align_of<T>() -> uint {\n-    unchecked { rusti::min_align_of::<T>() }\n+    unsafe { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n #[inline(always)]\n pure fn pref_align_of<T>() -> uint {\n-    unchecked { rusti::pref_align_of::<T>() }\n+    unsafe { rusti::pref_align_of::<T>() }\n }\n \n /// Returns the refcount of a shared box (as just before calling this)"}, {"sha": "f6e2d78e16f72e76e110db579dfa364d5e47cf1b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -187,7 +187,7 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  */\n pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n     let mut v = ~[];\n-    unchecked{reserve(v, n_elts);}\n+    unsafe{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n     while i < n_elts unsafe { raw::set(v, i, op(i)); i += 1u; }\n     unsafe { raw::set_len(v, n_elts); }\n@@ -202,7 +202,7 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  */\n pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n     let mut v = ~[];\n-    unchecked{reserve(v, n_elts)}\n+    unsafe{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n     unsafe { // because unsafe::set is unsafe\n         while i < n_elts { raw::set(v, i, t); i += 1u; }\n@@ -231,8 +231,8 @@ pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n #[inline(always)]\n pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> ~[A] {\n     let mut vec = ~[];\n-    unchecked { reserve(vec, size); }\n-    builder(|+x| unchecked { push(vec, move x) });\n+    unsafe { reserve(vec, size); }\n+    builder(|+x| unsafe { push(vec, move x) });\n     move vec\n }\n \n@@ -323,7 +323,7 @@ pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = ~[];\n-    unchecked {\n+    unsafe {\n         for uint::range(start, end) |i| { vec::push(result, v[i]) }\n     }\n     move result\n@@ -668,7 +668,7 @@ fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n #[inline(always)]\n pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n-    unchecked {\n+    unsafe {\n         push_all(v, rhs);\n     }\n     move v\n@@ -677,7 +677,7 @@ pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n #[inline(always)]\n pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n     let mut v <- lhs;\n-    unchecked { push(v, move x); }\n+    unsafe { push(v, move x); }\n     move v\n }\n \n@@ -754,7 +754,7 @@ fn grow_set<T: Copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n /// Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n-    unchecked{reserve(result, len(v));}\n+    unsafe{reserve(result, len(v));}\n     for each(v) |elem| { unsafe { push(result, f(elem)); } }\n     move result\n }\n@@ -770,7 +770,7 @@ fn map_consume<T, U>(+v: ~[T], f: fn(+T) -> U) -> ~[U] {\n /// Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n-    unchecked{reserve(result, len(v));}\n+    unsafe{reserve(result, len(v));}\n     for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n     move result\n }\n@@ -781,7 +781,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n  */\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unchecked{ push_all_move(result, f(elem)); } }\n+    for each(v) |elem| { unsafe{ push_all_move(result, f(elem)); } }\n     move result\n }\n \n@@ -849,7 +849,7 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n     let mut first = true;\n     for each(v) |inner| {\n         if first { first = false; } else { unsafe { push(r, sep); } }\n-        unchecked { push_all(r, inner) };\n+        unsafe { push_all(r, inner) };\n     }\n     move r\n }\n@@ -1071,7 +1071,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut as_ = ~[], bs = ~[];\n     for each(v) |p| {\n         let (a, b) = p;\n-        unchecked {\n+        unsafe {\n             vec::push(as_, a);\n             vec::push(bs, b);\n         }\n@@ -1089,7 +1089,7 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  */\n pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n-    unchecked {\n+    unsafe {\n         do consume(move v) |_i, p| {\n             let (a,b) = move p;\n             push(ts, move a);\n@@ -1108,7 +1108,7 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz unchecked { vec::push(zipped, (v[i], u[i])); i += 1u; }\n+    while i < sz unsafe { vec::push(zipped, (v[i], u[i])); i += 1u; }\n     move zipped\n }\n \n@@ -1123,10 +1123,10 @@ pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n     assert i == len(u);\n     let mut w = ~[mut];\n     while i > 0 {\n-        unchecked { push(w, (pop(v),pop(u))); }\n+        unsafe { push(w, (pop(v),pop(u))); }\n         i -= 1;\n     }\n-    unchecked { reverse(w); }\n+    unsafe { reverse(w); }\n     from_mut(move w)\n }\n \n@@ -1156,7 +1156,7 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (move rs); } else { i -= 1; }\n-    unchecked {\n+    unsafe {\n         while i != 0 { vec::push(rs, v[i]); i -= 1; }\n         vec::push(rs, v[0]);\n     }\n@@ -1400,7 +1400,7 @@ pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n         while i < ln {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i);\n-            unchecked {\n+            unsafe {\n                 push_all(rest, const_view(v, i+1u, ln));\n                 permute(rest, |permutation| {\n                     put(append(~[elt], permutation))\n@@ -1416,7 +1416,7 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     assert 1u <= nn;\n     vec::iteri (xx, |ii, _x| {\n         let len = vec::len(xx);\n-        if ii+nn <= len unchecked {\n+        if ii+nn <= len unsafe {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n     });"}, {"sha": "f12ad58a8130408c9933283104376b905b13f46c", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -127,7 +127,7 @@ impl BigBitv {\n             let w0 = self.storage[i] & mask;\n             let w1 = b.storage[i] & mask;\n             let w = op(w0, w1) & mask;\n-            if w0 != w unchecked {\n+            if w0 != w unsafe {\n                 changed = true;\n                 self.storage[i] = w;\n             }"}, {"sha": "0dbbfe1d150705498078b2bcf504c5b959684275", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -43,7 +43,7 @@ type TaggedDoc = {tag: uint, doc: Doc};\n \n impl Doc: ops::Index<uint,Doc> {\n     pure fn index(&&tag: uint) -> Doc {\n-        unchecked {\n+        unsafe {\n             get_doc(self, tag)\n         }\n     }"}, {"sha": "b269ca84104ff379c8a52ea65a6c8983b719ae75", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -645,7 +645,7 @@ pure fn lt(value0: Json, value1: Json) -> bool {\n             match value1 {\n                 Num(_) | String(_) | Boolean(_) | List(_) => false,\n                 Dict(d1) => {\n-                    unchecked {\n+                    unsafe {\n                         let (d0_flat, d1_flat) = {\n                             let d0_flat = dvec::DVec();\n                             for d0.each |k, v| { d0_flat.push((k, v)); }"}, {"sha": "1726e1f581fc5face0f2c5f55f60f903a6a6590e", "filename": "src/libstd/map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -137,7 +137,7 @@ mod chained {\n                   }\n                   Some(e1) => {\n                     comp += 1u;\n-                    unchecked {\n+                    unsafe {\n                         if e1.hash == h && e1.key == *k {\n                             debug!(\"search_tbl: present, comp %u, \\\n                                     hash %u, idx %u\",\n@@ -161,7 +161,7 @@ mod chained {\n                 return NotFound;\n               }\n               Some(e) => {\n-                unchecked {\n+                unsafe {\n                     if e.hash == h && e.key == *k {\n                         debug!(\"search_tbl: present, comp %u, hash %u, \\\n                                 idx %u\", 1u, h, idx);\n@@ -265,7 +265,7 @@ mod chained {\n         }\n \n         pure fn find(+k: K) -> Option<V> {\n-            unchecked {\n+            unsafe {\n                 match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n                   NotFound => None,\n                   FoundFirst(_, entry) => Some(entry.value),\n@@ -358,7 +358,7 @@ mod chained {\n \n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n         pure fn index(&&k: K) -> V {\n-            unchecked {\n+            unsafe {\n                 self.get(k)\n             }\n         }\n@@ -466,7 +466,7 @@ fn hash_from_uints<V: Copy>(items: &[(uint, V)]) -> HashMap<uint, V> {\n impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n     Map<K, V> {\n     pure fn size() -> uint {\n-        unchecked {\n+        unsafe {\n             do self.borrow_const |p| {\n                 p.len()\n             }\n@@ -498,7 +498,7 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n     }\n \n     pure fn find(+key: K) -> Option<V> {\n-        unchecked {\n+        unsafe {\n             do self.borrow_const |p| {\n                 p.find(&key)\n             }\n@@ -518,47 +518,47 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n     }\n \n     pure fn each(op: fn(+key: K, +value: V) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each(op)\n             }\n         }\n     }\n \n     pure fn each_key(op: fn(+key: K) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each_key(op)\n             }\n         }\n     }\n \n     pure fn each_value(op: fn(+value: V) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each_value(op)\n             }\n         }\n     }\n \n     pure fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each_ref(op)\n             }\n         }\n     }\n \n     pure fn each_key_ref(op: fn(key: &K) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each_key_ref(op)\n             }\n         }\n     }\n \n     pure fn each_value_ref(op: fn(value: &V) -> bool) {\n-        unchecked {\n+        unsafe {\n             do self.borrow_imm |p| {\n                 p.each_value_ref(op)\n             }"}, {"sha": "98907fba6829a63f25a6098ffd0c461d1ee9163f", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -737,7 +737,7 @@ impl Url: Eq {\n \n impl Url: IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n-        unchecked { self.to_str() }.iter_bytes(lsb0, f)\n+        unsafe { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }\n "}, {"sha": "ab4d46d2d8b06b4dec3f1c0184c1c1ab2071c92c", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -139,7 +139,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n \n impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n     pure fn index(&&key: uint) -> V {\n-        unchecked {\n+        unsafe {\n             get(self, key)\n         }\n     }"}, {"sha": "74ee337f5b525f561ade543810b2f103cbc17c90", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -314,7 +314,7 @@ mod tests {\n         // tjc: funny that we have to use parens\n         pure fn ile(x: &(&static/str), y: &(&static/str)) -> bool\n         {\n-            unchecked            // to_lower is not pure...\n+            unsafe            // to_lower is not pure...\n             {\n                 let x = x.to_lower();\n                 let y = y.to_lower();"}, {"sha": "34a812aac0056dfee61ed876c00d4760901d42d0", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -177,7 +177,7 @@ fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n     -> ValueRef {\n-    unchecked {\n+    unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n         llvm::LLVMConstPointerCast(v, T_ptr(llfnty))\n     }"}, {"sha": "a31d5568fa1c14efb55bef009a2694b7cd51fb86", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -1789,23 +1789,23 @@ fn remove_copyable(k: kind) -> kind {\n \n impl kind: ops::BitAnd<kind,kind> {\n     pure fn bitand(other: kind) -> kind {\n-        unchecked {\n+        unsafe {\n             lower_kind(self, other)\n         }\n     }\n }\n \n impl kind: ops::BitOr<kind,kind> {\n     pure fn bitor(other: kind) -> kind {\n-        unchecked {\n+        unsafe {\n             raise_kind(self, other)\n         }\n     }\n }\n \n impl kind: ops::Sub<kind,kind> {\n     pure fn sub(other: kind) -> kind {\n-        unchecked {\n+        unsafe {\n             kind_(*self & !*other)\n         }\n     }"}, {"sha": "22a1c15986c5b6eb0e53ba507e31157a2bf451ec", "filename": "src/test/compile-fail/borrowck-unchecked-with-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unchecked-with-borrow.rs?ref=2cdb23bbc08fba2f5dc7b0dcc79983fc02e32960", "patch": "@@ -5,7 +5,7 @@ fn foo(v: &const Option<int>) {\n     match *v {\n       Some(ref i) => {\n         //~^ ERROR illegal borrow unless pure\n-        unchecked {\n+        unsafe {\n             impure(*i); //~ NOTE impure due to access to impure function\n         }\n       }"}]}