{"sha": "c886815e949cefa9398b6c9c57a7126e743fe8eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ODY4MTVlOTQ5Y2VmYTkzOThiNmM5YzU3YTcxMjZlNzQzZmU4ZWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-03-11T19:57:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-11T19:57:42Z"}, "message": "Rollup merge of #40319 - eddyb:it's-\"unsize\"-not-\"unsound\", r=nikomatsakis\n\nDisallow subtyping between T and U in T: Unsize<U>.\n\nBecause `&mut T` can be coerced to `&mut U`, `T` and `U` must be unified invariantly. Fixes #40288.\nE.g. coercing `&mut [&'a X; N]` to `&mut [&'b X]` must require `'a` be equal to `'b`, otherwise you can convert between `&'a X` and `&'b X` (in either direction), potentially unsoundly lengthening lifetimes.\n\nSubtyping here was introduced with `Unsize` in #24619 (landed in 1.1, original PR is #23785).", "tree": {"sha": "6ced918a44754b28dfbe7a3d03f22d2d97021b29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ced918a44754b28dfbe7a3d03f22d2d97021b29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c886815e949cefa9398b6c9c57a7126e743fe8eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c886815e949cefa9398b6c9c57a7126e743fe8eb", "html_url": "https://github.com/rust-lang/rust/commit/c886815e949cefa9398b6c9c57a7126e743fe8eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c886815e949cefa9398b6c9c57a7126e743fe8eb/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b49036c7d016f1fdf99bec9b398f7f6c052d5464", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49036c7d016f1fdf99bec9b398f7f6c052d5464", "html_url": "https://github.com/rust-lang/rust/commit/b49036c7d016f1fdf99bec9b398f7f6c052d5464"}, {"sha": "cfb41aedd3a5e21c169a0a91dfd600e8e370d291", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb41aedd3a5e21c169a0a91dfd600e8e370d291", "html_url": "https://github.com/rust-lang/rust/commit/cfb41aedd3a5e21c169a0a91dfd600e8e370d291"}], "stats": {"total": 379, "additions": 249, "deletions": 130}, "files": [{"sha": "38ea1e4a19b91f536e989da9610cc1547384e700", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -2461,7 +2461,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_dynamic(\n                     ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n+                    self.infcx.eq_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2520,7 +2520,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, a, b)\n+                    self.infcx.eq_types(false, &obligation.cause, a, b)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2583,7 +2583,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, new_struct, target)\n+                    self.infcx.eq_types(false, &obligation.cause, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n "}, {"sha": "1aab4853a4f641f6efd096c191365258b75d46c9", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n \n use super::FnCtxt;\n \n+use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n@@ -149,6 +150,14 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n         where I: IntoIterator<Item = &'b hir::Expr>\n+    {\n+        let fcx = self.fcx;\n+        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n+    }\n+\n+    pub fn finalize_as_infer_ok<'b, I>(self, pref: LvaluePreference, exprs: I)\n+                                       -> InferOk<'tcx, ()>\n+        where I: IntoIterator<Item = &'b hir::Expr>\n     {\n         let methods: Vec<_> = self.steps\n             .iter()\n@@ -176,8 +185,9 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        for obligation in self.obligations {\n-            self.fcx.register_predicate(obligation);\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations\n         }\n     }\n }"}, {"sha": "c43291557f7fa4034959ac0f2fb1eb06a89c03ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 102, "deletions": 112, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -64,7 +64,8 @@ use check::FnCtxt;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{Coercion, InferOk, TypeTrace};\n+use rustc::infer::{Coercion, InferResult, InferOk, TypeTrace};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut,\n@@ -75,17 +76,14 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use syntax::abi;\n use syntax::feature_gate;\n-use util::common::indent;\n \n-use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n-    unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -95,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n+type CoerceResult<'tcx> = InferResult<'tcx, Adjustment<'tcx>>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -108,44 +106,53 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n+fn identity<'tcx>() -> Adjust<'tcx> {\n+    Adjust::DerefRef {\n+        autoderefs: 0,\n+        autoref: None,\n+        unsize: false,\n+    }\n+}\n+\n+fn success<'tcx>(kind: Adjust<'tcx>,\n+                 target: Ty<'tcx>,\n+                 obligations: traits::PredicateObligations<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+    Ok(InferOk {\n+        value: Adjustment {\n+            kind,\n+            target\n+        },\n+        obligations\n+    })\n+}\n+\n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n         Coerce {\n             fcx: fcx,\n             cause: cause,\n             use_lub: false,\n-            unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n-                    .map(|ok| self.register_infer_ok_obligations(ok))\n             } else {\n                 self.sub(false, trace, &a, &b)\n-                    .map(|InferOk { value, obligations }| {\n-                        self.fcx.register_predicates(obligations);\n-                        value\n-                    })\n             }\n         })\n     }\n \n-    /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        self.unify(&a, &b).and_then(|ty| self.identity(ty))\n-    }\n-\n-    /// Synthesize an identity adjustment.\n-    fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty, Adjust::DerefRef {\n-            autoderefs: 0,\n-            autoref: None,\n-            unsize: false,\n-        }))\n+    /// Unify two types (using sub or lub) and produce a specific coercion.\n+    fn unify_and(&self, a: Ty<'tcx>, b: Ty<'tcx>, kind: Adjust<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+        self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n+            success(kind, ty, obligations)\n+        })\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -158,11 +165,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return self.identity(b);\n+            return success(identity(), b, vec![]);\n         }\n \n         if a.is_never() {\n-            return Ok((b, Adjust::NeverToAny));\n+            return success(Adjust::NeverToAny, b, vec![]);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -208,7 +215,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_and_identity(a, b)\n+                self.unify_and(a, b, identity())\n             }\n         }\n     }\n@@ -240,15 +247,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and_identity(a, b),\n+            _ => return self.unify_and(a, b, identity()),\n         };\n \n         let span = self.cause.span;\n \n         let mut first_error = None;\n         let mut r_borrow_var = None;\n         let mut autoderef = self.autoderef(span, a);\n-        let mut success = None;\n+        let mut found = None;\n \n         for (referent_ty, autoderefs) in autoderef.by_ref() {\n             if autoderefs == 0 {\n@@ -346,8 +353,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                   mutbl: mt_b.mutbl, // [1] above\n                                               });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => {\n-                    success = Some((ty, autoderefs));\n+                Ok(ok) => {\n+                    found = Some((ok, autoderefs));\n                     break;\n                 }\n                 Err(err) => {\n@@ -363,7 +370,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let (ty, autoderefs) = match success {\n+        let (InferOk { value: ty, mut obligations }, autoderefs) = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n@@ -372,12 +379,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n-        // This commits the obligations to the fulfillcx. After this succeeds,\n-        // this snapshot can't be rolled back.\n-        autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n-\n-        // Now apply the autoref. We have to extract the region out of\n-        // the final ref type we got.\n         if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n@@ -391,8 +392,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return self.identity(ty);\n+            return success(identity(), ty, obligations);\n         }\n+\n+        // Now apply the autoref. We have to extract the region out of\n+        // the final ref type we got.\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n@@ -402,11 +406,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty, Adjust::DerefRef {\n+\n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs()).obligations);\n+\n+        success(Adjust::DerefRef {\n             autoderefs: autoderefs,\n             autoref: autoref,\n             unsize: false,\n-        }))\n+        }, ty, obligations)\n     }\n \n \n@@ -445,18 +453,32 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => (source, None),\n         };\n-        let source = source.adjust_for_autoref(self.tcx, reborrow);\n+        let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n+\n+        let adjust = Adjust::DerefRef {\n+            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n+            autoref: reborrow,\n+            unsize: true,\n+        };\n+\n+        // Setup either a subtyping or a LUB relationship between\n+        // the `CoerceUnsized` target type and the expected type.\n+        // We only have the latter, so we use an inference variable\n+        // for the former and let type inference do the rest.\n+        let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n+        let coerce_target = self.next_ty_var(origin);\n+        let mut coercion = self.unify_and(coerce_target, target, adjust)?;\n \n         let mut selcx = traits::SelectionContext::new(self);\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();\n-        let mut leftover_predicates = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.cause.span, self.body_id);\n         queue.push_back(self.tcx\n-            .predicate_for_trait_def(cause, coerce_unsized_did, 0, source, &[target]));\n+            .predicate_for_trait_def(cause, coerce_unsized_did, 0,\n+                                     coerce_source, &[coerce_target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -467,7 +489,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             let trait_ref = match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n                 _ => {\n-                    leftover_predicates.push(obligation);\n+                    coercion.obligations.push(obligation);\n                     continue;\n                 }\n             };\n@@ -495,33 +517,26 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n-        *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n-\n-        let adjustment = Adjust::DerefRef {\n-            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n-            autoref: reborrow,\n-            unsize: true,\n-        };\n-        debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, adjustment))\n+        Ok(coercion)\n     }\n \n     fn coerce_from_safe_fn(&self,\n                            a: Ty<'tcx>,\n                            fn_ty_a: ty::PolyFnSig<'tcx>,\n-                           b: Ty<'tcx>)\n+                           b: Ty<'tcx>,\n+                           to_unsafe: Adjust<'tcx>,\n+                           normal: Adjust<'tcx>)\n                            -> CoerceResult<'tcx> {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n+                    return self.unify_and(unsafe_a, b, to_unsafe);\n                 }\n                 _ => {}\n             }\n         }\n-        self.unify_and_identity(a, b)\n+        self.unify_and(a, b, normal)\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -536,7 +551,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n-        self.coerce_from_safe_fn(a, fn_ty_a, b)\n+        self.coerce_from_safe_fn(a, fn_ty_a, b,\n+            Adjust::UnsafeFnPointer, identity())\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -554,10 +570,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n+                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n+                    Adjust::ReifyFnPointer, Adjust::ReifyFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -582,7 +598,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                    self.cause.span,\n                                                    feature_gate::GateIssue::Language,\n                                                    feature_gate::CLOSURE_TO_FN_COERCION);\n-                    return self.unify_and_identity(a, b);\n+                    return self.unify_and(a, b, identity());\n                 }\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n@@ -607,10 +623,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n-                self.unify_and_identity(pointer_ty, b)\n-                    .map(|(ty, _)| (ty, Adjust::ClosureFnPointer))\n+                self.unify_and(pointer_ty, b, Adjust::ClosureFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -625,7 +640,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify_and_identity(a, b);\n+                return self.unify_and(a, b, identity());\n             }\n         };\n \n@@ -634,50 +649,22 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             mutbl: mutbl_b,\n             ty: mt_a.ty,\n         });\n-        let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n-\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok((ty,\n-            if is_ref {\n-                Adjust::DerefRef {\n-                    autoderefs: 1,\n-                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n-                    unsize: false,\n-                }\n-            } else if mt_a.mutbl != mutbl_b {\n-                Adjust::MutToConstPointer\n-            } else {\n-                noop\n-            }))\n-    }\n-}\n-\n-fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n-                                   exprs: &E,\n-                                   a: Ty<'tcx>,\n-                                   b: Ty<'tcx>)\n-                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n-    where E: Fn() -> I,\n-          I: IntoIterator<Item = &'b hir::Expr>\n-{\n-\n-    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n-\n-    let fcx = coerce.fcx;\n-    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n-        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-        for obligation in obligations.drain(..) {\n-            fcx.register_predicate(obligation);\n-        }\n+        self.unify_and(a_unsafe, b, if is_ref {\n+            Adjust::DerefRef {\n+                autoderefs: 1,\n+                autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                unsize: false,\n+            }\n+        } else if mt_a.mutbl != mutbl_b {\n+            Adjust::MutToConstPointer\n+        } else {\n+            identity()\n+        })\n     }\n-\n-    Ok(Adjustment {\n-        kind: adjust,\n-        target: ty\n-    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -694,9 +681,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n-        let mut coerce = Coerce::new(self, cause);\n+        let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n-            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let ok = coerce.coerce(&|| Some(expr), source, target)?;\n+            let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n@@ -773,9 +761,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(&|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok(adjustment) => {\n+                Ok(ok) => {\n+                    let adjustment = self.register_infer_ok_obligations(ok);\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n@@ -816,7 +805,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| coerce.coerce(&exprs, prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -828,7 +817,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok(adjustment) => {\n+            Ok(ok) => {\n+                let adjustment = self.register_infer_ok_obligations(ok);\n                 if !adjustment.is_identity() {\n                     let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {"}, {"sha": "c1e8cb8b6defb231e9594736b31ae80165decbf8", "filename": "src/test/compile-fail/issue-40288-2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn prove_static<T: 'static + ?Sized>(_: &'static T) {}\n+\n+fn lifetime_transmute_slice<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n+    let mut out = [x];\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    {\n+        let slice: &mut [_] = &mut out;\n+        slice[0] = y;\n+    }\n+    out[0]\n+}\n+\n+struct Struct<T, U: ?Sized> {\n+    head: T,\n+    _tail: U\n+}\n+\n+fn lifetime_transmute_struct<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n+    let mut out = Struct { head: x, _tail: [()] };\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    {\n+        let dst: &mut Struct<_, [()]> = &mut out;\n+        dst.head = y;\n+    }\n+    out.head\n+}\n+\n+fn main() {\n+    prove_static(lifetime_transmute_slice(\"\", &String::from(\"foo\")));\n+    prove_static(lifetime_transmute_struct(\"\", &String::from(\"bar\")));\n+}"}, {"sha": "b5418e85bec784b04afc64488c57009701132eb2", "filename": "src/test/compile-fail/issue-40288.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn save_ref<'a>(refr: &'a i32, to: &mut [&'a i32]) {\n+    for val in &mut *to {\n+        *val = refr;\n+    }\n+}\n+\n+fn main() {\n+    let ref init = 0i32;\n+    let ref mut refr = 1i32;\n+\n+    let mut out = [init];\n+\n+    save_ref(&*refr, &mut out);\n+\n+    // This shouldn't be allowed as `refr` is borrowed\n+    *refr = 3; //~ ERROR cannot assign to `*refr` because it is borrowed\n+\n+    // Prints 3?!\n+    println!(\"{:?}\", out[0]);\n+}"}, {"sha": "e37b6a2bb9c99aa0993c5c3525edc5c322efc696", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -79,7 +79,7 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR lifetime bound not satisfied\n+        //~^ ERROR cannot infer\n         //~| ERROR cannot infer\n }\n "}, {"sha": "c0dd5200f6cb4e97be5e24eddf6f1d699f27052a", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR lifetime bound not satisfied\n+    ss.r //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR lifetime bound not satisfied\n+    ss.r = b; //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "ad6c5a31bbbd3fbc4076af08cde2723acd0992ad", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR lifetime bound not satisfied\n+    box v as Box<SomeTrait+'a> //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "17fd55b031b61463513dc077928a330bb5ffe6ac", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -16,7 +16,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR does not fulfill the required lifetime\n+    Box::new(move|| { *x }) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "e8ada6a1755719205422e74f43591b9bf8ea138f", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -22,8 +22,8 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR lifetime bound not satisfied\n-     //~^ ERROR cannot infer\n+    x //~ ERROR cannot infer an appropriate lifetime\n+     //~^ ERROR cannot infer an appropriate lifetime\n }\n \n struct Wrapper<T>(T);"}, {"sha": "d3bf92e85f411a5207e03786dc844487d7417dcf", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -21,15 +21,15 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n     // Previously OK:\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "0e94e35df2839895fdc389f970eeb6396db708e0", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -22,14 +22,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n     where 'max : 'min\n {\n     // Previously OK, now an error as traits are invariant.\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "aa3e06c015d503829e89c839c2beb07e52a40e4e", "filename": "src/test/compile-fail/variance-invariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -18,14 +18,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "b19708f5a89316f46bad187fdca87bf5235eb932", "filename": "src/test/run-pass/coerce-unsize-subtype.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c886815e949cefa9398b6c9c57a7126e743fe8eb/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs?ref=c886815e949cefa9398b6c9c57a7126e743fe8eb", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-expanded FIXME #23616\n+\n+use std::rc::Rc;\n+\n+fn lub_short<'a, T>(_: &[&'a T], _: &[&'a T]) {}\n+\n+// The two arguments are a subtype of their LUB, after coercion.\n+fn long_and_short<'a, T>(xs: &[&'static T; 1], ys: &[&'a T; 1]) {\n+    lub_short(xs, ys);\n+}\n+\n+// The argument coerces to a subtype of the return type.\n+fn long_to_short<'a, 'b, T>(xs: &'b [&'static T; 1]) -> &'b [&'a T] {\n+    xs\n+}\n+\n+// Rc<T> is covariant over T just like &T.\n+fn long_to_short_rc<'a, T>(xs: Rc<[&'static T; 1]>) -> Rc<[&'a T]> {\n+    xs\n+}\n+\n+// LUB-coercion (if-else/match/array) coerces `xs: &'b [&'static T: N]`\n+// to a subtype of the LUB of `xs` and `ys` (i.e. `&'b [&'a T]`),\n+// regardless of the order they appear (in if-else/match/array).\n+fn long_and_short_lub1<'a, 'b, T>(xs: &'b [&'static T; 1], ys: &'b [&'a T]) {\n+    let _order1 = [xs, ys];\n+    let _order2 = [ys, xs];\n+}\n+\n+// LUB-coercion should also have the exact same effect when `&'b [&'a T; N]`\n+// needs to be coerced, i.e. the resulting type is not &'b [&'static T], but\n+// rather the `&'b [&'a T]` LUB.\n+fn long_and_short_lub2<'a, 'b, T>(xs: &'b [&'static T], ys: &'b [&'a T; 1]) {\n+    let _order1 = [xs, ys];\n+    let _order2 = [ys, xs];\n+}\n+\n+fn main() {}"}]}