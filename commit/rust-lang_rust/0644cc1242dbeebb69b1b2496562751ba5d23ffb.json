{"sha": "0644cc1242dbeebb69b1b2496562751ba5d23ffb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NDRjYzEyNDJkYmVlYmI2OWIxYjI0OTY1NjI3NTFiYTVkMjNmZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T11:48:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T11:48:50Z"}, "message": "Auto merge of #76610 - hch12907:master, r=LukasKalbertodt\n\nImplement as_ne_bytes() for integers and floats\n\nThis is related to issue #64464.\n\nI am pretty sure that these functions are actually const-ify-able, and technically as_bits() can also be implemented for floats, but I might need some comments on both.", "tree": {"sha": "3fa7d4c30d1edbabfed1a10a84634458aa538dff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fa7d4c30d1edbabfed1a10a84634458aa538dff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0644cc1242dbeebb69b1b2496562751ba5d23ffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0644cc1242dbeebb69b1b2496562751ba5d23ffb", "html_url": "https://github.com/rust-lang/rust/commit/0644cc1242dbeebb69b1b2496562751ba5d23ffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0644cc1242dbeebb69b1b2496562751ba5d23ffb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d37dca25a51fb900a402c94c8818ad1c2789e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d37dca25a51fb900a402c94c8818ad1c2789e30", "html_url": "https://github.com/rust-lang/rust/commit/0d37dca25a51fb900a402c94c8818ad1c2789e30"}, {"sha": "3c582db8cb43dac1d13dd653078a68753d4baa99", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c582db8cb43dac1d13dd653078a68753d4baa99", "html_url": "https://github.com/rust-lang/rust/commit/3c582db8cb43dac1d13dd653078a68753d4baa99"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "bf7c87f685d3cf4af7fb4aae996d025adf10ab6d", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=0644cc1242dbeebb69b1b2496562751ba5d23ffb", "patch": "@@ -773,6 +773,35 @@ impl f32 {\n         self.to_bits().to_ne_bytes()\n     }\n \n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n+    ///\n+    /// [`to_ne_bytes`] should be preferred over this whenever possible.\n+    ///\n+    /// [`to_ne_bytes`]: #method.to_ne_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(num_as_ne_bytes)]\n+    /// let num = 12.5f32;\n+    /// let bytes = num.as_ne_bytes();\n+    /// assert_eq!(\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         &[0x41, 0x48, 0x00, 0x00]\n+    ///     } else {\n+    ///         &[0x00, 0x00, 0x48, 0x41]\n+    ///     }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n+    #[inline]\n+    pub fn as_ne_bytes(&self) -> &[u8; 4] {\n+        // SAFETY: `f32` is a plain old datatype so we can always transmute to it\n+        unsafe { &*(self as *const Self as *const _) }\n+    }\n+\n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n     /// # Examples"}, {"sha": "e31e176ba1b0ac379ee9b32d51c4772734368e2e", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=0644cc1242dbeebb69b1b2496562751ba5d23ffb", "patch": "@@ -787,6 +787,35 @@ impl f64 {\n         self.to_bits().to_ne_bytes()\n     }\n \n+    /// Return the memory representation of this floating point number as a byte array in\n+    /// native byte order.\n+    ///\n+    /// [`to_ne_bytes`] should be preferred over this whenever possible.\n+    ///\n+    /// [`to_ne_bytes`]: #method.to_ne_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(num_as_ne_bytes)]\n+    /// let num = 12.5f64;\n+    /// let bytes = num.as_ne_bytes();\n+    /// assert_eq!(\n+    ///     bytes,\n+    ///     if cfg!(target_endian = \"big\") {\n+    ///         &[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n+    ///     } else {\n+    ///         &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n+    ///     }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n+    #[inline]\n+    pub fn as_ne_bytes(&self) -> &[u8; 8] {\n+        // SAFETY: `f64` is a plain old datatype so we can always transmute to it\n+        unsafe { &*(self as *const Self as *const _) }\n+    }\n+\n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n     /// # Examples"}, {"sha": "33fa26675f610234048af8aaf0f7d25e9dcda9ee", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=0644cc1242dbeebb69b1b2496562751ba5d23ffb", "patch": "@@ -2054,6 +2054,41 @@ assert_eq!(\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+[`to_ne_bytes`] should be preferred over this whenever possible.\n+\n+[`to_ne_bytes`]: #method.to_ne_bytes\n+\",\n+\n+\"\n+# Examples\n+\n+```\n+#![feature(num_as_ne_bytes)]\n+let num = \", $swap_op, stringify!($SelfT), \";\n+let bytes = num.as_ne_bytes();\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n+        &\", $be_bytes, \"\n+    } else {\n+        &\", $le_bytes, \"\n+    }\n+);\n+```\"),\n+            #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n+            #[inline]\n+            pub fn as_ne_bytes(&self) -> &[u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n+                unsafe { &*(self as *const Self as *const _) }\n+            }\n+        }\n+\n doc_comment! {\n             concat!(\"Create an integer value from its representation as a byte array in\n big endian."}, {"sha": "0de1cc6b1654a0173837bffe097c9689b5d9ce18", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0644cc1242dbeebb69b1b2496562751ba5d23ffb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=0644cc1242dbeebb69b1b2496562751ba5d23ffb", "patch": "@@ -1812,6 +1812,41 @@ assert_eq!(\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+[`to_ne_bytes`] should be preferred over this whenever possible.\n+\n+[`to_ne_bytes`]: #method.to_ne_bytes\n+\",\n+\n+\"\n+# Examples\n+\n+```\n+#![feature(num_as_ne_bytes)]\n+let num = \", $swap_op, stringify!($SelfT), \";\n+let bytes = num.as_ne_bytes();\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n+        &\", $be_bytes, \"\n+    } else {\n+        &\", $le_bytes, \"\n+    }\n+);\n+```\"),\n+            #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n+            #[inline]\n+            pub fn as_ne_bytes(&self) -> &[u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n+                unsafe { &*(self as *const Self as *const _) }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Create a native endian integer value from its representation\n as a byte array in big endian."}]}