{"sha": "38e842244c33ced2bc248a0b0911b507336829c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZTg0MjI0NGMzM2NlZDJiYzI0OGEwYjA5MTFiNTA3MzM2ODI5Yzk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T18:23:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T18:23:36Z"}, "message": "rustc: Remove all uses of plain_ty() and friends from outside of ty.rs", "tree": {"sha": "e58ecf52ea5e5914150e935dd42922515eb4e78f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e58ecf52ea5e5914150e935dd42922515eb4e78f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38e842244c33ced2bc248a0b0911b507336829c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38e842244c33ced2bc248a0b0911b507336829c9", "html_url": "https://github.com/rust-lang/rust/commit/38e842244c33ced2bc248a0b0911b507336829c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38e842244c33ced2bc248a0b0911b507336829c9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac62488bb1ca8ff934a803d3b608e2a1b2ccc82e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac62488bb1ca8ff934a803d3b608e2a1b2ccc82e", "html_url": "https://github.com/rust-lang/rust/commit/ac62488bb1ca8ff934a803d3b608e2a1b2ccc82e"}], "stats": {"total": 301, "additions": 136, "deletions": 165}, "files": [{"sha": "07a7da97cbfbd7fa86e4280bc9cf2c37462d6705", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=38e842244c33ced2bc248a0b0911b507336829c9", "patch": "@@ -456,7 +456,7 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(ebml_w, ty.plain_ty(ty.ty_native));\n+            encode_type(ebml_w, ty.mk_native());\n         }\n         case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);"}, {"sha": "fbdbf0b2a61fff2469ed5a5711e681f2aae836d3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=38e842244c33ced2bc248a0b0911b507336829c9", "patch": "@@ -21,7 +21,6 @@ import back.abi;\n import pretty.pprust;\n \n import middle.ty.pat_ty;\n-import middle.ty.plain_ty;\n \n import util.common;\n import util.common.istr;\n@@ -639,7 +638,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n             vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          plain_ty(ty.ty_nil), 0u)));\n+                                          ty.mk_nil(), 0u)));\n     }\n \n     // ... then explicit args.\n@@ -1150,7 +1149,7 @@ fn simplify_type(@ty.t typ) -> @ty.t {\n     fn simplifier(@ty.t typ) -> @ty.t {\n         alt (typ.struct) {\n             case (ty.ty_box(_)) {\n-                ret ty.plain_box_ty(ty.plain_ty(ty.ty_nil), ast.imm);\n+                ret ty.mk_imm_box(ty.mk_nil());\n             }\n             case (_) { ret typ; }\n         }\n@@ -1187,7 +1186,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (variant_info variant in variants) {\n-        auto tup_ty = simplify_type(ty.plain_tup_ty(variant.args));\n+        auto tup_ty = simplify_type(ty.mk_imm_tup(variant.args));\n \n         // Perform any type parameter substitutions.\n         tup_ty = ty.bind_params_in_type(tup_ty);\n@@ -1403,7 +1402,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(t, ixs, 0u);\n-    auto prefix_ty = ty.plain_tup_ty(s.prefix);\n+    auto prefix_ty = ty.mk_imm_tup(s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -1434,7 +1433,7 @@ fn GEP_tag(@block_ctxt cx,\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n     auto arg_tys = variant.args;\n-    auto elem_ty = ty.plain_ty(ty.ty_nil);  // typestate infelicity\n+    auto elem_ty = ty.mk_nil(); // typestate infelicity\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n     for (@ty.t aty in arg_tys) {\n@@ -1448,7 +1447,7 @@ fn GEP_tag(@block_ctxt cx,\n         i += 1;\n     }\n \n-    auto tup_ty = ty.plain_tup_ty(true_arg_tys);\n+    auto tup_ty = ty.mk_imm_tup(true_arg_tys);\n \n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n@@ -1488,8 +1487,8 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n-    auto boxed_body = ty.plain_tup_ty(vec(plain_ty(ty.ty_int), t));\n-    auto box_ptr = ty.plain_box_ty(t, ast.imm);\n+    auto boxed_body = ty.mk_imm_tup(vec(ty.mk_int(), t));\n+    auto box_ptr = ty.mk_imm_box(t);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.lcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -2294,13 +2293,6 @@ fn tag_variant_with_id(@crate_ctxt cx,\n     fail;\n }\n \n-// Returns a new plain tag type of the given ID with no type parameters. Don't\n-// use this function in new code; it's a hack to keep things working for now.\n-fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n-    let vec[@ty.t] tps = vec();\n-    ret ty.plain_ty(ty.ty_tag(tid, tps));\n-}\n-\n \n type val_pair_fn = fn(@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n@@ -2341,8 +2333,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                   val_pair_and_ty_fn f) -> result {\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n-        auto tnil = plain_ty(ty.ty_nil);\n-        auto tbox = ty.plain_box_ty(tnil, ast.imm);\n+        auto tnil = ty.mk_nil();\n+        auto tbox = ty.mk_imm_box(tnil);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2407,8 +2399,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n             auto bcx = cx;\n-            bcx = f(bcx, lldiscrim_a, lldiscrim_b,\n-                    plain_ty(ty.ty_int)).bcx;\n+            bcx = f(bcx, lldiscrim_a, lldiscrim_b, ty.mk_int()).bcx;\n \n             auto unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n             unr_cx.build.Unreachable();\n@@ -2628,7 +2619,7 @@ fn iter_sequence(@block_ctxt cx,\n             ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n         case (ty.ty_str) {\n-            auto et = plain_ty(ty.ty_machine(common.ty_u8));\n+            auto et = ty.mk_mach(common.ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n         case (_) { fail; }\n@@ -3449,7 +3440,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     auto lcx = cx.fcx.lcx;\n     // FIXME: possibly support alias-mode here?\n-    auto decl_ty = plain_ty(ty.ty_nil);\n+    auto decl_ty = ty.mk_nil();\n     auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n@@ -3536,7 +3527,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto iter_body_llty = type_of_fn_full(lcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n-                                          plain_ty(ty.ty_nil), 0u);\n+                                          ty.mk_nil(), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n@@ -4235,8 +4226,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llclosure_ptr_ty = type_of(cx.ccx, ty.plain_box_ty(closure_ty,\n-                                                            ast.imm));\n+    auto llclosure_ptr_ty = type_of(cx.ccx, ty.mk_imm_box(closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4411,12 +4401,12 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = ty.plain_tup_ty(bound_tys);\n+            let @ty.t bindings_ty = ty.mk_imm_tup(bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n             // it constructs.\n-            let @ty.t tydesc_ty = plain_ty(ty.ty_type);\n+            let @ty.t tydesc_ty = ty.mk_type();\n \n             let vec[@ty.t] captured_tys =\n                 _vec.init_elt[@ty.t](tydesc_ty, ty_param_count);\n@@ -4425,9 +4415,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n-                    ty.plain_tup_ty(captured_tys));\n+                    ty.mk_imm_tup(captured_tys));\n \n-            let @ty.t closure_ty = ty.plain_tup_ty(closure_tys);\n+            let @ty.t closure_ty = ty.mk_imm_tup(closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n@@ -4829,8 +4819,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                            C_int(abi.vec_elt_data)));\n \n     auto pseudo_tup_ty =\n-        ty.plain_tup_ty(_vec.init_elt[@ty.t](unit_ty,\n-                                             _vec.len[@ast.expr](args)));\n+        ty.mk_imm_tup(_vec.init_elt[@ty.t](unit_ty,\n+                                           _vec.len[@ast.expr](args)));\n     let int i = 0;\n \n     for (@ast.expr e in args) {\n@@ -5927,7 +5917,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n-    auto fields_tup_ty = ty.plain_tup_ty(field_tys);\n+    auto fields_tup_ty = ty.mk_imm_tup(field_tys);\n \n     auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n@@ -6152,18 +6142,18 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n-        auto tydesc_ty = plain_ty(ty.ty_type);\n+        auto tydesc_ty = ty.mk_type();\n         let vec[@ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n             _vec.push[@ty.t](tps, tydesc_ty);\n         }\n \n-        let @ty.t typarams_ty = ty.plain_tup_ty(tps);\n-        let @ty.t fields_ty = ty.plain_tup_ty(obj_fields);\n-        let @ty.t body_ty = ty.plain_tup_ty(vec(tydesc_ty,\n-                                                typarams_ty,\n-                                                fields_ty));\n-        let @ty.t boxed_body_ty = ty.plain_box_ty(body_ty, ast.imm);\n+        let @ty.t typarams_ty = ty.mk_imm_tup(tps);\n+        let @ty.t fields_ty = ty.mk_imm_tup(obj_fields);\n+        let @ty.t body_ty = ty.mk_imm_tup(vec(tydesc_ty,\n+                                              typarams_ty,\n+                                              fields_ty));\n+        let @ty.t boxed_body_ty = ty.mk_imm_box(body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6265,7 +6255,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     let vec[@ty.t] ty_param_substs = vec();\n     i = 0u;\n     for (ast.ty_param tp in ty_params) {\n-        ty_param_substs += vec(plain_ty(ty.ty_param(i)));\n+        ty_param_substs += vec(ty.mk_param(i));\n         i += 1u;\n     }\n "}, {"sha": "8ad579ae61e8f48cf5c251609b884cdd701c8f7e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=38e842244c33ced2bc248a0b0911b507336829c9", "patch": "@@ -32,11 +32,11 @@ type mt = rec(@t ty, ast.mutability mut);\n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n fn method_ty_to_fn_ty(method m) -> @ty.t {\n-    ret plain_ty(ty_fn(m.proto, m.inputs, m.output));\n+    ret mk_fn(m.proto, m.inputs, m.output);\n }\n \n // Do not construct these manually. Soon we want to intern these, at which\n-// point this will break.\n+// point that will break.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariant.\n@@ -120,12 +120,24 @@ fn mk_tag(ast.def_id did, vec[@t] tys) -> @t {\n     ret plain_ty(ty_tag(did, tys));\n }\n \n-fn mk_box(mt tm) -> @t                   { ret plain_ty(ty_box(tm)); }\n+fn mk_box(mt tm) -> @t     { ret plain_ty(ty_box(tm)); }\n+fn mk_imm_box(@t ty) -> @t { ret mk_box(rec(ty=ty, mut=ast.imm)); }\n+\n fn mk_vec(mt tm) -> @t                   { ret plain_ty(ty_vec(tm)); }\n fn mk_port(@t ty) -> @t                  { ret plain_ty(ty_port(ty)); }\n fn mk_chan(@t ty) -> @t                  { ret plain_ty(ty_chan(ty)); }\n fn mk_task() -> @t                       { ret plain_ty(ty_task); }\n+\n fn mk_tup(vec[mt] tms) -> @t             { ret plain_ty(ty_tup(tms)); }\n+fn mk_imm_tup(vec[@t] tys) -> @t {\n+    // TODO: map\n+    let vec[ty.mt] mts = vec();\n+    for (@ty.t typ in tys) {\n+        mts += vec(rec(ty=typ, mut=ast.imm));\n+    }\n+    ret mk_tup(mts);\n+}\n+\n fn mk_rec(vec[field] fs) -> @t           { ret plain_ty(ty_rec(fs)); }\n \n fn mk_fn(ast.proto proto, vec[arg] args, @t ty) -> @t {\n@@ -515,7 +527,7 @@ fn type_is_sequence(@t ty) -> bool {\n \n fn sequence_element_type(@t ty) -> @t {\n     alt (ty.struct) {\n-        case (ty_str)      { ret plain_ty(ty_machine(common.ty_u8)); }\n+        case (ty_str)      { ret mk_mach(common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n@@ -691,18 +703,6 @@ fn plain_ty(&sty st) -> @t {\n     ret @rec(struct=st, cname=none[str]);\n }\n \n-fn plain_box_ty(@t subty, ast.mutability mut) -> @t {\n-    ret plain_ty(ty_box(rec(ty=subty, mut=mut)));\n-}\n-\n-fn plain_tup_ty(vec[@t] elem_tys) -> @t {\n-    let vec[ty.mt] mts = vec();\n-    for (@ty.t typ in elem_tys) {\n-        mts += vec(rec(ty=typ, mut=ast.imm));\n-    }\n-    ret plain_ty(ty_tup(mts));\n-}\n-\n fn def_to_str(ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n@@ -957,15 +957,15 @@ fn stmt_ty(@ast.stmt s) -> @t {\n             ret expr_ty(e);\n         }\n         case (_) {\n-            ret plain_ty(ty_nil);\n+            ret mk_nil();\n         }\n     }\n }\n \n fn block_ty(&ast.block b) -> @t {\n     alt (b.node.expr) {\n         case (some[@ast.expr](?e)) { ret expr_ty(e); }\n-        case (none[@ast.expr])     { ret plain_ty(ty_nil); }\n+        case (none[@ast.expr])     { ret mk_nil(); }\n     }\n }\n \n@@ -1035,7 +1035,7 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n // expr_ty_params_and_ty() below.\n fn expr_ty(@ast.expr expr) -> @t {\n     alt (expr_ann(expr)) {\n-        case (none[ast.ann])     { ret plain_ty(ty_nil);   }\n+        case (none[ast.ann])     { ret mk_nil(); }\n         case (some[ast.ann](?a)) { ret ann_to_monotype(a); }\n     }\n }\n@@ -1044,7 +1044,7 @@ fn expr_ty_params_and_ty(@ast.expr expr) -> tup(vec[@t], @t) {\n     alt (expr_ann(expr)) {\n         case (none[ast.ann]) {\n             let vec[@t] tps = vec();\n-            ret tup(tps, plain_ty(ty_nil));\n+            ret tup(tps, mk_nil());\n         }\n         case (some[ast.ann](?a)) {\n             ret tup(ann_to_type_params(a), ann_to_type(a));\n@@ -1313,7 +1313,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = plain_ty(ty.ty_fn(e_proto, result_ins, result_out));\n+                auto t2 = mk_fn(e_proto, result_ins, result_out);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -1340,8 +1340,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = plain_ty(ty.ty_native_fn(e_abi, result_ins,\n-                                                   result_out));\n+                auto t2 = mk_native_fn(e_abi, result_ins, result_out);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -1390,7 +1389,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         }\n         i += 1u;\n       }\n-      auto t = plain_ty(ty_obj(result_meths));\n+      auto t = mk_obj(result_meths);\n       ret ures_ok(t);\n     }\n \n@@ -1520,8 +1519,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(plain_ty(ty.ty_tag(expected_id,\n-                                                       result_tps)));\n+                        ret ures_ok(mk_tag(expected_id, result_tps));\n                     }\n                     case (_) { /* fall through */ }\n                 }\n@@ -1548,7 +1546,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(plain_ty(ty.ty_box(mt)));\n+                                ret ures_ok(mk_box(mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1581,7 +1579,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(plain_ty(ty.ty_vec(mt)));\n+                                ret ures_ok(mk_vec(mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1604,7 +1602,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_port(result_sub)));\n+                                ret ures_ok(mk_port(result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1627,7 +1625,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_chan(result_sub)));\n+                                ret ures_ok(mk_chan(result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1687,7 +1685,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(plain_ty(ty.ty_tup(result_elems)));\n+                        ret ures_ok(mk_tup(result_elems));\n                     }\n \n                     case (_) {\n@@ -1752,7 +1750,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(plain_ty(ty.ty_rec(result_fields)));\n+                        ret ures_ok(mk_rec(result_fields));\n                     }\n \n                     case (_) {\n@@ -1988,7 +1986,7 @@ fn bind_params_in_type(@t typ) -> @t {\n                     \"has bound params in it\";\n                 fail;\n             }\n-            case (ty_param(?index)) { ret plain_ty(ty_bound_param(index)); }\n+            case (ty_param(?index)) { ret mk_bound_param(index); }\n             case (_) { ret typ; }\n         }\n     }"}, {"sha": "0759c80910acc8b506bc91da43cb304c0a010951", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 73, "deletions": 90, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=38e842244c33ced2bc248a0b0911b507336829c9", "patch": "@@ -19,7 +19,6 @@ import middle.ty.method;\n import middle.ty.mode_is_alias;\n import middle.ty.pat_ty;\n import middle.ty.path_to_str;\n-import middle.ty.plain_ty;\n import middle.ty.triv_ann;\n import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n@@ -65,9 +64,7 @@ type ty_getter = fn(ast.def_id) -> ty.ty_param_count_and_ty;\n \n // Used to fill in the annotation for things that have uninteresting\n // types\n-fn boring_ann() -> ann {\n-    ret triv_ann(plain_ty(ty_nil));\n-}\n+fn boring_ann() -> ann { ret triv_ann(ty.mk_nil()); }\n \n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n@@ -109,7 +106,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             auto t;\n             alt (fcx.locals.find(id)) {\n                 case (some[@ty.t](?t1)) { t = t1; }\n-                case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n+                case (none[@ty.t]) { t = ty.mk_local(id); }\n             }\n             ret tup(0u, t);\n         }\n@@ -140,7 +137,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         case (ast.def_mod(_)) {\n             // Hopefully part of a path.\n             // TODO: return a type that's more poisonous, perhaps?\n-            ret tup(0u, plain_ty(ty.ty_nil));\n+            ret tup(0u, ty.mk_nil());\n         }\n \n         case (ast.def_ty(_)) {\n@@ -345,7 +342,7 @@ fn ty_of_fn_decl(@ty_item_table id_to_ty_item,\n                  ast.def_id def_id) -> ty.ty_param_count_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n-    auto t_fn = plain_ty(ty.ty_fn(proto, input_tys, output_ty));\n+    auto t_fn = ty.mk_fn(proto, input_tys, output_ty);\n     auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n     auto tpt = tup(ty_param_count, t_fn);\n     type_cache.insert(def_id, tpt);\n@@ -362,7 +359,7 @@ fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n                  ast.def_id def_id) -> ty.ty_param_count_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n-    auto t_fn = plain_ty(ty.ty_native_fn(abi, input_tys, output_ty));\n+    auto t_fn = ty.mk_native_fn(abi, input_tys, output_ty);\n     auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n     auto tpt = tup(ty_param_count, t_fn);\n     type_cache.insert(def_id, tpt);\n@@ -455,7 +452,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n         type_cache.insert(obj_ty_id, t_obj);\n \n-        auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj._1));\n+        auto t_fn = ty.mk_fn(ast.proto_fn, t_inputs, t_obj._1);\n         ret tup(t_obj._0, t_fn);\n     }\n \n@@ -513,11 +510,11 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n                 auto i = 0u;\n                 for (ast.ty_param tp in tps) {\n-                    subtys += vec(plain_ty(ty.ty_param(i)));\n+                    subtys += vec(ty.mk_param(i));\n                     i += 1u;\n                 }\n \n-                auto t = plain_ty(ty.ty_tag(def_id, subtys));\n+                auto t = ty.mk_tag(def_id, subtys);\n \n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n@@ -571,7 +568,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         let vec[@ty.t] ty_param_tys = vec();\n         auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            ty_param_tys += vec(plain_ty(ty.ty_param(i)));\n+            ty_param_tys += vec(ty.mk_param(i));\n             i += 1u;\n         }\n \n@@ -582,7 +579,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             // constructors get turned into functions.\n             auto result_ty;\n             if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n-                result_ty = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n+                result_ty = ty.mk_tag(tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -593,8 +590,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     auto arg_ty = ast_ty_to_ty(f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n-                auto tag_t = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n-                result_ty = plain_ty(ty.ty_fn(ast.proto_fn, args, tag_t));\n+                auto tag_t = ty.mk_tag(tag_id, ty_param_tys);\n+                result_ty = ty.mk_fn(ast.proto_fn, args, tag_t);\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n@@ -750,9 +747,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             let method meth_ty = meth_tys.(ix);\n             let ast.method_ m_;\n             let @ast.method m;\n-            auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.proto,\n-                                              meth_ty.inputs,\n-                                              meth_ty.output));\n+            auto meth_tfn = ty.mk_fn(meth_ty.proto,\n+                                     meth_ty.inputs,\n+                                     meth_ty.output);\n             m_ = rec(ann=triv_ann(meth_tfn)\n                 with meth.node\n             );\n@@ -773,8 +770,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             case (some[@ast.method](?d)) {\n                 let vec[arg] inputs = vec();\n                 let @ty.t output = @rec(struct=ty.ty_nil, cname=none[str]);\n-                auto dtor_tfn = plain_ty(ty.ty_fn(ast.proto_fn,\n-                                                  inputs, output));\n+                auto dtor_tfn = ty.mk_fn(ast.proto_fn, inputs, output);\n                 auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n                 dtor = some[@ast.method](@rec(node=d_ with *d));\n             }\n@@ -836,8 +832,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n mod Unify {\n     fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n         // FIXME: horrid botch\n-        let vec[mutable @ty.t] param_substs =\n-            vec(mutable plain_ty(ty.ty_nil));\n+        let vec[mutable @ty.t] param_substs = vec(mutable ty.mk_nil());\n         _vec.pop[mutable @ty.t](param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n@@ -891,7 +886,7 @@ mod Unify {\n                 alt (result) {\n                     case (ty.ures_ok(?new_subst)) {\n                         param_substs.(index) = new_subst;\n-                        ret ty.ures_ok(plain_ty(ty.ty_bound_param(index)));\n+                        ret ty.ures_ok(ty.mk_bound_param(index));\n                     }\n                     case (_) { ret result; }\n                 }\n@@ -924,7 +919,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n fn add_boxes(uint n, @ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = ty.plain_box_ty(t1, ast.imm);\n+        t1 = ty.mk_imm_box(t1);\n         n -= 1u;\n     }\n     ret t1;\n@@ -978,8 +973,7 @@ mod Demand {\n             implicit_boxes = count_boxes(actual);\n         }\n \n-        let vec[mutable @ty.t] ty_param_substs =\n-            vec(mutable plain_ty(ty.ty_nil));\n+        let vec[mutable @ty.t] ty_param_substs = vec(mutable ty.mk_nil());\n         _vec.pop[mutable @ty.t](ty_param_substs);   // FIXME: horrid botch\n         for (@ty.t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += vec(mutable ty_param_subst);\n@@ -1402,7 +1396,7 @@ mod Pushdown {\n                 let @ast.expr es_1;\n                 alt (t.struct) {\n                     case (ty.ty_chan(?subty)) {\n-                        auto pt = plain_ty(ty.ty_port(subty));\n+                        auto pt = ty.mk_port(subty);\n                         es_1 = pushdown_expr(fcx, pt, es);\n                     }\n                     case (_) {\n@@ -1430,17 +1424,15 @@ mod Pushdown {\n                 auto lval_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             lval_0);\n                 auto t = expr_ty(lval_1);\n-                auto expr_1 = pushdown_expr(fcx, plain_ty(ty.ty_port(t)),\n-                                            expr_0);\n+                auto expr_1 = pushdown_expr(fcx, ty.mk_port(t), expr_0);\n                 e_1 = ast.expr_recv(lval_1, expr_1, ann);\n             }\n \n             case (ast.expr_send(?lval_0, ?expr_0, ?ann)) {\n                 auto expr_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             expr_0);\n                 auto t = expr_ty(expr_1);\n-                auto lval_1 = pushdown_expr(fcx, plain_ty(ty.ty_chan(t)),\n-                                            lval_0);\n+                auto lval_1 = pushdown_expr(fcx, ty.mk_chan(t), lval_0);\n                 e_1 = ast.expr_send(lval_1, expr_1, ann);\n             }\n \n@@ -1468,7 +1460,7 @@ mod Pushdown {\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n-                Demand.simple(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n+                Demand.simple(fcx, bloc.span, expected, ty.mk_nil());\n                 ret fold.respan[ast.block_](bloc.span,\n                       rec(a = boring_ann() with bloc.node));\n             }\n@@ -1547,21 +1539,20 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n // AST fragment checking\n \n fn check_lit(@ast.lit lit) -> @ty.t {\n-    auto sty;\n     alt (lit.node) {\n-        case (ast.lit_str(_))           { sty = ty.ty_str;  }\n-        case (ast.lit_char(_))          { sty = ty.ty_char; }\n-        case (ast.lit_int(_))           { sty = ty.ty_int;  }\n-        case (ast.lit_float(_))         { sty = ty.ty_float;  }\n+        case (ast.lit_str(_))           { ret ty.mk_str(); }\n+        case (ast.lit_char(_))          { ret ty.mk_char(); }\n+        case (ast.lit_int(_))           { ret ty.mk_int();  }\n+        case (ast.lit_float(_))         { ret ty.mk_float();  }\n         case (ast.lit_mach_float(?tm, _))\n-                                        { sty = ty.ty_machine(tm); }\n-        case (ast.lit_uint(_))          { sty = ty.ty_uint; }\n-        case (ast.lit_mach_int(?tm, _)) { sty = ty.ty_machine(tm); }\n-        case (ast.lit_nil)              { sty = ty.ty_nil;  }\n-        case (ast.lit_bool(_))          { sty = ty.ty_bool; }\n+                                        { ret ty.mk_mach(tm); }\n+        case (ast.lit_uint(_))          { ret ty.mk_uint(); }\n+        case (ast.lit_mach_int(?tm, _)) { ret ty.mk_mach(tm); }\n+        case (ast.lit_nil)              { ret ty.mk_nil();  }\n+        case (ast.lit_bool(_))          { ret ty.mk_bool(); }\n     }\n \n-    ret plain_ty(sty);\n+    fail; // not reached\n }\n \n fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n@@ -1677,10 +1668,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         auto t_0;\n         alt (expr_ty(f_0).struct) {\n             case (ty.ty_fn(?proto, _, _))   {\n-                t_0 = plain_ty(ty.ty_fn(proto, arg_tys_0, rt_0));\n+                t_0 = ty.mk_fn(proto, arg_tys_0, rt_0);\n             }\n             case (ty.ty_native_fn(?abi, _, _))   {\n-                t_0 = plain_ty(ty.ty_native_fn(abi, arg_tys_0, rt_0));\n+                t_0 = ty.mk_native_fn(abi, arg_tys_0, rt_0);\n             }\n             case (_) {\n                 log_err \"check_call_or_bind(): fn expr doesn't have fn type\";\n@@ -1755,12 +1746,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto t = strip_boxes(lhs_t0);\n             alt (binop) {\n-                case (ast.eq) { t = plain_ty(ty.ty_bool); }\n-                case (ast.lt) { t = plain_ty(ty.ty_bool); }\n-                case (ast.le) { t = plain_ty(ty.ty_bool); }\n-                case (ast.ne) { t = plain_ty(ty.ty_bool); }\n-                case (ast.ge) { t = plain_ty(ty.ty_bool); }\n-                case (ast.gt) { t = plain_ty(ty.ty_bool); }\n+                case (ast.eq) { t = ty.mk_bool(); }\n+                case (ast.lt) { t = ty.mk_bool(); }\n+                case (ast.le) { t = ty.mk_bool(); }\n+                case (ast.ne) { t = ty.mk_bool(); }\n+                case (ast.ge) { t = ty.mk_bool(); }\n+                case (ast.gt) { t = ty.mk_bool(); }\n                 case (_) { /* fall through */ }\n             }\n \n@@ -1776,7 +1767,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto oper_t = expr_ty(oper_1);\n             alt (unop) {\n                 case (ast.box(?mut)) {\n-                    oper_t = ty.plain_box_ty(oper_t, mut);\n+                    oper_t = ty.mk_box(rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n@@ -1800,7 +1791,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n-            auto t = plain_ty(ty.ty_nil);\n+            auto t = ty.mk_nil();\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n \n@@ -1851,7 +1842,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_ret(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = plain_ty(ty.ty_nil);\n+                    auto nil = ty.mk_nil();\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n@@ -1875,7 +1866,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_put(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = plain_ty(ty.ty_nil);\n+                    auto nil = ty.mk_nil();\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"put; in function \"\n                                          + \"putting non-nil\");\n@@ -1914,8 +1905,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n-            Demand.simple(fcx, expr.span, plain_ty(ty.ty_bool),\n-                          expr_ty(expr_t));\n+            Demand.simple(fcx, expr.span, ty.mk_bool(), expr_ty(expr_t));\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_check_expr(expr_t, boring_ann()));\n         }\n@@ -1942,7 +1932,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rhs_0 = check_expr(fcx, rhs);\n             auto rhs_t = expr_ty(rhs_0);\n \n-            auto chan_t = plain_ty(ty.ty_chan(rhs_t));\n+            auto chan_t = ty.mk_chan(rhs_t);\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n             alt (expr_ty(lhs_1).struct) {\n@@ -1965,7 +1955,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rhs_0 = check_expr(fcx, rhs);\n             auto lhs_t1 = expr_ty(lhs_0);\n \n-            auto port_t = plain_ty(ty.ty_port(lhs_t1));\n+            auto port_t = ty.mk_port(lhs_t1);\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n             alt (expr_ty(rhs_0).struct) {\n@@ -1985,8 +1975,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n-                                                 cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n             auto thn_t = block_ty(thn_0);\n@@ -2002,7 +1991,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (none[@ast.expr]) {\n                     elsopt_1 = none[@ast.expr];\n-                    elsopt_t = plain_ty(ty.ty_nil);\n+                    elsopt_t = ty.mk_nil();\n                 }\n             }\n \n@@ -2022,7 +2011,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(plain_ty(ty.ty_nil));\n+            auto ann = triv_ann(ty.mk_nil());\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -2033,27 +2022,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(plain_ty(ty.ty_nil));\n+            auto ann = triv_ann(ty.mk_nil());\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n         }\n \n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n-                                                 cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(plain_ty(ty.ty_nil));\n+            auto ann = triv_ann(ty.mk_nil());\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, plain_ty(ty.ty_bool),\n-                                                 cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n             auto ann = triv_ann(block_ty(body_1));\n@@ -2120,7 +2107,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     ann = triv_ann(expr_ty(expr));\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(plain_ty(ty.ty_nil));\n+                    ann = triv_ann(ty.mk_nil());\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2159,7 +2146,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto t_1 = plain_ty(ty.ty_fn(proto_1, arg_tys_1, rt_1));\n+            auto t_1 = ty.mk_fn(proto_1, arg_tys_1, rt_1);\n             auto ann = triv_ann(t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n@@ -2172,7 +2159,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Pull the return type out of the type of the function.\n-            auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n+            auto rt_1 = ty.mk_nil();    // FIXME: typestate botch\n             alt (expr_ty(f_1).struct) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n@@ -2188,7 +2175,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_self_method(?id, _)) {\n-            auto t = plain_ty(ty.ty_nil);\n+            auto t = ty.mk_nil();\n             let @ty.t this_obj_ty;\n \n             // Grab the type of the current object\n@@ -2246,7 +2233,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(plain_ty(ty.ty_task));\n+            auto ann = triv_ann(ty.mk_task());\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n@@ -2288,8 +2275,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 _vec.push[@ast.expr](args_1,expr_1);\n             }\n \n-            auto vec_sty = ty.ty_vec(rec(ty=t, mut=mut));\n-            auto ann = triv_ann(plain_ty(vec_sty));\n+            auto ann = triv_ann(ty.mk_vec(rec(ty=t, mut=mut)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, mut, ann));\n         }\n@@ -2305,7 +2291,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(plain_ty(ty.ty_tup(elts_mt)));\n+            auto ann = triv_ann(ty.mk_tup(elts_mt));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -2336,7 +2322,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(plain_ty(ty.ty_rec(fields_t)));\n+                    ann = triv_ann(ty.mk_rec(fields_t));\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n@@ -2421,8 +2407,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto t = plain_ty(ty.ty_fn(meth.proto,\n-                                               meth.inputs, meth.output));\n+                    auto t = ty.mk_fn(meth.proto, meth.inputs, meth.output);\n                     auto ann = triv_ann(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n@@ -2466,8 +2451,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              \"non-integral type of str index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto t = ty.ty_machine(common.ty_u8);\n-                    auto ann = triv_ann(plain_ty(t));\n+                    auto ann = triv_ann(ty.mk_mach(common.ty_u8));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2484,7 +2468,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_port(_)) {\n             auto t = next_ty_var(fcx.ccx);\n-            auto pt = plain_ty(ty.ty_port(t));\n+            auto pt = ty.mk_port(t);\n             auto ann = triv_ann(pt);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_port(ann));\n         }\n@@ -2494,7 +2478,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto port_t = expr_ty(expr_1);\n             alt (port_t.struct) {\n                 case (ty.ty_port(?subtype)) {\n-                    auto ct = plain_ty(ty.ty_chan(subtype));\n+                    auto ct = ty.mk_chan(subtype);\n                     auto ann = triv_ann(ct);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_chan(expr_1, ann));\n@@ -2516,7 +2500,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n }\n \n fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n-    auto t = plain_ty(ty.ty_var(ccx.next_var_id));\n+    auto t = ty.mk_var(ccx.next_var_id);\n     ccx.next_var_id += 1;\n     ret t;\n }\n@@ -2527,7 +2511,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n \n             auto t;\n \n-            t = plain_ty(middle.ty.ty_nil);\n+            t = middle.ty.mk_nil();\n             \n             alt (local.ty) {\n                 case (none[@ast.ty]) {\n@@ -2553,14 +2537,14 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n             alt (local.init) {\n                 case (some[ast.initializer](?init)) {\n                     auto expr_0 = check_expr(fcx, init.expr);\n-                    auto lty = plain_ty(ty.ty_local(local.id));\n+                    auto lty = ty.mk_local(local.id);\n                     auto expr_1;\n                     alt (init.op) {\n                         case (ast.init_assign) {\n                             expr_1 = Pushdown.pushdown_expr(fcx, lty, expr_0);\n                         }\n                         case (ast.init_recv) {\n-                            auto port_ty = plain_ty(ty.ty_port(lty));\n+                            auto port_ty = ty.mk_port(lty);\n                             expr_1 = Pushdown.pushdown_expr(fcx, port_ty,\n                                                             expr_0);\n                         }\n@@ -2692,8 +2676,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_sty = ty.ty_fn(f.proto, inputs, output_ty);\n-    auto fn_ann = triv_ann(plain_ty(fn_sty));\n+    auto fn_ann = triv_ann(ty.mk_fn(f.proto, inputs, output_ty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);"}, {"sha": "ef99a226e773d44a0545c3b2ca4ab00e39c94c31", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e842244c33ced2bc248a0b0911b507336829c9/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=38e842244c33ced2bc248a0b0911b507336829c9", "patch": "@@ -111,7 +111,7 @@ fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n }\n \n fn plain_ann() -> ast.ann {\n-  ret ast.ann_type(middle.ty.plain_ty(middle.ty.ty_nil),\n+  ret ast.ann_type(middle.ty.mk_nil(),\n                    none[vec[@middle.ty.t]], none[@ts_ann]);\n }\n "}]}