{"sha": "64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YTFiMjZiOGRmM2YxNTRkMTYyYzNkNzViN2NhN2Y3ZDRlYmFlNWY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-08T12:16:23Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-08T12:16:23Z"}, "message": "Implement `CoerceMany`", "tree": {"sha": "9e72fa6ff7350924b50126decb2b086904819bd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e72fa6ff7350924b50126decb2b086904819bd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "html_url": "https://github.com/rust-lang/rust/commit/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "html_url": "https://github.com/rust-lang/rust/commit/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9"}], "stats": {"total": 209, "additions": 120, "deletions": 89}, "files": [{"sha": "e4fcc56bc45bfb514cfa59f57bcc743cf1078941", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "patch": "@@ -25,9 +25,8 @@ impl InferenceContext<'_> {\n         };\n \n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n-        if let Ok(res) = self.coerce(closure_ty, &expected_ty) {\n-            self.write_expr_adj(closure_expr, res.value.0);\n-        }\n+        let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n+\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(&Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "7a624090b65fc3d0c19d13abfd11993b8dc4559f", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 85, "deletions": 49, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "patch": "@@ -10,7 +10,7 @@ use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n \n use crate::{\n     autoderef,\n-    infer::{Adjust, Adjustment, AutoBorrow, PointerCast, TypeMismatch},\n+    infer::{Adjust, Adjustment, AutoBorrow, InferResult, PointerCast, TypeMismatch},\n     static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Interner, Solution, Substitution, Ty,\n     TyBuilder, TyExt, TyKind,\n };\n@@ -36,23 +36,25 @@ fn success(\n ) -> CoerceResult {\n     Ok(InferOk { goals, value: (adj, target) })\n }\n+#[derive(Clone, Debug)]\n+pub(super) struct CoerceMany {\n+    expected_ty: Ty,\n+}\n \n-impl<'a> InferenceContext<'a> {\n-    /// Unify two types, but may coerce the first one to the second one\n-    /// using \"implicit coercion rules\" if needed.\n-    pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> CoerceResult {\n-        let from_ty = self.resolve_ty_shallow(from_ty);\n-        let to_ty = self.resolve_ty_shallow(to_ty);\n-        match self.coerce_inner(from_ty, &to_ty) {\n-            Ok(InferOk { value, goals }) => {\n-                self.table.register_infer_ok(InferOk { value: (), goals });\n-                Ok(InferOk { value, goals: Vec::new() })\n-            }\n-            Err(e) => {\n-                // FIXME deal with error\n-                Err(e)\n-            }\n-        }\n+impl CoerceMany {\n+    pub(super) fn new(expected: Ty) -> Self {\n+        CoerceMany { expected_ty: expected }\n+    }\n+\n+    pub(super) fn once(\n+        ctx: &mut InferenceContext<'_>,\n+        expected: Ty,\n+        expr: Option<ExprId>,\n+        expr_ty: &Ty,\n+    ) -> Ty {\n+        let mut this = CoerceMany::new(expected);\n+        this.coerce(ctx, expr, expr_ty);\n+        this.complete()\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -62,51 +64,88 @@ impl<'a> InferenceContext<'a> {\n     ///    coerce both to function pointers;\n     ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n     ///    least upper bound.\n-    pub(super) fn coerce_merge_branch(&mut self, id: Option<ExprId>, ty1: &Ty, ty2: &Ty) -> Ty {\n-        // TODO\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n+    pub(super) fn coerce(\n+        &mut self,\n+        ctx: &mut InferenceContext<'_>,\n+        expr: Option<ExprId>,\n+        expr_ty: &Ty,\n+    ) {\n+        let expr_ty = ctx.resolve_ty_shallow(expr_ty);\n+        self.expected_ty = ctx.resolve_ty_shallow(&self.expected_ty);\n+\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n+        let sig = match (self.expected_ty.kind(&Interner), expr_ty.kind(&Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n                 cov_mark::hit!(coerce_fn_reification);\n-                let sig = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig =\n+                    self.expected_ty.callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n                 Some(sig)\n             }\n             _ => None,\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(&Interner);\n-            let result1 = self.coerce_inner(ty1.clone(), &target_ty);\n-            let result2 = self.coerce_inner(ty2.clone(), &target_ty);\n+            let result1 = ctx.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result2 = ctx.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n-                self.table.register_infer_ok(result1);\n-                self.table.register_infer_ok(result2);\n-                return target_ty;\n+                ctx.table.register_infer_ok(result1);\n+                ctx.table.register_infer_ok(result2);\n+                return self.expected_ty = target_ty;\n             }\n         }\n \n-        // It might not seem like it, but order is important here: ty1 is our\n-        // \"previous\" type, ty2 is the \"new\" one being added. If the previous\n+        // It might not seem like it, but order is important here: If the expected\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if self.coerce(&ty2, &ty1).is_ok() {\n-            ty1\n-        } else if self.coerce(&ty1, &ty2).is_ok() {\n-            ty2\n+        if ctx.coerce(expr, &expr_ty, &self.expected_ty).is_ok() {\n+            /* self.expected_ty is already correct */\n+        } else if ctx.coerce(expr, &self.expected_ty, &expr_ty).is_ok() {\n+            self.expected_ty = expr_ty;\n         } else {\n-            if let Some(id) = id {\n-                self.result\n-                    .type_mismatches\n-                    .insert(id.into(), TypeMismatch { expected: ty1.clone(), actual: ty2 });\n+            if let Some(id) = expr {\n+                ctx.result.type_mismatches.insert(\n+                    id.into(),\n+                    TypeMismatch { expected: self.expected_ty.clone(), actual: expr_ty },\n+                );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n-            ty1\n+            /* self.expected_ty is already correct */\n+        }\n+    }\n+\n+    pub(super) fn complete(self) -> Ty {\n+        self.expected_ty\n+    }\n+}\n+\n+impl<'a> InferenceContext<'a> {\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    pub(super) fn coerce(\n+        &mut self,\n+        expr: Option<ExprId>,\n+        from_ty: &Ty,\n+        to_ty: &Ty,\n+    ) -> InferResult<Ty> {\n+        let from_ty = self.resolve_ty_shallow(from_ty);\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        match self.coerce_inner(from_ty, &to_ty) {\n+            Ok(InferOk { value: (adjustments, ty), goals }) => {\n+                if let Some(expr) = expr {\n+                    self.write_expr_adj(expr, adjustments);\n+                }\n+                self.table.register_infer_ok(InferOk { value: (), goals });\n+                Ok(InferOk { value: ty, goals: Vec::new() })\n+            }\n+            Err(e) => {\n+                // FIXME deal with error\n+                Err(e)\n+            }\n         }\n     }\n \n@@ -189,7 +228,6 @@ impl<'a> InferenceContext<'a> {\n \n         // Check that the types which they point at are compatible.\n         let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n-        // self.table.try_unify(&from_raw, to_ty);\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n@@ -518,15 +556,13 @@ impl<'a> InferenceContext<'a> {\n             // FIXME: should we accept ambiguous results here?\n             _ => return Err(TypeError),\n         };\n-        // TODO: this is probably wrong?\n-        let coerce_target = self.table.new_type_var();\n-        self.unify_and(&coerce_target, to_ty, |target| {\n-            let unsize = Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target };\n-            match reborrow {\n-                None => vec![unsize],\n-                Some((ref deref, ref autoref)) => vec![deref.clone(), autoref.clone(), unsize],\n-            }\n-        })\n+        let unsize =\n+            Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target: to_ty.clone() };\n+        let adjustments = match reborrow {\n+            None => vec![unsize],\n+            Some((deref, autoref)) => vec![deref, autoref, unsize],\n+        };\n+        success(adjustments, to_ty.clone(), vec![])\n     }\n }\n "}, {"sha": "20830d03e777f6729ea7c8d1fc57fbccafe87969", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=64a1b26b8df3f154d162c3d75b7ca7f7d4ebae5f", "patch": "@@ -16,6 +16,7 @@ use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, consteval,\n+    infer::coerce::CoerceMany,\n     lower::lower_to_chalk_mutability,\n     mapping::from_chalk,\n     method_resolution, op,\n@@ -56,11 +57,8 @@ impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, expected);\n         let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n-            match self.coerce(&ty, &target) {\n-                Ok(res) => {\n-                    self.result.expr_adjustments.insert(expr, res.value.0);\n-                    target\n-                }\n+            match self.coerce(Some(expr), &ty, &target) {\n+                Ok(res) => res.value,\n                 Err(_) => {\n                     self.result\n                         .type_mismatches\n@@ -128,31 +126,32 @@ impl<'a> InferenceContext<'a> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n             Expr::Missing => self.err_ty(),\n-            Expr::If { condition, then_branch, else_branch } => {\n+            &Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(\n-                    *condition,\n+                    condition,\n                     &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n-                let mut result_ty = self.table.new_type_var();\n-                let then_ty = self.infer_expr_inner(*then_branch, expected);\n+                let result_ty = self.table.new_type_var();\n+                let then_ty = self.infer_expr_inner(then_branch, expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n-                result_ty = self.coerce_merge_branch(Some(*then_branch), &result_ty, &then_ty);\n+                let mut coerce = CoerceMany::new(result_ty);\n+                coerce.coerce(self, Some(then_branch), &then_ty);\n                 let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(*else_branch, expected),\n+                    Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n                     None => TyBuilder::unit(),\n                 };\n                 both_arms_diverge &= self.diverges;\n                 // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n-                result_ty = self.coerce_merge_branch(*else_branch, &result_ty, &else_ty);\n+                coerce.coerce(self, else_branch, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                result_ty\n+                coerce.complete()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -193,7 +192,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Async { body } => {\n                 // Use the first type parameter as the output type of future.\n-                // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n@@ -223,6 +222,7 @@ impl<'a> InferenceContext<'a> {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n                     break_ty: self.err_ty(),\n+\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n@@ -344,14 +344,15 @@ impl<'a> InferenceContext<'a> {\n \n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n-                let mut result_ty = if arms.is_empty() {\n+                let result_ty = if arms.is_empty() {\n                     TyKind::Never.intern(&Interner)\n                 } else {\n                     match &expected {\n                         Expectation::HasType(ty) => ty.clone(),\n                         _ => self.table.new_type_var(),\n                     }\n                 };\n+                let mut coerce = CoerceMany::new(result_ty);\n \n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n@@ -368,12 +369,12 @@ impl<'a> InferenceContext<'a> {\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n                     all_arms_diverge &= self.diverges;\n-                    result_ty = self.coerce_merge_branch(Some(arm.expr), &result_ty, &arm_ty);\n+                    coerce.coerce(self, Some(arm.expr), &arm_ty);\n                 }\n \n                 self.diverges = matchee_diverges | all_arms_diverge;\n \n-                result_ty\n+                coerce.complete()\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -382,6 +383,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n             Expr::Break { expr, label } => {\n+                let expr = *expr;\n                 let last_ty =\n                     if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                         ctxt.break_ty.clone()\n@@ -390,13 +392,13 @@ impl<'a> InferenceContext<'a> {\n                     };\n \n                 let val_ty = if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none())\n+                    self.infer_expr(expr, &Expectation::none())\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                let merged_type = self.coerce_merge_branch(*expr, &last_ty, &val_ty);\n+                let merged_type = CoerceMany::once(self, last_ty, expr, &val_ty);\n \n                 if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                     ctxt.break_ty = merged_type;\n@@ -413,9 +415,7 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 } else {\n                     let unit = TyBuilder::unit();\n-                    if let Ok(ok) = self.coerce(&unit, &self.return_ty.clone()) {\n-                        self.write_expr_adj(tgt_expr, ok.value.0);\n-                    }\n+                    let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n                 TyKind::Never.intern(&Interner)\n             }\n@@ -744,39 +744,37 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let mut elem_ty =\n+                let elem_ty =\n                     match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(&Interner)) {\n                         Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n                         _ => self.table.new_type_var(),\n                     };\n+                let mut coerce = CoerceMany::new(elem_ty.clone());\n \n                 let expected = Expectation::has_type(elem_ty.clone());\n                 let len = match array {\n                     Array::ElementList(items) => {\n-                        for expr in items.iter() {\n-                            let cur_elem_ty = self.infer_expr_inner(*expr, &expected);\n-                            elem_ty = self.coerce_merge_branch(Some(*expr), &elem_ty, &cur_elem_ty);\n+                        for &expr in items.iter() {\n+                            let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n+                            coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n                         Some(items.len() as u64)\n                     }\n-                    Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(\n-                            *initializer,\n-                            &Expectation::has_type(elem_ty.clone()),\n-                        );\n+                    &Array::Repeat { initializer, repeat } => {\n+                        self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n                         self.infer_expr(\n-                            *repeat,\n+                            repeat,\n                             &Expectation::has_type(\n                                 TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner),\n                             ),\n                         );\n \n-                        let repeat_expr = &self.body.exprs[*repeat];\n+                        let repeat_expr = &self.body.exprs[repeat];\n                         consteval::eval_usize(repeat_expr)\n                     }\n                 };\n \n-                TyKind::Array(elem_ty, consteval::usize_const(len)).intern(&Interner)\n+                TyKind::Array(coerce.complete(), consteval::usize_const(len)).intern(&Interner)\n             }\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n@@ -872,9 +870,7 @@ impl<'a> InferenceContext<'a> {\n                 self.table.new_maybe_never_var()\n             } else {\n                 if let Some(t) = expected.only_has_type(&mut self.table) {\n-                    if let Ok(ok) = self.coerce(&TyBuilder::unit(), &t) {\n-                        self.write_expr_adj(expr, ok.value.0);\n-                    }\n+                    let _ = self.coerce(Some(expr), &TyBuilder::unit(), &t);\n                 }\n                 TyBuilder::unit()\n             }"}]}