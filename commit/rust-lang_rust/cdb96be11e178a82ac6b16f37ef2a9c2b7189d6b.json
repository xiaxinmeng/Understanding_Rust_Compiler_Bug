{"sha": "cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjk2YmUxMWUxNzhhODJhYzZiMTZmMzdlZjJhOWMyYjcxODlkNmI=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-02T18:46:30Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-24T00:24:40Z"}, "message": "Handle placeholder types in canonicalization", "tree": {"sha": "1ee4392f1b3a909c419d4308e31732e71e27072d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee4392f1b3a909c419d4308e31732e71e27072d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "html_url": "https://github.com/rust-lang/rust/commit/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91623ca6405b5e3c7736bcacb244718906d4aa69", "url": "https://api.github.com/repos/rust-lang/rust/commits/91623ca6405b5e3c7736bcacb244718906d4aa69", "html_url": "https://github.com/rust-lang/rust/commit/91623ca6405b5e3c7736bcacb244718906d4aa69"}], "stats": {"total": 106, "additions": 85, "deletions": 21}, "files": [{"sha": "e9fac5b923961da4d4f60f1db1737d623736d742", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "patch": "@@ -1099,12 +1099,13 @@ impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n \n impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n     Ty(k),\n+    PlaceholderTy(placeholder),\n     Region(ui),\n     PlaceholderRegion(placeholder),\n });\n \n impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n-    General,\n+    General(ui),\n     Int,\n     Float\n });"}, {"sha": "7a9527573c7d69aa33ceeaf3b119bafb1a6c5da4", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "patch": "@@ -339,18 +339,49 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::Infer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+            ty::Infer(ty::TyVar(vid)) => {\n+                match self.infcx.unwrap().probe_ty_var(vid) {\n+                    // `t` could be a float / int variable: canonicalize that instead\n+                    Ok(t) => self.fold_ty(t),\n+\n+                    // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n+                    // result\n+                    Err(ui) => self.canonicalize_ty_var(\n+                        CanonicalVarInfo {\n+                            kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui))\n+                        },\n+                        t\n+                    )\n+                }\n+            }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n+                CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                },\n+                t\n+            ),\n \n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n+                CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float)\n+                },\n+                t\n+            ),\n \n             ty::Infer(ty::FreshTy(_))\n             | ty::Infer(ty::FreshIntTy(_))\n             | ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n+            ty::Placeholder(placeholder) => self.canonicalize_ty_var(\n+                CanonicalVarInfo {\n+                    kind: CanonicalVarKind::PlaceholderTy(placeholder)\n+                },\n+                t\n+            ),\n+\n             ty::Bound(bound_ty) => {\n                 if bound_ty.index >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n@@ -380,7 +411,6 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::Projection(..)\n-            | ty::Placeholder(..)\n             | ty::UnnormalizedProjection(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n@@ -579,15 +609,12 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     /// if `ty_var` is bound to anything; if so, canonicalize\n     /// *that*. Otherwise, create a new canonical variable for\n     /// `ty_var`.\n-    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+    fn canonicalize_ty_var(&mut self, info: CanonicalVarInfo, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n         let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n         let bound_to = infcx.shallow_resolve(ty_var);\n         if bound_to != ty_var {\n             self.fold_ty(bound_to)\n         } else {\n-            let info = CanonicalVarInfo {\n-                kind: CanonicalVarKind::Ty(ty_kind),\n-            };\n             let var = self.canonical_var(info, ty_var.into());\n             self.tcx().mk_ty(ty::Bound(BoundTy::new(self.binder_index, var)))\n         }"}, {"sha": "230f8958b33851f81326e8cf01c2a10ad567551b", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "patch": "@@ -122,6 +122,7 @@ impl CanonicalVarInfo {\n     pub fn is_existential(&self) -> bool {\n         match self.kind {\n             CanonicalVarKind::Ty(_) => true,\n+            CanonicalVarKind::PlaceholderTy(_) => false,\n             CanonicalVarKind::Region(_) => true,\n             CanonicalVarKind::PlaceholderRegion(..) => false,\n         }\n@@ -136,6 +137,9 @@ pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n \n+    /// A \"placeholder\" that represents \"any type\".\n+    PlaceholderTy(ty::PlaceholderType),\n+\n     /// Region variable `'?R`.\n     Region(ty::UniverseIndex),\n \n@@ -148,12 +152,12 @@ pub enum CanonicalVarKind {\n impl CanonicalVarKind {\n     pub fn universe(self) -> ty::UniverseIndex {\n         match self {\n-            // At present, we don't support higher-ranked\n-            // quantification over types, so all type variables are in\n-            // the root universe.\n-            CanonicalVarKind::Ty(_) => ty::UniverseIndex::ROOT,\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(ui) => ui,\n+                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n+            }\n \n-            // Region variables can be created in sub-universes.\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n             CanonicalVarKind::Region(ui) => ui,\n             CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n         }\n@@ -168,7 +172,7 @@ impl CanonicalVarKind {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n-    General,\n+    General(ty::UniverseIndex),\n \n     /// Integral type variable `?I` (that can only be unified with integral types).\n     Int,\n@@ -358,8 +362,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         match cv_info.kind {\n             CanonicalVarKind::Ty(ty_kind) => {\n                 let ty = match ty_kind {\n-                    CanonicalTyVarKind::General => {\n-                        self.next_ty_var(TypeVariableOrigin::MiscVariable(span))\n+                    CanonicalTyVarKind::General(ui) => {\n+                        self.next_ty_var_in_universe(\n+                            TypeVariableOrigin::MiscVariable(span),\n+                            universe_map(ui)\n+                        )\n                     }\n \n                     CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n@@ -369,6 +376,15 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 ty.into()\n             }\n \n+            CanonicalVarKind::PlaceholderTy(ty::PlaceholderType { universe, name }) => {\n+                let universe_mapped = universe_map(universe);\n+                let placeholder_mapped = ty::PlaceholderType {\n+                    universe: universe_mapped,\n+                    name,\n+                };\n+                self.tcx.mk_ty(ty::Placeholder(placeholder_mapped)).into()\n+            }\n+\n             CanonicalVarKind::Region(ui) => self.next_region_var_in_universe(\n                 RegionVariableOrigin::MiscVariable(span),\n                 universe_map(ui),\n@@ -380,9 +396,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     universe: universe_mapped,\n                     name,\n                 };\n-                self.tcx\n-                    .mk_region(ty::RePlaceholder(placeholder_mapped))\n-                    .into()\n+                self.tcx.mk_region(ty::RePlaceholder(placeholder_mapped)).into()\n             }\n         }\n     }"}, {"sha": "6f041fdfb0ac4a86e923d52d83085b2ac1475840", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "patch": "@@ -972,6 +972,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n+    pub fn next_ty_var_in_universe(\n+        &self,\n+        origin: TypeVariableOrigin,\n+        universe: ty::UniverseIndex\n+    ) -> Ty<'tcx> {\n+        let vid = self.type_variables\n+            .borrow_mut()\n+            .new_var(universe, false, origin);\n+        self.tcx.mk_var(vid)\n+    }\n+\n     pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n@@ -1227,6 +1238,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n+    /// universe index of `TyVar(vid)`.\n+    pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n+        use self::type_variable::TypeVariableValue;\n+\n+        match self.type_variables.borrow_mut().probe(vid) {\n+            TypeVariableValue::Known { value } => Ok(value),\n+            TypeVariableValue::Unknown { universe } => Err(universe),\n+        }\n+    }\n+\n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }"}, {"sha": "5624961ea6e67a23dcf7aa23b22e881e5b3b31e6", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=cdb96be11e178a82ac6b16f37ef2a9c2b7189d6b", "patch": "@@ -72,7 +72,7 @@ pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n \n struct TypeVariableData {\n     origin: TypeVariableOrigin,\n-    diverging: bool\n+    diverging: bool,\n }\n \n #[derive(Copy, Clone, Debug)]"}]}