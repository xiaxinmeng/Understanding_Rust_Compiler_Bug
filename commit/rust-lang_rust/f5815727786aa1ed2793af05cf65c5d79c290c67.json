{"sha": "f5815727786aa1ed2793af05cf65c5d79c290c67", "node_id": "C_kwDOAAsO6NoAKGY1ODE1NzI3Nzg2YWExZWQyNzkzYWYwNWNmNjVjNWQ3OWMyOTBjNjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-04T02:53:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-04T02:53:54Z"}, "message": "Auto merge of #91505 - matthiaskrgr:rollup-orxgsxo, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90538 (Document how recursion is handled for `ty::Ty`)\n - #90851 (Add unchecked downcast methods)\n - #91209 (Implement ``@snapshot`` check for htmldocck)\n - #91385 (Suggest the `pat_param` specifier before `|` on 2021 edition )\n - #91478 (Remove incorrect newline from float cast suggestion)\n - #91481 (Use let_else in some more places in rustc_lint)\n - #91488 (Fix ICE when `yield`ing in function returning `impl Trait`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5c31934526b8f1a635e3212d45937ddffef49d10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c31934526b8f1a635e3212d45937ddffef49d10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5815727786aa1ed2793af05cf65c5d79c290c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5815727786aa1ed2793af05cf65c5d79c290c67", "html_url": "https://github.com/rust-lang/rust/commit/f5815727786aa1ed2793af05cf65c5d79c290c67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5815727786aa1ed2793af05cf65c5d79c290c67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c1e71d095a5500def51d4e405bd2b0010f3d37", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c1e71d095a5500def51d4e405bd2b0010f3d37", "html_url": "https://github.com/rust-lang/rust/commit/14c1e71d095a5500def51d4e405bd2b0010f3d37"}, {"sha": "df51bffe6bef0c15f6e29a15ea54f269b251e179", "url": "https://api.github.com/repos/rust-lang/rust/commits/df51bffe6bef0c15f6e29a15ea54f269b251e179", "html_url": "https://github.com/rust-lang/rust/commit/df51bffe6bef0c15f6e29a15ea54f269b251e179"}], "stats": {"total": 676, "additions": 530, "deletions": 146}, "files": [{"sha": "bc740de5150659cc48f1954c0a17b8036fec98a9", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -117,9 +117,29 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         }\n \n-        assert!(body.yield_ty().is_some() == universal_regions.yield_ty.is_some());\n-        if let Some(mir_yield_ty) = body.yield_ty() {\n-            let ur_yield_ty = universal_regions.yield_ty.unwrap();\n+        debug!(\n+            \"equate_inputs_and_outputs: body.yield_ty {:?}, universal_regions.yield_ty {:?}\",\n+            body.yield_ty(),\n+            universal_regions.yield_ty\n+        );\n+\n+        // We will not have a universal_regions.yield_ty if we yield (by accident)\n+        // outside of a generator and return an `impl Trait`, so emit a delay_span_bug\n+        // because we don't want to panic in an assert here if we've already got errors.\n+        if body.yield_ty().is_some() != universal_regions.yield_ty.is_some() {\n+            self.tcx().sess.delay_span_bug(\n+                body.span,\n+                &format!(\n+                    \"Expected body to have yield_ty ({:?}) iff we have a UR yield_ty ({:?})\",\n+                    body.yield_ty(),\n+                    universal_regions.yield_ty,\n+                ),\n+            );\n+        }\n+\n+        if let (Some(mir_yield_ty), Some(ur_yield_ty)) =\n+            (body.yield_ty(), universal_regions.yield_ty)\n+        {\n             let yield_span = body.local_decls[RETURN_PLACE].source_info.span;\n             self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty, yield_span);\n         }"}, {"sha": "537a10e98e59de2dcf0c11c0beac366c47de7511", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1027,6 +1027,24 @@ fn check_matcher_core(\n                                 ),\n                             );\n                             err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n+\n+                            if kind == NonterminalKind::PatWithOr\n+                                && sess.edition == Edition::Edition2021\n+                                && next_token.is_token(&BinOp(token::BinOpToken::Or))\n+                            {\n+                                let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl(\n+                                    span,\n+                                    name,\n+                                    Some(NonterminalKind::PatParam { inferred: false }),\n+                                ));\n+                                err.span_suggestion(\n+                                    span,\n+                                    &format!(\"try a `pat_param` fragment specifier instead\"),\n+                                    suggestion,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+\n                             let msg = \"allowed there are: \";\n                             match possible {\n                                 &[] => {}"}, {"sha": "4a24f803e8463b2c15bb765e54661389050539ad", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -79,9 +79,8 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             let receiver_ty = cx.typeck_results().expr_ty(receiver_arg);\n             let adjustments = cx.typeck_results().expr_adjustments(receiver_arg);\n \n-            let target = match adjustments.last() {\n-                Some(Adjustment { kind: Adjust::Borrow(_), target }) => target,\n-                _ => return,\n+            let Some(Adjustment { kind: Adjust::Borrow(_), target }) = adjustments.last() else {\n+                return\n             };\n \n             let types ="}, {"sha": "5dbcc1655c906f354b4046f0cbed2195ab663a38", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -609,14 +609,12 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n-                if let Some(def_id) = real_trait.as_local() {\n-                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n-                        if let hir::VisibilityKind::Inherited = item.vis.node {\n-                            for impl_item_ref in items {\n-                                self.private_traits.insert(impl_item_ref.id.hir_id());\n-                            }\n-                        }\n+                let Some(def_id) = real_trait.as_local() else { return };\n+                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+                let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) else { return };\n+                if let hir::VisibilityKind::Inherited = item.vis.node {\n+                    for impl_item_ref in items {\n+                        self.private_traits.insert(impl_item_ref.id.hir_id());\n                     }\n                 }\n                 return;\n@@ -829,9 +827,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             _ => return,\n         }\n \n-        let debug = match cx.tcx.get_diagnostic_item(sym::Debug) {\n-            Some(debug) => debug,\n-            None => return,\n+        let Some(debug) = cx.tcx.get_diagnostic_item(sym::Debug) else {\n+            return\n         };\n \n         if self.impling_types.is_none() {\n@@ -1509,9 +1506,8 @@ impl TypeAliasBounds {\n \n impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        let (ty, type_alias_generics) = match item.kind {\n-            hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n-            _ => return,\n+        let hir::ItemKind::TyAlias(ty, type_alias_generics) = &item.kind else {\n+            return\n         };\n         if let hir::TyKind::OpaqueDef(..) = ty.kind {\n             // Bounds are respected for `type X = impl Trait`\n@@ -2266,16 +2262,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                         // and should check for them here.\n                         match predicate.bounded_ty.kind {\n                             hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                if let Res::Def(DefKind::TyParam, def_id) = path.res {\n-                                    let index = ty_generics.param_def_id_to_index[&def_id];\n-                                    (\n-                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n-                                        &predicate.bounds,\n-                                        predicate.span,\n-                                    )\n-                                } else {\n-                                    continue;\n-                                }\n+                                let Res::Def(DefKind::TyParam, def_id) = path.res else {\n+                                    continue\n+                                };\n+                                let index = ty_generics.param_def_id_to_index[&def_id];\n+                                (\n+                                    Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                    &predicate.bounds,\n+                                    predicate.span,\n+                                )\n                             }\n                             _ => {\n                                 continue;\n@@ -3216,18 +3211,17 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                     for (idx, _) in statement.match_indices(':') {\n                         let possible_label = statement[start_idx..idx].trim();\n                         let mut chars = possible_label.chars();\n-                        if let Some(c) = chars.next() {\n-                            // A label starts with an alphabetic character or . or _ and continues with alphanumeric characters, _, or $\n-                            if (c.is_alphabetic() || matches!(c, '.' | '_'))\n-                                && chars.all(|c| c.is_alphanumeric() || matches!(c, '_' | '$'))\n-                            {\n-                                found_labels.push(possible_label);\n-                            } else {\n-                                // If we encounter a non-label, there cannot be any further labels, so stop checking\n-                                break;\n-                            }\n-                        } else {\n+                        let Some(c) = chars.next() else {\n                             // Empty string means a leading ':' in this section, which is not a label\n+                            break\n+                        };\n+                        // A label starts with an alphabetic character or . or _ and continues with alphanumeric characters, _, or $\n+                        if (c.is_alphabetic() || matches!(c, '.' | '_'))\n+                            && chars.all(|c| c.is_alphanumeric() || matches!(c, '_' | '$'))\n+                        {\n+                            found_labels.push(possible_label);\n+                        } else {\n+                            // If we encounter a non-label, there cannot be any further labels, so stop checking\n                             break;\n                         }\n "}, {"sha": "485728cbfd39d3e0ff85141702d6d0aae1d8dcc9", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -227,14 +227,12 @@ impl<'s> LintLevelsBuilder<'s> {\n         let sess = self.sess;\n         let bad_attr = |span| struct_span_err!(sess, span, E0452, \"malformed lint attribute input\");\n         for attr in attrs {\n-            let level = match Level::from_symbol(attr.name_or_empty()) {\n-                None => continue,\n-                Some(lvl) => lvl,\n+            let Some(level) = Level::from_symbol(attr.name_or_empty()) else {\n+                continue\n             };\n \n-            let mut metas = match attr.meta_item_list() {\n-                Some(x) => x,\n-                None => continue,\n+            let Some(mut metas) = attr.meta_item_list() else {\n+                continue\n             };\n \n             if metas.is_empty() {\n@@ -481,9 +479,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                     continue;\n                 }\n \n-                let (lint_attr_name, lint_attr_span) = match *src {\n-                    LintLevelSource::Node(name, span, _) => (name, span),\n-                    _ => continue,\n+                let LintLevelSource::Node(lint_attr_name, lint_attr_span, _) = *src else {\n+                    continue\n                 };\n \n                 let lint = builtin::UNUSED_ATTRIBUTES;"}, {"sha": "600504f7c1280973c018386ecc2afacba0fb2fbc", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -40,9 +40,8 @@ declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // We only care about method calls.\n-        let (call, elements) = match expr.kind {\n-            ExprKind::MethodCall(call, _, elements, _) => (call, elements),\n-            _ => return,\n+        let ExprKind::MethodCall(call, _, elements, _) = &expr.kind else {\n+            return\n         };\n         // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`\n         // traits and ignore any other method call.\n@@ -70,9 +69,8 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let param_env = cx.tcx.param_env(trait_id);\n         // Resolve the trait method instance.\n-        let i = match ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n-            Ok(Some(i)) => i,\n-            _ => return,\n+        let Ok(Some(i)) = ty::Instance::resolve(cx.tcx, param_env, did, substs) else {\n+            return\n         };\n         // (Re)check that it implements the noop diagnostic.\n         let Some(name) = cx.tcx.get_diagnostic_name(i.def_id()) else { return };"}, {"sha": "dafff640b36ef3d1bee3d26eb87e14931807e1ed", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -91,9 +91,8 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n \n         let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n         for &(predicate, span) in predicates.predicates {\n-            let trait_predicate = match predicate.kind().skip_binder() {\n-                Trait(trait_predicate) => trait_predicate,\n-                _ => continue,\n+            let Trait(trait_predicate) = predicate.kind().skip_binder() else {\n+                continue\n             };\n             if trait_predicate.constness == ty::BoundConstness::ConstIfConst {\n                 // `~const Drop` definitely have meanings so avoid linting here.\n@@ -106,9 +105,8 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                     continue;\n                 }\n                 cx.struct_span_lint(DROP_BOUNDS, span, |lint| {\n-                    let needs_drop = match cx.tcx.get_diagnostic_item(sym::needs_drop) {\n-                        Some(needs_drop) => needs_drop,\n-                        None => return,\n+                    let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                        return\n                     };\n                     let msg = format!(\n                         \"bounds on `{}` are most likely incorrect, consider instead \\\n@@ -123,17 +121,15 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx hir::Ty<'tcx>) {\n-        let bounds = match &ty.kind {\n-            hir::TyKind::TraitObject(bounds, _lifetime, _syntax) => bounds,\n-            _ => return,\n+        let hir::TyKind::TraitObject(bounds, _lifetime, _syntax) = &ty.kind else {\n+            return\n         };\n         for bound in &bounds[..] {\n             let def_id = bound.trait_ref.trait_def_id();\n             if cx.tcx.lang_items().drop_trait() == def_id {\n                 cx.struct_span_lint(DYN_DROP, bound.span, |lint| {\n-                    let needs_drop = match cx.tcx.get_diagnostic_item(sym::needs_drop) {\n-                        Some(needs_drop) => needs_drop,\n-                        None => return,\n+                    let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                        return\n                     };\n                     let msg = format!(\n                         \"types that do not implement `Drop` can still have drop glue, consider \\"}, {"sha": "32ed6dad7f8c349b5f411924759610e540b26a6c", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1342,11 +1342,10 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                     | ty::layout::LayoutError::NormalizationFailure(_, _),\n                 ) => return,\n             };\n-            let (variants, tag) = match layout.variants {\n-                Variants::Multiple {\n+            let Variants::Multiple {\n                     tag_encoding: TagEncoding::Direct, tag, ref variants, ..\n-                } => (variants, tag),\n-                _ => return,\n+                } = &layout.variants else {\n+                return\n             };\n \n             let tag_size = tag.value.size(&cx.tcx).bytes();"}, {"sha": "771ce2eb884afbf7e91f0647de6eb67bf8de2435", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -64,6 +64,30 @@ bitflags! {\n /// Moreover, Rust only allows recursive data types through indirection.\n ///\n /// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+///\n+/// # Recursive types\n+///\n+/// It may seem impossible to represent recursive types using [`Ty`],\n+/// since [`TyKind::Adt`] includes [`AdtDef`], which includes its fields,\n+/// creating a cycle. However, `AdtDef` does not actually include the *types*\n+/// of its fields; it includes just their [`DefId`]s.\n+///\n+/// [`TyKind::Adt`]: ty::TyKind::Adt\n+///\n+/// For example, the following type:\n+///\n+/// ```\n+/// struct S { x: Box<S> }\n+/// ```\n+///\n+/// is essentially represented with [`Ty`] as the following pseudocode:\n+///\n+/// ```\n+/// struct S { x }\n+/// ```\n+///\n+/// where `x` here represents the `DefId` of `S.x`. Then, the `DefId`\n+/// can be used with [`TyCtxt::type_of()`] to get the type of the field.\n pub struct AdtDef {\n     /// The `DefId` of the struct, enum or union item.\n     pub did: DefId,"}, {"sha": "7e1804673df2ce479bcf04075448db20dbcd9081", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1711,7 +1711,7 @@ impl ReprOptions {\n \n impl<'tcx> FieldDef {\n     /// Returns the type of this field. The resulting type is not normalized. The `subst` is\n-    /// typically obtained via the second field of `TyKind::AdtDef`.\n+    /// typically obtained via the second field of [`TyKind::Adt`].\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }"}, {"sha": "b210c78cae007989d7ea08f895bebc42dab1da13", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1223,7 +1223,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Missing try_into implementation for `{integer}` to `{float}`\n                     err.multipart_suggestion_verbose(\n                         &format!(\n-                            \"{}, producing the floating point representation of the integer,\n+                            \"{}, producing the floating point representation of the integer, \\\n                                  rounded if necessary\",\n                             cast_msg,\n                         ),"}, {"sha": "ab41f5646e5e50d3015c61bd796b59af69f2c7dc", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 109, "deletions": 28, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1518,8 +1518,6 @@ impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]> {\n }\n \n impl<A: Allocator> Box<dyn Any, A> {\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n     ///\n     /// # Examples\n@@ -1537,21 +1535,48 @@ impl<A: Allocator> Box<dyn Any, A> {\n     /// print_if_string(Box::new(my_string));\n     /// print_if_string(Box::new(0i8));\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n-        if self.is::<T>() {\n-            unsafe {\n-                let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_allocator(self);\n-                Ok(Box::from_raw_in(raw as *mut T, alloc))\n-            }\n-        } else {\n-            Err(self)\n+        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n+    }\n+\n+    /// Downcasts the box to a concrete type.\n+    ///\n+    /// For a safe alternative see [`downcast`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    ///\n+    /// [`downcast`]: Self::downcast\n+    #[inline]\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n+        debug_assert!(self.is::<T>());\n+        unsafe {\n+            let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_allocator(self);\n+            Box::from_raw_in(raw as *mut T, alloc)\n         }\n     }\n }\n \n impl<A: Allocator> Box<dyn Any + Send, A> {\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n     ///\n     /// # Examples\n@@ -1569,21 +1594,48 @@ impl<A: Allocator> Box<dyn Any + Send, A> {\n     /// print_if_string(Box::new(my_string));\n     /// print_if_string(Box::new(0i8));\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n-        if self.is::<T>() {\n-            unsafe {\n-                let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);\n-                Ok(Box::from_raw_in(raw as *mut T, alloc))\n-            }\n-        } else {\n-            Err(self)\n+        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n+    }\n+\n+    /// Downcasts the box to a concrete type.\n+    ///\n+    /// For a safe alternative see [`downcast`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any + Send> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    ///\n+    /// [`downcast`]: Self::downcast\n+    #[inline]\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n+        debug_assert!(self.is::<T>());\n+        unsafe {\n+            let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);\n+            Box::from_raw_in(raw as *mut T, alloc)\n         }\n     }\n }\n \n impl<A: Allocator> Box<dyn Any + Send + Sync, A> {\n-    #[inline]\n-    #[stable(feature = \"box_send_sync_any_downcast\", since = \"1.51.0\")]\n     /// Attempt to downcast the box to a concrete type.\n     ///\n     /// # Examples\n@@ -1601,15 +1653,44 @@ impl<A: Allocator> Box<dyn Any + Send + Sync, A> {\n     /// print_if_string(Box::new(my_string));\n     /// print_if_string(Box::new(0i8));\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"box_send_sync_any_downcast\", since = \"1.51.0\")]\n     pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n-        if self.is::<T>() {\n-            unsafe {\n-                let (raw, alloc): (*mut (dyn Any + Send + Sync), _) =\n-                    Box::into_raw_with_allocator(self);\n-                Ok(Box::from_raw_in(raw as *mut T, alloc))\n-            }\n-        } else {\n-            Err(self)\n+        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n+    }\n+\n+    /// Downcasts the box to a concrete type.\n+    ///\n+    /// For a safe alternative see [`downcast`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any + Send + Sync> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    ///\n+    /// [`downcast`]: Self::downcast\n+    #[inline]\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n+        debug_assert!(self.is::<T>());\n+        unsafe {\n+            let (raw, alloc): (*mut (dyn Any + Send + Sync), _) =\n+                Box::into_raw_with_allocator(self);\n+            Box::from_raw_in(raw as *mut T, alloc)\n         }\n     }\n }"}, {"sha": "72528185707a67fec8cca43880bde8311444285e", "filename": "library/core/src/any.rs", "status": "modified", "additions": 166, "deletions": 8, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -164,7 +164,7 @@ impl fmt::Debug for dyn Any + Send + Sync {\n }\n \n impl dyn Any {\n-    /// Returns `true` if the boxed type is the same as `T`.\n+    /// Returns `true` if the inner type is the same as `T`.\n     ///\n     /// # Examples\n     ///\n@@ -195,7 +195,7 @@ impl dyn Any {\n         t == concrete\n     }\n \n-    /// Returns some reference to the boxed value if it is of type `T`, or\n+    /// Returns some reference to the inner value if it is of type `T`, or\n     /// `None` if it isn't.\n     ///\n     /// # Examples\n@@ -221,13 +221,13 @@ impl dyn Any {\n             // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n             // that check for memory safety because we have implemented Any for all types; no other\n             // impls can exist as they would conflict with our impl.\n-            unsafe { Some(&*(self as *const dyn Any as *const T)) }\n+            unsafe { Some(self.downcast_ref_unchecked()) }\n         } else {\n             None\n         }\n     }\n \n-    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n+    /// Returns some mutable reference to the inner value if it is of type `T`, or\n     /// `None` if it isn't.\n     ///\n     /// # Examples\n@@ -257,15 +257,73 @@ impl dyn Any {\n             // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n             // that check for memory safety because we have implemented Any for all types; no other\n             // impls can exist as they would conflict with our impl.\n-            unsafe { Some(&mut *(self as *mut dyn Any as *mut T)) }\n+            unsafe { Some(self.downcast_mut_unchecked()) }\n         } else {\n             None\n         }\n     }\n+\n+    /// Returns a reference to the inner value as type `dyn T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_ref_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {\n+        debug_assert!(self.is::<T>());\n+        // SAFETY: caller guarantees that T is the correct type\n+        unsafe { &*(self as *const dyn Any as *const T) }\n+    }\n+\n+    /// Returns a mutable reference to the inner value as type `dyn T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let mut x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     *x.downcast_mut_unchecked::<usize>() += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(*x.downcast_ref::<usize>().unwrap(), 2);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {\n+        debug_assert!(self.is::<T>());\n+        // SAFETY: caller guarantees that T is the correct type\n+        unsafe { &mut *(self as *mut dyn Any as *mut T) }\n+    }\n }\n \n impl dyn Any + Send {\n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Any`.\n     ///\n     /// # Examples\n     ///\n@@ -289,7 +347,7 @@ impl dyn Any + Send {\n         <dyn Any>::is::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Any`.\n     ///\n     /// # Examples\n     ///\n@@ -313,7 +371,7 @@ impl dyn Any + Send {\n         <dyn Any>::downcast_ref::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Any`.\n     ///\n     /// # Examples\n     ///\n@@ -340,6 +398,60 @@ impl dyn Any + Send {\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         <dyn Any>::downcast_mut::<T>(self)\n     }\n+\n+    /// Forwards to the method defined on the type `dyn Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_ref_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// Same as the method on the type `dyn Any`.\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {\n+        // SAFETY: guaranteed by caller\n+        unsafe { <dyn Any>::downcast_ref_unchecked::<T>(self) }\n+    }\n+\n+    /// Forwards to the method defined on the type `dyn Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let mut x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     *x.downcast_mut_unchecked::<usize>() += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(*x.downcast_ref::<usize>().unwrap(), 2);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// Same as the method on the type `dyn Any`.\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {\n+        // SAFETY: guaranteed by caller\n+        unsafe { <dyn Any>::downcast_mut_unchecked::<T>(self) }\n+    }\n }\n \n impl dyn Any + Send + Sync {\n@@ -418,6 +530,52 @@ impl dyn Any + Send + Sync {\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         <dyn Any>::downcast_mut::<T>(self)\n     }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_ref_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_ref_unchecked<T: Any>(&self) -> &T {\n+        // SAFETY: guaranteed by caller\n+        unsafe { <dyn Any>::downcast_ref_unchecked::<T>(self) }\n+    }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    ///\n+    /// let mut x: Box<dyn Any> = Box::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     *x.downcast_mut_unchecked::<usize>() += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(*x.downcast_ref::<usize>().unwrap(), 2);\n+    /// ```\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    #[inline]\n+    pub unsafe fn downcast_mut_unchecked<T: Any>(&mut self) -> &mut T {\n+        // SAFETY: guaranteed by caller\n+        unsafe { <dyn Any>::downcast_mut_unchecked::<T>(self) }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////"}, {"sha": "48a341ffe083710770023c465dfe4b5d03a2b40c", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -90,10 +90,20 @@\n   highlights for example. If you want to simply check for the presence of\n   a given node or attribute, use an empty string (`\"\"`) as a `PATTERN`.\n \n-* `@count PATH XPATH COUNT' checks for the occurrence of the given XPath\n+* `@count PATH XPATH COUNT` checks for the occurrence of the given XPath\n   in the specified file. The number of occurrences must match the given\n   count.\n \n+* `@snapshot NAME PATH XPATH` creates a snapshot test named NAME.\n+  A snapshot test captures a subtree of the DOM, at the location\n+  determined by the XPath, and compares it to a pre-recorded value\n+  in a file. The file's name is the test's name with the `.rs` extension\n+  replaced with `.NAME.html`, where NAME is the snapshot's name.\n+\n+  htmldocck supports the `--bless` option to accept the current subtree\n+  as expected, saving it to the file determined by the snapshot's name.\n+  compiletest's `--bless` flag is forwarded to htmldocck.\n+\n * `@has-dir PATH` checks for the existence of the given directory.\n \n All conditions can be negated with `!`. `@!has foo/type.NoSuch.html`\n@@ -137,6 +147,10 @@\n \n channel = os.environ[\"DOC_RUST_LANG_ORG_CHANNEL\"]\n \n+# Initialized in main\n+rust_test_path = None\n+bless = None\n+\n class CustomHTMLParser(HTMLParser):\n     \"\"\"simplified HTML parser.\n \n@@ -387,6 +401,32 @@ def get_tree_count(tree, path):\n     return len(tree.findall(path))\n \n \n+def check_snapshot(snapshot_name, tree):\n+    assert rust_test_path.endswith('.rs')\n+    snapshot_path = '{}.{}.{}'.format(rust_test_path[:-3], snapshot_name, 'html')\n+    try:\n+        with open(snapshot_path, 'r') as snapshot_file:\n+            expected_str = snapshot_file.read()\n+    except FileNotFoundError:\n+        if bless:\n+            expected_str = None\n+        else:\n+            raise FailedCheck('No saved snapshot value')\n+\n+    actual_str = ET.tostring(tree).decode('utf-8')\n+\n+    if expected_str != actual_str:\n+        if bless:\n+            with open(snapshot_path, 'w') as snapshot_file:\n+                snapshot_file.write(actual_str)\n+        else:\n+            print('--- expected ---\\n')\n+            print(expected_str)\n+            print('\\n\\n--- actual ---\\n')\n+            print(actual_str)\n+            print()\n+            raise FailedCheck('Actual snapshot value is different than expected')\n+\n def stderr(*args):\n     if sys.version_info.major < 3:\n         file = codecs.getwriter('utf-8')(sys.stderr)\n@@ -448,6 +488,28 @@ def check_command(c, cache):\n                 ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n+\n+        elif c.cmd == 'snapshot':  # snapshot test\n+            if len(c.args) == 3:  # @snapshot <snapshot-name> <html-path> <xpath>\n+                [snapshot_name, html_path, pattern] = c.args\n+                tree = cache.get_tree(html_path)\n+                xpath = normalize_xpath(pattern)\n+                subtrees = tree.findall(xpath)\n+                if len(subtrees) == 1:\n+                    [subtree] = subtrees\n+                    try:\n+                        check_snapshot(snapshot_name, subtree)\n+                        ret = True\n+                    except FailedCheck as err:\n+                        cerr = str(err)\n+                        ret = False\n+                elif len(subtrees) == 0:\n+                    raise FailedCheck('XPATH did not match')\n+                else:\n+                    raise FailedCheck('Expected 1 match, but found {}'.format(len(subtrees)))\n+            else:\n+                raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n+\n         elif c.cmd == 'has-dir':  # has-dir test\n             if len(c.args) == 1:  # @has-dir <path> = has-dir test\n                 try:\n@@ -458,11 +520,13 @@ def check_command(c, cache):\n                     ret = False\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n+\n         elif c.cmd == 'valid-html':\n             raise InvalidCheck('Unimplemented @valid-html')\n \n         elif c.cmd == 'valid-links':\n             raise InvalidCheck('Unimplemented @valid-links')\n+\n         else:\n             raise InvalidCheck('Unrecognized @{}'.format(c.cmd))\n \n@@ -483,11 +547,19 @@ def check(target, commands):\n \n \n if __name__ == '__main__':\n-    if len(sys.argv) != 3:\n-        stderr('Usage: {} <doc dir> <template>'.format(sys.argv[0]))\n+    if len(sys.argv) not in [3, 4]:\n+        stderr('Usage: {} <doc dir> <template> [--bless]'.format(sys.argv[0]))\n         raise SystemExit(1)\n \n-    check(sys.argv[1], get_commands(sys.argv[2]))\n+    rust_test_path = sys.argv[2]\n+    if len(sys.argv) > 3 and sys.argv[3] == '--bless':\n+        bless = True\n+    else:\n+        # We only support `--bless` at the end of the arguments.\n+        # This assert is to prevent silent failures.\n+        assert '--bless' not in sys.argv\n+        bless = False\n+    check(sys.argv[1], get_commands(rust_test_path))\n     if ERR_COUNT:\n         stderr(\"\\nEncountered {} errors\".format(ERR_COUNT))\n         raise SystemExit(1)"}, {"sha": "69d647a92e82b30090fe9328bf6a11232ea7edba", "filename": "src/test/rustdoc/mixing-doc-comments-and-attrs.S1_top-doc.html", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S1_top-doc.html", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S1_top-doc.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S1_top-doc.html?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -0,0 +1,4 @@\n+<div class=\"docblock\"><p>Hello world!\n+Goodbye!\n+Hello again!</p>\n+</div>\n\\ No newline at end of file"}, {"sha": "8ff114b993edbeb5cd285e76fbfc09c050137d96", "filename": "src/test/rustdoc/mixing-doc-comments-and-attrs.S2_top-doc.html", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S2_top-doc.html", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S2_top-doc.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.S2_top-doc.html?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -0,0 +1,4 @@\n+<div class=\"docblock\"><p>Hello world!</p>\n+<p>Goodbye!\n+Hello again!</p>\n+</div>\n\\ No newline at end of file"}, {"sha": "1aedd4d107c21ef3d972678088ef5a042a0c624f", "filename": "src/test/rustdoc/mixing-doc-comments-and-attrs.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmixing-doc-comments-and-attrs.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -1,23 +1,15 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.S1.html'\n-// @count - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]/p' \\\n-//     1\n-// @has - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]/p[1]' \\\n-//     'Hello world! Goodbye! Hello again!'\n+// @snapshot S1_top-doc - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]'\n \n #[doc = \"Hello world!\\n\\n\"]\n /// Goodbye!\n #[doc = \"  Hello again!\\n\"]\n pub struct S1;\n \n // @has 'foo/struct.S2.html'\n-// @count - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]/p' \\\n-//     2\n-// @has - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]/p[1]' \\\n-//     'Hello world!'\n-// @has - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]/p[2]' \\\n-//     'Goodbye! Hello again!'\n+// @snapshot S2_top-doc - '//details[@class=\"rustdoc-toggle top-doc\"]/div[@class=\"docblock\"]'\n \n /// Hello world!\n ///"}, {"sha": "6c027feb422d17f418c18f5bcd1a56408feff6e0", "filename": "src/test/ui/generator/issue-91477.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -0,0 +1,7 @@\n+#![feature(generators)]\n+\n+fn foo() -> impl Sized {\n+    yield 1; //~ ERROR E0627\n+}\n+\n+fn main() {}"}, {"sha": "4597dc1bcdfa55142f49d63af5bae2442f2d9a04", "filename": "src/test/ui/generator/issue-91477.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-91477.stderr?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -0,0 +1,9 @@\n+error[E0627]: yield expression outside of generator literal\n+  --> $DIR/issue-91477.rs:4:5\n+   |\n+LL |     yield 1;\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0627`."}, {"sha": "a06487be3d601bfcc8f06ef6ace38bae47b19594", "filename": "src/test/ui/macros/macro-pat-pattern-followed-by-or-in-2021.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-pattern-followed-by-or-in-2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-pattern-followed-by-or-in-2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat-pattern-followed-by-or-in-2021.stderr?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -2,23 +2,29 @@ error: `$x:pat` is followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat-pattern-followed-by-or-in-2021.rs:3:28\n    |\n LL | macro_rules! foo { ($x:pat | $y:pat) => {} }\n-   |                            ^ not allowed after `pat` fragments\n+   |                     ------ ^ not allowed after `pat` fragments\n+   |                     |\n+   |                     help: try a `pat_param` fragment specifier instead: `$x:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n \n error: `$x:pat` is followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat-pattern-followed-by-or-in-2021.rs:4:32\n    |\n LL | macro_rules! bar { ($($x:pat)+ | $($y:pat)+) => {} }\n-   |                                ^ not allowed after `pat` fragments\n+   |                       ------   ^ not allowed after `pat` fragments\n+   |                       |\n+   |                       help: try a `pat_param` fragment specifier instead: `$x:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n \n error: `$pat:pat` may be followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat-pattern-followed-by-or-in-2021.rs:7:36\n    |\n LL |     ( $expr:expr , $( $( $pat:pat )|+ => $expr_arm:expr ),+ ) => {\n-   |                                    ^ not allowed after `pat` fragments\n+   |                          --------  ^ not allowed after `pat` fragments\n+   |                          |\n+   |                          help: try a `pat_param` fragment specifier instead: `$pat:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n "}, {"sha": "c3754dde080a39e3fe1acaebf653752226c791ec", "filename": "src/test/ui/macros/macro-pat2021-pattern-followed-by-or.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat2021-pattern-followed-by-or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat2021-pattern-followed-by-or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pat2021-pattern-followed-by-or.stderr?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -2,23 +2,29 @@ error: `$x:pat` is followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat2021-pattern-followed-by-or.rs:4:28\n    |\n LL | macro_rules! foo { ($x:pat | $y:pat) => {} }\n-   |                            ^ not allowed after `pat` fragments\n+   |                     ------ ^ not allowed after `pat` fragments\n+   |                     |\n+   |                     help: try a `pat_param` fragment specifier instead: `$x:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n \n error: `$x:pat` is followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat2021-pattern-followed-by-or.rs:7:28\n    |\n LL | macro_rules! ogg { ($x:pat | $y:pat_param) => {} }\n-   |                            ^ not allowed after `pat` fragments\n+   |                     ------ ^ not allowed after `pat` fragments\n+   |                     |\n+   |                     help: try a `pat_param` fragment specifier instead: `$x:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n \n error: `$pat:pat` may be followed by `|`, which is not allowed for `pat` fragments\n   --> $DIR/macro-pat2021-pattern-followed-by-or.rs:9:35\n    |\n LL |     ( $expr:expr , $( $( $pat:pat)|+ => $expr_arm:pat),+ ) => {\n-   |                                   ^ not allowed after `pat` fragments\n+   |                          -------- ^ not allowed after `pat` fragments\n+   |                          |\n+   |                          help: try a `pat_param` fragment specifier instead: `$pat:pat_param`\n    |\n    = note: allowed there are: `=>`, `,`, `=`, `if` or `in`\n "}, {"sha": "b8f2d88ab4957e9fb246700d708eab9f34528959", "filename": "src/test/ui/numeric/numeric-cast.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -994,8 +994,8 @@ error[E0308]: mismatched types\n LL |     foo::<f64>(x_usize);\n    |                ^^^^^^^ expected `f64`, found `usize`\n    |\n-help: you can cast a `usize` to an `f64`, producing the floating point representation of the integer,\n-   |                                              rounded if necessary\n+help: you can cast a `usize` to an `f64`, producing the floating point representation of the integer, rounded if necessary\n+   |\n LL |     foo::<f64>(x_usize as f64);\n    |                        ++++++\n \n@@ -1005,8 +1005,8 @@ error[E0308]: mismatched types\n LL |     foo::<f64>(x_u64);\n    |                ^^^^^ expected `f64`, found `u64`\n    |\n-help: you can cast a `u64` to an `f64`, producing the floating point representation of the integer,\n-   |                                              rounded if necessary\n+help: you can cast a `u64` to an `f64`, producing the floating point representation of the integer, rounded if necessary\n+   |\n LL |     foo::<f64>(x_u64 as f64);\n    |                      ++++++\n \n@@ -1115,8 +1115,8 @@ error[E0308]: mismatched types\n LL |     foo::<f32>(x_usize);\n    |                ^^^^^^^ expected `f32`, found `usize`\n    |\n-help: you can cast a `usize` to an `f32`, producing the floating point representation of the integer,\n-   |                                              rounded if necessary\n+help: you can cast a `usize` to an `f32`, producing the floating point representation of the integer, rounded if necessary\n+   |\n LL |     foo::<f32>(x_usize as f32);\n    |                        ++++++\n \n@@ -1126,8 +1126,8 @@ error[E0308]: mismatched types\n LL |     foo::<f32>(x_u64);\n    |                ^^^^^ expected `f32`, found `u64`\n    |\n-help: you can cast a `u64` to an `f32`, producing the floating point representation of the integer,\n-   |                                              rounded if necessary\n+help: you can cast a `u64` to an `f32`, producing the floating point representation of the integer, rounded if necessary\n+   |\n LL |     foo::<f32>(x_u64 as f32);\n    |                      ++++++\n \n@@ -1137,8 +1137,8 @@ error[E0308]: mismatched types\n LL |     foo::<f32>(x_u32);\n    |                ^^^^^ expected `f32`, found `u32`\n    |\n-help: you can cast a `u32` to an `f32`, producing the floating point representation of the integer,\n-   |                                              rounded if necessary\n+help: you can cast a `u32` to an `f32`, producing the floating point representation of the integer, rounded if necessary\n+   |\n LL |     foo::<f32>(x_u32 as f32);\n    |                      ++++++\n "}, {"sha": "4bf74c1508bd295882d648c39c8167ebd12987e1", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5815727786aa1ed2793af05cf65c5d79c290c67/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f5815727786aa1ed2793af05cf65c5d79c290c67", "patch": "@@ -2219,12 +2219,12 @@ impl<'test> TestCx<'test> {\n             self.check_rustdoc_test_option(proc_res);\n         } else {\n             let root = self.config.find_rust_src_root().unwrap();\n-            let res = self.cmd2procres(\n-                Command::new(&self.config.docck_python)\n-                    .arg(root.join(\"src/etc/htmldocck.py\"))\n-                    .arg(&out_dir)\n-                    .arg(&self.testpaths.file),\n-            );\n+            let mut cmd = Command::new(&self.config.docck_python);\n+            cmd.arg(root.join(\"src/etc/htmldocck.py\")).arg(&out_dir).arg(&self.testpaths.file);\n+            if self.config.bless {\n+                cmd.arg(\"--bless\");\n+            }\n+            let res = self.cmd2procres(&mut cmd);\n             if !res.status.success() {\n                 self.fatal_proc_rec_with_ctx(\"htmldocck failed!\", &res, |mut this| {\n                     this.compare_to_default_rustdoc(&out_dir)"}]}