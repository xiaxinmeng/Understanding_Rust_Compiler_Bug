{"sha": "db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNTYxNWRkZDVjMzE1YWYxMTViYmNjYTZhOWEwZDdhYzc5ZjYwODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-24T11:41:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-24T11:41:24Z"}, "message": "auto merge of #8725 : bblum/rust/docs, r=graydon\n\nThis documents how to use trait bounds in a (hopefully) user-friendly way, in the containers tutorial, and also documents the task watching implementation for runtime developers in kill.rs.\r\n\r\nr anybody", "tree": {"sha": "8e2b343c703c530bfe7cf2fd25fbbc4639f0259a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e2b343c703c530bfe7cf2fd25fbbc4639f0259a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "html_url": "https://github.com/rust-lang/rust/commit/db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db5615ddd5c315af115bbcca6a9a0d7ac79f6088/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "424e8f0fd55b94a45ebe112dc77312e3fab1ebfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/424e8f0fd55b94a45ebe112dc77312e3fab1ebfe", "html_url": "https://github.com/rust-lang/rust/commit/424e8f0fd55b94a45ebe112dc77312e3fab1ebfe"}, {"sha": "d468b7c0bfff9e805bd96daf21c1c5a023d12734", "url": "https://api.github.com/repos/rust-lang/rust/commits/d468b7c0bfff9e805bd96daf21c1c5a023d12734", "html_url": "https://github.com/rust-lang/rust/commit/d468b7c0bfff9e805bd96daf21c1c5a023d12734"}], "stats": {"total": 118, "additions": 116, "deletions": 2}, "files": [{"sha": "c8136605aaede98b561c71696ccd870c00e50cb5", "filename": "doc/tutorial.md", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/db5615ddd5c315af115bbcca6a9a0d7ac79f6088/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/db5615ddd5c315af115bbcca6a9a0d7ac79f6088/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "patch": "@@ -1864,7 +1864,7 @@ so you could not apply `head` to a type\n that does not implement `Clone`.\n \n While most traits can be defined and implemented by user code,\n-two traits are automatically derived and implemented\n+three traits are automatically derived and implemented\n for all applicable types by the compiler,\n and may not be overridden:\n \n@@ -1877,6 +1877,12 @@ These are types that do not contain anything intrinsically mutable.\n Intrinsically mutable values include `@mut`\n and `Cell` in the standard library.\n \n+* `'static` - Non-borrowed types.\n+These are types that do not contain any data whose lifetime is bound to\n+a particular stack frame. These are types that do not contain any\n+borrowed pointers, or types where the only contained borrowed pointers\n+have the `'static` lifetime.\n+\n > ***Note:*** These two traits were referred to as 'kinds' in earlier\n > iterations of the language, and often still are.\n \n@@ -2135,6 +2141,30 @@ select the method to call at runtime.\n \n This usage of traits is similar to Java interfaces.\n \n+By default, each of the three storage classes for traits enforce a\n+particular set of built-in kinds that their contents must fulfill in\n+order to be packaged up in a trait object of that storage class.\n+\n+* The contents of owned traits (`~Trait`) must fulfill the `Send` bound.\n+* The contents of managed traits (`@Trait`) must fulfill the `'static` bound.\n+* The contents of borrowed traits (`&Trait`) are not constrained by any bound.\n+\n+Consequently, the trait objects themselves automatically fulfill their\n+respective kind bounds. However, this default behavior can be overridden by\n+specifying a list of bounds on the trait type, for example, by writing `~Trait:`\n+(which indicates that the contents of the owned trait need not fulfill any\n+bounds), or by writing `~Trait:Send+Freeze`, which indicates that in addition\n+to fulfilling `Send`, contents must also fulfill `Freeze`, and as a consequence,\n+the trait itself fulfills `Freeze`.\n+\n+* `~Trait:Send` is equivalent to `~Trait`.\n+* `@Trait:'static` is equivalent to `@Trait`.\n+* `&Trait:` is equivalent to `&Trait`.\n+\n+Builtin kind bounds can also be specified on closure types in the same way (for\n+example, by writing `fn:Freeze()`), and the default behaviours are the same as\n+for traits of the same storage class.\n+\n ## Trait inheritance\n \n We can write a trait declaration that _inherits_ from other traits, called _supertraits_."}, {"sha": "b0b425e3aee4ad587b966fb2ba8adbeb817db771", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/db5615ddd5c315af115bbcca6a9a0d7ac79f6088/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5615ddd5c315af115bbcca6a9a0d7ac79f6088/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=db5615ddd5c315af115bbcca6a9a0d7ac79f6088", "patch": "@@ -20,6 +20,7 @@ observed by the parent of a task::try task that itself spawns child tasks\n (such as any #[test] function). In both cases the data structures live in\n KillHandle.\n \n+\n I. Task killing.\n \n The model for killing involves two atomic flags, the \"kill flag\" and the\n@@ -60,9 +61,92 @@ killer does perform both writes, it means it saw a KILL_RUNNING in the\n unkillable flag, which means an unkillable task will see KILL_KILLED and fail\n immediately (rendering the subsequent write to the kill flag unnecessary).\n \n+\n II. Exit code propagation.\n \n-FIXME(#7544): Decide on the ultimate model for this and document it.\n+The basic model for exit code propagation, which is used with the \"watched\"\n+spawn mode (on by default for linked spawns, off for supervised and unlinked\n+spawns), is that a parent will wait for all its watched children to exit\n+before reporting whether it succeeded or failed. A watching parent will only\n+report success if it succeeded and all its children also reported success;\n+otherwise, it will report failure. This is most useful for writing test cases:\n+\n+~~~\n+#[test]\n+fn test_something_in_another_task {\n+    do spawn {\n+        assert!(collatz_conjecture_is_false());\n+    }\n+}\n+~~~\n+\n+Here, as the child task will certainly outlive the parent task, we might miss\n+the failure of the child when deciding whether or not the test case passed.\n+The watched spawn mode avoids this problem.\n+\n+In order to propagate exit codes from children to their parents, any\n+'watching' parent must wait for all of its children to exit before it can\n+report its final exit status. We achieve this by using an UnsafeArc, using the\n+reference counting to track how many children are still alive, and using the\n+unwrap() operation in the parent's exit path to wait for all children to exit.\n+The UnsafeArc referred to here is actually the KillHandle itself.\n+\n+This also works transitively, as if a \"middle\" watched child task is itself\n+watching a grandchild task, the \"middle\" task will do unwrap() on its own\n+KillHandle (thereby waiting for the grandchild to exit) before dropping its\n+reference to its watching parent (which will alert the parent).\n+\n+While UnsafeArc::unwrap() accomplishes the synchronization, there remains the\n+matter of reporting the exit codes themselves. This is easiest when an exiting\n+watched task has no watched children of its own:\n+\n+- If the task with no watched children exits successfully, it need do nothing.\n+- If the task with no watched children has failed, it sets a flag in the\n+  parent's KillHandle (\"any_child_failed\") to false. It then stays false forever.\n+\n+However, if a \"middle\" watched task with watched children of its own exits\n+before its child exits, we need to ensure that the grandparent task may still\n+see a failure from the grandchild task. While we could achieve this by having\n+each intermediate task block on its handle, this keeps around the other resources\n+the task was using. To be more efficient, this is accomplished via \"tombstones\".\n+\n+A tombstone is a closure, ~fn() -> bool, which will perform any waiting necessary\n+to collect the exit code of descendant tasks. In its environment is captured\n+the KillHandle of whichever task created the tombstone, and perhaps also any\n+tombstones that that task itself had, and finally also another tombstone,\n+effectively creating a lazy-list of heap closures.\n+\n+When a child wishes to exit early and leave tombstones behind for its parent,\n+it must use a LittleLock (pthread mutex) to synchronize with any possible\n+sibling tasks which are trying to do the same thing with the same parent.\n+However, on the other side, when the parent is ready to pull on the tombstones,\n+it need not use this lock, because the unwrap() serves as a barrier that ensures\n+no children will remain with references to the handle.\n+\n+The main logic for creating and assigning tombstones can be found in the\n+function reparent_children_to() in the impl for KillHandle.\n+\n+\n+IIA. Issues with exit code propagation.\n+\n+There are two known issues with the current scheme for exit code propagation.\n+\n+- As documented in issue #8136, the structure mandates the possibility for stack\n+  overflow when collecting tombstones that are very deeply nested. This cannot\n+  be avoided with the closure representation, as tombstones end up structured in\n+  a sort of tree. However, notably, the tombstones do not actually need to be\n+  collected in any particular order, and so a doubly-linked list may be used.\n+  However we do not do this yet because DList is in libextra.\n+\n+- A discussion with Graydon made me realize that if we decoupled the exit code\n+  propagation from the parents-waiting action, this could result in a simpler\n+  implementation as the exit codes themselves would not have to be propagated,\n+  and could instead be propagated implicitly through the taskgroup mechanism\n+  that we already have. The tombstoning scheme would still be required. I have\n+  not implemented this because currently we can't receive a linked failure kill\n+  signal during the task cleanup activity, as that is currently \"unkillable\",\n+  and occurs outside the task's unwinder's \"try\" block, so would require some\n+  restructuring.\n \n */\n "}]}