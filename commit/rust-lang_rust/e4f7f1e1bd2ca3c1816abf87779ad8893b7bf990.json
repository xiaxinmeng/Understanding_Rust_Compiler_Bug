{"sha": "e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjdmMWUxYmQyY2EzYzE4MTZhYmY4Nzc3OWFkODg5M2I3YmY5OTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-19T13:01:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-19T13:01:30Z"}, "message": "Merge #8462\n\n8462: Expand macros at type position r=jonas-schievink a=cynecx\n\n\n\nCo-authored-by: cynecx <me@cynecx.net>", "tree": {"sha": "e843f284eca0c2a8d371c7af7c6532bace0d504d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e843f284eca0c2a8d371c7af7c6532bace0d504d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfX8qCRBK7hj4Ov3rIwAAGJcIAJ6WCYz6iQ45h6C2obcj5guv\nb8VZJxP4jWEnbRMCcy++t4W75XZ5/V1AgqWX/L55VdP/t1XNkasdunb3y4cmnETK\nv1GJZ0oj5rsasIoyPo46CzSjjnffiWkBHHY3H5tQtd5Xskee/6pu2KtbQoqZs+gF\nhNOqAINVEAHMJOey3NCPT4MTZKV19jjTmlQacctp+AMDBX1aS3rvR+ybOQ4w9v7N\nBP7yd/GrIfBBGB9C8QcOaj5KxsVCnNLC07YFloZ6uY0BGjhgt0HBIqbXuOFZ6H7n\nFwunrQmNgO/ysffD4cuaGwP9nsCKzhQKfzECHq4kB1n8asViTBbNjyeG/vbvMXM=\n=R/Gv\n-----END PGP SIGNATURE-----\n", "payload": "tree e843f284eca0c2a8d371c7af7c6532bace0d504d\nparent 3f1a220f32220cd4a664ca1adac5eb36e9eb33b2\nparent f0507ab7c697ba4bcd59dd2f673dfff5072e3e1a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618837290 +0000\ncommitter GitHub <noreply@github.com> 1618837290 +0000\n\nMerge #8462\n\n8462: Expand macros at type position r=jonas-schievink a=cynecx\n\n\n\nCo-authored-by: cynecx <me@cynecx.net>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "html_url": "https://github.com/rust-lang/rust/commit/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f1a220f32220cd4a664ca1adac5eb36e9eb33b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1a220f32220cd4a664ca1adac5eb36e9eb33b2", "html_url": "https://github.com/rust-lang/rust/commit/3f1a220f32220cd4a664ca1adac5eb36e9eb33b2"}, {"sha": "f0507ab7c697ba4bcd59dd2f673dfff5072e3e1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0507ab7c697ba4bcd59dd2f673dfff5072e3e1a", "html_url": "https://github.com/rust-lang/rust/commit/f0507ab7c697ba4bcd59dd2f673dfff5072e3e1a"}], "stats": {"total": 467, "additions": 391, "deletions": 76}, "files": [{"sha": "62500602a717623ae1ead7331eb6273b3b8aec30", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -6,10 +6,11 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n+    body,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n-use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n+use hir_expand::{name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -853,8 +854,8 @@ impl<'a> SemanticsScope<'a> {\n     /// Resolve a path as-if it was written at the given scope. This is\n     /// necessary a heuristic, as it doesn't take hygiene into account.\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n-        let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n-        let path = Path::from_src(path.clone(), &hygiene)?;\n+        let ctx = body::LowerCtx::new(self.db.upcast(), self.file_id);\n+        let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }"}, {"sha": "0895bd6f1f1fc06ebfc2ecb7b8ed4df961473a5f", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -9,6 +9,7 @@ use std::{iter::once, sync::Arc};\n \n use hir_def::{\n     body::{\n+        self,\n         scope::{ExprScopes, ScopeId},\n         Body, BodySourceMap,\n     },\n@@ -202,8 +203,8 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<MacroDef> {\n-        let hygiene = Hygiene::new(db.upcast(), macro_call.file_id);\n-        let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n+        let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n+        let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n         self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n     }\n \n@@ -281,7 +282,9 @@ impl SourceAnalyzer {\n         }\n \n         // This must be a normal source file rather than macro file.\n-        let hir_path = Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+        let hygiene = Hygiene::new(db.upcast(), self.file_id);\n+        let ctx = body::LowerCtx::with_hygiene(&hygiene);\n+        let hir_path = Path::from_src(path.clone(), &ctx)?;\n \n         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n         // trying to resolve foo::bar."}, {"sha": "131f424cc8ba79b97fb5067ebb65f90d28520deb", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -21,7 +21,7 @@ use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n \n-pub(crate) use lower::LowerCtx;\n+pub use lower::LowerCtx;\n \n use crate::{\n     attr::{Attrs, RawAttrs},\n@@ -37,13 +37,15 @@ use crate::{\n \n /// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n+#[derive(Debug)]\n pub(crate) struct CfgExpander {\n     cfg_options: CfgOptions,\n     hygiene: Hygiene,\n     krate: CrateId,\n }\n \n-pub(crate) struct Expander {\n+#[derive(Debug)]\n+pub struct Expander {\n     cfg_expander: CfgExpander,\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n@@ -80,11 +82,7 @@ impl CfgExpander {\n }\n \n impl Expander {\n-    pub(crate) fn new(\n-        db: &dyn DefDatabase,\n-        current_file_id: HirFileId,\n-        module: ModuleId,\n-    ) -> Expander {\n+    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n         let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n         let def_map = module.def_map(db);\n         let ast_id_map = db.ast_id_map(current_file_id);\n@@ -98,7 +96,7 @@ impl Expander {\n         }\n     }\n \n-    pub(crate) fn enter_expand<T: ast::AstNode>(\n+    pub fn enter_expand<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n@@ -170,7 +168,7 @@ impl Expander {\n         Ok(ExpandResult { value: Some((mark, node)), err })\n     }\n \n-    pub(crate) fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n@@ -190,8 +188,13 @@ impl Expander {\n         &self.cfg_expander.cfg_options\n     }\n \n+    pub fn current_file_id(&self) -> HirFileId {\n+        self.current_file_id\n+    }\n+\n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        Path::from_src(path, &self.cfg_expander.hygiene)\n+        let ctx = LowerCtx::with_hygiene(&self.cfg_expander.hygiene);\n+        Path::from_src(path, &ctx)\n     }\n \n     fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n@@ -204,7 +207,8 @@ impl Expander {\n     }\n }\n \n-pub(crate) struct Mark {\n+#[derive(Debug)]\n+pub struct Mark {\n     file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,\n     bomb: DropBomb,"}, {"sha": "c11da30d2e046021bb214a7cccfd87ff2cb62ed7", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -1,10 +1,11 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use std::mem;\n+use std::{mem, sync::Arc};\n \n use either::Either;\n use hir_expand::{\n+    ast_id_map::{AstIdMap, FileAstId},\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     ExpandError, HirFileId,\n@@ -39,20 +40,39 @@ use crate::{\n \n use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n \n-pub(crate) struct LowerCtx {\n+pub struct LowerCtx {\n     hygiene: Hygiene,\n+    file_id: Option<HirFileId>,\n+    source_ast_id_map: Option<Arc<AstIdMap>>,\n }\n \n impl LowerCtx {\n-    pub(crate) fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n+    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            file_id: Some(file_id),\n+            source_ast_id_map: Some(db.ast_id_map(file_id)),\n+        }\n+    }\n+\n+    pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n+        LowerCtx { hygiene: hygiene.clone(), file_id: None, source_ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n     }\n-    pub(crate) fn with_hygiene(hygiene: &Hygiene) -> Self {\n-        LowerCtx { hygiene: hygiene.clone() }\n+\n+    pub(crate) fn file_id(&self) -> HirFileId {\n+        self.file_id.unwrap()\n     }\n \n     pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, &self.hygiene)\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<FileAstId<N>> {\n+        self.source_ast_id_map.as_ref().map(|ast_id_map| ast_id_map.ast_id(item))\n     }\n }\n "}, {"sha": "16a94a058844706cb80f76f2ed2e857674fa91ff", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -104,6 +104,11 @@ impl ItemTree {\n                     // items and expanded during block DefMap computation\n                     return Default::default();\n                 },\n+                ast::Type(ty) => {\n+                    // Types can contain inner items. We return an empty item tree in this case, but\n+                    // still need to collect inner items.\n+                    ctx.lower_inner_items(ty.syntax())\n+                },\n                 ast::Expr(e) => {\n                     // Macros can expand to expressions. We return an empty item tree in this case, but\n                     // still need to collect inner items."}, {"sha": "25694f0372b2e001e9af9bdeb9328a956f827a13", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -688,6 +688,7 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct UnresolvedMacro {\n     pub path: ModPath,\n }"}, {"sha": "509f77850a304376d94b6f044ba843355548560d", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -48,7 +48,8 @@ pub enum ImportAlias {\n \n impl ModPath {\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        lower::lower_path(path, hygiene).map(|it| (*it.mod_path).clone())\n+        let ctx = LowerCtx::with_hygiene(hygiene);\n+        lower::lower_path(path, &ctx).map(|it| (*it.mod_path).clone())\n     }\n \n     pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n@@ -167,8 +168,8 @@ pub enum GenericArg {\n impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n-        lower::lower_path(path, hygiene)\n+    pub fn from_src(path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n+        lower::lower_path(path, ctx)\n     }\n \n     /// Converts a known mod path to `Path`."}, {"sha": "1df6db5250e70880cdbba4bc5dbb150ba415679f", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -6,10 +6,7 @@ use crate::intern::Interned;\n use std::sync::Arc;\n \n use either::Either;\n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{name, AsName},\n-};\n+use hir_expand::name::{name, AsName};\n use syntax::ast::{self, AstNode, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n@@ -23,12 +20,12 @@ pub(super) use lower_use::lower_use_tree;\n \n /// Converts an `ast::Path` to `Path`. Works with use trees.\n /// It correctly handles `$crate` based path from macro call.\n-pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n     let mut kind = PathKind::Plain;\n     let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n-    let ctx = LowerCtx::with_hygiene(hygiene);\n+    let hygiene = ctx.hygiene();\n     loop {\n         let segment = path.segment()?;\n \n@@ -43,10 +40,10 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     Either::Left(name) => {\n                         let args = segment\n                             .generic_arg_list()\n-                            .and_then(|it| lower_generic_args(&ctx, it))\n+                            .and_then(|it| lower_generic_args(ctx, it))\n                             .or_else(|| {\n                                 lower_generic_args_from_fn_path(\n-                                    &ctx,\n+                                    ctx,\n                                     segment.param_list(),\n                                     segment.ret_type(),\n                                 )\n@@ -64,7 +61,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                let self_type = TypeRef::from_ast(&ctx, type_ref?);\n+                let self_type = TypeRef::from_ast(ctx, type_ref?);\n \n                 match trait_ref {\n                     // <T>::foo\n@@ -74,7 +71,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let path = Path::from_src(trait_ref.path()?, hygiene)?;\n+                        let path = Path::from_src(trait_ref.path()?, ctx)?;\n                         let mod_path = (*path.mod_path).clone();\n                         let num_segments = path.mod_path.segments.len();\n                         kind = mod_path.kind;"}, {"sha": "ea29da5daae49f75677b08954fc810bd163b7db1", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -1,6 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n-use hir_expand::name::Name;\n+\n+use hir_expand::{name::Name, AstId, InFile};\n use syntax::ast;\n \n use crate::{body::LowerCtx, path::Path};\n@@ -68,6 +69,7 @@ impl TraitRef {\n         }\n     }\n }\n+\n /// Compare ty::Ty\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeRef {\n@@ -84,6 +86,7 @@ pub enum TypeRef {\n     // For\n     ImplTrait(Vec<TypeBound>),\n     DynTrait(Vec<TypeBound>),\n+    Macro(AstId<ast::MacroCall>),\n     Error,\n }\n \n@@ -116,7 +119,7 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n+    pub fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n         match node {\n             ast::Type::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n             ast::Type::TupleType(inner) => {\n@@ -176,8 +179,13 @@ impl TypeRef {\n             ast::Type::DynTraitType(inner) => {\n                 TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n-            // FIXME: Macros in type position are not yet supported.\n-            ast::Type::MacroType(_) => TypeRef::Error,\n+            ast::Type::MacroType(mt) => match mt.macro_call() {\n+                Some(mc) => ctx\n+                    .ast_id(&mc)\n+                    .map(|mc| TypeRef::Macro(InFile::new(ctx.file_id(), mc)))\n+                    .unwrap_or(TypeRef::Error),\n+                None => TypeRef::Error,\n+            },\n         }\n     }\n \n@@ -215,7 +223,7 @@ impl TypeRef {\n                     }\n                 }\n                 TypeRef::Path(path) => go_path(path, f),\n-                TypeRef::Never | TypeRef::Placeholder | TypeRef::Error => {}\n+                TypeRef::Never | TypeRef::Placeholder | TypeRef::Macro(_) | TypeRef::Error => {}\n             };\n         }\n "}, {"sha": "1e4b0cc194b711c7c933292007251ed6936201d5", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -440,6 +440,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n         MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n         MACRO_STMTS => FragmentKind::Statements,\n         MACRO_PAT => FragmentKind::Pattern,\n+        MACRO_TYPE => FragmentKind::Type,\n         ITEM_LIST => FragmentKind::Items,\n         LET_STMT => {\n             // FIXME: Handle LHS Pattern"}, {"sha": "a5ac32d3cb014c5434f06d51574edb005eec410a", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -31,6 +31,7 @@ use parser::FragmentKind;\n use std::sync::Arc;\n use syntax::{algo::SyntaxRewriter, SyntaxNode};\n \n+#[derive(Debug)]\n pub struct ErrorEmitted {\n     _private: (),\n }"}, {"sha": "4fb7d9cf2fd7da7fbab1c96ec749ca16cf7c7e7e", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -9,6 +9,7 @@ use std::{\n \n use chalk_ir::BoundVar;\n use hir_def::{\n+    body,\n     db::DefDatabase,\n     find_path,\n     generics::TypeParamProvenance,\n@@ -18,7 +19,7 @@ use hir_def::{\n     visibility::Visibility,\n     AssocContainerId, Lookup, ModuleId, TraitId,\n };\n-use hir_expand::name::Name;\n+use hir_expand::{hygiene::Hygiene, name::Name};\n \n use crate::{\n     const_from_placeholder_idx, db::HirDatabase, from_assoc_type_id, from_foreign_def_id,\n@@ -997,6 +998,18 @@ impl HirDisplay for TypeRef {\n                 write!(f, \"dyn \")?;\n                 f.write_joined(bounds, \" + \")?;\n             }\n+            TypeRef::Macro(macro_call) => {\n+                let macro_call = macro_call.to_node(f.db.upcast());\n+                let ctx = body::LowerCtx::with_hygiene(&Hygiene::new_unhygienic());\n+                match macro_call.path() {\n+                    Some(path) => match Path::from_src(path, &ctx) {\n+                        Some(path) => path.hir_fmt(f)?,\n+                        None => write!(f, \"{{macro}}\")?,\n+                    },\n+                    None => write!(f, \"{{macro}}\")?,\n+                }\n+                write!(f, \"!(..)\")?;\n+            }\n             TypeRef::Error => write!(f, \"{{error}}\")?,\n         }\n         Ok(())"}, {"sha": "7fd46becdb944c624193a16cdf6a488af2ba61f3", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -5,12 +5,14 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n+use std::cell::{Cell, RefCell};\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{cast::Cast, fold::Shift, interner::HasInterner, Mutability, Safety};\n use hir_def::{\n     adt::StructKind,\n+    body::{Expander, LowerCtx},\n     builtin_type::BuiltinType,\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n@@ -20,10 +22,11 @@ use hir_def::{\n     GenericDefId, HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n     TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::name::Name;\n+use hir_expand::{name::Name, ExpandResult};\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n+use syntax::ast;\n \n use crate::{\n     db::HirDatabase,\n@@ -50,7 +53,7 @@ pub struct TyLoweringContext<'a> {\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: TypeParamLoweringMode,\n     pub impl_trait_mode: ImplTraitLoweringMode,\n-    impl_trait_counter: std::cell::Cell<u16>,\n+    impl_trait_counter: Cell<u16>,\n     /// When turning `impl Trait` into opaque types, we have to collect the\n     /// bounds at the same time to get the IDs correct (without becoming too\n     /// complicated). I don't like using interior mutability (as for the\n@@ -59,16 +62,17 @@ pub struct TyLoweringContext<'a> {\n     /// we're grouping the mutable data (the counter and this field) together\n     /// with the immutable context (the references to the DB and resolver).\n     /// Splitting this up would be a possible fix.\n-    opaque_type_data: std::cell::RefCell<Vec<ReturnTypeImplTrait>>,\n+    opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n+    expander: RefCell<Option<Expander>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n     pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n-        let impl_trait_counter = std::cell::Cell::new(0);\n+        let impl_trait_counter = Cell::new(0);\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        let opaque_type_data = std::cell::RefCell::new(Vec::new());\n+        let opaque_type_data = RefCell::new(Vec::new());\n         Self {\n             db,\n             resolver,\n@@ -77,6 +81,7 @@ impl<'a> TyLoweringContext<'a> {\n             impl_trait_counter,\n             type_param_mode,\n             opaque_type_data,\n+            expander: RefCell::new(None),\n         }\n     }\n \n@@ -86,15 +91,18 @@ impl<'a> TyLoweringContext<'a> {\n         f: impl FnOnce(&TyLoweringContext) -> T,\n     ) -> T {\n         let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n+        let expander = self.expander.replace(None);\n         let new_ctx = Self {\n             in_binders: debruijn,\n-            impl_trait_counter: std::cell::Cell::new(self.impl_trait_counter.get()),\n-            opaque_type_data: std::cell::RefCell::new(opaque_ty_data_vec),\n+            impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n+            opaque_type_data: RefCell::new(opaque_ty_data_vec),\n+            expander: RefCell::new(expander),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n         self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n+        self.expander.replace(new_ctx.expander.into_inner());\n         result\n     }\n \n@@ -287,6 +295,53 @@ impl<'a> TyLoweringContext<'a> {\n                     }\n                 }\n             }\n+            TypeRef::Macro(macro_call) => {\n+                let (expander, recursion_start) = {\n+                    let mut expander = self.expander.borrow_mut();\n+                    if expander.is_some() {\n+                        (Some(expander), false)\n+                    } else {\n+                        if let Some(module_id) = self.resolver.module() {\n+                            *expander = Some(Expander::new(\n+                                self.db.upcast(),\n+                                macro_call.file_id,\n+                                module_id,\n+                            ));\n+                            (Some(expander), true)\n+                        } else {\n+                            (None, false)\n+                        }\n+                    }\n+                };\n+                let ty = if let Some(mut expander) = expander {\n+                    let expander_mut = expander.as_mut().unwrap();\n+                    let macro_call = macro_call.to_node(self.db.upcast());\n+                    match expander_mut.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n+                        Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n+                            let ctx =\n+                                LowerCtx::new(self.db.upcast(), expander_mut.current_file_id());\n+                            let type_ref = TypeRef::from_ast(&ctx, expanded);\n+\n+                            drop(expander);\n+                            let ty = self.lower_ty(&type_ref);\n+\n+                            self.expander\n+                                .borrow_mut()\n+                                .as_mut()\n+                                .unwrap()\n+                                .exit(self.db.upcast(), mark);\n+                            Some(ty)\n+                        }\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                };\n+                if recursion_start {\n+                    *self.expander.borrow_mut() = None;\n+                }\n+                ty.unwrap_or_else(|| TyKind::Error.intern(&Interner))\n+            }\n             TypeRef::Error => TyKind::Error.intern(&Interner),\n         };\n         (ty, res)"}, {"sha": "6588aa46c1e073a0b0a3a68dc79660c16f2f26f7", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -1074,3 +1074,202 @@ fn macro_in_arm() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn macro_in_type_alias_position() {\n+    check_infer(\n+        r#\"\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        trait Foo {\n+            type Ty;\n+        }\n+\n+        impl<T> Foo for T {\n+            type Ty = U32!();\n+        }\n+\n+        type TayTo = U32!();\n+\n+        fn testy() {\n+            let a: <() as Foo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            147..196 '{     ...yTo; }': ()\n+            157..158 'a': u32\n+            185..186 'b': u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn nested_macro_in_type_alias_position() {\n+    check_infer(\n+        r#\"\n+        macro_rules! U32Inner2 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! U32Inner1 {\n+            () => { U32Inner2!() };\n+        }\n+\n+        macro_rules! U32 {\n+            () => { U32Inner1!() };\n+        }\n+\n+        trait Foo {\n+            type Ty;\n+        }\n+\n+        impl<T> Foo for T {\n+            type Ty = U32!();\n+        }\n+\n+        type TayTo = U32!();\n+\n+        fn testy() {\n+            let a: <() as Foo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            259..308 '{     ...yTo; }': ()\n+            269..270 'a': u32\n+            297..298 'b': u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_alias_position_generics() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        trait Moo {\n+            type Ty;\n+        }\n+\n+        impl<T> Moo for T {\n+            type Ty = Bar!();\n+        }\n+\n+        type TayTo = Bar!();\n+\n+        fn main() {\n+            let a: <() as Moo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            228..277 '{     ...yTo; }': ()\n+            238..239 'a': Foo<u32, u32>\n+            266..267 'b': Foo<u32, u32>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_position() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        fn main() {\n+            let a: Bar!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            133..155 '{     ...!(); }': ()\n+            143..144 'a': Foo<u32, u32>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_generics() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        trait Moo {\n+            type Ty;\n+        }\n+\n+        impl<T> Moo for T {\n+            type Ty = Foo<Bar!(), Bar!()>;\n+        }\n+\n+        type TayTo = Foo<Bar!(), U32!()>;\n+\n+        fn main() {\n+            let a: <() as Moo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            254..303 '{     ...yTo; }': ()\n+            264..265 'a': Foo<Foo<u32, u32>, Foo<u32, u32>>\n+            292..293 'b': Foo<Foo<u32, u32>, u32>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn infinitely_recursive_macro_type() {\n+    check_infer(\n+        r#\"\n+        struct Bar<T, X>(T, X);\n+\n+        macro_rules! Foo {\n+            () => { Foo!() }\n+        }\n+\n+        macro_rules! U32 {\n+            () => { u32 }\n+        }\n+\n+        type A = Foo!();\n+        type B = Bar<Foo!(), U32!()>;\n+\n+        fn main() {\n+            let a: A;\n+            let b: B;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            166..197 '{     ...: B; }': ()\n+            176..177 'a': {unknown}\n+            190..191 'b': Bar<{unknown}, u32>\n+        \"#]],\n+    );\n+}"}, {"sha": "6ae3e734fe4218e331cfd532fd9210a149928597", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -283,17 +283,21 @@ pub(super) fn path_type(p: &mut Parser) {\n // type B = crate::foo!();\n fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n     assert!(paths::is_path_start(p));\n+    let r = p.start();\n     let m = p.start();\n+\n     paths::type_path(p);\n \n     let kind = if p.at(T![!]) && !p.at(T![!=]) {\n         items::macro_call_after_excl(p);\n-        MACRO_CALL\n+        m.complete(p, MACRO_CALL);\n+        MACRO_TYPE\n     } else {\n+        m.abandon(p);\n         PATH_TYPE\n     };\n \n-    let path = m.complete(p, kind);\n+    let path = r.complete(p, kind);\n \n     if allow_bounds {\n         opt_type_bounds_as_dyn_trait_type(p, path);\n@@ -319,7 +323,7 @@ pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n fn opt_type_bounds_as_dyn_trait_type(p: &mut Parser, type_marker: CompletedMarker) {\n     assert!(matches!(\n         type_marker.kind(),\n-        SyntaxKind::PATH_TYPE | SyntaxKind::FOR_TYPE | SyntaxKind::MACRO_CALL\n+        SyntaxKind::PATH_TYPE | SyntaxKind::FOR_TYPE | SyntaxKind::MACRO_TYPE\n     ));\n     if !p.at(T![+]) {\n         return;"}, {"sha": "1ff3f7656a446b2a2471d4f04b1c875a06197f86", "filename": "crates/syntax/test_data/parser/inline/ok/0117_macro_call_type.rast", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast?ref=e4f7f1e1bd2ca3c1816abf87779ad8893b7bf990", "patch": "@@ -7,15 +7,16 @@ SOURCE_FILE@0..41\n     WHITESPACE@6..7 \" \"\n     EQ@7..8 \"=\"\n     WHITESPACE@8..9 \" \"\n-    MACRO_CALL@9..15\n-      PATH@9..12\n-        PATH_SEGMENT@9..12\n-          NAME_REF@9..12\n-            IDENT@9..12 \"foo\"\n-      BANG@12..13 \"!\"\n-      TOKEN_TREE@13..15\n-        L_PAREN@13..14 \"(\"\n-        R_PAREN@14..15 \")\"\n+    MACRO_TYPE@9..15\n+      MACRO_CALL@9..15\n+        PATH@9..12\n+          PATH_SEGMENT@9..12\n+            NAME_REF@9..12\n+              IDENT@9..12 \"foo\"\n+        BANG@12..13 \"!\"\n+        TOKEN_TREE@13..15\n+          L_PAREN@13..14 \"(\"\n+          R_PAREN@14..15 \")\"\n     SEMICOLON@15..16 \";\"\n   WHITESPACE@16..17 \"\\n\"\n   TYPE_ALIAS@17..40\n@@ -26,19 +27,20 @@ SOURCE_FILE@0..41\n     WHITESPACE@23..24 \" \"\n     EQ@24..25 \"=\"\n     WHITESPACE@25..26 \" \"\n-    MACRO_CALL@26..39\n-      PATH@26..36\n-        PATH@26..31\n-          PATH_SEGMENT@26..31\n-            NAME_REF@26..31\n-              CRATE_KW@26..31 \"crate\"\n-        COLON2@31..33 \"::\"\n-        PATH_SEGMENT@33..36\n-          NAME_REF@33..36\n-            IDENT@33..36 \"foo\"\n-      BANG@36..37 \"!\"\n-      TOKEN_TREE@37..39\n-        L_PAREN@37..38 \"(\"\n-        R_PAREN@38..39 \")\"\n+    MACRO_TYPE@26..39\n+      MACRO_CALL@26..39\n+        PATH@26..36\n+          PATH@26..31\n+            PATH_SEGMENT@26..31\n+              NAME_REF@26..31\n+                CRATE_KW@26..31 \"crate\"\n+          COLON2@31..33 \"::\"\n+          PATH_SEGMENT@33..36\n+            NAME_REF@33..36\n+              IDENT@33..36 \"foo\"\n+        BANG@36..37 \"!\"\n+        TOKEN_TREE@37..39\n+          L_PAREN@37..38 \"(\"\n+          R_PAREN@38..39 \")\"\n     SEMICOLON@39..40 \";\"\n   WHITESPACE@40..41 \"\\n\""}]}