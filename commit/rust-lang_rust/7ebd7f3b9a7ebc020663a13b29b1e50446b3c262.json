{"sha": "7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYmQ3ZjNiOWE3ZWJjMDIwNjYzYTEzYjI5YjFlNTA0NDZiM2MyNjI=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-07-01T21:38:43Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-08-08T15:15:19Z"}, "message": "Add various methods to Bignum:\n\n- Exposing digits and individual bits\n- Counting the number of bits\n- Add small (digit-sized) values\n- Multiplication by power of 5\n- Division with remainder\n\nAll are necessary for decimal to floating point conversions.\nAll but the most trivial ones come with tests.", "tree": {"sha": "2006cf627946ab8bf23f81a6ab785d255910d542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2006cf627946ab8bf23f81a6ab785d255910d542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "html_url": "https://github.com/rust-lang/rust/commit/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262/comments", "author": null, "committer": null, "parents": [{"sha": "7ff10209aa9b8da6d6d4ceea0161757048126d2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff10209aa9b8da6d6d4ceea0161757048126d2d", "html_url": "https://github.com/rust-lang/rust/commit/7ff10209aa9b8da6d6d4ceea0161757048126d2d"}], "stats": {"total": 235, "additions": 230, "deletions": 5}, "files": [{"sha": "15980f925fa031ae8ebe170d2aff78298ff34c70", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 141, "deletions": 5, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "patch": "@@ -13,7 +13,7 @@\n //! This is designed to avoid the heap allocation at expense of stack memory.\n //! The most used bignum type, `Big32x40`, is limited by 32 \u00d7 40 = 1,280 bits\n //! and will take at most 160 bytes of stack memory. This is more than enough\n-//! for formatting and parsing all possible finite `f64` values.\n+//! for round-tripping all possible finite `f64` values.\n //!\n //! In principle it is possible to have multiple bignum types for different\n //! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n@@ -92,6 +92,14 @@ impl_full_ops! {\n //  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // see RFC #521 for enabling this.\n }\n \n+/// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value\n+/// that's a power of five, plus the corresponding exponent. Used in `mul_pow5`.\n+const SMALL_POW5: [(u64, usize); 3] = [\n+    (125, 3),\n+    (15625, 6),\n+    (1_220_703_125, 13),\n+];\n+\n macro_rules! define_bignum {\n     ($name:ident: type=$ty:ty, n=$n:expr) => (\n         /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n@@ -135,9 +143,53 @@ macro_rules! define_bignum {\n                 $name { size: sz, base: base }\n             }\n \n+            /// Return the internal digits as a slice `[a, b, c, ...]` such that the numeric\n+            /// value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in\n+            /// the digit type.\n+            pub fn digits(&self) -> &[$ty] {\n+                &self.base[..self.size]\n+            }\n+\n+            /// Return the `i`-th bit where bit 0 is the least significant one.\n+            /// In other words, the bit with weight `2^i`.\n+            pub fn get_bit(&self, i: usize) -> u8 {\n+                use mem;\n+\n+                let digitbits = mem::size_of::<$ty>() * 8;\n+                let d = i / digitbits;\n+                let b = i % digitbits;\n+                ((self.base[d] >> b) & 1) as u8\n+            }\n+\n             /// Returns true if the bignum is zero.\n             pub fn is_zero(&self) -> bool {\n-                self.base[..self.size].iter().all(|&v| v == 0)\n+                self.digits().iter().all(|&v| v == 0)\n+            }\n+\n+            /// Returns the number of bits necessary to represent this value. Note that zero\n+            /// is considered to need 0 bits.\n+            pub fn bit_length(&self) -> usize {\n+                use mem;\n+\n+                let digitbits = mem::size_of::<$ty>()* 8;\n+                // Skip over the most significant digits which are zero.\n+                let nonzero = match self.digits().iter().rposition(|&x| x != 0) {\n+                    Some(n) => {\n+                        let end = self.size - n;\n+                        &self.digits()[..end]\n+                    }\n+                    None => {\n+                        // There are no non-zero digits, i.e. the number is zero.\n+                        return 0;\n+                    }\n+                };\n+                // This could be optimized with leading_zeros() and bit shifts, but that's\n+                // probably not worth the hassle.\n+                let mut i = nonzero.len() * digitbits - 1;\n+                while self.get_bit(i) == 0 {\n+                    i -= 1;\n+                }\n+                i + 1\n             }\n \n             /// Adds `other` to itself and returns its own mutable reference.\n@@ -160,6 +212,24 @@ macro_rules! define_bignum {\n                 self\n             }\n \n+            pub fn add_small<'a>(&'a mut self, other: $ty) -> &'a mut $name {\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let (mut carry, v) = self.base[0].full_add(other, false);\n+                self.base[0] = v;\n+                let mut i = 1;\n+                while carry {\n+                    let (c, v) = self.base[i].full_add(0, carry);\n+                    self.base[i] = v;\n+                    carry = c;\n+                    i += 1;\n+                }\n+                if i > self.size {\n+                    self.size = i;\n+                }\n+                self\n+            }\n+\n             /// Subtracts `other` from itself and returns its own mutable reference.\n             pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                 use cmp;\n@@ -238,6 +308,34 @@ macro_rules! define_bignum {\n                 self\n             }\n \n+            /// Multiplies itself by `5^e` and returns its own mutable reference.\n+            pub fn mul_pow5<'a>(&'a mut self, mut e: usize) -> &'a mut $name {\n+                use mem;\n+                use num::flt2dec::bignum::SMALL_POW5;\n+\n+                // There are exactly n trailing zeros on 2^n, and the only relevant digit sizes\n+                // are consecutive powers of two, so this is well suited index for the table.\n+                let table_index = mem::size_of::<$ty>().trailing_zeros() as usize;\n+                let (small_power, small_e) = SMALL_POW5[table_index];\n+                let small_power = small_power as $ty;\n+\n+                // Multiply with the largest single-digit power as long as possible ...\n+                while e >= small_e {\n+                    self.mul_small(small_power);\n+                    e -= small_e;\n+                }\n+\n+                // ... then finish off the remainder.\n+                let mut rest_power = 1;\n+                for _ in 0..e {\n+                    rest_power *= 5;\n+                }\n+                self.mul_small(rest_power);\n+\n+                self\n+            }\n+\n+\n             /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n             /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n             /// and returns its own mutable reference.\n@@ -269,9 +367,9 @@ macro_rules! define_bignum {\n \n                 let mut ret = [0; $n];\n                 let retsz = if self.size < other.len() {\n-                    mul_inner(&mut ret, &self.base[..self.size], other)\n+                    mul_inner(&mut ret, &self.digits(), other)\n                 } else {\n-                    mul_inner(&mut ret, other, &self.base[..self.size])\n+                    mul_inner(&mut ret, other, &self.digits())\n                 };\n                 self.base = ret;\n                 self.size = retsz;\n@@ -294,6 +392,45 @@ macro_rules! define_bignum {\n                 }\n                 (self, borrow)\n             }\n+\n+            /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n+            /// remainder.\n+            pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n+                use mem;\n+\n+                // Stupid slow base-2 long division taken from\n+                // https://en.wikipedia.org/wiki/Division_algorithm\n+                // FIXME use a greater base ($ty) for the long division.\n+                assert!(!d.is_zero());\n+                let digitbits = mem::size_of::<$ty>() * 8;\n+                for digit in &mut q.base[..] {\n+                    *digit = 0;\n+                }\n+                for digit in &mut r.base[..] {\n+                    *digit = 0;\n+                }\n+                r.size = d.size;\n+                q.size = 1;\n+                let mut q_is_zero = true;\n+                let end = self.bit_length();\n+                for i in (0..end).rev() {\n+                    r.mul_pow2(1);\n+                    r.base[0] |= self.get_bit(i) as $ty;\n+                    if &*r >= d {\n+                        r.sub(d);\n+                        // Set bit `i` of q to 1.\n+                        let digit_idx = i / digitbits;\n+                        let bit_idx = i % digitbits;\n+                        if q_is_zero {\n+                            q.size = digit_idx + 1;\n+                            q_is_zero = false;\n+                        }\n+                        q.base[digit_idx] |= 1 << bit_idx;\n+                    }\n+                }\n+                debug_assert!(q.base[q.size..].iter().all(|&d| d == 0));\n+                debug_assert!(r.base[r.size..].iter().all(|&d| d == 0));\n+            }\n         }\n \n         impl ::cmp::PartialEq for $name {\n@@ -355,4 +492,3 @@ pub mod tests {\n     use prelude::v1::*;\n     define_bignum!(Big8x3: type=u8, n=3);\n }\n-"}, {"sha": "31065b2898f82bdf8a8ff020e006b1714d2091cc", "filename": "src/libcoretest/num/flt2dec/bignum.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd7f3b9a7ebc020663a13b29b1e50446b3c262/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs?ref=7ebd7f3b9a7ebc020663a13b29b1e50446b3c262", "patch": "@@ -39,6 +39,23 @@ fn test_add_overflow_2() {\n     Big::from_u64(0xffffff).add(&Big::from_small(1));\n }\n \n+#[test]\n+fn test_add_small() {\n+    assert_eq!(*Big::from_small(3).add_small(4), Big::from_small(7));\n+    assert_eq!(*Big::from_small(3).add_small(0), Big::from_small(3));\n+    assert_eq!(*Big::from_small(0).add_small(3), Big::from_small(3));\n+    assert_eq!(*Big::from_small(7).add_small(250), Big::from_u64(257));\n+    assert_eq!(*Big::from_u64(0x7fff).add_small(1), Big::from_u64(0x8000));\n+    assert_eq!(*Big::from_u64(0x2ffe).add_small(0x35), Big::from_u64(0x3033));\n+    assert_eq!(*Big::from_small(0xdc).add_small(0x89), Big::from_u64(0x165));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_add_small_overflow() {\n+    Big::from_u64(0xffffff).add_small(1);\n+}\n+\n #[test]\n fn test_sub() {\n     assert_eq!(*Big::from_small(7).sub(&Big::from_small(4)), Big::from_small(3));\n@@ -97,6 +114,30 @@ fn test_mul_pow2_overflow_2() {\n     Big::from_u64(0x123).mul_pow2(16);\n }\n \n+#[test]\n+fn test_mul_pow5() {\n+    assert_eq!(*Big::from_small(42).mul_pow5(0), Big::from_small(42));\n+    assert_eq!(*Big::from_small(1).mul_pow5(2), Big::from_small(25));\n+    assert_eq!(*Big::from_small(1).mul_pow5(4), Big::from_u64(25 * 25));\n+    assert_eq!(*Big::from_small(4).mul_pow5(3), Big::from_u64(500));\n+    assert_eq!(*Big::from_small(140).mul_pow5(2), Big::from_u64(25 * 140));\n+    assert_eq!(*Big::from_small(25).mul_pow5(1), Big::from_small(125));\n+    assert_eq!(*Big::from_small(125).mul_pow5(7), Big::from_u64(9765625));\n+    assert_eq!(*Big::from_small(0).mul_pow5(127), Big::from_small(0));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow5_overflow_1() {\n+    Big::from_small(1).mul_pow5(12);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow5_overflow_2() {\n+    Big::from_small(230).mul_pow5(8);\n+}\n+\n #[test]\n fn test_mul_digits() {\n     assert_eq!(*Big::from_small(3).mul_digits(&[5]), Big::from_small(15));\n@@ -132,6 +173,25 @@ fn test_div_rem_small() {\n                (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8));\n }\n \n+#[test]\n+fn test_div_rem() {\n+    fn div_rem(n: u64, d: u64) -> (Big, Big) {\n+        let mut q = Big::from_small(42);\n+        let mut r = Big::from_small(42);\n+        Big::from_u64(n).div_rem(&Big::from_u64(d), &mut q, &mut r);\n+        (q, r)\n+    }\n+    assert_eq!(div_rem(1, 1), (Big::from_small(1), Big::from_small(0)));\n+    assert_eq!(div_rem(4, 3), (Big::from_small(1), Big::from_small(1)));\n+    assert_eq!(div_rem(1, 7), (Big::from_small(0), Big::from_small(1)));\n+    assert_eq!(div_rem(45, 9), (Big::from_small(5), Big::from_small(0)));\n+    assert_eq!(div_rem(103, 9), (Big::from_small(11), Big::from_small(4)));\n+    assert_eq!(div_rem(123456, 77), (Big::from_u64(1603), Big::from_small(25)));\n+    assert_eq!(div_rem(0xffff, 1), (Big::from_u64(0xffff), Big::from_small(0)));\n+    assert_eq!(div_rem(0xeeee, 0xffff), (Big::from_small(0), Big::from_u64(0xeeee)));\n+    assert_eq!(div_rem(2_000_000, 2), (Big::from_u64(1_000_000), Big::from_u64(0)));\n+}\n+\n #[test]\n fn test_is_zero() {\n     assert!(Big::from_small(0).is_zero());\n@@ -141,6 +201,35 @@ fn test_is_zero() {\n     assert!(Big::from_u64(0xffffff).sub(&Big::from_u64(0xffffff)).is_zero());\n }\n \n+#[test]\n+fn test_get_bit() {\n+    let x = Big::from_small(0b1101);\n+    assert_eq!(x.get_bit(0), 1);\n+    assert_eq!(x.get_bit(1), 0);\n+    assert_eq!(x.get_bit(2), 1);\n+    assert_eq!(x.get_bit(3), 1);\n+    let y = Big::from_u64(1 << 15);\n+    assert_eq!(y.get_bit(14), 0);\n+    assert_eq!(y.get_bit(15), 1);\n+    assert_eq!(y.get_bit(16), 0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_get_bit_out_of_range() {\n+    Big::from_small(42).get_bit(24);\n+}\n+\n+#[test]\n+fn test_bit_length() {\n+    assert_eq!(Big::from_small(0).bit_length(), 0);\n+    assert_eq!(Big::from_small(1).bit_length(), 1);\n+    assert_eq!(Big::from_small(5).bit_length(), 3);\n+    assert_eq!(Big::from_small(0x18).bit_length(), 5);\n+    assert_eq!(Big::from_u64(0x4073).bit_length(), 15);\n+    assert_eq!(Big::from_u64(0xffffff).bit_length(), 24);\n+}\n+\n #[test]\n fn test_ord() {\n     assert!(Big::from_u64(0) < Big::from_u64(0xffffff));"}]}