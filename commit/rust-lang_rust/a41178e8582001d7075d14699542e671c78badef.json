{"sha": "a41178e8582001d7075d14699542e671c78badef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTE3OGU4NTgyMDAxZDcwNzVkMTQ2OTk1NDJlNjcxYzc4YmFkZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-19T19:04:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-19T19:04:15Z"}, "message": "Auto merge of #27110 - arthurprs:optintstr, r=Gankro\n\nI wrote a reasonably optimized version for both functions. Further optimizations are possible but I tried to keep the code size small (which I think is important), it's a road of diminished gains.\r\n\r\nThe repository used for testing/benchmarks is https://github.com/arthurprs/rust-optimized-inttostr\r\n\r\nBenchmarks are ran for 3 different distributions, bellow are string length histograms for the u32 type\r\n\r\n* _h (big numbers skew)\r\n[0, 0, 5, 29, 103, 212, 551, 1138, 1887, 3196, 2879]\r\n* _m (slight small number skew):\r\n[0, 2807, 1334, 1057, 905, 821, 772, 707, 627, 605, 365]\r\n* _l (small numbers skew):\r\n[0, 8004, 567, 351, 248, 212, 170, 126, 136, 112, 74]\r\n\r\nTested processors are\r\n* x64 laptop (i7-2670QM)\r\n* x32 server (Digital Ocean E5-2630L-v2)\r\n\r\n### Display\r\n\r\nIt uses a small look up table (200 bytes) and decode up to 4 characters at a time. I also took special precautions to reduce 64bit arithmetic on 32bit architectures and the gains are huge in these cases.\r\n\r\nOverall, on modern 64bit CPUs it's pretty much the same speed as the stdlib implementation for very small numbers (0..99), but pulls ahead as the length of the decimal increases. On slight older CPUs (w/ worse ALUs) or 32bit architectures it's pretty much always faster.\r\n\r\nx64 benchmarks\r\n```\r\ntest bench::display_h_new_u08     ... bench:      71,041 ns/iter (+/- 2,894)\r\ntest bench::display_h_new_u16     ... bench:     378,255 ns/iter (+/- 36,547)\r\ntest bench::display_h_new_u32     ... bench:   4,232,483 ns/iter (+/- 509,661)\r\ntest bench::display_h_new_u64     ... bench:   5,166,740 ns/iter (+/- 421,124)\r\ntest bench::display_h_stdlib_u08  ... bench:      73,536 ns/iter (+/- 5,287)\r\ntest bench::display_h_stdlib_u16  ... bench:     451,443 ns/iter (+/- 16,879)\r\ntest bench::display_h_stdlib_u32  ... bench:   5,551,070 ns/iter (+/- 518,151)\r\ntest bench::display_h_stdlib_u64  ... bench:   8,624,374 ns/iter (+/- 643,701)\r\ntest bench::display_l_new_u08     ... bench:      71,547 ns/iter (+/- 504)\r\ntest bench::display_l_new_u16     ... bench:     399,727 ns/iter (+/- 28,030)\r\ntest bench::display_l_new_u32     ... bench:   4,365,303 ns/iter (+/- 414,414)\r\ntest bench::display_l_new_u64     ... bench:   5,302,382 ns/iter (+/- 292,324)\r\ntest bench::display_l_stdlib_u08  ... bench:      75,445 ns/iter (+/- 2,487)\r\ntest bench::display_l_stdlib_u16  ... bench:     444,313 ns/iter (+/- 16,203)\r\ntest bench::display_l_stdlib_u32  ... bench:   5,761,801 ns/iter (+/- 387,186)\r\ntest bench::display_l_stdlib_u64  ... bench:   8,790,365 ns/iter (+/- 614,846)\r\ntest bench::display_m_new_u08     ... bench:      71,820 ns/iter (+/- 2,956)\r\ntest bench::display_m_new_u16     ... bench:     399,649 ns/iter (+/- 20,643)\r\ntest bench::display_m_new_u32     ... bench:   4,355,561 ns/iter (+/- 179,189)\r\ntest bench::display_m_new_u64     ... bench:   5,070,594 ns/iter (+/- 341,950)\r\ntest bench::display_m_stdlib_u08  ... bench:      74,900 ns/iter (+/- 1,909)\r\ntest bench::display_m_stdlib_u16  ... bench:     448,788 ns/iter (+/- 20,791)\r\ntest bench::display_m_stdlib_u32  ... bench:   5,717,939 ns/iter (+/- 316,824)\r\ntest bench::display_m_stdlib_u64  ... bench:   8,787,160 ns/iter (+/- 482,864)\r\n```\r\n\r\nx86 benchmarks\r\n```\r\ntest bench::display_h_new_u08     ... bench:      94,246 ns/iter (+/- 34,872)\r\ntest bench::display_h_new_u16     ... bench:     533,805 ns/iter (+/- 22,499)\r\ntest bench::display_h_new_u32     ... bench:   6,127,747 ns/iter (+/- 2,192,789)\r\ntest bench::display_h_new_u64     ... bench:  14,994,203 ns/iter (+/- 1,609,345)\r\ntest bench::display_h_stdlib_u08  ... bench:     107,233 ns/iter (+/- 8,571)\r\ntest bench::display_h_stdlib_u16  ... bench:     631,186 ns/iter (+/- 11,332)\r\ntest bench::display_h_stdlib_u32  ... bench:   7,696,344 ns/iter (+/- 957,917)\r\ntest bench::display_h_stdlib_u64  ... bench:  45,677,401 ns/iter (+/- 4,991,344)\r\ntest bench::display_l_new_u08     ... bench:      95,855 ns/iter (+/- 27,735)\r\ntest bench::display_l_new_u16     ... bench:     532,084 ns/iter (+/- 40,479)\r\ntest bench::display_l_new_u32     ... bench:   5,973,953 ns/iter (+/- 211,676)\r\ntest bench::display_l_new_u64     ... bench:  14,773,064 ns/iter (+/- 1,276,579)\r\ntest bench::display_l_stdlib_u08  ... bench:     106,350 ns/iter (+/- 63,963)\r\ntest bench::display_l_stdlib_u16  ... bench:     637,746 ns/iter (+/- 101,005)\r\ntest bench::display_l_stdlib_u32  ... bench:   7,740,640 ns/iter (+/- 848,478)\r\ntest bench::display_l_stdlib_u64  ... bench:  44,846,932 ns/iter (+/- 4,514,694)\r\ntest bench::display_m_new_u08     ... bench:      94,549 ns/iter (+/- 13,029)\r\ntest bench::display_m_new_u16     ... bench:     546,030 ns/iter (+/- 35,804)\r\ntest bench::display_m_new_u32     ... bench:   5,983,924 ns/iter (+/- 1,180,559)\r\ntest bench::display_m_new_u64     ... bench:  14,817,873 ns/iter (+/- 2,271,464)\r\ntest bench::display_m_stdlib_u08  ... bench:     107,806 ns/iter (+/- 8,805)\r\ntest bench::display_m_stdlib_u16  ... bench:     630,714 ns/iter (+/- 6,586)\r\ntest bench::display_m_stdlib_u32  ... bench:   7,784,210 ns/iter (+/- 358,601)\r\ntest bench::display_m_stdlib_u64  ... bench:  46,223,927 ns/iter (+/- 6,553,176)\r\n```\r\n\r\n### from_str_radix (FromStr)\r\n\r\nAll valid digits are ascii so I modified the function to use the underlining bytes instead and simplified the match to avoid wasting cycles.\r\n\r\nx64 benchmarks\r\n```\r\ntest bench::from_str_h_new_u08    ... bench:      28,153 ns/iter (+/- 624)\r\ntest bench::from_str_h_new_u16    ... bench:     223,513 ns/iter (+/- 11,554)\r\ntest bench::from_str_h_new_u32    ... bench:   3,098,935 ns/iter (+/- 231,022)\r\ntest bench::from_str_h_new_u64    ... bench:   5,009,900 ns/iter (+/- 341,961)\r\ntest bench::from_str_h_stdlib_u08 ... bench:      34,033 ns/iter (+/- 2,068)\r\ntest bench::from_str_h_stdlib_u16 ... bench:     248,785 ns/iter (+/- 14,208)\r\ntest bench::from_str_h_stdlib_u32 ... bench:   4,150,536 ns/iter (+/- 266,070)\r\ntest bench::from_str_h_stdlib_u64 ... bench:   6,817,997 ns/iter (+/- 449,838)\r\ntest bench::from_str_l_new_u08    ... bench:      27,552 ns/iter (+/- 1,500)\r\ntest bench::from_str_l_new_u16    ... bench:     234,360 ns/iter (+/- 13,144)\r\ntest bench::from_str_l_new_u32    ... bench:   3,140,261 ns/iter (+/- 248,175)\r\ntest bench::from_str_l_new_u64    ... bench:   5,176,583 ns/iter (+/- 350,416)\r\ntest bench::from_str_l_stdlib_u08 ... bench:      35,060 ns/iter (+/- 2,154)\r\ntest bench::from_str_l_stdlib_u16 ... bench:     252,135 ns/iter (+/- 23,461)\r\ntest bench::from_str_l_stdlib_u32 ... bench:   4,154,599 ns/iter (+/- 369,606)\r\ntest bench::from_str_l_stdlib_u64 ... bench:   6,892,767 ns/iter (+/- 213,030)\r\ntest bench::from_str_m_new_u08    ... bench:      28,252 ns/iter (+/- 1,384)\r\ntest bench::from_str_m_new_u16    ... bench:     231,051 ns/iter (+/- 16,540)\r\ntest bench::from_str_m_new_u32    ... bench:   3,166,504 ns/iter (+/- 134,418)\r\ntest bench::from_str_m_new_u64    ... bench:   5,103,195 ns/iter (+/- 218,912)\r\ntest bench::from_str_m_stdlib_u08 ... bench:      35,012 ns/iter (+/- 2,735)\r\ntest bench::from_str_m_stdlib_u16 ... bench:     250,967 ns/iter (+/- 14,708)\r\ntest bench::from_str_m_stdlib_u32 ... bench:   4,101,845 ns/iter (+/- 205,802)\r\ntest bench::from_str_m_stdlib_u64 ... bench:   6,823,001 ns/iter (+/- 267,215)\r\n```\r\n\r\nx86 benchmarks\r\n```\r\ntest bench::from_str_h_new_u08    ... bench:      23,682 ns/iter (+/- 3,590)\r\ntest bench::from_str_h_new_u16    ... bench:     190,916 ns/iter (+/- 29,688)\r\ntest bench::from_str_h_new_u32    ... bench:   2,649,952 ns/iter (+/- 308,576)\r\ntest bench::from_str_h_new_u64    ... bench:  23,458,434 ns/iter (+/- 2,327,427)\r\ntest bench::from_str_h_stdlib_u08 ... bench:      45,551 ns/iter (+/- 6,968)\r\ntest bench::from_str_h_stdlib_u16 ... bench:     313,739 ns/iter (+/- 17,175)\r\ntest bench::from_str_h_stdlib_u32 ... bench:   4,615,669 ns/iter (+/- 470,766)\r\ntest bench::from_str_h_stdlib_u64 ... bench:  30,589,482 ns/iter (+/- 2,278,996)\r\ntest bench::from_str_l_new_u08    ... bench:      23,763 ns/iter (+/- 5,545)\r\ntest bench::from_str_l_new_u16    ... bench:     185,472 ns/iter (+/- 33,097)\r\ntest bench::from_str_l_new_u32    ... bench:   2,691,307 ns/iter (+/- 473,886)\r\ntest bench::from_str_l_new_u64    ... bench:  22,952,593 ns/iter (+/- 1,963,742)\r\ntest bench::from_str_l_stdlib_u08 ... bench:      45,285 ns/iter (+/- 16,337)\r\ntest bench::from_str_l_stdlib_u16 ... bench:     313,624 ns/iter (+/- 6,643)\r\ntest bench::from_str_l_stdlib_u32 ... bench:   4,595,679 ns/iter (+/- 1,876,361)\r\ntest bench::from_str_l_stdlib_u64 ... bench:  30,434,683 ns/iter (+/- 1,901,996)\r\ntest bench::from_str_m_new_u08    ... bench:      23,812 ns/iter (+/- 1,505)\r\ntest bench::from_str_m_new_u16    ... bench:     185,553 ns/iter (+/- 19,788)\r\ntest bench::from_str_m_new_u32    ... bench:   2,614,920 ns/iter (+/- 66,230)\r\ntest bench::from_str_m_new_u64    ... bench:  23,241,778 ns/iter (+/- 3,474,077)\r\ntest bench::from_str_m_stdlib_u08 ... bench:      45,634 ns/iter (+/- 1,436)\r\ntest bench::from_str_m_stdlib_u16 ... bench:     316,479 ns/iter (+/- 21,212)\r\ntest bench::from_str_m_stdlib_u32 ... bench:   4,609,147 ns/iter (+/- 487,068)\r\ntest bench::from_str_m_stdlib_u64 ... bench:  30,165,173 ns/iter (+/- 1,601,830)\r\n```", "tree": {"sha": "7ffad34373a0def71355ad8535c14de1dc864f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ffad34373a0def71355ad8535c14de1dc864f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41178e8582001d7075d14699542e671c78badef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41178e8582001d7075d14699542e671c78badef", "html_url": "https://github.com/rust-lang/rust/commit/a41178e8582001d7075d14699542e671c78badef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41178e8582001d7075d14699542e671c78badef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58fb9b5c2d2f45b95866171720244edc1d06cde2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58fb9b5c2d2f45b95866171720244edc1d06cde2", "html_url": "https://github.com/rust-lang/rust/commit/58fb9b5c2d2f45b95866171720244edc1d06cde2"}, {"sha": "c073f81920bc2324b026cf9610a096df0d97c6a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c073f81920bc2324b026cf9610a096df0d97c6a5", "html_url": "https://github.com/rust-lang/rust/commit/c073f81920bc2324b026cf9610a096df0d97c6a5"}], "stats": {"total": 135, "additions": 120, "deletions": 15}, "files": [{"sha": "a098840c77a51a55cc3a26c458d84df260b8216d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a41178e8582001d7075d14699542e671c78badef/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41178e8582001d7075d14699542e671c78badef/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a41178e8582001d7075d14699542e671c78badef", "patch": "@@ -20,18 +20,25 @@ use fmt;\n use num::Zero;\n use ops::{Div, Rem, Sub};\n use str;\n+use slice;\n+use ptr;\n+use mem;\n \n #[doc(hidden)]\n trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n            Sub<Output=Self> + Copy {\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n+    fn to_u32(&self) -> u32;\n+    fn to_u64(&self) -> u64;\n }\n \n macro_rules! doit {\n     ($($t:ident)*) => ($(impl Int for $t {\n         fn from_u8(u: u8) -> $t { u as $t }\n         fn to_u8(&self) -> u8 { *self as u8 }\n+        fn to_u32(&self) -> u32 { *self as u32 }\n+        fn to_u64(&self) -> u64 { *self as u64 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n@@ -188,6 +195,7 @@ macro_rules! radix_fmt {\n         }\n     }\n }\n+\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -209,17 +217,16 @@ macro_rules! debug {\n         }\n     }\n }\n+\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base! { Display  for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n         radix_fmt! { $Int as $Int, fmt_int }\n         debug! { $Int }\n \n-        int_base! { Display  for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n@@ -233,3 +240,80 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+\n+const DEC_DIGITS_LUT: &'static[u8] =\n+    b\"0001020304050607080910111213141516171819\\\n+      2021222324252627282930313233343536373839\\\n+      4041424344454647484950515253545556575859\\\n+      6061626364656667686970717273747576777879\\\n+      8081828384858687888990919293949596979899\";\n+\n+macro_rules! impl_Display {\n+    ($($t:ident),*: $conv_fn:ident) => ($(\n+    impl fmt::Display for $t {\n+        #[allow(unused_comparisons)]\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let is_positive = *self >= 0;\n+            let mut n = if is_positive {\n+                self.$conv_fn()\n+            } else {\n+                // convert the negative num to positive by summing 1 to it's 2 complement\n+                (!self.$conv_fn()).wrapping_add(1)\n+            };\n+            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut curr = buf.len() as isize;\n+            let buf_ptr = buf.as_mut_ptr();\n+            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+\n+            unsafe {\n+                // eagerly decode 4 characters at a time\n+                if <$t>::max_value() as u64 >= 10000 {\n+                    while n >= 10000 {\n+                        let rem = (n % 10000) as isize;\n+                        n /= 10000;\n+\n+                        let d1 = (rem / 100) << 1;\n+                        let d2 = (rem % 100) << 1;\n+                        curr -= 4;\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    }\n+                }\n+\n+                // if we reach here numbers are <= 9999, so at most 4 chars long\n+                let mut n = n as isize; // possibly reduce 64bit math\n+\n+                // decode 2 more chars, if > 2 chars\n+                if n >= 100 {\n+                    let d1 = (n % 100) << 1;\n+                    n /= 100;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+\n+                // decode last 1 or 2 chars\n+                if n < 10 {\n+                    curr -= 1;\n+                    *buf_ptr.offset(curr) = (n as u8) + 48;\n+                } else {\n+                    let d1 = n << 1;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+            }\n+\n+            let buf_slice = unsafe {\n+                str::from_utf8_unchecked(\n+                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+            };\n+            f.pad_integral(is_positive, \"\", buf_slice)\n+        }\n+    })*);\n+}\n+\n+impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n+impl_Display!(i64, u64: to_u64);\n+#[cfg(target_pointer_width = \"32\")]\n+impl_Display!(isize, usize: to_u32);\n+#[cfg(target_pointer_width = \"64\")]\n+impl_Display!(isize, usize: to_u64);"}, {"sha": "bfbb2ded0782dbf4e177d35b00cca42e70e581e2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a41178e8582001d7075d14699542e671c78badef/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41178e8582001d7075d14699542e671c78badef/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a41178e8582001d7075d14699542e671c78badef", "patch": "@@ -24,6 +24,7 @@ use mem::size_of;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n+use slice::SliceExt;\n \n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n@@ -1448,19 +1449,30 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                                          -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n     use self::ParseIntError as PIE;\n+\n     assert!(radix >= 2 && radix <= 36,\n            \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n            radix);\n \n+    if src.is_empty() {\n+        return Err(PIE { kind: Empty });\n+    }\n+\n     let is_signed_ty = T::from_u32(0) > T::min_value();\n \n-    match src.slice_shift_char() {\n-        Some(('-', \"\")) => Err(PIE { kind: Empty }),\n-        Some(('-', src)) if is_signed_ty => {\n+    // all valid digits are ascii, so we will just iterate over the utf8 bytes\n+    // and cast them to chars. .to_digit() will safely return None for anything\n+    // other than a valid ascii digit for a the given radix, including the first-byte\n+    // of multi-byte sequences\n+    let src = src.as_bytes();\n+\n+    match (src[0], &src[1..])  {\n+        (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),\n+        (b'-', digits) if is_signed_ty => {\n             // The number is negative\n             let mut result = T::from_u32(0);\n-            for c in src.chars() {\n-                let x = match c.to_digit(radix) {\n+            for &c in digits {\n+                let x = match (c as char).to_digit(radix) {\n                     Some(x) => x,\n                     None => return Err(PIE { kind: InvalidDigit }),\n                 };\n@@ -1475,11 +1487,14 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n             }\n             Ok(result)\n         },\n-        Some((_, _)) => {\n+        (c, digits) => {\n             // The number is signed\n-            let mut result = T::from_u32(0);\n-            for c in src.chars() {\n-                let x = match c.to_digit(radix) {\n+            let mut result = match (c as char).to_digit(radix) {\n+                Some(x) => T::from_u32(x),\n+                None => return Err(PIE { kind: InvalidDigit }),\n+            };\n+            for &c in digits {\n+                let x = match (c as char).to_digit(radix) {\n                     Some(x) => x,\n                     None => return Err(PIE { kind: InvalidDigit }),\n                 };\n@@ -1493,8 +1508,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                 };\n             }\n             Ok(result)\n-        },\n-        None => Err(ParseIntError { kind: Empty }),\n+        }\n     }\n }\n "}, {"sha": "a9baa2cc477f6c326923888cb80bfa3bc162eb05", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a41178e8582001d7075d14699542e671c78badef/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41178e8582001d7075d14699542e671c78badef/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=a41178e8582001d7075d14699542e671c78badef", "patch": "@@ -117,7 +117,14 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_int_from_minus_sign() {\n-        assert_eq!(\"-\".parse::<i32>().ok(), None);\n+    fn test_invalid() {\n+        assert_eq!(\"--129\".parse::<i8>().ok(), None);\n+        assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+    }\n+\n+    #[test]\n+    fn test_empty() {\n+        assert_eq!(\"-\".parse::<i8>().ok(), None);\n+        assert_eq!(\"\".parse::<u8>().ok(), None);\n     }\n }"}]}