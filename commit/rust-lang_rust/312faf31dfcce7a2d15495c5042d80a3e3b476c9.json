{"sha": "312faf31dfcce7a2d15495c5042d80a3e3b476c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMmZhZjMxZGZjY2U3YTJkMTU0OTVjNTA0MmQ4MGEzZTNiNDc2Yzk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-21T23:44:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-21T23:44:10Z"}, "message": "Tag all remaining FIXMEs with bugs. Install rule in tidy script to enforce this.", "tree": {"sha": "4ad8383191907b5cb148291a2d1dbc078f590eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad8383191907b5cb148291a2d1dbc078f590eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/312faf31dfcce7a2d15495c5042d80a3e3b476c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/312faf31dfcce7a2d15495c5042d80a3e3b476c9", "html_url": "https://github.com/rust-lang/rust/commit/312faf31dfcce7a2d15495c5042d80a3e3b476c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/312faf31dfcce7a2d15495c5042d80a3e3b476c9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57101780811490fa759ed1dca310c405d28c0a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/57101780811490fa759ed1dca310c405d28c0a72", "html_url": "https://github.com/rust-lang/rust/commit/57101780811490fa759ed1dca310c405d28c0a72"}], "stats": {"total": 939, "additions": 460, "deletions": 479}, "files": [{"sha": "a33f05a95f60151584462fa4679ac3368c4bfe8d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -165,8 +165,8 @@ fn test_is_uuid() {\n     assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n }\n \n-// FIXME: implement url/URL parsing so we don't have to resort to weak checks\n-// (#2661)\n+// FIXME (#2661): implement url/URL parsing so we don't have to resort\n+// to weak checks\n \n fn has_archive_extension(p: str) -> bool {\n     str::ends_with(p, \".tar\") ||\n@@ -189,8 +189,8 @@ fn is_archive_path(u: str) -> bool {\n }\n \n fn is_archive_url(u: str) -> bool {\n-    // FIXME: this requires the protocol bit - if we had proper url parsing,\n-    // we wouldn't need it (#2661)\n+    // FIXME (#2661): this requires the protocol bit - if we had proper\n+    // url parsing, we wouldn't need it\n \n     alt str::find_str(u, \"://\") {\n         option::some(i) { has_archive_extension(u) }\n@@ -957,9 +957,10 @@ fn cmd_uninstall(c: cargo) {\n     let bin = c.bindir;\n     let target = c.opts.free[2u];\n \n-    // FIXME: needs stronger pattern matching\n-    // FIXME: needs to uninstall from a specified location in a cache instead\n-    // of looking for it (binaries can be uninstalled by name only) (#2662)\n+    // FIXME (#2662): needs stronger pattern matching\n+    // FIXME (#2662): needs to uninstall from a specified location in a\n+    // cache instead of looking for it (binaries can be uninstalled by\n+    // name only)\n     if is_uuid(target) {\n         for os::list_dir(lib).each { |file|\n             alt str::find_str(file, \"-\" + target + \"-\") {\n@@ -1060,9 +1061,9 @@ fn install_query(c: cargo, wd: str, target: str) {\n         }\n     }\n \n-    // FIXME: This whole dep_cache and current_install\n-    // thing is a bit of a hack. It should be cleaned up in the future.\n-    // #2662\n+    // FIXME (#2662): This whole dep_cache and current_install thing is\n+    // a bit of a hack. It should be cleaned up in the future.\n+\n     if target == c.current_install {\n         for c.dep_cache.each { |k, _v|\n             c.dep_cache.remove(k);\n@@ -1895,7 +1896,7 @@ fn main(argv: [str]) {\n     if !first_time && o.free[1] != \"init\" {\n         cmd_init(c);\n \n-        // FIXME: shouldn't need to reconfigure (#2662)\n+        // FIXME (#2662): shouldn't need to reconfigure\n         c = configure(o);\n     }\n "}, {"sha": "354d966c2ccd247142288cd8d612ce6b919cecd2", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -32,7 +32,7 @@ fn target_env(_lib_path: str, _prog: str) -> [(str,str)] {\n }\n \n \n-// FIXME: This code is duplicated in core::run::program_output (#2659)\n+// FIXME (#2659): This code is duplicated in core::run::program_output\n fn run(lib_path: str,\n        prog: str,\n        args: [str],"}, {"sha": "7d390c8c9aafb4bd3604f7e27fe3da460184f192", "filename": "src/etc/get-snapshot.py", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Fget-snapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Fget-snapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fget-snapshot.py?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -8,11 +8,7 @@ def unpack_snapshot(triple, dl_path):\n   tar = tarfile.open(dl_path)\n   kernel = get_kernel(triple)\n   for p in tar.getnames():\n-\n-    # FIXME: Fix this once win32 snapshot globs are fixed.\n-    name = p.replace(\"rust-stage0/stage3/\", \"\", 1);\n-    name = name.replace(\"rust-stage0/\", \"\", 1);\n-\n+    name = p.replace(\"rust-stage0/\", \"\", 1);\n     stagep = os.path.join(triple, \"stage0\")\n     fp = os.path.join(stagep, name)\n     print(\"extracting \" + p)"}, {"sha": "780ba4282094163a1a455d2cd0c10a4628a4fdfd", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -183,7 +183,7 @@ def in_tar_name(fn):\n     shutil.move(file0, file1)\n \n     if flag == \"install\":\n-      # FIXME this is an ugly quick hack; pls make it better\n+      # FIXME (#2664): this is an ugly quick hack; pls make it better\n       path  = file1\n       comps = path.split(\"-\")\n       parts = { 'year': comps[2], \\"}, {"sha": "51e13e7af19d6051545d522c4c39eb861c4eb201", "filename": "src/etc/tidy.py", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env python\n \n-import sys, fileinput, subprocess\n+import sys, fileinput, subprocess, re\n \n err=0\n cols=78\n@@ -23,6 +23,11 @@ def report_err(s):\n try:\n     for line in fileinput.input(file_names,\n                                 openhook=fileinput.hook_encoded(\"utf-8\")):\n+\n+        if fileinput.filename().find(\"tidy.py\") == -1:\n+            if line.find(\"FIXME\") != -1:\n+                if re.search(\"FIXME.*#\\d+\", line) == None:\n+                    report_err(\"FIXME without issue number\")\n         if (line.find('\\t') != -1 and\n             fileinput.filename().find(\"Makefile\") == -1):\n             report_err(\"tab character\")"}, {"sha": "fbb434d8e4b5cd83e121d6f1fd9a5f0e160aad19", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -2,8 +2,8 @@ export c_float;\n export c_double;\n \n // uncomment once #1433 is fixed\n-// FIXME export c_float_math_consts;\n-// FIXME export c_double_math_consts;\n+// FIXME (#1433): export c_float_math_consts;\n+// FIXME (#1433): export c_double_math_consts;\n \n export c_float_targ_consts;\n export c_double_targ_consts;\n@@ -68,8 +68,7 @@ native mod c_double {\n     #[link_name=\"ilogb\"] pure fn ilog_radix(n: c_double) -> c_int;\n     pure fn modf(n: c_double, &iptr: c_double) -> c_double;\n     pure fn pow(n: c_double, e: c_double) -> c_double;\n-// FIXME enable when rounding modes become available\n-// (See Issue #1379)\n+// FIXME (#1379): enable when rounding modes become available\n //    pure fn rint(n: c_double) -> c_double;\n     pure fn round(n: c_double) -> c_double;\n     // rename: for consistency with logradix\n@@ -149,8 +148,7 @@ native mod c_float {\n     #[link_name=\"modff\"] pure fn modf(n: c_float,\n                                       &iptr: c_float) -> c_float;\n     #[link_name=\"powf\"] pure fn pow(n: c_float, e: c_float) -> c_float;\n-// FIXME enable when rounding modes become available\n-// (See Issue #1379)\n+// FIXME (#1379): enable when rounding modes become available\n //    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n     #[link_name=\"roundf\"] pure fn round(n: c_float) -> c_float;\n     #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int)\n@@ -176,8 +174,8 @@ mod c_float_targ_consts {\n     const max_exp: uint = 128u;\n     const min_10_exp: int = -37;\n     const max_10_exp: int = 38;\n-    // FIXME this is wrong! replace with hexadecimal (%a) constants below\n-    // (see Issue #1433)\n+    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) constants\n+    // below.\n     const min_value: f32 = 1.175494e-38_f32;\n     const max_value: f32 = 3.402823e+38_f32;\n     const epsilon: f32 = 0.000000_f32;\n@@ -191,8 +189,8 @@ mod c_double_targ_consts {\n     const max_exp: uint = 1024u;\n     const min_10_exp: int = -307;\n     const max_10_exp: int = 308;\n-    // FIXME this is wrong! replace with hexadecimal (%a) constants below\n-    // (see Issue #1433)\n+    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) constants\n+    // below.\n     const min_value: f64 = 2.225074e-308_f64;\n     const max_value: f64 = 1.797693e+308_f64;\n     const epsilon: f64 = 2.220446e-16_f64;"}, {"sha": "8f4b301adaf2e7f58b4acc38c66e5b48e42881b2", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -50,9 +50,9 @@ export num;\n // NDM seems to be necessary for resolve to work\n export option_iter;\n \n-// FIXME: This creates some APIs that I do not want to commit to. It is\n-// currently exported for the uv code in std, but when that code moves into\n-// core this should become unexported\n+// FIXME (#2648): This creates some APIs that I do not want to commit\n+// to. It is currently exported for the uv code in std, but when that\n+// code moves into core this should become unexported\n export priv;\n \n "}, {"sha": "144ea571d7c5931394f5af635ce3891b215e78ad", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -274,8 +274,8 @@ mod rt {\n     enum count { count_is(int), count_implied, }\n     enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n \n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag (see Issue #1993)\n+    // FIXME (#1993): May not want to use a vector here for flags; instead\n+    // just use a bool per flag.\n     type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n     fn conv_int(cv: conv, i: int) -> str {"}, {"sha": "821fa68f55c7774c09727d3b47204f41d16842d8", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -6,8 +6,6 @@ import cmath::c_float::*;\n import cmath::c_float_targ_consts::*;\n import num::num;\n \n-// FIXME find out why these have to be exported explicitly\n-\n export add, sub, mul, div, rem, lt, le, gt, eq, eq, ne;\n export is_positive, is_negative, is_nonpositive, is_nonnegative;\n export is_zero, is_infinite, is_finite;\n@@ -55,9 +53,8 @@ pure fn ge(x: f32, y: f32) -> bool { ret x >= y; }\n \n pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n \n-// FIXME replace the predicates below with llvm intrinsics or calls\n-// to the libmath macros in the rust runtime for performance\n-// See Issue #1999\n+// FIXME (#1999): replace the predicates below with llvm intrinsics or\n+// calls to the libmath macros in the rust runtime for performance.\n \n #[doc = \"\n Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n@@ -106,14 +103,13 @@ pure fn is_finite(x: f32) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n \n-// FIXME add is_normal, is_subnormal, and fpclassify\n-// also see Issue #1999\n+// FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n@@ -167,9 +163,8 @@ pure fn logarithm(n: f32, b: f32) -> f32 {\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f32, b: f32) -> f32 {\n-    // FIXME check if it is good to use log2 instead of ln here;\n+    // FIXME (#2000): check if it is good to use log2 instead of ln here;\n     // in theory should be faster since the radix is 2\n-    // See Issue #2000\n     ret ln(n) / ln(b);\n }\n "}, {"sha": "066b1b818c7d218acde74677eb167f699a0f579b", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -29,8 +29,7 @@ export num;\n \n // PORT check per architecture\n \n-// FIXME obtain these in a different way\n-// (perhaps related to Issue #1433)\n+// FIXME (#1433): obtain these in a different way\n \n const radix: uint = 2u;\n \n@@ -127,14 +126,13 @@ pure fn is_finite(x: f64) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n \n-// FIXME add is_normal, is_subnormal, and fpclassify\n-// also see Issue #1999\n+// FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n@@ -188,9 +186,8 @@ pure fn logarithm(n: f64, b: f64) -> f64 {\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f64, b: f64) -> f64 {\n-    // FIXME check if it is good to use log2 instead of ln here;\n-    // in theory should be faster since the radix is 2\n-    // See Issue #2000\n+    // FIXME (#2000): check if it is good to use log2 instead of ln here; in\n+    // theory should be faster since the radix is 2\n     ret ln(n) / ln(b);\n }\n "}, {"sha": "9c995100273f64872a81b8eff4425c9ec95227f8", "filename": "src/libcore/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -38,8 +38,8 @@ const neg_infinity: float = -1.0/0.0;\n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: float = 3.14159265358979323846264338327950288;\n "}, {"sha": "635b3f9ebf41f2fc1da1b5ff0f61dcfb639bcd79", "filename": "src/libcore/io.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -22,14 +22,14 @@ native mod rustrt {\n \n // Reading\n \n-// FIXME This is all buffered. We might need an unbuffered variant as well\n-// #2004\n+// FIXME (#2004): This is all buffered. We might need an unbuffered variant\n+// as well\n enum seek_style { seek_set, seek_end, seek_cur, }\n \n \n // The raw underlying reader iface. All readers must implement this.\n iface reader {\n-    // FIXME: Seekable really should be orthogonal. // #2004\n+    // FIXME (#2004): Seekable really should be orthogonal.\n     fn read_bytes(uint) -> [u8];\n     fn read_byte() -> int;\n     fn unread_byte(int);\n@@ -82,8 +82,8 @@ impl reader_util for reader {\n         while nbread > 0u {\n             let data = self.read_bytes(nbread);\n             if vec::len(data) == 0u {\n-                // eof - FIXME should we do something if\n-                // we're split in a unicode char? // #2004\n+                // eof - FIXME (#2004): should we do something if\n+                // we're split in a unicode char?\n                 break;\n             }\n             buf += data;\n@@ -234,9 +234,9 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n     }\n }\n \n-// FIXME: this should either be an iface-less impl, a set of top-level\n-// functions that take a reader, or a set of default methods on reader\n-// (which can then be called reader) // #2004\n+// FIXME (#2004): this should either be an iface-less impl, a set of\n+// top-level functions that take a reader, or a set of default methods on\n+// reader (which can then be called reader)\n \n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n@@ -312,9 +312,8 @@ fn with_str_reader<T>(s: str, f: fn(reader) -> T) -> T {\n // Writing\n enum fileflag { append, create, truncate, no_flag, }\n \n-// FIXME: Seekable really should be orthogonal.\n-// FIXME: eventually u64\n-// #2004\n+// FIXME (#2004): Seekable really should be orthogonal.\n+// FIXME (#2004): eventually u64\n iface writer {\n     fn write([const u8]/&);\n     fn seek(int, seek_style);\n@@ -586,9 +585,9 @@ fn buffered_file_writer(path: str) -> result<writer, str> {\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n-// FIXME it would be great if this could be a const\n-// FIXME why are these different from the way stdin() is implemented?\n-// #2004\n+// FIXME (#2004) it would be great if this could be a const\n+// FIXME (#2004) why are these different from the way stdin() is\n+// implemented?\n fn stdout() -> writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n@@ -670,8 +669,8 @@ fn read_whole_file_str(file: str) -> result<str, str> {\n     })\n }\n \n-// FIXME implement this in a low-level way. Going through the abstractions is\n-// pointless. // #2004\n+// FIXME (#2004): implement this in a low-level way. Going through the\n+// abstractions is pointless.\n fn read_whole_file(file: str) -> result<[u8], str> {\n     result::chain(file_reader(file), { |rdr|\n         result::ok(rdr.read_whole_stream())\n@@ -714,8 +713,8 @@ mod fsync {\n     };\n \n     // fsync file after executing blk\n-    // FIXME find better way to create resources within lifetime of outer res\n-    // #2004\n+    // FIXME (#2004) find better way to create resources within lifetime of\n+    // outer res\n     fn FILE_res_sync(&&file: FILE_res, opt_level: option<level>,\n                   blk: fn(&&res<*libc::FILE>)) {\n         blk(res({"}, {"sha": "070e909c626d18e1af372afae955da15016033f2", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -97,8 +97,8 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ < b {\n-            // FIXME: Not sure if this is successfully optimized to a move\n-            // #2005\n+            // FIXME (#2005): Not sure if this is successfully optimized to\n+            // a move\n             a\n           }\n           _ { some(b) }\n@@ -113,8 +113,8 @@ fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ > b {\n-            // FIXME: Not sure if this is successfully optimized to a move\n-            // #2005\n+            // FIXME (#2005): Not sure if this is successfully optimized to\n+            // a move.\n             a\n           }\n           _ { some(b) }"}, {"sha": "c2679c6956e95d817c1d1986d53fd9e958716071", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -37,8 +37,7 @@ dissolved.\n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code.\n \n-// FIXME: change these to glob-exports when sufficiently supported.\n-// Issue #2006\n+// FIXME (#2006): change these to glob-exports when sufficiently supported.\n \n import types::common::c95::*;\n import types::common::c99::*;\n@@ -79,10 +78,9 @@ import funcs::posix08::unistd::*;\n import funcs::bsd44::*;\n import funcs::extra::*;\n \n-// FIXME: remove these 3 exports (and their uses next door in os::) when\n-// export globs work. They provide access (for now) for os:: to dig around in\n-// the rest of the platform-specific definitions.\n-// Issue #2006\n+// FIXME (#2006): remove these 3 exports (and their uses next door in os::)\n+// when export globs work. They provide access (for now) for os:: to dig\n+// around in the rest of the platform-specific definitions.\n \n export types, funcs, consts;\n "}, {"sha": "9ee7a80fcdaeea5c8de0e608bd43fd24b3d96b43", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -166,8 +166,8 @@ mod global_env {\n             task::set_opts(builder, {\n                 sched:  some({\n                     mode: task::single_threaded,\n-                    // FIXME: This would be a good place to use\n-                    // a very small native stack (#2621)\n+                    // FIXME (#2621): This would be a good place to use a\n+                    // very small native stack\n                     native_stack_size: none\n                 })\n                 with task::get_opts(builder)\n@@ -499,8 +499,8 @@ fn path_exists(p: path) -> bool {\n     }\n }\n \n-// FIXME: under Windows, we should prepend the current drive letter to paths\n-// that start with a slash. #2622\n+// FIXME (#2622): under Windows, we should prepend the current drive letter\n+// to paths that start with a slash.\n #[doc = \"\n Convert a relative path to an absolute path\n \n@@ -696,8 +696,8 @@ fn remove_file(p: path) -> bool {\n \n     #[cfg(windows)]\n     fn unlink(p: path) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n-        // (similar to Issue #2006)\n+        // FIXME (similar to Issue #2006): remove imports when export globs\n+        // work properly.\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;"}, {"sha": "401454c40dfced326c730249106f60f7e99c5d1c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -286,8 +286,8 @@ fn program_output(prog: str, args: [str]) ->\n \n     // Spawn two entire schedulers to read both stdout and sterr\n     // in parallel so we don't deadlock while blocking on one\n-    // or the other. FIXME: Surely there's a much more clever way\n-    // to do this. (#2625)\n+    // or the other. FIXME (#2625): Surely there's a much more\n+    // clever way to do this.\n     let p = comm::port();\n     let ch = comm::chan(p);\n     task::spawn_sched(task::single_threaded) {||"}, {"sha": "dbdd798033ce2750ad648418b8b3bc202c6e98c9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -593,8 +593,8 @@ Section: Comparing strings\n \n #[doc = \"Bytewise string equality\"]\n pure fn eq(&&a: str, &&b: str) -> bool {\n-    // FIXME: This should just be \"a == b\" but that calls into the shape code\n-    // :( (#2627)\n+    // FIXME (#2627): This should just be \"a == b\" but that calls into the\n+    // shape code.\n     let a_len = a.len();\n     let b_len = b.len();\n     if a_len != b_len { ret false; }"}, {"sha": "ab9b4f7d3d7ea8fc4e99df3e14ad2492507d51bf", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -64,8 +64,8 @@ Indicates the manner in which a task exited.\n A task that completes without failing and whose supervised children complete\n without failing is considered to exit successfully.\n \n-FIXME: This description does not indicate the current behavior for linked\n-failure. (See #1868)\n+FIXME (See #1868): This description does not indicate the current behavior\n+for linked failure.\n \"]\n enum task_result {\n     success,\n@@ -275,7 +275,7 @@ fn future_result(builder: builder) -> future::future<task_result> {\n     task.\n     \"];\n \n-    // FIXME (1087, 1857): Once linked failure and notification are\n+    // FIXME (#1087, #1857): Once linked failure and notification are\n     // handled in the library, I can imagine implementing this by just\n     // registering an arbitrary number of task::on_exit handlers and\n     // sending out messages.\n@@ -506,10 +506,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n     let mut f = if opts.supervise {\n         f\n     } else {\n-        // FIXME: The runtime supervision API is weird here because it\n-        // was designed to let the child unsupervise itself, when what\n-        // we actually want is for parents to unsupervise new\n-        // children. (#1868, #1789)\n+        // FIXME (#1868, #1789): The runtime supervision API is weird here\n+        // because it was designed to let the child unsupervise itself,\n+        // when what we actually want is for parents to unsupervise new\n+        // children.\n         fn~() {\n             rustrt::unsupervise();\n             f();\n@@ -529,7 +529,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n     };\n \n     option::iter(opts.notify_chan) {|c|\n-        // FIXME (1087): Would like to do notification in Rust\n+        // FIXME (#1087): Would like to do notification in Rust\n         rustrt::rust_task_config_notify(new_task, c);\n     }\n "}, {"sha": "be491433cd0fc2157c555e88c7983500721b3de3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -173,10 +173,9 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n          0u8,0u8,0u8,0u8,0u8\n          ]/65;\n \n-    // FIXME: post-snapshot, you can do this without\n-    // the raw pointers and unsafe bits, and the\n-    // codegen will prove it's all in-bounds, no\n-    // extra cost.\n+    // FIXME (#2649): post-snapshot, you can do this without the raw\n+    // pointers and unsafe bits, and the codegen will prove it's all\n+    // in-bounds, no extra cost.\n \n     vec::unpack_slice(buf) {|p, len|\n         let mp = p as *mut u8;"}, {"sha": "494470e32e4017df2063839bfb72bc2bf4693598", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -385,7 +385,7 @@ fn shift<T>(&v: [T]) -> T {\n             let mut r <- *vv;\n \n             for uint::range(1u, ln) {|i|\n-                // FIXME: this isn't legal, per se...\n+                // FIXME (#2703): this isn't legal, per se...\n                 let r <- *ptr::offset(vv, i);\n                 push(v, r);\n             }"}, {"sha": "254ed4d4ede42c5ff4fd1e5c2765af51705c6d42", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -16,11 +16,10 @@ export to_vec;\n export to_str;\n export eq_vec;\n \n-// FIXME: With recursive object types, we could implement binary methods like\n-//        union, intersection, and difference. At that point, we could write\n-//        an optimizing version of this module that produces a different obj\n-//        for the case where nbits <= 32.\n-// (Issue #2341)\n+// FIXME (#2341): With recursive object types, we could implement binary\n+// methods like union, intersection, and difference. At that point, we could\n+// write an optimizing version of this module that produces a different obj\n+// for the case where nbits <= 32.\n \n #[doc = \"The bitvector type\"]\n type bitv = @{storage: [mut uint], nbits: uint};"}, {"sha": "f57d2a21af6a41fada5a67d8f14df467ed11cbad", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -14,8 +14,8 @@ iface t<T> {\n     fn get(int) -> T;\n }\n \n-// FIXME eventually, a proper datatype plus an exported impl would be\n-// preferrable (#2343)\n+// FIXME (#2343) eventually, a proper datatype plus an exported impl would\n+// be preferrable.\n fn create<T: copy>() -> t<T> {\n     type cell<T> = option<T>;\n "}, {"sha": "c988b167fd0caf072fec8e13d8dde5745dec7c2c", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -67,8 +67,8 @@ iface map<K, V: copy> {\n     fn each_value(fn(V) -> bool);\n }\n \n-// FIXME: package this up and export it as a datatype usable for\n-// external code that doesn't want to pay the cost of a box. (#2344)\n+// FIXME (#2344): package this up and export it as a datatype usable for\n+// external code that doesn't want to pay the cost of a box.\n mod chained {\n     export t, mk, hashmap;\n "}, {"sha": "64cded848d1abead4f9ff7c53f1925c5d41b7f15", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -36,7 +36,7 @@ fn format_addr(ip: ip_addr) -> str {\n         #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n       ipv6(_, _, _, _, _, _, _, _) {\n-        fail \"FIXME impl parsing of ipv6 addr\";\n+        fail \"FIXME (#2651) impl parsing of ipv6 addr\";\n       }\n     }\n }"}, {"sha": "a2d36ac354b8e893a316ce1f43d0d3ccc449b6e9", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -2,15 +2,12 @@\n High-level interface to libuv's TCP functionality\n \"];\n \n-// FIXME: Fewer import *'s\n import ip = net_ip;\n import uv::iotask;\n import uv::iotask::iotask;\n-import comm::*;\n-import result::*;\n-import str::*;\n-import future::*;\n-import libc::size_t;\n+import comm::methods;\n+import future::future;\n+import result::{result,err,ok,extensions};\n \n // data\n export tcp_socket, tcp_conn_port, tcp_err_data;\n@@ -364,8 +361,8 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n                                                   tcp_err_data>>();\n     let new_conn_ch = comm::chan(new_conn_po);\n-    // FIXME: This shared box should not be captured in the i/o task\n-    // Make it a unique pointer.\n+    // FIXME (#2656): This shared box should not be captured in the i/o\n+    // task Make it a unique pointer.\n     let server_data: @tcp_conn_port_data = @{\n         server_stream: uv::ll::tcp_t(),\n         stream_closed_po: stream_closed_po,\n@@ -946,10 +943,10 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n           }\n         }\n     };\n-    // FIXME: Instead of passing unsafe pointers to local data, and waiting\n-    // here for the write to complete, we should transfer ownership of\n-    // everything to the I/O task and let it deal with the aftermath,\n-    // so we don't have to sit here blocking.\n+    // FIXME (#2656): Instead of passing unsafe pointers to local data,\n+    // and waiting here for the write to complete, we should transfer\n+    // ownership of everything to the I/O task and let it deal with the\n+    // aftermath, so we don't have to sit here blocking.\n     alt comm::recv(result_po) {\n       tcp_write_success { result::ok(()) }\n       tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n@@ -1191,20 +1188,16 @@ crust fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     let write_data_ptr = uv::ll::get_data_for_req(write_req)\n         as *write_req_data;\n-    // FIXME: if instead of alt\n-    alt status {\n-      0i32 {\n+    if status == 0i32 {\n         log(debug, \"successful write complete\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_success);\n-      }\n-      _ {\n+    } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, \"failure to write\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_error(err_data));\n-      }\n     }\n }\n \n@@ -1273,20 +1266,20 @@ type tcp_socket_data = {\n // convert rust ip_addr to libuv's native representation\n fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n                                port: uint) -> uv::ll::sockaddr_in unsafe {\n-    // FIXME ipv6\n+    // FIXME (#2656): ipv6\n     alt input_ip {\n       ip::ipv4(_,_,_,_) {\n         uv::ll::ip4_addr(ip::format_addr(input_ip), port as int)\n       }\n       ip::ipv6(_,_,_,_,_,_,_,_) {\n-        fail \"FIXME ipv6 not yet supported\";\n+        fail \"FIXME (#2656) ipv6 not yet supported\";\n       }\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    // FIXME don't run on fbsd or linux 32 bit(#2064)\n+    // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]"}, {"sha": "89e9d0338fe4eedef027e7fe0408c2f8a23428ed", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -6,8 +6,8 @@ import core::option;\n import core::option::{some, none};\n import dvec::{dvec, extensions};\n \n-// FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n-// to be. (#2347)\n+// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n+// requires this to be.\n type smallintmap<T: copy> = @{v: dvec<option<T>>};\n \n #[doc = \"Create a smallintmap\"]"}, {"sha": "d06749b57576326b6224a45e34d6857d487567d4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -319,15 +319,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 .chain { |pos| parse_type(s, pos, 'd', tm) }\n           }\n           'H' {\n-            // FIXME: range check. (#2350 -- same issue for all FIXMEs in this\n-            // file.)\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n           }\n           'I' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                   let (v, pos) = item;\n@@ -338,7 +337,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'j' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 3u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -349,14 +348,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'k' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n           }\n           'l' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n               some(item) {\n                   let (v, pos) = item;\n@@ -367,14 +366,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'M' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n               none { err(\"Invalid minute\") }\n             }\n           }\n           'm' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -412,7 +411,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 .chain { |pos| parse_type(s, pos, 'p', tm) }\n           }\n           'S' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -432,7 +431,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           't' { parse_char(s, pos, '\\t') }\n           'u' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -451,7 +450,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           //'W' {}\n           'w' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n               none { err(\"Invalid weekday\") }\n@@ -460,7 +459,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           //'X' {}\n           //'x' {}\n           'Y' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 4u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -471,7 +470,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'y' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -584,7 +583,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n \n fn strftime(format: str, tm: tm) -> str {\n     fn parse_type(ch: char, tm: tm) -> str {\n-        //FIXME: Implement missing types.\n+        //FIXME (#2350): Implement missing types.\n         alt check ch {\n           'A' {\n             alt check tm.tm_wday as int {\n@@ -915,7 +914,7 @@ mod tests {\n         assert local.tm_isdst == 0_i32;\n         assert local.tm_gmtoff == -28800_i32;\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.tm_zone;\n         assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n@@ -1063,8 +1062,8 @@ mod tests {\n         assert test(\"2009-02-13\", \"%F\");\n         assert test(\"03\", \"%H\");\n         assert test(\"13\", \"%H\");\n-        assert test(\"03\", \"%I\"); // FIXME: flesh out\n-        assert test(\"11\", \"%I\"); // FIXME: flesh out\n+        assert test(\"03\", \"%I\"); // FIXME (#2350): flesh out\n+        assert test(\"11\", \"%I\"); // FIXME (#2350): flesh out\n         assert test(\"044\", \"%j\");\n         assert test(\" 3\", \"%k\");\n         assert test(\"13\", \"%k\");\n@@ -1162,15 +1161,15 @@ mod tests {\n         assert local.strftime(\"%Y\") == \"2009\";\n         assert local.strftime(\"%y\") == \"09\";\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(\"%Z\");\n         assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n \n         assert local.strftime(\"%z\") == \"-0800\";\n         assert local.strftime(\"%%\") == \"%\";\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n         let prefix = \"Fri, 13 Feb 2009 15:31:30 \";"}, {"sha": "b7e1ee7d82cdb5d99e79157eb8bcee1d326cb92b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -505,7 +505,7 @@ native mod rustrt {\n                            tcp_handle_ptr: *uv_tcp_t,\n                            ++after_cb: *u8,\n                            ++addr: *sockaddr_in) -> libc::c_int;\n-    // FIXME ref 2064\n+    // FIXME ref #2064\n     fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n                         ++addr: *sockaddr_in) -> libc::c_int;\n     fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,"}, {"sha": "9d3dcb0f23e37cb6e28bd8109795f90d3fecc52c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -176,9 +176,7 @@ enum proto {\n \n #[auto_serialize]\n enum vstore {\n-    /* FIXME: Change uint to @expr (actually only constant exprs,\n-       as per #2112)\n-     */\n+    // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(option<uint>),   // [1,2,3,4]/_ or 4\n     vstore_uniq,                  // [1,2,3,4]/~\n     vstore_box,                   // [1,2,3,4]/@\n@@ -256,12 +254,11 @@ enum init_op { init_assign, init_move, }\n #[auto_serialize]\n type initializer = {op: init_op, expr: @expr};\n \n+// FIXME (pending discussion of #1697, #2178...): local should really be\n+// a refinement on pat.\n #[auto_serialize]\n-type local_ =  /* FIXME: should really be a refinement on pat\n-                  (pending discussion of #1697, #2178...)\n-                */\n-    {is_mutbl: bool, ty: @ty, pat: @pat,\n-     init: option<initializer>, id: node_id};\n+type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n+                init: option<initializer>, id: node_id};\n \n #[auto_serialize]\n type local = spanned<local_>;\n@@ -322,9 +319,8 @@ enum expr_ {\n     expr_block(blk),\n \n     /*\n-     * FIXME: many of these @exprs should be constrained with\n+     * FIXME (#34): many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n-     * (See #34)\n      */\n     expr_copy(@expr),\n     expr_move(@expr, @expr),"}, {"sha": "9355da5779e17424841f70f87c98f6e023b36199", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -13,16 +13,16 @@ type path = [path_elt];\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n-          path_mod(s) { /* FIXME: bad */ copy *s }\n-          path_name(s) { /* FIXME: bad */ copy *s }\n+          path_mod(s) { /* FIXME (#2543) */ copy *s }\n+          path_name(s) { /* FIXME (#2543) */ copy *s }\n         }\n     };\n     str::connect(strs, sep)\n }\n \n fn path_ident_to_str(p: path, i: ident) -> str {\n     if vec::is_empty(p) {\n-        /* FIXME: bad */ copy *i\n+        /* FIXME (#2543) */ copy *i\n     } else {\n         #fmt[\"%s::%s\", path_to_str(p), *i]\n     }\n@@ -98,7 +98,7 @@ fn map_decoded_item(diag: span_handler,\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n-              mut path: /* FIXME: bad */ copy path,\n+              mut path: /* FIXME (#2543) */ copy path,\n               mut local_id: 0u,\n               diag: diag};\n     let v = mk_ast_map_visitor();\n@@ -124,27 +124,29 @@ fn map_decoded_item(diag: span_handler,\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for decl.inputs.each {|a|\n-        cx.map.insert(a.id, node_arg(/* FIXME: bad */ copy a, cx.local_id));\n+        cx.map.insert(a.id,\n+                      node_arg(/* FIXME (#2543) */\n+                          copy a, cx.local_id));\n         cx.local_id += 1u;\n     }\n     alt fk {\n       visit::fk_ctor(nm, tps, self_id, parent_id) {\n           let ct = @{node: {id: id,\n                             self_id: self_id,\n-                            dec: /* FIXME: bad */ copy decl,\n-                            body: /* FIXME: bad */ copy body},\n+                            dec: /* FIXME (#2543) */ copy decl,\n+                            body: /* FIXME (#2543) */ copy body},\n                     span: sp};\n-          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm,\n-                                      /* FIXME: bad */ copy tps,\n+          cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n+                                      /* FIXME (#2543) */ copy tps,\n                                       class_ctor(ct, parent_id),\n-                                      @/* FIXME: bad */ copy cx.path));\n+                                      @/* FIXME (#2543) */ copy cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n           let dt = @{node: {id: id, self_id: self_id,\n-                     body: /* FIXME: bad */ copy body}, span: sp};\n-          cx.map.insert(id, node_dtor(/* FIXME: bad */ copy tps, dt,\n+                     body: /* FIXME (#2543) */ copy body}, span: sp};\n+          cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n                                       parent_id,\n-                                      @/* FIXME: bad */ copy cx.path));\n+                                      @/* FIXME (#2543) */ copy cx.path));\n        }\n \n        _ {}\n@@ -153,7 +155,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn map_block(b: blk, cx: ctx, v: vt) {\n-    cx.map.insert(b.node.id, node_block(/* FIXME: bad */ copy b));\n+    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -187,7 +189,7 @@ fn map_method(impl_did: def_id, impl_path: @path,\n }\n \n fn map_item(i: @item, cx: ctx, v: vt) {\n-    let item_path = @/* FIXME: bad */ copy cx.path;\n+    let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n       item_impl(_, _, _, _, ms) {\n@@ -198,17 +200,18 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_res(decl, tps, _, dtor_id, ctor_id, _) {\n-        cx.map.insert(ctor_id, node_ctor(/* FIXME: bad */ copy i.ident,\n-                                         /* FIXME: bad */ copy tps,\n-                                         res_ctor(/* FIXME: bad */ copy decl,\n+        cx.map.insert(ctor_id, node_ctor(/* FIXME (#2543) */ copy i.ident,\n+                                         /* FIXME (#2543) */ copy tps,\n+                                         res_ctor(/* FIXME (#2543) */\n+                                                  copy decl,\n                                                   ctor_id, i.span),\n                                          item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n-                /* FIXME: bad */ copy v, i,\n+                /* FIXME (#2543) */ copy v, i,\n                 extend(cx, i.ident)));\n         }\n       }\n@@ -220,7 +223,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         for nm.items.each {|nitem|\n             cx.map.insert(nitem.id,\n                           node_native_item(nitem, abi,\n-                                           @/* FIXME: bad */ copy cx.path));\n+                                           /* FIXME (#2543) */\n+                                           @copy cx.path));\n         }\n       }\n       item_class(tps, ifces, items, ctor, dtor, _) {\n@@ -251,7 +255,9 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n       view_item_export(vps) {\n         for vps.each {|vp|\n             let (id, name) = alt vp.node {\n-              view_path_simple(nm, _, id) { (id, /* FIXME: bad */ copy nm) }\n+              view_path_simple(nm, _, id) {\n+                (id, /* FIXME (#2543) */ copy nm)\n+              }\n               view_path_glob(pth, id) | view_path_list(pth, _, id) {\n                 (id, path_to_ident(pth))\n               }\n@@ -294,19 +300,19 @@ fn node_id_to_str(map: map, id: node_id) -> str {\n       }\n       // FIXMEs are as per #2410\n       some(node_export(_, path)) {\n-        #fmt[\"export %s (id=%?)\", // FIXME: add more info here\n+        #fmt[\"export %s (id=%?)\", // add more info here\n              path_to_str(*path), id]\n       }\n-      some(node_arg(_, _)) { // FIXME: add more info here\n+      some(node_arg(_, _)) { // add more info here\n         #fmt[\"arg (id=%?)\", id]\n       }\n-      some(node_local(_)) { // FIXME: add more info here\n+      some(node_local(_)) { // add more info here\n         #fmt[\"local (id=%?)\", id]\n       }\n-      some(node_ctor(*)) { // FIXME: add more info here\n+      some(node_ctor(*)) { // add more info here\n         #fmt[\"node_ctor (id=%?)\", id]\n       }\n-      some(node_dtor(*)) { // FIXME: add more info here\n+      some(node_dtor(*)) { // add more info here\n         #fmt[\"node_dtor (id=%?)\", id]\n       }\n       some(node_block(_)) {"}, {"sha": "8ce34a06329e85594a116d118a7593bde90b3ccc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -159,7 +159,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;\n-                   parent_enum = some(/* FIXME: bad */ copy it.ident);\n+                   parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n                 }\n             }\n           }\n@@ -268,7 +268,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n }\n \n pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n-    if is_unguarded(a) { some(/* FIXME: bad */ copy a.pats) } else { none }\n+    if is_unguarded(a) { some(/* FIXME (#2543) */ copy a.pats) } else { none }\n }\n \n // Provides an extra node_id to hang callee information on, in case the\n@@ -278,8 +278,8 @@ fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n     alt ci.node {\n-      instance_var(i,_,_,_,_) { /* FIXME: bad */ copy i }\n-      class_method(it) { /* FIXME: bad */ copy it.ident }\n+      instance_var(i,_,_,_,_) { /* FIXME (#2543) */ copy i }\n+      class_method(it) { /* FIXME (#2543) */ copy it.ident }\n     }\n }\n \n@@ -297,7 +297,7 @@ fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n-          vs += [{ident: /* FIXME: bad */ copy i,\n+          vs += [{ident: /* FIXME (#2543) */ copy i,\n                   ty: t,\n                   cm: cm,\n                   id: id,\n@@ -319,11 +319,11 @@ pure fn class_member_visibility(ci: @class_member) -> visibility {\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n-          ii_item(i) { /* FIXME: bad */ copy i.ident }\n-          ii_native(i) { /* FIXME: bad */ copy i.ident }\n-          ii_method(_, m) { /* FIXME: bad */ copy m.ident }\n-          ii_ctor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n-          ii_dtor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n+          ii_item(i) { /* FIXME (#2543) */ copy i.ident }\n+          ii_native(i) { /* FIXME (#2543) */ copy i.ident }\n+          ii_method(_, m) { /* FIXME (#2543) */ copy m.ident }\n+          ii_ctor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n+          ii_dtor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n         }\n     }\n "}, {"sha": "fb9560065a86ee77410ce332dedc540701f9fbd4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -91,9 +91,9 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n // All \"bad\" FIXME copies are as per #2543\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n-      ast::meta_word(n) { /* FIXME bad */ copy n }\n-      ast::meta_name_value(n, _) { /* FIXME bad */ copy n }\n-      ast::meta_list(n, _) { /* FIXME bad */ copy n }\n+      ast::meta_word(n) { /* FIXME (#2543) */ copy n }\n+      ast::meta_name_value(n, _) { /* FIXME (#2543) */ copy n }\n+      ast::meta_list(n, _) { /* FIXME (#2543) */ copy n }\n     }\n }\n \n@@ -120,7 +120,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n #[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n-      ast::meta_list(_, l) { option::some(/* FIXME bad */ copy l) }\n+      ast::meta_list(_, l) { option::some(/* FIXME (#2543) */ copy l) }\n       _ { option::none }\n     }\n }\n@@ -266,15 +266,15 @@ fn last_meta_item_list_by_name(\n \n /* Higher-level applications */\n \n-// FIXME: This needs to sort by meta_item variant in addition to the item name\n-// (See [Fixme-sorting])\n+// FIXME (#607): This needs to sort by meta_item variant in addition to\n+// the item name (See [Fixme-sorting])\n fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n-              ast::meta_word(name) { /* FIXME bad */ copy name }\n-              ast::meta_name_value(name, _) { /* FIXME bad */ copy name }\n-              ast::meta_list(name, _) { /* FIXME bad */ copy name }\n+              ast::meta_word(name) { /* FIXME (#2543) */ copy name }\n+              ast::meta_name_value(name, _) { /* FIXME (#2543) */ copy name }\n+              ast::meta_list(name, _) { /* FIXME (#2543) */ copy name }\n             }\n         }\n         ret key(ma) <= key(mb);\n@@ -292,7 +292,7 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: ast::ident) ->\n     ret vec::filter_map(items, {\n         |item|\n         if get_meta_item_name(item) != name {\n-            option::some(/* FIXME bad */ copy item)\n+            option::some(/* FIXME (#2543) */ copy item)\n         } else {\n             option::none\n         }\n@@ -317,7 +317,7 @@ linkage\n fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n-          ast::meta_list(_, items) { /* FIXME bad */ copy items }\n+          ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n         }\n     }\n }"}, {"sha": "49560fb5bbdd9c4c13d4a391af0d50db455f663f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -123,7 +123,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n       fss_none {\n-        {filename: /* FIXME bad */ copy loc.file.name,\n+        {filename: /* FIXME (#2543) */ copy loc.file.name,\n          line: loc.line,\n          col: loc.col,\n          file: some(loc.file)}\n@@ -132,7 +132,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n       }\n       fss_external(eloc) {\n-        {filename: /* FIXME bad */ copy eloc.filename,\n+        {filename: /* FIXME (#2543) */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n          file: none}\n@@ -178,7 +178,7 @@ type file_lines = {file: filemap, lines: [uint]};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n-    ret /* FIXME bad */ copy lo.file.name;\n+    ret /* FIXME (#2543) */ copy lo.file.name;\n }\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {"}, {"sha": "b8ebb27f51b83d5563b7c0d726ff69e0de3fdfd8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -201,7 +201,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = /* FIXME bad */ copy lines.lines;\n+    let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if vec::len(display_lines) > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines);\n         elided = true;"}, {"sha": "26a906f8cf0cce8a3c97d4e8f36391ebb6637822", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -11,8 +11,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"env\");\n \n-    // FIXME: if this was more thorough it would manufacture an\n-    // option<str> rather than just an maybe-empty string. (Issue #2248)\n+    // FIXME (#2248): if this was more thorough it would manufacture an\n+    // option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt os::getenv(var) {"}, {"sha": "26313e974946342780e6f0819ed784313141089a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -109,10 +109,10 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n     ret {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n-// FIXME: this is a terrible kludge to inject some macros into the default\n-// compilation environment. When the macro-definition system is substantially\n-// more mature, these should move from here, into a compiled part of libcore\n-// at very least. (Issue #2247)\n+// FIXME (#2247): this is a terrible kludge to inject some macros into\n+// the default compilation environment. When the macro-definition system\n+// is substantially more mature, these should move from here, into a\n+// compiled part of libcore at very least.\n \n fn core_macros() -> str {\n     ret"}, {"sha": "0cc4ba0a570a0ed1911f2af66084d82f7ef86f01", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -30,11 +30,10 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     ret pieces_to_expr(cx, sp, pieces, args);\n }\n \n-// FIXME: A lot of these functions for producing expressions can probably\n-// be factored out in common with other code that builds expressions.\n-// FIXME: Cleanup the naming of these functions\n+// FIXME (#2249): A lot of these functions for producing expressions can\n+// probably be factored out in common with other code that builds\n+// expressions.  Also: Cleanup the naming of these functions.\n // NOTE: Moved many of the common ones to build.rs --kevina\n-// See Issue #2249\n fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {"}, {"sha": "3f3eb0012507bc34b34a9e93049e3e7663e673d5", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -104,8 +104,8 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n               with *default_visitor()};\n     let cx = @{lo:lo, gather: dvec()};\n     node.visit(cx, mk_vt(v));\n-    // FIXME: Maybe this is an overkill (merge_sort), it might be better\n-    //   to just keep the gather array in sorted order ... (Issue #2250)\n+    // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n+    // be better to just keep the gather array in sorted order.\n     cx.gather.swap { |v|\n         vec::to_mut(std::sort::merge_sort({|a,b| a.lo < b.lo}, v))\n     };"}, {"sha": "4dad13dc06a526d70ad42e45740bce705035b67e", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -466,8 +466,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n               }\n             }\n           }\n-          /* FIXME: handle embedded types and blocks, at least\n-             (Issue #2251) */\n+          /* FIXME (#2251): handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n           }\n@@ -722,8 +721,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                         [@{params: pattern_to_selectors(cx, arg),\n                            body: elts[1u]}];\n \n-                    // FIXME: check duplicates (or just simplify\n-                    // the macro arg situation) (Issue #2251)\n+                    // FIXME (#2251): check duplicates (or just simplify\n+                    // the macro arg situation)\n                   }\n                   _ {\n                       cx.span_bug(mac.span, \"undocumented invariant in \\"}, {"sha": "ff296eb5aad3c0d2b89a6e9ed97028769503f323", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -88,11 +88,12 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n-                  meta_list(/* FIXME: bad */ copy id,\n+                  meta_list(/* FIXME: (#2543) */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) {\n-                  meta_name_value(fld.fold_ident(id), /* FIXME: bad */ copy s)\n+                  meta_name_value(fld.fold_ident(id),\n+                                  /* FIXME (#2543) */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};\n@@ -123,8 +124,8 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n                mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n                mac_ellipsis { mac_ellipsis }\n-               mac_aq(_,_) { /* FIXME: bad */ copy m.node }\n-               mac_var(_) { /* FIXME: bad */ copy m.node }\n+               mac_aq(_,_) { /* FIXME (#2543) */ copy m.node }\n+               mac_var(_) { /* FIXME (#2543) */ copy m.node }\n              },\n          span: fld.new_span(m.span)};\n }\n@@ -145,7 +146,7 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n }\n \n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    {ident: /* FIXME: bad */ copy tp.ident,\n+    {ident: /* FIXME (#2543) */ copy tp.ident,\n      id: fld.new_id(tp.id),\n      bounds: @vec::map(*tp.bounds, {|x|fold_ty_param_bound(x, fld)})}\n }\n@@ -168,20 +169,20 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     ret alt cd {\n           cdir_src_mod(id, attrs) {\n-            cdir_src_mod(fld.fold_ident(id), /* FIXME: bad */ copy attrs)\n+            cdir_src_mod(fld.fold_ident(id), /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n                          vec::map(cds, fld.fold_crate_directive),\n-                         /* FIXME: bad */ copy attrs)\n+                         /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { copy cd }\n         }\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n-    ret /* FIXME: bad */ copy vi;\n+    ret /* FIXME (#2543) */ copy vi;\n }\n \n \n@@ -223,8 +224,8 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n     @{node: alt ci.node {\n         instance_var(ident, t, cm, id, p) {\n-           instance_var(/* FIXME: bad */ copy ident, fld.fold_ty(t), cm, id,\n-                        p)\n+           instance_var(/* FIXME (#2543) */ copy ident,\n+                        fld.fold_ty(t), cm, id, p)\n         }\n         class_method(m) { class_method(fld.fold_method(m)) }\n       },\n@@ -260,7 +261,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n               item_class(\n-                  /* FIXME: bad */ copy typms,\n+                  /* FIXME (#2543) */ copy typms,\n                   vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n@@ -278,7 +279,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_iface(tps, rp, methods) {\n             item_iface(fold_ty_params(tps, fld),\n                        rp,\n-                       /* FIXME: bad */ copy methods)\n+                       /* FIXME (#2543) */ copy methods)\n           }\n           item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n@@ -297,7 +298,7 @@ fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n-          attrs: /* FIXME: bad */ copy m.attrs,\n+          attrs: /* FIXME (#2543) */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n@@ -344,7 +345,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_rec(fields, etc) {\n             let mut fs = [];\n             for fields.each {|f|\n-                fs += [{ident: /* FIXME: bad */ copy f.ident,\n+                fs += [{ident: /* FIXME (#2543) */ copy f.ident,\n                         pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)\n@@ -507,13 +508,13 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n }\n \n fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+    {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n      id: fld.new_id(c.id)}\n }\n \n fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n     let rslt: ty_constr_ =\n-        {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+        {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n          id: fld.new_id(c.id)};\n     rslt\n }\n@@ -542,15 +543,15 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       some(e) {some(fld.fold_expr(e))}\n       none {none}\n     };\n-    ret {name: /* FIXME: bad */ copy v.name,\n+    ret {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n-    ret /* FIXME: bad */ copy i;\n+    ret /* FIXME (#2543) */ copy i;\n }\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n@@ -644,7 +645,7 @@ impl of ast_fold for ast_fold_precursor {\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(/* FIXME: bad */ copy nm,\n+               instance_var(/* FIXME (#2543) */ copy nm,\n                             (self as ast_fold).fold_ty(t), mt, id, p)\n            }\n            class_method(m) {"}, {"sha": "d062f4bde6d69f582bd06fc976aa0bf87a46e856", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -17,7 +17,7 @@ import attr::parser_attr;\n import common::parser_common;\n import ast::node_id;\n import util::interner;\n-// FIXME: resolve badness\n+// FIXME (#1935): resolve badness\n import lexer::*;//{string_reader_as_reader, tt_reader_as_reader,\n                //reader, string_reader, tt_reader};\n import diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n@@ -75,7 +75,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    let cx = @{sess: sess, cfg: /* FIXME: bad */ copy p.cfg};\n+    let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n     let (companionmod, _) = path::splitext(path::basename(input));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, prefix, option::some(companionmod));\n@@ -85,7 +85,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                           {directives: cdirs,\n                            module: m,\n                            attrs: crate_attrs + attrs,\n-                           config: /* FIXME: bad */ copy p.cfg});\n+                           config: /* FIXME (#2543) */ copy p.cfg});\n }\n \n fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,"}, {"sha": "52cb9366df8c4693649e3a0ccba9c10eab984770", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -93,8 +93,8 @@ impl parser_common for parser {\n     fn eat_keyword(word: str) -> bool {\n         self.require_keyword(word);\n \n-        // FIXME: this gratuitous use of @ is to\n-        // workaround LLVM bug #13042\n+        // FIXME (#13042): this gratuitous use of @ is to\n+        // workaround LLVM bug.\n         alt @self.token {\n           @token::IDENT(sid, false) {\n             if str::eq(word, *self.get_str(sid)) {"}, {"sha": "ae11c883443623147286ec113bdfdb97518d73fe", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -103,7 +103,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n         let i = p0.mk_item(cdir.span.lo, cdir.span.hi,\n-                           /* FIXME: bad */ copy id,\n+                           /* FIXME (#2543) */ copy id,\n                            ast::item_mod(m0), ast::public, mod_attrs);\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = r0.chpos;\n@@ -119,7 +119,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i =\n-            @{ident: /* FIXME: bad */ copy id,\n+            @{ident: /* FIXME (#2543) */ copy id,\n               attrs: attrs + a0,\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),"}, {"sha": "02b34e8dc865548773acab8ebfea0797f5ce45ca", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -414,9 +414,9 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n             bump(rdr);\n             ret token::LIT_FLOAT(intern(*rdr.interner, @num_str),\n                                  ast::ty_f64);\n-            /* FIXME: if this is out of range for either a 32-bit or\n-            64-bit float, it won't be noticed till the back-end (Issue #2252)\n-            */\n+            /* FIXME (#2252): if this is out of range for either a\n+            32-bit or 64-bit float, it won't be noticed till the\n+            back-end.  */\n         } else {\n             is_float = true;\n         }"}, {"sha": "46e838fd4bef0f6f34edb8d23a74cacb956305ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -17,10 +17,10 @@ import dvec::{dvec, extensions};\n export file_type;\n export parser;\n \n-// FIXME: #ast expects to find this here but it's actually defined in `parse`\n-// Fixing this will be easier when we have export decls on individual items --\n-// then parse can export this publicly, and everything else crate-visibly.\n-// (See #1893)\n+// FIXME (#1893): #ast expects to find this here but it's actually\n+// defined in `parse` Fixing this will be easier when we have export\n+// decls on individual items -- then parse can export this publicly, and\n+// everything else crate-visibly.\n import parse_from_source_str;\n export parse_from_source_str;\n \n@@ -172,10 +172,10 @@ class parser {\n             {mode: mode, ty: p.parse_ty(false), ident: name,\n              id: p.get_id()}\n         };\n-        // FIXME: constrs is empty because right now, higher-order functions\n-        // can't have constrained types.\n-        // Not sure whether that would be desirable anyway. See #34 for the\n-        // story on constrained types.\n+        // FIXME (#34): constrs is empty because right now, higher-order\n+        // functions can't have constrained types. Not sure whether\n+        // that would be desirable anyway. See bug for the story on\n+        // constrained types.\n         let constrs: [@constr] = [];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret {inputs: inputs, output: ret_ty,\n@@ -2039,7 +2039,7 @@ class parser {\n     }\n \n     fn parse_ctor(result_ty: ast::ty_) -> class_contents {\n-        // Can ctors/dtors have attrs? FIXME\n+        // FIXME (#2660): Can ctors/dtors have attrs?\n         let lo = self.last_span.lo;\n         let (decl_, _) = self.parse_fn_decl(impure_fn, {|p| p.parse_arg()});\n         let decl = {output: @{id: self.get_id(),\n@@ -2050,7 +2050,7 @@ class parser {\n     }\n \n     fn parse_dtor() -> class_contents {\n-        // Can ctors/dtors have attrs? FIXME\n+        // FIXME (#2660): Can ctors/dtors have attrs?\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, mk_sp(lo, self.last_span.hi))"}, {"sha": "89f3b2d3aba960579d48070dafa597dd77a1a9ee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -545,12 +545,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n           }\n           for items.each {|ci|\n                   /*\n-                     FIXME: collect all private items and print them\n-                     in a single \"priv\" section\n+                     FIXME (#1893): collect all private items and print\n+                     them in a single \"priv\" section\n \n                      tjc: I'm not going to fix this yet b/c we might\n                      change how exports work, including for class items\n-                     (see #1893)\n                    */\n              hardbreak_if_not_bol(s);\n              maybe_print_comment(s, ci.span.lo);"}, {"sha": "5d27ee1452fe0267e17d565ae799c2e41d900dde", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -28,7 +28,7 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n-          | fk_ctor(name, _, _, _) { /* FIXME: bad */ copy name }\n+          | fk_ctor(name, _, _, _) { /* FIXME (#2543) */ copy name }\n       fk_anon(*) | fk_fn_block(*) { @\"anon\" }\n       fk_dtor(*)                  { @\"drop\" }\n     }\n@@ -38,7 +38,7 @@ fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n               | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n-          /* FIXME: bad */ copy tps\n+          /* FIXME (#2543) */ copy tps\n       }\n       fk_anon(*) | fk_fn_block(*) { [] }\n     }\n@@ -117,8 +117,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) {\n-        v.visit_fn(fk_item_fn(/* FIXME: bad */ copy i.ident,\n-                              /* FIXME: bad */ copy tp), decl, body,\n+        v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n+                              /* FIXME (#2543) */ copy tp), decl, body,\n                    i.span, i.id, e, v);\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n@@ -131,8 +131,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n       }\n       item_res(decl, tps, body, dtor_id, _, rp) {\n-        v.visit_fn(fk_res(/* FIXME: bad */ copy i.ident,\n-                          /* FIXME: bad */ copy tps,\n+        v.visit_fn(fk_res(/* FIXME (#2543) */ copy i.ident,\n+                          /* FIXME (#2543) */ copy tps,\n                           rp),\n                    decl, body, i.span, dtor_id, e, v);\n       }\n@@ -287,23 +287,24 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    v.visit_fn(fk_method(/* FIXME: bad */ copy m.ident,\n-                         /* FIXME: bad */ copy m.tps, m),\n+    v.visit_fn(fk_method(/* FIXME (#2543) */ copy m.ident,\n+                         /* FIXME (#2543) */ copy m.tps, m),\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n // Similar logic to the comment on visit_method_helper - Tim\n fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_ctor(/* FIXME: bad */ copy nm, /* FIXME: bad */ copy tps,\n+    v.visit_fn(fk_ctor(/* FIXME (#2543) */ copy nm,\n+                       /* FIXME (#2543) */ copy tps,\n                        ctor.node.self_id, parent_id), ctor.node.dec,\n                ctor.node.body, ctor.span, ctor.node.id, e, v)\n \n }\n \n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_dtor(/* FIXME: bad */ copy tps, dtor.node.self_id,\n+    v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.self_id,\n                        parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n "}, {"sha": "be8689672a897f993f43cb25d7bc0a84d09fb502", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -2,8 +2,8 @@\n  * The Rust runtime uses memory regions to provide a primitive level of\n  * memory management and isolation between tasks, and domains.\n  *\n- * FIXME: Implement a custom lock-free malloc / free instead of relying solely\n- *       on the standard malloc / free. (#2686)\n+ * FIXME (#2686): Implement a custom lock-free malloc / free instead of\n+ *       relying solely on the standard malloc / free.\n  */\n \n #ifndef MEMORY_REGION_H"}, {"sha": "67b3bf84938bed092c24f61f10820e777cb25a1b", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -67,8 +67,8 @@ command_line_args : public kernel_owned<command_line_args>\n };\n \n // A global that indicates whether Rust typestate claim statements should be\n-// executed. Generated code will read this variable directly (I think).\n-// FIXME: This belongs somewhere else (#2670)\n+// executed Generated code will read this variable directly (I think).\n+// FIXME (#2670): This belongs somewhere else\n int check_claims = 0;\n \n /**"}, {"sha": "cab1b6b427cbffca9fcb3233abcc9490ea1d866e", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -232,8 +232,8 @@ rand_free(randctx *rctx) {\n \n /* Debug helpers strictly to verify ABI conformance.\n  *\n- * FIXME: move these into a testcase when the testsuite\n- * understands how to have explicit C files included. (#2688)\n+ * FIXME (#2665): move these into a testcase when the testsuite\n+ * understands how to have explicit C files included.\n  */\n \n struct quad {\n@@ -288,19 +288,20 @@ debug_opaque(type_desc *t, uint8_t *front) {\n     rust_task *task = rust_get_current_task();\n     LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(t);\n-    // FIXME may want to actually account for alignment.  `front` may not\n-    // indeed be the front byte of the passed-in argument. (#2667)\n+    // FIXME (#2667) may want to actually account for alignment.\n+    // `front` may not indeed be the front byte of the passed-in\n+    // argument.\n     for (uintptr_t i = 0; i < t->size; ++front, ++i) {\n         LOG(task, stdlib, \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, *front);\n     }\n }\n \n-// FIXME this no longer reflects the actual structure of boxes! (#2667)\n+// FIXME (#2667) this no longer reflects the actual structure of boxes!\n struct rust_box {\n     RUST_REFCOUNTED(rust_box)\n \n-    // FIXME `data` could be aligned differently from the actual box body data\n-    // (#2667)\n+    // FIXME (#2667) `data` could be aligned differently from the actual\n+    // box body data\n     uint8_t data[];\n };\n \n@@ -636,7 +637,7 @@ extern \"C\" CDECL rust_task*\n rust_new_task_in_sched(rust_sched_id id) {\n     rust_task *task = rust_get_current_task();\n     rust_scheduler *sched = task->kernel->get_scheduler_by_id(id);\n-    // FIXME: What if we didn't get the scheduler? (#2668)\n+    // FIXME (#2668): What if we didn't get the scheduler?\n     return new_task_common(sched, task);\n }\n "}, {"sha": "ed31ddd9dad7527b573e01947f2023aad6511c18", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -79,7 +79,7 @@ class irc : public shape::data<irc,shape::ptr> {\n         shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n         while (sub.dp < data_end) {\n             sub.walk_reset();\n-            // FIXME: shouldn't this be 'sub.align = true;'?\n+            // FIXME (#2669): shouldn't this be 'sub.align = true;'?\n             align = true;\n         }\n     }\n@@ -214,7 +214,7 @@ irc::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n                    variant_ptr_and_end) {\n     irc sub(*this, variant_ptr_and_end.first);\n \n-    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n \n     const uint8_t *variant_end = variant_ptr_and_end.second;\n     while (sub.sp < variant_end) {\n@@ -329,7 +329,7 @@ class mark : public shape::data<mark,shape::ptr> {\n             return;\n \n         if (data_range.second - data_range.first > 100000)\n-            abort();    // FIXME: Temporary sanity check.\n+            abort();    // FIXME (#2666): Temporary sanity check.\n \n         mark sub(*this, shape::ptr(data_range.first));\n         shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n@@ -454,7 +454,7 @@ mark::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n                    variant_ptr_and_end) {\n     mark sub(*this, variant_ptr_and_end.first);\n \n-    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n \n     const uint8_t *variant_end = variant_ptr_and_end.second;\n     while (sub.sp < variant_end) {\n@@ -550,7 +550,9 @@ maybe_cc(rust_task *task) {\n         return;\n     }\n \n-    // FIXME: Needs a snapshot.\n+    // FIXME (#1498): depressingly, due to alignment bugs the whole file is\n+    // disabled presently unless you're doing testing. Remove the whole thing\n+    // when we transition to using a visitor for GC/CC.\n #if 0\n     if (task->cc_counter++ > RUST_CC_FREQUENCY) {\n         task->cc_counter = 0;"}, {"sha": "68f9e3d451984f4ba4d2380a7ae36fd7ff93b9c1", "filename": "src/rt/rust_debug.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_debug.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_debug.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -34,7 +34,7 @@ class flag {\n     flag(const char *in_name) : name(in_name), valid(false) {}\n \n     bool operator*() {\n-        // FIXME: We ought to lock this. (#2689)\n+        // FIXME (#2689): We ought to lock this.\n         if (!valid) {\n             char *ev = getenv(name);\n             value = ev && ev[0] != '\\0' && ev[0] != '0';"}, {"sha": "b13b1490c0f8bd2f42fdbddd5f10666d3dc0a5a7", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -184,23 +184,22 @@ rust_kernel::run() {\n     return rval;\n }\n \n-// FIXME: Fix all these FIXMEs (#2690)\n void\n rust_kernel::fail() {\n-    // FIXME: On windows we're getting \"Application has requested the\n-    // Runtime to terminate it in an unusual way\" when trying to shutdown\n-    // cleanly.\n+    // FIXME (#2671): On windows we're getting \"Application has\n+    // requested the Runtime to terminate it in an unusual way\" when\n+    // trying to shutdown cleanly.\n     set_exit_status(PROC_FAIL_CODE);\n #if defined(__WIN32__)\n     exit(rval);\n #endif\n     // Copy the list of schedulers so that we don't hold the lock while\n     // running kill_all_tasks.\n-    // FIXME: There's a lot that happens under kill_all_tasks, and I don't\n-    // know that holding sched_lock here is ok, but we need to hold the\n-    // sched lock to prevent the scheduler from being destroyed while\n-    // we are using it. Probably we need to make rust_scheduler atomicly\n-    // reference counted.\n+    // FIXME (#2671): There's a lot that happens under kill_all_tasks,\n+    // and I don't know that holding sched_lock here is ok, but we need\n+    // to hold the sched lock to prevent the scheduler from being\n+    // destroyed while we are using it. Probably we need to make\n+    // rust_scheduler atomicly reference counted.\n     std::vector<rust_scheduler*> scheds;\n     {\n         scoped_lock with(sched_lock);\n@@ -210,9 +209,9 @@ rust_kernel::fail() {\n         }\n     }\n \n-    // FIXME: This is not a foolproof way to kill all tasks while ensuring\n-    // that no new tasks or schedulers are created in the meantime that\n-    // keep the scheduler alive.\n+    // FIXME (#2671): This is not a foolproof way to kill all tasks\n+    // while ensuring that no new tasks or schedulers are created in the\n+    // meantime that keep the scheduler alive.\n     for (std::vector<rust_scheduler*>::iterator iter = scheds.begin();\n          iter != scheds.end(); iter++) {\n         (*iter)->kill_all_tasks();"}, {"sha": "5074b1f40c6a242ed0e1ca57e2e4331c5000dc67", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -126,8 +126,8 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n         assert(!task->on_rust_stack() && \"logging on rust stack\");\n     }\n \n-    // FIXME: The scheduler and task names used to have meaning,\n-    // but they are always equal to 'main' currently (#2672)\n+    // FIXME (#2672): The scheduler and task names used to have meaning,\n+    // but they are always equal to 'main' currently\n #if 0\n \n #if defined(__WIN32__)\n@@ -233,8 +233,9 @@ void update_crate_map(const cratemap* map, log_directive* dirs,\n     // First update log levels for this crate\n     update_module_map(map->entries, dirs, n_dirs, n_matches);\n     // Then recurse on linked crates\n-    // FIXME this does double work in diamond-shaped deps. could keep\n-    // a set of visited addresses, if it turns out to be actually slow (#2673)\n+    // FIXME (#2673) this does double work in diamond-shaped deps. could\n+    //   keep a set of visited addresses, if it turns out to be actually\n+    //   slow\n     for (size_t i = 0; map->children[i]; i++) {\n         update_crate_map(map->children[i], dirs, n_dirs, n_matches);\n     }"}, {"sha": "739527b84eb7413f338043794ac86907f3cfe183", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -160,7 +160,7 @@ rust_run_program(const char* argv[],\n     for (int fd = getdtablesize() - 1; fd >= 3; fd--) close(fd);\n     if (dir) {\n         int result = chdir(dir);\n-        // FIXME: need error handling (#2674)\n+        // FIXME (#2674): need error handling\n         assert(!result && \"chdir failed\");\n     }\n "}, {"sha": "61fd8ac05fd6cdfc5f1505c30b904a1263dcab7b", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -88,6 +88,7 @@ struct rust_sched_loop\n \n     randctx rctx;\n     const char *const name; // Used for debugging\n+\n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n     rust_sched_loop(rust_scheduler *sched, int id);"}, {"sha": "74e6d6bf2bd1641945aa8e2ef23f3691220799ea", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -16,7 +16,7 @@ class rust_sched_launcher;\n class rust_sched_launcher_factory;\n \n class rust_scheduler : public kernel_owned<rust_scheduler> {\n-    // FIXME: Make these private\n+    // FIXME (#2693): Make these private\n public:\n     rust_kernel *kernel;\n private:"}, {"sha": "cfac33008b94725393ea1f94600e578f91dd1a9c", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -84,7 +84,7 @@ class arena {\n \n     template<typename T>\n     inline T *alloc(size_t count = 1) {\n-        // FIXME: align\n+        // FIXME: align (probably won't fix before #1498)\n         size_t sz = count * sizeof(T);\n         T *rv = (T *)ptr;\n         ptr += sz;\n@@ -894,7 +894,8 @@ class data : public ctxt< data<T,U> > {\n     void walk_tag1(tag_info &tinfo);\n \n     void walk_struct1(const uint8_t *end_sp) {\n-        // FIXME: shouldn't we be aligning to the first element here?\n+        // FIXME (probably won't fix before #1498): shouldn't we be aligning\n+        // to the first element here?\n         static_cast<T *>(this)->walk_struct2(end_sp);\n     }\n "}, {"sha": "adbd75f1c90c760bec2070108885f0794d00ff6f", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -59,15 +59,16 @@ rust_task::delete_this()\n     DLOG(sched_loop, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n-    // FIXME: We should do this when the task exits, not in the destructor\n+    // FIXME (#2677): We should do this when the task exits, not in the\n+    // destructor\n     {\n         scoped_lock with(supervisor_lock);\n         if (supervisor) {\n             supervisor->deref();\n         }\n     }\n \n-    /* FIXME: tighten this up, there are some more\n+    /* FIXME (#2677): tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n     assert(ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n@@ -114,13 +115,14 @@ cleanup_task(cleanup_args *args) {\n         }\n     }\n \n-    // FIXME: For performance we should do the annihilator instead\n-    // of the cycle collector even under normal termination, but\n+    // FIXME (#2676): For performance we should do the annihilator\n+    // instead of the cycle collector even under normal termination, but\n     // since that would hide memory management errors (like not derefing\n     // boxes), it needs to be disableable in debug builds.\n     if (threw_exception) {\n-        // FIXME: When the annihilator is more powerful and successfully\n-        // runs resource destructors, etc. we can get rid of this cc\n+        // FIXME (#2676): When the annihilator is more powerful and\n+        // successfully runs resource destructors, etc. we can get rid\n+        // of this cc\n         cc::do_cc(task);\n         annihilate_boxes(task);\n     }\n@@ -287,7 +289,7 @@ void\n rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n \n     if (expr) {\n-        // FIXME: Change this message to be\n+        // FIXME (#2678): Change this message to be\n         // 'task failed at ...'\n         LOG_ERR(this, task, \"upcall fail '%s', %s:%\" PRIdPTR,\n                 expr, file, line);\n@@ -301,7 +303,7 @@ rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n #else\n     die();\n     conclude_failure();\n-    // FIXME: Need unwinding on windows. This will end up aborting\n+    // FIXME (#908): Need unwinding on windows. This will end up aborting\n     sched_loop->fail();\n #endif\n }\n@@ -458,7 +460,7 @@ rust_task::calloc(size_t size, const char *tag) {\n \n void\n rust_task::notify(bool success) {\n-    // FIXME (1078) Do this in rust code\n+    // FIXME (#1078) Do this in rust code\n     if(notify_enabled) {\n         rust_port *target_port =\n             kernel->get_port_by_id(notify_port);\n@@ -622,7 +624,7 @@ rust_task::reset_stack_limit() {\n     uintptr_t sp = get_sp();\n     // Have to do the rest on the C stack because it involves\n     // freeing stack segments, logging, etc.\n-    // FIXME: This probably doesn't need to happen on the C\n+    // FIXME (#2679): This probably doesn't need to happen on the C\n     // stack now\n     reset_args ra = {this, sp};\n     call_on_c_stack(&ra, (void*)reset_stack_limit_on_c_stack);"}, {"sha": "2a58725c6a43a937205c32b4008755baa7cf16fb", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -18,10 +18,11 @@\n    threads at any time. This may keep the task from being destroyed even after\n    the task is dead from a Rust task lifecycle perspective.\n \n-   FIXME: The task and the scheduler have an over-complicated, undocumented\n-   protocol for shutting down the task, hopefully without races. It would be\n-   easier to reason about if other runtime objects could not access the task\n-   from arbitrary threads, and didn't need to be atomically refcounted.\n+   FIXME (#2696): The task and the scheduler have an over-complicated,\n+   undocumented protocol for shutting down the task, hopefully without\n+   races. It would be easier to reason about if other runtime objects could\n+   not access the task from arbitrary threads, and didn't need to be\n+   atomically refcounted.\n  */\n \n #ifndef RUST_TASK_H\n@@ -42,8 +43,9 @@\n \n // The amount of extra space at the end of each stack segment, available\n // to the rt, compiler and dynamic linker for running small functions\n-// FIXME: We want this to be 128 but need to slim the red zone calls down,\n-// disable lazy symbol relocation, and other things we haven't discovered yet\n+// FIXME (#1509): We want this to be 128 but need to slim the red zone calls\n+// down, disable lazy symbol relocation, and other things we haven't\n+// discovered yet\n #define RZ_LINUX_32 (1024*2)\n #define RZ_LINUX_64 (1024*2)\n #define RZ_MAC_32   (1024*20)\n@@ -303,7 +305,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void allow_kill();\n };\n \n-// FIXME: It would be really nice to be able to get rid of this.\n+// FIXME (#2697): It would be really nice to be able to get rid of this.\n inline void *operator new[](size_t size, rust_task *task, const char *tag) {\n     return task->malloc(size, tag);\n }\n@@ -360,9 +362,9 @@ sanitize_next_sp(uintptr_t next_sp) {\n     // to the amount of stack needed for calling __morestack I've added some\n     // extra bytes here.\n \n-    // FIXME: On the rust stack this potentially puts is quite far into the\n-    // red zone. Might want to just allocate a new rust stack every time we\n-    // switch back to rust.\n+    // FIXME (#2698): On the rust stack this potentially puts is quite far\n+    // into the red zone. Might want to just allocate a new rust stack every\n+    // time we switch back to rust.\n     const uintptr_t padding = 16;\n \n     return align_down(next_sp - padding);\n@@ -416,7 +418,7 @@ rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n \n     uintptr_t sp = sanitize_next_sp(next_rust_sp);\n \n-    // FIXME(2047): There are times when this is called and needs\n+    // FIXME (#2047): There are times when this is called and needs\n     // to be able to throw, and we don't account for that.\n     __morestack(args, fn_ptr, sp);\n \n@@ -529,7 +531,7 @@ rust_task::record_stack_limit() {\n inline rust_task* rust_get_current_task() {\n     uintptr_t sp_limit = get_sp_limit();\n \n-    // FIXME (1226) - Because of a hack in upcall_call_shim_on_c_stack this\n+    // FIXME (#1226) - Because of a hack in upcall_call_shim_on_c_stack this\n     // value is sometimes inconveniently set to 0, so we can't use this\n     // method of retreiving the task pointer and need to fall back to TLS.\n     if (sp_limit == 0)"}, {"sha": "940cf3aa01a6f1e3b74eab66549e2c9cb1bf7e3d", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -49,7 +49,7 @@ extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n     rust_task *task = rust_get_current_task();\n \n-    // FIXME (1226) - The shim functions generated by rustc contain the\n+    // FIXME (#1226) - The shim functions generated by rustc contain the\n     // morestack prologue, so we need to let them know they have enough\n     // stack.\n     record_sp_limit(0);\n@@ -72,9 +72,9 @@ extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n     rust_task *task = rust_get_current_task();\n \n-    // FIXME: Because of the hack in the other function that disables the\n-    // stack limit when entering the C stack, here we restore the stack limit\n-    // again.\n+    // FIXME (#2680): Because of the hack in the other function that disables\n+    // the stack limit when entering the C stack, here we restore the stack\n+    // limit again.\n     task->record_stack_limit();\n \n     try {\n@@ -86,7 +86,7 @@ upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n         assert(false && \"Rust task failed after reentering the Rust stack\");\n     }\n \n-    // FIXME: As above\n+    // FIXME (#2680): As above\n     record_sp_limit(0);\n }\n \n@@ -177,7 +177,7 @@ upcall_exchange_malloc(type_desc *td, uintptr_t size) {\n     return args.retval;\n }\n \n-// FIXME: remove after snapshot (6/21/12)\n+// FIXME (#2681): remove after snapshot (6/21/12)\n extern \"C\" CDECL uintptr_t\n upcall_exchange_malloc_dyn(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();\n@@ -246,7 +246,7 @@ upcall_malloc(type_desc *td, uintptr_t size) {\n     return args.retval;\n }\n \n-// FIXME: remove after snapshot (6/21/12)\n+// FIXME (#2681): remove after snapshot (6/21/12)\n extern \"C\" CDECL uintptr_t\n upcall_malloc_dyn(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();"}, {"sha": "247f253fd9f4412f553d53f2c27d55d555e5aa3f", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -111,7 +111,7 @@ make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n \n inline size_t get_box_size(size_t body_size, size_t body_align) {\n     size_t header_size = sizeof(rust_opaque_box);\n-    // FIXME: This alignment calculation is suspicious. Is it right?\n+    // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n     size_t total_size = align_to(header_size, body_align) + body_size;\n     return total_size;\n }"}, {"sha": "9558aaa7c06b976afadcc0be478269f9bd91826f", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -9,7 +9,8 @@\n  * if you're using a pthreads cvar+mutex pair.\n  */\n \n-// FIXME: This is not a portable way of specifying an invalid pthread_t\n+// FIXME (#2683): This is not a portable way of specifying an invalid\n+// pthread_t\n #define INVALID_THREAD 0\n \n "}, {"sha": "ed11b1aa321b304b4683ecf76f7a93f1fbb0e911", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -88,8 +88,8 @@ class lock_free_queue {\n         pointer_t *oldValue,\n         pointer_t newValue) {\n \n-        // FIXME this is requiring us to pass -fno-strict-aliasing to GCC\n-        // (possibly there are other, similar problems)\n+        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing\n+        // to GCC (possibly there are other, similar problems)\n         if (sync::compare_and_swap(\n                 (uint64_t*) address,\n                 *(uint64_t*) oldValue,"}, {"sha": "0204517d51239e6eac7d4d0d65fe18a1ea6455bf", "filename": "src/rt/sync/timer.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Ftimer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frt%2Fsync%2Ftimer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ftimer.cpp?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -10,7 +10,7 @@ uint64_t ns_per_s = 1000000000LL;\n timer::timer() {\n #if __WIN32__\n     _ticks_per_s = 0LL;\n-    // FIXME: assert this works or have a workaround.\n+    // FIXME (#2675): assert this works or have a workaround.\n     QueryPerformanceFrequency((LARGE_INTEGER *)&_ticks_per_s);\n     if (_ticks_per_s == 0LL) {\n       _ticks_per_s = 1LL;"}, {"sha": "4875fbd69ca6bcd40f366a02a2f24cfe660464e5", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -85,13 +85,12 @@ mod write {\n             }\n         }\n         if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n-        // FIXME: This is mostly a copy of the bits of opt's -O2 that are\n-        // available in the C api.\n-        // FIXME2: We might want to add optimization levels like -O1, -O2,\n+        // FIXME (#2396): This is mostly a copy of the bits of opt's -O2 that\n+        // are available in the C api.\n+        // Also: We might want to add optimization levels like -O1, -O2,\n         // -Os, etc\n-        // FIXME3: Should we expose and use the pass lists used by the opt\n+        // Also: Should we expose and use the pass lists used by the opt\n         // tool?\n-        // See #2396\n \n         if opts.optimize != 0u {\n             let fpm = mk_pass_manager();\n@@ -668,9 +667,8 @@ fn link_binary(sess: session,\n     // Stack growth requires statically linking a __morestack function\n     cc_args += [\"-lmorestack\"];\n \n-    // FIXME: At some point we want to rpath our guesses as to where\n+    // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // native libraries might live, based on the addl_lib_search_paths\n-    // #2397\n     cc_args += rpath::get_rpath_flags(sess, output);\n \n     #debug(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));"}, {"sha": "553db7695a8a9b0e4f388a150835004cb36b0d88", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -78,9 +78,9 @@ fn build_configuration(sess: session, argv0: str, input: input) ->\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n-    // FIXME: It would be nice to use the parser to parse all varieties of\n-    // meta_item here. At the moment we just support the meta_word variant.\n-    // #2399\n+    // FIXME (#2399): It would be nice to use the parser to parse all\n+    // varieties of meta_item here. At the moment we just support the\n+    // meta_word variant.\n     let mut words = [];\n     for cfgspecs.each {|s| words += [attr::mk_word_item(@s)]; }\n     ret words;\n@@ -100,8 +100,7 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n         parse::parse_crate_from_file(file, cfg, sess.parse_sess)\n       }\n       str_input(src) {\n-        // FIXME: Don't really want to box the source string\n-        // #2319\n+        // FIXME (#2319): Don't really want to box the source string\n         parse::parse_crate_from_source_str(\n             anon_src(), @src, cfg, sess.parse_sess)\n       }\n@@ -389,9 +388,10 @@ fn host_triple() -> str {\n     // idea of the host triple is the same as for the set of libraries we've\n     // actually built.  We can't just take LLVM's host triple because they\n     // normalize all ix86 architectures to i386.\n-    // FIXME: Instead of grabbing the host triple we really should be\n-    // grabbing (at compile time) the target triple that this rustc is\n-    // built with and calling that (at runtime) the host triple. (#2400)\n+\n+    // FIXME (#2400): Instead of grabbing the host triple we really should\n+    // be grabbing (at compile time) the target triple that this rustc is\n+    // built with and calling that (at runtime) the host triple.\n     let ht = #env(\"CFG_HOST_TRIPLE\");\n     ret if ht != \"\" {\n             ht\n@@ -660,10 +660,10 @@ fn build_output_filenames(input: input,\n         };\n \n         if sess.building_library {\n-            // FIXME: We might want to warn here; we're actually not going to\n-            // respect the user's choice of library name when it comes time to\n-            // link, we'll be linking to lib<basename>-<hash>-<version>.so no\n-            // matter what. (#2401)\n+            // FIXME (#2401): We might want to warn here; we're actually not\n+            // going to respect the user's choice of library name when it\n+            // comes time to link, we'll be linking to\n+            // lib<basename>-<hash>-<version>.so no matter what.\n         }\n \n         if odir != none {"}, {"sha": "9645d919b04bf5c7953f33b2b5736465023c7600", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -32,7 +32,7 @@ const stats: uint = 16u;\n const no_asm_comments: uint = 32u;\n const no_verify: uint = 64u;\n const trace: uint = 128u;\n-// FIXME: This exists to transition to a Rust crate runtime\n+// FIXME (#2377): This exists to transition to a Rust crate runtime\n // It should be removed\n const no_rt: uint = 256u;\n "}, {"sha": "2c40db16a455ada28003a28d4f719773ac251150", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -64,9 +64,10 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n-    // the one we're going to add.  FIXME: This is sloppy. Instead we should\n-    // have some mechanism to indicate to the translation pass which function\n-    // we want to be main. (#2403)\n+    // the one we're going to add.\n+\n+    // FIXME (#2403): This is sloppy. Instead we should have some mechanism to\n+    // indicate to the translation pass which function we want to be main.\n     fn nomain(&&item: @ast::item) -> option<@ast::item> {\n         alt item.node {\n           ast::item_fn(_, _, _) {\n@@ -338,8 +339,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n }\n \n // Produces a bare function that wraps the test function\n-// FIXME: This can go away once fn is the type of bare function\n-// (See #1281)\n+\n+// FIXME (#1281): This can go away once fn is the type of bare function.\n fn mk_test_wrapper(cx: test_ctxt,\n                    fn_path_expr: ast::expr,\n                    span: span) -> @ast::expr {"}, {"sha": "c63d03ce2399c764dc415b207d03190f5be62515", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -261,8 +261,8 @@ fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n           none {\n             #debug(\"need to load it\");\n             // This is a new one so we've got to load it\n-            // FIXME: Need better error reporting than just a bogus span\n-            // #2404\n+            // FIXME (#2404): Need better error reporting than just a bogus\n+            // span.\n             let fake_span = ast_util::dummy_sp();\n             let local_cnum =\n                 resolve_crate(e, cname, cmetas, *dep.hash, fake_span);"}, {"sha": "7209d4e67311768c58b3c24d9827789d30b44e2f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -433,8 +433,7 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         rslt += [@{did: translate_def_id(cdata, m_did),\n-                    /* FIXME tjc: take a look at this, it may relate\n-                     to #2323 */\n+                    /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(mth_item)}];\n     }"}, {"sha": "62c4a0789528b5a6f651c86fb8fd6c57c7de0e86", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1028,9 +1028,8 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n     // the assumption that they are numbered 1 to n.\n-    // FIXME: This is not nearly enough to support correct versioning\n+    // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    // See #2166\n     ebml_w.start_tag(tag_crate_deps);\n     for get_ordered_deps(cstore).each {|dep|\n         encode_crate_dep(ebml_w, dep);"}, {"sha": "eeb44f80fd7cd6ecced442e54b4c3e3db1d0127a", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1,6 +1,6 @@\n // A module for searching for libraries\n-// FIXME: I'm not happy how this module turned out. Should probably\n-// just be folded into cstore.\n+// FIXME (#2658): I'm not happy how this module turned out. Should\n+// probably just be folded into cstore.\n \n import result::result;\n export filesearch;"}, {"sha": "a5874aa29fa48911adab0c17ca94b5a4984e83e8", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -125,8 +125,8 @@ fn crate_name_from_metas(metas: [@ast::meta_item]) -> @str {\n       some(i) {\n         alt attr::get_meta_item_value_str(i) {\n           some(n) { n }\n-          // FIXME: Probably want a warning here since the user\n-          // is using the wrong type of meta item (#2406)\n+          // FIXME (#2406): Probably want a warning here since the user\n+          // is using the wrong type of meta item.\n           _ { fail }\n         }\n       }"}, {"sha": "df46a4cef8f420a2f82823d0d45b4a5624936d81", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -85,12 +85,12 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // is mutable in the caller's frame, thus effectively\n                 // passing the buck onto us to enforce this)\n                 //\n-                // FIXME---this handling is not really adequate.  For\n-                // example, if there is a type like, {f: [int]}, we\n-                // will ignore it, but we ought to be requiring it to\n-                // be immutable (whereas something like {f:int} would\n-                // be fine).\n-                // (See #2493)\n+                // FIXME (#2493): this handling is not really adequate.\n+                // For example, if there is a type like, {f: [int]}, we\n+                // will ignore it, but we ought to be requiring it to be\n+                // immutable (whereas something like {f:int} would be\n+                // fine).\n+                //\n \n                 alt opt_deref_kind(arg_ty.ty) {\n                   some(deref_ptr(region_ptr)) |\n@@ -130,7 +130,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // Here, in an overloaded operator, the call is this expression,\n         // and hence the scope of the borrow is this call.\n         //\n-        // FIXME/NOT REALLY---technically we should check the other\n+        // FIX? / NOT REALLY---technically we should check the other\n         // argument and consider the argument mode.  But how annoying.\n         // And this problem when goes away when argument modes are\n         // phased out.  So I elect to leave this undone."}, {"sha": "26ffbdc0273c5dfbbeedd7328960e4c4b7d66e96", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1,7 +1,7 @@\n import syntax::ast::*;\n \n-// FIXME this doesn't handle big integer/float literals correctly (nor does\n-// the rest of our literal handling - issue #33)\n+// FIXME (#33): this doesn't handle big integer/float literals correctly\n+// (nor does the rest of our literal handling).\n enum const_val {\n     const_float(f64),\n     const_int(i64),"}, {"sha": "0ae04c25ccd2d76d3ebdc829fbf25b2261d684be", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -215,9 +215,9 @@ fn iter_effective_import_paths(vi: ast::view_item,\n     iter_export_paths(vi) {|vp|\n         alt vp.node {\n           ast::view_path_simple(_, _, _) { }\n-          // FIXME: support uniform ident-list exports eventually;\n-          // at the moment they have half a meaning as reaching into\n-          // tags. (but also see #1893)\n+          // FIXME (but also see #1893): support uniform ident-list exports\n+          // eventually; at the moment they have half a meaning as reaching\n+          // into tags.\n           ast::view_path_list(_, _, _) {}\n           ast::view_path_glob(_,_) {\n             f(vp);"}, {"sha": "d202ba7a123f32845bc33606d3a9ff32a4d4ec59", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1354,10 +1354,10 @@ fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n                 n_bytes: ValueRef) {\n-    // FIXME: Provide LLVM with better alignment information when the\n-    // alignment is statically known (it must be nothing more than a constant\n-    // int, or LLVM complains -- not even a constant element of a tydesc\n-    // works). (Related to #1645, I think?)\n+    // FIXME (Related to #1645, I think?): Provide LLVM with better\n+    // alignment information when the alignment is statically known (it must\n+    // be nothing more than a constant int, or LLVM complains -- not even a\n+    // constant element of a tydesc works).\n     let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = alt ccx.sess.targ_cfg.arch {\n@@ -1439,9 +1439,9 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n \n // This works like copy_val, except that it deinitializes the source.\n // Since it needs to zero out the source, src also needs to be an lval.\n-// FIXME: We always zero out the source. Ideally we would detect the\n+// FIXME (#839): We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n-// doesn't need to be dropped. (Issue #839)\n+// doesn't need to be dropped.\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n \n@@ -1652,8 +1652,8 @@ fn cast_shift_rhs(op: ast::binop,\n         if lhs_sz < rhs_sz {\n             trunc(rhs, lhs_llty)\n         } else if lhs_sz > rhs_sz {\n-            // FIXME: If shifting by negative values becomes not undefined\n-            // then this is wrong. (See discussion at #1570)\n+            // FIXME (See discussion at #1570): If shifting by negative\n+            // values becomes not undefined then this is wrong.\n             zext(rhs, lhs_llty)\n         } else {\n             rhs\n@@ -1790,14 +1790,14 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             bcx, ex.info(), fty,\n             expr_ty(bcx, ex),\n             {|bcx|\n-                // FIXME provide the already-computed address, not the expr\n-                // #2528\n+                // FIXME (#2528): provide the already-computed address, not\n+                // the expr.\n                 impl::trans_method_callee(bcx, callee_id, dst, origin)\n             },\n             arg_exprs([src]), save_in(target));\n \n         ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n-                     // FIXME: should kind be owned?\n+                     // FIXME (#2704): should kind be owned?\n                      {bcx: bcx, val: target, kind: owned},\n                      dty);\n       }\n@@ -4759,9 +4759,9 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n }\n \n \n-// FIXME: this should do some structural hash-consing to avoid\n-// duplicate constants. I think. Maybe LLVM has a magical mode\n-// that does so later on? (#2530)\n+// FIXME (#2530): this should do some structural hash-consing to avoid\n+// duplicate constants. I think. Maybe LLVM has a magical mode that does so\n+// later on?\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_const_expr\");\n     alt e.node {\n@@ -4863,9 +4863,9 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               ast_map::node_item(@{\n                 node: ast::item_const(_, subexpr), _\n               }, _) {\n-                // FIXME: Instead of recursing here to regenerate the values\n-                // for other constants, we should just look up the\n-                // already-defined value (#2530)\n+                // FIXME (#2530): Instead of recursing here to regenerate\n+                // the values for other constants, we should just look up\n+                // the already-defined value.\n                 trans_const_expr(cx, subexpr)\n               }\n               _ {"}, {"sha": "e90590f0228e7ce0315f199919885113b2f1e78c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -522,7 +522,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       option::none {}\n     }*/\n \n-    /* FIXME I am disabling this code as part of the patch that moves\n+    /* FIXME (#2012): disabled this code as part of the patch that moves\n      * recognition of named builtin types into resolve. I tried to fix\n      * it, but it seems to already be broken -- it's only called when\n      * --xg is given, and compiling with --xg fails on trivial programs.\n@@ -531,8 +531,6 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n      * needed. It is only done to track spans, but you will not get the\n      * right spans anyway -- types tend to refer to stuff defined\n      * elsewhere, not be self-contained.\n-     *\n-     * See Issue #2012\n      */\n \n     fail;"}, {"sha": "fcc7f370f743c0b3b48ebe86c778dc4cbbf96208", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -700,8 +700,8 @@ fn trans_native_mod(ccx: @crate_ctxt,\n         }\n     }\n \n-    // FIXME this is very shaky and probably gets ABIs wrong all over\n-    // the place (#2535)\n+    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n+    // over the place\n     fn build_direct_fn(ccx: @crate_ctxt, decl: ValueRef,\n                        item: @ast::native_item, tys: @c_stack_tys,\n                        cc: lib::llvm::CallConv) {"}, {"sha": "740d53ed773125f0486f9b3a2a7ee62a80261feb", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -163,8 +163,8 @@ impl methods for reflector {\n             self.visit(\"leave_tup\", extra);\n           }\n \n-          // FIXME: fetch constants out of intrinsic:: for the numbers.\n-          // (#2594)\n+          // FIXME (#2594): fetch constants out of intrinsic:: for the\n+          // numbers.\n           ty::ty_fn(fty) {\n             let pureval = alt fty.purity {\n               ast::pure_fn { 0u }\n@@ -226,10 +226,10 @@ impl methods for reflector {\n             self.visit(\"leave_class\", extra);\n           }\n \n-          // FIXME: visiting all the variants in turn is probably\n-          // not ideal. It'll work but will get costly on big enums.\n-          // Maybe let the visitor tell us if it wants to visit only\n-          // a particular variant? (#2595)\n+          // FIXME (#2595): visiting all the variants in turn is probably\n+          // not ideal. It'll work but will get costly on big enums. Maybe\n+          // let the visitor tell us if it wants to visit only a particular\n+          // variant?\n           ty::ty_enum(did, substs) {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;"}, {"sha": "f28d0b53e538d167844ff4e61985fe67a279098f", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -491,7 +491,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         // Compute the minimum and maximum size and alignment for each\n         // variant.\n         //\n-        // FIXME: We could do better here; e.g. we know that any\n+        // NB: We could do better here; e.g. we know that any\n         // variant that contains (T,T) must be as least as large as\n         // any variant that contains just T.\n         let mut ranges = [];\n@@ -500,7 +500,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             let mut min_size = 0u, min_align = 0u;\n             for vec::each(variant.args) {|elem_t|\n                 if ty::type_has_params(elem_t) {\n-                    // FIXME: We could do better here; this causes us to\n+                    // NB: We could do better here; this causes us to\n                     // conservatively assume that (int, T) has minimum size 0,\n                     // when in fact it has minimum size sizeof(int).\n                     bounded = false;\n@@ -699,7 +699,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // Computes the static size of a enum, without using mk_tup(), which is\n // bad for performance.\n //\n-// FIXME: Migrate trans over to use this.\n+// NB: Migrate trans over to use this.\n \n // Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {"}, {"sha": "d05629b990f0f2edbb19c8a3d3ea88673c98e8f0", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -422,8 +422,9 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n     // Calculate the last pointer address we want to handle.\n-    // FIXME: Optimize this when the size of the unit type is statically\n-    // known to not use pointer casts, which tend to confuse LLVM. (#2536)\n+    // FIXME (#2536): Optimize this when the size of the unit type is\n+    // statically known to not use pointer casts, which tend to confuse\n+    // LLVM.\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n     // Now perform the iteration."}, {"sha": "628d407feadc71a62328d387c437f4c145e950e4", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -183,8 +183,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_repr, val.id);\n       }\n       expr_index(base, _) | expr_field(base, _, _) {\n-        // FIXME could be more careful and not count fields\n-        // after the chosen field (#2537)\n+        // FIXME (#2537): could be more careful and not count fields after\n+        // the chosen field.\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n "}, {"sha": "f20ad0f73dc80f032b0dca80326d2453f1977f57", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -243,8 +243,8 @@ fn trit_str(t: trit) -> str {\n     alt t { dont_care { \"?\" } ttrue { \"1\" } tfalse { \"0\" } }\n }\n \n-// FIXME: Would be nice to have unit tests for some of these operations, as\n-// a step towards formalizing them more rigorously. #2538\n+// FIXME (#2538): Would be nice to have unit tests for some of these\n+// operations, as a step towards formalizing them more rigorously.\n \n //\n // Local Variables:"}, {"sha": "5fb79dc1318d6beb2099aa676a3d29e0db02aa5f", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -195,8 +195,8 @@ may be the operator in a \"check\" expression in the source.  */\n \n type constraint = {\n     path: @path,\n-    // FIXME: really only want it to be mut during collect_locals.\n-    // freeze it after that. (#2539)\n+    // FIXME (#2539): really only want it to be mut during\n+    // collect_locals.  freeze it after that.\n     descs: @dvec<pred_args>\n };\n \n@@ -494,9 +494,8 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n     ret rslt;\n }\n \n-// FIXME\n-// Would rather take an immutable vec as an argument,\n-// should freeze it at some earlier point. (#2539)\n+// FIXME (#2539): Would rather take an immutable vec as an argument,\n+// should freeze it at some earlier point.\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\","}, {"sha": "4883422a90872d6ce0b5903c98be2d093e6b1fac", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -169,9 +169,9 @@ fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n                             id: node_id, ops: [init_op], bs: [@expr],\n                             cf: ret_style) -> bool {\n     let mut changed = find_pre_post_state_expr(fcx, pres, a);\n-    // FIXME: This could be a typestate constraint (except we're\n-    // not using them inside the compiler, I guess... see\n-    // discussion at #2178)\n+    // FIXME (#2178): This could be a typestate constraint (except we're\n+    // not using them inside the compiler, I guess... see discussion in\n+    // bug)\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n                                   #fmt[\"mismatched arg lengths: \\"}, {"sha": "7bcc4840d25e26f4f1177752e86069e44cfda110", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -25,10 +25,10 @@ export to_str;\n    01 = \"this constraint is definitely true\"\n    00 = \"this constraint is definitely false\"\n    11 should never appear\n- FIXME: typestate precondition (uncertain and val must\n+ FIXME (#2178): typestate precondition (uncertain and val must\n  have the same length; 11 should never appear in a given position)\n  (except we're not putting typestate constraints in the compiler, as\n- per discussion at #2178).\n+ per discussion at).\n */\n \n type t = {uncertain: bitv::bitv, val: bitv::bitv, nbits: uint};\n@@ -90,8 +90,8 @@ fn trit_or(a: trit, b: trit) -> trit {\n       tfalse {\n         alt b {\n           ttrue { dont_care }\n-          /* FIXME: ??????\n-             Again, unit tests would help here -- #2538\n+          /* FIXME (#2538): ??????\n+             Again, unit tests would help here\n            */\n           _ {\n             tfalse\n@@ -101,12 +101,11 @@ fn trit_or(a: trit, b: trit) -> trit {\n     }\n }\n \n-// FIXME: This still seems kind of dodgy to me (that is,\n+// FIXME (#2538): This still seems kind of dodgy to me (that is,\n // that 1 + ? = 1. But it might work out given that\n // all variables start out in a 0 state. Probably I need\n // to make it so that all constraints start out in a 0 state\n // (we consider a constraint false until proven true), too.\n-// #2538 would help.\n fn trit_and(a: trit, b: trit) -> trit {\n     alt a {\n       dont_care { b }"}, {"sha": "3083563d220e6c5f173e9191f3dae8401df4b39c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -1209,7 +1209,6 @@ pure fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-// FIXME maybe inline this for speed?\n fn type_is_immediate(ty: t) -> bool {\n     ret type_is_scalar(ty) || type_is_boxed(ty) ||\n         type_is_unique(ty) || type_is_region_ptr(ty);\n@@ -1614,7 +1613,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      // FIXME: is self ever const?\n+      // FIXME (#2663): is self ever const?\n       ty_self { kind_noncopyable() }\n       ty_var(_) | ty_var_integral(_) {\n         cx.sess.bug(\"Asked to compute kind of a type variable\");\n@@ -2038,7 +2037,6 @@ fn hash_type_structure(st: sty) -> uint {\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let mut h = id;\n         h = (h << 2u) + hash_def(h, c.node.id);\n-        // FIXME this makes little sense\n         for c.node.args.each {|a|\n             alt a.node {\n               carg_base { h += h << 2u; }\n@@ -2169,7 +2167,6 @@ fn args_eq<T>(eq: fn(T, T) -> bool,\n fn constr_eq(c: @constr, d: @constr) -> bool {\n     fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n-            // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n "}, {"sha": "b693ddb8492e7ed86282f0cf4269f0bf60479e39", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -25,8 +25,8 @@ import rscope::*;\n \n fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n-    // FIXME: hooking into the \"intrinsic\" root module is crude.\n-    // there ought to be a better approach. Attributes? (#2592)\n+    // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n+    // There ought to be a better approach. Attributes?\n \n     for crate.node.module.items.each {|crate_item|\n         if *crate_item.ident == \"intrinsic\" {"}, {"sha": "e948e999e5c8c95692d39334028b024a51c37f4f", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -387,10 +387,10 @@ fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     #debug[\"can_mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)];\n \n-    // FIXME---this will not unroll any entries we make in the\n-    // borrowings table.  But this is OK for the moment because this\n-    // is only used in method lookup, and there must be exactly one\n-    // match or an error is reported. Still, it should be fixed. (#2593)\n+    // FIXME (#2593): this will not unroll any entries we make in the\n+    // borrowings table.  But this is OK for the moment because this is only\n+    // used in method lookup, and there must be exactly one match or an\n+    // error is reported. Still, it should be fixed.\n \n     indent {|| cx.probe {||\n         cx.assign_tys(anmnt, a, b)\n@@ -1707,16 +1707,16 @@ fn super_fns<C:combine>(\n             argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n                 self.tys(a_f.output, b_f.output).chain {|output|\n                     self.purities(a_f.purity, b_f.purity).chain {|purity|\n-                    //FIXME self.infcx().constrvecs(a_f.constraints,\n-                    //FIXME                         b_f.constraints).then {||\n-                    // (Fix this if #2588 doesn't get accepted)\n+                    // FIXME: uncomment if #2588 doesn't get accepted:\n+                    // self.infcx().constrvecs(a_f.constraints,\n+                    //                         b_f.constraints).then {||\n                         ok({purity: purity,\n                             proto: p,\n                             inputs: inputs,\n                             output: output,\n                             ret_style: rs,\n                             constraints: a_f.constraints})\n-                    //FIXME }\n+                    // }\n                     }\n                 }\n             }"}, {"sha": "6e6c5fa740e5ce8c98f48335d276fe8f2d491f70", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -70,8 +70,8 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n }\n \n fn is_main_name(path: syntax::ast_map::path) -> bool {\n-    // FIXME: path should be a constrained type, so we know\n-    // the call to last doesn't fail (#34)\n+    // FIXME (#34): path should be a constrained type, so we know\n+    // the call to last doesn't fail.\n     vec::last(path) == syntax::ast_map::path_name(@\"main\")\n }\n "}, {"sha": "f39fe1f8120d0c2556f6610623488b37a2d02db3", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -8,7 +8,7 @@\n     for testing purposes. It doesn't surve any functional\n     purpose. This here, for instance, is just some filler text.\n \n-    FIXME (1654): It would be nice if we could run some automated\n+    FIXME (#1654): It would be nice if we could run some automated\n     tests on this file\n \n \"];"}, {"sha": "84d7c8c31fd3b6e1f53b0e20aea685ea1acc3b9c", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312faf31dfcce7a2d15495c5042d80a3e3b476c9/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=312faf31dfcce7a2d15495c5042d80a3e3b476c9", "patch": "@@ -20,9 +20,9 @@ type section = {\n     body: str\n };\n \n-// FIXME: We currently give topmod the name of the crate.  There would\n-// probably be fewer special cases if the crate had its own name and\n-// topmod's name was the empty string. (#2596)\n+// FIXME (#2596): We currently give topmod the name of the crate.  There\n+// would probably be fewer special cases if the crate had its own name\n+// and topmod's name was the empty string.\n type cratedoc = {\n     topmod: moddoc,\n };"}]}