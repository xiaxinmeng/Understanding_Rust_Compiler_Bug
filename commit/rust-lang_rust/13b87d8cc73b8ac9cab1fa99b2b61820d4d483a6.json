{"sha": "13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "node_id": "C_kwDOAAsO6NoAKDEzYjg3ZDhjYzczYjhhYzljYWIxZmE5OWIyYjYxODIwZDRkNDgzYTY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-25T04:51:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-25T04:51:14Z"}, "message": "Rollup merge of #93269 - jacobbramley:dev/pauth-option-1, r=petrochenkov\n\nUse error-on-mismatch policy for PAuth module flags.\n\nThis agrees with Clang, and avoids an error when using LTO with mixed\nC/Rust. LLVM considers different behaviour flags to be a mismatch,\neven when the flag value itself is the same.\n\nThis also makes the flag setting explicit for all uses of\nLLVMRustAddModuleFlag.\n\n----\n\nI believe that this fixes #92885, but have only reproduced it locally on Linux hosts so cannot confirm that it fixes the issue as reported.\n\nI have not included a test for this because it is covered by an existing test (`src/test/run-make-fulldeps/cross-lang-lto-clang`). It is not without its problems, though:\n* The test requires Clang and `--run-clang-based-tests-with=...` to run, and this is not the case on the CI.\n   * Any test I add would have a similar requirement.\n* With this patch applied, the test gets further, but it still fails (for other reasons). I don't think that affects #92885.", "tree": {"sha": "937d7106779ef49d1997a2178f187af99809a09a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/937d7106779ef49d1997a2178f187af99809a09a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh74HCCRBK7hj4Ov3rIwAAFhsIAK8s+kM0Ja5+D55v1H55YfOW\nAjsub7DPOUW1eP27/DmGNhOIyVbGT+aZCDBqGKk/Bl0f4871FtRIcF8hi/MjuNXr\nRh99FZichmxI6xzBR6HzS9gXZ5fZjsPliWqG+9Id592S2b2Em1J8kMe1WBHz4y/O\nTbpOf3ygaOCEaBJSWRaiZgM41G6YiW+M+yk5KJxTzXYy314xjXXPBgxWZndy3QTK\naclLAfk3zqyxJgM5puQNPSNH5nPo8jRPi0MwBIU3VnveoyJz2XcSY3i9iu/IzKRo\nP/LS5K1R2D0FvHbnQMkGSEedUKrzRn/1a1y5zlLUBnJJIU+kCY5GsvKHvrZeOe4=\n=dF/V\n-----END PGP SIGNATURE-----\n", "payload": "tree 937d7106779ef49d1997a2178f187af99809a09a\nparent c3ddca6d4a3cc36337101685f100e0ca9c5e9626\nparent e02e9582d253ffaa04c9137f732efb0b80f98907\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643086274 +0100\ncommitter GitHub <noreply@github.com> 1643086274 +0100\n\nRollup merge of #93269 - jacobbramley:dev/pauth-option-1, r=petrochenkov\n\nUse error-on-mismatch policy for PAuth module flags.\n\nThis agrees with Clang, and avoids an error when using LTO with mixed\nC/Rust. LLVM considers different behaviour flags to be a mismatch,\neven when the flag value itself is the same.\n\nThis also makes the flag setting explicit for all uses of\nLLVMRustAddModuleFlag.\n\n----\n\nI believe that this fixes #92885, but have only reproduced it locally on Linux hosts so cannot confirm that it fixes the issue as reported.\n\nI have not included a test for this because it is covered by an existing test (`src/test/run-make-fulldeps/cross-lang-lto-clang`). It is not without its problems, though:\n* The test requires Clang and `--run-clang-based-tests-with=...` to run, and this is not the case on the CI.\n   * Any test I add would have a similar requirement.\n* With this patch applied, the test gets further, but it still fails (for other reasons). I don't think that affects #92885.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "html_url": "https://github.com/rust-lang/rust/commit/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ddca6d4a3cc36337101685f100e0ca9c5e9626", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ddca6d4a3cc36337101685f100e0ca9c5e9626", "html_url": "https://github.com/rust-lang/rust/commit/c3ddca6d4a3cc36337101685f100e0ca9c5e9626"}, {"sha": "e02e9582d253ffaa04c9137f732efb0b80f98907", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02e9582d253ffaa04c9137f732efb0b80f98907", "html_url": "https://github.com/rust-lang/rust/commit/e02e9582d253ffaa04c9137f732efb0b80f98907"}], "stats": {"total": 86, "additions": 73, "deletions": 13}, "files": [{"sha": "8672459b5da3aae9191938309ca7e29808314256", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "patch": "@@ -215,16 +215,19 @@ pub unsafe fn create_module<'ll>(\n     // to ensure intrinsic calls don't use it.\n     if !sess.needs_plt() {\n         let avoid_plt = \"RtLibUseGOT\\0\".as_ptr().cast();\n-        llvm::LLVMRustAddModuleFlag(llmod, avoid_plt, 1);\n+        llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Warning, avoid_plt, 1);\n     }\n \n     if sess.is_sanitizer_cfi_enabled() {\n         // FIXME(rcvalle): Add support for non canonical jump tables.\n         let canonical_jump_tables = \"CFI Canonical Jump Tables\\0\".as_ptr().cast();\n-        // FIXME(rcvalle): Add it with Override behavior flag--LLVMRustAddModuleFlag adds it with\n-        // Warning behavior flag. Add support for specifying the behavior flag to\n-        // LLVMRustAddModuleFlag.\n-        llvm::LLVMRustAddModuleFlag(llmod, canonical_jump_tables, 1);\n+        // FIXME(rcvalle): Add it with Override behavior flag.\n+        llvm::LLVMRustAddModuleFlag(\n+            llmod,\n+            llvm::LLVMModFlagBehavior::Warning,\n+            canonical_jump_tables,\n+            1,\n+        );\n     }\n \n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n@@ -233,11 +236,21 @@ pub unsafe fn create_module<'ll>(\n             CFGuard::Disabled => {}\n             CFGuard::NoChecks => {\n                 // Set `cfguard=1` module flag to emit metadata only.\n-                llvm::LLVMRustAddModuleFlag(llmod, \"cfguard\\0\".as_ptr() as *const _, 1)\n+                llvm::LLVMRustAddModuleFlag(\n+                    llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"cfguard\\0\".as_ptr() as *const _,\n+                    1,\n+                )\n             }\n             CFGuard::Checks => {\n                 // Set `cfguard=2` module flag to emit metadata and checks.\n-                llvm::LLVMRustAddModuleFlag(llmod, \"cfguard\\0\".as_ptr() as *const _, 2)\n+                llvm::LLVMRustAddModuleFlag(\n+                    llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"cfguard\\0\".as_ptr() as *const _,\n+                    2,\n+                )\n             }\n         }\n     }\n@@ -247,24 +260,28 @@ pub unsafe fn create_module<'ll>(\n \n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"branch-target-enforcement\\0\".as_ptr().cast(),\n             bti.into(),\n         );\n \n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address\\0\".as_ptr().cast(),\n             pac.is_some().into(),\n         );\n         let pac_opts = pac.unwrap_or(PacRet { leaf: false, key: PAuthKey::A });\n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address-all\\0\".as_ptr().cast(),\n             pac_opts.leaf.into(),\n         );\n         let is_bkey = if pac_opts.key == PAuthKey::A { false } else { true };\n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address-with-bkey\\0\".as_ptr().cast(),\n             is_bkey.into(),\n         );"}, {"sha": "28eb8e2a0a462de1e22b3fcb803d73cdc3cddf80", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "patch": "@@ -108,18 +108,29 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n             // This can be overridden using --llvm-opts -dwarf-version,N.\n             // Android has the same issue (#22398)\n             if let Some(version) = sess.target.dwarf_version {\n-                llvm::LLVMRustAddModuleFlag(self.llmod, \"Dwarf Version\\0\".as_ptr().cast(), version)\n+                llvm::LLVMRustAddModuleFlag(\n+                    self.llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"Dwarf Version\\0\".as_ptr().cast(),\n+                    version,\n+                )\n             }\n \n             // Indicate that we want CodeView debug information on MSVC\n             if sess.target.is_like_msvc {\n-                llvm::LLVMRustAddModuleFlag(self.llmod, \"CodeView\\0\".as_ptr().cast(), 1)\n+                llvm::LLVMRustAddModuleFlag(\n+                    self.llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"CodeView\\0\".as_ptr().cast(),\n+                    1,\n+                )\n             }\n \n             // Prevent bitcode readers from deleting the debug info.\n             let ptr = \"Debug Info Version\\0\".as_ptr();\n             llvm::LLVMRustAddModuleFlag(\n                 self.llmod,\n+                llvm::LLVMModFlagBehavior::Warning,\n                 ptr.cast(),\n                 llvm::LLVMRustDebugMetadataVersion(),\n             );"}, {"sha": "2b102188790389dc86445e6be4393ca049f62350", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "patch": "@@ -61,6 +61,26 @@ pub enum LLVMMachineType {\n     ARM = 0x01c0,\n }\n \n+/// LLVM's Module::ModFlagBehavior, defined in llvm/include/llvm/IR/Module.h.\n+///\n+/// When merging modules (e.g. during LTO), their metadata flags are combined. Conflicts are\n+/// resolved according to the merge behaviors specified here. Flags differing only in merge\n+/// behavior are still considered to be in conflict.\n+///\n+/// In order for Rust-C LTO to work, we must specify behaviors compatible with Clang. Notably,\n+/// 'Error' and 'Warning' cannot be mixed for a given flag.\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum LLVMModFlagBehavior {\n+    Error = 1,\n+    Warning = 2,\n+    Require = 3,\n+    Override = 4,\n+    Append = 5,\n+    AppendUnique = 6,\n+    Max = 7,\n+}\n+\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n /// LLVM CallingConv::ID. Should we wrap this?\n@@ -1895,7 +1915,16 @@ extern \"C\" {\n \n     pub fn LLVMRustIsRustLLVM() -> bool;\n \n-    pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n+    /// Add LLVM module flags.\n+    ///\n+    /// In order for Rust-C LTO to work, module flags must be compatible with Clang. What\n+    /// \"compatible\" means depends on the merge behaviors involved.\n+    pub fn LLVMRustAddModuleFlag(\n+        M: &Module,\n+        merge_behavior: LLVMModFlagBehavior,\n+        name: *const c_char,\n+        value: u32,\n+    );\n \n     pub fn LLVMRustMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n "}, {"sha": "dcd6327c92f6a38789a747473ac8ca6d11bc1b55", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "patch": "@@ -722,9 +722,12 @@ extern \"C\" bool LLVMRustIsRustLLVM() {\n #endif\n }\n \n-extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *Name,\n-                                      uint32_t Value) {\n-  unwrap(M)->addModuleFlag(Module::Warning, Name, Value);\n+extern \"C\" void LLVMRustAddModuleFlag(\n+    LLVMModuleRef M,\n+    Module::ModFlagBehavior MergeBehavior,\n+    const char *Name,\n+    uint32_t Value) {\n+  unwrap(M)->addModuleFlag(MergeBehavior, Name, Value);\n }\n \n extern \"C\" LLVMValueRef LLVMRustMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD) {"}]}