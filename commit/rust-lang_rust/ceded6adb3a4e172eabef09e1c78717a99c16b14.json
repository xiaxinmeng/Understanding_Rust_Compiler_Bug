{"sha": "ceded6adb3a4e172eabef09e1c78717a99c16b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZGVkNmFkYjNhNGUxNzJlYWJlZjA5ZTFjNzg3MTdhOTljMTZiMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T22:12:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T22:12:46Z"}, "message": "Auto merge of #27210 - vadimcn:win64-eh-pers, r=alexcrichton\n\nAfter this change, the only remaining symbol we are pulling from libgcc on Win64 is `__chkstk_ms` - the stack probing routine.", "tree": {"sha": "3cca4bd7b8a31d8c82b6cdf34c668d2dea010aab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cca4bd7b8a31d8c82b6cdf34c668d2dea010aab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceded6adb3a4e172eabef09e1c78717a99c16b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceded6adb3a4e172eabef09e1c78717a99c16b14", "html_url": "https://github.com/rust-lang/rust/commit/ceded6adb3a4e172eabef09e1c78717a99c16b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceded6adb3a4e172eabef09e1c78717a99c16b14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d877e6540431d99b0945a3d27eeb466b0d693902", "url": "https://api.github.com/repos/rust-lang/rust/commits/d877e6540431d99b0945a3d27eeb466b0d693902", "html_url": "https://github.com/rust-lang/rust/commit/d877e6540431d99b0945a3d27eeb466b0d693902"}, {"sha": "96d1db2b1a43a149a1d0436a03a72aa01a39efd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/96d1db2b1a43a149a1d0436a03a72aa01a39efd2", "html_url": "https://github.com/rust-lang/rust/commit/96d1db2b1a43a149a1d0436a03a72aa01a39efd2"}], "stats": {"total": 904, "additions": 667, "deletions": 237}, "files": [{"sha": "39de8920f098cb34cd7e77a3fc93162e3929b957", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -54,6 +54,7 @@ fn main(argc: isize, argv: *const *const u8) -> isize {\n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to"}, {"sha": "e530a9f1051a5ea02ff6ca0fa7941eec57e61990", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -39,6 +39,7 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -63,6 +64,7 @@ pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -150,6 +152,7 @@ extern fn panic_fmt(args: &core::fmt::Arguments,\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n # fn main() {}\n ```"}, {"sha": "da1b9f48eda72ea48d39883fc6047111a5a18c15", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -327,6 +327,7 @@ lets_do_this! {\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n     EhPersonalityCatchLangItem,      \"eh_personality_catch\",    eh_personality_catch;\n+    EhUnwindResumeLangItem,          \"eh_unwind_resume\",        eh_unwind_resume;\n     MSVCTryFilterLangItem,           \"msvc_try_filter\",         msvc_try_filter;\n \n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;"}, {"sha": "934f7c0688c172fd95cd49aff0d317c887fecdd6", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -45,6 +45,10 @@ pub fn check_crate(krate: &ast::Crate,\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n+    if sess.target.target.options.custom_unwind_resume &\n+       items.eh_unwind_resume().is_none() {\n+        items.missing.push(lang_items::EhUnwindResumeLangItem);\n+    }\n \n     {\n         let mut cx = Context { sess: sess, items: items };\n@@ -122,4 +126,5 @@ weak_lang_items! {\n     panic_fmt,          PanicFmtLangItem,           rust_begin_unwind;\n     stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n+    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n }"}, {"sha": "ce05a8878ff4b9e0145374f7bce9fdcdeca26f3b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -171,6 +171,11 @@ pub struct TargetOptions {\n     /// currently only \"gnu\" is used to fall into LLVM. Unknown strings cause\n     /// the system linker to be used.\n     pub archive_format: String,\n+    /// Whether the target uses a custom unwind resumption routine.\n+    /// By default LLVM lowers `resume` instructions into calls to `_Unwind_Resume`\n+    /// defined in libgcc.  If this option is enabled, the target must provide\n+    /// `eh_unwind_resume` lang item.\n+    pub custom_unwind_resume: bool,\n }\n \n impl Default for TargetOptions {\n@@ -209,6 +214,7 @@ impl Default for TargetOptions {\n             pre_link_objects: Vec::new(),\n             post_link_objects: Vec::new(),\n             archive_format: String::new(),\n+            custom_unwind_resume: false,\n         }\n     }\n }"}, {"sha": "aef1d7471b85b1d415f2d723dcb66bf11b2d2bf0", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n     // On Win64 unwinding is handled by the OS, so we can link libgcc statically.\n     base.pre_link_args.push(\"-static-libgcc\".to_string());\n     base.pre_link_args.push(\"-m64\".to_string());\n+    base.custom_unwind_resume = true;\n \n     Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),"}, {"sha": "a5f2306aac80613c945a6dd9160fffb3d980302a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -2171,6 +2171,12 @@ fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n             llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n         }\n     }\n+    if ccx.tcx().lang_items.eh_unwind_resume() == Some(def) {\n+        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n+        if ccx.use_dll_storage_attrs() {\n+            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n+        }\n+    }\n }\n \n fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "5e472e45775d0fc469ea40f6ccbf7bc81bbf7f10", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -846,6 +846,8 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n         debug!(\"get_or_create_landing_pad\");\n \n+        self.inject_unwind_resume_hook();\n+\n         // Check if a landing pad block exists; if not, create one.\n         {\n             let mut scopes = self.scopes.borrow_mut();"}, {"sha": "d0b81b38ab7a728923e82f95ed9af8c0ceb0e47c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -561,6 +561,55 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// By default, LLVM lowers `resume` instructions into calls to `_Unwind_Resume`\n+    /// defined in libgcc, however, unlike personality routines, there is no easy way to\n+    /// override that symbol.  This method injects a local-scoped `_Unwind_Resume` function\n+    /// which immediately defers to the user-defined `eh_unwind_resume` lang item.\n+    pub fn inject_unwind_resume_hook(&self) {\n+        let ccx = self.ccx;\n+        if !ccx.sess().target.target.options.custom_unwind_resume ||\n+           ccx.unwind_resume_hooked().get() {\n+            return;\n+        }\n+\n+        let new_resume = match ccx.tcx().lang_items.eh_unwind_resume() {\n+            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0), &self.param_substs).val,\n+            None => {\n+                let fty = Type::variadic_func(&[], &Type::void(self.ccx));\n+                declare::declare_cfn(self.ccx, \"rust_eh_unwind_resume\", fty,\n+                                     self.ccx.tcx().mk_nil())\n+            }\n+        };\n+\n+        unsafe {\n+            let resume_type = Type::func(&[Type::i8(ccx).ptr_to()], &Type::void(ccx));\n+            let old_resume = llvm::LLVMAddFunction(ccx.llmod(),\n+                                                   \"_Unwind_Resume\\0\".as_ptr() as *const _,\n+                                                   resume_type.to_ref());\n+            llvm::SetLinkage(old_resume, llvm::InternalLinkage);\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(),\n+                                                           old_resume,\n+                                                           \"\\0\".as_ptr() as *const _);\n+            let builder = ccx.builder();\n+            builder.position_at_end(llbb);\n+            builder.call(new_resume, &[llvm::LLVMGetFirstParam(old_resume)], None);\n+            builder.unreachable(); // it should never return\n+\n+            // Until DwarfEHPrepare pass has run, _Unwind_Resume is not referenced by any live code\n+            // and is subject to dead code elimination.  Here we add _Unwind_Resume to @llvm.globals\n+            // to prevent that.\n+            let i8p_ty = Type::i8p(ccx);\n+            let used_ty = Type::array(&i8p_ty, 1);\n+            let used = llvm::LLVMAddGlobal(ccx.llmod(), used_ty.to_ref(),\n+                                           \"llvm.used\\0\".as_ptr() as *const _);\n+            let old_resume = llvm::LLVMConstBitCast(old_resume, i8p_ty.to_ref());\n+            llvm::LLVMSetInitializer(used, C_array(i8p_ty, &[old_resume]));\n+            llvm::SetLinkage(used, llvm::AppendingLinkage);\n+            llvm::LLVMSetSection(used, \"llvm.metadata\\0\".as_ptr() as *const _)\n+        }\n+        ccx.unwind_resume_hooked().set(true);\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block"}, {"sha": "b7b7b28a42bfb3d9c21a6d5213dc2886dc48a712", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -146,6 +146,7 @@ pub struct LocalCrateContext<'tcx> {\n \n     eh_personality: RefCell<Option<ValueRef>>,\n     rust_try_fn: RefCell<Option<ValueRef>>,\n+    unwind_resume_hooked: Cell<bool>,\n \n     intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n \n@@ -466,6 +467,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 rust_try_fn: RefCell::new(None),\n+                unwind_resume_hooked: Cell::new(false),\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 trait_cache: RefCell::new(FnvHashMap()),\n@@ -735,6 +737,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.rust_try_fn\n     }\n \n+    pub fn unwind_resume_hooked<'a>(&'a self) -> &'a Cell<bool> {\n+        &self.local.unwind_resume_hooked\n+    }\n+\n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n         &self.local.intrinsics\n     }"}, {"sha": "0400771dff15c0cebe0f1b967447b2af19b95d34", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 47, "deletions": 104, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -16,6 +16,7 @@ use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeK\n use middle::subst;\n use middle::subst::FnSpace;\n use trans::adt;\n+use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -1159,26 +1160,14 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n // instructions).\n //\n-// This translation is a little surprising for two reasons:\n+// This translation is a little surprising because\n+// we always call a shim function instead of inlining the call to `invoke`\n+// manually here. This is done because in LLVM we're only allowed to have one\n+// personality per function definition. The call to the `try` intrinsic is\n+// being inlined into the function calling it, and that function may already\n+// have other personality functions in play. By calling a shim we're\n+// guaranteed that our shim will have the right personality function.\n //\n-// 1. We always call a shim function instead of inlining the call to `invoke`\n-//    manually here. This is done because in LLVM we're only allowed to have one\n-//    personality per function definition. The call to the `try` intrinsic is\n-//    being inlined into the function calling it, and that function may already\n-//    have other personality functions in play. By calling a shim we're\n-//    guaranteed that our shim will have the right personality function.\n-//\n-// 2. Instead of making one shim (explained above), we make two shims! The\n-//    reason for this has to do with the technical details about the\n-//    implementation of unwinding in the runtime, but the tl;dr; is that the\n-//    outer shim's personality function says \"catch rust exceptions\" and the\n-//    inner shim's landing pad will not `resume` the exception being thrown.\n-//    This means that the outer shim's landing pad is never run and the inner\n-//    shim's return value is the return value of the whole call.\n-//\n-// The double-shim aspect is currently done for implementation ease on the\n-// runtime side of things, and more info can be found in\n-// src/libstd/rt/unwind/gcc.rs.\n fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              func: ValueRef,\n                              data: ValueRef,\n@@ -1188,108 +1177,63 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let ccx = bcx.ccx();\n         let dloc = DebugLoc::None;\n \n-        // Type indicator for the exception being thrown, not entirely sure\n-        // what's going on here but it's what all the examples in LLVM use.\n-        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n-                                    false);\n+        // Translates the shims described above:\n+        //\n+        //   bcx:\n+        //      invoke %func(%args...) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret null\n+        //\n+        //   catch:\n+        //      (ptr, _) = landingpad\n+        //      ret ptr\n \n-        // Define the \"inner try\" shim\n-        let rust_try_inner = declare::define_internal_rust_fn(ccx,\n-                                                              \"__rust_try_inner\",\n-                                                              try_fn_ty);\n-        trans_rust_try(ccx, rust_try_inner, lpad_ty, bcx.fcx.eh_personality(),\n-                       output, dloc, &mut |bcx, then, catch| {\n-            let func = llvm::get_param(rust_try_inner, 0);\n-            let data = llvm::get_param(rust_try_inner, 1);\n-            Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n-            C_null(Type::i8p(ccx))\n-        });\n-\n-        // Define the \"outer try\" shim.\n-        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\",\n-                                                        try_fn_ty);\n+        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\", try_fn_ty);\n+        attributes::emit_uwtable(rust_try, true);\n         let catch_pers = match bcx.tcx().lang_items.eh_personality_catch() {\n             Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n                                               bcx.fcx.param_substs).val,\n             None => bcx.tcx().sess.bug(\"eh_personality_catch not defined\"),\n         };\n-        trans_rust_try(ccx, rust_try, lpad_ty, catch_pers, output, dloc,\n-                       &mut |bcx, then, catch| {\n-            let func = llvm::get_param(rust_try, 0);\n-            let data = llvm::get_param(rust_try, 1);\n-            Invoke(bcx, rust_try_inner, &[func, data], then.llbb, catch.llbb,\n-                   None, dloc)\n-        });\n-        return rust_try\n-    });\n \n-    // Note that no invoke is used here because by definition this function\n-    // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n-    Store(bcx, ret, dest);\n-    return bcx;\n-\n-    // Translates both the inner and outer shims described above. The only\n-    // difference between these two is the function invoked and the personality\n-    // involved, so a common routine is shared.\n-    //\n-    //   bcx:\n-    //      invoke %func(%args...) normal %normal unwind %unwind\n-    //\n-    //   normal:\n-    //      ret null\n-    //\n-    //   unwind:\n-    //      (ptr, _) = landingpad\n-    //      br (ptr != null), done, reraise\n-    //\n-    //   done:\n-    //      ret ptr\n-    //\n-    //   reraise:\n-    //      resume\n-    //\n-    // Note that the branch checking for `null` here isn't actually necessary,\n-    // it's just an unfortunate hack to make sure that LLVM doesn't optimize too\n-    // much. If this were not present, then LLVM would correctly deduce that our\n-    // inner shim should be tagged with `nounwind` (as it catches all\n-    // exceptions) and then the outer shim's `invoke` will be translated to just\n-    // a simple call, destroying that entry for the personality function.\n-    //\n-    // To ensure that both shims always have an `invoke` this check against null\n-    // confuses LLVM enough to the point that it won't infer `nounwind` and\n-    // we'll proceed as normal.\n-    fn trans_rust_try<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                llfn: ValueRef,\n-                                lpad_ty: Type,\n-                                personality: ValueRef,\n-                                output: ty::FnOutput<'tcx>,\n-                                dloc: DebugLoc,\n-                                invoke: &mut FnMut(Block, Block, Block) -> ValueRef) {\n         let (fcx, block_arena);\n         block_arena = TypedArena::new();\n-        fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+        fcx = new_fn_ctxt(ccx, rust_try, ast::DUMMY_NODE_ID, false,\n                           output, ccx.tcx().mk_substs(Substs::trans_empty()),\n                           None, &block_arena);\n         let bcx = init_function(&fcx, true, output);\n         let then = bcx.fcx.new_temp_block(\"then\");\n         let catch = bcx.fcx.new_temp_block(\"catch\");\n-        let reraise = bcx.fcx.new_temp_block(\"reraise\");\n-        let catch_return = bcx.fcx.new_temp_block(\"catch-return\");\n \n-        let invoke_ret = invoke(bcx, then, catch);\n-        Ret(then, invoke_ret, dloc);\n-        let vals = LandingPad(catch, lpad_ty, personality, 1);\n+        let func = llvm::get_param(rust_try, 0);\n+        let data = llvm::get_param(rust_try, 1);\n+        Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+        Ret(then, C_null(Type::i8p(ccx)), dloc);\n+\n+        // Type indicator for the exception being thrown.\n+        // The first value in this tuple is a pointer to the exception object being thrown.\n+        // The second value is a \"selector\" indicating which of the landing pad clauses\n+        // the exception's type had been matched to.  rust_try ignores the selector.\n+        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n+                                    false);\n+        let vals = LandingPad(catch, lpad_ty, catch_pers, 1);\n         AddClause(catch, vals, C_null(Type::i8p(ccx)));\n         let ptr = ExtractValue(catch, vals, 0);\n-        let valid = ICmp(catch, llvm::IntNE, ptr, C_null(Type::i8p(ccx)), dloc);\n-        CondBr(catch, valid, catch_return.llbb, reraise.llbb, dloc);\n-        Ret(catch_return, ptr, dloc);\n-        Resume(reraise, vals);\n-    }\n+        Ret(catch, ptr, dloc);\n+        fcx.cleanup();\n+\n+        return rust_try\n+    });\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n+    Store(bcx, ret, dest);\n+    return bcx;\n }\n \n-// Helper to generate the `Ty` associated with `rust_Try`\n+// Helper to generate the `Ty` associated with `rust_try`\n fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                              f: &mut FnMut(Ty<'tcx>,\n                                            ty::FnOutput<'tcx>) -> ValueRef)\n@@ -1299,8 +1243,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         return llfn\n     }\n \n-    // Define the types up front for the signatures of the rust_try and\n-    // rust_try_inner functions.\n+    // Define the type up front for the signature of the rust_try function.\n     let tcx = ccx.tcx();\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "990501b28dba1a36c0164d79448dbca29a4e1331", "filename": "src/libstd/rt/dwarf/eh.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parsing of GCC-style Language-Specific Data Area (LSDA)\n+//! For details see:\n+//!   http://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/ehframechpt.html\n+//!   http://mentorembedded.github.io/cxx-abi/exceptions.pdf\n+//!   http://www.airs.com/blog/archives/460\n+//!   http://www.airs.com/blog/archives/464\n+//!\n+//! A reference implementation may be found in the GCC source tree\n+//! (<root>/libgcc/unwind-c.c as of this writing)\n+\n+#![allow(non_upper_case_globals)]\n+#![allow(unused)]\n+\n+use prelude::v1::*;\n+use rt::dwarf::DwarfReader;\n+use core::mem;\n+\n+pub const DW_EH_PE_omit     : u8 = 0xFF;\n+pub const DW_EH_PE_absptr   : u8 = 0x00;\n+\n+pub const DW_EH_PE_uleb128  : u8 = 0x01;\n+pub const DW_EH_PE_udata2   : u8 = 0x02;\n+pub const DW_EH_PE_udata4   : u8 = 0x03;\n+pub const DW_EH_PE_udata8   : u8 = 0x04;\n+pub const DW_EH_PE_sleb128  : u8 = 0x09;\n+pub const DW_EH_PE_sdata2   : u8 = 0x0A;\n+pub const DW_EH_PE_sdata4   : u8 = 0x0B;\n+pub const DW_EH_PE_sdata8   : u8 = 0x0C;\n+\n+pub const DW_EH_PE_pcrel    : u8 = 0x10;\n+pub const DW_EH_PE_textrel  : u8 = 0x20;\n+pub const DW_EH_PE_datarel  : u8 = 0x30;\n+pub const DW_EH_PE_funcrel  : u8 = 0x40;\n+pub const DW_EH_PE_aligned  : u8 = 0x50;\n+\n+pub const DW_EH_PE_indirect : u8 = 0x80;\n+\n+#[derive(Copy, Clone)]\n+pub struct EHContext {\n+    pub ip: usize,         // Current instruction pointer\n+    pub func_start: usize, // Address of the current function\n+    pub text_start: usize, // Address of the code section\n+    pub data_start: usize, // Address of the data section\n+}\n+\n+pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)\n+                               -> Option<usize> {\n+    if lsda.is_null() {\n+        return None;\n+    }\n+\n+    let func_start = context.func_start;\n+    let mut reader = DwarfReader::new(lsda);\n+\n+    let start_encoding = reader.read::<u8>();\n+    // base address for landing pad offsets\n+    let lpad_base = if start_encoding != DW_EH_PE_omit {\n+        read_encoded_pointer(&mut reader, context, start_encoding)\n+    } else {\n+        func_start\n+    };\n+\n+    let ttype_encoding = reader.read::<u8>();\n+    if ttype_encoding != DW_EH_PE_omit {\n+        // Rust doesn't analyze exception types, so we don't care about the type table\n+        reader.read_uleb128();\n+    }\n+\n+    let call_site_encoding = reader.read::<u8>();\n+    let call_site_table_length = reader.read_uleb128();\n+    let action_table = reader.ptr.offset(call_site_table_length as isize);\n+    // Return addresses point 1 byte past the call instruction, which could\n+    // be in the next IP range.\n+    let ip = context.ip-1;\n+\n+    while reader.ptr < action_table {\n+        let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+        let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+        let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding);\n+        let cs_action = reader.read_uleb128();\n+        // Callsite table is sorted by cs_start, so if we've passed the ip, we\n+        // may stop searching.\n+        if ip < func_start + cs_start {\n+            break\n+        }\n+        if ip < func_start + cs_start + cs_len {\n+            if cs_lpad != 0 {\n+                return Some(lpad_base + cs_lpad);\n+            } else {\n+                return None;\n+            }\n+        }\n+    }\n+    // IP range not found: gcc's C++ personality calls terminate() here,\n+    // however the rest of the languages treat this the same as cs_lpad == 0.\n+    // We follow this suit.\n+    return None;\n+}\n+\n+#[inline]\n+fn round_up(unrounded: usize, align: usize) -> usize {\n+    assert!(align.is_power_of_two());\n+    (unrounded + align - 1) & !(align - 1)\n+}\n+\n+unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n+                               context: &EHContext,\n+                               encoding: u8) -> usize {\n+    assert!(encoding != DW_EH_PE_omit);\n+\n+    // DW_EH_PE_aligned implies it's an absolute pointer value\n+    if encoding == DW_EH_PE_aligned {\n+        reader.ptr = round_up(reader.ptr as usize,\n+                              mem::size_of::<usize>()) as *const u8;\n+        return reader.read::<usize>();\n+    }\n+\n+    let mut result = match encoding & 0x0F {\n+        DW_EH_PE_absptr => reader.read::<usize>(),\n+        DW_EH_PE_uleb128 => reader.read_uleb128() as usize,\n+        DW_EH_PE_udata2 => reader.read::<u16>() as usize,\n+        DW_EH_PE_udata4 => reader.read::<u32>() as usize,\n+        DW_EH_PE_udata8 => reader.read::<u64>() as usize,\n+        DW_EH_PE_sleb128 => reader.read_sleb128() as usize,\n+        DW_EH_PE_sdata2 => reader.read::<i16>() as usize,\n+        DW_EH_PE_sdata4 => reader.read::<i32>() as usize,\n+        DW_EH_PE_sdata8 => reader.read::<i64>() as usize,\n+        _ => panic!()\n+    };\n+\n+    result += match encoding & 0x70 {\n+        DW_EH_PE_absptr => 0,\n+        // relative to address of the encoded value, despite the name\n+        DW_EH_PE_pcrel => reader.ptr as usize,\n+        DW_EH_PE_textrel => { assert!(context.text_start != 0);\n+                              context.text_start },\n+        DW_EH_PE_datarel => { assert!(context.data_start != 0);\n+                              context.data_start },\n+        DW_EH_PE_funcrel => { assert!(context.func_start != 0);\n+                              context.func_start },\n+        _ => panic!()\n+    };\n+\n+    if encoding & DW_EH_PE_indirect != 0 {\n+        result = *(result as *const usize);\n+    }\n+\n+    result\n+}"}, {"sha": "822826bcc837f08f67117d86cce4d8a77de0a63e", "filename": "src/libstd/rt/dwarf/mod.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdwarf%2Fmod.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utilities for parsing DWARF-encoded data streams.\n+//! See http://www.dwarfstd.org,\n+//! DWARF-4 standard, Section 7 - \"Data Representation\"\n+\n+// This module is used only by x86_64-pc-windows-gnu for now, but we\n+// are compiling it everywhere to avoid regressions.\n+#![allow(unused)]\n+\n+pub mod eh;\n+\n+use prelude::v1::*;\n+use core::mem;\n+\n+pub struct DwarfReader {\n+    pub ptr : *const u8\n+}\n+\n+#[repr(C,packed)]\n+struct Unaligned<T>(T);\n+\n+impl DwarfReader {\n+\n+    pub fn new(ptr : *const u8) -> DwarfReader {\n+        DwarfReader {\n+            ptr : ptr\n+        }\n+    }\n+\n+    // DWARF streams are packed, so e.g. a u32 would not necessarily be aligned\n+    // on a 4-byte boundary. This may cause problems on platforms with strict\n+    // alignment requirements. By wrapping data in a \"packed\" struct, we are\n+    // telling the backend to generate \"misalignment-safe\" code.\n+    pub unsafe fn read<T:Copy>(&mut self) -> T {\n+        let Unaligned(result) = *(self.ptr as *const Unaligned<T>);\n+        self.ptr = self.ptr.offset(mem::size_of::<T>() as isize);\n+        result\n+    }\n+\n+    // ULEB128 and SLEB128 encodings are defined in Section 7.6 - \"Variable\n+    // Length Data\".\n+    pub unsafe fn read_uleb128(&mut self) -> u64 {\n+        let mut shift : usize = 0;\n+        let mut result : u64 = 0;\n+        let mut byte : u8;\n+        loop {\n+            byte = self.read::<u8>();\n+            result |= ((byte & 0x7F) as u64) << shift;\n+            shift += 7;\n+            if byte & 0x80 == 0 {\n+                break;\n+            }\n+        }\n+        result\n+    }\n+\n+    pub unsafe fn read_sleb128(&mut self) -> i64 {\n+        let mut shift : usize = 0;\n+        let mut result : u64 = 0;\n+        let mut byte : u8;\n+        loop {\n+            byte = self.read::<u8>();\n+            result |= ((byte & 0x7F) as u64) << shift;\n+            shift += 7;\n+            if byte & 0x80 == 0 {\n+                break;\n+            }\n+        }\n+        // sign-extend\n+        if shift < 8 * mem::size_of::<u64>() && (byte & 0x40) != 0 {\n+            result |= (!0 as u64) << shift;\n+        }\n+        result as i64\n+    }\n+}\n+\n+#[test]\n+fn dwarf_reader() {\n+    let encoded: &[u8] = &[1,\n+                           2, 3,\n+                           4, 5, 6, 7,\n+                           0xE5, 0x8E, 0x26,\n+                           0x9B, 0xF1, 0x59,\n+                           0xFF, 0xFF];\n+\n+    let mut reader = DwarfReader::new(encoded.as_ptr());\n+\n+    unsafe {\n+        assert!(reader.read::<u8>() == u8::to_be(1u8));\n+        assert!(reader.read::<u16>() == u16::to_be(0x0203));\n+        assert!(reader.read::<u32>() == u32::to_be(0x04050607));\n+\n+        assert!(reader.read_uleb128() == 624485);\n+        assert!(reader.read_sleb128() == -624485);\n+\n+        assert!(reader.read::<i8>() == i8::to_be(-1));\n+    }\n+}"}, {"sha": "fde612014e9921f3b3f32b807d172b76894ca12d", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -36,6 +36,7 @@ pub enum _Unwind_Action {\n \n #[cfg(target_arch = \"arm\")]\n #[repr(C)]\n+#[derive(Copy, Clone)]\n pub enum _Unwind_State {\n     _US_VIRTUAL_UNWIND_FRAME = 0,\n     _US_UNWIND_FRAME_STARTING = 1,\n@@ -46,6 +47,7 @@ pub enum _Unwind_State {\n }\n \n #[repr(C)]\n+#[derive(Copy, Clone)]\n pub enum _Unwind_Reason_Code {\n     _URC_NO_REASON = 0,\n     _URC_FOREIGN_EXCEPTION_CAUGHT = 1,"}, {"sha": "414ccc911afebc4693220ca8c7d03b4ea1bd27ba", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -18,7 +18,7 @@ macro_rules! rterrln {\n         ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\")))\n     } );\n     ($fmt:expr, $($arg:expr),*) => ( {\n-        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\"), $($arg)*))\n+        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\"), $($arg),*))\n     } )\n }\n \n@@ -31,7 +31,7 @@ macro_rules! rtdebug {\n     } );\n     ($str:expr, $($arg:expr),*) => ( {\n         if cfg!(rtdebug) {\n-            rterrln!($str, $($arg)*)\n+            rterrln!($str, $($arg),*)\n         }\n     })\n }"}, {"sha": "56bf73db3992e0be77679c268047b74f5fe8d116", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -47,6 +47,8 @@ pub mod args;\n mod at_exit_imp;\n mod libunwind;\n \n+mod dwarf;\n+\n /// The default error code of the rust runtime if the main thread panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: isize = 101;"}, {"sha": "55deb048b7ee538db2f0acf941a75791e447d1a2", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "modified", "additions": 19, "deletions": 126, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -74,14 +74,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n //   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n // - rust_eh_personality_catch, used only by rust_try(), which always catches.\n //\n-// Note, however, that for implementation simplicity, rust_eh_personality_catch\n-// lacks code to install a landing pad, so in order to obtain exception object\n-// pointer (which it needs to return upstream), rust_try() employs another trick:\n-// it calls into the nested rust_try_inner(), whose landing pad does not resume\n-// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n-// return.\n-//\n-// See also: rt/rust_try.ll\n+// See also: rustc_trans::trans::intrinsic::trans_gnu_try\n \n #[cfg(all(not(target_arch = \"arm\"),\n           not(all(windows, target_arch = \"x86_64\")),\n@@ -118,19 +111,22 @@ pub mod eabi {\n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n     pub extern fn rust_eh_personality_catch(\n-        _version: c_int,\n+        version: c_int,\n         actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n \n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n+            unsafe {\n+                __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                     context)\n+            }\n         }\n     }\n }\n@@ -171,20 +167,20 @@ pub mod eabi {\n     #[lang = \"eh_personality_catch\"]\n     #[no_mangle]\n     pub extern fn rust_eh_personality_catch(\n-        _version: c_int,\n+        version: c_int,\n         actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n             unsafe {\n-                __gcc_personality_sj0(_version, actions, _exception_class, _ue_header,\n-                                      _context)\n+                __gcc_personality_sj0(version, actions, exception_class, ue_header,\n+                                      context)\n             }\n         }\n     }\n@@ -222,121 +218,18 @@ pub mod eabi {\n     #[no_mangle]\n     pub extern fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (state as c_int & uw::_US_ACTION_MASK as c_int)\n                            == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n-        }\n-    }\n-}\n-\n-// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n-//\n-// This looks a bit convoluted because rather than implementing a native SEH\n-// handler, GCC reuses the same personality routine as for the other\n-// architectures by wrapping it with an \"API translator\" layer\n-// (_GCC_specific_handler).\n-\n-#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n-#[doc(hidden)]\n-#[allow(non_camel_case_types, non_snake_case)]\n-pub mod eabi {\n-    pub use self::EXCEPTION_DISPOSITION::*;\n-    use rt::libunwind as uw;\n-    use libc::{c_void, c_int};\n-\n-    // Fake definitions; these are actually complicated structs,\n-    // but we don't use the contents here.\n-    pub type EXCEPTION_RECORD = c_void;\n-    pub type CONTEXT = c_void;\n-    pub type DISPATCHER_CONTEXT = c_void;\n-\n-    #[repr(C)]\n-    #[derive(Copy, Clone)]\n-    pub enum EXCEPTION_DISPOSITION {\n-        ExceptionContinueExecution,\n-        ExceptionContinueSearch,\n-        ExceptionNestedException,\n-        ExceptionCollidedUnwind\n-    }\n-\n-    type _Unwind_Personality_Fn =\n-        extern fn(\n-            version: c_int,\n-            actions: uw::_Unwind_Action,\n-            exception_class: uw::_Unwind_Exception_Class,\n-            ue_header: *mut uw::_Unwind_Exception,\n-            context: *mut uw::_Unwind_Context\n-        ) -> uw::_Unwind_Reason_Code;\n-\n-    extern {\n-        fn __gcc_personality_seh0(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT\n-        ) -> EXCEPTION_DISPOSITION;\n-\n-        fn _GCC_specific_handler(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT,\n-            personality: _Unwind_Personality_Fn\n-        ) -> EXCEPTION_DISPOSITION;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    extern fn rust_eh_personality(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        unsafe {\n-            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n-                                   contextRecord, dispatcherContext)\n-        }\n-    }\n-\n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern fn rust_eh_personality_catch(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        extern fn inner(\n-                _version: c_int,\n-                actions: uw::_Unwind_Action,\n-                _exception_class: uw::_Unwind_Exception_Class,\n-                _ue_header: *mut uw::_Unwind_Exception,\n-                _context: *mut uw::_Unwind_Context\n-            ) -> uw::_Unwind_Reason_Code\n-        {\n-            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-                uw::_URC_HANDLER_FOUND // catch!\n-            }\n-            else { // cleanup phase\n-                uw::_URC_INSTALL_CONTEXT\n+            unsafe {\n+                __gcc_personality_v0(state, ue_header, context)\n             }\n         }\n-\n-        unsafe {\n-            _GCC_specific_handler(exceptionRecord, establisherFrame,\n-                                  contextRecord, dispatcherContext,\n-                                  inner)\n-        }\n     }\n }\n-"}, {"sha": "59b2e14643d31fb28e64299cd27870896dd8c783", "filename": "src/libstd/rt/unwind/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -14,7 +14,7 @@\n //! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n //! documents linked from it.\n //! These are also good reads:\n-//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//!     http://mentorembedded.github.io/cxx-abi/abi-eh.html\n //!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n //!     http://www.airs.com/blog/index.php?s=exception+frames\n //!\n@@ -76,9 +76,20 @@ use sys_common::mutex::Mutex;\n // The actual unwinding implementation is cfg'd here, and we've got two current\n // implementations. One goes through SEH on Windows and the other goes through\n // libgcc via the libunwind-like API.\n-#[cfg(target_env = \"msvc\")] #[path = \"seh.rs\"] #[doc(hidden)]\n+\n+// *-pc-windows-msvc\n+#[cfg(all(windows, target_env = \"msvc\"))]\n+#[path = \"seh.rs\"] #[doc(hidden)]\n+pub mod imp;\n+\n+// x86_64-pc-windows-gnu\n+#[cfg(all(windows, target_arch=\"x86_64\", target_env=\"gnu\"))]\n+#[path = \"seh64_gnu.rs\"] #[doc(hidden)]\n pub mod imp;\n-#[cfg(not(target_env = \"msvc\"))] #[path = \"gcc.rs\"] #[doc(hidden)]\n+\n+// i686-pc-windows-gnu and all others\n+#[cfg(any(unix, all(windows, target_arch=\"x86\", target_env=\"gnu\")))]\n+#[path = \"gcc.rs\"] #[doc(hidden)]\n pub mod imp;\n \n pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);"}, {"sha": "6a061a55fc2a65aa1ee8c255bd473783d6de8cc3", "filename": "src/libstd/rt/unwind/seh64_gnu.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh64_gnu.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwinding implementation of top of native Win64 SEH,\n+//! however the unwind handler data (aka LSDA) uses GCC-compatible encoding.\n+\n+#![allow(bad_style)]\n+#![allow(private_no_mangle_fns)]\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use self::EXCEPTION_DISPOSITION::*;\n+use rt::dwarf::eh;\n+use core::mem;\n+use core::ptr;\n+use simd;\n+use libc::{c_void, c_ulonglong, DWORD, LPVOID};\n+type ULONG_PTR = c_ulonglong;\n+\n+// Define our exception codes:\n+// according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,\n+//    [31:30] = 3 (error), 2 (warning), 1 (info), 0 (success)\n+//    [29]    = 1 (user-defined)\n+//    [28]    = 0 (reserved)\n+// we define bits:\n+//    [24:27] = type\n+//    [0:23]  = magic\n+const ETYPE: DWORD = 0b1110_u32 << 28;\n+const MAGIC: DWORD = 0x525354; // \"RST\"\n+\n+const RUST_PANIC: DWORD  = ETYPE | (1 << 24) | MAGIC;\n+\n+const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n+const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n+const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n+const EXCEPTION_STACK_INVALID: DWORD = 0x8;    // Stack out of limits or unaligned\n+const EXCEPTION_NESTED_CALL: DWORD = 0x10;     // Nested exception handler call\n+const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n+const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n+const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING |\n+                                EXCEPTION_EXIT_UNWIND |\n+                                EXCEPTION_TARGET_UNWIND |\n+                                EXCEPTION_COLLIDED_UNWIND;\n+\n+#[repr(C)]\n+pub struct EXCEPTION_RECORD {\n+    ExceptionCode: DWORD,\n+    ExceptionFlags: DWORD,\n+    ExceptionRecord: *const EXCEPTION_RECORD,\n+    ExceptionAddress: LPVOID,\n+    NumberParameters: DWORD,\n+    ExceptionInformation: [ULONG_PTR; 15],\n+}\n+\n+pub type CONTEXT = c_void;\n+pub type UNWIND_HISTORY_TABLE = c_void;\n+\n+#[repr(C)]\n+pub struct RUNTIME_FUNCTION {\n+    BeginAddress: DWORD,\n+    EndAddress: DWORD,\n+    UnwindData: DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct DISPATCHER_CONTEXT {\n+    ControlPc: LPVOID,\n+    ImageBase: LPVOID,\n+    FunctionEntry: *const RUNTIME_FUNCTION,\n+    EstablisherFrame: LPVOID,\n+    TargetIp: LPVOID,\n+    ContextRecord: *const CONTEXT,\n+    LanguageHandler: LPVOID,\n+    HandlerData: *const u8,\n+    HistoryTable: *const UNWIND_HISTORY_TABLE,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum EXCEPTION_DISPOSITION {\n+    ExceptionContinueExecution,\n+    ExceptionContinueSearch,\n+    ExceptionNestedException,\n+    ExceptionCollidedUnwind\n+}\n+\n+// From kernel32.dll\n+extern \"system\" {\n+    fn RaiseException(dwExceptionCode: DWORD,\n+                      dwExceptionFlags: DWORD,\n+                      nNumberOfArguments: DWORD,\n+                      lpArguments: *const ULONG_PTR);\n+\n+    fn RtlUnwindEx(TargetFrame: LPVOID,\n+                   TargetIp: LPVOID,\n+                   ExceptionRecord: *const EXCEPTION_RECORD,\n+                   ReturnValue: LPVOID,\n+                   OriginalContext: *const CONTEXT,\n+                   HistoryTable: *const UNWIND_HISTORY_TABLE);\n+}\n+\n+#[repr(C)]\n+struct PanicData {\n+    data: Box<Any + Send + 'static>\n+}\n+\n+pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+    let panic_ctx = Box::new(PanicData { data: data });\n+    let params = [Box::into_raw(panic_ctx) as ULONG_PTR];\n+    rtdebug!(\"panic: ctx={:X}\", params[0]);\n+    RaiseException(RUST_PANIC,\n+                   EXCEPTION_NONCONTINUABLE,\n+                   params.len() as DWORD,\n+                   &params as *const ULONG_PTR);\n+    rtabort!(\"could not unwind stack\");\n+}\n+\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n+    rtdebug!(\"cleanup: ctx={:X}\", ptr as usize);\n+    let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n+    return panic_ctx.data;\n+}\n+\n+// SEH doesn't support resuming unwinds after calling a landing pad like\n+// libunwind does. For this reason, MSVC compiler outlines landing pads into\n+// separate functions that can be called directly from the personality function\n+// but are nevertheless able to find and modify stack frame of the \"parent\"\n+// function.\n+//\n+// Since this cannot be done with libdwarf-style landing pads,\n+// rust_eh_personality instead catches RUST_PANICs, runs the landing pad, then\n+// reraises the exception.\n+//\n+// Note that it makes certain assumptions about the exception:\n+//\n+// 1. That RUST_PANIC is non-continuable, so no lower stack frame may choose to\n+//    resume execution.\n+// 2. That the first parameter of the exception is a pointer to an extra data\n+//    area (PanicData).\n+// Since these assumptions do not generally hold true for foreign exceptions\n+// (system faults, C++ exceptions, etc), we make no attempt to invoke our\n+// landing pads (and, thus, destructors!) for anything other than RUST_PANICs.\n+// This is considered acceptable, because the behavior of throwing exceptions\n+// through a C ABI boundary is undefined.\n+\n+#[lang = \"eh_personality_catch\"]\n+#[cfg(not(test))]\n+unsafe extern fn rust_eh_personality_catch(\n+    exceptionRecord: *mut EXCEPTION_RECORD,\n+    establisherFrame: LPVOID,\n+    contextRecord: *mut CONTEXT,\n+    dispatcherContext: *mut DISPATCHER_CONTEXT\n+) -> EXCEPTION_DISPOSITION\n+{\n+    rust_eh_personality(exceptionRecord, establisherFrame,\n+                        contextRecord, dispatcherContext)\n+}\n+\n+#[lang = \"eh_personality\"]\n+#[cfg(not(test))]\n+unsafe extern fn rust_eh_personality(\n+    exceptionRecord: *mut EXCEPTION_RECORD,\n+    establisherFrame: LPVOID,\n+    contextRecord: *mut CONTEXT,\n+    dispatcherContext: *mut DISPATCHER_CONTEXT\n+) -> EXCEPTION_DISPOSITION\n+{\n+    let er = &*exceptionRecord;\n+    let dc = &*dispatcherContext;\n+    rtdebug!(\"rust_eh_personality: code={:X}, flags={:X}, frame={:X}, ip={:X}\",\n+        er.ExceptionCode, er.ExceptionFlags,\n+        establisherFrame as usize, dc.ControlPc as usize);\n+\n+    if er.ExceptionFlags & EXCEPTION_UNWIND == 0 { // we are in the dispatch phase\n+        if er.ExceptionCode == RUST_PANIC {\n+            if let Some(lpad) = find_landing_pad(dc) {\n+                rtdebug!(\"unwinding to landing pad {:X}\", lpad);\n+\n+                RtlUnwindEx(establisherFrame,\n+                            lpad as LPVOID,\n+                            exceptionRecord,\n+                            er.ExceptionInformation[0] as LPVOID, // pointer to PanicData\n+                            contextRecord,\n+                            dc.HistoryTable);\n+                rtabort!(\"could not unwind\");\n+            }\n+        }\n+    }\n+    ExceptionContinueSearch\n+}\n+\n+// The `resume` instruction, found at the end of the landing pads, and whose job\n+// is to resume stack unwinding, is typically lowered by LLVM into a call to\n+// `_Unwind_Resume` routine.  To avoid confusion with the same symbol exported\n+// from libgcc, we redirect it to `rust_eh_unwind_resume`.\n+// Since resolution of this symbol is done by the linker, `rust_eh_unwind_resume`\n+// must be marked `pub` + `#[no_mangle]`.  (Can we make it a lang item?)\n+\n+#[lang = \"eh_unwind_resume\"]\n+#[cfg(not(test))]\n+unsafe extern fn rust_eh_unwind_resume(panic_ctx: LPVOID) {\n+    rtdebug!(\"rust_eh_unwind_resume: ctx={:X}\", panic_ctx as usize);\n+    let params = [panic_ctx as ULONG_PTR];\n+    RaiseException(RUST_PANIC,\n+                   EXCEPTION_NONCONTINUABLE,\n+                   params.len() as DWORD,\n+                   &params as *const ULONG_PTR);\n+    rtabort!(\"could not resume unwind\");\n+}\n+\n+unsafe fn find_landing_pad(dc: &DISPATCHER_CONTEXT) -> Option<usize> {\n+    let eh_ctx = eh::EHContext {\n+        ip: dc.ControlPc as usize,\n+        func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n+        text_start: dc.ImageBase as usize,\n+        data_start: 0\n+    };\n+    eh::find_landing_pad(dc.HandlerData, &eh_ctx)\n+}"}, {"sha": "fa5f7f48ab44366fda43c156f7a9127f6136c69e", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -21,6 +21,9 @@ extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"]\n extern fn eh_personality() {}\n \n+#[lang = \"eh_unwind_resume\"]\n+extern fn eh_unwind_resume() {}\n+\n #[lang = \"panic_fmt\"]\n extern fn rust_begin_unwind(msg: core::fmt::Arguments, file: &'static str,\n                             line: u32) -> ! {"}, {"sha": "b25367013755a1a765965bec93ea0a2fbcb3dfe8", "filename": "src/test/compile-fail/no_owned_box_lang_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -23,4 +23,5 @@ fn main() {\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }"}, {"sha": "2b927e3e4a730835bebe04f11dd0f37f2c10b104", "filename": "src/test/run-make/c-link-to-rust-staticlib/Makefile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fc-link-to-rust-staticlib%2FMakefile?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -1,8 +1,6 @@\n -include ../tools.mk\n \n-ifndef IS_WINDOWS\n EXTRAFLAGS := $(EXTRACFLAGS)\n-endif\n \n # FIXME: ignore freebsd\n ifneq ($(shell uname),FreeBSD)"}, {"sha": "2c92778f59ac69dc13c5b4a939dbe55e65aa276c", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -19,4 +19,5 @@ pub extern fn bar() {}\n \n #[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n+#[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }"}, {"sha": "b3a36ec3efd8116a80adc56f6ce5ac0af0f6a68a", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -19,4 +19,6 @@ pub extern fn foo() {}\n \n #[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n+#[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+"}, {"sha": "67affb5ae090efa4acc70ef46536355535fcb63e", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceded6adb3a4e172eabef09e1c78717a99c16b14/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=ceded6adb3a4e172eabef09e1c78717a99c16b14", "patch": "@@ -22,6 +22,7 @@ extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n \n #[start]"}]}