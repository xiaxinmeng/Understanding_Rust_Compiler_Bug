{"sha": "e844b524ed1c099a6c19b7754fafcf67b99455df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDRiNTI0ZWQxYzA5OWE2YzE5Yjc3NTRmYWZjZjY3Yjk5NDU1ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-15T22:22:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-15T22:22:19Z"}, "message": "auto merge of #7806 : apasel422/rust/hash_consume, r=catamorphism\n\nThis partially addresses #7719.", "tree": {"sha": "a6e52447b84577f089fa9705b10636e98d2e6477", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6e52447b84577f089fa9705b10636e98d2e6477"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e844b524ed1c099a6c19b7754fafcf67b99455df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e844b524ed1c099a6c19b7754fafcf67b99455df", "html_url": "https://github.com/rust-lang/rust/commit/e844b524ed1c099a6c19b7754fafcf67b99455df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e844b524ed1c099a6c19b7754fafcf67b99455df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04f9ce0ae3ed8ea5b304ab15c9b554fe3fc6ce48", "url": "https://api.github.com/repos/rust-lang/rust/commits/04f9ce0ae3ed8ea5b304ab15c9b554fe3fc6ce48", "html_url": "https://github.com/rust-lang/rust/commit/04f9ce0ae3ed8ea5b304ab15c9b554fe3fc6ce48"}, {"sha": "faa280cee69a34462e43b1a5df7c06faf97e56be", "url": "https://api.github.com/repos/rust-lang/rust/commits/faa280cee69a34462e43b1a5df7c06faf97e56be", "html_url": "https://github.com/rust-lang/rust/commit/faa280cee69a34462e43b1a5df7c06faf97e56be"}], "stats": {"total": 82, "additions": 82, "deletions": 0}, "files": [{"sha": "3b3b71d729735281acfb91ddf9479a4ba93e7538", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e844b524ed1c099a6c19b7754fafcf67b99455df/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e844b524ed1c099a6c19b7754fafcf67b99455df/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=e844b524ed1c099a6c19b7754fafcf67b99455df", "patch": "@@ -455,6 +455,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Creates a consuming iterator, that is, one that moves each key-value\n+    /// pair out of the map in arbitrary order. The map cannot be used after\n+    /// calling this.\n+    pub fn consume_iter(self) -> HashMapConsumeIterator<K, V> {\n+        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n+        HashMapConsumeIterator {iter: self.buckets.consume_rev_iter()}\n+    }\n+\n     /// Retrieves a value for the given key, failing if the key is not\n     /// present.\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n@@ -568,11 +576,21 @@ pub struct HashMapMutIterator<'self, K, V> {\n     priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n }\n \n+/// HashMap consume iterator\n+pub struct HashMapConsumeIterator<K, V> {\n+    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, V>>>,\n+}\n+\n /// HashSet iterator\n pub struct HashSetIterator<'self, K> {\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n }\n \n+/// HashSet consume iterator\n+pub struct HashSetConsumeIterator<K> {\n+    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, ()>>>,\n+}\n+\n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self V)> {\n@@ -599,6 +617,19 @@ impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'sel\n     }\n }\n \n+impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                Some(Bucket {key, value, _}) => return Some((key, value)),\n+                None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self K> {\n@@ -612,6 +643,19 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     }\n }\n \n+impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                Some(bucket) => return Some(bucket.key),\n+                None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K, V> {\n     pub fn from_iterator(iter: &mut T) -> HashMap<K, V> {\n         let (lower, _) = iter.size_hint();\n@@ -726,6 +770,14 @@ impl<T:Hash + Eq> HashSet<T> {\n         self.map.consume(|k, _| f(k))\n     }\n \n+    /// Creates a consuming iterator, that is, one that moves each value out\n+    /// of the set in arbitrary order. The set cannot be used after calling\n+    /// this.\n+    pub fn consume_iter(self) -> HashSetConsumeIterator<T> {\n+        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n+        HashSetConsumeIterator {iter: self.map.buckets.consume_rev_iter()}\n+    }\n+\n     /// Returns true if the hash set contains a value equivalent to the\n     /// given query value.\n     pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n@@ -888,6 +940,21 @@ mod test_map {\n         assert!(m.insert(1, 2));\n     }\n \n+    #[test]\n+    fn test_consume_iter() {\n+        let hm = {\n+            let mut hm = HashMap::new();\n+\n+            hm.insert('a', 1);\n+            hm.insert('b', 2);\n+\n+            hm\n+        };\n+\n+        let v = hm.consume_iter().collect::<~[(char, int)]>();\n+        assert!([('a', 1), ('b', 2)] == v || [('b', 2), ('a', 1)] == v);\n+    }\n+\n     #[test]\n     fn test_iterate() {\n         let mut m = linear_map_with_capacity(4);\n@@ -1168,4 +1235,19 @@ mod test_set {\n             assert!(set.contains(x));\n         }\n     }\n+\n+    #[test]\n+    fn test_consume_iter() {\n+        let hs = {\n+            let mut hs = HashSet::new();\n+\n+            hs.insert('a');\n+            hs.insert('b');\n+\n+            hs\n+        };\n+\n+        let v = hs.consume_iter().collect::<~[char]>();\n+        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+    }\n }"}]}