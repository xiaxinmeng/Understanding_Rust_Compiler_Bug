{"sha": "321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMTQ4OGI2NzUxZTMzYWM5YmMyZDQ4YTdlNWQ1YzJhNWNhNWI2MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T14:27:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-16T14:27:08Z"}, "message": "auto merge of #18752 : jakub-/rust/remove-unit, r=eddyb\n\nCloses https://github.com/rust-lang/rust/issues/18614.", "tree": {"sha": "96434804193d3e514d269e4fbfd99514710c4af4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96434804193d3e514d269e4fbfd99514710c4af4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "html_url": "https://github.com/rust-lang/rust/commit/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "html_url": "https://github.com/rust-lang/rust/commit/0c7a3d6c167c4656e8d35a1d428d142993e0aaab"}, {"sha": "c425ed2a8d98241cdd4b795e4277c68eb4eeb235", "url": "https://api.github.com/repos/rust-lang/rust/commits/c425ed2a8d98241cdd4b795e4277c68eb4eeb235", "html_url": "https://github.com/rust-lang/rust/commit/c425ed2a8d98241cdd4b795e4277c68eb4eeb235"}], "stats": {"total": 960, "additions": 435, "deletions": 525}, "files": [{"sha": "4e21c76e5a6dcd1781a40bb87df3516ca8299afc", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -458,10 +458,9 @@ Examples of floating-point literals of various forms:\n 12E+99_f64;                        // type f64\n ```\n \n-##### Unit and boolean literals\n+##### Boolean literals\n \n-The _unit value_, the only value of the type that has the same name, is written\n-as `()`. The two values of the boolean type are written `true` and `false`.\n+The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n@@ -2717,7 +2716,7 @@ or an item. Path expressions are [lvalues](#lvalues,-rvalues-and-temporaries).\n \n ### Tuple expressions\n \n-Tuples are written by enclosing one or more comma-separated expressions in\n+Tuples are written by enclosing zero or more comma-separated expressions in\n parentheses. They are used to create [tuple-typed](#tuple-types) values.\n \n ```{.tuple}\n@@ -2726,6 +2725,11 @@ parentheses. They are used to create [tuple-typed](#tuple-types) values.\n (\"a\", 4u, true);\n ```\n \n+### Unit expressions\n+\n+The expression `()` denotes the _unit value_, the only value of the type with\n+the same name.\n+\n ### Structure expressions\n \n ```{.ebnf .gram}"}, {"sha": "1792599783b2cacfcab0bce2ef2ecea112c9e584", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -66,7 +66,6 @@ register_diagnostics!(\n     E0055,\n     E0056,\n     E0057,\n-    E0058,\n     E0059,\n     E0060,\n     E0061,"}, {"sha": "83194efc554b7143796141b25157cf79f468bb7c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -447,7 +447,9 @@ impl LintPass for ImproperCTypes {\n             for input in decl.inputs.iter() {\n                 check_ty(cx, &*input.ty);\n             }\n-            check_ty(cx, &*decl.output)\n+            if let ast::Return(ref ret_ty) = decl.output {\n+                check_ty(cx, &**ret_ty);\n+            }\n         }\n \n         match it.node {\n@@ -735,7 +737,8 @@ impl LintPass for UnusedResults {\n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n-            ty::ty_nil | ty::ty_bool => return,\n+            ty::ty_tup(ref tys) if tys.is_empty() => return,\n+            ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {"}, {"sha": "50c9a4a2a52c72a31eb90ad932c404ad6604f781", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -360,7 +360,6 @@ fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n \n fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n-      'n' => return ty::mk_nil(),\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n       'u' => return ty::mk_uint(),"}, {"sha": "3242d3961467a153efd2fd0ad223a6dffe8c224d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -199,7 +199,6 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n \n fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     match *st {\n-        ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bool => mywrite!(w, \"b\"),\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {"}, {"sha": "3968e6b653429c30c66be9e806dc518d514c1219", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n+use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n@@ -332,7 +332,6 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n fn const_val_to_expr(value: &const_val) -> P<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n-        &const_nil => LitNil,\n         _ => unreachable!()\n     };\n     P(Expr {\n@@ -497,9 +496,6 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_nil =>\n-            vec!(ConstantValue(const_nil)),\n-\n         ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n@@ -552,7 +548,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        ty::mk_nil()\n+        ty::mk_nil(cx.tcx)\n     } else {\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };"}, {"sha": "1fd5b81f49924e1307bf04572007c129a85222e8", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -311,8 +311,7 @@ pub enum const_val {\n     const_uint(u64),\n     const_str(InternedString),\n     const_binary(Rc<Vec<u8> >),\n-    const_bool(bool),\n-    const_nil\n+    const_bool(bool)\n }\n \n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n@@ -589,7 +588,6 @@ pub fn lit_to_const(lit: &Lit) -> const_val {\n         LitFloatUnsuffixed(ref n) => {\n             const_float(from_str::<f64>(n.get()).unwrap() as f64)\n         }\n-        LitNil => const_nil,\n         LitBool(b) => const_bool(b)\n     }\n }\n@@ -605,7 +603,6 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n         (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n-        (&const_nil, &const_nil) => compare_vals((), ()),\n         _ => None\n     }\n }"}, {"sha": "2cfaf8438ae1b776ef86c8a8c2e545a43598c957", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -4285,7 +4285,9 @@ impl<'a> Resolver<'a> {\n                                     _ => {}\n                                 }\n \n-                                this.resolve_type(&*ty_m.decl.output);\n+                                if let ast::Return(ref ret_ty) = ty_m.decl.output {\n+                                    this.resolve_type(&**ret_ty);\n+                                }\n                             });\n                           }\n                           ast::ProvidedMethod(ref m) => {\n@@ -4467,7 +4469,9 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    this.resolve_type(&*declaration.output);\n+                    if let ast::Return(ref ret_ty) = declaration.output {\n+                        this.resolve_type(&**ret_ty);\n+                    }\n                 }\n             }\n "}, {"sha": "367fe2845dd14a1cab1266ed1ac4623d16c951fc", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -383,7 +383,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for arg in method.pe_fn_decl().inputs.iter() {\n             self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*method.pe_fn_decl().output);\n+\n+        if let ast::Return(ref ret_ty) = method.pe_fn_decl().output {\n+            self.visit_ty(&**ret_ty);\n+        }\n+\n         // walk the fn body\n         self.nest(method.id, |v| v.visit_block(&*method.pe_body()));\n \n@@ -491,7 +495,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for arg in decl.inputs.iter() {\n             self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*decl.output);\n+\n+        if let ast::Return(ref ret_ty) = decl.output {\n+            self.visit_ty(&**ret_ty);\n+        }\n \n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n@@ -1136,7 +1143,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 for arg in method_type.decl.inputs.iter() {\n                     self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*method_type.decl.output);\n+\n+                if let ast::Return(ref ret_ty) = method_type.decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n \n                 self.process_generic_params(&method_type.generics,\n                                             method_type.span,\n@@ -1352,7 +1362,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 for arg in decl.inputs.iter() {\n                     self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*decl.output);\n+\n+                if let ast::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n \n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));"}, {"sha": "be5a007c1ebde7f63b6f4ca293f5fcdc1f02b600", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -79,7 +79,6 @@ pub fn ty_is_local(tcx: &ty::ctxt,\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n     match ty::get(ty).sty {\n-        ty::ty_nil |\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |"}, {"sha": "b50956ec9dbaf588193463ede6ea1cefe6cdd541", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -1227,7 +1227,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_infer(ty::FloatVar(_)) |\n             ty::ty_uint(_) |\n             ty::ty_int(_) |\n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_float(_) |\n             ty::ty_bare_fn(_) |"}, {"sha": "e4409777686f57fef6c3845eb5d78b6a24bb0d1c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -1012,7 +1012,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                          .unwrap_or(DUMMY_NODE_ID);\n \n     let left_ty = if pat_id == DUMMY_NODE_ID {\n-        ty::mk_nil()\n+        ty::mk_nil(tcx)\n     } else {\n         node_id_type(bcx, pat_id)\n     };"}, {"sha": "d4d532c1c4401ca5085ce9ecb2f68a558c399801", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -47,7 +47,7 @@ use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::cleanup;\n-use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral, C_nil};\n+use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use middle::trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use middle::trans::common::{CrateContext, ExternMap, FunctionContext};\n use middle::trans::common::{NodeInfo, Result, SubstP};\n@@ -517,7 +517,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n+                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),\n@@ -551,7 +551,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match ty::get(t).sty {\n-        ty::ty_nil => f(nil_type),\n+        ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n         ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n         ty::ty_int(_) => f(signed_int),\n@@ -1578,12 +1578,6 @@ fn create_datums_for_fn_args_under_call_abi(\n                                                                 \"argtuple\"));\n                 result.push(tuple);\n             }\n-            ty::ty_nil => {\n-                let mode = datum::Rvalue::new(datum::ByValue);\n-                result.push(datum::Datum::new(C_nil(bcx.ccx()),\n-                                              ty::mk_nil(),\n-                                              mode))\n-            }\n             _ => {\n                 bcx.tcx().sess.bug(\"last argument of a function with \\\n                                     `rust-call` ABI isn't a tuple?!\")\n@@ -1647,10 +1641,8 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                       arg_datum.to_lvalue_datum_in_scope(bcx,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n-    let empty = Vec::new();\n     let untupled_arg_types = match ty::get(monomorphized_arg_types[0]).sty {\n         ty::ty_tup(ref types) => types.as_slice(),\n-        ty::ty_nil => empty.as_slice(),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1824,7 +1816,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         NotUnboxedClosure => monomorphized_arg_types,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![ty::mk_tup_or_nil(ccx.tcx(), monomorphized_arg_types)]\n+        IsUnboxedClosure => vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n@@ -2380,7 +2372,6 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             assert!(abi == RustCall);\n \n             match ty::get(fn_sig.inputs[0]).sty {\n-                ty::ty_nil => Vec::new(),\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n@@ -2389,7 +2380,6 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n             match ty::get(fn_sig.inputs[1]).sty {\n-                ty::ty_nil => inputs,\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n@@ -2532,7 +2522,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil()));\n+    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2564,7 +2554,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         let llfty = Type::func([ccx.int_type(), Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type());\n \n-        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n+        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil(ccx.tcx()));\n \n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR"}, {"sha": "f62159cd4902a6d682d5430dda105878db2c7a5c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -764,7 +764,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         expr::Ignore => {\n             let ret_ty = match ret_ty {\n                 ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ty::mk_nil()\n+                ty::FnDiverging => ty::mk_nil(ccx.tcx())\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n@@ -957,7 +957,6 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                 llargs.push(arg_datum.add_clean(bcx.fcx, arg_cleanup_scope));\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             bcx.sess().span_bug(tuple_expr.span,\n                                 \"argument to `.call()` wasn't a tuple?!\")\n@@ -1004,7 +1003,6 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                 }))\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             bcx.sess().span_bug(arg_exprs[0].span,\n                                 \"argument to `.call()` wasn't a tuple?!\")"}, {"sha": "330959d687155c3eef301833cb067032eff24a9d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -81,7 +81,6 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             }\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n-        ast::LitNil => C_nil(cx),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => C_binary_slice(cx, data.as_slice()),\n     }"}, {"sha": "42da0573460be72b41580df43366902aeab9bd1b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -718,15 +718,17 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n+                let f = base::decl_cdecl_fn(\n+                    ccx, $name, Type::func([], &$ret),\n+                    ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n-                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n+                                  Type::func([$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -863,7 +865,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n-                                      ty::mk_nil());\n+                                      ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "f11ca1eec5a2696f17f352817493b8ab5eba7be9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -350,7 +350,6 @@ impl TypeMap {\n         unique_type_id.push('{');\n \n         match ty::get(type_).sty {\n-            ty::ty_nil      |\n             ty::ty_bool     |\n             ty::ty_char     |\n             ty::ty_str      |\n@@ -367,6 +366,9 @@ impl TypeMap {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n+            ty::ty_tup(ref component_types) if component_types.is_empty() => {\n+                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n+            },\n             ty::ty_tup(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n                 for &component_type in component_types.iter() {\n@@ -1372,10 +1374,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n-        match fn_decl.output.node {\n-            ast::TyNil => {\n-                signature.push(ptr::null_mut());\n-            }\n+        match fn_decl.output {\n+            ast::Return(ref ret_ty) if ret_ty.node == ast::TyTup(vec![]) =>\n+                signature.push(ptr::null_mut()),\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n \n@@ -1736,7 +1737,8 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n-        ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n+        ty::ty_tup(ref elements) if elements.is_empty() =>\n+            (\"()\".to_string(), DW_ATE_unsigned),\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n@@ -2773,7 +2775,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     // return type\n     signature_metadata.push(match signature.output {\n         ty::FnConverging(ret_ty) => match ty::get(ret_ty).sty {\n-            ty::ty_nil => ptr::null_mut(),\n+            ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n         },\n         ty::FnDiverging => diverging_type_metadata(cx)\n@@ -2880,14 +2882,16 @@ fn type_metadata(cx: &CrateContext,\n \n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n-        ty::ty_nil      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n+        ty::ty_tup(ref elements) if elements.is_empty() => {\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n+        }\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n@@ -3669,9 +3673,8 @@ fn compute_debuginfo_type_name(cx: &CrateContext,\n fn push_debuginfo_type_name(cx: &CrateContext,\n                             t: ty::t,\n                             qualified: bool,\n-                            output:&mut String) {\n+                            output: &mut String) {\n     match ty::get(t).sty {\n-        ty::ty_nil               => output.push_str(\"()\"),\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),\n@@ -3698,8 +3701,10 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n-            output.pop();\n-            output.pop();\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n             output.push(')');\n         },\n         ty::ty_uniq(inner_type) => {"}, {"sha": "0b03163a02bab09627e0c64874680ad7ad787c6c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -520,7 +520,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil()));\n+    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));"}, {"sha": "f5db3d418128b1f8b4d36fe024761b07ded2869b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -159,7 +159,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n+            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -288,7 +288,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n+                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n@@ -520,7 +520,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }\n@@ -538,10 +538,11 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::FnConverging(ty::mk_nil()),\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                          ty::FnConverging(ty::mk_nil(ccx.tcx())),\n                           &empty_param_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil()));\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -556,7 +557,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil()));\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n \n     llfn\n }"}, {"sha": "f0af123221f92beb332339d08a57aef764199597", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -594,7 +594,6 @@ pub fn get_vtable(bcx: Block,\n                                             new_inputs.push(element.subst(bcx.tcx(), substs));\n                                         }\n                                     }\n-                                    ty::ty_nil => {}\n                                     _ => {\n                                         bcx.tcx().sess.bug(\"get_vtable(): closure \\\n                                                             type wasn't a tuple\")"}, {"sha": "379d1e85b8b856339f5320979f2e16f6c27bed56", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -83,7 +83,6 @@ pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n                 result.push(tupled_argument);\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             ccx.tcx().sess.bug(\"argument to function with \\\"rust-call\\\" ABI \\\n                                 is neither a tuple nor unit\")\n@@ -186,7 +185,6 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                   ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n \n-        ty::ty_nil => Type::nil(cx),\n         ty::ty_bool => Type::bool(cx),\n         ty::ty_char => Type::char(cx),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -211,6 +209,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             Type::array(&llty, size)\n         }\n \n+        ty::ty_tup(ref tys) if tys.is_empty() => {\n+            Type::nil(cx)\n+        }\n+\n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr, false)\n@@ -298,7 +300,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let mut llty = match ty::get(t).sty {\n-      ty::ty_nil => Type::nil(cx),\n       ty::ty_bool => Type::bool(cx),\n       ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -365,6 +366,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n           Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n       }\n+      ty::ty_tup(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)"}, {"sha": "97160e7a6d16c2be42fa74d664a09440ffba1418", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 71, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -906,7 +906,6 @@ mod primitives {\n         )\n     )\n \n-    def_prim_ty!(TY_NIL,    super::ty_nil)\n     def_prim_ty!(TY_BOOL,   super::ty_bool)\n     def_prim_ty!(TY_CHAR,   super::ty_char)\n     def_prim_ty!(TY_INT,    super::ty_int(ast::TyI))\n@@ -932,7 +931,6 @@ mod primitives {\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum sty {\n-    ty_nil,\n     ty_bool,\n     ty_char,\n     ty_int(ast::IntTy),\n@@ -1557,7 +1555,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n-        ty_nil => return mk_nil(),\n         ty_err => return mk_err(),\n         ty_bool => return mk_bool(),\n         ty_int(i) => return mk_mach_int(i),\n@@ -1603,7 +1600,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         rflags(bounds.region_bound)\n     }\n     match &st {\n-      &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n+      &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n@@ -1689,9 +1686,6 @@ pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     }\n }\n \n-#[inline]\n-pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n-\n #[inline]\n pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n@@ -1803,7 +1797,7 @@ pub fn mk_imm_ptr(cx: &ctxt, ty: t) -> t {\n }\n \n pub fn mk_nil_ptr(cx: &ctxt) -> t {\n-    mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n+    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n pub fn mk_vec(cx: &ctxt, t: t, sz: Option<uint>) -> t {\n@@ -1818,14 +1812,12 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n             })\n }\n \n-pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t {\n+    mk_t(cx, ty_tup(ts))\n+}\n \n-pub fn mk_tup_or_nil(cx: &ctxt, ts: Vec<t>) -> t {\n-    if ts.len() == 0 {\n-        ty::mk_nil()\n-    } else {\n-        mk_t(cx, ty_tup(ts))\n-    }\n+pub fn mk_nil(cx: &ctxt) -> t {\n+    mk_tup(cx, Vec::new())\n }\n \n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n@@ -1908,7 +1900,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         return;\n     }\n     match get(ty).sty {\n-        ty_nil | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n@@ -1996,7 +1988,10 @@ impl ParamBounds {\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool {\n-    get(ty).sty == ty_nil\n+    match get(ty).sty {\n+        ty_tup(ref tys) => tys.is_empty(),\n+        _ => false\n+    }\n }\n \n pub fn type_is_error(ty: t) -> bool {\n@@ -2133,9 +2128,10 @@ pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n */\n pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_nil | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n+      ty_tup(ref tys) if tys.is_empty() => true,\n       _ => false\n     }\n }\n@@ -2170,7 +2166,7 @@ pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n         let mut needs_unwind_cleanup = false;\n         maybe_walk_ty(ty, |ty| {\n             needs_unwind_cleanup |= match get(ty).sty {\n-                ty_nil | ty_bool | ty_int(_) | ty_uint(_) |\n+                ty_bool | ty_int(_) | ty_uint(_) |\n                 ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n                 ty_enum(did, ref substs) =>\n@@ -2429,7 +2425,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             // Scalar and unique types are sendable, and durable\n             ty_infer(ty::SkolemizedIntTy(_)) |\n-            ty_nil | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n             }\n@@ -2740,7 +2736,6 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_vec(_, Some(0)) => false, // don't need no contents\n             ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n \n-            ty_nil |\n             ty_bool |\n             ty_char |\n             ty_int(_) |\n@@ -3779,10 +3774,11 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n \n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n-        ty_nil | ty_bool | ty_char | ty_int(_) |\n+        ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_string(cx, t)\n         }\n+        ty_tup(ref tys) if tys.is_empty() => ::util::ppaux::ty_to_string(cx, t),\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n         ty_uniq(_) => \"box\".to_string(),\n@@ -4777,54 +4773,42 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n-      Ok(ref const_val) => match *const_val {\n-        const_eval::const_int(count) => if count < 0 {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found negative integer\");\n-            0\n-        } else {\n-            count as uint\n-        },\n-        const_eval::const_uint(count) => count as uint,\n-        const_eval::const_float(count) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found float\");\n-            count as uint\n-        }\n-        const_eval::const_str(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found string\");\n-            0\n-        }\n-        const_eval::const_bool(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found boolean\");\n-            0\n-        }\n-        const_eval::const_binary(_) => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found binary array\");\n-            0\n-        }\n-        const_eval::const_nil => {\n-            tcx.sess.span_err(count_expr.span,\n-                              \"expected positive integer for \\\n-                               repeat count, found ()\");\n-            0\n-        }\n-      },\n-      Err(..) => {\n-        tcx.sess.span_err(count_expr.span,\n-                          \"expected constant integer for repeat count, \\\n-                           found variable\");\n-        0\n-      }\n+        Ok(val) => {\n+            let found = match val {\n+                const_eval::const_uint(count) => return count as uint,\n+                const_eval::const_int(count) if count >= 0 => return count as uint,\n+                const_eval::const_int(_) =>\n+                    \"negative integer\",\n+                const_eval::const_float(_) =>\n+                    \"float\",\n+                const_eval::const_str(_) =>\n+                    \"string\",\n+                const_eval::const_bool(_) =>\n+                    \"boolean\",\n+                const_eval::const_binary(_) =>\n+                    \"binary array\"\n+            };\n+            tcx.sess.span_err(count_expr.span, format!(\n+                \"expected positive integer for repeat count, found {}\",\n+                found).as_slice());\n+        }\n+        Err(_) => {\n+            let found = match count_expr.node {\n+                ast::ExprPath(ast::Path {\n+                    global: false,\n+                    ref segments,\n+                    ..\n+                }) if segments.len() == 1 =>\n+                    \"variable\",\n+                _ =>\n+                    \"non-constant expression\"\n+            };\n+            tcx.sess.span_err(count_expr.span, format!(\n+                \"expected constant integer for repeat count, found {}\",\n+                found).as_slice());\n+        }\n     }\n+    0\n }\n \n // Iterate over a type parameter's bounded traits and any supertraits\n@@ -5141,7 +5125,6 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     };\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n-            ty_nil => byte!(0),\n             ty_bool => byte!(2),\n             ty_char => byte!(3),\n             ty_int(i) => {\n@@ -5512,7 +5495,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }\n-            ty_nil |\n             ty_bool |\n             ty_char |\n             ty_int(_) |"}, {"sha": "6d8d03aa0ab7af9c724593b935dfa14c174298d2", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -554,7 +554,7 @@ pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_unboxed_closure(did, ref region, ref substs) => {\n             ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n         }\n-        ty::ty_nil | ty::ty_bool | ty::ty_char | ty::ty_str |\n+        ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) => {"}, {"sha": "8df4d59a292bf7ab1cebeb5dda0a619719feaabe", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 55, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -385,11 +385,11 @@ fn ast_path_substs<'tcx,AC,RS>(\n         let inputs = data.inputs.iter()\n                                 .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n                                 .collect();\n-        let input_ty = ty::mk_tup_or_nil(this.tcx(), inputs);\n+        let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n         let output = match data.output {\n             Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n-            None => ty::mk_nil()\n+            None => ty::mk_nil(this.tcx())\n         };\n \n         (Vec::new(), vec![input_ty, output])\n@@ -652,12 +652,6 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n-#[deriving(Show)]\n-enum PointerTy {\n-    RPtr(ty::Region),\n-    Uniq\n-}\n-\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n@@ -666,14 +660,14 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         rscope: &RS,\n         a_seq_mutbl: ast::Mutability,\n         a_seq_ty: &ast::Ty,\n-        ptr_ty: PointerTy,\n+        region: ty::Region,\n         constr: |ty::t| -> ty::t)\n         -> ty::t\n {\n     let tcx = this.tcx();\n \n-    debug!(\"mk_pointer(ptr_ty={}, a_seq_ty={})\",\n-           ptr_ty,\n+    debug!(\"mk_pointer(region={}, a_seq_ty={})\",\n+           region,\n            a_seq_ty.repr(tcx));\n \n     match a_seq_ty.node {\n@@ -688,14 +682,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             match tcx.def_map.borrow().get(&id) {\n                 Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                    match ptr_ty {\n-                        Uniq => {\n-                            return constr(ty::mk_str(tcx));\n-                        }\n-                        RPtr(r) => {\n-                            return ty::mk_str_slice(tcx, r, a_seq_mutbl);\n-                        }\n-                    }\n+                    return ty::mk_str_slice(tcx, region, a_seq_mutbl);\n                 }\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(this,\n@@ -716,14 +703,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     let tr = ty::mk_trait(tcx,\n                                           result,\n                                           existential_bounds);\n-                    return match ptr_ty {\n-                        Uniq => {\n-                            return ty::mk_uniq(tcx, tr);\n-                        }\n-                        RPtr(r) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n-                        }\n-                    };\n+                    return ty::mk_rptr(tcx, region, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n                 }\n                 _ => {}\n             }\n@@ -824,12 +804,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n     let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n         match ast_ty.node {\n-            ast::TyNil => ty::mk_nil(),\n-            ast::TyBot => unreachable!(),\n-            ast::TyUniq(ref ty) => {\n-                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,\n-                           |ty| ty::mk_uniq(tcx, ty))\n-            }\n             ast::TyVec(ref ty) => {\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n@@ -842,7 +816,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, RPtr(r),\n+                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, r,\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n@@ -1208,22 +1182,24 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                                                                    .filter(|&(_, l)| l != 0)\n                                                                    .collect();\n \n-    let output_ty = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n-        _ => ty::FnConverging(match implied_output_region {\n-            Some(implied_output_region) => {\n-                let rb = SpecificRscope::new(implied_output_region);\n-                ast_ty_to_ty(this, &rb, &*decl.output)\n-            }\n-            None => {\n-                // All regions must be explicitly specified in the output\n-                // if the lifetime elision rules do not apply. This saves\n-                // the user from potentially-confusing errors.\n-                let rb = UnelidableRscope::new(param_lifetimes);\n-                ast_ty_to_ty(this, &rb, &*decl.output)\n-            }\n-        })\n+    let output_ty = match decl.output {\n+        ast::Return(ref output) if output.node == ast::TyInfer =>\n+            ty::FnConverging(this.ty_infer(output.span)),\n+        ast::Return(ref output) =>\n+            ty::FnConverging(match implied_output_region {\n+                Some(implied_output_region) => {\n+                    let rb = SpecificRscope::new(implied_output_region);\n+                    ast_ty_to_ty(this, &rb, &**output)\n+                }\n+                None => {\n+                    // All regions must be explicitly specified in the output\n+                    // if the lifetime elision rules do not apply. This saves\n+                    // the user from potentially-confusing errors.\n+                    let rb = UnelidableRscope::new(param_lifetimes);\n+                    ast_ty_to_ty(this, &rb, &**output)\n+                }\n+            }),\n+        ast::NoReturn(_) => ty::FnDiverging\n     };\n \n     (ty::BareFnTy {\n@@ -1346,11 +1322,14 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n \n-    let output_ty = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n-        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n-        _ => ty::FnConverging(ast_ty_to_ty(this, &rb, &*decl.output))\n+    let output_ty = match decl.output {\n+        ast::Return(ref output) if output.node == ast::TyInfer && expected_ret_ty.is_some() =>\n+            expected_ret_ty.unwrap(),\n+        ast::Return(ref output) if output.node == ast::TyInfer =>\n+            ty::FnConverging(this.ty_infer(output.span)),\n+        ast::Return(ref output) =>\n+            ty::FnConverging(ast_ty_to_ty(this, &rb, &**output)),\n+        ast::NoReturn(_) => ty::FnDiverging\n     };\n \n     ty::ClosureTy {"}, {"sha": "a35bc502813ce935d8ef899f193b09ccea9ca286", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -1214,7 +1214,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             ty_bare_fn(..) | ty_uniq(..) | ty_rptr(..) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_param(..) | ty_nil | ty_bool |\n+            ty_param(..) | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n             ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |"}, {"sha": "37fb368b54b4a300bbd79918c4901c8c2833289d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -556,7 +556,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         .collect();\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n-        fcx.require_type_is_sized(ret_ty, decl.output.span, traits::ReturnType);\n+        fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n         fn_sig_tys.push(ret_ty);\n     }\n \n@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn default_diverging_type_variables_to_nil(&self) {\n         for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n             if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(*ty)) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil());\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n             }\n         }\n     }\n@@ -1741,7 +1741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_nil());\n+        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n@@ -2664,17 +2664,6 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n                     (*arg_types).clone()\n                 }\n             }\n-            ty::ty_nil => {\n-                if args.len() != 0 {\n-                    span_err!(tcx.sess, sp, E0058,\n-                        \"this function takes 0 parameters but {} parameter{} supplied\",\n-                        args.len(),\n-                        if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    err_args(args.len())\n-                } else {\n-                    vec![]\n-                }\n-            }\n             _ => {\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n@@ -2865,7 +2854,6 @@ fn check_lit(fcx: &FnCtxt,\n             opt_ty.unwrap_or_else(\n                 || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitNil => ty::mk_nil(),\n         ast::LitBool(_) => ty::mk_bool()\n     }\n }\n@@ -3179,7 +3167,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                         infer::IfExpressionWithNoElse(sp),\n                                         false,\n                                         then_ty,\n-                                        ty::mk_nil())\n+                                        ty::mk_nil(fcx.tcx()))\n             }\n         };\n \n@@ -3480,7 +3468,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = vec![ty::mk_tup_or_nil(fcx.tcx(), fn_ty.sig.inputs)];\n+        fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n \n         let kind = match kind {\n             ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n@@ -4148,7 +4136,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 match *expr_opt {\n                     None =>\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n-                                                    result_type, ty::mk_nil()) {\n+                                                    result_type, ty::mk_nil(fcx.tcx())) {\n                             span_err!(tcx.sess, expr.span, E0069,\n                                 \"`return;` in function returning non-nil\");\n                         },\n@@ -4743,7 +4731,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n       ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, ty::mk_nil());\n+        check_expr_has_type(fcx, &**expr, ty::mk_nil(fcx.tcx()));\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n@@ -4769,12 +4757,12 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n }\n \n pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n-    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil()));\n+    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n         fcx.write_error(blk.id);\n     } else {\n-        let nilty = ty::mk_nil();\n+        let nilty = ty::mk_nil(fcx.tcx());\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n }\n@@ -5497,7 +5485,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n         let tuple_ty =\n-            ty::mk_tup_or_nil(fcx.tcx(), input_tys);\n+            ty::mk_tup(fcx.tcx(), input_tys);\n \n         if type_count >= 1 {\n             substs.types.push(space, tuple_ty);\n@@ -5507,7 +5495,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n-            output_ty.unwrap_or(ty::mk_nil());\n+            output_ty.unwrap_or(ty::mk_nil(fcx.tcx()));\n \n         if type_count >= 2 {\n             substs.types.push(space, output_ty);\n@@ -5727,15 +5715,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"load\" => (1, vec!(ty::mk_imm_ptr(tcx, param(ccx, 0))),\n                        param(ccx, 0)),\n             \"store\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n-                        ty::mk_nil()),\n+                        ty::mk_nil(tcx)),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n             \"fence\" => {\n-                (0, Vec::new(), ty::mk_nil())\n+                (0, Vec::new(), ty::mk_nil(tcx))\n             }\n             op => {\n                 span_err!(tcx.sess, it.span, E0092,\n@@ -5748,20 +5736,20 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n         let (n_tps, inputs, output) = match name.get() {\n-            \"breakpoint\" => (0, Vec::new(), ty::mk_nil()),\n+            \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n             \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n             \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n-            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil()),\n+            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n                   ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n             \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n@@ -5817,7 +5805,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   }),\n                   ty::mk_uint()\n                ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"set_memory\" | \"volatile_set_memory\" => {\n               (1,\n@@ -5829,7 +5817,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ty::mk_u8(),\n                   ty::mk_uint()\n                ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n             \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n@@ -5912,7 +5900,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil()),\n+                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n                 (0, vec!(ty::mk_i8(), ty::mk_i8()),\n@@ -5948,7 +5936,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n             \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, ty::mk_u8())),\n \n-            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil()),\n+            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil(tcx)),\n \n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,"}, {"sha": "032b31b1f3874c572acf7b763e06d53b4f46ca7b", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -91,7 +91,6 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                ty.repr(self.tcx));\n \n         match ty::get(ty).sty {\n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "ca03e9d96e8c5414b34e8ddfd4bca0a3b3206322", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -24,7 +24,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_enum, ty_err};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n@@ -82,7 +82,7 @@ fn get_base_type(inference_context: &InferCtxt,\n             Some(resolved_type)\n         }\n \n-        ty_nil | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {"}, {"sha": "eed574a1a1d7d297378038c85851be635efaa421", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -2096,9 +2096,11 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n                         .collect();\n \n-    let output = match decl.output.node {\n-        ast::TyBot => ty::FnDiverging,\n-        _ => ty::FnConverging(ast_ty_to_ty(ccx, &rb, &*decl.output))\n+    let output = match decl.output {\n+        ast::Return(ref ty) =>\n+            ty::FnConverging(ast_ty_to_ty(ccx, &rb, &**ty)),\n+        ast::NoReturn(_) =>\n+            ty::FnDiverging\n     };\n \n     let t_fn = ty::mk_bare_fn("}, {"sha": "078a2c10bcb3514b8adb7c87c8046b32f1bd3c21", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -433,7 +433,6 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         }\n \n       (&ty::ty_char, _) |\n-      (&ty::ty_nil, _) |\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n@@ -540,9 +539,11 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n                .map(|(a, b)| this.tys(*a, *b))\n                .collect::<Result<_, _>>()\n                .map(|ts| ty::mk_tup(tcx, ts))\n-        } else {\n+        } else if as_.len() != 0 && bs.len() != 0 {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))\n+        } else {\n+            Err(ty::terr_sorts(expected_found(this, a, b)))\n         }\n       }\n "}, {"sha": "e12019a15302ceb545ab543b5cc9faa340d352e1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -973,8 +973,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                                    &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n                                           &anon_nums, &region_names);\n-            output = self.rebuild_arg_ty_or_output(&*output, lifetime,\n-                                                   &anon_nums, &region_names);\n+            output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n                                                &region_names);\n         }\n@@ -989,7 +988,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let new_fn_decl = ast::FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: self.fn_decl.cf,\n             variadic: self.fn_decl.variadic\n         };\n         (new_fn_decl, expl_self_opt, generics)\n@@ -1206,6 +1204,18 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         new_inputs\n     }\n \n+    fn rebuild_output(&self, ty: &ast::FunctionRetTy,\n+                      lifetime: ast::Lifetime,\n+                      anon_nums: &HashSet<uint>,\n+                      region_names: &HashSet<ast::Name>) -> ast::FunctionRetTy {\n+        match *ty {\n+            ast::Return(ref ret_ty) => ast::Return(\n+                self.rebuild_arg_ty_or_output(&**ret_ty, lifetime, anon_nums, region_names)\n+            ),\n+            ast::NoReturn(span) => ast::NoReturn(span)\n+        }\n+    }\n+\n     fn rebuild_arg_ty_or_output(&self,\n                                 ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n@@ -1301,7 +1311,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n                 ast::TyVec(ref ty) |\n-                ast::TyUniq(ref ty) |\n                 ast::TyFixedLengthVec(ref ty, _) => {\n                     ty_queue.push(&**ty);\n                 }\n@@ -1338,7 +1347,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         })\n                     }\n                     ast::TyVec(ty) => ast::TyVec(build_to(ty, to)),\n-                    ast::TyUniq(ty) => ast::TyUniq(build_to(ty, to)),\n                     ast::TyFixedLengthVec(ty, e) => {\n                         ast::TyFixedLengthVec(build_to(ty, to), e)\n                     }"}, {"sha": "9458960156ea0be547c3d25c36e95798dee0639d", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -148,7 +148,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n                 self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n             }\n \n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "2c8d1ce3f4fc4d1e28286d97d948d200946d31f5", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -382,7 +382,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(ty::mk_nil()),\n+                    output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n                 }\n             });"}, {"sha": "97d7f9f18630aa0c9d2f1eab7b5230285ab3f760", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -728,7 +728,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n         match ty::get(ty).sty {\n-            ty::ty_nil | ty::ty_bool |\n+            ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n             ty::ty_float(_) | ty::ty_str => {\n                 /* leaf type -- noop */"}, {"sha": "bcd70510edd36e4a8dc71489d511b788a6a760b2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n+use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -384,7 +384,6 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n \n     // pretty print the structural type representation:\n     match ty::get(typ).sty {\n-        ty_nil => \"()\".to_string(),\n         ty_bool => \"bool\".to_string(),\n         ty_char => \"char\".to_string(),\n         ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),"}, {"sha": "a608fba80e3098666b712aaa05e3e7497162bc63", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -710,8 +710,7 @@ impl Clean<Item> for ast::Method {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.pe_fn_decl().output.clean(cx)),\n-            cf: self.pe_fn_decl().cf.clean(cx),\n+            output: self.pe_fn_decl().output.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n@@ -749,8 +748,7 @@ impl Clean<Item> for ast::TypeMethod {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean(cx)).collect(),\n             },\n-            output: (self.decl.output.clean(cx)),\n-            cf: self.decl.cf.clean(cx),\n+            output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n         Item {\n@@ -840,8 +838,7 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n-    pub output: Type,\n-    pub cf: RetStyle,\n+    pub output: FunctionRetTy,\n     pub attrs: Vec<Attribute>,\n }\n \n@@ -857,7 +854,6 @@ impl Clean<FnDecl> for ast::FnDecl {\n                 values: self.inputs.clean(cx),\n             },\n             output: self.output.clean(cx),\n-            cf: self.cf.clean(cx),\n             attrs: Vec::new()\n         }\n     }\n@@ -884,8 +880,7 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: sig.output.clean(cx),\n-            cf: Return,\n+            output: Return(sig.output.clean(cx)),\n             attrs: Vec::new(),\n             inputs: Arguments {\n                 values: sig.inputs.iter().map(|t| {\n@@ -918,16 +913,16 @@ impl Clean<Argument> for ast::Arg {\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n-pub enum RetStyle {\n-    NoReturn,\n-    Return\n+pub enum FunctionRetTy {\n+    Return(Type),\n+    NoReturn\n }\n \n-impl Clean<RetStyle> for ast::RetStyle {\n-    fn clean(&self, _: &DocContext) -> RetStyle {\n+impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n+    fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n         match *self {\n-            ast::Return => Return,\n-            ast::NoReturn => NoReturn\n+            ast::Return(ref typ) => Return(typ.clean(cx)),\n+            ast::NoReturn(_) => NoReturn\n         }\n     }\n }\n@@ -1124,7 +1119,6 @@ pub enum PrimitiveType {\n     F32, F64,\n     Char,\n     Bool,\n-    Unit,\n     Str,\n     Slice,\n     PrimitiveTuple,\n@@ -1156,7 +1150,6 @@ impl PrimitiveType {\n             \"u32\" => Some(U32),\n             \"u64\" => Some(U64),\n             \"bool\" => Some(Bool),\n-            \"unit\" => Some(Unit),\n             \"char\" => Some(Char),\n             \"str\" => Some(Str),\n             \"f32\" => Some(F32),\n@@ -1205,17 +1198,13 @@ impl PrimitiveType {\n             Str => \"str\",\n             Bool => \"bool\",\n             Char => \"char\",\n-            Unit => \"()\",\n             Slice => \"slice\",\n             PrimitiveTuple => \"tuple\",\n         }\n     }\n \n     pub fn to_url_str(&self) -> &'static str {\n-        match *self {\n-            Unit => \"unit\",\n-            other => other.to_string(),\n-        }\n+        self.to_string()\n     }\n \n     /// Creates a rustdoc-specific node id for primitive types.\n@@ -1230,12 +1219,10 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use syntax::ast::*;\n         match self.node {\n-            TyNil => Primitive(Unit),\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n-            TyUniq(ref ty) => Unique(box ty.clean(cx)),\n             TyVec(ref ty) => Vector(box ty.clean(cx)),\n             TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n                                                            e.span.to_src(cx)),\n@@ -1247,7 +1234,6 @@ impl Clean<Type> for ast::Ty {\n             TyProc(ref c) => Proc(box c.clean(cx)),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n-            TyBot => Bottom,\n             ref x => panic!(\"Unimplemented type {}\", x),\n         }\n     }\n@@ -1256,7 +1242,6 @@ impl Clean<Type> for ast::Ty {\n impl Clean<Type> for ty::t {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n-            ty::ty_nil => Primitive(Unit),\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n             ty::ty_int(ast::TyI) => Primitive(Int),\n@@ -1342,7 +1327,7 @@ impl Clean<Type> for ty::t {\n                 }\n             }\n \n-            ty::ty_unboxed_closure(..) => Primitive(Unit), // FIXME(pcwalton)\n+            ty::ty_unboxed_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n             ty::ty_open(..) => panic!(\"ty_open\"),\n@@ -2041,7 +2026,6 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         ast::LitFloat(ref f, _t) => f.get().to_string(),\n         ast::LitFloatUnsuffixed(ref f) => f.get().to_string(),\n         ast::LitBool(b) => b.to_string(),\n-        ast::LitNil => \"\".to_string(),\n     }\n }\n "}, {"sha": "a7f33151547564a342927aa4edcdabe386af0208", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -393,10 +393,7 @@ impl fmt::Show for clean::Type {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n-                       arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Unit) => \"\".to_string(),\n-                           _ => format!(\" -&gt; {}\", decl.decl.output),\n-                       },\n+                       arrow = decl.decl.output,\n                        bounds = {\n                            let mut ret = String::new();\n                            for bound in decl.bounds.iter() {\n@@ -435,10 +432,7 @@ impl fmt::Show for clean::Type {\n                                \": {}\",\n                                m.collect::<Vec<String>>().connect(\" + \"))\n                        },\n-                       arrow = match decl.decl.output {\n-                           clean::Primitive(clean::Unit) => \"\".to_string(),\n-                           _ => format!(\" -&gt; {}\", decl.decl.output)\n-                       })\n+                       arrow = decl.decl.output)\n             }\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n@@ -514,14 +508,19 @@ impl fmt::Show for clean::Arguments {\n     }\n }\n \n+impl fmt::Show for clean::FunctionRetTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n+            clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n+            clean::NoReturn => write!(f, \" -&gt; !\")\n+        }\n+    }\n+}\n+\n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({args}){arrow}\",\n-               args = self.inputs,\n-               arrow = match self.output {\n-                   clean::Primitive(clean::Unit) => \"\".to_string(),\n-                   _ => format!(\" -&gt; {}\", self.output),\n-               })\n+        write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n     }\n }\n \n@@ -551,12 +550,7 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_).as_slice());\n         }\n-        write!(f, \"({args}){arrow}\",\n-               args = args,\n-               arrow = match d.output {\n-                   clean::Primitive(clean::Unit) => \"\".to_string(),\n-                   _ => format!(\" -&gt; {}\", d.output),\n-               })\n+        write!(f, \"({args}){arrow}\", args = args, arrow = d.output)\n     }\n }\n "}, {"sha": "0e1921a07734b4a960f87fba96c72618859d102e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -893,7 +893,6 @@ pub enum Lit_ {\n     LitInt(u64, LitIntType),\n     LitFloat(InternedString, FloatTy),\n     LitFloatUnsuffixed(InternedString),\n-    LitNil,\n     LitBool(bool),\n }\n \n@@ -1086,12 +1085,6 @@ pub struct BareFnTy {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n-    /// The unit type (`()`)\n-    TyNil,\n-    /// The bottom type (`!`)\n-    TyBot,\n-    TyUniq(P<Ty>),\n-    /// An array (`[T]`)\n     TyVec(P<Ty>),\n     /// A fixed length array (`[T, ..n]`)\n     TyFixedLengthVec(P<Ty>, P<Expr>),\n@@ -1175,8 +1168,7 @@ impl Arg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n-    pub output: P<Ty>,\n-    pub cf: RetStyle,\n+    pub output: FunctionRetTy,\n     pub variadic: bool\n }\n \n@@ -1198,12 +1190,21 @@ impl fmt::Show for FnStyle {\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum RetStyle {\n+pub enum FunctionRetTy {\n     /// Functions with return type ! that always\n     /// raise an error or exit (i.e. never return to the caller)\n-    NoReturn,\n+    NoReturn(Span),\n     /// Everything else\n-    Return,\n+    Return(P<Ty>),\n+}\n+\n+impl FunctionRetTy {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            NoReturn(span) => span,\n+            Return(ref ty) => ty.span\n+        }\n+    }\n }\n \n /// Represents the kind of 'self' associated with a method"}, {"sha": "0c7a3cf4a6ce3f4b2efe92e62c07058073ca9f63", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -248,7 +248,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(P(codemap::respan(sp, ast::LitNil))),\n+            node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n             span: sp,\n         })\n     }"}, {"sha": "ffc42b6703384667e032ed6efe1400e74eb46f9a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -54,11 +54,9 @@ pub trait AstBuilder {\n     fn ty_ptr(&self, span: Span,\n               ty: P<ast::Ty>,\n               mutbl: ast::Mutability) -> P<ast::Ty>;\n-    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n-    fn ty_nil(&self) -> P<ast::Ty>;\n \n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n@@ -377,9 +375,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(span,\n                 ast::TyPtr(self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty(span, ast::TyUniq(ty))\n-    }\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty_path(\n@@ -406,14 +401,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(span, ast::TyInfer)\n     }\n \n-    fn ty_nil(&self) -> P<ast::Ty> {\n-        P(ast::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::TyNil,\n-            span: DUMMY_SP,\n-        })\n-    }\n-\n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n@@ -809,8 +796,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat(span, pat)\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = ast::PatTup(pats);\n-        self.pat(span, pat)\n+        self.pat(span, ast::PatTup(pats))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n@@ -931,11 +917,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // FIXME unused self\n-    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl> {\n+    fn fn_decl(&self, inputs: Vec<ast::Arg>, output: P<ast::Ty>) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs: inputs,\n-            output: output,\n-            cf: ast::Return,\n+            output: ast::Return(output),\n             variadic: false\n         })\n     }"}, {"sha": "e2867c2fbabfa9fb67d2531727120940fb6e5365", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -46,7 +46,6 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n                         accumulator.push_str(format!(\"-{}\", i).as_slice());\n                     }\n-                    ast::LitNil => {}\n                     ast::LitBool(b) => {\n                         accumulator.push_str(format!(\"{}\", b).as_slice());\n                     }"}, {"sha": "62f3b5d01b41a2053da0a00e03364025571de532", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -88,7 +88,7 @@\n //! }\n //! ```\n \n-use ast::{MetaItem, Item, Expr, ExprRet, MutMutable, LitNil};\n+use ast::{MetaItem, Item, Expr, ExprRet, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -186,7 +186,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             if stmts.is_empty() {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_lit(trait_span, LitNil)))));\n+                                                             cx.expr_tuple(trait_span, vec![])))));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n \n@@ -231,7 +231,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             if stmts.len() == 0 {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_lit(trait_span, LitNil)))));\n+                                                             cx.expr_tuple(trait_span, vec![])))));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n "}, {"sha": "4be299994fd2110d5f7aacf1f63f7363fdac49bc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -922,7 +922,7 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat(sp, ast::PatTup(subpats));\n+                let single_pat = cx.pat_tuple(sp, subpats);\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case"}, {"sha": "8b46769d633f3c05c745418cdf38ae5f7e8f6eed", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -152,14 +152,9 @@ impl<'a> Ty<'a> {\n                 cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n             }\n             Tuple(ref fields) => {\n-                let ty = if fields.is_empty() {\n-                    ast::TyNil\n-                } else {\n-                    ast::TyTup(fields.iter()\n-                                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n-                                     .collect())\n-                };\n-\n+                let ty = ast::TyTup(fields.iter()\n+                    .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n+                    .collect());\n                 cx.ty(span, ty)\n             }\n         }"}, {"sha": "fa69495fa42aae0b2dca2e89e0be529114b76da5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -159,7 +159,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // `_ => [<elseopt> | ()]`\n             let else_arm = {\n                 let pat_under = fld.cx.pat_wild(span);\n-                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_lit(span, ast::LitNil));\n+                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_tuple(span, vec![]));\n                 fld.cx.arm(span, vec![pat_under], else_expr)\n             };\n "}, {"sha": "a816b4796304646a1a653564185a8cdd8d4913e4", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         //\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n-        let pat = self.ecx.pat(self.fmtsp, ast::PatTup(pats));\n+        let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n         let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))"}, {"sha": "56d912824374d7ae025fab3c1e42ea375d732755", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -391,8 +391,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyNil | TyBot | TyInfer => node,\n-            TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n+            TyInfer => node,\n             TyVec(ty) => TyVec(fld.fold_ty(ty)),\n             TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n             TyRptr(region, mt) => {\n@@ -706,10 +705,12 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n }\n \n pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+    decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n         inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-        output: fld.fold_ty(output),\n-        cf: cf,\n+        output: match output {\n+            Return(ty) => Return(fld.fold_ty(ty)),\n+            NoReturn(span) => NoReturn(span)\n+        },\n         variadic: variadic\n     })\n }\n@@ -1146,10 +1147,12 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n         attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n         node: match node {\n             ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(fdec.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+                ForeignItemFn(fdec.map(|FnDecl {inputs, output, variadic}| FnDecl {\n                     inputs: inputs.move_map(|a| folder.fold_arg(a)),\n-                    output: folder.fold_ty(output),\n-                    cf: cf,\n+                    output: match output {\n+                        Return(ty) => Return(folder.fold_ty(ty)),\n+                        NoReturn(span) => NoReturn(span)\n+                    },\n                     variadic: variadic\n                 }), folder.fold_generics(generics))\n             }"}, {"sha": "fa10cb90f83a934be1f1bda24acb3cab646a0743", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -24,7 +24,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n+#![feature(if_let, macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n \n extern crate arena;"}, {"sha": "2810db4eaddd8ee493793b05dab0aaacb45bb343", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -1037,10 +1037,9 @@ mod test {\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }),\n-                                output: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                  node: ast::TyNil,\n-                                                  span:sp(15,15)}), // not sure\n-                                cf: ast::Return,\n+                                output: ast::Return(P(ast::Ty{id: ast::DUMMY_NODE_ID,\n+                                                  node: ast::TyTup(vec![]),\n+                                                  span:sp(15,15)})), // not sure\n                                 variadic: false\n                             }),\n                                     ast::NormalFn,"}, {"sha": "1b2ab3c235d5f59bdb17fdf697f1b9c09bde5fc9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -17,8 +17,8 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{Expr, ExprLit, LitNil};\n-use codemap::{Span, respan};\n+use ast::{Expr, ExprTup};\n+use codemap::Span;\n use parse::parser;\n use parse::token;\n use ptr::P;\n@@ -96,7 +96,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// a placeholder expression\n     fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> P<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(P(respan(sp, LitNil))))\n+        self.mk_expr(sp.lo, sp.hi, ExprTup(vec![]))\n     }\n \n     fn report(&mut self,"}, {"sha": "4f487a10e9867c97baea0641faae98d028438abd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 60, "deletions": 96, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -30,32 +30,32 @@ use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{Once, Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n-use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n+use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, NormalFn, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n-use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n+use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchNormal};\n use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef};\n use ast::{QPath, RequiredMethod};\n-use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{TupleVariantKind, Ty, Ty_, TyBot};\n+use ast::{TupleVariantKind, Ty, Ty_};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n-use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n+use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n+use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n@@ -1066,11 +1066,10 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Fn);\n         let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, true);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         });\n         TyBareFn(P(BareFnTy {\n@@ -1100,11 +1099,10 @@ impl<'a> Parser<'a> {\n         let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, false);\n         let bounds = self.parse_colon_then_ty_param_bounds();\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         });\n         TyProc(P(ClosureTy {\n@@ -1200,11 +1198,10 @@ impl<'a> Parser<'a> {\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n \n-        let (return_style, output) = self.parse_ret_ty();\n+        let output = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: return_style,\n             variadic: false\n         });\n \n@@ -1384,31 +1381,20 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&mut self) -> (RetStyle, P<Ty>) {\n-        return if self.eat(&token::RArrow) {\n-            let lo = self.span.lo;\n+    pub fn parse_ret_ty(&mut self) -> FunctionRetTy {\n+        if self.eat(&token::RArrow) {\n             if self.eat(&token::Not) {\n-                (\n-                    NoReturn,\n-                    P(Ty {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: TyBot,\n-                        span: mk_sp(lo, self.last_span.hi)\n-                    })\n-                )\n+                NoReturn(self.span)\n             } else {\n-                (Return, self.parse_ty(true))\n+                Return(self.parse_ty(true))\n             }\n         } else {\n             let pos = self.span.lo;\n-            (\n-                Return,\n-                P(Ty {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: TyNil,\n-                    span: mk_sp(pos, pos),\n-                })\n-            )\n+            Return(P(Ty {\n+                id: ast::DUMMY_NODE_ID,\n+                node: TyTup(vec![]),\n+                span: mk_sp(pos, pos),\n+            }))\n         }\n     }\n \n@@ -1423,34 +1409,29 @@ impl<'a> Parser<'a> {\n \n         let t = if self.token == token::OpenDelim(token::Paren) {\n             self.bump();\n-            if self.token == token::CloseDelim(token::Paren) {\n-                self.bump();\n-                TyNil\n-            } else {\n-                // (t) is a parenthesized ty\n-                // (t,) is the type of a tuple with only one field,\n-                // of type t\n-                let mut ts = vec!(self.parse_ty(true));\n-                let mut one_tuple = false;\n-                while self.token == token::Comma {\n-                    self.bump();\n-                    if self.token != token::CloseDelim(token::Paren) {\n-                        ts.push(self.parse_ty(true));\n-                    }\n-                    else {\n-                        one_tuple = true;\n-                    }\n-                }\n \n-                if ts.len() == 1 && !one_tuple {\n-                    self.expect(&token::CloseDelim(token::Paren));\n-                    TyParen(ts.into_iter().nth(0).unwrap())\n+            // (t) is a parenthesized ty\n+            // (t,) is the type of a tuple with only one field,\n+            // of type t\n+            let mut ts = vec![];\n+            let mut last_comma = false;\n+            while self.token != token::CloseDelim(token::Paren) {\n+                ts.push(self.parse_ty(true));\n+                if self.token == token::Comma {\n+                    last_comma = true;\n+                    self.bump();\n                 } else {\n-                    let t = TyTup(ts);\n-                    self.expect(&token::CloseDelim(token::Paren));\n-                    t\n+                    last_comma = false;\n+                    break;\n                 }\n             }\n+\n+            self.expect(&token::CloseDelim(token::Paren));\n+            if ts.len() == 1 && !last_comma {\n+                TyParen(ts.into_iter().nth(0).unwrap())\n+            } else {\n+                TyTup(ts)\n+            }\n         } else if self.token == token::Tilde {\n             // OWNED POINTER\n             self.bump();\n@@ -1459,7 +1440,7 @@ impl<'a> Parser<'a> {\n                 token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n-            TyUniq(self.parse_ty(false))\n+            TyTup(vec![self.parse_ty(false)])\n         } else if self.token == token::BinOp(token::Star) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -1662,10 +1643,6 @@ impl<'a> Parser<'a> {\n                 LitBinary(parse::binary_lit(i.as_str())),\n             token::LitBinaryRaw(i, _) =>\n                 LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n-            token::OpenDelim(token::Paren) => {\n-                self.expect(&token::CloseDelim(token::Paren));\n-                LitNil\n-            },\n             _ => { self.unexpected_last(tok); }\n         }\n     }\n@@ -2126,33 +2103,29 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::OpenDelim(token::Paren) => {\n                 self.bump();\n+\n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n+                let mut es = vec![];\n                 let mut trailing_comma = false;\n-                if self.token == token::CloseDelim(token::Paren) {\n-                    hi = self.span.hi;\n-                    self.bump();\n-                    let lit = P(spanned(lo, hi, LitNil));\n-                    return self.mk_expr(lo, hi, ExprLit(lit));\n-                }\n-                let mut es = vec!(self.parse_expr());\n-                self.commit_expr(&**es.last().unwrap(), &[],\n-                                 &[token::Comma, token::CloseDelim(token::Paren)]);\n-                while self.token == token::Comma {\n-                    self.bump();\n-                    if self.token != token::CloseDelim(token::Paren) {\n-                        es.push(self.parse_expr());\n-                        self.commit_expr(&**es.last().unwrap(), &[],\n-                                         &[token::Comma, token::CloseDelim(token::Paren)]);\n-                    } else {\n+                while self.token != token::CloseDelim(token::Paren) {\n+                    es.push(self.parse_expr());\n+                    self.commit_expr(&**es.last().unwrap(), &[],\n+                                     &[token::Comma, token::CloseDelim(token::Paren)]);\n+                    if self.token == token::Comma {\n                         trailing_comma = true;\n+\n+                        self.bump();\n+                    } else {\n+                        trailing_comma = false;\n+                        break;\n                     }\n                 }\n-                hi = self.span.hi;\n-                self.commit_expr_expecting(&**es.last().unwrap(), token::CloseDelim(token::Paren));\n+                self.bump();\n \n+                hi = self.span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                   self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n+                    self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()))\n                 } else {\n                     self.mk_expr(lo, hi, ExprTup(es))\n                 }\n@@ -3293,13 +3266,8 @@ impl<'a> Parser<'a> {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n             if self.token == token::CloseDelim(token::Paren) {\n-                hi = self.span.hi;\n                 self.bump();\n-                let lit = P(codemap::Spanned {\n-                    node: LitNil,\n-                    span: mk_sp(lo, hi)});\n-                let expr = self.mk_expr(lo, hi, ExprLit(lit));\n-                pat = PatLit(expr);\n+                pat = PatTup(vec![]);\n             } else {\n                 let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n@@ -4137,12 +4105,11 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> P<FnDecl> {\n \n         let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n \n         P(FnDecl {\n             inputs: args,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: variadic\n         })\n     }\n@@ -4337,12 +4304,11 @@ impl<'a> Parser<'a> {\n \n         let hi = self.span.hi;\n \n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let ret_ty = self.parse_ret_ty();\n \n         let fn_decl = P(FnDecl {\n             inputs: fn_inputs,\n             output: ret_ty,\n-            cf: ret_style,\n             variadic: false\n         });\n \n@@ -4368,10 +4334,10 @@ impl<'a> Parser<'a> {\n                 (optional_unboxed_closure_kind, args)\n             }\n         };\n-        let (style, output) = if self.token == token::RArrow {\n+        let output = if self.token == token::RArrow {\n             self.parse_ret_ty()\n         } else {\n-            (Return, P(Ty {\n+            Return(P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyInfer,\n                 span: self.span,\n@@ -4381,7 +4347,6 @@ impl<'a> Parser<'a> {\n         (P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n-            cf: style,\n             variadic: false\n         }), optional_unboxed_closure_kind)\n     }\n@@ -4394,10 +4359,10 @@ impl<'a> Parser<'a> {\n                                      seq_sep_trailing_allowed(token::Comma),\n                                      |p| p.parse_fn_block_arg());\n \n-        let (style, output) = if self.token == token::RArrow {\n+        let output = if self.token == token::RArrow {\n             self.parse_ret_ty()\n         } else {\n-            (Return, P(Ty {\n+            Return(P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyInfer,\n                 span: self.span,\n@@ -4407,7 +4372,6 @@ impl<'a> Parser<'a> {\n         P(FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: style,\n             variadic: false\n         })\n     }"}, {"sha": "7025555ab4006483c8abc397fbdc974a464a5fcc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -645,12 +645,6 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ty.span.lo));\n         try!(self.ibox(0u));\n         match ty.node {\n-            ast::TyNil => try!(word(&mut self.s, \"()\")),\n-            ast::TyBot => try!(word(&mut self.s, \"!\")),\n-            ast::TyUniq(ref ty) => {\n-                try!(word(&mut self.s, \"~\"));\n-                try!(self.print_type(&**ty));\n-            }\n             ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n@@ -2307,15 +2301,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.pclose());\n \n-        try!(self.maybe_print_comment(decl.output.span.lo));\n-        match decl.output.node {\n-            ast::TyNil => Ok(()),\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                self.print_type(&*decl.output)\n-            }\n-        }\n+        self.print_fn_output(decl)\n     }\n \n     pub fn print_fn_block_args(\n@@ -2333,16 +2319,24 @@ impl<'a> State<'a> {\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n \n-        match decl.output.node {\n-            ast::TyInfer => {}\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            if ty.node == ast::TyInfer {\n+                return self.maybe_print_comment(ty.span.lo);\n             }\n         }\n \n-        self.maybe_print_comment(decl.output.span.lo)\n+        try!(self.space_if_not_bol());\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::Return(ref ty) => {\n+                try!(self.print_type(&**ty));\n+                self.maybe_print_comment(ty.span.lo)\n+            }\n+            ast::NoReturn(span) => {\n+                try!(self.word_nbsp(\"!\"));\n+                self.maybe_print_comment(span.lo)\n+            }\n+        }\n     }\n \n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureClause)\n@@ -2359,16 +2353,24 @@ impl<'a> State<'a> {\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \")\"));\n \n-        match decl.output.node {\n-            ast::TyInfer => {}\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.word_space(\"->\"));\n-                try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            if ty.node == ast::TyInfer {\n+                return self.maybe_print_comment(ty.span.lo);\n             }\n         }\n \n-        self.maybe_print_comment(decl.output.span.lo)\n+        try!(self.space_if_not_bol());\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::Return(ref ty) => {\n+                try!(self.print_type(&**ty));\n+                self.maybe_print_comment(ty.span.lo)\n+            }\n+            ast::NoReturn(span) => {\n+                try!(self.word_nbsp(\"!\"));\n+                self.maybe_print_comment(span.lo)\n+            }\n+        }\n     }\n \n     pub fn print_bounds(&mut self,\n@@ -2627,20 +2629,30 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n-        match decl.output.node {\n-            ast::TyNil => Ok(()),\n-            _ => {\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(indent_unit));\n-                try!(self.word_space(\"->\"));\n-                if decl.cf == ast::NoReturn {\n-                    try!(self.word_nbsp(\"!\"));\n-                } else {\n-                    try!(self.print_type(&*decl.output));\n+        if let ast::Return(ref ty) = decl.output {\n+            match ty.node {\n+                ast::TyTup(ref tys) if tys.is_empty() => {\n+                    return self.maybe_print_comment(ty.span.lo);\n                 }\n-                self.end()\n+                _ => ()\n             }\n         }\n+\n+        try!(self.space_if_not_bol());\n+        try!(self.ibox(indent_unit));\n+        try!(self.word_space(\"->\"));\n+        match decl.output {\n+            ast::NoReturn(_) =>\n+                try!(self.word_nbsp(\"!\")),\n+            ast::Return(ref ty) =>\n+                try!(self.print_type(&**ty))\n+        }\n+        try!(self.end());\n+\n+        match decl.output {\n+            ast::Return(ref output) => self.maybe_print_comment(output.span.lo),\n+            _ => Ok(())\n+        }\n     }\n \n     pub fn print_ty_fn(&mut self,\n@@ -2700,8 +2712,6 @@ impl<'a> State<'a> {\n \n         try!(self.print_bounds(\":\", bounds));\n \n-        try!(self.maybe_print_comment(decl.output.span.lo));\n-\n         try!(self.print_fn_output(decl));\n \n         match generics {\n@@ -2807,7 +2817,6 @@ impl<'a> State<'a> {\n                          ast_util::float_ty_to_string(t).as_slice()).as_slice())\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n-            ast::LitNil => word(&mut self.s, \"()\"),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n@@ -3003,10 +3012,9 @@ mod test {\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n-            output: P(ast::Ty {id: 0,\n-                               node: ast::TyNil,\n-                               span: codemap::DUMMY_SP}),\n-            cf: ast::Return,\n+            output: ast::Return(P(ast::Ty {id: 0,\n+                               node: ast::TyTup(vec![]),\n+                               span: codemap::DUMMY_SP})),\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();"}, {"sha": "8b6d752d4848e83154109593479642c62fd87853", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -289,9 +289,12 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n-            let no_output = match decl.output.node {\n-                ast::TyNil => true,\n-                _ => false,\n+            let no_output = match decl.output {\n+                ast::Return(ref ret_ty) => match ret_ty.node {\n+                    ast::TyTup(ref tys) if tys.is_empty() => true,\n+                    _ => false,\n+                },\n+                ast::NoReturn(_) => false\n             };\n             if decl.inputs.is_empty()\n                    && no_output\n@@ -325,9 +328,12 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n-                let no_output = match decl.output.node {\n-                    ast::TyNil => true,\n-                    _ => false\n+                let no_output = match decl.output {\n+                    ast::Return(ref ret_ty) => match ret_ty.node {\n+                        ast::TyTup(ref tys) if tys.is_empty() => true,\n+                        _ => false,\n+                    },\n+                    ast::NoReturn(_) => false\n                 };\n                 let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running"}, {"sha": "f30a4325eb8c0dd8a3f8965eee702af802ad8121", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -341,7 +341,7 @@ pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n-        TyUniq(ref ty) | TyVec(ref ty) | TyParen(ref ty) => {\n+        TyVec(ref ty) | TyParen(ref ty) => {\n             visitor.visit_ty(&**ty)\n         }\n         TyPtr(ref mutable_type) => {\n@@ -360,23 +360,23 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_ty_param_bounds(visitor, &function_declaration.bounds);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_ty_param_bounds(visitor, &function_declaration.bounds);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyPath(ref path, ref opt_bounds, id) => {\n@@ -403,7 +403,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(&**expression)\n         }\n-        TyNil | TyBot | TyInfer => {}\n+        TyInfer => {}\n     }\n }\n \n@@ -538,12 +538,18 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n }\n \n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+    if let Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(&**output_ty)\n+    }\n+}\n+\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in function_declaration.inputs.iter() {\n         visitor.visit_pat(&*argument.pat);\n         visitor.visit_ty(&*argument.ty)\n     }\n-    visitor.visit_ty(&*function_declaration.output)\n+    walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -601,7 +607,7 @@ pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v Type\n         visitor.visit_ty(&*argument_type.ty)\n     }\n     visitor.visit_generics(&method_type.generics);\n-    visitor.visit_ty(&*method_type.decl.output);\n+    walk_fn_ret_ty(visitor, &method_type.decl.output);\n     for attr in method_type.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }"}, {"sha": "e7d3d15e5a938893b2d5d32f06b66d656a94c830", "filename": "src/test/compile-fail/issue-16939.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -14,7 +14,7 @@\n // wrong arity.\n \n fn _foo<F: Fn()> (f: F) {\n-    |t| f(t); //~ ERROR E0058\n+    |t| f(t); //~ ERROR E0057\n }\n \n fn main() {}"}, {"sha": "87fe50c86665c1735cfcd160711b746a14f747e4", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -12,5 +12,5 @@ enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [ST_NULL, ..(ST_WHITESPACE as uint)];\n-    //~^ ERROR expected constant integer for repeat count, found variable\n+    //~^ ERROR expected constant integer for repeat count, found non-constant expression\n }"}, {"sha": "38fbb426fb19885259fc9f90e69d4af3e1b8d30f", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -13,8 +13,9 @@\n fn main() {\n     let n = 1;\n     let a = [0, ..n]; //~ ERROR expected constant integer for repeat count, found variable\n-    let b = [0, ..()]; //~ ERROR expected positive integer for repeat count, found ()\n-    //~^ ERROR: expected `uint`, found `()`\n+    let b = [0, ..()];\n+//~^ ERROR expected constant integer for repeat count, found non-constant expression\n+//~^^ ERROR: expected `uint`, found `()`\n     let c = [0, ..true]; //~ ERROR expected positive integer for repeat count, found boolean\n     //~^ ERROR: expected `uint`, found `bool`\n     let d = [0, ..0.5]; //~ ERROR expected positive integer for repeat count, found float"}, {"sha": "d78f948edc5c7d75367e63c7c102e792e3465f82", "filename": "src/test/run-pass/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Frun-pass%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615/src%2Ftest%2Frun-pass%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconcat.rs?ref=321488b6751e33ac9bc2d48a7e5d5c2a5ca5b615", "patch": "@@ -15,12 +15,12 @@ pub fn main() {\n     assert_eq!(concat!(\"qux\", \"quux\",).to_string(), \"quxquux\".to_string());\n \n     assert_eq!(\n-        concat!(1, 2i, 3u, 4f32, 4.0, 'a', true, ()),\n+        concat!(1, 2i, 3u, 4f32, 4.0, 'a', true),\n         \"12344.0atrue\"\n     );\n \n     assert!(match \"12344.0atrue\" {\n-        concat!(1, 2i, 3u, 4f32, 4.0, 'a', true, ()) => true,\n+        concat!(1, 2i, 3u, 4f32, 4.0, 'a', true) => true,\n         _ => false\n     })\n }"}]}