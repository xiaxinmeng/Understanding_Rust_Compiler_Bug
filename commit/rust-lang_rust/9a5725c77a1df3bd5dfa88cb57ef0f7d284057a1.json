{"sha": "9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTcyNWM3N2ExZGYzYmQ1ZGZhODhjYjU3ZWYwZjdkMjg0MDU3YTE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-11-29T12:10:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-29T12:10:49Z"}, "message": "Rollup merge of #56312 - oli-obk:const_eval_literal, r=eddyb\n\nDeduplicate literal -> constant lowering", "tree": {"sha": "7cd06a6e285f81a22bfaf654eaa228395bae7e08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd06a6e285f81a22bfaf654eaa228395bae7e08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb/9dJCRBK7hj4Ov3rIwAAdHIIAC0NB8U7aIrWUbbqqIFSbfva\nXLl582mqNH1TkX9tCGJGHFn2GzHEBWsiUlvaEy4DdJXpfZBHRKoYnhBX0YXzLc8r\nmRhcouvxlXMzGzAbMWgsF6o8EiWyv2oIt3BXw9ruw7EbrSYVvSDA/tK35IklQRPv\ntreaVwqAAWUmeAT+XtqEwvUPzcStm0U/dWotO+OJe56rnnomklg4YdCMslou+xZ0\nqmNJgv6XNuUZOhVAJKmFEB8FGLnfB2liK2pu8D0vO01b9pYGQYEeoTV3SDgLHfAM\n+H9/XPUmBhH58h5MpmCCBYr4BoZDDMGrbhmZNv91vGEUJCDnqXPBmbKd0lv3srI=\n=dr/2\n-----END PGP SIGNATURE-----\n", "payload": "tree 7cd06a6e285f81a22bfaf654eaa228395bae7e08\nparent ad6434ecad1bbe880c78a4b33f05cb3182b72505\nparent afb8cba5fc611a652a674b44f1bbf26d200e1aa9\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1543493449 +0100\ncommitter GitHub <noreply@github.com> 1543493449 +0100\n\nRollup merge of #56312 - oli-obk:const_eval_literal, r=eddyb\n\nDeduplicate literal -> constant lowering\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "html_url": "https://github.com/rust-lang/rust/commit/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6434ecad1bbe880c78a4b33f05cb3182b72505", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6434ecad1bbe880c78a4b33f05cb3182b72505", "html_url": "https://github.com/rust-lang/rust/commit/ad6434ecad1bbe880c78a4b33f05cb3182b72505"}, {"sha": "afb8cba5fc611a652a674b44f1bbf26d200e1aa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/afb8cba5fc611a652a674b44f1bbf26d200e1aa9", "html_url": "https://github.com/rust-lang/rust/commit/afb8cba5fc611a652a674b44f1bbf26d200e1aa9"}], "stats": {"total": 307, "additions": 122, "deletions": 185}, "files": [{"sha": "c98ef31c2bae22b958f357b969e54be0948ce89c", "filename": "src/librustc_mir/hair/constant.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "patch": "@@ -0,0 +1,102 @@\n+use syntax::ast;\n+use rustc::ty::{self, Ty, TyCtxt, ParamEnv};\n+use syntax_pos::symbol::Symbol;\n+use rustc::mir::interpret::{ConstValue, Scalar};\n+\n+#[derive(PartialEq)]\n+crate enum LitToConstError {\n+    UnparseableFloat,\n+    Reported,\n+}\n+\n+crate fn lit_to_const<'a, 'gcx, 'tcx>(\n+    lit: &'tcx ast::LitKind,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    neg: bool,\n+) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n+    use syntax::ast::*;\n+\n+    let trunc = |n| {\n+        let param_ty = ParamEnv::reveal_all().and(tcx.lift_to_global(&ty).unwrap());\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let shift = 128 - width.bits();\n+        let result = (n << shift) >> shift;\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::Bits {\n+            bits: result,\n+            size: width.bytes() as u8,\n+        }))\n+    };\n+\n+    use rustc::mir::interpret::*;\n+    let lit = match *lit {\n+        LitKind::Str(ref s, _) => {\n+            let s = s.as_str();\n+            let id = tcx.allocate_bytes(s.as_bytes());\n+            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &tcx)\n+        },\n+        LitKind::ByteStr(ref data) => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::Ptr(id.into()))\n+        },\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n+            bits: n as u128,\n+            size: 1,\n+        }),\n+        LitKind::Int(n, _) if neg => {\n+            let n = n as i128;\n+            let n = n.overflowing_neg().0;\n+            trunc(n as u128)?\n+        },\n+        LitKind::Int(n, _) => trunc(n)?,\n+        LitKind::Float(n, fty) => {\n+            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n+        }\n+        LitKind::FloatUnsuffixed(n) => {\n+            let fty = match ty.sty {\n+                ty::Float(fty) => fty,\n+                _ => bug!()\n+            };\n+            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n+        }\n+        LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n+        LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n+    };\n+    Ok(ty::Const::from_const_value(tcx, lit, ty))\n+}\n+\n+fn parse_float<'tcx>(\n+    num: Symbol,\n+    fty: ast::FloatTy,\n+    neg: bool,\n+) -> Result<ConstValue<'tcx>, ()> {\n+    let num = num.as_str();\n+    use rustc_apfloat::ieee::{Single, Double};\n+    use rustc_apfloat::Float;\n+    let (bits, size) = match fty {\n+        ast::FloatTy::F32 => {\n+            num.parse::<f32>().map_err(|_| ())?;\n+            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            (f.to_bits(), 4)\n+        }\n+        ast::FloatTy::F64 => {\n+            num.parse::<f64>().map_err(|_| ())?;\n+            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            (f.to_bits(), 8)\n+        }\n+    };\n+\n+    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n+}"}, {"sha": "c414088b653221c099ffb5f80ec38c4882fa9035", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "patch": "@@ -26,12 +26,12 @@ use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::layout::VariantIdx;\n-use syntax::ast::{self, LitKind};\n+use syntax::ast;\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n-use hair::pattern::parse_float;\n+use hair::constant::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -131,7 +131,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty::Const::from_bool(self.tcx, false)\n     }\n \n-    // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n     pub fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n@@ -141,61 +140,19 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     ) -> &'tcx ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n-        let parse_float = |num, fty| -> ConstValue<'tcx> {\n-            parse_float(num, fty, neg).unwrap_or_else(|_| {\n+        match lit_to_const(lit, self.tcx, ty, neg) {\n+            Ok(c) => c,\n+            Err(LitToConstError::UnparseableFloat) => {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                self.tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n-            })\n-        };\n-\n-        let trunc = |n| {\n-            let param_ty = self.param_env.and(self.tcx.lift_to_global(&ty).unwrap());\n-            let width = self.tcx.layout_of(param_ty).unwrap().size;\n-            trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-            let shift = 128 - width.bits();\n-            let result = (n << shift) >> shift;\n-            trace!(\"trunc result: {}\", result);\n-            ConstValue::Scalar(Scalar::Bits {\n-                bits: result,\n-                size: width.bytes() as u8,\n-            })\n-        };\n-\n-        use rustc::mir::interpret::*;\n-        let lit = match *lit {\n-            LitKind::Str(ref s, _) => {\n-                let s = s.as_str();\n-                let id = self.tcx.allocate_bytes(s.as_bytes());\n-                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &self.tcx)\n-            },\n-            LitKind::ByteStr(ref data) => {\n-                let id = self.tcx.allocate_bytes(data);\n-                ConstValue::Scalar(Scalar::Ptr(id.into()))\n+                self.tcx.sess.span_err(sp, \"could not evaluate float literal (see issue #31407)\");\n+                // create a dummy value and continue compiling\n+                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n             },\n-            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-                bits: n as u128,\n-                size: 1,\n-            }),\n-            LitKind::Int(n, _) if neg => {\n-                let n = n as i128;\n-                let n = n.overflowing_neg().0;\n-                trunc(n as u128)\n-            },\n-            LitKind::Int(n, _) => trunc(n),\n-            LitKind::Float(n, fty) => {\n-                parse_float(n, fty)\n-            }\n-            LitKind::FloatUnsuffixed(n) => {\n-                let fty = match ty.sty {\n-                    ty::Float(fty) => fty,\n-                    _ => bug!()\n-                };\n-                parse_float(n, fty)\n+            Err(LitToConstError::Reported) => {\n+                // create a dummy value and continue compiling\n+                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n             }\n-            LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n-            LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n-        };\n-        ty::Const::from_const_value(self.tcx, lit, ty)\n+        }\n     }\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {"}, {"sha": "e604b118eacf1f8f445acd5553806bf1ef9dc8e8", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "patch": "@@ -26,6 +26,7 @@ use syntax_pos::Span;\n use self::cx::Cx;\n \n pub mod cx;\n+mod constant;\n \n pub mod pattern;\n pub use self::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};"}, {"sha": "61d8297fec90e5f59202a761c5be89df8603f503", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 130, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=9a5725c77a1df3bd5dfa88cb57ef0f7d284057a1", "patch": "@@ -19,6 +19,7 @@ pub(crate) use self::check_match::check_match;\n use const_eval::{const_field, const_variant_index};\n \n use hair::util::UserAnnotatedTyHelpers;\n+use hair::constant::*;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n@@ -37,7 +38,6 @@ use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::symbol::Symbol;\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n@@ -891,12 +891,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        if e == LitToConstError::UnparseableFloat {\n-                            self.errors.push(PatternError::FloatBug);\n-                        }\n+                    Err(LitToConstError::UnparseableFloat) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n+                    Err(LitToConstError::Reported) => PatternKind::Wild,\n                 }\n             },\n             hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n@@ -914,12 +913,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        if e == LitToConstError::UnparseableFloat {\n-                            self.errors.push(PatternError::FloatBug);\n-                        }\n+                    Err(LitToConstError::UnparseableFloat) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n+                    Err(LitToConstError::Reported) => PatternKind::Wild,\n                 }\n             }\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n@@ -1294,124 +1292,3 @@ pub fn compare_const_vals<'a, 'tcx>(\n \n     fallback()\n }\n-\n-#[derive(PartialEq)]\n-enum LitToConstError {\n-    UnparseableFloat,\n-    Propagated,\n-}\n-\n-// FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n-fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          neg: bool)\n-                          -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n-    use syntax::ast::*;\n-\n-    use rustc::mir::interpret::*;\n-    let lit = match *lit {\n-        LitKind::Str(ref s, _) => {\n-            let s = s.as_str();\n-            let id = tcx.allocate_bytes(s.as_bytes());\n-            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &tcx)\n-        },\n-        LitKind::ByteStr(ref data) => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::Ptr(id.into()))\n-        },\n-        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-            bits: n as u128,\n-            size: 1,\n-        }),\n-        LitKind::Int(n, _) => {\n-            enum Int {\n-                Signed(IntTy),\n-                Unsigned(UintTy),\n-            }\n-            let ity = match ty.sty {\n-                ty::Int(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n-                ty::Int(other) => Int::Signed(other),\n-                ty::Uint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n-                ty::Uint(other) => Int::Unsigned(other),\n-                ty::Error => { // Avoid ICE (#51963)\n-                    return Err(LitToConstError::Propagated);\n-                }\n-                _ => bug!(\"literal integer type with bad type ({:?})\", ty.sty),\n-            };\n-            // This converts from LitKind::Int (which is sign extended) to\n-            // Scalar::Bytes (which is zero extended)\n-            let n = match ity {\n-                // FIXME(oli-obk): are these casts correct?\n-                Int::Signed(IntTy::I8) if neg =>\n-                    (n as i8).overflowing_neg().0 as u8 as u128,\n-                Int::Signed(IntTy::I16) if neg =>\n-                    (n as i16).overflowing_neg().0 as u16 as u128,\n-                Int::Signed(IntTy::I32) if neg =>\n-                    (n as i32).overflowing_neg().0 as u32 as u128,\n-                Int::Signed(IntTy::I64) if neg =>\n-                    (n as i64).overflowing_neg().0 as u64 as u128,\n-                Int::Signed(IntTy::I128) if neg =>\n-                    (n as i128).overflowing_neg().0 as u128,\n-                Int::Signed(IntTy::I8) | Int::Unsigned(UintTy::U8) => n as u8 as u128,\n-                Int::Signed(IntTy::I16) | Int::Unsigned(UintTy::U16) => n as u16 as u128,\n-                Int::Signed(IntTy::I32) | Int::Unsigned(UintTy::U32) => n as u32 as u128,\n-                Int::Signed(IntTy::I64) | Int::Unsigned(UintTy::U64) => n as u64 as u128,\n-                Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n-                _ => bug!(),\n-            };\n-            let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bytes() as u8;\n-            ConstValue::Scalar(Scalar::Bits {\n-                bits: n,\n-                size,\n-            })\n-        },\n-        LitKind::Float(n, fty) => {\n-            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n-            let fty = match ty.sty {\n-                ty::Float(fty) => fty,\n-                _ => bug!()\n-            };\n-            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n-        }\n-        LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n-        LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n-    };\n-    Ok(ty::Const::from_const_value(tcx, lit, ty))\n-}\n-\n-pub fn parse_float<'tcx>(\n-    num: Symbol,\n-    fty: ast::FloatTy,\n-    neg: bool,\n-) -> Result<ConstValue<'tcx>, ()> {\n-    let num = num.as_str();\n-    use rustc_apfloat::ieee::{Single, Double};\n-    use rustc_apfloat::Float;\n-    let (bits, size) = match fty {\n-        ast::FloatTy::F32 => {\n-            num.parse::<f32>().map_err(|_| ())?;\n-            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n-                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n-            });\n-            if neg {\n-                f = -f;\n-            }\n-            (f.to_bits(), 4)\n-        }\n-        ast::FloatTy::F64 => {\n-            num.parse::<f64>().map_err(|_| ())?;\n-            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n-                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n-            });\n-            if neg {\n-                f = -f;\n-            }\n-            (f.to_bits(), 8)\n-        }\n-    };\n-\n-    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n-}"}]}