{"sha": "18f9a79c23da8e8920e4c944656b9945f3544337", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZjlhNzljMjNkYThlODkyMGU0Yzk0NDY1NmI5OTQ1ZjM1NDQzMzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-04T17:59:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-10T17:28:48Z"}, "message": "std: Lift out Windows' CreateProcess lock a bit\n\nThe function `CreateProcess` is not itself unsafe to call from many threads, the\narticle in question is pointing out that handles can be inherited by unintended\nchild processes. This is basically the same race as the standard Unix\nopen-then-set-cloexec race.\n\nSince the intention of the lock is to protect children from inheriting\nunintended handles, the lock is now lifted out to before the creation of the\nchild I/O handles (which will all be inheritable). This will ensure that we only\nhave one process in Rust at least creating inheritable handles at a time,\npreventing unintended inheritance to children.", "tree": {"sha": "9d2095b06d861c8b8f4764d5e6f025066ada8003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d2095b06d861c8b8f4764d5e6f025066ada8003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f9a79c23da8e8920e4c944656b9945f3544337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f9a79c23da8e8920e4c944656b9945f3544337", "html_url": "https://github.com/rust-lang/rust/commit/18f9a79c23da8e8920e4c944656b9945f3544337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f9a79c23da8e8920e4c944656b9945f3544337/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8bd8f3d7c9c8a3187d6c80ab201f66dedee457c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bd8f3d7c9c8a3187d6c80ab201f66dedee457c", "html_url": "https://github.com/rust-lang/rust/commit/b8bd8f3d7c9c8a3187d6c80ab201f66dedee457c"}], "stats": {"total": 33, "additions": 20, "deletions": 13}, "files": [{"sha": "2f548a708039cf317c00083cd4173876e4865469", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/18f9a79c23da8e8920e4c944656b9945f3544337/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f9a79c23da8e8920e4c944656b9945f3544337/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=18f9a79c23da8e8920e4c944656b9945f3544337", "patch": "@@ -159,14 +159,6 @@ impl Process {\n         si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n-        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n-        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n-        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n-\n-        si.hStdInput = stdin.raw();\n-        si.hStdOutput = stdout.raw();\n-        si.hStdError = stderr.raw();\n-\n         let program = program.as_ref().unwrap_or(&cfg.program);\n         let mut cmd_str = try!(make_command_line(program, &cfg.args));\n         cmd_str.push(0); // add null terminator\n@@ -180,12 +172,27 @@ impl Process {\n         let (envp, _data) = try!(make_envp(cfg.env.as_ref()));\n         let (dirp, _data) = try!(make_dirp(cfg.cwd.as_ref()));\n         let mut pi = zeroed_process_information();\n-        try!(unsafe {\n-            // `CreateProcess` is racy!\n-            // http://support.microsoft.com/kb/315939\n-            static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n-            let _lock = CREATE_PROCESS_LOCK.lock();\n \n+        // Prepare all stdio handles to be inherited by the child. This\n+        // currently involves duplicating any existing ones with the ability to\n+        // be inherited by child processes. Note, however, that once an\n+        // inheritable handle is created, *any* spawned child will inherit that\n+        // handle. We only want our own child to inherit this handle, so we wrap\n+        // the remaining portion of this spawn in a mutex.\n+        //\n+        // For more information, msdn also has an article about this race:\n+        // http://support.microsoft.com/kb/315939\n+        static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n+        let _lock = CREATE_PROCESS_LOCK.lock();\n+\n+        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n+        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n+        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n+        si.hStdInput = stdin.raw();\n+        si.hStdOutput = stdout.raw();\n+        si.hStdError = stderr.raw();\n+\n+        try!(unsafe {\n             cvt(c::CreateProcessW(ptr::null(),\n                                   cmd_str.as_mut_ptr(),\n                                   ptr::null_mut(),"}]}