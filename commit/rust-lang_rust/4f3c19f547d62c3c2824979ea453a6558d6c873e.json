{"sha": "4f3c19f547d62c3c2824979ea453a6558d6c873e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmM2MxOWY1NDdkNjJjM2MyODI0OTc5ZWE0NTNhNjU1OGQ2Yzg3M2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-14T22:47:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-14T22:47:55Z"}, "message": "Auto merge of #26110 - nrc:save-api-3, r=brson\n\nr? @huonw", "tree": {"sha": "ea603605134d307557bc7665cd20cb940d1aa225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea603605134d307557bc7665cd20cb940d1aa225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3c19f547d62c3c2824979ea453a6558d6c873e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c19f547d62c3c2824979ea453a6558d6c873e", "html_url": "https://github.com/rust-lang/rust/commit/4f3c19f547d62c3c2824979ea453a6558d6c873e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c19f547d62c3c2824979ea453a6558d6c873e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b26eeffacb80c122e0559ada5584fdce7183561b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26eeffacb80c122e0559ada5584fdce7183561b", "html_url": "https://github.com/rust-lang/rust/commit/b26eeffacb80c122e0559ada5584fdce7183561b"}, {"sha": "718268398e312b02775e946af31d77fe35fb5550", "url": "https://api.github.com/repos/rust-lang/rust/commits/718268398e312b02775e946af31d77fe35fb5550", "html_url": "https://github.com/rust-lang/rust/commit/718268398e312b02775e946af31d77fe35fb5550"}], "stats": {"total": 540, "additions": 332, "deletions": 208}, "files": [{"sha": "cbc40af4b524e8009dc346c34909a82f8e3127a9", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 156, "deletions": 197, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=4f3c19f547d62c3c2824979ea453a6558d6c873e", "patch": "@@ -54,6 +54,15 @@ use super::recorder::{Recorder, FmtStrs};\n \n use util::ppaux;\n \n+macro_rules! down_cast_data {\n+    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+        let $id = if let super::Data::$kind(data) = $id {\n+            data\n+        } else {\n+            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+        };\n+    };\n+}\n \n pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n@@ -249,7 +258,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n-            def::DefStruct(_) => Some(recorder::StructRef),\n+            def::DefStruct(_) => Some(recorder::TypeRef),\n             def::DefTy(..) |\n             def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n@@ -419,48 +428,31 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     id);\n     }\n \n-    fn process_trait_ref(&mut self,\n-                         trait_ref: &ast::TraitRef) {\n-        match self.lookup_type_ref(trait_ref.ref_id) {\n-            Some(id) => {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 trait_ref.path.span,\n-                                 sub_span,\n-                                 id,\n-                                 self.cur_scope);\n-                visit::walk_path(self, &trait_ref.path);\n-            },\n-            None => ()\n+    fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n+        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n+        if let Some(trait_ref_data) = trait_ref_data {\n+            self.fmt.ref_str(recorder::TypeRef,\n+                             trait_ref.path.span,\n+                             Some(trait_ref_data.span),\n+                             trait_ref_data.ref_id,\n+                             trait_ref_data.scope);\n+            visit::walk_path(self, &trait_ref.path);\n         }\n     }\n \n     fn process_struct_field_def(&mut self,\n                                 field: &ast::StructField,\n-                                qualname: &str,\n-                                scope_id: NodeId) {\n-        match field.node.kind {\n-            ast::NamedField(ident, _) => {\n-                let name = get_ident(ident);\n-                let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n-                match self.span.sub_span_before_token(field.span, token::Colon) {\n-                    Some(sub_span) => self.fmt.field_str(field.span,\n-                                                         Some(sub_span),\n-                                                         field.node.id,\n-                                                         &name,\n-                                                         &qualname,\n-                                                         &typ,\n-                                                         scope_id),\n-                    None => self.sess.span_bug(field.span,\n-                                               &format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)),\n-                }\n-            },\n-            _ => (),\n+                                parent_id: NodeId) {\n+        let field_data = self.save_ctxt.get_field_data(field, parent_id);\n+        if let Some(field_data) = field_data {\n+            down_cast_data!(field_data, VariableData, self, field.span);\n+            self.fmt.field_str(field.span,\n+                               Some(field_data.span),\n+                               field_data.id,\n+                               &field_data.name,\n+                               &field_data.qualname,\n+                               &field_data.type_value,\n+                               field_data.scope);\n         }\n     }\n \n@@ -497,19 +489,16 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n         let fn_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::FunctionData(fn_data) = fn_data {\n-            self.fmt.fn_str(item.span,\n-                            Some(fn_data.span),\n-                            fn_data.id,\n-                            &fn_data.qualname,\n-                            fn_data.scope);\n+        down_cast_data!(fn_data, FunctionData, self, item.span);\n+        self.fmt.fn_str(item.span,\n+                        Some(fn_data.span),\n+                        fn_data.id,\n+                        &fn_data.qualname,\n+                        fn_data.scope);\n \n \n-            self.process_formals(&decl.inputs, &fn_data.qualname);\n-            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected FunctionData\");\n-        }\n+        self.process_formals(&decl.inputs, &fn_data.qualname);\n+        self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n \n         for arg in &decl.inputs {\n             self.visit_ty(&arg.ty);\n@@ -528,18 +517,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     expr: &ast::Expr)\n     {\n         let var_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::VariableData(var_data) = var_data {\n-            self.fmt.static_str(item.span,\n-                                Some(var_data.span),\n-                                var_data.id,\n-                                &var_data.name,\n-                                &var_data.qualname,\n-                                &var_data.value,\n-                                &var_data.type_value,\n-                                var_data.scope);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected VariableData\");\n-        }\n+        down_cast_data!(var_data, VariableData, self, item.span);\n+        self.fmt.static_str(item.span,\n+                            Some(var_data.span),\n+                            var_data.id,\n+                            &var_data.name,\n+                            &var_data.qualname,\n+                            &var_data.value,\n+                            &var_data.type_value,\n+                            var_data.scope);\n \n         self.visit_ty(&typ);\n         self.visit_expr(expr);\n@@ -593,8 +579,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         // fields\n         for field in &def.fields {\n-            self.process_struct_field_def(field, &qualname, item.id);\n-            self.visit_ty(&*field.node.ty);\n+            self.process_struct_field_def(field, item.id);\n+            self.visit_ty(&field.node.ty);\n         }\n \n         self.process_generic_params(ty_params, item.span, &qualname, item.id);\n@@ -605,59 +591,57 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::EnumData(enum_data) = enum_data {\n-            self.fmt.enum_str(item.span,\n-                              Some(enum_data.span),\n-                              enum_data.id,\n-                              &enum_data.qualname,\n-                              self.cur_scope,\n-                              &enum_data.value);\n-            for variant in &enum_definition.variants {\n-                let name = &get_ident(variant.node.name);\n-                let mut qualname = enum_data.qualname.clone();\n-                qualname.push_str(\"::\");\n-                qualname.push_str(name);\n-                let val = self.span.snippet(variant.span);\n-                match variant.node.kind {\n-                    ast::TupleVariantKind(ref args) => {\n-                        // first ident in span is the variant's name\n-                        self.fmt.tuple_variant_str(variant.span,\n-                                                   self.span.span_for_first_ident(variant.span),\n-                                                   variant.node.id,\n-                                                   name,\n-                                                   &qualname,\n-                                                   &enum_data.qualname,\n-                                                   &val,\n-                                                   item.id);\n-                        for arg in args {\n-                            self.visit_ty(&*arg.ty);\n-                        }\n+        down_cast_data!(enum_data, EnumData, self, item.span);\n+        self.fmt.enum_str(item.span,\n+                          Some(enum_data.span),\n+                          enum_data.id,\n+                          &enum_data.qualname,\n+                          enum_data.scope,\n+                          &enum_data.value);\n+\n+        for variant in &enum_definition.variants {\n+            let name = &get_ident(variant.node.name);\n+            let mut qualname = enum_data.qualname.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n+            let val = self.span.snippet(variant.span);\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    // first ident in span is the variant's name\n+                    self.fmt.tuple_variant_str(variant.span,\n+                                               self.span.span_for_first_ident(variant.span),\n+                                               variant.node.id,\n+                                               name,\n+                                               &qualname,\n+                                               &enum_data.qualname,\n+                                               &val,\n+                                               enum_data.id);\n+                    for arg in args {\n+                        self.visit_ty(&*arg.ty);\n                     }\n-                    ast::StructVariantKind(ref struct_def) => {\n-                        let ctor_id = match struct_def.ctor_id {\n-                            Some(node_id) => node_id,\n-                            None => -1,\n-                        };\n-                        self.fmt.struct_variant_str(variant.span,\n-                                                    self.span.span_for_first_ident(variant.span),\n-                                                    variant.node.id,\n-                                                    ctor_id,\n-                                                    &qualname,\n-                                                    &enum_data.qualname,\n-                                                    &val,\n-                                                    item.id);\n-\n-                        for field in &struct_def.fields {\n-                            self.process_struct_field_def(field, &qualname, variant.node.id);\n-                            self.visit_ty(&*field.node.ty);\n-                        }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    let ctor_id = match struct_def.ctor_id {\n+                        Some(node_id) => node_id,\n+                        None => -1,\n+                    };\n+                    self.fmt.struct_variant_str(variant.span,\n+                                                self.span.span_for_first_ident(variant.span),\n+                                                variant.node.id,\n+                                                ctor_id,\n+                                                &qualname,\n+                                                &enum_data.qualname,\n+                                                &val,\n+                                                enum_data.id);\n+\n+                    for field in &struct_def.fields {\n+                        self.process_struct_field_def(field, variant.node.id);\n+                        self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n-            self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected EnumData\");\n         }\n+        self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -666,45 +650,36 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n                     impl_items: &[P<ast::ImplItem>]) {\n-        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n-        match typ.node {\n-            // Common case impl for a struct or something basic.\n-            ast::TyPath(None, ref path) => {\n-                let sub_span = self.span.sub_span_for_type_name(path.span);\n-                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    id\n-                });\n-                self.fmt.impl_str(path.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  self_id,\n-                                  trait_id,\n-                                  self.cur_scope);\n-            },\n-            _ => {\n-                // Less useful case, impl for a compound type.\n-                self.visit_ty(&*typ);\n-\n-                let sub_span = self.span.sub_span_for_type_name(typ.span);\n-                self.fmt.impl_str(typ.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  None,\n-                                  trait_id,\n-                                  self.cur_scope);\n+        let impl_data = self.save_ctxt.get_item_data(item);\n+        down_cast_data!(impl_data, ImplData, self, item.span);\n+        match impl_data.self_ref {\n+            Some(ref self_ref) => {\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 item.span,\n+                                 Some(self_ref.span),\n+                                 self_ref.ref_id,\n+                                 self_ref.scope);\n+            }\n+            None => {\n+                self.visit_ty(&typ);\n             }\n         }\n-\n-        match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n-            None => (),\n+        if let Some(ref trait_ref_data) = impl_data.trait_ref {\n+            self.fmt.ref_str(recorder::TypeRef,\n+                             item.span,\n+                             Some(trait_ref_data.span),\n+                             trait_ref_data.ref_id,\n+                             trait_ref_data.scope);\n+            visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n         }\n \n+        self.fmt.impl_str(item.span,\n+                          Some(impl_data.span),\n+                          impl_data.id,\n+                          impl_data.self_ref.map(|data| data.ref_id),\n+                          impl_data.trait_ref.map(|data| data.ref_id),\n+                          impl_data.scope);\n+\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n             self.visit_impl_item(impl_item);\n@@ -765,16 +740,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_mod(&mut self,\n                    item: &ast::Item) {  // The module in question, represented as an item.\n         let mod_data = self.save_ctxt.get_item_data(item);\n-        if let super::Data::ModData(mod_data) = mod_data {\n-            self.fmt.mod_str(item.span,\n-                             Some(mod_data.span),\n-                             mod_data.id,\n-                             &mod_data.qualname,\n-                             mod_data.scope,\n-                             &mod_data.filename);\n-        } else {\n-            self.sess.span_bug(item.span, \"expected ModData\");\n-        }\n+        down_cast_data!(mod_data, ModData, self, item.span);\n+        self.fmt.mod_str(item.span,\n+                         Some(mod_data.span),\n+                         mod_data.id,\n+                         &mod_data.qualname,\n+                         mod_data.scope,\n+                         &mod_data.filename);\n     }\n \n     fn process_path(&mut self,\n@@ -804,7 +776,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                                     sub_span,\n                                                     def.def_id(),\n                                                     self.cur_scope),\n-            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n+            def::DefStruct(def_id) => self.fmt.ref_str(recorder::TypeRef,\n                                                        span,\n                                                        sub_span,\n                                                        def_id,\n@@ -901,44 +873,33 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         self.write_sub_paths_truncated(path, false);\n \n-        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n-        let struct_def = match *ty {\n-            ty::TyStruct(def_id, _) => {\n-                let sub_span = self.span.span_for_last_ident(path.span);\n-                self.fmt.ref_str(recorder::StructRef,\n-                                 path.span,\n-                                 sub_span,\n-                                 def_id,\n-                                 self.cur_scope);\n-                Some(def_id)\n-            }\n-            _ => None\n-        };\n-\n-        for field in fields {\n-            match struct_def {\n-                Some(struct_def) => {\n-                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in &fields {\n-                        if generated_code(field.ident.span) {\n-                            continue;\n-                        }\n-                        if f.name == field.ident.node.name {\n-                            // We don't really need a sub-span here, but no harm done\n-                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n-                            self.fmt.ref_str(recorder::VarRef,\n-                                             field.ident.span,\n-                                             sub_span,\n-                                             f.id,\n-                                             self.cur_scope);\n-                        }\n-                    }\n+        if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n+            down_cast_data!(struct_lit_data, TypeRefData, self, ex.span);\n+            self.fmt.ref_str(recorder::TypeRef,\n+                             ex.span,\n+                             Some(struct_lit_data.span),\n+                             struct_lit_data.ref_id,\n+                             struct_lit_data.scope);\n+            let struct_def = struct_lit_data.ref_id;\n+\n+            for field in fields {\n+                if generated_code(field.ident.span) {\n+                    continue;\n                 }\n-                None => {}\n-            }\n \n-            self.visit_expr(&*field.expr)\n+                let field_data = self.save_ctxt.get_field_ref_data(field,\n+                                                                   struct_def,\n+                                                                   self.cur_scope);\n+                self.fmt.ref_str(recorder::VarRef,\n+                                 field.ident.span,\n+                                 Some(field_data.span),\n+                                 field_data.ref_id,\n+                                 field_data.scope);\n+\n+                self.visit_expr(&field.expr)\n+            }\n         }\n+\n         visit::walk_expr_opt(self, base)\n     }\n \n@@ -1174,7 +1135,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_impl(item,\n                                   ty_params,\n                                   trait_ref,\n-                                  &**typ,\n+                                  &typ,\n                                   impl_items)\n             }\n             ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n@@ -1296,15 +1257,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&sub_ex);\n \n-                let field_data = self.save_ctxt.get_expr_data(ex);\n-                if let super::Data::VariableRefData(field_data) = field_data {\n+                if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n+                    down_cast_data!(field_data, VariableRefData, self, ex.span);\n                     self.fmt.ref_str(recorder::VarRef,\n                                      ex.span,\n                                      Some(field_data.span),\n                                      field_data.ref_id,\n                                      field_data.scope);\n-                } else {\n-                    self.sess.span_bug(ex.span, \"expected VariableRefData\");\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {"}, {"sha": "380d6b0ee6578a4264eda8fe48cf6c9601194bba", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 176, "deletions": 7, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=4f3c19f547d62c3c2824979ea453a6558d6c873e", "patch": "@@ -10,6 +10,7 @@\n \n use session::Session;\n use middle::ty;\n+use middle::def;\n \n use std::env;\n use std::fs::{self, File};\n@@ -23,9 +24,11 @@ use syntax::parse::token::{self, get_ident, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n+use util::ppaux;\n \n use self::span_utils::SpanUtils;\n \n+\n mod span_utils;\n mod recorder;\n \n@@ -44,22 +47,28 @@ pub struct CrateData {\n \n /// Data for any entity in the Rust language. The actual data contained varied\n /// with the kind of entity being queried. See the nested structs for details.\n+#[derive(Debug)]\n pub enum Data {\n     /// Data for all kinds of functions and methods.\n     FunctionData(FunctionData),\n-    /// Data for local and global variables (consts and statics).\n+    /// Data for local and global variables (consts and statics), and fields.\n     VariableData(VariableData),\n     /// Data for modules.\n     ModData(ModData),\n     /// Data for Enums.\n     EnumData(EnumData),\n+    /// Data for impls.\n+    ImplData(ImplData),\n \n     /// Data for the use of some variable (e.g., the use of a local variable, which\n     /// will refere to that variables declaration).\n     VariableRefData(VariableRefData),\n+    /// Data for a reference to a type or trait.\n+    TypeRefData(TypeRefData),\n }\n \n /// Data for all kinds of functions and methods.\n+#[derive(Debug)]\n pub struct FunctionData {\n     pub id: NodeId,\n     pub name: String,\n@@ -70,6 +79,7 @@ pub struct FunctionData {\n }\n \n /// Data for local and global variables (consts and statics).\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: NodeId,\n     pub name: String,\n@@ -81,6 +91,7 @@ pub struct VariableData {\n }\n \n /// Data for modules.\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: NodeId,\n     pub name: String,\n@@ -91,22 +102,45 @@ pub struct ModData {\n }\n \n /// Data for enum declarations.\n+#[derive(Debug)]\n pub struct EnumData {\n     pub id: NodeId,\n     pub value: String,\n     pub qualname: String,\n     pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+#[derive(Debug)]\n+pub struct ImplData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    // FIXME: I'm not really sure inline data is the best way to do this. Seems\n+    // OK in this case, but generalising leads to returning chunks of AST, which\n+    // feels wrong.\n+    pub trait_ref: Option<TypeRefData>,\n+    pub self_ref: Option<TypeRefData>,\n }\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refere to that variables declaration (by ref_id)).\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n+/// Data for a reference to a type or trait.\n+#[derive(Debug)]\n+pub struct TypeRefData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(sess: &'l Session,\n@@ -209,16 +243,93 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n                 })\n             },\n+            ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n+                let mut type_data = None;\n+                let sub_span;\n+\n+                let parent = self.analysis.ty_cx.map.get_parent(item.id);\n+\n+                match typ.node {\n+                    // Common case impl for a struct or something basic.\n+                    ast::TyPath(None, ref path) => {\n+                        sub_span = self.span_utils.sub_span_for_type_name(path.span);\n+                        type_data = self.lookup_ref_id(typ.id).map(|id| TypeRefData {\n+                            span: sub_span.unwrap(),\n+                            scope: parent,\n+                            ref_id: id,\n+                        });\n+                    },\n+                    _ => {\n+                        // Less useful case, impl for a compound type.\n+                        sub_span = self.span_utils.sub_span_for_type_name(typ.span);\n+                    }\n+                }\n+\n+                let trait_data =\n+                    trait_ref.as_ref().and_then(|tr| self.get_trait_ref_data(tr, parent));\n+\n+                Data::ImplData(ImplData {\n+                    id: item.id,\n+                    span: sub_span.unwrap(),\n+                    scope: parent,\n+                    trait_ref: trait_data,\n+                    self_ref: type_data,\n+                })\n+            }\n             _ => {\n                 // FIXME\n                 unimplemented!();\n             }\n         }\n     }\n \n-    pub fn get_expr_data(&self, expr: &ast::Expr) -> Data {\n+    // FIXME: we ought to be able to get the parent id ourselves, but we can't\n+    // for now.\n+    pub fn get_field_data(&self, field: &ast::StructField, parent: NodeId) -> Option<Data> {\n+        match field.node.kind {\n+            ast::NamedField(ident, _) => {\n+                let name = get_ident(ident);\n+                let qualname = format!(\"::{}::{}\",\n+                                       self.analysis.ty_cx.map.path_to_string(parent),\n+                                       name);\n+                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n+                                              *self.analysis.ty_cx.node_types()\n+                                                  .get(&field.node.id).unwrap());\n+                let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n+                Some(Data::VariableData(VariableData {\n+                    id: field.node.id,\n+                    name: get_ident(ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: parent,\n+                    value: \"\".to_owned(),\n+                    type_value: typ,\n+                }))\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    // FIXME: we ought to be able to get the parent id ourselves, but we can't\n+    // for now.\n+    pub fn get_trait_ref_data(&self,\n+                              trait_ref: &ast::TraitRef,\n+                              parent: NodeId)\n+                              -> Option<TypeRefData> {\n+        self.lookup_ref_id(trait_ref.ref_id).map(|def_id| {\n+            let sub_span = self.span_utils.sub_span_for_type_name(trait_ref.path.span);\n+            TypeRefData {\n+                span: sub_span.unwrap(),\n+                scope: parent,\n+                ref_id: def_id,\n+            }\n+        })\n+    }\n+\n+    pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n                 let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &sub_ex).sty;\n@@ -228,12 +339,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         for f in &fields {\n                             if f.name == ident.node.name {\n                                 let sub_span = self.span_utils.span_for_last_ident(expr.span);\n-                                return Data::VariableRefData(VariableRefData {\n+                                return Some(Data::VariableRefData(VariableRefData {\n                                     name: get_ident(ident.node).to_string(),\n                                     span: sub_span.unwrap(),\n                                     scope: self.analysis.ty_cx.map.get_parent(expr.id),\n                                     ref_id: f.id,\n-                                });\n+                                }));\n                             }\n                         }\n \n@@ -242,8 +353,29 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                                     &get_ident(ident.node),\n                                                     ty))\n                     }\n-                    _ => self.sess.span_bug(expr.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)),\n+                    _ => {\n+                        debug!(\"Expected struct type, found {:?}\", ty);\n+                        None\n+                    }\n+                }\n+            }\n+            ast::ExprStruct(ref path, _, _) => {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, expr).sty;\n+                match *ty {\n+                    ty::TyStruct(def_id, _) => {\n+                        let sub_span = self.span_utils.span_for_last_ident(path.span);\n+                        Some(Data::TypeRefData(TypeRefData {\n+                            span: sub_span.unwrap(),\n+                            scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                            ref_id: def_id,\n+                        }))\n+                    }\n+                    _ => {\n+                        // FIXME ty could legitimately be a TyEnum, but then we will fail\n+                        // later if we try to look up the fields.\n+                        debug!(\"expected TyStruct, found {:?}\", ty);\n+                        None\n+                    }\n                 }\n             }\n             _ => {\n@@ -253,10 +385,47 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    pub fn get_field_ref_data(&self,\n+                              field_ref: &ast::Field,\n+                              struct_id: DefId,\n+                              parent: NodeId)\n+                              -> VariableRefData {\n+        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_id);\n+        let field_name = get_ident(field_ref.ident.node).to_string();\n+        for f in &fields {\n+            if f.name == field_ref.ident.node.name {\n+                // We don't really need a sub-span here, but no harm done\n+                let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n+                return VariableRefData {\n+                    name: field_name,\n+                    span: sub_span.unwrap(),\n+                    scope: parent,\n+                    ref_id: f.id,\n+                };\n+            }\n+        }\n+\n+        self.sess.span_bug(field_ref.span,\n+                           &format!(\"Couldn't find field {}\", field_name));\n+    }\n+\n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n         // FIXME\n         unimplemented!();\n     }\n+\n+    fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n+        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id));\n+        }\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id()),\n+        }\n+    }\n+\n }\n \n // An AST visitor for collecting paths from patterns.\n@@ -284,7 +453,7 @@ impl<'v> Visitor<'v> for PathCollector {\n                 self.collected_paths.push((p.id,\n                                            path.clone(),\n                                            ast::MutMutable,\n-                                           recorder::StructRef));\n+                                           recorder::TypeRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {"}, {"sha": "c53fa22a2c196d9ab21c30c56f034b5871dbcef0", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3c19f547d62c3c2824979ea453a6558d6c873e/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=4f3c19f547d62c3c2824979ea453a6558d6c873e", "patch": "@@ -89,7 +89,6 @@ pub enum Row {\n     ModRef,\n     VarRef,\n     TypeRef,\n-    StructRef,\n     FnRef,\n }\n \n@@ -150,9 +149,6 @@ impl<'a> FmtStrs<'a> {\n             TypeRef => (\"type_ref\",\n                         vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n                         true, true),\n-            StructRef => (\"struct_ref\",\n-                          vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n-                          true, true),\n             FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true)\n         }\n     }"}]}