{"sha": "00dac20e017d321b9999b04fd6d3132c4a21a388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZGFjMjBlMDE3ZDMyMWI5OTk5YjA0ZmQ2ZDMxMzJjNGEyMWEzODg=", "commit": {"author": {"name": "Bryan Drewery", "email": "bryan@shatow.net", "date": "2018-03-19T20:11:55Z"}, "committer": {"name": "Bryan Drewery", "email": "bryan@shatow.net", "date": "2018-03-19T20:11:55Z"}, "message": "Merge branch 'update-beta-freebsd' into freebsd-posix-spawn", "tree": {"sha": "4a3b8da2afb957823317ffc83a8b0532934e46d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a3b8da2afb957823317ffc83a8b0532934e46d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00dac20e017d321b9999b04fd6d3132c4a21a388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00dac20e017d321b9999b04fd6d3132c4a21a388", "html_url": "https://github.com/rust-lang/rust/commit/00dac20e017d321b9999b04fd6d3132c4a21a388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00dac20e017d321b9999b04fd6d3132c4a21a388/comments", "author": {"login": "bdrewery", "id": 33693, "node_id": "MDQ6VXNlcjMzNjkz", "avatar_url": "https://avatars.githubusercontent.com/u/33693?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bdrewery", "html_url": "https://github.com/bdrewery", "followers_url": "https://api.github.com/users/bdrewery/followers", "following_url": "https://api.github.com/users/bdrewery/following{/other_user}", "gists_url": "https://api.github.com/users/bdrewery/gists{/gist_id}", "starred_url": "https://api.github.com/users/bdrewery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bdrewery/subscriptions", "organizations_url": "https://api.github.com/users/bdrewery/orgs", "repos_url": "https://api.github.com/users/bdrewery/repos", "events_url": "https://api.github.com/users/bdrewery/events{/privacy}", "received_events_url": "https://api.github.com/users/bdrewery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bdrewery", "id": 33693, "node_id": "MDQ6VXNlcjMzNjkz", "avatar_url": "https://avatars.githubusercontent.com/u/33693?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bdrewery", "html_url": "https://github.com/bdrewery", "followers_url": "https://api.github.com/users/bdrewery/followers", "following_url": "https://api.github.com/users/bdrewery/following{/other_user}", "gists_url": "https://api.github.com/users/bdrewery/gists{/gist_id}", "starred_url": "https://api.github.com/users/bdrewery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bdrewery/subscriptions", "organizations_url": "https://api.github.com/users/bdrewery/orgs", "repos_url": "https://api.github.com/users/bdrewery/repos", "events_url": "https://api.github.com/users/bdrewery/events{/privacy}", "received_events_url": "https://api.github.com/users/bdrewery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d740083fc8981ee933dc48a6b3dcee21b82c993e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d740083fc8981ee933dc48a6b3dcee21b82c993e", "html_url": "https://github.com/rust-lang/rust/commit/d740083fc8981ee933dc48a6b3dcee21b82c993e"}, {"sha": "57c74c39813c4668d3be5a0c244758f59ab32d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c74c39813c4668d3be5a0c244758f59ab32d9a", "html_url": "https://github.com/rust-lang/rust/commit/57c74c39813c4668d3be5a0c244758f59ab32d9a"}], "stats": {"total": 78862, "additions": 46268, "deletions": 32594}, "files": [{"sha": "55f586389b11766c587af558c66a716cdced1fb9", "filename": ".gitmodules", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -41,12 +41,15 @@\n [submodule \"src/dlmalloc\"]\n \tpath = src/dlmalloc\n \turl = https://github.com/alexcrichton/dlmalloc-rs.git\n-[submodule \"src/binaryen\"]\n-\tpath = src/binaryen\n-\turl = https://github.com/alexcrichton/binaryen.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example\n [submodule \"src/llvm-emscripten\"]\n \tpath = src/llvm-emscripten\n \turl = https://github.com/rust-lang/llvm\n+[submodule \"src/stdsimd\"]\n+\tpath = src/stdsimd\n+\turl = https://github.com/rust-lang-nursery/stdsimd\n+[submodule \"src/tools/lld\"]\n+\tpath = src/tools/lld\n+\turl = https://github.com/rust-lang/lld.git"}, {"sha": "3ff9e94ee5410d259b65120b13f7ba0f7ede9784", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -95,9 +95,9 @@ Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtk\n Ilyong Cho <ilyoan@gmail.com>\n Ivan Ivaschenko <defuz.net@gmail.com>\n J. J. Weber <jjweber@gmail.com>\n-Jakub Bukaj <jakub@jakub.cc>\n-Jakub Bukaj <jakub@jakub.cc> <jakubw@jakubw.net>\n-Jakub Bukaj <jakub@jakub.cc> Jakub Bukaj <jakub.bukaj@yahoo.com>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub@jakub.cc>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakubw@jakubw.net>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>"}, {"sha": "41ea0c9afa87cc97c93973e6f3ad5109031393fc", "filename": ".travis.yml", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -35,7 +35,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # macOS builders. These are placed near the beginning because they are very\n@@ -56,7 +56,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode9.2\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     - env: >\n@@ -70,7 +70,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode9.2\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and\n@@ -81,7 +81,7 @@ matrix:\n     # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-extended --enable-profiler --enable-emscripten\"\n+        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -90,12 +90,12 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers --enable-profiler --enable-emscripten\"\n+        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -104,7 +104,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # Linux builders, remaining docker images\n@@ -188,7 +188,7 @@ matrix:\n       script:\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n         . src/ci/docker/x86_64-gnu-tools/repo.sh;\n-        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\"\n+        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\";\n \n env:\n   global:\n@@ -275,11 +275,12 @@ after_failure:\n   - ls -lat $HOME/Library/Logs/DiagnosticReports/\n   - find $HOME/Library/Logs/DiagnosticReports\n       -type f\n+      -name '*.crash'\n       -not -name '*.stage2-*.crash'\n       -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n       -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n       -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\;\n+      -exec echo travis_fold\":\"end:crashlog \\; || true\n \n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened"}, {"sha": "d70b2b52aca1b136d70617a03d04b5c7bccd9969", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -11,9 +11,9 @@ A version of this document [can be found online](https://www.rust-lang.org/condu\n * Please be kind and courteous. There's no need to be mean or rude.\n * Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n * Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n * Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n \n ## Moderation\n "}, {"sha": "2b389888e5185eb46675af9eb3a4a63cadeb04b5", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -26,10 +26,10 @@ As a reminder, all contributors are expected to follow our [Code of Conduct][coc\n ## Feature Requests\n [feature-requests]: #feature-requests\n \n-To request a change to the way that the Rust language works, please open an\n-issue in the [RFCs repository](https://github.com/rust-lang/rfcs/issues/new)\n-rather than this one. New features and other significant language changes\n-must go through the RFC process.\n+To request a change to the way the Rust language works, please head over\n+to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the \n+[README](https://github.com/rust-lang/rfcs/blob/master/README.md)\n+for instructions.\n \n ## Bug Reports\n [bug-reports]: #bug-reports\n@@ -623,6 +623,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* The [rustc guide] contains information about how various parts of the compiler work\n * [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n@@ -635,6 +636,7 @@ are:\n * **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n [gdfrustc]: http://manishearth.github.io/rust-internals-docs/rustc/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org"}, {"sha": "19ef96fae015c9f851c1c2eed143656bf6d57cdc", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -129,9 +129,6 @@ CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.\n python x.py build\n ```\n \n-If you are seeing build failure when compiling `rustc_binaryen`, make sure the path\n-length of the rust folder is not longer than 22 characters.\n-\n #### Specifying an ABI\n [specifying-an-abi]: #specifying-an-abi\n \n@@ -227,9 +224,13 @@ variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n Rust. And a good place to ask for help would be [#rust-beginners].\n \n+Also, the [rustc guide] might be a good place to start if you want to\n+find out how various parts of the compiler work.\n+\n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n \n ## License\n [license]: #license"}, {"sha": "45e1b4b90d6c75e91935bd726d4fda55986e3283", "filename": "appveyor.yml", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,12 +19,18 @@ environment:\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i686-pc-windows-msvc\n-    SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check-aux\n+    RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+  - MSYS_BITS: 64\n+    SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # MSVC tools tests\n@@ -47,7 +53,13 @@ environment:\n   # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test\n+    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+    MINGW_DIR: mingw32\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n@@ -61,29 +73,27 @@ environment:\n   # 32/64 bit MSVC and GNU deployment\n   - RUST_CONFIGURE_ARGS: >\n       --build=x86_64-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n-      --enable-emscripten\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n-      --enable-emscripten\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-extended --enable-emscripten\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n     SCRIPT: python x.py dist\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n   - MSYS_BITS: 64\n     SCRIPT: python x.py dist\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-extended --enable-emscripten\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64"}, {"sha": "aec5e5a0e2c800220da705d7101a96de198d8491", "filename": "config.toml.example", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -118,6 +118,10 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# Update submodules only when the checked out commit in the submodules differs\n+# from what is committed in the main rustc repo.\n+#fast-submodules = true\n+\n # The path to (or name of) the GDB executable to use. This is only used for\n # executing the debuginfo test suite.\n #gdb = \"gdb\"\n@@ -321,11 +325,18 @@\n # bootstrap)\n #codegen-backends = [\"llvm\"]\n \n+# This is the name of the directory in which codegen backends will get installed\n+#codegen-backends-dir = \"codegen-backends\"\n+\n # Flag indicating whether `libstd` calls an imported function to handle basic IO\n # when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n # target, as without this option the test output will not be captured.\n #wasm-syscall = false\n \n+# Indicates whether LLD will be compiled and made available in the sysroot for\n+# rustc to execute.\n+#lld = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "c82588e41125c5b822d89e44865bcac7974f6da3", "filename": "src/Cargo.lock", "status": "modified", "additions": 564, "deletions": 614, "changes": 1178, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "814c054c51e41eaff3c6b155110474f8a252c3e8", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -72,3 +72,4 @@ cargo = { path = \"tools/cargo\" }\n # RLS depends on `rustfmt` from crates.io, so we put this in a `[patch]` section\n # for crates.io\n rustfmt-nightly = { path = \"tools/rustfmt\" }\n+clippy_lints = { path = \"tools/clippy/clippy_lints\" }"}, {"sha": "690ab674c64ebd96bf1700994b0097f506c58955", "filename": "src/README.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -0,0 +1,15 @@\n+This directory contains the source code of the rust project, including:\n+- `rustc` and its tests\n+- `libstd`\n+- Various submodules for tools, like rustdoc, rls, etc.\n+\n+For more information on how various parts of the compiler work, see the [rustc guide].\n+\n+Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/maps\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n+- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html"}, {"sha": "17841e155edf858c8ea7802dd5f5ecbef54b989f", "filename": "src/binaryen", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1 +0,0 @@\n-Subproject commit 17841e155edf858c8ea7802dd5f5ecbef54b989f"}, {"sha": "4be16475590f4fdf946019953785b881a141e607", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -61,6 +61,11 @@ fn main() {\n         args.remove(n);\n     }\n \n+    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n+        args.push(\"--error-format\".into());\n+        args.push(s);\n+    }\n+\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)\n@@ -90,7 +95,7 @@ fn main() {\n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n     let mut dylib_path = bootstrap::util::dylib_path();\n-    dylib_path.insert(0, PathBuf::from(libdir));\n+    dylib_path.insert(0, PathBuf::from(&libdir));\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n@@ -102,7 +107,7 @@ fn main() {\n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(sysroot);\n+        cmd.arg(\"--sysroot\").arg(&sysroot);\n \n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n@@ -170,9 +175,6 @@ fn main() {\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n-        if env::var(\"RUSTC_THINLTO\").is_ok() {\n-            cmd.arg(\"-Ccodegen-units=16\").arg(\"-Zthinlto\");\n-        }\n \n         // Emit save-analysis info.\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n@@ -219,7 +221,7 @@ fn main() {\n                 // flesh out rpath support more fully in the future.\n                 cmd.arg(\"-Z\").arg(\"osx-rpath-install-name\");\n                 Some(\"-Wl,-rpath,@loader_path/../lib\")\n-            } else if !target.contains(\"windows\") {\n+            } else if !target.contains(\"windows\") && !target.contains(\"wasm32\") {\n                 Some(\"-Wl,-rpath,$ORIGIN/../lib\")\n             } else {\n                 None\n@@ -275,6 +277,8 @@ fn main() {\n \n     if verbose > 1 {\n         eprintln!(\"rustc command: {:?}\", cmd);\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n+        eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n     // Actually run the compiler!"}, {"sha": "b55a133501d8eefc126966df971bd848c830179b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -294,7 +294,7 @@ def default_build_triple():\n             raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n         # only the n64 ABI is supported, indicate it\n         ostype += 'abi64'\n-    elif cputype == 'sparcv9' or cputype == 'sparc64':\n+    elif cputype == 'sparc' or cputype == 'sparcv9' or cputype == 'sparc64':\n         pass\n     else:\n         err = \"unknown cpu type: {}\".format(cputype)\n@@ -314,7 +314,6 @@ def __init__(self):\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n         self.config_toml = ''\n-        self.printed = False\n         self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n@@ -336,7 +335,6 @@ def download_stage0(self):\n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or\n                  self.program_out_of_date(self.rustc_stamp())):\n-            self.print_what_bootstrap_means()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             filename = \"rust-std-{}-{}.tar.gz\".format(\n@@ -351,10 +349,17 @@ def download_stage0(self):\n             with open(self.rustc_stamp(), 'w') as rust_stamp:\n                 rust_stamp.write(self.date)\n \n+            # This is required so that we don't mix incompatible MinGW\n+            # libraries/binaries that are included in rust-std with\n+            # the system MinGW ones.\n+            if \"pc-windows-gnu\" in self.build:\n+                filename = \"rust-mingw-{}-{}.tar.gz\".format(\n+                    rustc_channel, self.build)\n+                self._download_stage0_helper(filename, \"rust-mingw\")\n+\n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or\n                  self.program_out_of_date(self.cargo_stamp())):\n-            self.print_what_bootstrap_means()\n             filename = \"cargo-{}-{}.tar.gz\".format(cargo_channel, self.build)\n             self._download_stage0_helper(filename, \"cargo\")\n             self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n@@ -555,23 +560,6 @@ def exe_suffix():\n             return '.exe'\n         return ''\n \n-    def print_what_bootstrap_means(self):\n-        \"\"\"Prints more information about the build system\"\"\"\n-        if hasattr(self, 'printed'):\n-            return\n-        self.printed = True\n-        if os.path.exists(self.bootstrap_binary()):\n-            return\n-        if '--help' not in sys.argv or len(sys.argv) == 1:\n-            return\n-\n-        print('info: the build system for Rust is written in Rust, so this')\n-        print('      script is now going to download a stage0 rust compiler')\n-        print('      and then compile the build system itself')\n-        print('')\n-        print('info: in the meantime you can read more about rustbuild at')\n-        print('      src/bootstrap/README.md before the download finishes')\n-\n     def bootstrap_binary(self):\n         \"\"\"Return the path of the boostrap binary\n \n@@ -585,7 +573,6 @@ def bootstrap_binary(self):\n \n     def build_bootstrap(self):\n         \"\"\"Build bootstrap\"\"\"\n-        self.print_what_bootstrap_means()\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n@@ -610,10 +597,8 @@ def build_bootstrap(self):\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        if self.verbose:\n+        for _ in range(1, self.verbose):\n             args.append(\"--verbose\")\n-            if self.verbose > 1:\n-                args.append(\"--verbose\")\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -627,20 +612,55 @@ def build_triple(self):\n             return config\n         return default_build_triple()\n \n+    def check_submodule(self, module, slow_submodules):\n+        if not slow_submodules:\n+            checked_out = subprocess.Popen([\"git\", \"rev-parse\", \"HEAD\"],\n+                                           cwd=os.path.join(self.rust_root, module),\n+                                           stdout=subprocess.PIPE)\n+            return checked_out\n+        else:\n+            return None\n+\n+    def update_submodule(self, module, checked_out, recorded_submodules):\n+        module_path = os.path.join(self.rust_root, module)\n+\n+        if checked_out != None:\n+            default_encoding = sys.getdefaultencoding()\n+            checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n+            if recorded_submodules[module] == checked_out:\n+                return\n+\n+        print(\"Updating submodule\", module)\n+\n+        run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"update\",\n+            \"--init\", \"--recursive\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"reset\", \"-q\", \"--hard\"],\n+            cwd=module_path, verbose=self.verbose)\n+        run([\"git\", \"clean\", \"-qdfx\"],\n+            cwd=module_path, verbose=self.verbose)\n+\n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n-        print('Updating submodules')\n+        slow_submodules = self.get_toml('fast-submodule') == \"false\"\n+        start_time = time()\n+        if slow_submodules:\n+            print('Unconditionally updating all submodules')\n+        else:\n+            print('Updating only changed submodules')\n         default_encoding = sys.getdefaultencoding()\n-        run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root, verbose=self.verbose)\n         submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n             [\"git\", \"config\", \"--file\",\n              os.path.join(self.rust_root, \".gitmodules\"),\n              \"--get-regexp\", \"path\"]\n         ).decode(default_encoding).splitlines()]\n         filtered_submodules = []\n+        submodules_names = []\n         for module in submodules:\n             if module.endswith(\"llvm\"):\n                 if self.get_toml('llvm-config'):\n@@ -654,29 +674,44 @@ def update_submodules(self):\n                     continue\n                 if self.get_toml('jemalloc'):\n                     continue\n-            filtered_submodules.append(module)\n-        run([\"git\", \"submodule\", \"update\",\n-             \"--init\", \"--recursive\"] + filtered_submodules,\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"reset\", \"-q\", \"--hard\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"clean\", \"-qdfx\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n+            if module.endswith(\"lld\"):\n+                config = self.get_toml('lld')\n+                if config is None or config == 'false':\n+                    continue\n+            check = self.check_submodule(module, slow_submodules)\n+            filtered_submodules.append((module, check))\n+            submodules_names.append(module)\n+        recorded = subprocess.Popen([\"git\", \"ls-tree\", \"HEAD\"] + submodules_names,\n+                                    cwd=self.rust_root, stdout=subprocess.PIPE)\n+        recorded = recorded.communicate()[0].decode(default_encoding).strip().splitlines()\n+        recorded_submodules = {}\n+        for data in recorded:\n+            data = data.split()\n+            recorded_submodules[data[3]] = data[2]\n+        for module in filtered_submodules:\n+            self.update_submodule(module[0], module[1], recorded_submodules)\n+        print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n         self._download_url = 'https://dev-static.rust-lang.org'\n \n \n-def bootstrap():\n+def bootstrap(help_triggered):\n     \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n+\n+    # If the user is asking for help, let them know that the whole download-and-build\n+    # process has to happen before anything is printed out.\n+    if help_triggered:\n+        print(\"info: Downloading and building bootstrap before processing --help\")\n+        print(\"      command. See src/bootstrap/README.md for help with common\")\n+        print(\"      commands.\")\n+\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n     parser.add_argument('--clean', action='store_true')\n-    parser.add_argument('-v', '--verbose', action='store_true')\n+    parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     args = [a for a in sys.argv if a != '-h' and a != '--help']\n     args, _ = parser.parse_known_args(args)\n@@ -692,10 +727,9 @@ def bootstrap():\n     except (OSError, IOError):\n         pass\n \n-    if '\\nverbose = 2' in build.config_toml:\n-        build.verbose = 2\n-    elif '\\nverbose = 1' in build.config_toml:\n-        build.verbose = 1\n+    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n+    if match is not None:\n+        build.verbose = max(build.verbose, int(match.group(1)))\n \n     build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n \n@@ -708,7 +742,7 @@ def bootstrap():\n             print('      and so in order to preserve your $HOME this will now')\n             print('      use vendored sources by default. Note that if this')\n             print('      does not work you should run a normal build first')\n-            print('      before running a command like `sudo make install`')\n+            print('      before running a command like `sudo ./x.py install`')\n \n     if build.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n@@ -734,7 +768,10 @@ def bootstrap():\n     if 'dev' in data:\n         build.set_dev_environment()\n \n-    build.update_submodules()\n+    # No help text depends on submodules. This check saves ~1 minute of git commands, even if\n+    # all the submodules are present and downloaded!\n+    if not help_triggered:\n+        build.update_submodules()\n \n     # Fetch/build the bootstrap\n     build.build = args.build or build.build_triple()\n@@ -760,7 +797,7 @@ def main():\n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n-        bootstrap()\n+        bootstrap(help_triggered)\n         if not help_triggered:\n             print(\"Build completed successfully in {}\".format(\n                 format_build_time(time() - start_time)))"}, {"sha": "675d3dd437eef9deb3cc60d7956b038628c81e05", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -60,12 +60,6 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Run this rule for all targets, but only with the native host.\n-    const ONLY_BUILD_TARGETS: bool = false;\n-\n-    /// Only run this step with the build triple as host and target.\n-    const ONLY_BUILD: bool = false;\n-\n     /// Primary function to execute this rule. Can call `builder.ensure(...)`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n@@ -101,8 +95,6 @@ pub struct RunConfig<'a> {\n struct StepDescription {\n     default: bool,\n     only_hosts: bool,\n-    only_build_targets: bool,\n-    only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n     name: &'static str,\n@@ -138,8 +130,6 @@ impl StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n             only_hosts: S::ONLY_HOSTS,\n-            only_build_targets: S::ONLY_BUILD_TARGETS,\n-            only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n             name: unsafe { ::std::intrinsics::type_name::<S>() },\n@@ -155,18 +145,12 @@ impl StepDescription {\n                 self.name, builder.config.exclude);\n         }\n         let build = builder.build;\n-        let hosts = if self.only_build_targets || self.only_build {\n-            build.build_triple()\n-        } else {\n-            &build.hosts\n-        };\n+        let hosts = &build.hosts;\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if build.config.run_host_only {\n-                &[]\n-            } else if self.only_build {\n-                build.build_triple()\n+            if !build.config.run_host_only {\n+                return; // don't run anything\n             } else {\n                 &build.hosts\n             }\n@@ -231,7 +215,7 @@ pub struct ShouldRun<'a> {\n     paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n-    // it's run. Generally something like compiler docs being enabled.\n+    // its run. Generally something like compiler docs being enabled.\n     is_really_default: bool,\n }\n \n@@ -316,7 +300,7 @@ impl<'a> Builder<'a> {\n                 tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n-                native::Llvm, tool::Rustfmt, tool::Miri),\n+                native::Llvm, tool::Rustfmt, tool::Miri, native::Lld),\n             Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n             Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n                 test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n@@ -325,8 +309,10 @@ impl<'a> Builder<'a> {\n                 test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n                 test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n                 test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n-                test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n-                test::Cargo, test::Rls, test::Docs, test::ErrorIndex, test::Distcheck,\n+                test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n+                test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+                test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n+                test::TheBook, test::UnstableBook,\n                 test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n@@ -444,10 +430,11 @@ impl<'a> Builder<'a> {\n \n             fn run(self, builder: &Builder) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n-                let lib = if compiler.stage >= 1 && builder.build.config.libdir.is_some() {\n-                    builder.build.config.libdir.clone().unwrap()\n+                let config = &builder.build.config;\n+                let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {\n+                    builder.build.config.libdir_relative().unwrap()\n                 } else {\n-                    PathBuf::from(\"lib\")\n+                    Path::new(\"lib\")\n                 };\n                 let sysroot = builder.sysroot(self.compiler).join(lib)\n                     .join(\"rustlib\").join(self.target).join(\"lib\");\n@@ -461,7 +448,7 @@ impl<'a> Builder<'a> {\n \n     pub fn sysroot_codegen_backends(&self, compiler: Compiler) -> PathBuf {\n         self.sysroot_libdir(compiler, compiler.host)\n-            .with_file_name(\"codegen-backends\")\n+            .with_file_name(self.build.config.rust_codegen_backends_dir.clone())\n     }\n \n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n@@ -598,6 +585,9 @@ impl<'a> Builder<'a> {\n         if let Some(target_linker) = self.build.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n+        if let Some(ref error_format) = self.config.rustc_error_format {\n+            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n+        }\n         if cmd != \"build\" && cmd != \"check\" {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n         }\n@@ -682,9 +672,25 @@ impl<'a> Builder<'a> {\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            let cc = self.cc(target);\n-            cargo.env(format!(\"CC_{}\", target), cc)\n-                 .env(\"CC\", cc);\n+            let ccache = self.config.ccache.as_ref();\n+            let ccacheify = |s: &Path| {\n+                let ccache = match ccache {\n+                    Some(ref s) => s,\n+                    None => return s.display().to_string(),\n+                };\n+                // FIXME: the cc-rs crate only recognizes the literal strings\n+                // `ccache` and `sccache` when doing caching compilations, so we\n+                // mirror that here. It should probably be fixed upstream to\n+                // accept a new env var or otherwise work with custom ccache\n+                // vars.\n+                match &ccache[..] {\n+                    \"ccache\" | \"sccache\" => format!(\"{} {}\", ccache, s.display()),\n+                    _ => s.display().to_string(),\n+                }\n+            };\n+            let cc = ccacheify(&self.cc(target));\n+            cargo.env(format!(\"CC_{}\", target), &cc)\n+                 .env(\"CC\", &cc);\n \n             let cflags = self.cflags(target).join(\" \");\n             cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n@@ -699,8 +705,9 @@ impl<'a> Builder<'a> {\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                cargo.env(format!(\"CXX_{}\", target), cxx)\n-                     .env(\"CXX\", cxx)\n+                let cxx = ccacheify(&cxx);\n+                cargo.env(format!(\"CXX_{}\", target), &cxx)\n+                     .env(\"CXX\", &cxx)\n                      .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n                      .env(\"CXXFLAGS\", cflags);\n             }\n@@ -752,9 +759,11 @@ impl<'a> Builder<'a> {\n         // be resolved because MinGW has the import library. The downside is we\n         // don't get newer functions from Windows, but we don't use any of them\n         // anyway.\n-        cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        if mode != Mode::Tool {\n+            cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        }\n \n-        if self.is_very_verbose() {\n+        for _ in 1..self.verbosity {\n             cargo.arg(\"-v\");\n         }\n \n@@ -769,17 +778,6 @@ impl<'a> Builder<'a> {\n             if cmd != \"bench\" {\n                 cargo.arg(\"--release\");\n             }\n-\n-            if self.config.rust_codegen_units.is_none() &&\n-               self.build.is_rust_llvm(compiler.host) &&\n-               self.config.rust_thinlto {\n-                cargo.env(\"RUSTC_THINLTO\", \"1\");\n-            } else if self.config.rust_codegen_units.is_none() {\n-                // Generally, if ThinLTO has been disabled for some reason, we\n-                // want to set the codegen units to 1. However, we shouldn't do\n-                // this if the option was specifically set by the user.\n-                cargo.env(\"RUSTC_CODEGEN_UNITS\", \"1\");\n-            }\n         }\n \n         if self.config.locked_deps {"}, {"sha": "8f393a4c573716e38eecc660f4a412a1a0ed1a1c", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -77,8 +77,11 @@ pub fn find(build: &mut Build) {\n                                .collect::<HashSet<_>>();\n     for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n+        if target.contains(\"msvc\") {\n+            cfg.static_crt(true);\n+        }\n \n         let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n@@ -106,7 +109,7 @@ pub fn find(build: &mut Build) {\n     let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n     for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {"}, {"sha": "72841cb0616c148db52831f38718c50e97e7af6d", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.25.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.26.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "33bcfaa80ca319185f2b61f83319c67de922e6c8", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -46,7 +46,7 @@ impl Step for Std {\n         let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n-        std_cargo(build, &compiler, target, &mut cargo);\n+        std_cargo(builder, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),"}, {"sha": "86263c8fa07330f7858557de10d4f4cb7ec4e4f0", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -105,7 +105,7 @@ impl Step for Std {\n         let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n-        std_cargo(build, &compiler, target, &mut cargo);\n+        std_cargo(builder, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n@@ -135,7 +135,7 @@ fn copy_musl_third_party_objects(build: &Build,\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(build: &Build,\n+pub fn std_cargo(build: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n@@ -162,7 +162,11 @@ pub fn std_cargo(build: &Build,\n         // missing\n         // We also only build the runtimes when --enable-sanitizers (or its\n         // config.toml equivalent) is used\n-        cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n+        let llvm_config = build.ensure(native::Llvm {\n+            target: build.config.build,\n+            emscripten: false,\n+        });\n+        cargo.env(\"LLVM_CONFIG\", llvm_config);\n     }\n \n     cargo.arg(\"--features\").arg(features)\n@@ -514,10 +518,10 @@ fn rustc_cargo_env(build: &Build, cargo: &mut Command) {\n     cargo.env(\"CFG_RELEASE\", build.rust_release())\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n+         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default())\n+         .env(\"CFG_CODEGEN_BACKENDS_DIR\", &build.config.rust_codegen_backends_dir);\n \n-    let libdir_relative =\n-        build.config.libdir.clone().unwrap_or(PathBuf::from(\"lib\"));\n+    let libdir_relative = build.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n     // If we're not building a compiler with debugging information then remove\n@@ -630,6 +634,8 @@ impl Step for CodegenBackend {\n             .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(build, &mut cargo);\n \n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+\n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n                 // Build LLVM for our target. This will implicitly build the\n@@ -643,7 +649,6 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n                 println!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n                          compiler.stage, &compiler.host, target, self.backend);\n \n@@ -746,6 +751,21 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     }\n }\n \n+fn copy_lld_to_sysroot(builder: &Builder,\n+                       target_compiler: Compiler,\n+                       lld_install_root: &Path) {\n+    let target = target_compiler.host;\n+\n+    let dst = builder.sysroot_libdir(target_compiler, target)\n+        .parent()\n+        .unwrap()\n+        .join(\"bin\");\n+    t!(fs::create_dir_all(&dst));\n+\n+    let exe = exe(\"lld\", &target);\n+    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+}\n+\n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n@@ -895,6 +915,14 @@ impl Step for Assemble {\n             }\n         }\n \n+        let lld_install = if build.config.lld_enabled && target_compiler.stage > 0 {\n+            Some(builder.ensure(native::Lld {\n+                target: target_compiler.host,\n+            }))\n+        } else {\n+            None\n+        };\n+\n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n         println!(\"Assembling stage{} compiler ({})\", stage, host);\n@@ -914,6 +942,9 @@ impl Step for Assemble {\n         copy_codegen_backends_to_sysroot(builder,\n                                          build_compiler,\n                                          target_compiler);\n+        if let Some(lld_install) = lld_install {\n+            copy_lld_to_sysroot(builder, target_compiler, &lld_install);\n+        }\n \n         // Link the compiler binary itself into place\n         let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n@@ -1008,6 +1039,10 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n             continue\n         };\n         if json[\"reason\"].as_str() != Some(\"compiler-artifact\") {\n+            if build.config.rustc_error_format.as_ref().map_or(false, |e| e == \"json\") {\n+                // most likely not a cargo message, so let's send it out as well\n+                println!(\"{}\", line);\n+            }\n             continue\n         }\n         for filename in json[\"filenames\"].as_array().unwrap() {"}, {"sha": "920a8ffc2fc860e1981fe053d451cb07f3c9f2dc", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -17,7 +17,7 @@ use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n@@ -57,6 +57,7 @@ pub struct Config {\n     pub profiler: bool,\n     pub ignore_git: bool,\n     pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n \n     pub run_host_only: bool,\n \n@@ -80,10 +81,11 @@ pub struct Config {\n     pub llvm_experimental_targets: String,\n     pub llvm_link_jobs: Option<u32>,\n \n+    pub lld_enabled: bool,\n+\n     // rust codegen options\n     pub rust_optimize: bool,\n     pub rust_codegen_units: Option<u32>,\n-    pub rust_thinlto: bool,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n@@ -95,6 +97,7 @@ pub struct Config {\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n     pub rust_codegen_backends: Vec<Interned<String>>,\n+    pub rust_codegen_backends_dir: String,\n \n     pub build: Interned<String>,\n     pub hosts: Vec<Interned<String>>,\n@@ -123,6 +126,7 @@ pub struct Config {\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<PathBuf>,\n     pub sysconfdir: Option<PathBuf>,\n+    pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n     pub bindir: Option<PathBuf>,\n     pub libdir: Option<PathBuf>,\n@@ -208,13 +212,13 @@ struct Build {\n struct Install {\n     prefix: Option<String>,\n     sysconfdir: Option<String>,\n+    datadir: Option<String>,\n     docdir: Option<String>,\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n \n     // standard paths, currently unused\n-    datadir: Option<String>,\n     infodir: Option<String>,\n     localstatedir: Option<String>,\n }\n@@ -265,7 +269,6 @@ impl Default for StringOrBool {\n struct Rust {\n     optimize: Option<bool>,\n     codegen_units: Option<u32>,\n-    thinlto: Option<bool>,\n     debug_assertions: Option<bool>,\n     debuginfo: Option<bool>,\n     debuginfo_lines: Option<bool>,\n@@ -288,7 +291,9 @@ struct Rust {\n     test_miri: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n+    codegen_backends_dir: Option<String>,\n     wasm_syscall: Option<bool>,\n+    lld: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -329,7 +334,9 @@ impl Config {\n         config.rust_dist_src = true;\n         config.test_miri = false;\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n+        config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n \n+        config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n         config.src = flags.src;\n@@ -339,7 +346,7 @@ impl Config {\n         config.keep_stage = flags.keep_stage;\n \n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = flags.host.is_empty() && !flags.target.is_empty();\n+        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n         let toml = file.map(|file| {\n             let mut f = t!(File::open(&file));\n@@ -411,6 +418,7 @@ impl Config {\n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n+            config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n             config.bindir = install.bindir.clone().map(PathBuf::from);\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n@@ -419,7 +427,6 @@ impl Config {\n \n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n-        let mut thinlto = None;\n         let mut llvm_assertions = None;\n         let mut debuginfo_lines = None;\n         let mut debuginfo_only_std = None;\n@@ -463,7 +470,6 @@ impl Config {\n             optimize = rust.optimize;\n             ignore_git = rust.ignore_git;\n             debug_jemalloc = rust.debug_jemalloc;\n-            thinlto = rust.thinlto;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n@@ -475,6 +481,7 @@ impl Config {\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n             set(&mut config.wasm_syscall, rust.wasm_syscall);\n+            set(&mut config.lld_enabled, rust.lld);\n             config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n@@ -486,6 +493,8 @@ impl Config {\n                     .collect();\n             }\n \n+            set(&mut config.rust_codegen_backends_dir, rust.codegen_backends_dir.clone());\n+\n             match rust.codegen_units {\n                 Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n                 Some(n) => config.rust_codegen_units = Some(n),\n@@ -548,7 +557,6 @@ impl Config {\n             \"stable\" | \"beta\" | \"nightly\" => true,\n             _ => false,\n         };\n-        config.rust_thinlto = thinlto.unwrap_or(true);\n         config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n         config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n \n@@ -564,6 +572,17 @@ impl Config {\n         config\n     }\n \n+    /// Try to find the relative path of `libdir`.\n+    pub fn libdir_relative(&self) -> Option<&Path> {\n+        let libdir = self.libdir.as_ref()?;\n+        if libdir.is_relative() {\n+            Some(libdir)\n+        } else {\n+            // Try to make it relative to the prefix.\n+            libdir.strip_prefix(self.prefix.as_ref()?).ok()\n+        }\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }"}, {"sha": "97da7cae07f7c6e9aa99810121584496f5484791", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -66,11 +66,11 @@ def v(*args):\n o(\"cargo-openssl-static\", \"build.openssl-static\", \"static openssl in cargo\")\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"emscripten\", None, \"compile the emscripten backend as well as LLVM\")\n+o(\"full-tools\", None, \"enable all tools\")\n \n # Optimization and debugging options. These may be overridden by the release\n # channel, etc.\n o(\"optimize\", \"rust.optimize\", \"build optimized rust code\")\n-o(\"thinlto\", \"rust.thinlto\", \"build Rust with ThinLTO enabled\")\n o(\"optimize-llvm\", \"llvm.optimize\", \"build optimized LLVM\")\n o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")\n@@ -326,6 +326,10 @@ def set(key, value):\n         set('build.target', value.split(','))\n     elif option.name == 'emscripten':\n         set('rust.codegen-backends', ['llvm', 'emscripten'])\n+    elif option.name == 'full-tools':\n+        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+        set('rust.lld', True)\n+        set('build.extended', True)\n     elif option.name == 'option-checking':\n         # this was handled above\n         pass"}, {"sha": "dcb572416594ebcd1857b4da268dd14eb56520f5", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -28,7 +28,7 @@ use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file};\n+use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -70,7 +70,6 @@ pub struct Docs {\n impl Step for Docs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/doc\")\n@@ -204,18 +203,22 @@ fn make_win_dist(\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n         \"libcomdlg32.a\",\n+        \"libcredui.a\",\n         \"libcrypt32.a\",\n+        \"libdbghelp.a\",\n         \"libgdi32.a\",\n         \"libimagehlp.a\",\n         \"libiphlpapi.a\",\n         \"libkernel32.a\",\n+        \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\",\n         \"libopengl32.a\",\n         \"libpsapi.a\",\n         \"librpcrt4.a\",\n+        \"libsecur32.a\",\n         \"libsetupapi.a\",\n         \"libshell32.a\",\n         \"libuser32.a\",\n@@ -226,8 +229,6 @@ fn make_win_dist(\n         \"libwinspool.a\",\n         \"libws2_32.a\",\n         \"libwsock32.a\",\n-        \"libdbghelp.a\",\n-        \"libmsimg32.a\",\n     ];\n \n     //Find mingw artifacts we want to bundle\n@@ -271,7 +272,6 @@ pub struct Mingw {\n impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -331,7 +331,6 @@ impl Step for Rustc {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/librustc\")\n@@ -443,6 +442,22 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(&backends_dst));\n             cp_r(&backends_src, &backends_dst);\n \n+            // Copy over lld if it's there\n+            if builder.config.lld_enabled {\n+                let exe = exe(\"lld\", &compiler.host);\n+                let src = builder.sysroot_libdir(compiler, host)\n+                    .parent()\n+                    .unwrap()\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                let dst = image.join(\"lib/rustlib\")\n+                    .join(&*host)\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                t!(fs::create_dir_all(&dst.parent().unwrap()));\n+                copy(&src, &dst);\n+            }\n+\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n             let man_src = build.src.join(\"src/doc/man\");\n@@ -545,15 +560,14 @@ pub struct Std {\n impl Step for Std {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/libstd\")\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n             target: run.target,\n         });\n     }\n@@ -590,7 +604,10 @@ impl Step for Std {\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n         cp_filtered(&src, &dst, &|path| {\n-            path.file_name().and_then(|s| s.to_str()) != Some(\"codegen-backends\")\n+            let name = path.file_name().and_then(|s| s.to_str());\n+            name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n+                name != Some(\"bin\")\n+\n         });\n \n         let mut cmd = rust_installer(builder);\n@@ -619,7 +636,6 @@ pub struct Analysis {\n impl Step for Analysis {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n@@ -628,7 +644,7 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n             target: run.target,\n         });\n     }\n@@ -736,8 +752,6 @@ impl Step for Src {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src\")\n@@ -791,6 +805,7 @@ impl Step for Src {\n             \"src/libterm\",\n             \"src/jemalloc\",\n             \"src/libprofiler_builtins\",\n+            \"src/stdsimd\",\n         ];\n         let std_src_dirs_exclude = [\n             \"src/libcompiler_builtins/compiler-rt/test\",\n@@ -831,8 +846,6 @@ impl Step for PlainSourceTarball {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n@@ -987,7 +1000,6 @@ pub struct Cargo {\n \n impl Step for Cargo {\n     type Output = PathBuf;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1075,7 +1087,6 @@ pub struct Rls {\n \n impl Step for Rls {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1111,7 +1122,7 @@ impl Step for Rls {\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n         install(&rls, &image.join(\"bin\"), 0o755);\n@@ -1157,7 +1168,6 @@ pub struct Rustfmt {\n \n impl Step for Rustfmt {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1191,11 +1201,11 @@ impl Step for Rustfmt {\n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Rustfmt, skipping dist\"); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n         install(&rustfmt, &image.join(\"bin\"), 0o755);\n@@ -1243,7 +1253,6 @@ pub struct Extended {\n impl Step for Extended {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1254,7 +1263,7 @@ impl Step for Extended {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n-            host: run.host,\n+            host: run.builder.build.build,\n             target: run.target,\n         });\n     }\n@@ -1672,9 +1681,7 @@ pub struct HashSign;\n \n impl Step for HashSign {\n     type Output = ();\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"hash-and-sign\")"}, {"sha": "5bc582b3507bb4935b936cf67123ab790efeb42f", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -312,6 +312,7 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n     cmd.arg(\"--html-after-content\").arg(&footer)\n         .arg(\"--html-before-content\").arg(&version_info)\n         .arg(\"--html-in-header\").arg(&favicon)\n+        .arg(\"--markdown-no-toc\")\n         .arg(\"--markdown-playground-url\")\n         .arg(\"https://play.rust-lang.org/\")\n         .arg(\"-o\").arg(&out)\n@@ -480,7 +481,7 @@ impl Step for Std {\n         t!(symlink_dir_force(&my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n-        compile::std_cargo(build, &compiler, target, &mut cargo);\n+        compile::std_cargo(builder, &compiler, target, &mut cargo);\n \n         // We don't want to build docs for internal std dependencies unless\n         // in compiler-docs mode. When not in that mode, we whitelist the crates"}, {"sha": "c5af0f8e2e15331cc45fbf779b471731cde82149", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,7 +29,7 @@ use cache::{Interned, INTERNER};\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n-    pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n+    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n@@ -43,6 +43,7 @@ pub struct Flags {\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n }\n \n pub enum Subcommand {\n@@ -118,6 +119,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n+        opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n@@ -370,6 +372,7 @@ Arguments:\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n+            rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))"}, {"sha": "0d7c1b8de63234d728ed584cc0e15c646754c7d7", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -67,18 +67,21 @@ fn install_sh(\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n-    let docdir_default = PathBuf::from(\"share/doc/rust\");\n+    let datadir_default = PathBuf::from(\"share\");\n+    let docdir_default = datadir_default.join(\"doc/rust\");\n     let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n-    let mandir_default = PathBuf::from(\"share/man\");\n+    let mandir_default = datadir_default.join(\"man\");\n     let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n     let sysconfdir = build.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n+    let datadir = build.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n     let bindir = build.config.bindir.as_ref().unwrap_or(&bindir_default);\n     let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n     let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n \n     let sysconfdir = prefix.join(sysconfdir);\n+    let datadir = prefix.join(datadir);\n     let docdir = prefix.join(docdir);\n     let bindir = prefix.join(bindir);\n     let libdir = prefix.join(libdir);\n@@ -88,6 +91,7 @@ fn install_sh(\n \n     let prefix = add_destdir(&prefix, &destdir);\n     let sysconfdir = add_destdir(&sysconfdir, &destdir);\n+    let datadir = add_destdir(&datadir, &destdir);\n     let docdir = add_destdir(&docdir, &destdir);\n     let bindir = add_destdir(&bindir, &destdir);\n     let libdir = add_destdir(&libdir, &destdir);\n@@ -107,6 +111,7 @@ fn install_sh(\n         .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n+        .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n         .arg(format!(\"--docdir={}\", sanitize_sh(&docdir)))\n         .arg(format!(\"--bindir={}\", sanitize_sh(&bindir)))\n         .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n@@ -161,7 +166,6 @@ macro_rules! install {\n         impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n-            const ONLY_BUILD_TARGETS: bool = true;\n             const ONLY_HOSTS: bool = $only_hosts;\n             $(const $c: bool = true;)*\n \n@@ -174,7 +178,7 @@ macro_rules! install {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n-                    host: run.host,\n+                    host: run.builder.build.build,\n                 });\n             }\n \n@@ -226,14 +230,39 @@ install!((self, builder, _config),\n         });\n         install_analysis(builder, self.stage, self.target);\n     };\n-    Src, \"src\", Self::should_build(_config) , only_hosts: true, {\n-        builder.ensure(dist::Src);\n-        install_src(builder, self.stage);\n-    }, ONLY_BUILD;\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n             compiler: builder.compiler(self.stage, self.target),\n         });\n         install_rustc(builder, self.stage, self.target);\n     };\n );\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Src {\n+    pub stage: u32,\n+}\n+\n+impl Step for Src {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let config = &run.builder.config;\n+        let cond = config.extended &&\n+            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        run.path(\"src\").default_condition(cond)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Src {\n+            stage: run.builder.top_stage,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(dist::Src);\n+        install_src(builder, self.stage);\n+    }\n+}"}, {"sha": "b778ba33d89ccfd06e71d372596400c509ffd1b4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -113,8 +113,9 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-//#![deny(warnings)]\n+#![deny(warnings)]\n #![feature(core_intrinsics)]\n+#![feature(slice_concat_ext)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -501,6 +502,10 @@ impl Build {\n         self.out.join(&*target).join(\"llvm-emscripten\")\n     }\n \n+    fn lld_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"lld\")\n+    }\n+\n     /// Output directory for all documentation for a target\n     fn doc_out(&self, target: Interned<String>) -> PathBuf {\n         self.out.join(&*target).join(\"doc\")\n@@ -528,20 +533,6 @@ impl Build {\n         }\n     }\n \n-    /// Returns the path to `llvm-config` for the specified target.\n-    ///\n-    /// If a custom `llvm-config` was specified for target then that's returned\n-    /// instead.\n-    fn llvm_config(&self, target: Interned<String>) -> PathBuf {\n-        let target_config = self.config.target_config.get(&target);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.clone()\n-        } else {\n-            self.llvm_out(self.config.build).join(\"bin\")\n-                .join(exe(\"llvm-config\", &*target))\n-        }\n-    }\n-\n     /// Returns the path to `FileCheck` binary for the specified target\n     fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n         let target_config = self.config.target_config.get(&target);\n@@ -615,10 +606,6 @@ impl Build {\n         self.verbosity > 0\n     }\n \n-    pub fn is_very_verbose(&self) -> bool {\n-        self.verbosity > 1\n-    }\n-\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n         if self.is_verbose() {\n@@ -685,7 +672,9 @@ impl Build {\n                                                        .and_then(|c| c.linker.as_ref()) {\n             Some(linker)\n         } else if target != self.config.build &&\n-                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+                  !target.contains(\"msvc\") &&\n+                  !target.contains(\"emscripten\") &&\n+                  !target.contains(\"wasm32\") {\n             Some(self.cc(target))\n         } else {\n             None"}, {"sha": "7897af4f72470cba4ef84795d255f5a5807185cd", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -16,6 +16,12 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n+ifdef EXCLUDE_CARGO\n+AUX_ARGS :=\n+else\n+AUX_ARGS := src/tools/cargo src/tools/cargotest\n+endif\n+\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -52,14 +58,13 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/tools/cargo \\\n-\t\tsrc/tools/cargotest \\\n \t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\tsrc/test/run-fail-fulldeps/pretty \\\n+\t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "f923ad46bcbaa07d79b35c6e1a1baf39e44e62a1", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 145, "deletions": 75, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -84,8 +84,11 @@ impl Step for Llvm {\n             let config_dir = dir.join(\"bin\");\n             (dir, config_dir)\n         } else {\n-            (build.llvm_out(target),\n-                build.llvm_out(build.config.build).join(\"bin\"))\n+            let mut dir = build.llvm_out(build.config.build);\n+            if !build.config.build.contains(\"msvc\") || build.config.ninja {\n+                dir.push(\"build\");\n+            }\n+            (build.llvm_out(target), dir.join(\"bin\"))\n         };\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n         let build_llvm_config = llvm_config_ret_dir\n@@ -110,9 +113,6 @@ impl Step for Llvm {\n         // http://llvm.org/docs/CMake.html\n         let root = if self.emscripten { \"src/llvm-emscripten\" } else { \"src/llvm\" };\n         let mut cfg = cmake::Config::new(build.src.join(root));\n-        if build.config.ninja {\n-            cfg.generator(\"Ninja\");\n-        }\n \n         let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n             (false, _) => \"Debug\",\n@@ -139,9 +139,7 @@ impl Step for Llvm {\n \n         let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n-        cfg.target(&target)\n-           .host(&build.build)\n-           .out_dir(&out_dir)\n+        cfg.out_dir(&out_dir)\n            .profile(profile)\n            .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n            .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n@@ -213,67 +211,7 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_NATIVE_BUILD\", build.llvm_out(build.build).join(\"build\"));\n         }\n \n-        let sanitize_cc = |cc: &Path| {\n-            if target.contains(\"msvc\") {\n-                OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n-            } else {\n-                cc.as_os_str().to_owned()\n-            }\n-        };\n-\n-        let configure_compilers = |cfg: &mut cmake::Config| {\n-            // MSVC with CMake uses msbuild by default which doesn't respect these\n-            // vars that we'd otherwise configure. In that case we just skip this\n-            // entirely.\n-            if target.contains(\"msvc\") && !build.config.ninja {\n-                return\n-            }\n-\n-            let cc = build.cc(target);\n-            let cxx = build.cxx(target).unwrap();\n-\n-            // Handle msvc + ninja + ccache specially (this is what the bots use)\n-            if target.contains(\"msvc\") &&\n-               build.config.ninja &&\n-               build.config.ccache.is_some() {\n-                let mut cc = env::current_exe().expect(\"failed to get cwd\");\n-                cc.set_file_name(\"sccache-plus-cl.exe\");\n-\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n-               cfg.env(\"SCCACHE_PATH\",\n-                       build.config.ccache.as_ref().unwrap())\n-                  .env(\"SCCACHE_TARGET\", target);\n-\n-            // If ccache is configured we inform the build a little differently hwo\n-            // to invoke ccache while also invoking our compilers.\n-            } else if let Some(ref ccache) = build.config.ccache {\n-               cfg.define(\"CMAKE_C_COMPILER\", ccache)\n-                  .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", ccache)\n-                  .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n-            } else {\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n-            }\n-\n-            cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n-            cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n-            cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n-            if let Some(ar) = build.ar(target) {\n-                if ar.is_absolute() {\n-                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n-                    // tries to resolve this path in the LLVM build directory.\n-                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n-                }\n-            }\n-        };\n-\n-        configure_compilers(&mut cfg);\n-\n-        if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-            cfg.env(\"RUST_LOG\", \"sccache=warn\");\n-        }\n+        configure_cmake(build, target, &mut cfg, false);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g. we just want a few components and a few\n@@ -304,6 +242,134 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n }\n \n+fn configure_cmake(build: &Build,\n+                   target: Interned<String>,\n+                   cfg: &mut cmake::Config,\n+                   building_dist_binaries: bool) {\n+    if build.config.ninja {\n+        cfg.generator(\"Ninja\");\n+    }\n+    cfg.target(&target)\n+       .host(&build.config.build);\n+\n+    let sanitize_cc = |cc: &Path| {\n+        if target.contains(\"msvc\") {\n+            OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n+        } else {\n+            cc.as_os_str().to_owned()\n+        }\n+    };\n+\n+    // MSVC with CMake uses msbuild by default which doesn't respect these\n+    // vars that we'd otherwise configure. In that case we just skip this\n+    // entirely.\n+    if target.contains(\"msvc\") && !build.config.ninja {\n+        return\n+    }\n+\n+    let cc = build.cc(target);\n+    let cxx = build.cxx(target).unwrap();\n+\n+    // Handle msvc + ninja + ccache specially (this is what the bots use)\n+    if target.contains(\"msvc\") &&\n+       build.config.ninja &&\n+       build.config.ccache.is_some() {\n+        let mut cc = env::current_exe().expect(\"failed to get cwd\");\n+        cc.set_file_name(\"sccache-plus-cl.exe\");\n+\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n+       cfg.env(\"SCCACHE_PATH\",\n+               build.config.ccache.as_ref().unwrap())\n+          .env(\"SCCACHE_TARGET\", target);\n+\n+    // If ccache is configured we inform the build a little differently hwo\n+    // to invoke ccache while also invoking our compilers.\n+    } else if let Some(ref ccache) = build.config.ccache {\n+       cfg.define(\"CMAKE_C_COMPILER\", ccache)\n+          .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", ccache)\n+          .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n+    } else {\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+    }\n+\n+    cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n+    cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n+    let mut cxxflags = build.cflags(target).join(\" \");\n+    if building_dist_binaries {\n+        if build.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n+            cxxflags.push_str(\" -static-libstdc++\");\n+        }\n+    }\n+    cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n+    if let Some(ar) = build.ar(target) {\n+        if ar.is_absolute() {\n+            // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+            // tries to resolve this path in the LLVM build directory.\n+            cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+        }\n+    }\n+\n+    if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n+        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Lld {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Lld {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/lld\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Lld { target: run.target });\n+    }\n+\n+    /// Compile LLVM for `target`.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let target = self.target;\n+        let build = builder.build;\n+\n+        let llvm_config = builder.ensure(Llvm {\n+            target: self.target,\n+            emscripten: false,\n+        });\n+\n+        let out_dir = build.lld_out(target);\n+        let done_stamp = out_dir.join(\"lld-finished-building\");\n+        if done_stamp.exists() {\n+            return out_dir\n+        }\n+\n+        let _folder = build.fold_output(|| \"lld\");\n+        println!(\"Building LLD for {}\", target);\n+        let _time = util::timeit();\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n+        configure_cmake(build, target, &mut cfg, true);\n+\n+        cfg.out_dir(&out_dir)\n+           .profile(\"Release\")\n+           .define(\"LLVM_CONFIG_PATH\", llvm_config)\n+           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n+\n+        cfg.build();\n+\n+        t!(File::create(&done_stamp));\n+        out_dir\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TestHelpers {\n     pub target: Interned<String>,\n@@ -313,7 +379,7 @@ impl Step for TestHelpers {\n     type Output = ();\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rt/rust_test_helpers.c\")\n+        run.path(\"src/test/auxiliary/rust_test_helpers.c\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -326,7 +392,7 @@ impl Step for TestHelpers {\n         let build = builder.build;\n         let target = self.target;\n         let dst = build.test_helpers_out(target);\n-        let src = build.src.join(\"src/rt/rust_test_helpers.c\");\n+        let src = build.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n         if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n             return\n         }\n@@ -353,14 +419,14 @@ impl Step for TestHelpers {\n            .opt_level(0)\n            .warnings(false)\n            .debug(false)\n-           .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n+           .file(build.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n            .compile(\"rust_test_helpers\");\n     }\n }\n \n-const OPENSSL_VERS: &'static str = \"1.0.2m\";\n+const OPENSSL_VERS: &'static str = \"1.0.2n\";\n const OPENSSL_SHA256: &'static str =\n-    \"8c6ff15ec6b319b50788f42c7abc2890c08ba5a1cdcd3810eb9092deada37b0f\";\n+    \"370babb75f278c39e0c50e8c4e7493bc0f18db6867478341a832a982fd15a8fe\";\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Openssl {\n@@ -480,16 +546,20 @@ impl Step for Openssl {\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n             \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n+            \"powerpc-unknown-linux-gnuspe\" => \"linux-ppc\",\n+            \"powerpc-unknown-netbsd\" => \"BSD-generic32\",\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"sparc-unknown-linux-gnu\" => \"linux-sparcv9\",\n             \"sparc64-unknown-linux-gnu\" => \"linux64-sparcv9\",\n             \"sparc64-unknown-netbsd\" => \"BSD-sparc64\",\n             \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n             \"x86_64-linux-android\" => \"linux-x86_64\",\n             \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n             \"x86_64-unknown-dragonfly\" => \"BSD-x86_64\",\n             \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n+            \"x86_64-unknown-linux-gnux32\" => \"linux-x32\",\n             \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n             \"x86_64-unknown-netbsd\" => \"BSD-x86_64\",\n             _ => panic!(\"don't know how to configure OpenSSL for {}\", target),\n@@ -526,7 +596,7 @@ impl Step for Openssl {\n         println!(\"Building openssl for {}\", target);\n         build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n         println!(\"Installing openssl for {}\", target);\n-        build.run_quiet(Command::new(\"make\").arg(\"install\").current_dir(&obj));\n+        build.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));\n         t!(f.write_all(OPENSSL_VERS.as_bytes()));"}, {"sha": "de938ec8e8306a9f828c8e14b5d1b8f02466c83c", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 93, "deletions": 36, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -78,15 +78,17 @@ fn try_run(build: &Build, cmd: &mut Command) -> bool {\n     true\n }\n \n-fn try_run_quiet(build: &Build, cmd: &mut Command) {\n+fn try_run_quiet(build: &Build, cmd: &mut Command) -> bool {\n     if !build.fail_fast {\n         if !build.try_run_quiet(cmd) {\n             let mut failures = build.delayed_failures.borrow_mut();\n             failures.push(format!(\"{:?}\", cmd));\n+            return false;\n         }\n     } else {\n         build.run_quiet(cmd);\n     }\n+    true\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -243,7 +245,7 @@ impl Step for Rls {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        builder.ensure(tool::Rls { compiler, target: self.host });\n+        builder.ensure(tool::Rls { compiler, target: self.host, extra_features: Vec::new() });\n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n                                                  host,\n@@ -289,7 +291,7 @@ impl Step for Rustfmt {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n+        builder.ensure(tool::Rustfmt { compiler, target: self.host, extra_features: Vec::new() });\n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n                                                  host,\n@@ -337,7 +339,12 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+        let miri = builder.ensure(tool::Miri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(miri) = miri {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n             cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n \n@@ -389,7 +396,12 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+        let clippy = builder.ensure(tool::Clippy {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(clippy) = clippy {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n             cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n@@ -503,29 +515,26 @@ impl Step for RustdocJS {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Tidy {\n-    host: Interned<String>,\n-}\n+pub struct Tidy;\n \n impl Step for Tidy {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n-    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+    /// Runs the `tidy` tool.\n     ///\n     /// This tool in `src/tools` checks up on various bits and pieces of style and\n     /// otherwise just implements a few lint-like checks that are specific to the\n     /// compiler itself.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let host = self.host;\n \n         let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check ({})\", host);\n+        println!(\"tidy check\");\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(&build.initial_cargo);\n         if !build.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n@@ -540,9 +549,7 @@ impl Step for Tidy {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Tidy {\n-            host: run.builder.build.build,\n-        });\n+        run.builder.ensure(Tidy);\n     }\n }\n \n@@ -912,7 +919,10 @@ impl Step for Compiletest {\n         }\n \n         if build.config.llvm_enabled {\n-            let llvm_config = build.llvm_config(target);\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target: build.config.build,\n+                emscripten: false,\n+            });\n             let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n             cmd.arg(\"--llvm-version\").arg(llvm_version);\n             if !build.is_rust_llvm(target) {\n@@ -994,23 +1004,19 @@ impl Step for Compiletest {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Docs {\n+struct DocTest {\n     compiler: Compiler,\n+    path: &'static str,\n+    name: &'static str,\n+    is_ext_doc: bool,\n }\n \n-impl Step for Docs {\n+impl Step for DocTest {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/doc\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Docs {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n+        run.never()\n     }\n \n     /// Run `rustdoc --test` for all documentation in `src/doc`.\n@@ -1026,9 +1032,9 @@ impl Step for Docs {\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(\"src/doc\")];\n+        let mut stack = vec![build.src.join(self.path)];\n         let _time = util::timeit();\n-        let _folder = build.fold_output(|| \"test_docs\");\n+        let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n@@ -1046,11 +1052,64 @@ impl Step for Docs {\n                 continue;\n             }\n \n-            markdown_test(builder, compiler, &p);\n+            let test_result = markdown_test(builder, compiler, &p);\n+            if self.is_ext_doc {\n+                let toolstate = if test_result {\n+                    ToolState::TestPass\n+                } else {\n+                    ToolState::TestFail\n+                };\n+                build.save_toolstate(self.name, toolstate);\n+            }\n         }\n     }\n }\n \n+macro_rules! test_book {\n+    ($($name:ident, $path:expr, $book_name:expr, default=$default:expr;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+            pub struct $name {\n+                compiler: Compiler,\n+            }\n+\n+            impl Step for $name {\n+                type Output = ();\n+                const DEFAULT: bool = $default;\n+                const ONLY_HOSTS: bool = true;\n+\n+                fn should_run(run: ShouldRun) -> ShouldRun {\n+                    run.path($path)\n+                }\n+\n+                fn make_run(run: RunConfig) {\n+                    run.builder.ensure($name {\n+                        compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+                    });\n+                }\n+\n+                fn run(self, builder: &Builder) {\n+                    builder.ensure(DocTest {\n+                        compiler: self.compiler,\n+                        path: $path,\n+                        name: $book_name,\n+                        is_ext_doc: !$default,\n+                    });\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+test_book!(\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\", default=false;\n+    Reference, \"src/doc/reference\", \"reference\", default=false;\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n+    TheBook, \"src/doc/book\", \"book\", default=false;\n+    UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n+);\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ErrorIndex {\n     compiler: Compiler,\n@@ -1101,13 +1160,13 @@ impl Step for ErrorIndex {\n     }\n }\n \n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n+fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n     let build = builder.build;\n     let mut file = t!(File::open(markdown));\n     let mut contents = String::new();\n     t!(file.read_to_string(&mut contents));\n     if !contents.contains(\"```\") {\n-        return;\n+        return true;\n     }\n \n     println!(\"doc tests for: {}\", markdown.display());\n@@ -1121,9 +1180,9 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n     cmd.arg(\"--test-args\").arg(test_args);\n \n     if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd);\n+        try_run_quiet(build, &mut cmd)\n     } else {\n-        try_run(build, &mut cmd);\n+        try_run(build, &mut cmd)\n     }\n }\n \n@@ -1330,7 +1389,7 @@ impl Step for Crate {\n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n             Mode::Libstd => {\n-                compile::std_cargo(build, &compiler, target, &mut cargo);\n+                compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n             Mode::Libtest => {\n                 compile::test_cargo(build, &compiler, target, &mut cargo);\n@@ -1555,7 +1614,6 @@ pub struct Distcheck;\n \n impl Step for Distcheck {\n     type Output = ();\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"distcheck\")\n@@ -1621,7 +1679,6 @@ impl Step for Bootstrap {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     /// Test the build system itself\n     fn run(self, builder: &Builder) {"}, {"sha": "5f5b10a07b865893cc3c0750ccf0961b42ed8b4d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -12,6 +12,7 @@ use std::fs;\n use std::env;\n use std::path::PathBuf;\n use std::process::{Command, exit};\n+use std::slice::SliceConcatExt;\n \n use Mode;\n use Compiler;\n@@ -74,14 +75,15 @@ impl Step for CleanTools {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n     target: Interned<String>,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n     is_ext_tool: bool,\n+    extra_features: Vec<String>,\n }\n \n impl Step for ToolBuild {\n@@ -114,6 +116,7 @@ impl Step for ToolBuild {\n         println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n \n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n+        cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n         let is_expected = build.try_run(&mut cargo);\n         build.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n@@ -242,6 +245,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     is_ext_tool: false,\n+                    extra_features: Vec::new(),\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -291,6 +295,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             is_ext_tool: false,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -409,6 +414,7 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             is_ext_tool: false,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -421,10 +427,11 @@ macro_rules! tool_extended {\n        $tool_name:expr,\n        $extra_deps:block;)+) => {\n         $(\n-            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+            #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n             pub target: Interned<String>,\n+            pub extra_features: Vec<String>,\n         }\n \n         impl Step for $name {\n@@ -441,17 +448,20 @@ macro_rules! tool_extended {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n                     target: run.target,\n+                    extra_features: Vec::new(),\n                 });\n             }\n \n-            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+            #[allow(unused_mut)]\n+            fn run(mut $sel, $builder: &Builder) -> Option<PathBuf> {\n                 $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n                     tool: $tool_name,\n                     mode: Mode::Librustc,\n                     path: $path,\n+                    extra_features: $sel.extra_features,\n                     is_ext_tool: true,\n                 })\n             }\n@@ -472,6 +482,14 @@ tool_extended!((self, builder),\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n+        let clippy = builder.ensure(Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+            extra_features: Vec::new(),\n+        });\n+        if clippy.is_some() {\n+            self.extra_features.push(\"clippy\".to_owned());\n+        }\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });"}, {"sha": "e10ccd56a4a54613978def21f294de6d9fb86fdd", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -31,9 +31,7 @@ ENV PATH=$PATH:/android/sdk/platform-tools\n \n ENV TARGETS=arm-linux-androideabi\n \n-ENV RUST_CONFIGURE_ARGS \\\n-      --target=$TARGETS \\\n-      --arm-linux-androideabi-ndk=/android/ndk/arm-14\n+ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n "}, {"sha": "2b7624d53ee05d04f706a105979678717bd59a55", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -76,9 +76,7 @@ RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/cu\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV RUST_CONFIGURE_ARGS \\\n-      --target=arm-unknown-linux-gnueabihf \\\n-      --qemu-armhf-rootfs=/tmp/rootfs\n+ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n ENV SCRIPT python2.7 ../x.py test --target arm-unknown-linux-gnueabihf\n \n ENV NO_CHANGE_USER=1"}, {"sha": "cb85cf3d9e9f094f87ba6617250e55ef68a7fd42", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,6 +29,11 @@ ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=asmjs-unknown-emscripten\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-emscripten\n+ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+  src/test/run-pass \\\n+  src/test/run-fail \\\n+  src/libstd \\\n+  src/liballoc \\\n+  src/libcore"}, {"sha": "b2a3ba3ec2600ebc2d37296b328d09b675d237fd", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -74,7 +74,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=aarch64-unknown-linux-gnu \\\n       --qemu-aarch64-rootfs=/tmp/rootfs\n ENV SCRIPT python2.7 ../x.py test --target aarch64-unknown-linux-gnu\n ENV NO_CHANGE_USER=1"}, {"sha": "a7903b6f42501337f8fe500dc9d41db069e94c9a", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,8 +14,6 @@ ENV DEP_Z_ROOT=/android/ndk/arm64-21/sysroot/usr/\n ENV HOSTS=aarch64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "c02a5e5a09542c3fd163ab7c7deed3f69fac42d5", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -20,8 +20,6 @@ ENV DEP_Z_ROOT=/android/ndk/arm-14/sysroot/usr/\n ENV HOSTS=armv7-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "04e83a431c45526e7587cb007164a55f2e8eea7d", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -20,8 +20,6 @@ ENV DEP_Z_ROOT=/android/ndk/x86-14/sysroot/usr/\n ENV HOSTS=i686-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --i686-linux-android-ndk=/android/ndk/x86 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "937301864cd059bfeaae5899f20d0d3305b5da29", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,8 +14,6 @@ ENV DEP_Z_ROOT=/android/ndk/x86_64-21/sysroot/usr/\n ENV HOSTS=x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "dbff9e32e1311d9ceff3e2314009dae43df16132", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-dragonfly\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "440afd7c97f5e3a162e8e49fb145df681115caef", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -42,8 +42,8 @@ RUN sh /scripts/sccache.sh\n ENV HOST=x86_64-unknown-haiku\n ENV TARGET=target.$HOST\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOST --target=$HOST --disable-jemalloc \\\n+ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n   --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n   --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n   --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV SCRIPT python2.7 ../x.py dist\n+ENV SCRIPT python2.7 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "f4c25f791bc3916bdf60be34aa927ae6b8ea88f5", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -18,5 +18,5 @@ ENV \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n     CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n \n-ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-redox --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "420d47b314c0f63da8e006eb78688c6051eec6c5", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -30,6 +30,6 @@ ENV EM_CONFIG=/root/.emscripten\n \n ENV TARGETS=wasm32-experimental-emscripten\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --experimental-targets=WebAssembly\n+ENV RUST_CONFIGURE_ARGS --experimental-targets=WebAssembly\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "6ac90d17450a37fbac1bcd610a0b86eaa72b3f8e", "filename": "src/ci/docker/disabled/wasm32/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,7 +29,4 @@ ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.37.13_64bit/binaryen/\n ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=wasm32-unknown-emscripten\n-\n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n-\n ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "dbc319312aa9fcdd6661b78f4dd90d4e71492fc6", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=aarch64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "aa5da136758a0d6c41877f9b58fb246bd0b64225", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -21,7 +21,6 @@ ENV TARGETS=$TARGETS,aarch64-linux-android\n ENV TARGETS=$TARGETS,x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=$TARGETS \\\n       --enable-extended \\\n       --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\"}, {"sha": "89f7f85cb3b17d15da8c0c02c7c2adc597781e86", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e0c1b9a9e858941dcbc0bc853c43ee89726648d3", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e7d4f464ffcd2252ce65269818c94f8eda46a662", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "7bcc649f4aa5c8af72b2d828c3d237a6de4fd9de", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -30,7 +30,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=i686-unknown-linux-musl,i586-unknown-linux-gnu \\\n       --musl-root-i586=/musl-i586 \\\n       --musl-root-i686=/musl-i686 \\\n       --enable-extended\n@@ -46,8 +45,7 @@ ENV CFLAGS_i586_unknown_linux_gnu=-Wa,-mrelax-relocations=no\n #       https://github.com/alexcrichton/cc-rs/pull/281\n ENV CFLAGS_i586_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wl,-melf_i386\"\n \n-ENV TARGETS=i586-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,i686-unknown-linux-musl\n+ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n \n ENV SCRIPT \\\n       python2.7 ../x.py test --target $TARGETS && \\"}, {"sha": "1f595ba7a290f8cddebf807831f93ae5358bb269", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=i686-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "0ec57ee08868716098f19a4e6aa9bf0067123305", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -82,13 +82,10 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=i686-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler \\\n-      --enable-emscripten \\\n-      --build=i686-unknown-linux-gnu\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+      --enable-profiler\n+ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs\n ENV DIST_SRC 1"}, {"sha": "37ab5bdcce555001b181e05f776e278dbee55b82", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a5180780b225925431657420b2c9b9aaf68a3561", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "d38ed24f6255fb14c562ecc9b19c39042e6da950", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "491c57ba6773703917485871034aaa55fdf9cbac", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mipsel-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "c503f2af9cdaa902548273122de9e46403c62579", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -34,7 +34,7 @@ ENV \\\n \n ENV HOSTS=powerpc-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # FIXME(#36150) this will fail the bootstrap. Probably means something bad is"}, {"sha": "4a3691777360ba47fdec854b7596b133daa619ef", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -35,5 +35,5 @@ ENV \\\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "bf6c8b4b7121173e31e393fb327e2c41fed56a22", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a2ebf590bab74548f8e5910101f9ea9adac228b6", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -34,5 +34,5 @@ ENV \\\n \n ENV HOSTS=s390x-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a23153645cde2f55075cce358dfbf8f8678cda22", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -89,7 +89,6 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CFLAGS_armv5te_unknown_linux_gnueabi=\"-march=armv5te -marm -mfloat-abi=soft\"\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=$TARGETS \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n       --musl-root-armv7=/musl-armv7 \\"}, {"sha": "4505a60e46396540103c5ef1ef67a4c23ed11521", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -55,5 +55,5 @@ ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "dd595a192051f7a8444eb7f71af0f71b6c3e7206", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "3b98b0aa926bd1250915725724ca5af9356a7b9d", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -82,11 +82,9 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=x86_64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler \\\n-      --enable-emscripten\n+      --enable-profiler\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "3a9ad178c6390b571c9c9159c8c3c0f44c4d28bc", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -30,7 +30,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=x86_64-unknown-linux-musl \\\n       --musl-root-x86_64=/musl-x86_64 \\\n       --enable-extended\n "}, {"sha": "06298a12fc70a9718a47eafbde4cf9c710981394", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -33,5 +33,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-netbsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "0972eb85191a94b7134f23df7f22a7fa064b38f4", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -22,8 +22,8 @@ RUN sh /scripts/sccache.sh\n ENV TARGETS=wasm32-unknown-unknown\n \n ENV RUST_CONFIGURE_ARGS \\\n-  --target=$TARGETS \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node\n+  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n+  --set rust.lld\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n   src/test/ui \\"}, {"sha": "bab9145cbcb9c78ed68ee5c5a06fdf28cca932a6", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -17,6 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+COPY x86_64-gnu-tools/checkregression.py /tmp/\n COPY x86_64-gnu-tools/checktools.sh /tmp/\n COPY x86_64-gnu-tools/repo.sh /tmp/\n "}, {"sha": "df791d12645fdea798b18f5df759de51019a5501", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -0,0 +1,40 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+# Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import json\n+\n+if __name__ == '__main__':\n+    os_name = sys.argv[1]\n+    toolstate_file = sys.argv[2]\n+    current_state = sys.argv[3]\n+\n+    with open(toolstate_file, 'r') as f:\n+        toolstate = json.load(f)\n+    with open(current_state, 'r') as f:\n+        current = json.load(f)\n+\n+    regressed = False\n+    for cur in current:\n+        tool = cur['tool']\n+        state = cur[os_name]\n+        new_state = toolstate.get(tool, '')\n+        if new_state < state:\n+            print(\n+                'Error: The state of \"{}\" has regressed from \"{}\" to \"{}\"'\n+                .format(tool, state, new_state)\n+            )\n+            regressed = True\n+\n+    if regressed:\n+        sys.exit(1)"}, {"sha": "da89aa9423b2daa18cf9a9bc500fd63c717ecc64", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -17,39 +17,57 @@ TOOLSTATE_FILE=\"$(realpath $2)\"\n OS=\"$3\"\n COMMIT=\"$(git rev-parse HEAD)\"\n CHANGED_FILES=\"$(git diff --name-status HEAD HEAD^)\"\n+SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 604800 - 3) % 6 ))\"\n+# ^ 1970 Jan 1st is a Thursday, and our release dates are also on Thursdays,\n+#   thus we could divide by 604800 (7 days in seconds) directly.\n \n touch \"$TOOLSTATE_FILE\"\n \n set +e\n python2.7 \"$X_PY\" test --no-fail-fast \\\n+    src/doc/book \\\n+    src/doc/nomicon \\\n+    src/doc/reference \\\n+    src/doc/rust-by-example \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n     src/tools/clippy\n set -e\n \n cat \"$TOOLSTATE_FILE\"\n+echo\n \n-# If this PR is intended to update one of these tools, do not let the build pass\n-# when they do not test-pass.\n-for TOOL in rls rustfmt clippy; do\n-    echo \"Verifying status of $TOOL...\"\n-    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]src/tools/$TOOL$\"; then\n-        echo \"This PR updated 'src/tools/$TOOL', verifying if status is 'test-pass'...\"\n-        if grep -vq '\"'\"$TOOL\"'[^\"]*\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n+verify_status() {\n+    echo \"Verifying status of $1...\"\n+    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n+        echo \"This PR updated '$2', verifying if status is 'test-pass'...\"\n+        if grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n             echo\n-            echo \"\u26a0\ufe0f We detected that this PR updated '$TOOL', but its tests failed.\"\n+            echo \"\u26a0\ufe0f We detected that this PR updated '$1', but its tests failed.\"\n             echo\n-            echo \"If you do intend to update '$TOOL', please check the error messages above and\"\n+            echo \"If you do intend to update '$1', please check the error messages above and\"\n             echo \"commit another update.\"\n             echo\n-            echo \"If you do NOT intend to update '$TOOL', please ensure you did not accidentally\"\n-            echo \"change the submodule at 'src/tools/$TOOL'. You may ask your reviewer for the\"\n+            echo \"If you do NOT intend to update '$1', please ensure you did not accidentally\"\n+            echo \"change the submodule at '$2'. You may ask your reviewer for the\"\n             echo \"proper steps.\"\n             exit 3\n         fi\n     fi\n-done\n+}\n+\n+# If this PR is intended to update one of these tools, do not let the build pass\n+# when they do not test-pass.\n+\n+verify_status book src/doc/book\n+verify_status nomicon src/doc/nomicon\n+verify_status reference src/doc/reference\n+verify_status rust-by-example src/doc/rust-by-example\n+verify_status rls src/tool/rls\n+verify_status rustfmt src/tool/rustfmt\n+verify_status clippy-driver src/tool/clippy\n+#verify_status miri src/tool/miri\n \n if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n     . \"$(dirname $0)/repo.sh\"\n@@ -59,6 +77,11 @@ if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_s\n         sed -i \"1 a\\\\\n $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n \" \"history/$OS.tsv\"\n+    # if we are at the last week in the 6-week release cycle, reject any kind of regression.\n+    if [ $SIX_WEEK_CYCLE -eq 5 ]; then\n+        python2.7 \"$(dirname $0)/checkregression.py\" \\\n+            \"$OS\" \"$TOOLSTATE_FILE\" \"rust-toolstate/_data/latest.json\"\n+    fi\n     rm -f \"$MESSAGE_FILE\"\n     exit 0\n fi"}, {"sha": "e3f38e4834a92dcf86643532ed9df5930b66fa87", "filename": "src/ci/run.sh", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -46,7 +46,6 @@ export RUST_RELEASE_CHANNEL=nightly\n if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n-  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-thinlto\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n@@ -67,6 +66,12 @@ else\n   fi\n fi\n \n+# We've had problems in the past of shell scripts leaking fds into the sccache\n+# server (#48192) which causes Cargo to erroneously think that a build script\n+# hasn't finished yet. Try to solve that problem by starting a very long-lived\n+# sccache server at the start of the build, but no need to worry if this fails.\n+SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n+\n travis_fold start configure\n travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS\n@@ -85,11 +90,19 @@ make check-bootstrap\n travis_fold end check-bootstrap\n travis_time_finish\n \n+# Display the CPU and memory information. This helps us know why the CI timing\n+# is fluctuating.\n+travis_fold start log-system-info\n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+    system_profiler SPHardwareDataType || true\n+    sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)\n else\n+    cat /proc/cpuinfo || true\n+    cat /proc/meminfo || true\n     ncpus=$(grep processor /proc/cpuinfo | wc -l)\n fi\n+travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n   sh -x -c \"$SCRIPT\"\n@@ -98,7 +111,7 @@ else\n     travis_fold start \"make-$1\"\n     travis_time_start\n     echo \"make -j $ncpus $1\"\n-    make -j $ncpus \"$1\"\n+    make -j $ncpus $1\n     local retval=$?\n     travis_fold end \"make-$1\"\n     travis_time_finish"}, {"sha": "98921e9de849acdaeaed08cfad6758bb89769b7d", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1 +1 @@\n-Subproject commit ec5660820dea91df470dab0b9eb26ef798f20889\n+Subproject commit 98921e9de849acdaeaed08cfad6758bb89769b7d"}, {"sha": "39d105399594535a5f0885e67369a796f918e696", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -125,6 +125,16 @@ Print version info and exit.\n \\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\n Use verbose output.\n .TP\n+\\fB\\-\\-remap\\-path\\-prefix\\fR \\fIfrom\\fR=\\fIto\\fR\n+Remap source path prefixes in all output, including compiler diagnostics, debug information,\n+macro expansions, etc. The \\fIfrom\\fR=\\fIto\\fR parameter is scanned from right to left, so \\fIfrom\\fR\n+may contain '=', but \\fIto\\fR may not.\n+\n+This is useful for normalizing build products, for example by removing the current directory out of\n+pathnames emitted into the object files. The replacement is purely textual, with no consideration of\n+the current system's pathname syntax. For example \\fI\\-\\-remap\\-path\\-prefix foo=bar\\fR will\n+match \\fBfoo/lib.rs\\fR but not \\fB./foo/lib.rs\\fR.\n+.TP\n \\fB\\-\\-extern\\fR \\fINAME\\fR=\\fIPATH\\fR\n Specify where an external rust library is located. These should match\n \\fIextern\\fR declarations in the crate's source code."}, {"sha": "b62762ef69e0136e61975ad92df73df6e23e8fd1", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -64,7 +64,6 @@ for details on how to format and write long error codes.\n   [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n   [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n   [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_const_eval](https://github.com/rust-lang/rust/blob/master/src/librustc_const_eval/diagnostics.rs),\n   [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n   [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),"}, {"sha": "fea8685a605d6859b52fcd4a3806d016b5826e06", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,18 +19,38 @@ running `rustdoc --test foo.rs` will extract this example, and then run it as a\n Please note that by default, if no language is set for the block code, `rustdoc`\n assumes it is `Rust` code. So the following:\n \n+``````markdown\n ```rust\n let x = 5;\n ```\n+``````\n \n is strictly equivalent to:\n \n+``````markdown\n ```\n let x = 5;\n ```\n+``````\n \n There's some subtlety though! Read on for more details.\n \n+## Passing or failing a doctest\n+\n+Like regular unit tests, regular doctests are considered to \"pass\"\n+if they compile and run without panicking.\n+So if you want to demonstrate that some computation gives a certain result,\n+the `assert!` family of macros works the same as other Rust code:\n+\n+```rust\n+let foo = \"foo\";\n+\n+assert_eq!(foo, \"foo\");\n+```\n+\n+This way, if the computation ever returns something different,\n+the code panics and the doctest fails.\n+\n ## Pre-processing examples\n \n In the example above, you'll note something strange: there's no `main`"}, {"sha": "8ca04d253259258af86b8e2546cc28f943d8734d", "filename": "src/doc/unstable-book/src/compiler-flags/remap-path-prefix.md", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,37 +0,0 @@\n-# `remap-path-prefix`\n-\n-The tracking issue for this feature is: [#41555](https://github.com/rust-lang/rust/issues/41555)\n-\n-------------------------\n-\n-The `-Z remap-path-prefix-from`, `-Z remap-path-prefix-to` commandline option\n-pair allows to replace prefixes of any file paths the compiler emits in various\n-places. This is useful for bringing debuginfo paths into a well-known form and\n-for achieving reproducible builds independent of the directory the compiler was\n-executed in. All paths emitted by the compiler are affected, including those in\n-error messages.\n-\n-In order to map all paths starting with `/home/foo/my-project/src` to\n-`/sources/my-project`, one would invoke the compiler as follows:\n-\n-```text\n-rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" -Zremap-path-prefix-to=\"/sources/my-project\"\n-```\n-\n-Debuginfo for code from the file `/home/foo/my-project/src/foo/mod.rs`,\n-for example, would then point debuggers to `/sources/my-project/foo/mod.rs`\n-instead of the original file.\n-\n-The options can be specified multiple times when multiple prefixes should be\n-mapped:\n-\n-```text\n-rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" \\\n-      -Zremap-path-prefix-to=\"/sources/my-project\" \\\n-      -Zremap-path-prefix-from=\"/home/foo/my-project/build-dir\" \\\n-      -Zremap-path-prefix-to=\"/stable-build-dir\"\n-```\n-\n-When the options are given multiple times, the nth `-from` will be matched up\n-with the nth `-to` and they can appear anywhere on the commandline. Mappings\n-specified later on the line will take precedence over earlier ones."}, {"sha": "42d46ce15f676e552025619097bd9c90c17730e3", "filename": "src/doc/unstable-book/src/language-features/const-indexing.md", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,19 +0,0 @@\n-# `const_indexing`\n-\n-The tracking issue for this feature is: [#29947]\n-\n-[#29947]: https://github.com/rust-lang/rust/issues/29947\n-\n-------------------------\n-\n-The `const_indexing` feature allows the constant evaluation of index operations\n-on constant arrays and repeat expressions.\n-\n-## Examples\n-\n-```rust\n-#![feature(const_indexing)]\n-\n-const ARR: [usize; 5] = [1, 2, 3, 4, 5];\n-const ARR2: [usize; ARR[1]] = [42, 99];\n-```\n\\ No newline at end of file"}, {"sha": "56f58803150ca6ca274b5b9046f771f92e1c0627", "filename": "src/doc/unstable-book/src/language-features/inclusive-range-syntax.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,20 +0,0 @@\n-# `inclusive_range_syntax`\n-\n-The tracking issue for this feature is: [#28237]\n-\n-[#28237]: https://github.com/rust-lang/rust/issues/28237\n-\n-------------------------\n-\n-To get a range that goes from 0 to 10 and includes the value 10, you\n-can write `0..=10`:\n-\n-```rust\n-#![feature(inclusive_range_syntax)]\n-\n-fn main() {\n-    for i in 0..=10 {\n-        println!(\"{}\", i);\n-    }\n-}\n-```"}, {"sha": "1280c71e83c922fa2b5e3befe3419f6014aa1dd2", "filename": "src/doc/unstable-book/src/library-features/entry-and-modify.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,77 +0,0 @@\n-# `entry_and_modify`\n-\n-The tracking issue for this feature is: [#44733]\n-\n-[#44733]: https://github.com/rust-lang/rust/issues/44733\n-\n-------------------------\n-\n-This introduces a new method for the Entry API of maps\n-(`std::collections::HashMap` and `std::collections::BTreeMap`), so that\n-occupied entries can be modified before any potential inserts into the\n-map.\n-\n-For example:\n-\n-```rust\n-#![feature(entry_and_modify)]\n-# fn main() {\n-use std::collections::HashMap;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-map.entry(\"quux\")\n-   .and_modify(|e| e.new = false)\n-   .or_insert(Foo { new: true });\n-# }\n-```\n-\n-This is not possible with the stable API alone since inserting a default\n-_before_ modifying the `new` field would mean we would lose the default state:\n-\n-```rust\n-# fn main() {\n-use std::collections::HashMap;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-map.entry(\"quux\").or_insert(Foo { new: true }).new = false;\n-# }\n-```\n-\n-In the above code the `new` field will never be `true`, even though we only\n-intended to update that field to `false` for previously extant entries.\n-\n-To achieve the same effect as `and_modify` we would have to manually match\n-against the `Occupied` and `Vacant` variants of the `Entry` enum, which is\n-a little less user-friendly, and much more verbose:\n-\n-```rust\n-# fn main() {\n-use std::collections::HashMap;\n-use std::collections::hash_map::Entry;\n-\n-struct Foo {\n-    new: bool,\n-}\n-\n-let mut map: HashMap<&str, Foo> = HashMap::new();\n-\n-match map.entry(\"quux\") {\n-    Entry::Occupied(entry) => {\n-        entry.into_mut().new = false;\n-    },\n-    Entry::Vacant(entry) => {\n-        entry.insert(Foo { new: true });\n-    },\n-};\n-# }\n-```"}, {"sha": "ac2223f4acef3052d32d35689b90eb1227ca4a19", "filename": "src/etc/sugarise-doc-comments.py", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,93 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-#\n-# this script attempts to turn doc comment attributes (#[doc = \"...\"])\n-# into sugared-doc-comments (/** ... */ and /// ...)\n-#\n-# it sugarises all .rs/.rc files underneath the working directory\n-#\n-\n-import sys\n-import os\n-import fnmatch\n-import re\n-\n-\n-DOC_PATTERN = '^(?P<indent>[\\\\t ]*)#\\\\[(\\\\s*)doc(\\\\s*)=' + \\\n-              '(\\\\s*)\"(?P<text>(\\\\\"|[^\"])*?)\"(\\\\s*)\\\\]' + \\\n-              '(?P<semi>;)?'\n-\n-ESCAPES = [(\"\\\\'\", \"'\"),\n-           ('\\\\\"', '\"'),\n-           (\"\\\\n\", \"\\n\"),\n-           (\"\\\\r\", \"\\r\"),\n-           (\"\\\\t\", \"\\t\")]\n-\n-\n-def unescape(s):\n-    for (find, repl) in ESCAPES:\n-        s = s.replace(find, repl)\n-    return s\n-\n-\n-def block_trim(s):\n-    lns = s.splitlines()\n-\n-    # remove leading/trailing whitespace-lines\n-    while lns and not lns[0].strip():\n-        lns = lns[1:]\n-    while lns and not lns[-1].strip():\n-        lns = lns[:-1]\n-\n-    # remove leading horizontal whitespace\n-    n = sys.maxsize\n-    for ln in lns:\n-        if ln.strip():\n-            n = min(n, len(re.search('^\\s*', ln).group()))\n-    if n != sys.maxsize:\n-        lns = [ln[n:] for ln in lns]\n-\n-    # strip trailing whitespace\n-    lns = [ln.rstrip() for ln in lns]\n-\n-    return lns\n-\n-\n-def replace_doc(m):\n-    indent = m.group('indent')\n-    text = block_trim(unescape(m.group('text')))\n-\n-    if len(text) > 1:\n-        inner = '!' if m.group('semi') else '*'\n-        starify = lambda s: indent + ' *' + (' ' + s if s else '')\n-        text = '\\n'.join(map(starify, text))\n-        repl = indent + '/*' + inner + '\\n' + text + '\\n' + indent + ' */'\n-    else:\n-        inner = '!' if m.group('semi') else '/'\n-        repl = indent + '//' + inner + ' ' + text[0]\n-\n-    return repl\n-\n-\n-def sugarise_file(path):\n-    s = open(path).read()\n-\n-    r = re.compile(DOC_PATTERN, re.MULTILINE | re.DOTALL)\n-    ns = re.sub(r, replace_doc, s)\n-\n-    if s != ns:\n-        open(path, 'w').write(ns)\n-\n-for (dirpath, dirnames, filenames) in os.walk('.'):\n-    for name in fnmatch.filter(filenames, '*.r[sc]'):\n-        sugarise_file(os.path.join(dirpath, name))"}, {"sha": "98d6202a63fbf75468bcf71206a540329d8efa9b", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -107,6 +107,8 @@ imports.env = {\n   exp2f: function(x) { return Math.pow(2, x); },\n   ldexp: function(x, y) { return x * Math.pow(2, y); },\n   ldexpf: function(x, y) { return x * Math.pow(2, y); },\n+  log: Math.log,\n+  log2: Math.log2,\n   log10: Math.log10,\n   log10f: Math.log10,\n "}, {"sha": "762f9565b7802e41a93ca3e693d96ea825fb03c2", "filename": "src/etc/ziggurat_tables.py", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fetc%2Fziggurat_tables.py", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Fetc%2Fziggurat_tables.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fziggurat_tables.py?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,127 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# This creates the tables used for distributions implemented using the\n-# ziggurat algorithm in `rand::distributions;`. They are\n-# (basically) the tables as used in the ZIGNOR variant (Doornik 2005).\n-# They are changed rarely, so the generated file should be checked in\n-# to git.\n-#\n-# It creates 3 tables: X as in the paper, F which is f(x_i), and\n-# F_DIFF which is f(x_i) - f(x_{i-1}). The latter two are just cached\n-# values which is not done in that paper (but is done in other\n-# variants). Note that the adZigR table is unnecessary because of\n-# algebra.\n-#\n-# It is designed to be compatible with Python 2 and 3.\n-\n-from math import exp, sqrt, log, floor\n-import random\n-\n-# The order should match the return value of `tables`\n-TABLE_NAMES = ['X', 'F']\n-\n-# The actual length of the table is 1 more, to stop\n-# index-out-of-bounds errors. This should match the bitwise operation\n-# to find `i` in `zigurrat` in `libstd/rand/mod.rs`. Also the *_R and\n-# *_V constants below depend on this value.\n-TABLE_LEN = 256\n-\n-# equivalent to `zigNorInit` in Doornik2005, but generalised to any\n-# distribution. r = dR, v = dV, f = probability density function,\n-# f_inv = inverse of f\n-def tables(r, v, f, f_inv):\n-    # compute the x_i\n-    xvec = [0]*(TABLE_LEN+1)\n-\n-    xvec[0] = v / f(r)\n-    xvec[1] = r\n-\n-    for i in range(2, TABLE_LEN):\n-        last = xvec[i-1]\n-        xvec[i] = f_inv(v / last + f(last))\n-\n-    # cache the f's\n-    fvec = [0]*(TABLE_LEN+1)\n-    for i in range(TABLE_LEN+1):\n-        fvec[i] = f(xvec[i])\n-\n-    return xvec, fvec\n-\n-# Distributions\n-# N(0, 1)\n-def norm_f(x):\n-    return exp(-x*x/2.0)\n-def norm_f_inv(y):\n-    return sqrt(-2.0*log(y))\n-\n-NORM_R = 3.6541528853610088\n-NORM_V = 0.00492867323399\n-\n-NORM = tables(NORM_R, NORM_V,\n-              norm_f, norm_f_inv)\n-\n-# Exp(1)\n-def exp_f(x):\n-    return exp(-x)\n-def exp_f_inv(y):\n-    return -log(y)\n-\n-EXP_R = 7.69711747013104972\n-EXP_V = 0.0039496598225815571993\n-\n-EXP = tables(EXP_R, EXP_V,\n-             exp_f, exp_f_inv)\n-\n-\n-# Output the tables/constants/types\n-\n-def render_static(name, type, value):\n-    # no space or\n-    return 'pub static %s: %s =%s;\\n' % (name, type, value)\n-\n-# static `name`: [`type`, .. `len(values)`] =\n-#     [values[0], ..., values[3],\n-#      values[4], ..., values[7],\n-#      ... ];\n-def render_table(name, values):\n-    rows = []\n-    # 4 values on each row\n-    for i in range(0, len(values), 4):\n-        row = values[i:i+4]\n-        rows.append(', '.join('%.18f' % f for f in row))\n-\n-    rendered = '\\n    [%s]' % ',\\n     '.join(rows)\n-    return render_static(name, '[f64, .. %d]' % len(values), rendered)\n-\n-\n-with open('ziggurat_tables.rs', 'w') as f:\n-    f.write('''// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tables for distributions which are sampled using the ziggurat\n-// algorithm. Autogenerated by `ziggurat_tables.py`.\n-\n-pub type ZigTable = &\\'static [f64, .. %d];\n-'''  % (TABLE_LEN + 1))\n-    for name, tables, r in [('NORM', NORM, NORM_R),\n-                            ('EXP', EXP, EXP_R)]:\n-        f.write(render_static('ZIG_%s_R' % name, 'f64', ' %.18f' % r))\n-        for (tabname, table) in zip(TABLE_NAMES, tables):\n-            f.write(render_table('ZIG_%s_%s' % (name, tabname), table))"}, {"sha": "3bf919b0c0016e3c689b87146e5a0ba30c940f22", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -12,7 +12,7 @@ core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n [dev-dependencies]\n-rand = \"0.3\"\n+rand = \"0.4\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "fdc4efc66b988a9df322a083285ba8d6809dec38", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -373,6 +373,24 @@ impl fmt::Display for CannotReallocInPlace {\n     }\n }\n \n+/// Augments `AllocErr` with a CapacityOverflow variant.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+pub enum CollectionAllocErr {\n+    /// Error due to the computed capacity exceeding the collection's maximum\n+    /// (usually `isize::MAX` bytes).\n+    CapacityOverflow,\n+    /// Error due to the allocator (see the `AllocErr` type's docs).\n+    AllocErr(AllocErr),\n+}\n+\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<AllocErr> for CollectionAllocErr {\n+    fn from(err: AllocErr) -> Self {\n+        CollectionAllocErr::AllocErr(err)\n+    }\n+}\n+\n /// An implementation of `Alloc` can allocate, reallocate, and\n /// deallocate arbitrary blocks of data described via `Layout`.\n ///"}, {"sha": "2de0ffb4b26113a69f58feb8a525b283670585d1", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -13,7 +13,6 @@\n #![feature(i128_type)]\n #![feature(rand)]\n #![feature(repr_simd)]\n-#![feature(slice_rotate)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "8aaac5d6e08a53d9f908b81c845a4bced2ec79ca", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -964,7 +964,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n /// An owning iterator over the elements of a `BinaryHeap`.\n@@ -1019,7 +1019,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n /// A draining iterator over the elements of a `BinaryHeap`.\n@@ -1065,7 +1065,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]"}, {"sha": "b776556d59f11b033500d34cafd1ec13b4cf4435", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -359,8 +359,6 @@ impl<T: ?Sized> Box<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// #![feature(box_leak)]\n-    ///\n     /// fn main() {\n     ///     let x = Box::new(41);\n     ///     let static_ref: &'static mut usize = Box::leak(x);\n@@ -372,17 +370,14 @@ impl<T: ?Sized> Box<T> {\n     /// Unsized data:\n     ///\n     /// ```\n-    /// #![feature(box_leak)]\n-    ///\n     /// fn main() {\n     ///     let x = vec![1, 2, 3].into_boxed_slice();\n     ///     let static_ref = Box::leak(x);\n     ///     static_ref[0] = 4;\n     ///     assert_eq!(*static_ref, [4, 2, 3]);\n     /// }\n     /// ```\n-    #[unstable(feature = \"box_leak\", reason = \"needs an FCP to stabilize\",\n-               issue = \"46179\")]\n+    #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n     pub fn leak<'a>(b: Box<T>) -> &'a mut T\n     where\n@@ -727,7 +722,7 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n \n "}, {"sha": "ed9c8c18f0d6db7059d65d77a78b59af9b3a1b72", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1156,7 +1156,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1235,7 +1235,7 @@ impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1365,7 +1365,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1395,7 +1395,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1432,7 +1432,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1482,7 +1482,7 @@ impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n \n \n@@ -1561,7 +1561,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Range<'a, K, V> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -1630,7 +1630,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for RangeMut<'a, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n@@ -2114,7 +2114,6 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(entry_and_modify)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n@@ -2129,7 +2128,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     ///    .or_insert(42);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"entry_and_modify\", issue = \"44733\")]\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n     pub fn and_modify<F>(self, mut f: F) -> Self\n         where F: FnMut(&mut V)\n     {"}, {"sha": "2e3157147a085b9a8086c4ad48fd83584a87662c", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -946,7 +946,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -971,7 +971,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -997,7 +997,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Range<'a, T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n@@ -1044,7 +1044,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Difference<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1078,7 +1078,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for SymmetricDifference<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1116,7 +1116,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Intersection<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1150,5 +1150,5 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Union<'a, T> {}"}, {"sha": "2c4cdef03b0f7d3f7ed331a5f2e0ef2c47963970", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -113,6 +113,8 @@\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n+//! * `x?` \u21d2 [`Debug`] with lower-case hexadecimal integers\n+//! * `X?` \u21d2 [`Debug`] with lower-case hexadecimal integers\n //! * `o` \u21d2 [`Octal`](trait.Octal.html)\n //! * `x` \u21d2 [`LowerHex`](trait.LowerHex.html)\n //! * `X` \u21d2 [`UpperHex`](trait.UpperHex.html)"}, {"sha": "c13ad39e5e1d598a8f9b40f15ff572a271417a4d", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -228,14 +228,6 @@ unsafe impl Alloc for Heap {\n     }\n }\n \n-/// An arbitrary non-null address to represent zero-size allocations.\n-///\n-/// This preserves the non-null invariant for types like `Box<T>`. The address\n-/// may overlap with non-zero-size memory allocations.\n-#[rustc_deprecated(since = \"1.19.0\", reason = \"Use Unique/NonNull::empty() instead\")]\n-#[unstable(feature = \"heap_api\", issue = \"27700\")]\n-pub const EMPTY: *mut () = 1 as *mut ();\n-\n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n #[cfg(not(test))]"}, {"sha": "2727bcaa28a9311c9f8d8d5bbdf5ced4ddde410c", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -79,7 +79,6 @@\n #![cfg_attr(test, feature(placement_in))]\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n-#![cfg_attr(not(test), feature(slice_rotate))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]\n@@ -97,10 +96,8 @@\n #![feature(fmt_internals)]\n #![feature(from_ref)]\n #![feature(fundamental)]\n-#![feature(fused)]\n #![feature(generic_param_attrs)]\n #![feature(i128_type)]\n-#![feature(inclusive_range)]\n #![feature(iter_rfold)]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n@@ -119,14 +116,17 @@\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(exact_chunks)]\n+#![feature(pointer_methods)]\n+#![feature(inclusive_range_fields)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n+#![cfg_attr(not(test), feature(fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "097d2e414f5cc953fedd04808278f5637fc64abe", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -747,8 +747,8 @@ impl<T> LinkedList<T> {\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded.\n-    /// If the closure returns false, it will try again, and call the closure on the next element,\n-    /// seeing if it passes the test.\n+    /// If the closure returns false, the element will remain in the list and will not be yielded\n+    /// by the iterator.\n     ///\n     /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n     /// whether you choose to keep or remove it.\n@@ -897,7 +897,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -946,7 +946,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n@@ -1117,7 +1117,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b03abc8518087addd1b7d8976c3a0a1f45e06ca8", "filename": "src/liballoc/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -103,7 +103,7 @@ impl<T> RangeArgument<T> for Range<T> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> RangeArgument<T> for RangeInclusive<T> {\n     fn start(&self) -> Bound<&T> {\n         Included(&self.start)\n@@ -113,7 +113,7 @@ impl<T> RangeArgument<T> for RangeInclusive<T> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> RangeArgument<T> for RangeToInclusive<T> {\n     fn start(&self) -> Bound<&T> {\n         Unbounded"}, {"sha": "229ae54d7474adffd634883aa654b69b32518698", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -15,6 +15,8 @@ use core::ptr::{self, Unique};\n use core::slice;\n use heap::{Alloc, Layout, Heap};\n use super::boxed::Box;\n+use super::allocator::CollectionAllocErr;\n+use super::allocator::CollectionAllocErr::*;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -84,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let elem_size = mem::size_of::<T>();\n \n             let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(alloc_size);\n+            alloc_guard(alloc_size).expect(\"capacity overflow\");\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n@@ -308,7 +310,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n-                    alloc_guard(new_size);\n+                    alloc_guard(new_size).expect(\"capacity overflow\");\n                     let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                                  cur,\n                                                  new_layout);\n@@ -367,7 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n-            alloc_guard(new_size);\n+            alloc_guard(new_size).expect(\"capacity overflow\");\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n@@ -403,7 +405,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+           -> Result<(), CollectionAllocErr> {\n+\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -413,43 +417,50 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they gave a bad `used_cap`.\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+                return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            alloc_guard(new_layout.size());\n+            let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+            alloc_guard(new_layout.size())?;\n+\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve_exact(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n+\n     /// Calculates the buffer's new size given that it'll hold `used_cap +\n     /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<usize, CollectionAllocErr> {\n+\n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap)\n-            .expect(\"capacity overflow\");\n+        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n-        cmp::max(double_cap, required_cap)\n+        Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -504,8 +515,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        unsafe {\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -514,33 +526,38 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they give a bad `used_cap`\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+               return Ok(());\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+             // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size())?;\n \n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    /// The same as try_reserve, but errors are lowered to a call to oom().\n+    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -576,7 +593,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+                              .expect(\"capacity overflow\");\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n@@ -585,7 +603,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n+            alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -709,14 +727,14 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g. PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) {\n-    if mem::size_of::<usize>() < 8 {\n-        assert!(alloc_size <= ::core::isize::MAX as usize,\n-                \"capacity overflow\");\n+fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+    if mem::size_of::<usize>() < 8 && alloc_size > ::core::isize::MAX as usize {\n+        Err(CapacityOverflow)\n+    } else {\n+        Ok(())\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "dc40062ef13df5ebccebd317cbb8be313bb75c23", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1460,8 +1460,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a.rotate_left(2);\n     /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n@@ -1470,23 +1468,15 @@ impl<T> [T] {\n     /// Rotating a subslice:\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_left(1);\n     /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-    /// ```\n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+   /// ```\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         core_slice::SliceExt::rotate_left(self, mid);\n     }\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n-    #[rustc_deprecated(since = \"\", reason = \"renamed to `rotate_left`\")]\n-    pub fn rotate(&mut self, mid: usize) {\n-        core_slice::SliceExt::rotate_left(self, mid);\n-    }\n-\n     /// Rotates the slice in-place such that the first `self.len() - k`\n     /// elements of the slice move to the end while the last `k` elements move\n     /// to the front. After calling `rotate_right`, the element previously at\n@@ -1505,8 +1495,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a.rotate_right(2);\n     /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n@@ -1515,13 +1503,11 @@ impl<T> [T] {\n     /// Rotate a subslice:\n     ///\n     /// ```\n-    /// #![feature(slice_rotate)]\n-    ///\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_right(1);\n     /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n     /// ```\n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         core_slice::SliceExt::rotate_right(self, k);\n     }"}, {"sha": "14d5e96d2e73a87853ea103a9abe18bd768c1b40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -43,6 +43,7 @@ use core::str as core_str;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n+use core::ptr;\n use core::iter::FusedIterator;\n use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n@@ -171,7 +172,7 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for EncodeUtf16<'a> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2066,9 +2067,59 @@ impl str {\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n-        let mut s = String::with_capacity(self.len() * n);\n-        s.extend((0..n).map(|_| self));\n-        s\n+        if n == 0 {\n+            return String::new();\n+        }\n+\n+        // If `n` is larger than zero, it can be split as\n+        // `n = 2^expn + rem (2^expn > rem, expn >= 0, rem >= 0)`.\n+        // `2^expn` is the number represented by the leftmost '1' bit of `n`,\n+        // and `rem` is the remaining part of `n`.\n+\n+        // Using `Vec` to access `set_len()`.\n+        let mut buf = Vec::with_capacity(self.len() * n);\n+\n+        // `2^expn` repetition is done by doubling `buf` `expn`-times.\n+        buf.extend(self.as_bytes());\n+        {\n+            let mut m = n >> 1;\n+            // If `m > 0`, there are remaining bits up to the leftmost '1'.\n+            while m > 0 {\n+                // `buf.extend(buf)`:\n+                unsafe {\n+                    ptr::copy_nonoverlapping(\n+                        buf.as_ptr(),\n+                        (buf.as_mut_ptr() as *mut u8).add(buf.len()),\n+                        buf.len(),\n+                    );\n+                    // `buf` has capacity of `self.len() * n`.\n+                    let buf_len = buf.len();\n+                    buf.set_len(buf_len * 2);\n+                }\n+\n+                m >>= 1;\n+            }\n+        }\n+\n+        // `rem` (`= n - 2^expn`) repetition is done by copying\n+        // first `rem` repetitions from `buf` itself.\n+        let rem_len = self.len() * n - buf.len(); // `self.len() * rem`\n+        if rem_len > 0 {\n+            // `buf.extend(buf[0 .. rem_len])`:\n+            unsafe {\n+                // This is non-overlapping since `2^expn > rem`.\n+                ptr::copy_nonoverlapping(\n+                    buf.as_ptr(),\n+                    (buf.as_mut_ptr() as *mut u8).add(buf.len()),\n+                    rem_len,\n+                );\n+                // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n+                let buf_cap = buf.capacity();\n+                buf.set_len(buf_cap);\n+            }\n+        }\n+\n+        unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n     /// Checks if all characters in this string are within the ASCII range."}, {"sha": "9fec90914985d83b567bd80bd87170b26cf38696", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -71,6 +71,7 @@ use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n+use super::allocator::CollectionAllocErr;\n \n /// A UTF-8 encoded, growable string.\n ///\n@@ -364,7 +365,7 @@ impl String {\n     ///\n     /// Given that the `String` is empty, this will not allocate any initial\n     /// buffer. While that means that this initial operation is very\n-    /// inexpensive, but may cause excessive allocation later, when you add\n+    /// inexpensive, it may cause excessive allocation later when you add\n     /// data. If you have an idea of how much data the `String` will hold,\n     /// consider the [`with_capacity`] method to prevent excessive\n     /// re-allocation.\n@@ -920,6 +921,79 @@ impl String {\n         self.vec.reserve_exact(additional)\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `String`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.vec.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `String`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.vec.try_reserve_exact(additional)\n+    }\n+\n     /// Shrinks the capacity of this `String` to match its length.\n     ///\n     /// # Examples\n@@ -1876,7 +1950,7 @@ impl ops::Index<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::Index<ops::RangeInclusive<usize>> for String {\n     type Output = str;\n \n@@ -1885,7 +1959,7 @@ impl ops::Index<ops::RangeInclusive<usize>> for String {\n         Index::index(&**self, index)\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::Index<ops::RangeToInclusive<usize>> for String {\n     type Output = str;\n \n@@ -1923,14 +1997,14 @@ impl ops::IndexMut<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n@@ -2254,5 +2328,5 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Drain<'a> {}"}, {"sha": "5c979d82e55dc701cfbcf2f8ca0211349ea4b6c5", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::panic;\n+use std::cmp;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::panic::{self, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+use rand::{thread_rng, Rng};\n \n #[test]\n fn test_iterator() {\n@@ -300,3 +304,80 @@ fn assert_covariance() {\n         d\n     }\n }\n+\n+// old binaryheap failed this test\n+//\n+// Integrity means that all elements are present after a comparison panics,\n+// even if the order may not be correct.\n+//\n+// Destructors must be called exactly once per element.\n+#[test]\n+fn panic_safe() {\n+    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    #[derive(Eq, PartialEq, Ord, Clone, Debug)]\n+    struct PanicOrd<T>(T, bool);\n+\n+    impl<T> Drop for PanicOrd<T> {\n+        fn drop(&mut self) {\n+            // update global drop count\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    impl<T: PartialOrd> PartialOrd for PanicOrd<T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+            if self.1 || other.1 {\n+                panic!(\"Panicking comparison\");\n+            }\n+            self.0.partial_cmp(&other.0)\n+        }\n+    }\n+    let mut rng = thread_rng();\n+    const DATASZ: usize = 32;\n+    const NTEST: usize = 10;\n+\n+    // don't use 0 in the data -- we want to catch the zeroed-out case.\n+    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+\n+    // since it's a fuzzy test, run several tries.\n+    for _ in 0..NTEST {\n+        for i in 1..DATASZ + 1 {\n+            DROP_COUNTER.store(0, Ordering::SeqCst);\n+\n+            let mut panic_ords: Vec<_> = data.iter()\n+                                             .filter(|&&x| x != i)\n+                                             .map(|&x| PanicOrd(x, false))\n+                                             .collect();\n+            let panic_item = PanicOrd(i, true);\n+\n+            // heapify the sane items\n+            rng.shuffle(&mut panic_ords);\n+            let mut heap = BinaryHeap::from(panic_ords);\n+            let inner_data;\n+\n+            {\n+                // push the panicking item to the heap and catch the panic\n+                let thread_result = {\n+                    let mut heap_ref = AssertUnwindSafe(&mut heap);\n+                    panic::catch_unwind(move || {\n+                        heap_ref.push(panic_item);\n+                    })\n+                };\n+                assert!(thread_result.is_err());\n+\n+                // Assert no elements were dropped\n+                let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+                assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n+                inner_data = heap.clone().into_vec();\n+                drop(heap);\n+            }\n+            let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+            assert_eq!(drops, DATASZ);\n+\n+            let mut data_sorted = inner_data.into_iter().map(|p| p.0).collect::<Vec<_>>();\n+            data_sorted.sort();\n+            assert_eq!(data_sorted, data);\n+        }\n+    }\n+}"}, {"sha": "bcd2ef27605830ec678ee59b4884715bf9918389", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,7 +14,7 @@\n #![feature(alloc_system)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n-#![feature(inclusive_range_syntax)]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(collection_placement)]\n #![feature(const_fn)]\n #![feature(drain_filter)]\n@@ -23,13 +23,14 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(slice_rotate)]\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(exact_chunks)]\n+#![feature(inclusive_range_fields)]\n \n extern crate alloc_system;\n extern crate std_unicode;"}, {"sha": "d9e9d91cea88a06d5a39d74363610a3991945477", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cell::Cell;\n use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::cmp::Ordering;\n use std::mem;\n+use std::panic;\n use std::rc::Rc;\n+use std::sync::atomic::Ordering::Relaxed;\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::thread;\n \n use rand::{Rng, thread_rng};\n \n@@ -1341,3 +1347,162 @@ fn test_copy_from_slice_dst_shorter() {\n     let mut dst = [0; 3];\n     dst.copy_from_slice(&src);\n }\n+\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n+    // FIXME #5244: AtomicUsize is not Copy.\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+];\n+\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n+    }\n+}\n+\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n+\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n+\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n+        }\n+    }\n+}\n+\n+thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+fn panic_safe() {\n+    let prev = panic::take_hook();\n+    panic::set_hook(Box::new(move |info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    }));\n+\n+    let mut rng = thread_rng();\n+\n+    for len in (1..20).chain(70..MAX_LEN) {\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n+                }\n+\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n+        }\n+    }\n+}"}, {"sha": "d1e746ea43b45516875e87f7d30f94f0e194556d", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n use std::borrow::Cow;\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B>;\n@@ -504,3 +507,163 @@ fn test_into_boxed_str() {\n     let ys = xs.into_boxed_str();\n     assert_eq!(&*ys, \"hello my name is bob\");\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut s = String::new();\n+    assert_eq!(s.capacity(), 0);\n+\n+    s.reserve_exact(2);\n+    assert!(s.capacity() >= 2);\n+\n+    for _i in 0..16 {\n+        s.push('0');\n+    }\n+\n+    assert!(s.capacity() >= 16);\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 32);\n+\n+    s.push('0');\n+\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_string: String = String::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_string: String = String::new();\n+\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "3c17a401bbaf5793b4d63486d8ad3121b879c0a5", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 208, "deletions": 1, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -10,8 +10,9 @@\n \n use std::borrow::Cow;\n use std::mem::size_of;\n-use std::panic;\n+use std::{usize, isize, panic};\n use std::vec::{Drain, IntoIter};\n+use std::collections::CollectionAllocErr::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -965,3 +966,209 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut v = Vec::new();\n+    assert_eq!(v.capacity(), 0);\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "fc1a0b624a555eebde59edf875a7f459074800bc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -11,6 +11,9 @@\n use std::collections::VecDeque;\n use std::fmt::Debug;\n use std::collections::vec_deque::{Drain};\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n use self::Taggy::*;\n use self::Taggypar::*;\n@@ -1022,3 +1025,208 @@ fn test_placement_in() {\n     }\n     assert_eq!(buf, [5,4,3,1,2,6]);\n }\n+\n+#[test]\n+fn test_reserve_exact_2() {\n+    // This is all the same as test_reserve\n+\n+    let mut v = VecDeque::new();\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push_back(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push_back(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 48)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "953f95876be1586763d384ec54b6edf5b7c5cfa0", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 107, "deletions": 138, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -86,6 +86,7 @@ use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n use super::range::RangeArgument;\n+use super::allocator::CollectionAllocErr;\n use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n@@ -489,6 +490,83 @@ impl<T> Vec<T> {\n         self.buf.reserve_exact(self.len, additional);\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.buf.try_reserve(self.len, additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.buf.try_reserve_exact(self.len, additional)\n+    }\n+\n     /// Shrinks the capacity of the vector as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator\n@@ -1212,8 +1290,9 @@ impl<T: Clone> Vec<T> {\n     /// difference, with each additional slot filled with `value`.\n     /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n     ///\n-    /// This method requires `Clone` to clone the passed value. If you'd\n-    /// rather create a value with `Default` instead, see [`resize_default`].\n+    /// This method requires [`Clone`] to be able clone the passed value. If\n+    /// you'd rather create a value with [`Default`] instead, see\n+    /// [`resize_default`].\n     ///\n     /// # Examples\n     ///\n@@ -1227,6 +1306,8 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n     ///\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n+    /// [`Default`]: ../../std/default/trait.Default.html\n     /// [`resize_default`]: #method.resize_default\n     #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n@@ -1244,7 +1325,7 @@ impl<T: Clone> Vec<T> {\n     /// Iterates over the slice `other`, clones each element, and then appends\n     /// it to this `Vec`. The `other` vector is traversed in-order.\n     ///\n-    /// Note that this function is same as `extend` except that it is\n+    /// Note that this function is same as [`extend`] except that it is\n     /// specialized to work with slices instead. If and when Rust gets\n     /// specialization this function will likely be deprecated (but still\n     /// available).\n@@ -1256,6 +1337,8 @@ impl<T: Clone> Vec<T> {\n     /// vec.extend_from_slice(&[2, 3, 4]);\n     /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n+    ///\n+    /// [`extend`]: #method.extend\n     #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n@@ -1266,12 +1349,11 @@ impl<T: Default> Vec<T> {\n     /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n     ///\n     /// If `new_len` is greater than `len`, the `Vec` is extended by the\n-    /// difference, with each additional slot filled with `Default::default()`.\n+    /// difference, with each additional slot filled with [`Default::default()`].\n     /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n     ///\n-    /// This method uses `Default` to create new values on every push. If\n-    /// you'd rather `Clone` a given value, use [`resize`].\n-    ///\n+    /// This method uses [`Default`] to create new values on every push. If\n+    /// you'd rather [`Clone`] a given value, use [`resize`].\n     ///\n     /// # Examples\n     ///\n@@ -1288,6 +1370,9 @@ impl<T: Default> Vec<T> {\n     /// ```\n     ///\n     /// [`resize`]: #method.resize\n+    /// [`Default::default()`]: ../../std/default/trait.Default.html#tymethod.default\n+    /// [`Default`]: ../../std/default/trait.Default.html\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n     pub fn resize_default(&mut self, new_len: usize) {\n         let len = self.len();\n@@ -1527,142 +1612,26 @@ impl<T: Hash> Hash for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> Index<usize> for Vec<T> {\n-    type Output = T;\n-\n-    #[inline]\n-    fn index(&self, index: usize) -> &T {\n-        // NB built-in indexing via `&[T]`\n-        &(**self)[index]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> IndexMut<usize> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: usize) -> &mut T {\n-        // NB built-in indexing via `&mut [T]`\n-        &mut (**self)[index]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::Range<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, _index: ops::RangeFull) -> &[T] {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n-    type Output = [T];\n+impl<T, I> Index<I> for Vec<T>\n+where\n+    I: ::core::slice::SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n \n     #[inline]\n-    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n+    fn index(&self, index: I) -> &Self::Output {\n         Index::index(&**self, index)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n+impl<T, I> IndexMut<I> for Vec<T>\n+where\n+    I: ::core::slice::SliceIndex<[T]>,\n+{\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n+    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n@@ -1966,8 +1935,8 @@ impl<T> Vec<T> {\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded.\n-    /// If the closure returns false, it will try again, and call the closure\n-    /// on the next element, seeing if it passes the test.\n+    /// If the closure returns false, the element will remain in the vector and will not be yielded\n+    /// by the iterator.\n     ///\n     /// Using this method is equivalent to the following code:\n     ///\n@@ -2389,7 +2358,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -2495,7 +2464,7 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n \n /// A place for insertion at the back of a `Vec`."}, {"sha": "0658777f0a0e0bba40c15f012f7e352502f202eb", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -31,6 +31,7 @@ use core::cmp;\n \n use raw_vec::RawVec;\n \n+use super::allocator::CollectionAllocErr;\n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n@@ -566,6 +567,97 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve_exact(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        let old_cap = self.cap();\n+        let used_cap = self.len() + 1;\n+        let new_cap = used_cap.checked_add(additional)\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+\n+        if new_cap > old_cap {\n+            self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Shrinks the capacity of the `VecDeque` as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator may still inform the\n@@ -1991,7 +2083,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n \n@@ -2084,7 +2176,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n /// An owning iterator over the elements of a `VecDeque`.\n@@ -2140,7 +2232,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n /// A draining iterator over the elements of a `VecDeque`.\n@@ -2247,7 +2339,7 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "24529f7a9d8d42161d2a943ad95878e9f4569e98", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -16,3 +16,6 @@ path = \"../libcore/tests/lib.rs\"\n [[bench]]\n name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n+\n+[dev-dependencies]\n+rand = \"0.4\""}, {"sha": "a6ba53087ac3030c356b5a81fc62925a713f8d8f", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -349,31 +349,6 @@ pub struct TypeId {\n }\n \n impl TypeId {\n-    /// Returns the `TypeId` of the type this generic function has been\n-    /// instantiated with.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::any::{Any, TypeId};\n-    ///\n-    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n-    ///     TypeId::of::<String>() == TypeId::of::<T>()\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(stage0)]\n-    pub fn of<T: ?Sized + 'static>() -> TypeId {\n-        TypeId {\n-            t: unsafe { intrinsics::type_id::<T>() },\n-        }\n-    }\n-\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with.\n     ///\n@@ -393,7 +368,6 @@ impl TypeId {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature=\"const_type_id\")]\n-    #[cfg(not(stage0))]\n     pub const fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },"}, {"sha": "2c4bccebceb95247d45a42ffbba8130acc351df1", "filename": "src/libcore/ascii.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on ASCII strings and characters.\n+//!\n+//! Most string operations in Rust act on UTF-8 strings. However, at times it\n+//! makes more sense to only consider the ASCII character set for a specific\n+//! operation.\n+//!\n+//! The [`escape_default`] function provides an iterator over the bytes of an\n+//! escaped version of the character given.\n+//!\n+//! [`escape_default`]: fn.escape_default.html\n+\n+#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+\n+use fmt;\n+use ops::Range;\n+use iter::FusedIterator;\n+\n+/// An iterator over the escaped version of a byte.\n+///\n+/// This `struct` is created by the [`escape_default`] function. See its\n+/// documentation for more.\n+///\n+/// [`escape_default`]: fn.escape_default.html\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n+}\n+\n+/// Returns an iterator that produces an escaped version of a `u8`.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// * Tab is escaped as `\\t`.\n+/// * Carriage return is escaped as `\\r`.\n+/// * Line feed is escaped as `\\n`.\n+/// * Single quote is escaped as `\\'`.\n+/// * Double quote is escaped as `\\\"`.\n+/// * Backslash is escaped as `\\\\`.\n+/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n+///   inclusive is not escaped.\n+/// * Any other chars are given hex escapes of the form '\\xNN'.\n+/// * Unicode escapes are never generated by this function.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ascii;\n+///\n+/// let escaped = ascii::escape_default(b'0').next().unwrap();\n+/// assert_eq!(b'0', escaped);\n+///\n+/// let mut escaped = ascii::escape_default(b'\\t');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b't', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\r');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'r', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\n');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'n', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\'');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\'', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\"');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\"', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\\\');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\x9d');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'x', escaped.next().unwrap());\n+/// assert_eq!(b'9', escaped.next().unwrap());\n+/// assert_eq!(b'd', escaped.next().unwrap());\n+/// ```\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub fn escape_default(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: 0..len, data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeDefault {}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EscapeDefault { .. }\")\n+    }\n+}"}, {"sha": "6c597301ac2045cfeea0158268455c9d6eb19364", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -281,3 +281,32 @@ bench_sums! {\n     bench_take_while_chain_ref_sum,\n     (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n }\n+\n+// Checks whether Skip<Zip<A,B>> is as fast as Zip<Skip<A>, Skip<B>>, from\n+// https://users.rust-lang.org/t/performance-difference-between-iterator-zip-and-skip-order/15743\n+#[bench]\n+fn bench_zip_then_skip(b: &mut Bencher) {\n+    let v: Vec<_> = (0..100_000).collect();\n+    let t: Vec<_> = (0..100_000).collect();\n+\n+    b.iter(|| {\n+        let s = v.iter().zip(t.iter()).skip(10000)\n+            .take_while(|t| *t.0 < 10100)\n+            .map(|(a, b)| *a + *b)\n+            .sum::<u64>();\n+        assert_eq!(s, 2009900);\n+    });\n+}\n+#[bench]\n+fn bench_skip_then_zip(b: &mut Bencher) {\n+    let v: Vec<_> = (0..100_000).collect();\n+    let t: Vec<_> = (0..100_000).collect();\n+\n+    b.iter(|| {\n+        let s = v.iter().skip(10000).zip(t.iter().skip(10000))\n+            .take_while(|t| *t.0 < 10100)\n+            .map(|(a, b)| *a + *b)\n+            .sum::<u64>();\n+        assert_eq!(s, 2009900);\n+    });\n+}"}, {"sha": "36618e86968b5ea3d0fecf4c684bed1b6b0f0ca2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -10,6 +10,24 @@\n \n //! Shareable mutable containers.\n //!\n+//! Rust memory safety is based on this rule: Given an object `T`, it is only possible to\n+//! have one of the following:\n+//!\n+//! - Having several immutable references (`&T`) to the object (also known as **aliasing**).\n+//! - Having one mutable reference (`&mut T`) to the object (also known as **mutability**).\n+//!\n+//! This is enforced by the Rust compiler. However, there are situations where this rule is not\n+//! flexible enough. Sometimes it is required to have multiple references to an object and yet\n+//! mutate it.\n+//!\n+//! Shareable mutable containers exist to permit mutability in a controlled manner, even in the\n+//! presence of aliasing. Both `Cell<T>` and `RefCell<T>` allows to do this in a single threaded\n+//! way. However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement\n+//! `Sync`). If you need to do aliasing and mutation between multiple threads it is possible to\n+//! use [`Mutex`](../../std/sync/struct.Mutex.html),\n+//! [`RwLock`](../../std/sync/struct.RwLock.html) or\n+//! [`atomic`](../../core/sync/atomic/index.html) types.\n+//!\n //! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n //! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n //! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n@@ -863,6 +881,9 @@ impl<T: ?Sized> !Sync for RefCell<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently mutably borrowed.\n     #[inline]\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n@@ -880,6 +901,9 @@ impl<T:Default> Default for RefCell<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -891,26 +915,41 @@ impl<T: ?Sized + Eq> Eq for RefCell<T> {}\n \n #[stable(feature = \"cell_ord\", since = \"1.10.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn partial_cmp(&self, other: &RefCell<T>) -> Option<Ordering> {\n         self.borrow().partial_cmp(&*other.borrow())\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn lt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() < *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn le(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() <= *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn gt(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() > *other.borrow()\n     }\n \n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn ge(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() >= *other.borrow()\n@@ -919,6 +958,9 @@ impl<T: ?Sized + PartialOrd> PartialOrd for RefCell<T> {\n \n #[stable(feature = \"cell_ord\", since = \"1.10.0\")]\n impl<T: ?Sized + Ord> Ord for RefCell<T> {\n+    /// # Panics\n+    ///\n+    /// Panics if the value in either `RefCell` is currently borrowed.\n     #[inline]\n     fn cmp(&self, other: &RefCell<T>) -> Ordering {\n         self.borrow().cmp(&*other.borrow())\n@@ -1161,21 +1203,42 @@ impl<'a, T: ?Sized + fmt::Display> fmt::Display for RefMut<'a, T> {\n /// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n /// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n ///\n-/// The compiler makes optimizations based on the knowledge that `&T` is not mutably aliased or\n-/// mutated, and that `&mut T` is unique. When building abstractions like `Cell`, `RefCell`,\n-/// `Mutex`, etc, you need to turn these optimizations off. `UnsafeCell` is the only legal way\n-/// to do this. When `UnsafeCell<T>` is immutably aliased, it is still safe to obtain a mutable\n-/// reference to its interior and/or to mutate it. However, it is up to the abstraction designer\n-/// to ensure that no two mutable references obtained this way are active at the same time, and\n-/// that there are no active mutable references or mutations when an immutable reference is obtained\n-/// from the cell. This is often done via runtime checks.\n+/// If you have a reference `&SomeStruct`, then normally in Rust all fields of `SomeStruct` are\n+/// immutable. The compiler makes optimizations based on the knowledge that `&T` is not mutably\n+/// aliased or mutated, and that `&mut T` is unique. `UnsafeCel<T>` is the only core language\n+/// feature to work around this restriction. All other types that allow internal mutability, such as\n+/// `Cell<T>` and `RefCell<T>` use `UnsafeCell` to wrap their internal data.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way); it is still undefined behavior\n-/// to have multiple `&mut UnsafeCell<T>` aliases.\n+/// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n+/// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n+///\n+/// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n+///\n+/// - If you create a safe reference with lifetime `'a` (either a `&T` or `&mut T` reference) that\n+/// is accessible by safe code (for example, because you returned it), then you must not access\n+/// the data in any way that contradicts that reference for the remainder of `'a`. For example, that\n+/// means that if you take the `*mut T` from an `UnsafeCell<T>` and case it to an `&T`, then until\n+/// that reference's lifetime expires, the data in `T` must remain immutable (modulo any\n+/// `UnsafeCell` data found within `T`, of course). Similarly, if you create an `&mut T` reference\n+/// that is released to safe code, then you must not access the data within the `UnsafeCell` until\n+/// that reference expires.\n+///\n+/// - At all times, you must avoid data races, meaning that if multiple threads have access to\n+/// the same `UnsafeCell`, then any writes must have a proper happens-before relation to all other\n+/// accesses (or use atomics).\n ///\n+/// To assist with proper design, the following scenarios are explicitly declared legal\n+/// for single-threaded code:\n ///\n-/// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n+/// 1. A `&T` reference can be released to safe code and there it can co-exit with other `&T`\n+/// references, but not with a `&mut T`\n+///\n+/// 2. A `&mut T` reference may be released to safe code, provided neither other `&mut T` nor `&T`\n+/// co-exist with it. A `&mut T` must always be unique.\n+///\n+/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n+/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples\n ///\n@@ -1240,9 +1303,9 @@ impl<T: ?Sized> UnsafeCell<T> {\n     /// Gets a mutable pointer to the wrapped value.\n     ///\n     /// This can be cast to a pointer of any kind.\n-    /// Ensure that the access is unique when casting to\n-    /// `&mut T`, and ensure that there are no mutations or mutable\n-    /// aliases going on when casting to `&T`\n+    /// Ensure that the access is unique (no active references, mutable or not)\n+    /// when casting to `&mut T`, and ensure that there are no mutations\n+    /// or mutable aliases going on when casting to `&T`\n     ///\n     /// # Examples\n     ///"}, {"sha": "1638f9710f597a973abd466b8a071970c543c4a3", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -79,7 +79,7 @@ pub const MAX: char = '\\u{10ffff}';\n \n /// Converts a `u32` to a `char`.\n ///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n /// [`as`]:\n ///\n /// ```\n@@ -131,7 +131,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n \n /// Converts a `u32` to a `char`, ignoring validity.\n ///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n /// [`as`]:\n ///\n /// ```\n@@ -643,7 +643,7 @@ impl ExactSizeIterator for EscapeUnicode {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeUnicode {}\n \n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n@@ -756,7 +756,7 @@ impl ExactSizeIterator for EscapeDefault {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDefault {}\n \n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n@@ -790,7 +790,7 @@ impl Iterator for EscapeDebug {\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl ExactSizeIterator for EscapeDebug { }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n@@ -904,5 +904,5 @@ impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}"}, {"sha": "67445daa436024b54b0bae004af0c440d7c3fcd2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -343,7 +343,7 @@ impl Ordering {\n /// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n /// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n /// ```\n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n@@ -427,6 +427,7 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+#[cfg_attr(not(stage0), lang = \"ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`.\n@@ -596,7 +597,8 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n-#[lang = \"ord\"]\n+#[cfg_attr(stage0, lang = \"ord\")]\n+#[cfg_attr(not(stage0), lang = \"partial_ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n@@ -880,24 +882,24 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl Eq for ! {}\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self"}, {"sha": "3ecd73873c09195a35bff6fadac166a9111b523e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 151, "deletions": 9, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -333,7 +333,7 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n+enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, DebugLowerHex, DebugUpperHex }\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n@@ -684,18 +684,16 @@ pub trait Octal {\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n-/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n /// negative values are formatted as the two\u2019s complement representation.\n ///\n /// The alternate flag, `#`, adds a `0b` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n-/// [module]: ../../std/fmt/index.html\n-///\n /// # Examples\n ///\n-/// Basic usage with `i32`:\n+/// Basic usage with [`i32`]:\n ///\n /// ```\n /// let x = 42; // 42 is '101010' in binary\n@@ -725,6 +723,12 @@ pub trait Octal {\n ///\n /// println!(\"l as binary is: {:b}\", l);\n /// ```\n+///\n+/// [module]: ../../std/fmt/index.html\n+/// [`i8`]: ../../std/primitive.i8.html\n+/// [`i128`]: ../../std/primitive.i128.html\n+/// [`isize`]: ../../std/primitive.isize.html\n+/// [`i32`]: ../../std/primitive.i32.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n@@ -1375,32 +1379,170 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    /// Optionally specified integer width that the output should be\n+    /// Optionally specified integer width that the output should be.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(width) = formatter.width() {\n+    ///             // If we received a width, we use it\n+    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n+    ///         } else {\n+    ///             // Otherwise we do nothing special\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn width(&self) -> Option<usize> { self.width }\n \n-    /// Optionally specified precision for numeric types\n+    /// Optionally specified precision for numeric types.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(f32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(precision) = formatter.precision() {\n+    ///             // If we received a precision, we use it.\n+    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n+    ///         } else {\n+    ///             // Otherwise we default to 2.\n+    ///             write!(formatter, \"Foo({:.2})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n \n     /// Determines if the `+` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_plus() {\n+    ///             write!(formatter,\n+    ///                    \"Foo({}{})\",\n+    ///                    if self.0 < 0 { '-' } else { '+' },\n+    ///                    self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n \n     /// Determines if the `-` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_minus() {\n+    ///             // You want a minus sign? Have one!\n+    ///             write!(formatter, \"-Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n \n     /// Determines if the `#` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.alternate() {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"{}\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n \n     /// Determines if the `0` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         assert!(formatter.sign_aware_zero_pad());\n+    ///         assert_eq!(formatter.width(), Some(4));\n+    ///         // We ignore the formatter's options.\n+    ///         write!(formatter, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n         self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n     }\n \n+    // FIXME: Decide what public API we want for these two flags.\n+    // https://github.com/rust-lang/rust/issues/48584\n+    fn debug_lower_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0 }\n+\n+    fn debug_upper_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0 }\n+\n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n     /// [`fmt::Debug`] implementations for structs.\n     ///\n@@ -1575,14 +1717,14 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.26.0\")]\n impl Debug for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self\n     }\n }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.26.0\")]\n impl Display for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self"}, {"sha": "86f1b5a8f287546db828de5f0f7b9bbf7df448e4", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -159,7 +159,13 @@ macro_rules! debug {\n         impl fmt::Debug for $T {\n             #[inline]\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::Display::fmt(self, f)\n+                if f.debug_lower_hex() {\n+                    fmt::LowerHex::fmt(self, f)\n+                } else if f.debug_upper_hex() {\n+                    fmt::UpperHex::fmt(self, f)\n+                } else {\n+                    fmt::Display::fmt(self, f)\n+                }\n             }\n         }\n     }"}, {"sha": "ab714645675af153fb5473534cb4a0177694319a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -99,9 +99,10 @@ use mem;\n #[allow(deprecated)]\n pub use self::sip::SipHasher;\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[allow(deprecated)]\n-pub use self::sip::{SipHasher13, SipHasher24};\n+#[doc(hidden)]\n+pub use self::sip::SipHasher13;\n \n mod sip;\n "}, {"sha": "e3bdecdc4b1fd714ede210948c373d048bf30abe", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 12, "deletions": 44, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -23,22 +23,23 @@ use mem;\n /// (eg. `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n+#[doc(hidden)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n }\n \n /// An implementation of SipHash 2-4.\n ///\n /// See: <https://131002.net/siphash/>\n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n-pub struct SipHasher24 {\n+struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n }\n \n@@ -156,14 +157,16 @@ impl SipHasher {\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher(SipHasher24::new_with_keys(key0, key1))\n+        SipHasher(SipHasher24 {\n+            hasher: Hasher::new_with_keys(key0, key1)\n+        })\n     }\n }\n \n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher13 {\n@@ -172,7 +175,7 @@ impl SipHasher13 {\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n@@ -182,28 +185,6 @@ impl SipHasher13 {\n     }\n }\n \n-impl SipHasher24 {\n-    /// Creates a new `SipHasher24` with the two initial keys set to 0.\n-    #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n-    pub fn new() -> SipHasher24 {\n-        SipHasher24::new_with_keys(0, 0)\n-    }\n-\n-    /// Creates a `SipHasher24` that is keyed off the provided keys.\n-    #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n-        SipHasher24 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        }\n-    }\n-}\n-\n impl<S: Sip> Hasher<S> {\n     #[inline]\n     fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n@@ -271,16 +252,16 @@ impl<S: Sip> Hasher<S> {\n impl super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n-        self.0.write(msg)\n+        self.0.hasher.write(msg)\n     }\n \n     #[inline]\n     fn finish(&self) -> u64 {\n-        self.0.finish()\n+        self.0.hasher.finish()\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n impl super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n@@ -293,19 +274,6 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-impl super::Hasher for SipHasher24 {\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n-        self.hasher.write(msg)\n-    }\n-\n-    #[inline]\n-    fn finish(&self) -> u64 {\n-        self.hasher.finish()\n-    }\n-}\n-\n impl<S: Sip> super::Hasher for Hasher<S> {\n     // see short_write comment for explanation\n     #[inline]"}, {"sha": "830ebad065427fa3954552f99f90595702e96ff2", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1292,6 +1292,10 @@ extern \"rust-intrinsic\" {\n     /// Reverses the bytes in an integer type `T`.\n     pub fn bswap<T>(x: T) -> T;\n \n+    /// Reverses the bits in an integer type `T`.\n+    #[cfg(not(stage0))]\n+    pub fn bitreverse<T>(x: T) -> T;\n+\n     /// Performs checked integer addition.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,"}, {"sha": "2cfbc09229342b46c404134db13b77b1ca4e749d", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 144, "deletions": 40, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -12,7 +12,8 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::{AlwaysOk, LoopState};\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n use super::{ChainState, FromIterator, ZipImpl};\n@@ -168,7 +169,7 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than [`usize::MAX`]\n     /// elements.\n     ///\n-    /// [`usize::MAX`]: ../../std/isize/constant.MAX.html\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n     ///\n     /// # Examples\n     ///\n@@ -997,11 +998,15 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n+    /// You can think of [`flat_map(f)`][flat_map] as the semantic equivalent\n+    /// of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n+    ///\n     /// Another way of thinking about `flat_map()`: [`map`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n     /// [`map`]: #method.map\n+    /// [`flatten`]: #method.flatten\n     ///\n     /// # Examples\n     ///\n@@ -1021,7 +1026,79 @@ pub trait Iterator {\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n         where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n     {\n-        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+        FlatMap { inner: flatten_compat(self.map(f)) }\n+    }\n+\n+    /// Creates an iterator that flattens nested structure.\n+    ///\n+    /// This is useful when you have an iterator of iterators or an iterator of\n+    /// things that can be turned into iterators and you want to remove one\n+    /// level of indirection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\n+    /// let flattened = data.into_iter().flatten().collect::<Vec<u8>>();\n+    /// assert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    ///\n+    /// Mapping and then flattening:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .map(|s| s.chars())\n+    ///                           .flatten()\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// You can also rewrite this in terms of [`flat_map()`], which is preferable\n+    /// in this case since it conveys intent more clearly:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// Flattening once only removes one level of nesting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n+    ///\n+    /// let d2 = d3.iter().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);\n+    ///\n+    /// let d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);\n+    /// ```\n+    ///\n+    /// Here we see that `flatten()` does not perform a \"deep\" flatten.\n+    /// Instead, only one level of nesting is removed. That is, if you\n+    /// `flatten()` a three-dimensional array the result will be\n+    /// two-dimensional and not one-dimensional. To get a one-dimensional\n+    /// structure, you have to `flatten()` again.\n+    #[inline]\n+    #[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+    fn flatten(self) -> Flatten<Self>\n+    where Self: Sized, Self::Item: IntoIterator {\n+        Flatten { inner: flatten_compat(self) }\n     }\n \n     /// Creates an iterator which ends after the first [`None`].\n@@ -1103,26 +1180,27 @@ pub trait Iterator {\n     ///\n     /// // this iterator sequence is complex.\n     /// let sum = a.iter()\n-    ///             .cloned()\n-    ///             .filter(|&x| x % 2 == 0)\n-    ///             .fold(0, |sum, i| sum + i);\n+    ///     .cloned()\n+    ///     .filter(|x| x % 2 == 0)\n+    ///     .fold(0, |sum, i| sum + i);\n     ///\n     /// println!(\"{}\", sum);\n     ///\n     /// // let's add some inspect() calls to investigate what's happening\n     /// let sum = a.iter()\n-    ///             .cloned()\n-    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n-    ///             .filter(|&x| x % 2 == 0)\n-    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n-    ///             .fold(0, |sum, i| sum + i);\n+    ///     .cloned()\n+    ///     .inspect(|x| println!(\"about to filter: {}\", x))\n+    ///     .filter(|x| x % 2 == 0)\n+    ///     .inspect(|x| println!(\"made it through filter: {}\", x))\n+    ///     .fold(0, |sum, i| sum + i);\n     ///\n     /// println!(\"{}\", sum);\n     /// ```\n     ///\n     /// This will print:\n     ///\n     /// ```text\n+    /// 6\n     /// about to filter: 1\n     /// about to filter: 4\n     /// made it through filter: 4\n@@ -1153,8 +1231,7 @@ pub trait Iterator {\n     ///\n     /// let iter = a.into_iter();\n     ///\n-    /// let sum: i32 = iter.take(5)\n-    ///                    .fold(0, |acc, &i| acc + i );\n+    /// let sum: i32 = iter.take(5).fold(0, |acc, i| acc + i );\n     ///\n     /// assert_eq!(sum, 6);\n     ///\n@@ -1168,9 +1245,7 @@ pub trait Iterator {\n     /// let mut iter = a.into_iter();\n     ///\n     /// // instead, we add in a .by_ref()\n-    /// let sum: i32 = iter.by_ref()\n-    ///                    .take(2)\n-    ///                    .fold(0, |acc, &i| acc + i );\n+    /// let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i );\n     ///\n     /// assert_eq!(sum, 3);\n     ///\n@@ -1227,9 +1302,7 @@ pub trait Iterator {\n     ///\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled: VecDeque<i32> = a.iter()\n-    ///                               .map(|&x| x * 2)\n-    ///                               .collect();\n+    /// let doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();\n     ///\n     /// assert_eq!(2, doubled[0]);\n     /// assert_eq!(4, doubled[1]);\n@@ -1241,9 +1314,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled = a.iter()\n-    ///                .map(|&x| x * 2)\n-    ///                .collect::<Vec<i32>>();\n+    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n     ///\n     /// assert_eq!(vec![2, 4, 6], doubled);\n     /// ```\n@@ -1254,9 +1325,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled = a.iter()\n-    ///                .map(|&x| x * 2)\n-    ///                .collect::<Vec<_>>();\n+    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n     ///\n     /// assert_eq!(vec![2, 4, 6], doubled);\n     /// ```\n@@ -1267,9 +1336,9 @@ pub trait Iterator {\n     /// let chars = ['g', 'd', 'k', 'k', 'n'];\n     ///\n     /// let hello: String = chars.iter()\n-    ///                          .map(|&x| x as u8)\n-    ///                          .map(|x| (x + 1) as char)\n-    ///                          .collect();\n+    ///     .map(|&x| x as u8)\n+    ///     .map(|x| (x + 1) as char)\n+    ///     .collect();\n     ///\n     /// assert_eq!(\"hello\", hello);\n     /// ```\n@@ -1316,8 +1385,9 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n-    ///                                          .partition(|&n| n % 2 == 0);\n+    /// let (even, odd): (Vec<i32>, Vec<i32>) = a\n+    ///     .into_iter()\n+    ///     .partition(|&n| n % 2 == 0);\n     ///\n     /// assert_eq!(even, vec![2]);\n     /// assert_eq!(odd, vec![1, 3]);\n@@ -1366,9 +1436,9 @@ pub trait Iterator {\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n     /// from which this iterator is composed.  If multiple calls are needed,\n-    /// the `?` operator be convenient for chaining the accumulator value along,\n-    /// but beware any invariants that need to be upheld before those early\n-    /// returns.  This is a `&mut self` method, so iteration needs to be\n+    /// the `?` operator may be convenient for chaining the accumulator value\n+    /// along, but beware any invariants that need to be upheld before those\n+    /// early returns.  This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples\n@@ -1380,8 +1450,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3];\n     ///\n     /// // the checked sum of all of the elements of the array\n-    /// let sum = a.iter()\n-    ///            .try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    /// let sum = a.iter().try_fold(0i8, |acc, &x| acc.checked_add(x));\n     ///\n     /// assert_eq!(sum, Some(6));\n     /// ```\n@@ -1414,6 +1483,42 @@ pub trait Iterator {\n         Try::from_ok(accum)\n     }\n \n+    /// An iterator method that applies a fallible function to each item in the\n+    /// iterator, stopping at the first error and returning that error.\n+    ///\n+    /// This can also be thought of as the fallible form of [`for_each()`]\n+    /// or as the stateless version of [`try_fold()`].\n+    ///\n+    /// [`for_each()`]: #method.for_each\n+    /// [`try_fold()`]: #method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// use std::fs::rename;\n+    /// use std::io::{stdout, Write};\n+    /// use std::path::Path;\n+    ///\n+    /// let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n+    ///\n+    /// let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{}\", x));\n+    /// assert!(res.is_ok());\n+    ///\n+    /// let mut it = data.iter().cloned();\n+    /// let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\n+    /// assert!(res.is_err());\n+    /// // It short-circuited, so the remaining items are still in the iterator:\n+    /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n+    {\n+        self.try_fold((), move |(), x| f(x))\n+    }\n+\n     /// An iterator method that applies a function, producing a single, final value.\n     ///\n     /// `fold()` takes two arguments: an initial value, and a closure with two\n@@ -1443,8 +1548,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3];\n     ///\n     /// // the sum of all of the elements of the array\n-    /// let sum = a.iter()\n-    ///            .fold(0, |acc, &x| acc + x);\n+    /// let sum = a.iter().fold(0, |acc, x| acc + x);\n     ///\n     /// assert_eq!(sum, 6);\n     /// ```\n@@ -1532,7 +1636,7 @@ pub trait Iterator {\n     fn all<F>(&mut self, mut f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if f(x) { LoopState::Continue(()) }\n             else { LoopState::Break(()) }\n         }) == LoopState::Continue(())\n@@ -1581,7 +1685,7 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if f(x) { LoopState::Break(()) }\n             else { LoopState::Continue(()) }\n         }) == LoopState::Break(())\n@@ -1635,7 +1739,7 @@ pub trait Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_fold((), move |(), x| {\n+        self.try_for_each(move |x| {\n             if predicate(&x) { LoopState::Break(x) }\n             else { LoopState::Continue(()) }\n         }).break_value()"}, {"sha": "b1b783b47c72b1b19dc0a70834c020e6aaf2cd69", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 234, "deletions": 53, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -344,7 +344,7 @@ pub use self::sources::{Once, once};\n pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{ExactSizeIterator, Sum, Product};\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n pub use self::traits::FusedIterator;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n@@ -506,7 +506,7 @@ impl<I> ExactSizeIterator for Rev<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Rev<I>\n     where I: FusedIterator + DoubleEndedIterator {}\n \n@@ -589,7 +589,7 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n     where I: FusedIterator<Item=&'a T>, T: Clone\n {}\n@@ -662,7 +662,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n \n /// An iterator for stepping iterators by a custom amount.\n@@ -1002,7 +1002,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n     where A: FusedIterator,\n           B: FusedIterator<Item=A::Item>,\n@@ -1045,6 +1045,11 @@ impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         ZipImpl::size_hint(self)\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        ZipImpl::nth(self, n)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1065,6 +1070,14 @@ trait ZipImpl<A, B> {\n     fn new(a: A, b: B) -> Self;\n     fn next(&mut self) -> Option<Self::Item>;\n     fn size_hint(&self) -> (usize, Option<usize>);\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn super_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        while let Some(x) = self.next() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n     fn next_back(&mut self) -> Option<Self::Item>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator;\n@@ -1094,6 +1107,11 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         })\n     }\n \n+    #[inline]\n+    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.super_nth(n)\n+    }\n+\n     #[inline]\n     default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n@@ -1174,6 +1192,24 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         (len, Some(len))\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let delta = cmp::min(n, self.len - self.index);\n+        let end = self.index + delta;\n+        while self.index < end {\n+            let i = self.index;\n+            self.index += 1;\n+            if A::may_have_side_effect() {\n+                unsafe { self.a.get_unchecked(i); }\n+            }\n+            if B::may_have_side_effect() {\n+                unsafe { self.b.get_unchecked(i); }\n+            }\n+        }\n+\n+        self.super_nth(n - delta)\n+    }\n+\n     #[inline]\n     fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n@@ -1226,7 +1262,7 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Zip<A, B>\n     where A: FusedIterator, B: FusedIterator, {}\n \n@@ -1368,7 +1404,7 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n@@ -1517,7 +1553,7 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n     where P: FnMut(&I::Item) -> bool {}\n \n@@ -1627,7 +1663,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B> {}\n \n@@ -1782,7 +1818,7 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1902,7 +1938,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n \n impl<I: Iterator> Peekable<I> {\n@@ -2036,7 +2072,7 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for SkipWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n@@ -2115,7 +2151,7 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n@@ -2254,7 +2290,7 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n@@ -2335,7 +2371,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -2410,24 +2446,23 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    iter: I,\n-    f: F,\n-    frontiter: Option<U::IntoIter>,\n-    backiter: Option<U::IntoIter>,\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n     where U::IntoIter: fmt::Debug\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"frontiter\", &self.frontiter)\n-            .field(\"backiter\", &self.backiter)\n-            .finish()\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n     }\n }\n \n@@ -2437,17 +2472,173 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n {\n     type Item = U::Item;\n \n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let Some(x) = inner.by_ref().next() {\n-                    return Some(x)\n-                }\n+                if let elt@Some(_) = inner.next() { return elt }\n             }\n-            match self.iter.next().map(&mut self.f) {\n+            match self.iter.next() {\n                 None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                next => self.frontiter = next.map(IntoIterator::into_iter),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -2473,10 +2664,9 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         self.frontiter = None;\n \n         {\n-            let f = &mut self.f;\n             let frontiter = &mut self.frontiter;\n             init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_fold(acc, &mut fold);\n                 *frontiter = Some(mid);\n                 r\n@@ -2497,27 +2687,23 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n-    F: FnMut(I::Item) -> U,\n-    U: IntoIterator,\n-    U::IntoIter: DoubleEndedIterator\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let Some(y) = inner.next_back() {\n-                    return Some(y)\n-                }\n+                if let elt@Some(_) = inner.next_back() { return elt }\n             }\n-            match self.iter.next_back().map(&mut self.f) {\n+            match self.iter.next_back() {\n                 None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n@@ -2534,10 +2720,9 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         self.backiter = None;\n \n         {\n-            let f = &mut self.f;\n             let backiter = &mut self.backiter;\n             init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_rfold(acc, &mut fold);\n                 *backiter = Some(mid);\n                 r\n@@ -2558,16 +2743,12 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n ///\n@@ -2584,7 +2765,7 @@ pub struct Fuse<I> {\n     done: bool\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2715,7 +2896,7 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2757,7 +2938,7 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     }\n }\n \n-#[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> DoubleEndedIterator for Fuse<I>\n     where I: DoubleEndedIterator + FusedIterator\n {\n@@ -2901,6 +3082,6 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}"}, {"sha": "8d1080bb876efdfb164c8c09def52961a3d0b756", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -186,9 +186,7 @@ macro_rules! range_exact_iter_impl {\n \n macro_rules! range_incl_exact_iter_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n+        #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n         impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n     )*)\n }\n@@ -202,9 +200,7 @@ macro_rules! range_trusted_len_impl {\n \n macro_rules! range_incl_trusted_len_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n+        #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n         unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n     )*)\n }\n@@ -295,7 +291,7 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -322,13 +318,13 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<A: Step> TrustedLen for ops::RangeFrom<A> {}\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     type Item = A;\n \n@@ -422,7 +418,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -463,5 +459,5 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "0fc1a3aa8ac06c988764ef758a04198e9b1c5a37", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -41,7 +41,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Clone> FusedIterator for Repeat<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -135,7 +135,7 @@ impl<A, F: FnMut() -> A> DoubleEndedIterator for RepeatWith<F> {\n     fn next_back(&mut self) -> Option<A> { self.next() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -259,7 +259,7 @@ impl<T> ExactSizeIterator for Empty<T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for Empty<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Empty<T> {}\n \n // not #[derive] because that adds a Clone bound on T,\n@@ -340,7 +340,7 @@ impl<T> ExactSizeIterator for Once<T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for Once<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Once<T> {}\n \n /// Creates an iterator that yields an element exactly once."}, {"sha": "0267fcd375453cbcdd24f9f6e330ebdb3a65787f", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -959,10 +959,10 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n /// [`Fuse`]: ../../std/iter/struct.Fuse.html\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n pub trait FusedIterator: Iterator {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n \n /// An iterator that reports an accurate length using size_hint."}, {"sha": "9aebe2e4ee4b4eb90043592e704ead8ac43c618c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -68,31 +68,42 @@\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_type_defaults)]\n+#![feature(attr_literals)]\n #![feature(cfg_target_feature)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![feature(doc_cfg)]\n+#![feature(doc_spotlight)]\n+#![feature(fn_must_use)]\n #![feature(fundamental)]\n #![feature(i128_type)]\n-#![feature(inclusive_range_syntax)]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(intrinsics)]\n+#![feature(iterator_flatten)]\n+#![feature(iterator_repeat_with)]\n #![feature(lang_items)]\n-#![feature(never_type)]\n+#![feature(link_llvm_intrinsics)]\n+#![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n #![feature(optin_builtin_traits)]\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n+#![feature(rustc_const_unstable)]\n+#![feature(simd_ffi)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(target_feature)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n-#![feature(doc_spotlight)]\n-#![feature(rustc_const_unstable)]\n-#![feature(iterator_repeat_with)]\n+\n+#![cfg_attr(stage0, allow(unused_attributes))]\n+#![cfg_attr(stage0, feature(never_type))]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -157,6 +168,7 @@ pub mod borrow;\n \n pub mod any;\n pub mod array;\n+pub mod ascii;\n pub mod sync;\n pub mod cell;\n pub mod char;\n@@ -178,3 +190,21 @@ mod char_private;\n mod iter_private;\n mod tuple;\n mod unit;\n+\n+// Pull in the the `coresimd` crate directly into libcore. This is where all the\n+// architecture-specific (and vendor-specific) intrinsics are defined. AKA\n+// things like SIMD and such. Note that the actual source for all this lies in a\n+// different repository, rust-lang-nursery/stdsimd. That's why the setup here is\n+// a bit wonky.\n+#[path = \"../stdsimd/coresimd/mod.rs\"]\n+#[allow(missing_docs, missing_debug_implementations, dead_code)]\n+#[unstable(feature = \"stdsimd\", issue = \"48556\")]\n+#[cfg(not(stage0))] // allow changes to how stdsimd works in stage0\n+mod coresimd;\n+\n+#[unstable(feature = \"stdsimd\", issue = \"48556\")]\n+#[cfg(not(stage0))]\n+pub use coresimd::simd;\n+#[unstable(feature = \"stdsimd\", issue = \"48556\")]\n+#[cfg(not(stage0))]\n+pub use coresimd::arch;"}, {"sha": "8a87bea71e2530cf9562698aa6650955a854cc33", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,7 +19,10 @@ macro_rules! panic {\n     ($msg:expr) => ({\n         $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n     });\n-    ($fmt:expr, $($arg:tt)*) => ({\n+    ($msg:expr,) => (\n+        panic!($msg)\n+    );\n+    ($fmt:expr, $($arg:tt)+) => ({\n         $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*),\n                                      &(file!(), line!(), __rust_unstable_column!()))\n     });\n@@ -73,12 +76,16 @@ macro_rules! panic {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n+    ($cond:expr,) => (\n+        assert!($cond)\n+    );\n     ($cond:expr, $($arg:tt)+) => (\n         if !$cond {\n             panic!($($arg)+)\n@@ -359,7 +366,8 @@ macro_rules! try {\n         $crate::result::Result::Err(err) => {\n             return $crate::result::Result::Err($crate::convert::From::from(err))\n         }\n-    })\n+    });\n+    ($expr:expr,) => (try!($expr));\n }\n \n /// Write formatted data into a buffer.\n@@ -456,6 +464,9 @@ macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")\n     );\n+    ($dst:expr,) => (\n+        writeln!($dst)\n+    );\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n     );\n@@ -524,6 +535,9 @@ macro_rules! unreachable {\n     ($msg:expr) => ({\n         unreachable!(\"{}\", $msg)\n     });\n+    ($msg:expr,) => ({\n+        unreachable!($msg)\n+    });\n     ($fmt:expr, $($arg:tt)*) => ({\n         panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     });\n@@ -603,7 +617,10 @@ mod builtin {\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! compile_error { ($msg:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ });\n+        ($msg:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// The core macro for formatted string creation & output.\n     ///\n@@ -639,7 +656,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! option_env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n+        ($name:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Concatenate identifiers into one identifier.\n     ///\n@@ -715,7 +735,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_str {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n@@ -725,7 +748,10 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n \n     /// Expands to a string that represents the current module path.\n     ///\n@@ -755,5 +781,22 @@ mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     #[cfg(dox)]\n-    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n+    macro_rules! include {\n+        ($file:expr) => ({ /* compiler built-in */ });\n+        ($file:expr,) => ({ /* compiler built-in */ });\n+    }\n+\n+    /// Ensure that a boolean expression is `true` at runtime.\n+    ///\n+    /// For more information, see the documentation for [`std::assert!`].\n+    ///\n+    /// [`std::assert!`]: ../std/macro.assert.html\n+    #[macro_export]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(dox)]\n+    macro_rules! assert {\n+        ($cond:expr) => ({ /* compiler built-in */ });\n+        ($cond:expr,) => ({ /* compiler built-in */ });\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    }\n }"}, {"sha": "53b1d1cd12de33f3dfe602f42b9637796e3a24aa", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -343,8 +343,21 @@ pub trait Copy : Clone {\n /// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+#[rustc_on_unimplemented(\n+    message=\"`{Self}` cannot be shared between threads safely\",\n+    label=\"`{Self}` cannot be shared between threads safely\"\n+)]\n pub unsafe auto trait Sync {\n+    // FIXME(estebank): once support to add notes in `rustc_on_unimplemented`\n+    // lands in beta, and it has been extended to check whether a closure is\n+    // anywhere in the requirement chain, extend it as such (#48534):\n+    // ```\n+    // on(\n+    //     closure,\n+    //     note=\"`{Self}` cannot be shared safely, consider marking the closure `move`\"\n+    // ),\n+    // ```\n+\n     // Empty\n }\n "}, {"sha": "69418434ebead36b0ed701744ab61c4ce7d25dfa", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -73,7 +73,8 @@ pub fn parse_decimal(s: &str) -> ParseResult {\n         }\n         Some(&b'.') => {\n             let (fractional, s) = eat_digits(&s[1..]);\n-            if integral.is_empty() && fractional.is_empty() && s.is_empty() {\n+            if integral.is_empty() && fractional.is_empty() {\n+                // We require at least a single digit before or after the point.\n                 return Invalid;\n             }\n "}, {"sha": "09ab7060d37db8420162350925900891dbb2e5b5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 372, "deletions": 3, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -321,6 +321,33 @@ $EndFeature, \"\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `i16` is used here.\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: i16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m as u16, 0b10101010_00000000);\n+        /// assert_eq!(m, -22016);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            (self as $UnsignedT).reverse_bits() as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n \n@@ -634,6 +661,46 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.checked_mul(base)?;\n+                    }\n+                    exp /= 2;\n+                    base = base.checked_mul(base)?;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.checked_mul(base)?;\n+                }\n+\n+                Some(acc)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n bounds instead of overflowing.\n@@ -713,6 +780,34 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None if self < 0 && exp % 2 == 1 => Self::min_value(),\n+                    None => Self::max_value(),\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n boundary of the type.\n@@ -947,6 +1042,46 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\n+assert_eq!(3i8.wrapping_pow(5), -13);\n+assert_eq!(3i8.wrapping_pow(6), -39);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.wrapping_mul(base);\n+                }\n+\n+                acc\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -1202,14 +1337,64 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n \n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\n+assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    r = acc.overflowing_mul(base);\n+                    acc = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                (acc, overflown)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n # Examples\n \n Basic usage:\n \n ```\n \", $Feature, \"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n \n-assert_eq!(x.pow(4), 16);\",\n+assert_eq!(x.pow(5), 32);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1615,6 +1800,33 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u16` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: u16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m, 0b10101010_00000000);\n+        /// assert_eq!(m, 43520);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n \n@@ -1887,6 +2099,44 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature,\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\n+assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.checked_mul(base)?;\n+                    }\n+                    exp /= 2;\n+                    base = base.checked_mul(base)?;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.checked_mul(base)?;\n+                }\n+\n+                Some(acc)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n@@ -1953,6 +2203,32 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None => Self::max_value(),\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n@@ -2147,6 +2423,44 @@ assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\n+assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    acc = acc.wrapping_mul(base);\n+                }\n+\n+                acc\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -2353,7 +2667,55 @@ assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $E\n             pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n             }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(no_panic_pow)]\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\n+assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"no_panic_pow\", issue = \"48320\")]\n+            #[inline]\n+            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n \n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                if exp == 1 {\n+                    r = acc.overflowing_mul(base);\n+                    acc = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                (acc, overflown)\n+            }\n         }\n \n         doc_comment! {\n@@ -2364,7 +2726,7 @@ assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $E\n Basic usage:\n \n ```\n-\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(4), 16);\", $EndFeature, \"\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -2892,7 +3254,7 @@ impl u8 {\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '@' ... U+007E '~'.\n+    /// U+0021 '!' ... U+007E '~'.\n     ///\n     /// # Examples\n     ///\n@@ -3538,6 +3900,13 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n /// This error is used as the error type for the `from_str_radix()` functions\n /// on the primitive integer types, such as [`i8::from_str_radix`].\n ///\n+/// # Potential causes\n+///\n+/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n+/// in the string e.g. when it is obtained from the standard input.\n+/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n+///\n+/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n /// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "234970a81faf72c36d3dc3511a6b74c3ec3f7eab", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -191,7 +191,7 @@ pub use self::index::{Index, IndexMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub use self::range::{RangeInclusive, RangeToInclusive};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "be51f5239b0c64c2aef58bdce6611b8be78e19f6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -128,7 +128,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// The range is empty if either side is incomparable:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// use std::f32::NAN;\n     /// assert!(!(3.0..5.0).is_empty());\n@@ -283,7 +283,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// #![feature(inclusive_range_fields)]\n ///\n /// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n@@ -293,21 +293,17 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     /// The lower bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..={:?}\", self.start, self.end)\n@@ -320,7 +316,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// #![feature(range_contains)]\n     ///\n     /// assert!(!(3..=5).contains(2));\n     /// assert!( (3..=5).contains(3));\n@@ -341,7 +337,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// assert!(!(3..=5).is_empty());\n     /// assert!(!(3..=3).is_empty());\n@@ -351,7 +347,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// The range is empty if either side is incomparable:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// use std::f32::NAN;\n     /// assert!(!(3.0..=5.0).is_empty());\n@@ -362,7 +358,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// This method returns `true` after iteration has finished:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// let mut r = 3..=5;\n     /// for _ in r.by_ref() {}\n@@ -385,16 +381,13 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// The `..=end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n /// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n /// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n-/// #![feature(inclusive_range_syntax)]\n-///\n /// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n /// // std::iter::Iterator` is not satisfied\n /// for i in ..=5 {\n@@ -406,8 +399,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n-/// #![feature(inclusive_range_syntax)]\n-///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1..=2], [  1,2  ]);\n@@ -417,16 +408,14 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeToInclusive<Idx> {\n     /// The upper bound of the range (inclusive)\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..={:?}\", self.end)\n@@ -440,7 +429,7 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// #![feature(range_contains)]\n     ///\n     /// assert!( (..=5).contains(-1_000_000_000));\n     /// assert!( (..=5).contains(5));"}, {"sha": "570f745f8330c78739bd095d97d20416b9e362cc", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -233,11 +233,11 @@ impl<T> Option<T> {\n     /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// ```\n-    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n+    /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n-    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n-    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n-    /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n+    /// // then consume *that* with `map`, leaving `text` on the stack.\n+    /// let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n+    /// println!(\"still can print text: {:?}\", text);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -829,14 +829,13 @@ impl<'a, T: Clone> Option<&'a mut T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(option_ref_mut_cloned)]\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n     /// let cloned = opt_x.cloned();\n     /// assert_eq!(cloned, Some(12));\n     /// ```\n-    #[unstable(feature = \"option_ref_mut_cloned\", issue = \"43738\")]\n+    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.clone())\n     }\n@@ -1051,7 +1050,7 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, A> FusedIterator for Iter<'a, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1096,7 +1095,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n@@ -1133,7 +1132,7 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A> FusedIterator for IntoIter<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "94db0baa3f95f883f9eb73855ce0c0ff24b939fa", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -64,7 +64,8 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32))\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n-        #[unwind]\n+        #[cfg_attr(stage0, unwind)]\n+        #[cfg_attr(not(stage0), unwind(allowed))]\n         fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n     }\n     let (file, line, col) = *file_line_col;"}, {"sha": "6270e5892b3a0b4141da929e105fe71300bed165", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 78, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -740,8 +740,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     /// let ptr: *const u8 = s.as_ptr();\n     ///\n@@ -750,7 +748,7 @@ impl<T: ?Sized> *const T {\n     ///     println!(\"{}\", *ptr.add(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n         where T: Sized,\n@@ -799,8 +797,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     ///\n     /// unsafe {\n@@ -809,7 +805,7 @@ impl<T: ?Sized> *const T {\n     ///     println!(\"{}\", *end.sub(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -836,8 +832,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -852,7 +846,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_add(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n         where T: Sized,\n@@ -879,8 +873,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements (backwards)\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -895,7 +887,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_sub(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -922,16 +914,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n         where T: Sized,\n@@ -974,16 +964,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n         where T: Sized,\n@@ -1010,16 +998,14 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n         where T: Sized,\n@@ -1046,8 +1032,6 @@ impl<T: ?Sized> *const T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1056,7 +1040,7 @@ impl<T: ?Sized> *const T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1085,8 +1069,6 @@ impl<T: ?Sized> *const T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1095,7 +1077,7 @@ impl<T: ?Sized> *const T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1443,8 +1425,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     /// let ptr: *const u8 = s.as_ptr();\n     ///\n@@ -1453,7 +1433,7 @@ impl<T: ?Sized> *mut T {\n     ///     println!(\"{}\", *ptr.add(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn add(self, count: usize) -> Self\n         where T: Sized,\n@@ -1502,8 +1482,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let s: &str = \"123\";\n     ///\n     /// unsafe {\n@@ -1512,7 +1490,7 @@ impl<T: ?Sized> *mut T {\n     ///     println!(\"{}\", *end.sub(2) as char);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -1539,8 +1517,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -1555,7 +1531,7 @@ impl<T: ?Sized> *mut T {\n     ///     ptr = ptr.wrapping_add(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_add(self, count: usize) -> Self\n         where T: Sized,\n@@ -1582,8 +1558,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// // Iterate using a raw pointer in increments of two elements (backwards)\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -1598,7 +1572,7 @@ impl<T: ?Sized> *mut T {\n     ///     ptr = ptr.wrapping_sub(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub fn wrapping_sub(self, count: usize) -> Self\n         where T: Sized,\n@@ -1625,16 +1599,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n         where T: Sized,\n@@ -1668,7 +1640,7 @@ impl<T: ?Sized> *mut T {\n     /// Beyond accepting a raw pointer, this is unsafe because it semantically\n     /// moves the value out of `self` without preventing further usage of `self`.\n     /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `src` is not used before the data is overwritten again (e.g. with `write`,\n+    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n@@ -1677,16 +1649,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n         where T: Sized,\n@@ -1713,16 +1683,14 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let x = 12;\n     /// let y = &x as *const i32;\n     ///\n     /// unsafe {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n         where T: Sized,\n@@ -1749,8 +1717,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1759,7 +1725,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1788,8 +1754,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n@@ -1798,7 +1762,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n         where T: Sized,\n@@ -1825,8 +1789,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n@@ -1835,7 +1797,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n         where T: Sized,\n@@ -1864,8 +1826,6 @@ impl<T: ?Sized> *mut T {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// # #[allow(dead_code)]\n     /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n@@ -1874,7 +1834,7 @@ impl<T: ?Sized> *mut T {\n     ///     dst\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n         where T: Sized,\n@@ -1899,7 +1859,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This has all the same safety problems as `ptr::read` with respect to\n     /// invalid pointers, types, and double drops.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n         drop_in_place(self)\n@@ -1929,8 +1889,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -1940,7 +1898,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n         where T: Sized,\n@@ -1954,16 +1912,14 @@ impl<T: ?Sized> *mut T {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut vec = vec![0; 4];\n     /// unsafe {\n     ///     let vec_ptr = vec.as_mut_ptr();\n     ///     vec_ptr.write_bytes(b'a', 2);\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n         where T: Sized,\n@@ -2008,8 +1964,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -2019,7 +1973,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read_volatile(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n         where T: Sized,\n@@ -2040,8 +1994,8 @@ impl<T: ?Sized> *mut T {\n     /// allocations or resources, so care must be taken not to overwrite an object\n     /// that should be dropped.\n     ///\n-    /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n-    /// location pointed to by `dst`.\n+    /// Additionally, it does not drop `self`. Semantically, `self` is moved into the\n+    /// location pointed to by `val`.\n     ///\n     /// This is appropriate for initializing uninitialized memory, or overwriting\n     /// memory that has previously been `read` from.\n@@ -2051,8 +2005,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(pointer_methods)]\n-    ///\n     /// let mut x = 0;\n     /// let y = &mut x as *mut i32;\n     /// let z = 12;\n@@ -2062,7 +2014,7 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(y.read_unaligned(), 12);\n     /// }\n     /// ```\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n         where T: Sized,\n@@ -2077,7 +2029,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This is only unsafe because it accepts a raw pointer.\n     /// Otherwise, this operation is identical to `mem::replace`.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n         where T: Sized,\n@@ -2095,7 +2047,7 @@ impl<T: ?Sized> *mut T {\n     /// as arguments.\n     ///\n     /// Ensure that these pointers are valid before calling `swap`.\n-    #[unstable(feature = \"pointer_methods\", issue = \"43941\")]\n+    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)\n         where T: Sized,"}, {"sha": "c152d4979b90e3c880e3fd5c7f35aa52b11701be", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1038,7 +1038,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1082,7 +1082,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1125,7 +1125,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "0f1b7cb8fcc00ea34af430396864d97bb741ab9d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -211,10 +211,10 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     fn rotate_left(&mut self, mid: usize);\n \n-    #[unstable(feature = \"slice_rotate\", issue = \"41891\")]\n+    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     fn rotate_right(&mut self, k: usize);\n \n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n@@ -1039,7 +1039,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n }\n \n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n@@ -1080,7 +1080,7 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n@@ -1246,18 +1246,15 @@ macro_rules! iterator {\n             {\n                 // The addition might panic on overflow\n                 // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let _n = make_slice!(self.ptr, self.end).len();\n+                let n = make_slice!(self.ptr, self.end).len();\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n                 }).err()\n-                    // // FIXME(#48116/#45964):\n-                    // // This assume() causes misoptimization on LLVM 6.\n-                    // // Commented out until it is fixed again.\n-                    // .map(|i| {\n-                    //     unsafe { assume(i < n) };\n-                    //     i\n-                    // })\n+                    .map(|i| {\n+                        unsafe { assume(i < n) };\n+                        i\n+                    })\n             }\n \n             #[inline]\n@@ -1274,13 +1271,10 @@ macro_rules! iterator {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i) }\n                 }).err()\n-                    // // FIXME(#48116/#45964):\n-                    // // This assume() causes misoptimization on LLVM 6.\n-                    // // Commented out until it is fixed again.\n-                    // .map(|i| {\n-                    //     unsafe { assume(i < n) };\n-                    //     i\n-                    // })\n+                    .map(|i| {\n+                        unsafe { assume(i < n) };\n+                        i\n+                    })\n             }\n         }\n \n@@ -1461,7 +1455,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1589,7 +1583,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1737,7 +1731,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, P> FusedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over the subslices of the vector which are separated\n@@ -1835,7 +1829,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over subslices separated by elements that match a predicate\n@@ -1892,7 +1886,6 @@ impl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-//#[unstable(feature = \"fused\", issue = \"35602\")]\n #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n impl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n \n@@ -1951,7 +1944,6 @@ impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n     }\n }\n \n-//#[unstable(feature = \"fused\", issue = \"35602\")]\n #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n impl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n@@ -2088,7 +2080,7 @@ macro_rules! forward_iterator {\n             }\n         }\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P>\n             where P: FnMut(&T) -> bool {}\n     }\n@@ -2194,7 +2186,7 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Windows<'a, T> {}\n \n #[doc(hidden)]\n@@ -2313,7 +2305,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Chunks<'a, T> {}\n \n #[doc(hidden)]\n@@ -2429,7 +2421,7 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for ChunksMut<'a, T> {}\n \n #[doc(hidden)]\n@@ -2539,7 +2531,7 @@ impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n \n #[doc(hidden)]\n@@ -2636,7 +2628,7 @@ impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n \n #[doc(hidden)]"}, {"sha": "9cf862bd93625f9e2604eef7abcc3eb685a40758", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -609,7 +609,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Chars<'a> {}\n \n impl<'a> Chars<'a> {\n@@ -702,7 +702,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for CharIndices<'a> {}\n \n impl<'a> CharIndices<'a> {\n@@ -817,7 +817,7 @@ impl<'a> ExactSizeIterator for Bytes<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Bytes<'a> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -977,10 +977,10 @@ macro_rules! generate_pattern_iterators {\n             }\n         }\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, P: Pattern<'a>> FusedIterator for $reverse_iterator<'a, P>\n             where P::Searcher: ReverseSearcher<'a> {}\n \n@@ -1337,7 +1337,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Lines<'a> {}\n \n /// Created with the method [`lines_any`].\n@@ -1403,7 +1403,7 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n #[allow(deprecated)]\n impl<'a> FusedIterator for LinesAny<'a> {}\n \n@@ -1779,9 +1779,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::Index<ops::RangeInclusive<usize>> for str {\n         type Output = str;\n \n@@ -1791,9 +1789,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::Index<ops::RangeToInclusive<usize>> for str {\n         type Output = str;\n \n@@ -1803,18 +1799,14 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n             index.index_mut(self)\n         }\n     }\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n@@ -1997,9 +1989,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n         #[inline]\n@@ -2042,9 +2032,7 @@ mod traits {\n \n \n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;\n         #[inline]"}, {"sha": "4d43067ad2cf3e7b4467581b0d2e190af19d0a59", "filename": "src/libcore/tests/ascii.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -0,0 +1,360 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::char::from_u32;\n+use std::ascii::AsciiExt;\n+\n+#[test]\n+fn test_is_ascii() {\n+    assert!(b\"\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n+\n+    assert!(\"\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n+}\n+\n+#[test]\n+fn test_to_ascii_uppercase() {\n+    assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+    assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+                   (from_u32(upper).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_to_ascii_lowercase() {\n+    assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+                   (from_u32(lower).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_make_ascii_lower_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_lowercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'A', b'a');\n+    test!(b'a', b'a');\n+    test!(b'!', b'!');\n+    test!('A', 'a');\n+    test!('\u00c0', '\u00c0');\n+    test!('a', 'a');\n+    test!('!', '!');\n+    test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+    test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+}\n+\n+\n+#[test]\n+fn test_make_ascii_upper_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_uppercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'a', b'A');\n+    test!(b'A', b'A');\n+    test!(b'!', b'!');\n+    test!('a', 'A');\n+    test!('\u00e0', '\u00e0');\n+    test!('A', 'A');\n+    test!('!', '!');\n+    test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+    test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+    let mut x = \"Hello\".to_string();\n+    x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+    assert_eq!(x, \"HELlo\")\n+}\n+\n+#[test]\n+fn test_eq_ignore_ascii_case() {\n+    assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+    assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+    assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+    assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+    assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n+                &from_u32(lower).unwrap().to_string()));\n+    }\n+}\n+\n+#[test]\n+fn inference_works() {\n+    let x = \"a\".to_string();\n+    x.eq_ignore_ascii_case(\"A\");\n+}\n+\n+// Shorthands used by the is_ascii_* tests.\n+macro_rules! assert_all {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if !b.$what() {\n+                    panic!(\"expected {}({}) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if !b.$what() {\n+                    panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            assert!($str.$what());\n+            assert!($str.as_bytes().$what());\n+        )+\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+}\n+macro_rules! assert_none {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}({}) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+        )*\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+}\n+\n+#[test]\n+fn test_is_ascii_alphabetic() {\n+    assert_all!(is_ascii_alphabetic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_alphabetic,\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_uppercase() {\n+    assert_all!(is_ascii_uppercase,\n+        \"\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_uppercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_lowercase() {\n+    assert_all!(is_ascii_lowercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+    );\n+    assert_none!(is_ascii_lowercase,\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_alphanumeric() {\n+    assert_all!(is_ascii_alphanumeric,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_alphanumeric,\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_digit() {\n+    assert_all!(is_ascii_digit,\n+        \"\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_digit,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_hexdigit() {\n+    assert_all!(is_ascii_hexdigit,\n+        \"\",\n+        \"0123456789\",\n+        \"abcdefABCDEF\",\n+    );\n+    assert_none!(is_ascii_hexdigit,\n+        \"ghijklmnopqrstuvwxyz\",\n+        \"GHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_punctuation() {\n+    assert_all!(is_ascii_punctuation,\n+        \"\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_punctuation,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_graphic() {\n+    assert_all!(is_ascii_graphic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_graphic,\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_whitespace() {\n+    assert_all!(is_ascii_whitespace,\n+        \"\",\n+        \" \\t\\n\\x0c\\r\",\n+    );\n+    assert_none!(is_ascii_whitespace,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x0b\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_control() {\n+    assert_all!(is_ascii_control,\n+        \"\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+    assert_none!(is_ascii_control,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \",\n+    );\n+}"}, {"sha": "bc205ec0582ea8c7ae1405c323494fa62eb67aff", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -150,3 +150,9 @@ fn test_format_int_twos_complement() {\n     assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n     assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n }\n+\n+#[test]\n+fn test_format_debug_hex() {\n+    assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\");\n+    assert!(format!(\"{:02X?}\", b\"Foo\\0\") == \"[46, 6F, 6F, 00]\");\n+}"}, {"sha": "bad858011e960e4513fbe29a36ea5c9c4640de83", "filename": "src/libcore/tests/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -11,7 +11,7 @@\n #![allow(deprecated)]\n \n use core::hash::{Hash, Hasher};\n-use core::hash::{SipHasher, SipHasher13, SipHasher24};\n+use core::hash::{SipHasher, SipHasher13};\n use core::{slice, mem};\n \n // Hash just the bytes of the slice, without length prefix\n@@ -224,14 +224,14 @@ fn test_siphash_2_4() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipHasher24::new_with_keys(k0, k1);\n+    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n \n     while t < 64 {\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n+        let out = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        let full = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n+        let full = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n         let i = state_inc.finish();\n \n         assert_eq!(full, i);\n@@ -322,13 +322,13 @@ fn test_hash_no_concat_alias() {\n #[test]\n fn test_write_short_works() {\n     let test_usize = 0xd0c0b0a0usize;\n-    let mut h1 = SipHasher24::new();\n+    let mut h1 = SipHasher::new();\n     h1.write_usize(test_usize);\n     h1.write(b\"bytes\");\n     h1.write(b\"string\");\n     h1.write_u8(0xFFu8);\n     h1.write_u8(0x01u8);\n-    let mut h2 = SipHasher24::new();\n+    let mut h2 = SipHasher::new();\n     h2.write(unsafe {\n         slice::from_raw_parts(&test_usize as *const _ as *const u8,\n                               mem::size_of::<usize>())"}, {"sha": "a962efadd64e9aed3cca29088bd9cee74ec2823c", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -144,6 +144,43 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_zip_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let ys = [10, 11, 12];\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(0), Some((&0, &10)));\n+    assert_eq!(it.nth(1), Some((&2, &12)));\n+    assert_eq!(it.nth(0), None);\n+\n+    let mut it = xs.iter().zip(&ys);\n+    assert_eq!(it.nth(3), None);\n+\n+    let mut it = ys.iter().zip(&xs);\n+    assert_eq!(it.nth(3), None);\n+}\n+\n+#[test]\n+fn test_zip_nth_side_effects() {\n+    let mut a = Vec::new();\n+    let mut b = Vec::new();\n+    let value = [1, 2, 3, 4, 5, 6].iter().cloned()\n+        .map(|n| {\n+            a.push(n);\n+            n * 10\n+        })\n+        .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\n+            b.push(n * 100);\n+            n * 1000\n+        }))\n+        .skip(1)\n+        .nth(3);\n+    assert_eq!(value, Some((50, 6000)));\n+    assert_eq!(a, vec![1, 2, 3, 4, 5]);\n+    assert_eq!(b, vec![200, 300, 400, 500, 600]);\n+}\n+\n #[test]\n fn test_iterator_step_by() {\n     // Identity\n@@ -874,6 +911,44 @@ fn test_iterator_flat_map_fold() {\n     assert_eq!(i, 0);\n }\n \n+#[test]\n+fn test_iterator_flatten() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+/// Test `Flatten::fold` with items already picked off the front and back,\n+/// to make sure all parts of the `Flatten` are folded correctly.\n+#[test]\n+fn test_iterator_flatten_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_inspect() {\n     let xs = [1, 2, 3, 4];\n@@ -1287,6 +1362,23 @@ fn test_double_ended_flat_map() {\n     assert_eq!(it.next_back(), None);\n }\n \n+#[test]\n+fn test_double_ended_flatten() {\n+    let u = [0,1];\n+    let v = [5,6,7,8];\n+    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n #[test]\n fn test_double_ended_range() {\n     assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n@@ -1978,3 +2070,54 @@ fn test_flat_map_try_folds() {\n     assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n     assert_eq!(iter.next_back(), Some(35));\n }\n+\n+#[test]\n+fn test_flatten_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).map(mr).flatten();\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).map(|x| (4*x)..(4*x + 4)).flatten();\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}\n+\n+#[test]\n+fn test_functor_laws() {\n+    // identity:\n+    fn identity<T>(x: T) -> T { x }\n+    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n+\n+    // composition:\n+    fn f(x: usize) -> usize { x + 3 }\n+    fn g(x: usize) -> usize { x * 2 }\n+    fn h(x: usize) -> usize { g(f(x)) }\n+    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_left_identity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        (0..10).map(move |y| x * y)\n+    }\n+    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_right_identity() {\n+    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_associativity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> { 0..x }\n+    fn g(x: usize) -> impl Iterator<Item = usize> { (0..x).rev() }\n+    assert_eq!((0..10).flat_map(f).flat_map(g).sum::<usize>(),\n+                (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>());\n+}"}, {"sha": "1c876fa0bd7d05ed541e2d5f0c8c80494c806185", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -10,6 +10,7 @@\n \n #![deny(warnings)]\n \n+#![feature(ascii_ctype)]\n #![feature(box_syntax)]\n #![feature(core_float)]\n #![feature(core_private_bignum)]\n@@ -20,11 +21,13 @@\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(hashmap_internals)]\n #![feature(iterator_step_by)]\n #![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(inclusive_range_syntax)]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(iterator_try_fold)]\n+#![feature(iterator_flatten)]\n+#![feature(conservative_impl_trait)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(iterator_repeat_with)]\n@@ -33,9 +36,7 @@\n #![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n-#![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n-#![feature(slice_rotate)]\n #![feature(sort_internals)]\n #![feature(specialization)]\n #![feature(step_trait)]\n@@ -45,12 +46,16 @@\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]\n+#![feature(reverse_bits)]\n+#![feature(inclusive_range_fields)]\n \n extern crate core;\n extern crate test;\n+extern crate rand;\n \n mod any;\n mod array;\n+mod ascii;\n mod atomic;\n mod cell;\n mod char;"}, {"sha": "17b2f59cd4df2814e47e1175eab92b011b3ddd99", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -101,6 +101,12 @@ fn lonely_dot() {\n     assert!(\".\".parse::<f64>().is_err());\n }\n \n+#[test]\n+fn exponentiated_dot() {\n+    assert!(\".e0\".parse::<f32>().is_err());\n+    assert!(\".e0\".parse::<f64>().is_err());\n+}\n+\n #[test]\n fn lonely_sign() {\n     assert!(\"+\".parse::<f32>().is_err());"}, {"sha": "04567e25e25ba243a3b1fc3c766f848fa56e20c8", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -23,6 +23,7 @@ mod strategy {\n     mod dragon;\n     mod grisu;\n }\n+mod random;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {"}, {"sha": "315ac4d7d99f53650a3a61c07307078bef959df9", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:--test\n-\n-#![feature(rustc_private, flt2dec)]\n-\n-extern crate core;\n-extern crate rand;\n+#![cfg(not(target_arch = \"wasm32\"))]\n \n use std::i16;\n use std::mem;\n@@ -24,8 +19,9 @@ use core::num::flt2dec::strategy::grisu::format_exact_opt;\n use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-use rand::{Rand, XorShiftRng};\n+use rand::{self, Rand, XorShiftRng};\n use rand::distributions::{IndependentSample, Range};\n+\n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n@@ -161,3 +157,4 @@ fn exact_f64_random_equivalence_test() {\n                                              |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n     }\n }\n+", "previous_filename": "src/test/run-pass-fulldeps/flt2dec.rs"}, {"sha": "ca6906f731047c62e0091c3a3212756cff2b5c23", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -97,6 +97,17 @@ mod tests {\n         assert_eq!(_1.swap_bytes(), _1);\n     }\n \n+    #[test]\n+    fn test_reverse_bits() {\n+        assert_eq!(A.reverse_bits().reverse_bits(), A);\n+        assert_eq!(B.reverse_bits().reverse_bits(), B);\n+        assert_eq!(C.reverse_bits().reverse_bits(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.reverse_bits(), _0);\n+        assert_eq!(_1.reverse_bits(), _1);\n+    }\n+\n     #[test]\n     fn test_le() {\n         assert_eq!($T::from_le(A.to_le()), A);"}, {"sha": "53fdfa0682742454284a2ea9bdea79970d335a6c", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -10,7 +10,6 @@\n \n use core::result::Result::{Ok, Err};\n \n-\n #[test]\n fn test_position() {\n     let b = [1, 2, 3, 5, 5];\n@@ -481,3 +480,73 @@ fn test_rotate_right() {\n         assert_eq!(a[(i + 42) % N], i);\n     }\n }\n+\n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+fn sort_unstable() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use core::slice::heapsort;\n+    use rand::{Rng, XorShiftRng};\n+\n+    let mut v = [0; 600];\n+    let mut tmp = [0; 600];\n+    let mut rng = XorShiftRng::new_unseeded();\n+\n+    for len in (2..25).chain(500..510) {\n+        let v = &mut v[0..len];\n+        let tmp = &mut tmp[0..len];\n+\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..100 {\n+                for i in 0..len {\n+                    v[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                // Sort in default order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable();\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| a.cmp(b));\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| b.cmp(a));\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Test heapsort using `<` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a < b);\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Test heapsort using `>` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a > b);\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort_unstable();\n+    [(); 10].sort_unstable();\n+    [(); 100].sort_unstable();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort_unstable();\n+    assert!(v == [0xDEADBEEF]);\n+}"}, {"sha": "0f45f965104cadff7b8cce5e168e73a0036cf36b", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -108,6 +108,10 @@ pub enum Flag {\n     /// For numbers, this means that the number will be padded with zeroes,\n     /// and the sign (`+` or `-`) will precede them.\n     FlagSignAwareZeroPad,\n+    /// For Debug / `?`, format integers in lower-case hexadecimal.\n+    FlagDebugLowerHex,\n+    /// For Debug / `?`, format integers in upper-case hexadecimal.\n+    FlagDebugUpperHex,\n }\n \n /// A count is used for the precision and width parameters of an integer, and\n@@ -377,8 +381,22 @@ impl<'a> Parser<'a> {\n                 spec.precision = self.count();\n             }\n         }\n-        // Finally the actual format specifier\n-        if self.consume('?') {\n+        // Optional radix followed by the actual format specifier\n+        if self.consume('x') {\n+            if self.consume('?') {\n+                spec.flags |= 1 << (FlagDebugLowerHex as u32);\n+                spec.ty = \"?\";\n+            } else {\n+                spec.ty = \"x\";\n+            }\n+        } else if self.consume('X') {\n+            if self.consume('?') {\n+                spec.flags |= 1 << (FlagDebugUpperHex as u32);\n+                spec.ty = \"?\";\n+            } else {\n+                spec.ty = \"X\";\n+            }\n+        } else if self.consume('?') {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();"}, {"sha": "d8c366d2413d9cf15975eb67bf64feb49b5de58f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -711,6 +711,12 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+impl<'a> IntoCow<'a, str> for Cow<'a, str> {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        self\n+    }\n+}\n+\n impl<'a, T: Clone> IntoCow<'a, [T]> for Vec<T> {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)"}, {"sha": "ed04152aacf5b4798f78ff13396f3c04c0a77144", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1 +1 @@\n-Subproject commit 8bed48a751562c1c396b361bb6940c677268e997\n+Subproject commit ed04152aacf5b4798f78ff13396f3c04c0a77144"}, {"sha": "ca2fd561cadcfcc75d9bb719cc5937fee4227b31", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -286,7 +286,8 @@ unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n // See docs in the `unwind` module.\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n     uw::_Unwind_Resume(panic_ctx as *mut uw::_Unwind_Exception);\n }"}, {"sha": "a5cebc3e4d04b6eee6b74854f82d1146508878d9", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -112,7 +112,8 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[no_mangle]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n     imp::panic(mem::transmute(raw::TraitObject {\n         data: data as *mut (),"}, {"sha": "090cd095380ee8dfcaffdaeb3600e664130105b3", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -108,7 +108,8 @@ unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut c::EXCEPTION_RECO\n }\n \n #[lang = \"eh_unwind_resume\"]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n     let params = [panic_ctx as c::ULONG_PTR];\n     c::RaiseException(RUST_PANIC,"}, {"sha": "50fba5faee747facb0f1309ebd900411f912982e", "filename": "src/libpanic_unwind/windows.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -79,18 +79,21 @@ pub enum EXCEPTION_DISPOSITION {\n pub use self::EXCEPTION_DISPOSITION::*;\n \n extern \"system\" {\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn RaiseException(dwExceptionCode: DWORD,\n                           dwExceptionFlags: DWORD,\n                           nNumberOfArguments: DWORD,\n                           lpArguments: *const ULONG_PTR);\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn RtlUnwindEx(TargetFrame: LPVOID,\n                        TargetIp: LPVOID,\n                        ExceptionRecord: *const EXCEPTION_RECORD,\n                        ReturnValue: LPVOID,\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8);\n }"}, {"sha": "c1b2622520b112eb4519d786d4a9bbe11258dca0", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "b239f8018bebb9207b22527fcb834efddf33c9e0", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -38,19 +38,21 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(lang_items)]\n+#![feature(optin_builtin_traits)]\n \n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors;\n+extern crate rustc_data_structures;\n \n mod diagnostic;\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use std::str::FromStr;\n \n use syntax::ast;\n@@ -306,17 +308,22 @@ pub struct LineColumn {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n pub struct SourceFile {\n-    filemap: Rc<FileMap>,\n+    filemap: Lrc<FileMap>,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for SourceFile {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for SourceFile {}\n+\n impl SourceFile {\n     /// Get the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n     /// may not be an actual path on the filesystem. Use [`is_real`] to check.\n     ///\n-    /// Also note that even if `is_real` returns `true`, if `-Z remap-path-prefix-*` was passed on\n+    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n     /// the command line, the path as given may not actually be valid.\n     ///\n     /// [`is_real`]: #method.is_real\n@@ -356,7 +363,7 @@ impl fmt::Debug for SourceFile {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl PartialEq for SourceFile {\n     fn eq(&self, other: &Self) -> bool {\n-        Rc::ptr_eq(&self.filemap, &other.filemap)\n+        Lrc::ptr_eq(&self.filemap, &other.filemap)\n     }\n }\n \n@@ -673,7 +680,6 @@ impl TokenTree {\n             Pound => op!('#'),\n             Dollar => op!('$'),\n             Question => op!('?'),\n-            Underscore => op!('_'),\n \n             Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n             Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n@@ -736,7 +742,6 @@ impl TokenTree {\n             '#' => Pound,\n             '$' => Dollar,\n             '?' => Question,\n-            '_' => Underscore,\n             _ => panic!(\"unsupported character {}\", op),\n         };\n \n@@ -844,6 +849,12 @@ pub mod __internal {\n         })\n     }\n \n+    pub fn in_sess() -> bool\n+    {\n+        let p = CURRENT_SESS.with(|p| p.get());\n+        !p.0.is_null()\n+    }\n+\n     pub fn with_sess<F, R>(f: F) -> R\n         where F: FnOnce((&ParseSess, Mark)) -> R\n     {"}, {"sha": "7e84a69dd7913b99356acd128321d93a0cf5602e", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,7 +14,9 @@ bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n+lazy_static = \"1.0.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+proc_macro = { path = \"../libproc_macro\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "9909ff91a18aabe186dc2142bb4e1cf47464f65c", "filename": "src/librustc/README.md", "status": "modified", "additions": 2, "deletions": 203, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -1,204 +1,3 @@\n-An informal guide to reading and working on the rustc compiler.\n-==================================================================\n+For more information about how rustc works, see the [rustc guide].\n \n-If you wish to expand on this document, or have a more experienced\n-Rust contributor add anything else to it, please get in touch:\n-\n-* https://internals.rust-lang.org/\n-* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-\n-or file a bug:\n-\n-https://github.com/rust-lang/rust/issues\n-\n-Your concerns are probably the same as someone else's.\n-\n-You may also be interested in the\n-[Rust Forge](https://forge.rust-lang.org/), which includes a number of\n-interesting bits of information.\n-\n-Finally, at the end of this file is a GLOSSARY defining a number of\n-common (and not necessarily obvious!) names that are used in the Rust\n-compiler code. If you see some funky name and you'd like to know what\n-it stands for, check there!\n-\n-The crates of rustc\n-===================\n-\n-Rustc consists of a number of crates, including `syntax`,\n-`rustc`, `rustc_back`, `rustc_trans`, `rustc_driver`, and\n-many more. The source for each crate can be found in a directory\n-like `src/libXXX`, where `XXX` is the crate name.\n-\n-(NB. The names and divisions of these crates are not set in\n-stone and may change over time -- for the time being, we tend towards\n-a finer-grained division to help with compilation time, though as\n-incremental improves that may change.)\n-\n-The dependency structure of these crates is roughly a diamond:\n-\n-```\n-                  rustc_driver\n-                /      |       \\\n-              /        |         \\\n-            /          |           \\\n-          /            v             \\\n-rustc_trans    rustc_borrowck   ...  rustc_metadata\n-          \\            |            /\n-            \\          |          /\n-              \\        |        /\n-                \\      v      /\n-                    rustc\n-                       |\n-                       v\n-                    syntax\n-                    /    \\\n-                  /       \\\n-           syntax_pos  syntax_ext\n-```                    \n-\n-The `rustc_driver` crate, at the top of this lattice, is effectively\n-the \"main\" function for the rust compiler. It doesn't have much \"real\n-code\", but instead ties together all of the code defined in the other\n-crates and defines the overall flow of execution. (As we transition\n-more and more to the [query model](ty/maps/README.md), however, the\n-\"flow\" of compilation is becoming less centrally defined.)\n-\n-At the other extreme, the `rustc` crate defines the common and\n-pervasive data structures that all the rest of the compiler uses\n-(e.g., how to represent types, traits, and the program itself). It\n-also contains some amount of the compiler itself, although that is\n-relatively limited.\n-\n-Finally, all the crates in the bulge in the middle define the bulk of\n-the compiler -- they all depend on `rustc`, so that they can make use\n-of the various types defined there, and they export public routines\n-that `rustc_driver` will invoke as needed (more and more, what these\n-crates export are \"query definitions\", but those are covered later\n-on).\n-\n-Below `rustc` lie various crates that make up the parser and error\n-reporting mechanism. For historical reasons, these crates do not have\n-the `rustc_` prefix, but they are really just as much an internal part\n-of the compiler and not intended to be stable (though they do wind up\n-getting used by some crates in the wild; a practice we hope to\n-gradually phase out).\n-\n-Each crate has a `README.md` file that describes, at a high-level,\n-what it contains, and tries to give some kind of explanation (some\n-better than others).\n-\n-The compiler process\n-====================\n-\n-The Rust compiler is in a bit of transition right now. It used to be a\n-purely \"pass-based\" compiler, where we ran a number of passes over the\n-entire program, and each did a particular check of transformation.\n-\n-We are gradually replacing this pass-based code with an alternative\n-setup based on on-demand **queries**. In the query-model, we work\n-backwards, executing a *query* that expresses our ultimate goal (e.g.,\n-\"compile this crate\"). This query in turn may make other queries\n-(e.g., \"get me a list of all modules in the crate\"). Those queries\n-make other queries that ultimately bottom out in the base operations,\n-like parsing the input, running the type-checker, and so forth. This\n-on-demand model permits us to do exciting things like only do the\n-minimal amount of work needed to type-check a single function. It also\n-helps with incremental compilation. (For details on defining queries,\n-check out `src/librustc/ty/maps/README.md`.)\n-\n-Regardless of the general setup, the basic operations that the\n-compiler must perform are the same. The only thing that changes is\n-whether these operations are invoked front-to-back, or on demand.  In\n-order to compile a Rust crate, these are the general steps that we\n-take:\n-\n-1. **Parsing input**\n-    - this processes the `.rs` files and produces the AST (\"abstract syntax tree\")\n-    - the AST is defined in `syntax/ast.rs`. It is intended to match the lexical\n-      syntax of the Rust language quite closely.\n-2. **Name resolution, macro expansion, and configuration**\n-    - once parsing is complete, we process the AST recursively, resolving paths\n-      and expanding macros. This same process also processes `#[cfg]` nodes, and hence\n-      may strip things out of the AST as well.\n-3. **Lowering to HIR**\n-    - Once name resolution completes, we convert the AST into the HIR,\n-      or \"high-level IR\". The HIR is defined in `src/librustc/hir/`; that module also includes\n-      the lowering code.\n-    - The HIR is a lightly desugared variant of the AST. It is more processed than the\n-      AST and more suitable for the analyses that follow. It is **not** required to match\n-      the syntax of the Rust language.\n-    - As a simple example, in the **AST**, we preserve the parentheses\n-      that the user wrote, so `((1 + 2) + 3)` and `1 + 2 + 3` parse\n-      into distinct trees, even though they are equivalent. In the\n-      HIR, however, parentheses nodes are removed, and those two\n-      expressions are represented in the same way.\n-3. **Type-checking and subsequent analyses**\n-    - An important step in processing the HIR is to perform type\n-      checking. This process assigns types to every HIR expression,\n-      for example, and also is responsible for resolving some\n-      \"type-dependent\" paths, such as field accesses (`x.f` -- we\n-      can't know what field `f` is being accessed until we know the\n-      type of `x`) and associated type references (`T::Item` -- we\n-      can't know what type `Item` is until we know what `T` is).\n-    - Type checking creates \"side-tables\" (`TypeckTables`) that include\n-      the types of expressions, the way to resolve methods, and so forth.\n-    - After type-checking, we can do other analyses, such as privacy checking.\n-4. **Lowering to MIR and post-processing**\n-    - Once type-checking is done, we can lower the HIR into MIR (\"middle IR\"), which\n-      is a **very** desugared version of Rust, well suited to the borrowck but also\n-      certain high-level optimizations. \n-5. **Translation to LLVM and LLVM optimizations**\n-    - From MIR, we can produce LLVM IR.\n-    - LLVM then runs its various optimizations, which produces a number of `.o` files\n-      (one for each \"codegen unit\").\n-6. **Linking**\n-    - Finally, those `.o` files are linked together.\n-\n-Glossary\n-========\n-\n-The compiler uses a number of...idiosyncratic abbreviations and\n-things. This glossary attempts to list them and give you a few\n-pointers for understanding them better.\n-\n-- AST -- the **abstract syntax tree** produced by the `syntax` crate; reflects user syntax\n-  very closely. \n-- codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n-  units. Each of these units is processed by LLVM independently from one another,\n-  enabling parallelism. They are also the unit of incremental re-use. \n-- cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n-- `DefId` -- an index identifying a **definition** (see `librustc/hir/def_id.rs`). Uniquely\n-  identifies a `DefPath`.\n-- HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n-- `HirId` -- identifies a particular node in the HIR by combining a\n-  def-id with an \"intra-definition offset\".\n-- `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n-- generics -- the set of generic type parameters defined on a type or item\n-- ICE -- internal compiler error. When the compiler crashes.\n-- ICH -- incremental compilation hash.\n-- infcx -- the inference context (see `librustc/infer`)\n-- MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n-  Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n-  found in `src/librustc_mir`.\n-- obligation -- something that must be proven by the trait system; see `librustc/traits`.\n-- local crate -- the crate currently being compiled.\n-- node-id or `NodeId` -- an index identifying a particular node in the\n-  AST or HIR; gradually being phased out and replaced with `HirId`.\n-- query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n-- provider -- the function that executes a query; see `librustc/maps`.\n-- sess -- the **compiler session**, which stores global data used throughout compilation\n-- side tables -- because the AST and HIR are immutable once created, we often carry extra\n-  information about them in the form of hashtables, indexed by the id of a particular node.\n-- span -- a location in the user's source code, used for error\n-  reporting primarily.  These are like a file-name/line-number/column\n-  tuple on steroids: they carry a start/end point, and also track\n-  macro expansions and compiler desugaring. All while being packed\n-  into a few bytes (really, it's an index into a table). See the\n-  `Span` datatype for more.\n-- substs -- the **substitutions** for a given generic type or item\n-  (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n-- tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`).\n-- trans -- the code to **translate** MIR into LLVM IR.\n-- trait reference -- a trait and values for its type parameters (see `librustc/ty`).\n-- ty -- the internal representation of a **type** (see `librustc/ty`).\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/"}, {"sha": "e56333aba9be571c5d52c738a81909b291b87a17", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -54,7 +54,7 @@ pub struct EdgeFilter {\n }\n \n impl EdgeFilter {\n-    pub fn new(test: &str) -> Result<EdgeFilter, Box<Error>> {\n+    pub fn new(test: &str) -> Result<EdgeFilter, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n             Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())"}, {"sha": "744e3a5eaabccb4c2dd346506152aecf55c64b79", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -60,18 +60,19 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n+use mir::interpret::{GlobalId};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n-use ich::Fingerprint;\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n+use ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use ich::StableHashingContext;\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n+use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e. which sub-expression of the macro we are in) but don't need\n@@ -80,6 +81,10 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n+macro_rules! replace {\n+    ($x:tt with $($y:tt)*) => ($($y)*)\n+}\n+\n macro_rules! is_anon_attr {\n     (anon) => (true);\n     ($attr:ident) => (false);\n@@ -111,7 +116,7 @@ macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n         [$($attr:ident),* ]\n-        $variant:ident $(( $($tuple_arg:tt),* ))*\n+        $variant:ident $(( $tuple_arg_ty:ty $(,)* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n     ) => (\n@@ -134,7 +139,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <( $($tuple_arg,)* ) as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -186,7 +191,7 @@ macro_rules! define_dep_nodes {\n                         DepKind :: $variant => {\n                             // tuple args\n                             $({\n-                                $(erase!($tuple_arg);)*\n+                                erase!($tuple_arg_ty);\n                                 return true;\n                             })*\n \n@@ -205,7 +210,7 @@ macro_rules! define_dep_nodes {\n \n         pub enum DepConstructor<$tcx> {\n             $(\n-                $variant $(( $($tuple_arg),* ))*\n+                $variant $(( $tuple_arg_ty ))*\n                          $({ $($struct_arg_name : $struct_arg_ty),* })*\n             ),*\n         }\n@@ -227,15 +232,14 @@ macro_rules! define_dep_nodes {\n             {\n                 match dep {\n                     $(\n-                        DepConstructor :: $variant $(( $($tuple_arg),* ))*\n+                        DepConstructor :: $variant $(( replace!(($tuple_arg_ty) with arg) ))*\n                                                    $({ $($struct_arg_name),* })*\n                             =>\n                         {\n                             // tuple args\n                             $({\n-                                let tupled_args = ( $($tuple_arg,)* );\n-                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n-                                                                         tcx);\n+                                erase!($tuple_arg_ty);\n+                                let hash = DepNodeParams::to_fingerprint(&arg, tcx);\n                                 let dep_node = DepNode {\n                                     kind: DepKind::$variant,\n                                     hash\n@@ -247,7 +251,7 @@ macro_rules! define_dep_nodes {\n                                     tcx.sess.opts.debugging_opts.query_dep_graph)\n                                 {\n                                     tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n+                                        arg.to_debug_str(tcx)\n                                     });\n                                 }\n \n@@ -436,6 +440,9 @@ impl DepKind {\n }\n \n define_dep_nodes!( <'tcx>\n+    // We use this for most things when incr. comp. is turned off.\n+    [] Null,\n+\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n@@ -515,7 +522,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeckTables(DefId),\n     [] UsedTraitImports(DefId),\n     [] HasTypeckTables(DefId),\n-    [] ConstEval { param_env: ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)> },\n+    [] ConstEval { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n     [] CheckMatch(DefId),\n     [] SymbolName(DefId),\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n@@ -553,9 +560,10 @@ define_dep_nodes!( <'tcx>\n     [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n-    [] IsExportedSymbol(DefId),\n+    [] IsReachableNonGeneric(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n+    [] TransFnAttrs(DefId),\n     [] FnArgNames(DefId),\n     [] DylibDepFormats(CrateNum),\n     [] IsPanicRuntime(CrateNum),\n@@ -571,7 +579,7 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n-    [] ExportedSymbolIds(CrateNum),\n+    [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n@@ -605,8 +613,8 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [input] HasCloneClosures(CrateNum),\n-    [input] HasCopyClosures(CrateNum),\n+    [] HasCloneClosures(CrateNum),\n+    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -623,25 +631,25 @@ define_dep_nodes!( <'tcx>\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n     [eval_always] CollectAndPartitionTranslationItems,\n-    [] ExportName(DefId),\n-    [] ContainsExternIndicator(DefId),\n-    [] IsTranslatedFunction(DefId),\n+    [] IsTranslatedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n-    [anon] NormalizeTy,\n-    // We use this for most things when incr. comp. is turned off.\n-    [] Null,\n+    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n+    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n     [input] TargetFeaturesWhitelist,\n-    [] TargetFeaturesEnabled(DefId),\n \n     [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n \n     [] GetSymbolExportLevel(DefId),\n \n+    [input] Features,\n+\n+    [] ProgramClausesFor(DefId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n@@ -661,7 +669,7 @@ trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'gcx>> + fmt::Debug\n+    where T: HashStable<StableHashingContext<'a>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n@@ -679,43 +687,43 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.def_path_hash(self.0).0\n+        tcx.def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(self.0)\n+        tcx.item_path_str(*self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.hir.definitions().def_path_hash(self.0).0\n+        tcx.hir.definitions().def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(DefId::local(self.0))\n+        tcx.item_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n         let def_id = DefId {\n-            krate: self.0,\n+            krate: *self,\n             index: CRATE_DEF_INDEX,\n         };\n         tcx.def_path_hash(def_id).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.crate_name(self.0).as_str().to_string()\n+        tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n@@ -743,17 +751,17 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (HirId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        let (HirId {\n+        let HirId {\n             owner,\n             local_id: ItemLocalId(local_id),\n-        },) = *self;\n+        } = *self;\n \n         let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n         let local_id = Fingerprint::from_smaller_hash(local_id as u64);"}, {"sha": "0ad79eacd2b03f9a04981bf5d2a4e9db918b7089", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 140, "deletions": 72, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -9,18 +9,17 @@\n // except according to those terms.\n \n use errors::DiagnosticBuilder;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHashingContextProvider};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::sync::Lrc;\n use std::cell::{Ref, RefCell};\n use std::env;\n use std::hash::Hash;\n-use std::rc::Rc;\n use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n-use ich::Fingerprint;\n+use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n@@ -32,13 +31,13 @@ use super::prev::PreviousDepGraph;\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Option<Rc<DepGraphData>>,\n+    data: Option<Lrc<DepGraphData>>,\n \n     // A vector mapping depnodes from the current graph to their associated\n     // result value fingerprints. Do not rely on the length of this vector\n     // being the same as the number of nodes in the graph. The vector can\n     // contain an arbitrary number of zero-entries at the end.\n-    fingerprints: Rc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n+    fingerprints: Lrc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n \n@@ -74,7 +73,7 @@ struct DepGraphData {\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n     previous: PreviousDepGraph,\n \n-    colors: RefCell<FxHashMap<DepNode, DepNodeColor>>,\n+    colors: RefCell<DepNodeColorMap>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -97,26 +96,28 @@ impl DepGraph {\n         // Pre-allocate the fingerprints array. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n         // session.\n+        let prev_graph_node_count = prev_graph.node_count();\n+\n         let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n-                                                 (prev_graph.node_count() * 115) / 100);\n+                                                 (prev_graph_node_count * 115) / 100);\n         DepGraph {\n-            data: Some(Rc::new(DepGraphData {\n+            data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n                 dep_node_debug: RefCell::new(FxHashMap()),\n                 current: RefCell::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n-                colors: RefCell::new(FxHashMap()),\n+                colors: RefCell::new(DepNodeColorMap::new(prev_graph_node_count)),\n                 loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n-            fingerprints: Rc::new(RefCell::new(fingerprints)),\n+            fingerprints: Lrc::new(RefCell::new(fingerprints)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n         DepGraph {\n             data: None,\n-            fingerprints: Rc::new(RefCell::new(IndexVec::new())),\n+            fingerprints: Lrc::new(RefCell::new(IndexVec::new())),\n         }\n     }\n \n@@ -166,7 +167,7 @@ impl DepGraph {\n     /// what state they have access to. In particular, we want to\n     /// prevent implicit 'leaks' of tracked state into the task (which\n     /// could then be read without generating correct edges in the\n-    /// dep-graph -- see the module-level [README] for more details on\n+    /// dep-graph -- see the [rustc guide] for more details on\n     /// the dep-graph). To this end, the task function gets exactly two\n     /// pieces of state: the context `cx` and an argument `arg`. Both\n     /// of these bits of state must be of some type that implements\n@@ -186,50 +187,50 @@ impl DepGraph {\n     /// - If you need 3+ arguments, use a tuple for the\n     ///   `arg` parameter.\n     ///\n-    /// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/dep_graph/README.md\n-    pub fn with_task<C, A, R, HCX>(&self,\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/incremental-compilation.html\n+    pub fn with_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_task(key),\n             |data, key| data.borrow_mut().pop_task(key))\n     }\n \n-    fn with_task_impl<C, A, R, HCX>(&self,\n+    fn with_task_impl<'gcx, C, A, R>(&self,\n                                     key: DepNode,\n                                     cx: C,\n                                     arg: A,\n                                     task: fn(C, A) -> R,\n                                     push: fn(&RefCell<CurrentDepGraph>, DepNode),\n                                     pop: fn(&RefCell<CurrentDepGraph>, DepNode) -> DepNodeIndex)\n                                     -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         if let Some(ref data) = self.data {\n-            debug_assert!(!data.colors.borrow().contains_key(&key));\n-\n             push(&data.current, key);\n-            if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n \n             // In incremental mode, hash the result of the task. We don't\n             // do anything with the hash yet, but we are computing it\n             // anyway so that\n             //  - we make sure that the infrastructure works and\n             //  - we can get an idea of the runtime cost.\n-            let mut hcx = cx.create_stable_hashing_context();\n+            let mut hcx = cx.get_stable_hashing_context();\n+\n+            if cfg!(debug_assertions) {\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n \n             let result = task(cx, arg);\n+\n             if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskEnd)\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n             let dep_node_index = pop(&data.current, key);\n@@ -254,25 +255,27 @@ impl DepGraph {\n             }\n \n             // Determine the color of the new DepNode.\n-            {\n-                let prev_fingerprint = data.previous.fingerprint_of(&key);\n+            if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n+                let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if Some(current_fingerprint) == prev_fingerprint {\n+                let color = if current_fingerprint == prev_fingerprint {\n                     DepNodeColor::Green(dep_node_index)\n                 } else {\n                     DepNodeColor::Red\n                 };\n \n-                let old_value = data.colors.borrow_mut().insert(key, color);\n-                debug_assert!(old_value.is_none(),\n+                let mut colors = data.colors.borrow_mut();\n+                debug_assert!(colors.get(prev_index).is_none(),\n                               \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                                insertion for {:?}\", key);\n+\n+                colors.insert(prev_index, color);\n             }\n \n             (result, dep_node_index)\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n-                let mut hcx = cx.create_stable_hashing_context();\n+                let mut hcx = cx.get_stable_hashing_context();\n                 let result = task(cx, arg);\n                 let mut stable_hasher = StableHasher::new();\n                 result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -281,9 +284,11 @@ impl DepGraph {\n                 let mut fingerprints = self.fingerprints.borrow_mut();\n                 let dep_node_index = DepNodeIndex::new(fingerprints.len());\n                 fingerprints.push(fingerprint);\n+\n                 debug_assert!(fingerprints[dep_node_index] == fingerprint,\n                               \"DepGraph::with_task() - Assigned fingerprint to \\\n                                unexpected index for {:?}\", key);\n+\n                 (result, dep_node_index)\n             } else {\n                 (task(cx, arg), DepNodeIndex::INVALID)\n@@ -310,14 +315,14 @@ impl DepGraph {\n \n     /// Execute something within an \"eval-always\" task which is a task\n     // that runs whenever anything changes.\n-    pub fn with_eval_always_task<C, A, R, HCX>(&self,\n+    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_eval_always_task(key),\n@@ -356,6 +361,15 @@ impl DepGraph {\n             .unwrap()\n     }\n \n+    #[inline]\n+    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+        if let Some(ref data) = self.data {\n+            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+        } else {\n+            false\n+        }\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n         match self.fingerprints.borrow().get(dep_node_index) {\n@@ -495,7 +509,17 @@ impl DepGraph {\n     }\n \n     pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n-        self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n+        if let Some(ref data) = self.data {\n+            if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n+                return data.colors.borrow().get(prev_index)\n+            } else {\n+                // This is a node that did not exist in the previous compilation\n+                // session, so we consider it to be red.\n+                return Some(DepNodeColor::Red)\n+            }\n+        }\n+\n+        None\n     }\n \n     pub fn try_mark_green<'tcx>(&self,\n@@ -505,7 +529,6 @@ impl DepGraph {\n         debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n         let data = self.data.as_ref().unwrap();\n \n-        debug_assert!(!data.colors.borrow().contains_key(dep_node));\n         debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n \n         if dep_node.kind.is_input() {\n@@ -535,19 +558,22 @@ impl DepGraph {\n             }\n         };\n \n+        debug_assert!(data.colors.borrow().get(prev_dep_node_index).is_none());\n+\n         let mut current_deps = Vec::new();\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n \n-            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n             match dep_dep_node_color {\n                 Some(DepNodeColor::Green(node_index)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n                     debug!(\"try_mark_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\", dep_node, dep_dep_node);\n+                            be immediately green\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n@@ -556,10 +582,14 @@ impl DepGraph {\n                     // mark the DepNode as green and also don't need to bother\n                     // with checking any of the other dependencies.\n                     debug!(\"try_mark_green({:?}) - END - dependency {:?} was \\\n-                            immediately red\", dep_node, dep_dep_node);\n+                            immediately red\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     return None\n                 }\n                 None => {\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+\n                     // We don't know the state of this dependency. If it isn't\n                     // an input node, let's try to mark it green recursively.\n                     if !dep_dep_node.kind.is_input() {\n@@ -601,10 +631,8 @@ impl DepGraph {\n                     debug!(\"try_mark_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n                     if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n-                        let dep_dep_node_color = data.colors\n-                                                     .borrow()\n-                                                     .get(dep_dep_node)\n-                                                     .cloned();\n+                        let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n+\n                         match dep_dep_node_color {\n                             Some(DepNodeColor::Green(node_index)) => {\n                                 debug!(\"try_mark_green({:?}) --- managed to \\\n@@ -620,8 +648,15 @@ impl DepGraph {\n                                 return None\n                             }\n                             None => {\n-                                bug!(\"try_mark_green() - Forcing the DepNode \\\n-                                      should have set its color\")\n+                                if !tcx.sess.has_errors() {\n+                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                          should have set its color\")\n+                                } else {\n+                                    // If the query we just forced has resulted\n+                                    // in some kind of compilation error, we\n+                                    // don't expect that the corresponding\n+                                    // dep-node color has been updated.\n+                                }\n                             }\n                         }\n                     } else {\n@@ -681,26 +716,21 @@ impl DepGraph {\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n-        let old_color = data.colors\n-                            .borrow_mut()\n-                            .insert(*dep_node, DepNodeColor::Green(dep_node_index));\n-        debug_assert!(old_color.is_none(),\n+        let mut colors = data.colors.borrow_mut();\n+        debug_assert!(colors.get(prev_dep_node_index).is_none(),\n                       \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n \n+        colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+\n         debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n-    // Used in various assertions\n-    pub fn is_green(&self, dep_node_index: DepNodeIndex) -> bool {\n-        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index];\n-        self.data.as_ref().unwrap().colors.borrow().get(&dep_node).map(|&color| {\n-            match color {\n-                DepNodeColor::Red => false,\n-                DepNodeColor::Green(_) => true,\n-            }\n-        }).unwrap_or(false)\n+    // Returns true if the given node has been marked as green during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+        self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n     // This method loads all on-disk cacheable query results into memory, so\n@@ -714,20 +744,25 @@ impl DepGraph {\n     pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n-            data.colors.borrow().iter().filter_map(|(dep_node, color)| match color {\n-                DepNodeColor::Green(_) => {\n-                    if dep_node.cache_on_disk(tcx) {\n-                        Some(*dep_node)\n-                    } else {\n+            let colors = data.colors.borrow();\n+            colors.values.indices().filter_map(|prev_index| {\n+                match colors.get(prev_index) {\n+                    Some(DepNodeColor::Green(_)) => {\n+                        let dep_node = data.previous.index_to_node(prev_index);\n+                        if dep_node.cache_on_disk(tcx) {\n+                            Some(dep_node)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    None |\n+                    Some(DepNodeColor::Red) => {\n+                        // We can skip red nodes because a node can only be marked\n+                        // as red if the query result was recomputed and thus is\n+                        // already in memory.\n                         None\n                     }\n                 }\n-                DepNodeColor::Red => {\n-                    // We can skip red nodes because a node can only be marked\n-                    // as red if the query result was recomputed and thus is\n-                    // already in memory.\n-                    None\n-                }\n             }).collect()\n         };\n \n@@ -1052,3 +1087,36 @@ enum OpenTask {\n         node: DepNode,\n     },\n }\n+\n+// A data structure that stores Option<DepNodeColor> values as a contiguous\n+// array, using one u32 per entry.\n+struct DepNodeColorMap {\n+    values: IndexVec<SerializedDepNodeIndex, u32>,\n+}\n+\n+const COMPRESSED_NONE: u32 = 0;\n+const COMPRESSED_RED: u32 = 1;\n+const COMPRESSED_FIRST_GREEN: u32 = 2;\n+\n+impl DepNodeColorMap {\n+    fn new(size: usize) -> DepNodeColorMap {\n+        DepNodeColorMap {\n+            values: IndexVec::from_elem_n(COMPRESSED_NONE, size)\n+        }\n+    }\n+\n+    fn get(&self, index: SerializedDepNodeIndex) -> Option<DepNodeColor> {\n+        match self.values[index] {\n+            COMPRESSED_NONE => None,\n+            COMPRESSED_RED => Some(DepNodeColor::Red),\n+            value => Some(DepNodeColor::Green(DepNodeIndex(value - COMPRESSED_FIRST_GREEN)))\n+        }\n+    }\n+\n+    fn insert(&mut self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n+        self.values[index] = match color {\n+            DepNodeColor::Red => COMPRESSED_RED,\n+            DepNodeColor::Green(index) => index.0 + COMPRESSED_FIRST_GREEN,\n+        }\n+    }\n+}"}, {"sha": "504b60e763e23543fc9e5663acbe5bbf6a842429", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -49,6 +49,11 @@ impl PreviousDepGraph {\n         self.index[dep_node]\n     }\n \n+    #[inline]\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+        self.index.get(dep_node).cloned()\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index"}, {"sha": "b3a904f2f5fec520598714aee8882b5642f33c12", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,19 +14,6 @@\n // Each message should start and end with a new line, and be wrapped to 80 characters.\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n-E0020: r##\"\n-This error indicates that an attempt was made to divide by zero (or take the\n-remainder of a zero divisor) in a static or constant expression. Erroneous\n-code example:\n-\n-```compile_fail\n-#[deny(const_err)]\n-\n-const X: i32 = 42 / 0;\n-// error: attempt to divide by zero in a constant expression\n-```\n-\"##,\n-\n E0038: r##\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question."}, {"sha": "e283fc40c50a345fc9ed5658753bc45eb9d6836a", "filename": "src/librustc/hir/README.md", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,119 +0,0 @@\n-# Introduction to the HIR\n-\n-The HIR -- \"High-level IR\" -- is the primary IR used in most of\n-rustc. It is a desugared version of the \"abstract syntax tree\" (AST)\n-that is generated after parsing, macro expansion, and name resolution\n-have completed. Many parts of HIR resemble Rust surface syntax quite\n-closely, with the exception that some of Rust's expression forms have\n-been desugared away (as an example, `for` loops are converted into a\n-`loop` and do not appear in the HIR).\n-\n-This README covers the main concepts of the HIR.\n-\n-### Out-of-band storage and the `Crate` type\n-\n-The top-level data-structure in the HIR is the `Crate`, which stores\n-the contents of the crate currently being compiled (we only ever\n-construct HIR for the current crate). Whereas in the AST the crate\n-data structure basically just contains the root module, the HIR\n-`Crate` structure contains a number of maps and other things that\n-serve to organize the content of the crate for easier access.\n-\n-For example, the contents of individual items (e.g., modules,\n-functions, traits, impls, etc) in the HIR are not immediately\n-accessible in the parents. So, for example, if had a module item `foo`\n-containing a function `bar()`:\n-\n-```\n-mod foo {\n-  fn bar() { }\n-}\n-```\n-\n-Then in the HIR the representation of module `foo` (the `Mod`\n-stuct) would have only the **`ItemId`** `I` of `bar()`. To get the\n-details of the function `bar()`, we would lookup `I` in the\n-`items` map.\n-\n-One nice result from this representation is that one can iterate\n-over all items in the crate by iterating over the key-value pairs\n-in these maps (without the need to trawl through the IR in total).\n-There are similar maps for things like trait items and impl items,\n-as well as \"bodies\" (explained below).\n-\n-The other reason to setup the representation this way is for better\n-integration with incremental compilation. This way, if you gain access\n-to a `&hir::Item` (e.g. for the mod `foo`), you do not immediately\n-gain access to the contents of the function `bar()`. Instead, you only\n-gain access to the **id** for `bar()`, and you must invoke some\n-function to lookup the contents of `bar()` given its id; this gives us\n-a chance to observe that you accessed the data for `bar()` and record\n-the dependency.\n-\n-### Identifiers in the HIR\n-\n-Most of the code that has to deal with things in HIR tends not to\n-carry around references into the HIR, but rather to carry around\n-*identifier numbers* (or just \"ids\"). Right now, you will find four\n-sorts of identifiers in active use:\n-\n-- `DefId`, which primarily names \"definitions\" or top-level items.\n-  - You can think of a `DefId` as being shorthand for a very explicit\n-    and complete path, like `std::collections::HashMap`. However,\n-    these paths are able to name things that are not nameable in\n-    normal Rust (e.g., impls), and they also include extra information\n-    about the crate (such as its version number, as two versions of\n-    the same crate can co-exist).\n-  - A `DefId` really consists of two parts, a `CrateNum` (which\n-    identifies the crate) and a `DefIndex` (which indixes into a list\n-    of items that is maintained per crate).\n-- `HirId`, which combines the index of a particular item with an\n-  offset within that item.\n-  - the key point of a `HirId` is that it is *relative* to some item (which is named\n-    via a `DefId`).\n-- `BodyId`, this is an absolute identifier that refers to a specific\n-  body (definition of a function or constant) in the crate. It is currently\n-  effectively a \"newtype'd\" `NodeId`.\n-- `NodeId`, which is an absolute id that identifies a single node in the HIR tree.\n-  - While these are still in common use, **they are being slowly phased out**.\n-  - Since they are absolute within the crate, adding a new node\n-    anywhere in the tree causes the node-ids of all subsequent code in\n-    the crate to change. This is terrible for incremental compilation,\n-    as you can perhaps imagine.\n-\n-### HIR Map\n-\n-Most of the time when you are working with the HIR, you will do so via\n-the **HIR Map**, accessible in the tcx via `tcx.hir` (and defined in\n-the `hir::map` module). The HIR map contains a number of methods to\n-convert between ids of various kinds and to lookup data associated\n-with a HIR node.\n-\n-For example, if you have a `DefId`, and you would like to convert it\n-to a `NodeId`, you can use `tcx.hir.as_local_node_id(def_id)`. This\n-returns an `Option<NodeId>` -- this will be `None` if the def-id\n-refers to something outside of the current crate (since then it has no\n-HIR node), but otherwise returns `Some(n)` where `n` is the node-id of\n-the definition.\n-\n-Similarly, you can use `tcx.hir.find(n)` to lookup the node for a\n-`NodeId`. This returns a `Option<Node<'tcx>>`, where `Node` is an enum\n-defined in the map; by matching on this you can find out what sort of\n-node the node-id referred to and also get a pointer to the data\n-itself. Often, you know what sort of node `n` is -- e.g., if you know\n-that `n` must be some HIR expression, you can do\n-`tcx.hir.expect_expr(n)`, which will extract and return the\n-`&hir::Expr`, panicking if `n` is not in fact an expression.\n-\n-Finally, you can use the HIR map to find the parents of nodes, via\n-calls like `tcx.hir.get_parent_node(n)`.\n-\n-### HIR Bodies\n-\n-A **body** represents some kind of executable code, such as the body\n-of a function/closure or the definition of a constant. Bodies are\n-associated with an **owner**, which is typically some kind of item\n-(e.g., a `fn()` or `const`), but could also be a closure expression\n-(e.g., `|x, y| x + y`). You can use the HIR map to find the body\n-associated with a given def-id (`maybe_body_owned_by()`) or to find\n-the owner of a body (`body_owner_def_id()`)."}, {"sha": "d7194e9c2cabb420b607a2651f51998d2e027994", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -47,7 +47,13 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        self.tcx.target_features_enabled(self.tcx.hir.local_def_id(item.id));\n+        if target == Target::Fn {\n+            self.tcx.trans_fn_attrs(self.tcx.hir.local_def_id(item.id));\n+        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n+            self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n+                .span_label(item.span, \"not a function\")\n+                .emit();\n+        }\n \n         for attr in &item.attrs {\n             if let Some(name) = attr.name() {"}, {"sha": "34b3aa53d6bcf807e0e818ad4eef538128942bfb", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -220,7 +220,6 @@ impl serialize::UseSpecializedDecodable for DefId {}\n pub struct LocalDefId(DefIndex);\n \n impl LocalDefId {\n-\n     #[inline]\n     pub fn from_def_id(def_id: DefId) -> LocalDefId {\n         assert!(def_id.is_local());"}, {"sha": "972278bdf865fb5bd61db6acc405caa4e05f4c16", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -444,10 +444,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n-        ItemExternCrate(opt_name) => {\n+        ItemExternCrate(orig_name) => {\n             visitor.visit_id(item.id);\n-            if let Some(name) = opt_name {\n-                visitor.visit_name(item.span, name);\n+            if let Some(orig_name) = orig_name {\n+                visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemUse(ref path, _) => {"}, {"sha": "1439410f7e9aa2ac025f2d23b92363cc77a1f9ff", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 135, "deletions": 121, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -46,7 +46,7 @@ use hir::HirVec;\n use hir::map::{Definitions, DefKey, DefPathData};\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX, DefIndexAddressSpace};\n use hir::def::{Def, PathResolution};\n-use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n+use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES};\n use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n@@ -80,13 +80,13 @@ pub struct LoweringContext<'a> {\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n \n-    cstore: &'a CrateStore,\n+    cstore: &'a dyn CrateStore,\n \n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n-    resolver: &'a mut Resolver,\n+    resolver: &'a mut dyn Resolver,\n     name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n@@ -177,10 +177,10 @@ enum ImplTraitContext {\n }\n \n pub fn lower_crate(sess: &Session,\n-                   cstore: &CrateStore,\n+                   cstore: &dyn CrateStore,\n                    dep_graph: &DepGraph,\n                    krate: &Crate,\n-                   resolver: &mut Resolver)\n+                   resolver: &mut dyn Resolver)\n                    -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n@@ -550,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n-        self.is_collecting_in_band_lifetimes = self.sess.features.borrow().in_band_lifetimes;\n+        self.is_collecting_in_band_lifetimes = self.sess.features_untracked().in_band_lifetimes;\n \n         assert!(self.in_band_ty_params.is_empty());\n \n@@ -571,7 +571,8 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeDef(name.as_str()),\n                         DefIndexAddressSpace::High,\n-                        Mark::root()\n+                        Mark::root(),\n+                        span\n                     );\n \n                     hir::GenericParam::Lifetime(hir::LifetimeDef {\n@@ -878,7 +879,7 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n-                let span = t.span.with_hi(t.span.lo());\n+                let span = t.span.shrink_to_lo();\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_lifetime(span)\n@@ -912,7 +913,11 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Path(ref qself, ref path) => {\n                 let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n-                return self.ty_path(id, t.span, qpath);\n+                let ty = self.ty_path(id, t.span, qpath);\n+                if let hir::TyTraitObject(..) = ty.node {\n+                    self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n+                }\n+                return ty;\n             }\n             TyKind::ImplicitSelf => {\n                 hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n@@ -931,7 +936,7 @@ impl<'a> LoweringContext<'a> {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n                 hir::TyTypeof(expr)\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {\n@@ -950,14 +955,17 @@ impl<'a> LoweringContext<'a> {\n                 let lifetime_bound = lifetime_bound.unwrap_or_else(|| {\n                     self.elided_lifetime(t.span)\n                 });\n+                if kind != TraitObjectSyntax::Dyn {\n+                    self.maybe_lint_bare_trait(t.span, t.id, false);\n+                }\n                 hir::TyTraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(ref bounds) => {\n                 use syntax::feature_gate::{emit_feature_err, GateIssue};\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential => {\n-                        let has_feature = self.sess.features.borrow().conservative_impl_trait;\n+                        let has_feature = self.sess.features_untracked().conservative_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"conservative_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -981,7 +989,7 @@ impl<'a> LoweringContext<'a> {\n                         }, lifetimes)\n                     },\n                     ImplTraitContext::Universal(def_id) => {\n-                        let has_feature = self.sess.features.borrow().universal_impl_trait;\n+                        let has_feature = self.sess.features_untracked().universal_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"universal_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -996,7 +1004,8 @@ impl<'a> LoweringContext<'a> {\n                             def_node_id,\n                             DefPathData::ImplTrait,\n                             DefIndexAddressSpace::High,\n-                            Mark::root()\n+                            Mark::root(),\n+                            span\n                         );\n \n                         let hir_bounds = self.lower_bounds(bounds, itctx);\n@@ -1143,7 +1152,8 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeDef(name.name().as_str()),\n                         DefIndexAddressSpace::High,\n-                        Mark::root()\n+                        Mark::root(),\n+                        lifetime.span\n                     );\n                     let def_lifetime = hir::Lifetime {\n                         id: def_node_id,\n@@ -1345,17 +1355,11 @@ impl<'a> LoweringContext<'a> {\n                         id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n-                        param_mode: ParamMode,\n-                        defaults_to_global: bool)\n+                        param_mode: ParamMode)\n                         -> hir::Path {\n-        let mut segments = p.segments.iter();\n-        if defaults_to_global && p.is_global() {\n-            segments.next();\n-        }\n-\n         hir::Path {\n             def: self.expect_full_def(id),\n-            segments: segments.map(|segment| {\n+            segments: p.segments.iter().map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n                                         ParenthesizedGenericArgs::Err,\n                                         ImplTraitContext::Disallowed)\n@@ -1368,10 +1372,9 @@ impl<'a> LoweringContext<'a> {\n     fn lower_path(&mut self,\n                   id: NodeId,\n                   p: &Path,\n-                  param_mode: ParamMode,\n-                  defaults_to_global: bool)\n+                  param_mode: ParamMode)\n                   -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode, defaults_to_global)\n+        self.lower_path_extra(id, p, None, param_mode)\n     }\n \n     fn lower_path_segment(&mut self,\n@@ -1894,7 +1897,7 @@ impl<'a> LoweringContext<'a> {\n                        i: &ItemKind)\n                        -> hir::Item_ {\n         match *i {\n-            ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n+            ItemKind::ExternCrate(orig_name) => hir::ItemExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n                 // Start with an empty prefix\n                 let prefix = Path {\n@@ -2037,8 +2040,8 @@ impl<'a> LoweringContext<'a> {\n         let path = &tree.prefix;\n \n         match tree.kind {\n-            UseTreeKind::Simple(ident) => {\n-                *name = ident.name;\n+            UseTreeKind::Simple(rename) => {\n+                *name = tree.ident().name;\n \n                 // First apply the prefix to the path\n                 let mut path = Path {\n@@ -2054,12 +2057,12 @@ impl<'a> LoweringContext<'a> {\n                 if path.segments.len() > 1 &&\n                    path.segments.last().unwrap().identifier.name == keywords::SelfValue.name() {\n                     let _ = path.segments.pop();\n-                    if ident.name == keywords::SelfValue.name() {\n+                    if rename.is_none() {\n                         *name = path.segments.last().unwrap().identifier.name;\n                     }\n                 }\n \n-                let path = P(self.lower_path(id, &path, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &path, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -2070,7 +2073,7 @@ impl<'a> LoweringContext<'a> {\n                         .cloned()\n                         .collect(),\n                     span: path.span,\n-                }, ParamMode::Explicit, true));\n+                }, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -2126,7 +2129,7 @@ impl<'a> LoweringContext<'a> {\n                 // Privatize the degenerate import base, used only to check\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n-                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n                 *vis = hir::Inherited;\n                 hir::ItemUse(path, hir::UseKind::ListStem)\n             }\n@@ -2465,86 +2468,88 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let node = match p.node {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n+                match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n+                    // `None` can occur in body-less function signatures\n+                    def @ None | def @ Some(Def::Local(_)) => {\n+                        let canonical_id = match def {\n+                            Some(Def::Local(id)) => id,\n+                            _ => p.id\n+                        };\n+                        hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n+                                                canonical_id,\n+                                                respan(pth1.span, pth1.node.name),\n+                                                sub.as_ref().map(|x| self.lower_pat(x)))\n+                    }\n+                    Some(def) => {\n+                        hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                            span: pth1.span,\n+                            def,\n+                            segments: hir_vec![\n+                                hir::PathSegment::from_name(pth1.node.name)\n+                            ],\n+                        })))\n+                    }\n+                }\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n+            PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+                hir::PatKind::TupleStruct(qpath,\n+                                            pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                            ddpos)\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n+                                                    ImplTraitContext::Disallowed))\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                ImplTraitContext::Disallowed);\n+\n+                let fs = fields.iter()\n+                                .map(|f| {\n+                                    Spanned {\n+                                        span: f.span,\n+                                        node: hir::FieldPat {\n+                                            name: self.lower_ident(f.node.ident),\n+                                            pat: self.lower_pat(&f.node.pat),\n+                                            is_shorthand: f.node.is_shorthand,\n+                                        },\n+                                    }\n+                                })\n+                                .collect();\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref elts, ddpos) => {\n+                hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => {\n+                hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n+            }\n+            PatKind::Range(ref e1, ref e2, ref end) => {\n+                hir::PatKind::Range(P(self.lower_expr(e1)),\n+                                    P(self.lower_expr(e2)),\n+                                    self.lower_range_end(end))\n+            }\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n+                hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n+                            slice.as_ref().map(|x| self.lower_pat(x)),\n+                            after.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n-            node: match p.node {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                    match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n-                        // `None` can occur in body-less function signatures\n-                        def @ None | def @ Some(Def::Local(_)) => {\n-                            let canonical_id = match def {\n-                                Some(Def::Local(id)) => id,\n-                                _ => p.id\n-                            };\n-                            hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n-                                                  canonical_id,\n-                                                  respan(pth1.span, pth1.node.name),\n-                                                  sub.as_ref().map(|x| self.lower_pat(x)))\n-                        }\n-                        Some(def) => {\n-                            hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n-                                span: pth1.span,\n-                                def,\n-                                segments: hir_vec![\n-                                    hir::PathSegment::from_name(pth1.node.name)\n-                                ],\n-                            })))\n-                        }\n-                    }\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n-                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-                    hir::PatKind::TupleStruct(qpath,\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n-                }\n-                PatKind::Path(ref qself, ref path) => {\n-                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n-                                                        ImplTraitContext::Disallowed))\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n-                                                 ImplTraitContext::Disallowed);\n-\n-                    let fs = fields.iter()\n-                                   .map(|f| {\n-                                       Spanned {\n-                                           span: f.span,\n-                                           node: hir::FieldPat {\n-                                               name: self.lower_ident(f.node.ident),\n-                                               pat: self.lower_pat(&f.node.pat),\n-                                               is_shorthand: f.node.is_shorthand,\n-                                           },\n-                                       }\n-                                   })\n-                                   .collect();\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref elts, ddpos) => {\n-                    hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => {\n-                    hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n-                }\n-                PatKind::Range(ref e1, ref e2, ref end) => {\n-                    hir::PatKind::Range(P(self.lower_expr(e1)),\n-                                        P(self.lower_expr(e2)),\n-                                        self.lower_range_end(end))\n-                }\n-                PatKind::Slice(ref before, ref slice, ref after) => {\n-                    hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n-                                slice.as_ref().map(|x| self.lower_pat(x)),\n-                                after.iter().map(|x| self.lower_pat(x)).collect())\n-                }\n-                PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-            },\n+            node,\n             span: p.span,\n         })\n     }\n@@ -2956,7 +2961,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+            ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n                 //   match <sub_expr> {\n@@ -2970,8 +2975,8 @@ impl<'a> LoweringContext<'a> {\n                 {\n                     let body = self.lower_block(body, false);\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    arms.push(self.arm(hir_vec![pat], body_expr));\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    arms.push(self.arm(pats, body_expr));\n                 }\n \n                 // _ => [<else_opt>|()]\n@@ -3000,7 +3005,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_label) => {\n+            ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -3021,8 +3026,8 @@ impl<'a> LoweringContext<'a> {\n                 // `<pat> => <body>`\n                 let pat_arm = {\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    self.arm(hir_vec![pat], body_expr)\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    self.arm(pats, body_expr)\n                 };\n \n                 // `_ => break`\n@@ -3362,20 +3367,20 @@ impl<'a> LoweringContext<'a> {\n                         v: &Visibility,\n                         explicit_owner: Option<NodeId>)\n                         -> hir::Visibility {\n-        match *v {\n-            Visibility::Public => hir::Public,\n-            Visibility::Crate(..) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id } => {\n+        match v.node {\n+            VisibilityKind::Public => hir::Public,\n+            VisibilityKind::Crate(..) => hir::Visibility::Crate,\n+            VisibilityKind::Restricted { ref path, id, .. } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                     id: if let Some(owner) = explicit_owner {\n                         self.lower_node_id_with_owner(id, owner).node_id\n                     } else {\n                         self.lower_node_id(id).node_id\n                     }\n                 }\n             }\n-            Visibility::Inherited => hir::Inherited,\n+            VisibilityKind::Inherited => hir::Inherited,\n         }\n     }\n \n@@ -3685,7 +3690,6 @@ impl<'a> LoweringContext<'a> {\n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n-\n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n                     hir::TyPath(hir::QPath::Resolved(None, path))\n@@ -3703,6 +3707,16 @@ impl<'a> LoweringContext<'a> {\n             name: hir::LifetimeName::Implicit,\n         }\n     }\n+\n+    fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n+        if self.sess.features_untracked().dyn_trait {\n+            self.sess.buffer_lint_with_diagnostic(\n+                builtin::BARE_TRAIT_OBJECT, id, span,\n+                \"trait objects without an explicit `dyn` are deprecated\",\n+                builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global)\n+            )\n+        }\n+    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {"}, {"sha": "34ed325705ab98c231f0ae9ac578fd252c6a6f1d", "filename": "src/librustc/hir/map/README.md", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,4 +0,0 @@\n-The HIR map, accessible via `tcx.hir`, allows you to quickly navigate the\n-HIR and convert between various forms of identifiers. See [the HIR README] for more information.\n-\n-[the HIR README]: ../README.md"}, {"sha": "f77275926eba37477648a5dd8a7bca8d94868173", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -13,6 +13,7 @@ use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::def_id::{LOCAL_CRATE, CrateNum};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::svh::Svh;\n+use ich::Fingerprint;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n@@ -121,21 +122,24 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector\n     }\n \n-    pub(super) fn finalize_and_compute_crate_hash(self,\n+    pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n-                                                  cstore: &CrateStore,\n+                                                  cstore: &dyn CrateStore,\n                                                   codemap: &CodeMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n-        let mut node_hashes: Vec<_> = self\n+        self\n             .hir_body_nodes\n-            .iter()\n-            .map(|&(def_path_hash, dep_node_index)| {\n-                (def_path_hash, self.dep_graph.fingerprint_of(dep_node_index))\n-            })\n-            .collect();\n+            .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n \n-        node_hashes.sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+        let node_hashes = self\n+            .hir_body_nodes\n+            .iter()\n+            .fold(Fingerprint::ZERO, |fingerprint , &(def_path_hash, dep_node_index)| {\n+                fingerprint.combine(\n+                    def_path_hash.0.combine(self.dep_graph.fingerprint_of(dep_node_index))\n+                )\n+            });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n             let name = cstore.crate_name_untracked(cnum).as_str();\n@@ -529,7 +533,7 @@ struct HirItemLike<T> {\n     hash_bodies: bool,\n }\n \n-impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+impl<'a, 'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n     where T: HashStable<StableHashingContext<'hir>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "3619a7fb0c603288df6a75c2c5b4b8ce74f68a2f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -18,6 +18,7 @@ use syntax::visit;\n use syntax::symbol::keywords;\n use syntax::symbol::Symbol;\n use syntax::parse::token::{self, Token};\n+use syntax_pos::Span;\n \n use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n@@ -26,7 +27,7 @@ pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     expansion: Mark,\n-    pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n+    pub visit_macro_invoc: Option<&'a mut dyn FnMut(MacroInvocationData)>,\n }\n \n pub struct MacroInvocationData {\n@@ -57,12 +58,13 @@ impl<'a> DefCollector<'a> {\n     fn create_def(&mut self,\n                   node_id: NodeId,\n                   data: DefPathData,\n-                  address_space: DefIndexAddressSpace)\n+                  address_space: DefIndexAddressSpace,\n+                  span: Span)\n                   -> DefIndex {\n         let parent_def = self.parent_def.unwrap();\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions\n-            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion)\n+            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion, span)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -83,7 +85,7 @@ impl<'a> DefCollector<'a> {\n             _ => {}\n         }\n \n-        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE);\n+        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE, expr.span);\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n@@ -122,7 +124,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 return visit::walk_item(self, i);\n             }\n         };\n-        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE, i.span);\n \n         self.with_parent(def, |this| {\n             match i.node {\n@@ -131,14 +133,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name.name.as_str()),\n-                                            REGULAR_SPACE);\n+                                            REGULAR_SPACE,\n+                                            v.span);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id,\n                                                 DefPathData::Field(name.as_str()),\n-                                                REGULAR_SPACE);\n+                                                REGULAR_SPACE,\n+                                                field.span);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -152,13 +156,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),\n                                         DefPathData::StructCtor,\n-                                        REGULAR_SPACE);\n+                                        REGULAR_SPACE,\n+                                        i.span);\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name)\n                             .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                        this.create_def(field.id, DefPathData::Field(name.as_str()), REGULAR_SPACE);\n+                        this.create_def(field.id,\n+                                        DefPathData::Field(name.as_str()),\n+                                        REGULAR_SPACE,\n+                                        field.span);\n                     }\n                 }\n                 _ => {}\n@@ -168,14 +176,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n-        self.create_def(id, DefPathData::Misc, ITEM_LIKE_SPACE);\n+        self.create_def(id, DefPathData::Misc, ITEM_LIKE_SPACE, use_tree.span);\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n-                                  REGULAR_SPACE);\n+                                  REGULAR_SPACE,\n+                                  foreign_item.span);\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -188,14 +197,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 self.create_def(\n                     lifetime_def.lifetime.id,\n                     DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n-                    REGULAR_SPACE\n+                    REGULAR_SPACE,\n+                    lifetime_def.lifetime.span\n                 );\n             }\n             GenericParam::Type(ref ty_param) => {\n                 self.create_def(\n                     ty_param.id,\n                     DefPathData::TypeParam(ty_param.ident.name.as_str()),\n-                    REGULAR_SPACE\n+                    REGULAR_SPACE,\n+                    ty_param.span\n                 );\n             }\n         }\n@@ -211,7 +222,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n-        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE, ti.span);\n         self.with_parent(def, |this| {\n             if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n                 this.visit_const_expr(expr);\n@@ -229,7 +240,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n-        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE, ii.span);\n         self.with_parent(def, |this| {\n             if let ImplItemKind::Const(_, ref expr) = ii.node {\n                 this.visit_const_expr(expr);\n@@ -255,7 +266,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ExprKind::Closure(..) => {\n                 let def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n-                                          REGULAR_SPACE);\n+                                          REGULAR_SPACE,\n+                                          expr.span);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -270,7 +282,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_const_expr(length),\n             TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE);\n+                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE, ty.span);\n             }\n             TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}"}, {"sha": "1a2840de447de75d3d157288c0074610294d7002", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -28,6 +28,7 @@ use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n+use syntax_pos::{Span, DUMMY_SP};\n use util::nodemap::NodeMap;\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n@@ -72,6 +73,10 @@ impl DefPathTable {\n         index\n     }\n \n+    pub fn next_id(&self, address_space: DefIndexAddressSpace) -> DefIndex {\n+        DefIndex::from_array_index(self.index_to_key[address_space.index()].len(), address_space)\n+    }\n+\n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.index_to_key[index.address_space().index()]\n@@ -155,6 +160,7 @@ pub struct Definitions {\n     macro_def_scopes: FxHashMap<Mark, DefId>,\n     expansions: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n+    def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -172,6 +178,7 @@ impl Clone for Definitions {\n             macro_def_scopes: self.macro_def_scopes.clone(),\n             expansions: self.expansions.clone(),\n             next_disambiguator: self.next_disambiguator.clone(),\n+            def_index_to_span: self.def_index_to_span.clone(),\n         }\n     }\n }\n@@ -406,6 +413,7 @@ impl Definitions {\n             macro_def_scopes: FxHashMap(),\n             expansions: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n+            def_index_to_span: FxHashMap(),\n         }\n     }\n \n@@ -489,6 +497,22 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    /// Retrieve the span of the given `DefId` if `DefId` is in the local crate, the span exists and\n+    /// it's not DUMMY_SP\n+    #[inline]\n+    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n+        if def_id.krate == LOCAL_CRATE {\n+            let span = self.def_index_to_span.get(&def_id.index).cloned().unwrap_or(DUMMY_SP);\n+            if span != DUMMY_SP {\n+                Some(span)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n@@ -526,7 +550,8 @@ impl Definitions {\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n                                   address_space: DefIndexAddressSpace,\n-                                  expansion: Mark)\n+                                  expansion: Mark,\n+                                  span: Span)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -579,6 +604,11 @@ impl Definitions {\n             self.expansions.insert(index, expansion);\n         }\n \n+        // The span is added if it isn't DUMMY_SP\n+        if span != DUMMY_SP {\n+            self.def_index_to_span.insert(index, span);\n+        }\n+\n         index\n     }\n \n@@ -688,7 +718,8 @@ macro_rules! define_global_metadata_kind {\n                         ast::DUMMY_NODE_ID,\n                         DefPathData::GlobalMetaData(instance.name().as_str()),\n                         GLOBAL_MD_ADDRESS_SPACE,\n-                        Mark::root()\n+                        Mark::root(),\n+                        DUMMY_SP\n                     );\n \n                     // Make sure calling def_index does not crash."}, {"sha": "61fae4609d54fe7813b76857c5baa5fb6e48ed09", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,9 +19,12 @@ use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n+use middle::cstore::CrateStore;\n+\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n+use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n \n use hir::*;\n@@ -32,13 +35,15 @@ use util::nodemap::{DefIdMap, FxHashMap};\n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n+use ty::TyCtxt;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n+\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n@@ -373,6 +378,92 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n     }\n \n+    pub fn describe_def(&self, node_id: NodeId) -> Option<Def> {\n+        let node = if let Some(node) = self.find(node_id) {\n+            node\n+        } else {\n+            return None\n+        };\n+\n+        match node {\n+            NodeItem(item) => {\n+                let def_id = || {\n+                    self.local_def_id(item.id)\n+                };\n+\n+                match item.node {\n+                    ItemStatic(_, m, _) => Some(Def::Static(def_id(),\n+                                                            m == MutMutable)),\n+                    ItemConst(..) => Some(Def::Const(def_id())),\n+                    ItemFn(..) => Some(Def::Fn(def_id())),\n+                    ItemMod(..) => Some(Def::Mod(def_id())),\n+                    ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemTy(..) => Some(Def::TyAlias(def_id())),\n+                    ItemEnum(..) => Some(Def::Enum(def_id())),\n+                    ItemStruct(..) => Some(Def::Struct(def_id())),\n+                    ItemUnion(..) => Some(Def::Union(def_id())),\n+                    ItemTrait(..) => Some(Def::Trait(def_id())),\n+                    ItemTraitAlias(..) => {\n+                        bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n+                    },\n+                    ItemExternCrate(_) |\n+                    ItemUse(..) |\n+                    ItemForeignMod(..) |\n+                    ItemImpl(..) => None,\n+                }\n+            }\n+            NodeForeignItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ForeignItemFn(..) => Some(Def::Fn(def_id)),\n+                    ForeignItemStatic(_, m) => Some(Def::Static(def_id, m)),\n+                    ForeignItemType => Some(Def::TyForeign(def_id)),\n+                }\n+            }\n+            NodeTraitItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeImplItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    ImplItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeVariant(variant) => {\n+                let def_id = self.local_def_id(variant.node.data.id());\n+                Some(Def::Variant(def_id))\n+            }\n+            NodeField(_) |\n+            NodeExpr(_) |\n+            NodeStmt(_) |\n+            NodeTy(_) |\n+            NodeTraitRef(_) |\n+            NodePat(_) |\n+            NodeBinding(_) |\n+            NodeStructCtor(_) |\n+            NodeLifetime(_) |\n+            NodeVisibility(_) |\n+            NodeBlock(_) => None,\n+            NodeLocal(local) => {\n+                Some(Def::Local(local.id))\n+            }\n+            NodeMacroDef(macro_def) => {\n+                Some(Def::Macro(self.local_def_id(macro_def.id),\n+                                MacroKind::Bang))\n+            }\n+            NodeTyParam(param) => {\n+                Some(Def::TyParam(self.local_def_id(param.id)))\n+            }\n+        }\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }\n@@ -1047,8 +1138,9 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n+\n pub fn map_crate<'hir>(sess: &::session::Session,\n-                       cstore: &::middle::cstore::CrateStore,\n+                       cstore: &dyn CrateStore,\n                        forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n@@ -1275,3 +1367,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n+\n+pub fn describe_def(tcx: TyCtxt, def_id: DefId) -> Option<Def> {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        tcx.hir.describe_def(node_id)\n+    } else {\n+        bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n+             def_id)\n+    }\n+}"}, {"sha": "5ae84f5685eafca61a09c0716dd2de7ff76d7a56", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -30,19 +30,22 @@ pub use self::Visibility::{Public, Inherited};\n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n+use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n+use ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec;\n \n@@ -211,7 +214,7 @@ impl LifetimeName {\n         use self::LifetimeName::*;\n         match *self {\n             Implicit => keywords::Invalid.name(),\n-            Underscore => Symbol::intern(\"'_\"),\n+            Underscore => keywords::UnderscoreLifetime.name(),\n             Static => keywords::StaticLifetime.name(),\n             Name(name) => name,\n         }\n@@ -601,9 +604,9 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n /// The top-level data structure that stores the entire contents of\n /// the crate currently being compiled.\n ///\n-/// For more details, see the module-level [README].\n+/// For more details, see the [rustc guide].\n ///\n-/// [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/hir/README.md.\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/hir.html\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n@@ -2008,9 +2011,9 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n-    /// An `extern crate` item, with optional original crate name,\n+    /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n+    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ItemExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2204,3 +2207,56 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n+\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.describe_def = map::describe_def;\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n+pub struct TransFnAttrs {\n+    pub flags: TransFnAttrFlags,\n+    pub inline: InlineAttr,\n+    pub export_name: Option<Symbol>,\n+    pub target_features: Vec<Symbol>,\n+    pub linkage: Option<Linkage>,\n+}\n+\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    pub struct TransFnAttrFlags: u8 {\n+        const COLD                      = 0b0000_0001;\n+        const ALLOCATOR                 = 0b0000_0010;\n+        const UNWIND                    = 0b0000_0100;\n+        const RUSTC_ALLOCATOR_NOUNWIND  = 0b0000_1000;\n+        const NAKED                     = 0b0001_0000;\n+        const NO_MANGLE                 = 0b0010_0000;\n+        const RUSTC_STD_INTERNAL_SYMBOL = 0b0100_0000;\n+    }\n+}\n+\n+impl TransFnAttrs {\n+    pub fn new() -> TransFnAttrs {\n+        TransFnAttrs {\n+            flags: TransFnAttrFlags::empty(),\n+            inline: InlineAttr::None,\n+            export_name: None,\n+            target_features: vec![],\n+            linkage: None,\n+        }\n+    }\n+\n+    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    pub fn requests_inline(&self) -> bool {\n+        match self.inline {\n+            InlineAttr::Hint | InlineAttr::Always => true,\n+            InlineAttr::None | InlineAttr::Never => false,\n+        }\n+    }\n+\n+    /// True if `#[no_mangle]` or `#[export_name(...)]` is present.\n+    pub fn contains_extern_indicator(&self) -> bool {\n+        self.flags.contains(TransFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n+    }\n+}\n+"}, {"sha": "3d38c0c8ed9e57f396076d84786fdc54bdc13e43", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -62,7 +62,7 @@ pub trait PpAnn {\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n-pub const NO_ANN: &'static PpAnn = &NoAnn;\n+pub const NO_ANN: &'static dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n     fn nested(&self, state: &mut State, nested: Nested) -> io::Result<()> {\n@@ -83,7 +83,7 @@ pub struct State<'a> {\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a (PpAnn + 'a),\n+    ann: &'a (dyn PpAnn + 'a),\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -126,9 +126,9 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n-                       input: &mut Read,\n-                       out: Box<Write + 'a>,\n-                       ann: &'a PpAnn,\n+                       input: &mut dyn Read,\n+                       out: Box<dyn Write + 'a>,\n+                       ann: &'a dyn PpAnn,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n@@ -145,9 +145,9 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n-                          input: &mut Read,\n-                          out: Box<Write + 'a>,\n-                          ann: &'a PpAnn,\n+                          input: &mut dyn Read,\n+                          out: Box<dyn Write + 'a>,\n+                          ann: &'a dyn PpAnn,\n                           is_expanded: bool)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n@@ -167,8 +167,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<Write + 'a>,\n-               ann: &'a PpAnn,\n+               out: Box<dyn Write + 'a>,\n+               ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>)\n                -> State<'a> {\n@@ -184,7 +184,7 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n+pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n     where F: FnOnce(&mut State) -> io::Result<()>\n {\n     let mut wr = Vec::new();\n@@ -524,15 +524,10 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n-            hir::ItemExternCrate(ref optional_path) => {\n+            hir::ItemExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n-                if let Some(p) = *optional_path {\n-                    let val = p.as_str();\n-                    if val.contains(\"-\") {\n-                        self.print_string(&val, ast::StrStyle::Cooked)?;\n-                    } else {\n-                        self.print_name(p)?;\n-                    }\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name)?;\n                     self.s.space()?;\n                     self.s.word(\"as\")?;\n                     self.s.space()?;\n@@ -1810,15 +1805,35 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             PatKind::Box(ref inner) => {\n+                let is_range_inner = match inner.node {\n+                    PatKind::Range(..) => true,\n+                    _ => false,\n+                };\n                 self.s.word(\"box \")?;\n+                if is_range_inner {\n+                    self.popen()?;\n+                }\n                 self.print_pat(&inner)?;\n+                if is_range_inner {\n+                    self.pclose()?;\n+                }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n+                let is_range_inner = match inner.node {\n+                    PatKind::Range(..) => true,\n+                    _ => false,\n+                };\n                 self.s.word(\"&\")?;\n                 if mutbl == hir::MutMutable {\n                     self.s.word(\"mut \")?;\n                 }\n+                if is_range_inner {\n+                    self.popen()?;\n+                }\n                 self.print_pat(&inner)?;\n+                if is_range_inner {\n+                    self.pclose()?;\n+                }\n             }\n             PatKind::Lit(ref e) => self.print_expr(&e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n@@ -2208,13 +2223,8 @@ impl<'a> State<'a> {\n         if self.next_comment().is_none() {\n             self.s.hardbreak()?;\n         }\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    self.print_comment(cmnt)?;\n-                }\n-                _ => break,\n-            }\n+        while let Some(ref cmnt) = self.next_comment() {\n+            self.print_comment(cmnt)?\n         }\n         Ok(())\n     }"}, {"sha": "e5bf384d253c526c386455bd52907f789d5952f2", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n \n@@ -18,7 +18,7 @@ struct CacheEntry {\n     line_number: usize,\n     line_start: BytePos,\n     line_end: BytePos,\n-    file: Rc<FileMap>,\n+    file: Lrc<FileMap>,\n     file_index: usize,\n }\n \n@@ -51,7 +51,7 @@ impl<'cm> CachingCodemapView<'cm> {\n \n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n-                                    -> Option<(Rc<FileMap>, usize, BytePos)> {\n+                                    -> Option<(Lrc<FileMap>, usize, BytePos)> {\n         self.time_stamp += 1;\n \n         // Check if the position is in one of the cached lines"}, {"sha": "33e0d0e69449756e7199ae9f45fb78244ef26801", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -30,7 +30,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n+use rustc_data_structures::stable_hasher::{HashStable,\n                                            StableHasher, StableHasherResult,\n                                            ToStableHashKey};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -46,19 +46,19 @@ pub fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n #[derive(Clone)]\n-pub struct StableHashingContext<'gcx> {\n-    sess: &'gcx Session,\n-    definitions: &'gcx Definitions,\n-    cstore: &'gcx CrateStore,\n-    body_resolver: BodyResolver<'gcx>,\n+pub struct StableHashingContext<'a> {\n+    sess: &'a Session,\n+    definitions: &'a Definitions,\n+    cstore: &'a dyn CrateStore,\n+    body_resolver: BodyResolver<'a>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n     // CachingCodemapView, so we initialize it lazily.\n-    raw_codemap: &'gcx CodeMap,\n-    caching_codemap: Option<CachingCodemapView<'gcx>>,\n+    raw_codemap: &'a CodeMap,\n+    caching_codemap: Option<CachingCodemapView<'a>>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -81,14 +81,14 @@ impl<'gcx> BodyResolver<'gcx> {\n     }\n }\n \n-impl<'gcx> StableHashingContext<'gcx> {\n+impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n-    pub fn new(sess: &'gcx Session,\n-               krate: &'gcx hir::Crate,\n-               definitions: &'gcx Definitions,\n-               cstore: &'gcx CrateStore)\n+    pub fn new(sess: &'a Session,\n+               krate: &'a hir::Crate,\n+               definitions: &'a Definitions,\n+               cstore: &'a dyn CrateStore)\n                -> Self {\n         let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n \n@@ -106,7 +106,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn sess(&self) -> &'gcx Session {\n+    pub fn sess(&self) -> &'a Session {\n         self.sess\n     }\n \n@@ -165,7 +165,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'a> {\n         match self.caching_codemap {\n             Some(ref mut cm) => {\n                 cm\n@@ -192,39 +192,55 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        (*self).create_stable_hashing_context()\n+/// Something that can provide a stable hashing context.\n+pub trait StableHashingContextProvider<'a> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a>;\n+}\n+\n+impl<'a, 'b, T: StableHashingContextProvider<'a>> StableHashingContextProvider<'a>\n+for &'b T {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (**self).get_stable_hashing_context()\n     }\n }\n \n+impl<'a, 'b, T: StableHashingContextProvider<'a>> StableHashingContextProvider<'a>\n+for &'b mut T {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (**self).get_stable_hashing_context()\n+    }\n+}\n+\n+impl<'a, 'gcx, 'lcx> StableHashingContextProvider<'a> for TyCtxt<'a, 'gcx, 'lcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+        (*self).create_stable_hashing_context()\n+    }\n+}\n \n-impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n         self.clone()\n     }\n }\n \n-impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+impl<'a> ::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -243,21 +259,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let def_path_hash = hcx.local_def_path_hash(self.owner);\n         (def_path_hash, self.local_id)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -270,18 +286,18 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n+impl<'a> HashStable<StableHashingContext<'a>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -293,7 +309,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n@@ -373,8 +389,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_trait_impls<'gcx, W, R>(\n-    hcx: &mut StableHashingContext<'gcx>,\n+pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'a>,\n     hasher: &mut StableHasher<W>,\n     blanket_impls: &Vec<DefId>,\n     non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)"}, {"sha": "5f3ff461c0c7ec5a28309a77c093c019c9e6bc5f", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -16,33 +16,6 @@ impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n     bits\n });\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n-    I8(val),\n-    I16(val),\n-    I32(val),\n-    I64(val),\n-    I128(val),\n-    Isize(val),\n-    U8(val),\n-    U16(val),\n-    U32(val),\n-    U64(val),\n-    U128(val),\n-    Usize(val)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n-    Is16(i16),\n-    Is32(i32),\n-    Is64(i64)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n-    Us16(i16),\n-    Us32(i32),\n-    Us64(i64)\n-});\n-\n impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n     NotInRange,\n     CmpBetweenUnequalTypes,"}, {"sha": "e764cedd658b5df4070f031fcd0f5bc33c26c663", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 105, "deletions": 67, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,47 +19,48 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n use syntax::ast;\n+use syntax::attr;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(*self)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(self.to_def_id())\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> HashStable<StableHashingContext<'a>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n@@ -68,25 +69,25 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         def_id.to_stable_hash_key(hcx)\n     }\n }\n \n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> hir::ItemLocalId {\n         *self\n     }\n@@ -99,9 +100,9 @@ for hir::ItemLocalId {\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -113,9 +114,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -127,9 +128,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -270,9 +271,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n@@ -338,9 +339,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -375,9 +376,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -399,9 +400,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Pat {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Pat {\n             id: _,\n@@ -526,9 +527,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -590,9 +591,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -646,9 +647,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -659,9 +660,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id: _,\n@@ -694,9 +695,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id: _,\n@@ -728,9 +729,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -749,9 +750,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Defaultness {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -770,9 +771,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Mod {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -825,9 +826,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Item {\n             name,\n@@ -850,7 +851,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n }\n \n impl_stable_hash_for!(enum hir::Item_ {\n-    ItemExternCrate(name),\n+    ItemExternCrate(orig_name),\n     ItemUse(path, use_kind),\n     ItemStatic(ty, mutability, body_id),\n     ItemConst(ty, body_id),\n@@ -884,10 +885,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -929,9 +930,9 @@ impl_stable_hash_for!(struct hir::Arg {\n     hir_id\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n             ref arguments,\n@@ -947,12 +948,12 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let hir::BodyId { node_id } = *self;\n         node_id.to_stable_hash_key(hcx)\n@@ -965,9 +966,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -978,9 +979,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::InlineAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1061,22 +1062,22 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n          hcx.local_def_path_hash(*self)\n     }\n }\n@@ -1089,10 +1090,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     is_import\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n@@ -1103,10 +1104,10 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {\n@@ -1120,11 +1121,11 @@ for hir::TraitCandidate {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     type KeyType = (DefPathHash, Option<(DefPathHash, hir::ItemLocalId)>);\n \n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> Self::KeyType {\n         let hir::TraitCandidate {\n             def_id,\n@@ -1138,6 +1139,43 @@ impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n     }\n }\n \n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TransFnAttrs {\n+            flags,\n+            inline,\n+            export_name,\n+            ref target_features,\n+            linkage,\n+        } = *self;\n+\n+        flags.hash_stable(hcx, hasher);\n+        inline.hash_stable(hcx, hasher);\n+        export_name.hash_stable(hcx, hasher);\n+        target_features.hash_stable(hcx, hasher);\n+        linkage.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrFlags\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.bits().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::Freevar {\n     def,"}, {"sha": "1e6dadae363717729d0e567fdd07686f965d725e", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -35,11 +35,11 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::BorrowKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -54,11 +54,11 @@ for mir::BorrowKind {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::UnsafetyViolationKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -79,12 +79,12 @@ impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n     source_info\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for mir::ClearCrossCrate<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -96,61 +96,61 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::BasicBlock {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Field {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Promoted {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::TerminatorKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -227,10 +227,10 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AssertMessage<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -250,10 +250,10 @@ for mir::AssertMessage<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::StatementKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -287,12 +287,12 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n     for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>)\n     {\n         self.place.hash_stable(hcx, hasher);\n@@ -304,9 +304,9 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -323,14 +323,14 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n     }\n }\n \n-impl<'gcx, B, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, B, V, T> HashStable<StableHashingContext<'a>>\n for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'gcx>>,\n-          V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where B: HashStable<StableHashingContext<'a>>,\n+          V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -342,13 +342,13 @@ for mir::Projection<'gcx, B, V, T>\n     }\n }\n \n-impl<'gcx, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, V, T> HashStable<StableHashingContext<'a>>\n for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -382,9 +382,9 @@ impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n     lint_root, safety\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Safety {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -399,9 +399,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -419,9 +419,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Rvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -479,10 +479,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AggregateKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -541,9 +541,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -570,9 +570,9 @@ impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n     blame_span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubject<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubject<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -585,3 +585,5 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubjec\n         }\n     }\n }\n+\n+impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });"}, {"sha": "513b6c835f982337cb3b9f72b85e9a473446eab2", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -17,6 +17,7 @@ use std::hash as std_hash;\n use std::mem;\n \n use syntax::ast;\n+use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::symbol::InternedString;\n use syntax::tokenstream;\n@@ -28,42 +29,42 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.clone()\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.as_str()\n     }\n@@ -110,10 +111,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     rustc_const_unstable\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -165,9 +166,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n+impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n@@ -190,9 +191,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -219,10 +220,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -241,20 +242,22 @@ for tokenstream::TokenTree {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n-                                           hcx: &mut StableHashingContext<'gcx>,\n-                                           hasher: &mut StableHasher<W>) {\n+fn hash_token<'a, 'gcx, W: StableHasherResult>(\n+    token: &token::Token,\n+    hcx: &mut StableHashingContext<'a>,\n+    hasher: &mut StableHasher<W>,\n+) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n     match *token {\n         token::Token::Eq |\n@@ -284,7 +287,6 @@ fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n         token::Token::Pound |\n         token::Token::Dollar |\n         token::Token::Question |\n-        token::Token::Underscore |\n         token::Token::Whitespace |\n         token::Token::Comment |\n         token::Token::Eof => {}\n@@ -382,9 +384,9 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Custom(s)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             name: _, // We hash the smaller name_hash instead of this\n@@ -414,24 +416,27 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n         src_hash.hash_stable(hcx, hasher);\n \n         // We only hash the relative position within this filemap\n-        let lines = lines.borrow();\n-        lines.len().hash_stable(hcx, hasher);\n-        for &line in lines.iter() {\n-            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-        }\n+        lines.with_lock(|lines| {\n+            lines.len().hash_stable(hcx, hasher);\n+            for &line in lines.iter() {\n+                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n \n         // We only hash the relative position within this filemap\n-        let multibyte_chars = multibyte_chars.borrow();\n-        multibyte_chars.len().hash_stable(hcx, hasher);\n-        for &char_pos in multibyte_chars.iter() {\n-            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-        }\n+        multibyte_chars.with_lock(|multibyte_chars| {\n+            multibyte_chars.len().hash_stable(hcx, hasher);\n+            for &char_pos in multibyte_chars.iter() {\n+                stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n \n-        let non_narrow_chars = non_narrow_chars.borrow();\n-        non_narrow_chars.len().hash_stable(hcx, hasher);\n-        for &char_pos in non_narrow_chars.iter() {\n-            stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-        }\n+        non_narrow_chars.with_lock(|non_narrow_chars| {\n+            non_narrow_chars.len().hash_stable(hcx, hasher);\n+            for &char_pos in non_narrow_chars.iter() {\n+                stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n     }\n }\n \n@@ -460,3 +465,21 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n \n     (pos.0 - filemap_start.0, width as u32)\n }\n+\n+\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for feature_gate::Features {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Unfortunately we cannot exhaustively list fields here, since the\n+        // struct is macro generated.\n+        self.declared_stable_lang_features.hash_stable(hcx, hasher);\n+        self.declared_lib_features.hash_stable(hcx, hasher);\n+\n+        self.walk_feature_fields(|feature_name, value| {\n+            feature_name.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "9a442e0529938e0a0eddc57b4f3b8cd19073e53b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 538, "deletions": 152, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -19,14 +19,16 @@ use std::cell::RefCell;\n use std::hash as std_hash;\n use std::mem;\n use middle::region;\n+use infer;\n use traits;\n use ty;\n+use mir;\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for &'gcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'gcx>> {\n+    where T: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n@@ -51,20 +53,31 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        self.as_type().hash_stable(hcx, hasher);\n-        self.as_region().hash_stable(hcx, hasher);\n+        self.unpack().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ty::subst::UnpackedKind<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match self {\n+            ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n+            ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -73,6 +86,9 @@ for ty::RegionKind {\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReCanonical(c) => {\n+                c.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.depth.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n@@ -108,7 +124,17 @@ for ty::RegionKind {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CanonicalVar {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n@@ -118,10 +144,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -136,10 +162,10 @@ for ty::adjustment::AutoBorrow<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::Adjust<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -185,10 +211,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::UpvarCapture<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -212,11 +238,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Binder(ref inner) = *self;\n         inner.hash_stable(hcx, hasher);\n@@ -233,16 +259,15 @@ impl_stable_hash_for!(enum ty::Visibility {\n \n impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n-impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, A, B> HashStable<StableHashingContext<'a>>\n for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'gcx>>,\n-          B: HashStable<StableHashingContext<'gcx>>,\n+    where A: HashStable<StableHashingContext<'a>>,\n+          B: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -254,18 +279,15 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::Predicate<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             ty::Predicate::Trait(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }\n-            ty::Predicate::Equate(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n             ty::Predicate::Subtype(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }\n@@ -297,9 +319,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::AdtFlags {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -324,69 +346,102 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n-        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Integral(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Float(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Str(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            ByteStr(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Bool(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Char(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Variant(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            Function(def_id, substs) => {\n+            Unevaluated(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    substs.hash_stable(hcx, hasher);\n-                });\n-            }\n-            Aggregate(Struct(ref name_values)) => {\n-                let mut values = name_values.to_vec();\n-                values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n-                values.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Tuple(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Array(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n             }\n-            Aggregate(Repeat(ref value, times)) => {\n+            Value(ref value) => {\n                 value.hash_stable(hcx, hasher);\n-                times.hash_stable(hcx, hasher);\n             }\n-            Unevaluated(def_id, substs) => {\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::interpret::Value {\n+    ByVal(v),\n+    ByValPair(a, b),\n+    ByRef(ptr, align)\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n+    alloc_id,\n+    offset\n+});\n+\n+enum AllocDiscriminant {\n+    Static,\n+    Constant,\n+    Function,\n+}\n+impl_stable_hash_for!(enum self::AllocDiscriminant {\n+    Static,\n+    Constant,\n+    Function\n+});\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        ty::tls::with_opt(|tcx| {\n+            let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n+            if let Some(def_id) = tcx.interpret_interner.get_corresponding_static_def_id(*self) {\n+                AllocDiscriminant::Static.hash_stable(hcx, hasher);\n+                // statics are unique via their DefId\n                 def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n+            } else if let Some(alloc) = tcx.interpret_interner.get_alloc(*self) {\n+                // not a static, can't be recursive, hash the allocation\n+                AllocDiscriminant::Constant.hash_stable(hcx, hasher);\n+                alloc.hash_stable(hcx, hasher);\n+            } else if let Some(inst) = tcx.interpret_interner.get_fn(*self) {\n+                AllocDiscriminant::Function.hash_stable(hcx, hasher);\n+                inst.hash_stable(hcx, hasher);\n+            } else {\n+                bug!(\"no allocation for {}\", self);\n             }\n+        });\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.bytes.hash_stable(hcx, hasher);\n+        for reloc in self.relocations.iter() {\n+            reloc.hash_stable(hcx, hasher);\n         }\n+        self.undef_mask.hash_stable(hcx, hasher);\n+        self.align.hash_stable(hcx, hasher);\n+        self.runtime_mutability.hash_stable(hcx, hasher);\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n-    data\n+impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n+    Immutable,\n+    Mutable\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n+\n+impl_stable_hash_for!(enum mir::interpret::PrimVal {\n+    Bytes(b),\n+    Ptr(p),\n+    Undef\n });\n \n impl_stable_hash_for!(struct ty::Const<'tcx> {\n@@ -399,26 +454,22 @@ impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n     kind\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl_stable_hash_for!(struct ::middle::const_val::FrameInfo {\n+    span,\n+    location\n+});\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ErrKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ErrKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            CannotCast |\n-            MissingStructField |\n             NonConstPath |\n-            ExpectedConstTuple |\n-            ExpectedConstStruct |\n-            IndexedNonVec |\n-            IndexNotUsize |\n-            MiscBinaryOp |\n-            MiscCatchAll |\n-            IndexOpFeatureGated |\n             TypeckError |\n             CheckMatchError => {\n                 // nothing to do\n@@ -436,9 +487,10 @@ for ::middle::const_val::ErrKind<'gcx> {\n             LayoutError(ref layout_error) => {\n                 layout_error.hash_stable(hcx, hasher);\n             }\n-            ErroneousReferencedConstant(ref const_val) => {\n-                const_val.hash_stable(hcx, hasher);\n-            }\n+            Miri(ref err, ref trace) => {\n+                err.hash_stable(hcx, hasher);\n+                trace.hash_stable(hcx, hasher);\n+            },\n         }\n     }\n }\n@@ -452,6 +504,167 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::EvalError<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::EvalErrorKind::*;\n+\n+        mem::discriminant(&self.kind).hash_stable(hcx, hasher);\n+\n+        match self.kind {\n+            DanglingPointerDeref |\n+            DoubleFree |\n+            InvalidMemoryAccess |\n+            InvalidFunctionPointer |\n+            InvalidBool |\n+            InvalidDiscriminant |\n+            InvalidNullPointerUsage |\n+            ReadPointerAsBytes |\n+            ReadBytesAsPointer |\n+            InvalidPointerMath |\n+            ReadUndefBytes |\n+            DeadLocal |\n+            ExecutionTimeLimitReached |\n+            StackFrameLimitReached |\n+            OutOfTls |\n+            TlsOutOfBounds |\n+            CalledClosureAsFunction |\n+            VtableForArgumentlessMethod |\n+            ModifiedConstantMemory |\n+            AssumptionNotHeld |\n+            InlineAsm |\n+            ReallocateNonBasePtr |\n+            DeallocateNonBasePtr |\n+            HeapAllocZeroBytes |\n+            Unreachable |\n+            Panic |\n+            ReadFromReturnPointer |\n+            UnimplementedTraitSelection |\n+            TypeckError |\n+            DerefFunctionPointer |\n+            ExecuteMemory |\n+            ReferencedConstant |\n+            OverflowingMath => {}\n+            MachineError(ref err) => err.hash_stable(hcx, hasher),\n+            FunctionPointerTyMismatch(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            NoMirFor(ref s) => s.hash_stable(hcx, hasher),\n+            UnterminatedCString(ptr) => ptr.hash_stable(hcx, hasher),\n+            PointerOutOfBounds {\n+                ptr,\n+                access,\n+                allocation_size,\n+            } => {\n+                ptr.hash_stable(hcx, hasher);\n+                access.hash_stable(hcx, hasher);\n+                allocation_size.hash_stable(hcx, hasher)\n+            },\n+            InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n+            Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n+            ArrayIndexOutOfBounds(sp, a, b) => {\n+                sp.hash_stable(hcx, hasher);\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            Math(sp, ref err) => {\n+                sp.hash_stable(hcx, hasher);\n+                err.hash_stable(hcx, hasher)\n+            },\n+            Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n+            InvalidChar(c) => c.hash_stable(hcx, hasher),\n+            AbiViolation(ref s) => s.hash_stable(hcx, hasher),\n+            AlignmentCheckFailed {\n+                required,\n+                has,\n+            } => {\n+                required.hash_stable(hcx, hasher);\n+                has.hash_stable(hcx, hasher)\n+            },\n+            MemoryLockViolation {\n+                ptr,\n+                len,\n+                frame,\n+                access,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                frame.hash_stable(hcx, hasher);\n+                access.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            MemoryAcquireConflict {\n+                ptr,\n+                len,\n+                kind,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                kind.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            InvalidMemoryLockRelease {\n+                ptr,\n+                len,\n+                frame,\n+                ref lock,\n+            } =>  {\n+                ptr.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+                frame.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            DeallocatedLockedMemory {\n+                ptr,\n+                ref lock,\n+            } => {\n+                ptr.hash_stable(hcx, hasher);\n+                lock.hash_stable(hcx, hasher)\n+            },\n+            ValidationFailure(ref s) => s.hash_stable(hcx, hasher),\n+            TypeNotPrimitive(ty) => ty.hash_stable(hcx, hasher),\n+            ReallocatedWrongMemoryKind(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            DeallocatedWrongMemoryKind(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            IncorrectAllocationInformation(a, b, c, d) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+                c.hash_stable(hcx, hasher);\n+                d.hash_stable(hcx, hasher)\n+            },\n+            Layout(lay) => lay.hash_stable(hcx, hasher),\n+            HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n+            PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::interpret::Lock {\n+    NoLock,\n+    WriteLock(dl),\n+    ReadLock(v)\n+});\n+\n+impl_stable_hash_for!(struct mir::interpret::DynamicLifetime {\n+    frame,\n+    region\n+});\n+\n+impl_stable_hash_for!(enum mir::interpret::AccessKind {\n+    Read,\n+    Write\n+});\n+\n impl_stable_hash_for!(enum ty::Variance {\n     Covariant,\n     Invariant,\n@@ -463,9 +676,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -491,10 +704,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -520,12 +733,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     synthetic\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -576,11 +789,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n impl_stable_hash_for!(tuple_struct ::middle::region::FirstStatementIndex { idx });\n impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'gcx>) -> region::Scope {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'a>) -> region::Scope {\n         *self\n     }\n }\n@@ -606,11 +819,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::TypeVariants<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -673,9 +886,8 @@ for ty::TypeVariants<'gcx>\n             TyGeneratorWitness(types) => {\n                 types.hash_stable(hcx, hasher)\n             }\n-            TyTuple(inner_tys, from_diverging_type_var) => {\n+            TyTuple(inner_tys) => {\n                 inner_tys.hash_stable(hcx, hasher);\n-                from_diverging_type_var.hash_stable(hcx, hasher);\n             }\n             TyProjection(ref projection_ty) => {\n                 projection_ty.hash_stable(hcx, hasher);\n@@ -690,13 +902,59 @@ for ty::TypeVariants<'gcx>\n             TyForeign(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            TyInfer(..) => {\n-                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant {:?}.\", *self)\n+            TyInfer(infer_ty) => {\n+                infer_ty.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n+impl_stable_hash_for!(enum ty::InferTy {\n+    TyVar(a),\n+    IntVar(a),\n+    FloatVar(a),\n+    FreshTy(a),\n+    FreshIntTy(a),\n+    FreshFloatTy(a),\n+    CanonicalTy(a),\n+});\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ty::TyVid\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _hcx: &mut StableHashingContext<'a>,\n+                                          _hasher: &mut StableHasher<W>) {\n+        // TyVid values are confined to an inference context and hence\n+        // should not be hashed.\n+        bug!(\"ty::TypeVariants::hash_stable() - can't hash a TyVid {:?}.\", *self)\n+    }\n+}\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ty::IntVid\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _hcx: &mut StableHashingContext<'a>,\n+                                          _hasher: &mut StableHasher<W>) {\n+        // IntVid values are confined to an inference context and hence\n+        // should not be hashed.\n+        bug!(\"ty::TypeVariants::hash_stable() - can't hash an IntVid {:?}.\", *self)\n+    }\n+}\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ty::FloatVid\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _hcx: &mut StableHashingContext<'a>,\n+                                          _hasher: &mut StableHasher<W>) {\n+        // FloatVid values are confined to an inference context and hence\n+        // should not be hashed.\n+        bug!(\"ty::TypeVariants::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::ParamTy {\n     idx,\n     name\n@@ -707,11 +965,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::ExistentialPredicate<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -744,9 +1002,9 @@ impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     substs\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -768,21 +1026,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n             ty::InstanceDef::ClosureOnceShim { call_once } => {\n                 call_once.hash_stable(hcx, hasher);\n             }\n-            ty::InstanceDef::DropGlue(def_id, t) => {\n+            ty::InstanceDef::DropGlue(def_id, ty) => {\n                 def_id.hash_stable(hcx, hasher);\n-                t.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n             }\n-            ty::InstanceDef::CloneShim(def_id, t) => {\n+            ty::InstanceDef::CloneShim(def_id, ty) => {\n                 def_id.hash_stable(hcx, hasher);\n-                t.hash_stable(hcx, hasher);\n+                ty.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TraitDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::TraitDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TraitDef {\n             // We already have the def_path_hash below, no need to hash it twice\n@@ -804,15 +1062,9 @@ impl_stable_hash_for!(struct ty::Destructor {\n     did\n });\n \n-impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n-    outlives,\n-    dtorck_types\n-});\n-\n-\n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CrateVariancesMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::CrateVariancesMap {\n             ref variances,\n@@ -846,19 +1098,20 @@ impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n });\n \n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ty::steal::Steal<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n }\n \n impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n     caller_bounds,\n+    universe,\n     reveal\n });\n \n@@ -873,10 +1126,10 @@ impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n     Public\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let ::middle::privacy::AccessLevels {\n@@ -903,10 +1156,10 @@ impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use traits::Vtable::*;\n \n@@ -925,10 +1178,10 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableImplData {\n             impl_def_id,\n@@ -941,10 +1194,10 @@ for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gc\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableAutoImplData {\n             trait_def_id,\n@@ -955,10 +1208,10 @@ for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableObjectData {\n             upcast_trait_ref,\n@@ -971,10 +1224,10 @@ for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableBuiltinData {\n             ref nested,\n@@ -983,10 +1236,10 @@ for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableClosureData {\n             closure_def_id,\n@@ -999,10 +1252,10 @@ for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableFnPointerData {\n             fn_ty,\n@@ -1013,10 +1266,10 @@ for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableGeneratorData {\n             closure_def_id,\n@@ -1028,3 +1281,136 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n         nested.hash_stable(hcx, hasher);\n     }\n }\n+\n+impl<'a> HashStable<StableHashingContext<'a>>\n+for ty::UniverseIndex {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.depth().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n+        variables, value\n+    }\n+);\n+\n+impl_stable_hash_for!(\n+    impl<'tcx> for struct infer::canonical::CanonicalVarValues<'tcx> {\n+        var_values\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n+    kind\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n+    Ty(k),\n+    Region\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n+    General,\n+    Int,\n+    Float\n+});\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, R> for struct infer::canonical::QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n+    region_outlives, ty_outlives\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::Certainty {\n+    Proven, Ambiguous\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::WhereClauseAtom::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::DomainGoal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Holds(where_clause) |\n+            WellFormed(where_clause) |\n+            FromEnv(where_clause) => where_clause.hash_stable(hcx, hasher),\n+\n+            WellFormedTy(ty) => ty.hash_stable(hcx, hasher),\n+            FromEnvTy(ty) => ty.hash_stable(hcx, hasher),\n+            RegionOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n+            TypeOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Goal::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+            And(goal1, goal2) => {\n+                goal1.hash_stable(hcx, hasher);\n+                goal2.hash_stable(hcx, hasher);\n+            }\n+            Not(goal) => goal.hash_stable(hcx, hasher),\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            Quantified(quantifier, goal) => {\n+                quantifier.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Clause::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            }\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            ForAll(clause) => clause.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum traits::QuantifierKind {\n+    Universal,\n+    Existential\n+});"}, {"sha": "1b77a2e7c82b985d119b0fbdef3d9dd2e1c18d7e", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -12,7 +12,7 @@\n \n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n-pub use self::hcx::{StableHashingContext, NodeIdHashingMode,\n+pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls, compute_ignored_attr_names};\n mod fingerprint;\n mod caching_codemap_view;"}, {"sha": "7f58d03906026ee0a79f23334f48c86d63d111b7", "filename": "src/librustc/infer/README.md", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e", "patch": "@@ -1,227 +0,0 @@\n-# Type inference engine\n-\n-The type inference is based on standard HM-type inference, but\n-extended in various way to accommodate subtyping, region inference,\n-and higher-ranked types.\n-\n-## A note on terminology\n-\n-We use the notation `?T` to refer to inference variables, also called\n-existential variables.\n-\n-We use the term \"region\" and \"lifetime\" interchangeably. Both refer to\n-the `'a` in `&'a T`.\n-\n-The term \"bound region\" refers to regions bound in a function\n-signature, such as the `'a` in `for<'a> fn(&'a u32)`. A region is\n-\"free\" if it is not bound.\n-\n-## Creating an inference context\n-\n-You create and \"enter\" an inference context by doing something like\n-the following:\n-\n-```rust\n-tcx.infer_ctxt().enter(|infcx| {\n-    // use the inference context `infcx` in here\n-})\n-```\n-\n-Each inference context creates a short-lived type arena to store the\n-fresh types and things that it will create, as described in\n-[the README in the ty module][ty-readme]. This arena is created by the `enter`\n-function and disposed after it returns.\n-\n-[ty-readme]: src/librustc/ty/README.md\n-\n-Within the closure, the infcx will have the type `InferCtxt<'cx, 'gcx,\n-'tcx>` for some fresh `'cx` and `'tcx` -- the latter corresponds to\n-the lifetime of this temporary arena, and the `'cx` is the lifetime of\n-the `InferCtxt` itself. (Again, see [that ty README][ty-readme] for\n-more details on this setup.)\n-\n-The `tcx.infer_ctxt` method actually returns a build, which means\n-there are some kinds of configuration you can do before the `infcx` is\n-created. See `InferCtxtBuilder` for more information.\n-\n-## Inference variables\n-\n-The main purpose of the inference context is to house a bunch of\n-**inference variables** -- these represent types or regions whose precise\n-value is not yet known, but will be uncovered as we perform type-checking.\n-\n-If you're familiar with the basic ideas of unification from H-M type\n-systems, or logic languages like Prolog, this is the same concept. If\n-you're not, you might want to read a tutorial on how H-M type\n-inference works, or perhaps this blog post on\n-[unification in the Chalk project].\n-\n-[Unification in the Chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/\n-\n-All told, the inference context stores four kinds of inference variables as of this\n-writing:\n-\n-- Type variables, which come in three varieties:\n-  - General type variables (the most common). These can be unified with any type.\n-  - Integral type variables, which can only be unified with an integral type, and\n-    arise from an integer literal expression like `22`.\n-  - Float type variables, which can only be unified with a float type, and\n-    arise from a float literal expression like `22.0`.\n-- Region variables, which represent lifetimes, and arise all over the dang place.\n-\n-All the type variables work in much the same way: you can create a new\n-type variable, and what you get is `Ty<'tcx>` representing an\n-unresolved type `?T`. Then later you can apply the various operations\n-that the inferencer supports, such as equality or subtyping, and it\n-will possibly **instantiate** (or **bind**) that `?T` to a specific\n-value as a result.\n-\n-The region variables work somewhat differently, and are described\n-below in a separate section.\n-\n-## Enforcing equality / subtyping\n-\n-The most basic operations you can perform in the type inferencer is\n-**equality**, which forces two types `T` and `U` to be the same. The\n-recommended way to add an equality constraint is using the `at`\n-method, roughly like so:\n-\n-```\n-infcx.at(...).eq(t, u);\n-```\n-\n-The first `at()` call provides a bit of context, i.e., why you are\n-doing this unification, and in what environment, and the `eq` method\n-performs the actual equality constraint.\n-\n-When you equate things, you force them to be precisely equal. Equating\n-returns a `InferResult` -- if it returns `Err(err)`, then equating\n-failed, and the enclosing `TypeError` will tell you what went wrong.\n-\n-The success case is perhaps more interesting. The \"primary\" return\n-type of `eq` is `()` -- that is, when it succeeds, it doesn't return a\n-value of any particular interest. Rather, it is executed for its\n-side-effects of constraining type variables and so forth. However, the\n-actual return type is not `()`, but rather `InferOk<()>`. The\n-`InferOk` type is used to carry extra trait obligations -- your job is\n-to ensure that these are fulfilled (typically by enrolling them in a\n-fulfillment context). See the [trait README] for more background here.\n-\n-[trait README]: ../traits/README.md\n-\n-You can also enforce subtyping through `infcx.at(..).sub(..)`. The same\n-basic concepts apply as above.\n-\n-## \"Trying\" equality\n-\n-Sometimes you would like to know if it is *possible* to equate two\n-types without error.  You can test that with `infcx.can_eq` (or\n-`infcx.can_sub` for subtyping). If this returns `Ok`, then equality\n-is possible -- but in all cases, any side-effects are reversed.\n-\n-Be aware though that the success or failure of these methods is always\n-**modulo regions**. That is, two types `&'a u32` and `&'b u32` will\n-return `Ok` for `can_eq`, even if `'a != 'b`.  This falls out from the\n-\"two-phase\" nature of how we solve region constraints.\n-\n-## Snapshots\n-\n-As described in the previous section on `can_eq`, often it is useful\n-to be able to do a series of operations and then roll back their\n-side-effects. This is done for various reasons: one of them is to be\n-able to backtrack, trying out multiple possibilities before settling\n-on which path to take. Another is in order to ensure that a series of\n-smaller changes take place atomically or not at all.\n-\n-To allow for this, the inference context supports a `snapshot` method.\n-When you call it, it will start recording changes that occur from the\n-operations you perform. When you are done, you can either invoke\n-`rollback_to`, which will undo those changes, or else `confirm`, which\n-will make the permanent. Snapshots can be nested as long as you follow\n-a stack-like discipline.\n-\n-Rather than use snapshots directly, it is often helpful to use the\n-methods like `commit_if_ok` or `probe` that encapsulate higher-level\n-patterns.\n-\n-## Subtyping obligations\n-\n-One thing worth discussing are subtyping obligations. When you force\n-two types to be a subtype, like `?T <: i32`, we can often convert those\n-into equality constraints. This follows from Rust's rather limited notion\n-of subtyping: so, in the above case, `?T <: i32` is equivalent to `?T = i32`.\n-\n-However, in some cases we have to be more careful. For example, when\n-regions are involved. So if you have `?T <: &'a i32`, what we would do\n-is to first \"generalize\" `&'a i32` into a type with a region variable:\n-`&'?b i32`, and then unify `?T` with that (`?T = &'?b i32`). We then\n-relate this new variable with the original bound:\n-\n-    &'?b i32 <: &'a i32\n-    \n-This will result in a region constraint (see below) of `'?b: 'a`.\n-\n-One final interesting case is relating two unbound type variables,\n-like `?T <: ?U`.  In that case, we can't make progress, so we enqueue\n-an obligation `Subtype(?T, ?U)` and return it via the `InferOk`\n-mechanism. You'll have to try again when more details about `?T` or\n-`?U` are known.\n-\n-## Region constraints\n-\n-Regions are inferred somewhat differently from types. Rather than\n-eagerly unifying things, we simply collect constraints as we go, but\n-make (almost) no attempt to solve regions. These constraints have the\n-form of an outlives constraint:\n-\n-    'a: 'b\n-    \n-Actually the code tends to view them as a subregion relation, but it's the same\n-idea:\n-\n-    'b <= 'a\n-\n-(There are various other kinds of constriants, such as \"verifys\"; see\n-the `region_constraints` module for details.)\n-\n-There is one case where we do some amount of eager unification. If you have an equality constraint\n-between two regions\n-\n-    'a = 'b\n-    \n-we will record that fact in a unification table. You can then use\n-`opportunistic_resolve_var` to convert `'b` to `'a` (or vice\n-versa). This is sometimes needed to ensure termination of fixed-point\n-algorithms.\n-\n-## Extracting region constraints\n-\n-Ultimately, region constraints are only solved at the very end of\n-type-checking, once all other constraints are known. There are two\n-ways to solve region constraints right now: lexical and\n-non-lexical. Eventually there will only be one.\n-\n-To solve **lexical** region constraints, you invoke\n-`resolve_regions_and_report_errors`.  This will \"close\" the region\n-constraint process and invoke the `lexical_region_resolve` code. Once\n-this is done, any further attempt to equate or create a subtyping\n-relationship will yield an ICE.\n-\n-Non-lexical region constraints are not handled within the inference\n-context. Instead, the NLL solver (actually, the MIR type-checker)\n-invokes `take_and_reset_region_constraints` periodically. This\n-extracts all of the outlives constraints from the region solver, but\n-leaves the set of variables intact. This is used to get *just* the\n-region constraints that resulted from some particular point in the\n-program, since the NLL solver needs to know not just *what* regions\n-were subregions but *where*. Finally, the NLL solver invokes\n-`take_region_var_origins`, which \"closes\" the region constraint\n-process in the same way as normal solving.\n-\n-## Lexical region resolution\n-\n-Lexical region resolution is done by initially assigning each region\n-variable to an empty value. We then process each outlives constraint\n-repeatedly, growing region variables until a fixed-point is reached.\n-Region variables can be grown using a least-upper-bound relation on\n-the region lattice in a fairly straight-forward fashion."}, {"sha": "eb26f0c1188bf639bf8c0b31aa40a8c85e7cdf40", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -17,7 +17,7 @@ use traits::{self, PredicateObligation};\n use ty::{self, Ty};\n use ty::fold::{BottomUpFolder, TypeFoldable};\n use ty::outlives::Component;\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{Kind, UnpackedKind, Substs};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let index = region_def.index as usize;\n \n             // Get the value supplied for this region from the substs.\n-            let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+            let subst_arg = anon_defn.substs.region_at(index);\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n@@ -466,7 +466,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // All other regions, we map them appropriately to their adjusted\n                 // indices, erroring if we find any lifetimes that were not mapped\n                 // into the new set.\n-                _ => if let Some(r1) = map.get(&Kind::from(r)).and_then(|k| k.as_region()) {\n+                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n+                                                                  .map(|k| k.unpack()) {\n                     r1\n                 } else {\n                     // No mapping was found. This means that\n@@ -599,7 +600,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                       TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "89dbc76c8a65c2b58306e8d3ea1d95f2de912d29", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -40,9 +40,9 @@ use super::*;\n use ty::relate::{Relate, TypeRelation};\n \n pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    cause: &'a ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub cause: &'a ObligationCause<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -281,6 +281,20 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Regions(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(cause: &ObligationCause<'tcx>,\n                 a_is_expected: bool,"}, {"sha": "4e0cf59e8a7fd7dc6db068c5f4d60ac62feaab49", "filename": "src/librustc/infer/canonical.rs", "status": "added", "additions": 936, "deletions": 0, "changes": 936, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -0,0 +1,936 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constriants\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+//!\n+//! For a more detailed look at what is happening here, check\n+//! out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html\n+\n+use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::fmt::Debug;\n+use std::ops::Index;\n+use syntax::codemap::Span;\n+use traits::{Obligation, ObligationCause, PredicateObligation};\n+use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n+use ty::subst::{Kind, UnpackedKind};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::CellUsizeExt;\n+\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewriten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Canonical<'gcx, V> {\n+    pub variables: CanonicalVarInfos<'gcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables.\n+///\n+/// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n+/// to get back a `CanonicalVarValues` containing fresh inference\n+/// variables.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// Region variable `'?R`.\n+    Region,\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General,\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResult<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug)]\n+pub struct QueryResult<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResult<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+/// Subset of `RegionConstraintData` produced by trait query.\n+#[derive(Clone, Debug, Default)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub region_outlives: Vec<(Region<'tcx>, Region<'tcx>)>,\n+    pub ty_outlives: Vec<(Ty<'tcx>, Region<'tcx>)>,\n+}\n+\n+/// Trait implemented by values that can be canonicalized. It mainly\n+/// serves to identify the interning table we will use.\n+pub trait Canonicalize<'gcx: 'tcx, 'tcx>: TypeFoldable<'tcx> + Lift<'gcx> {\n+    type Canonicalized: 'gcx + Debug;\n+\n+    /// After a value has been fully canonicalized and lifted, this\n+    /// method will allocate it in a global arena.\n+    fn intern(\n+        gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Creates a substitution S for the canonical value with fresh\n+    /// inference variables and applies it to the canonical value.\n+    /// Returns both the instantiated result *and* the substitution S.\n+    ///\n+    /// This is useful at the start of a query: it basically brings\n+    /// the canonical value \"into scope\" within your new infcx. At the\n+    /// end of processing, the substitution S (once canonicalized)\n+    /// then represents the values that you computed for each of the\n+    /// canonical inputs to your query.\n+    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> (T, CanonicalVarValues<'tcx>)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let canonical_inference_vars =\n+            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+        let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n+        (result, canonical_inference_vars)\n+    }\n+\n+    /// Given the \"infos\" about the canonical variables from some\n+    /// canonical, creates fresh inference variables with the same\n+    /// characteristics. You can then use `substitute` to instantiate\n+    /// the canonical variable with these inference variables.\n+    pub fn fresh_inference_vars_for_canonical_vars(\n+        &self,\n+        span: Span,\n+        variables: &Slice<CanonicalVarInfo>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n+            .iter()\n+            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .collect();\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    /// Given the \"info\" about a canonical variable, creates a fresh\n+    /// inference variable with the same characteristics.\n+    pub fn fresh_inference_var_for_canonical_var(\n+        &self,\n+        span: Span,\n+        cv_info: CanonicalVarInfo,\n+    ) -> Kind<'tcx> {\n+        match cv_info.kind {\n+            CanonicalVarKind::Ty(ty_kind) => {\n+                let ty = match ty_kind {\n+                    CanonicalTyVarKind::General => {\n+                        self.next_ty_var(\n+                            // FIXME(#48696) this handling of universes is not right.\n+                            ty::UniverseIndex::ROOT,\n+                            TypeVariableOrigin::MiscVariable(span),\n+                        )\n+                    }\n+\n+                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n+\n+                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n+                };\n+                Kind::from(ty)\n+            }\n+\n+            CanonicalVarKind::Region => {\n+                Kind::from(self.next_region_var(RegionVariableOrigin::MiscVariable(span)))\n+            }\n+        }\n+    }\n+\n+    /// Given the (canonicalized) result to a canonical query,\n+    /// instantiates the result so it can be used, plugging in the\n+    /// values from the canonical query. (Note that the result may\n+    /// have been ambiguous; you should check the certainty level of\n+    /// the query before applying this function.)\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#processing-the-canonicalized-query-result\n+    pub fn instantiate_query_result<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        // Every canonical query result includes values for each of\n+        // the inputs to the query. Therefore, we begin by unifying\n+        // these values with the original inputs that were\n+        // canonicalized.\n+        let result_values = &query_result.value.var_values;\n+        assert_eq!(original_values.len(), result_values.len());\n+\n+        // Quickly try to find initial values for the canonical\n+        // variables in the result in terms of the query. We do this\n+        // by iterating down the values that the query gave to each of\n+        // the canonical inputs. If we find that one of those values\n+        // is directly equal to one of the canonical variables in the\n+        // result, then we can type the corresponding value from the\n+        // input. See the example above.\n+        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n+            IndexVec::from_elem_n(None, query_result.variables.len());\n+\n+        // In terms of our example above, we are iterating over pairs like:\n+        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n+        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+            match result_value.unpack() {\n+                UnpackedKind::Type(result_value) => {\n+                    // e.g., here `result_value` might be `?0` in the example above...\n+                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+                UnpackedKind::Lifetime(result_value) => {\n+                    // e.g., here `result_value` might be `'?1` in the example above...\n+                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n+                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Create a result substitution: if we found a value for a\n+        // given variable in the loop above, use that. Otherwise, use\n+        // a fresh inference variable.\n+        let result_subst = &CanonicalVarValues {\n+            var_values: query_result\n+                .variables\n+                .iter()\n+                .enumerate()\n+                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n+                    Some(k) => k,\n+                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n+                })\n+                .collect(),\n+        };\n+\n+        // Unify the original values for the canonical variables in\n+        // the input with the value found in the query\n+        // post-substitution. Often, but not always, this is a no-op,\n+        // because we already found the mapping in the first step.\n+        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n+        };\n+        let mut obligations =\n+            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n+                .into_obligations();\n+\n+        obligations.extend(self.query_region_constraints_into_obligations(\n+            cause,\n+            param_env,\n+            &query_result.value.region_constraints,\n+            result_subst,\n+        ));\n+\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// Converts the region constraints resulting from a query into an\n+    /// iterator of obligations.\n+    fn query_region_constraints_into_obligations<'a>(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n+        result_subst: &'a CanonicalVarValues<'tcx>,\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        let QueryRegionConstraints {\n+            region_outlives,\n+            ty_outlives,\n+        } = unsubstituted_region_constraints;\n+\n+        let region_obligations = region_outlives.iter().map(move |(r1, r2)| {\n+            let r1 = substitute_value(self.tcx, result_subst, r1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n+            )\n+        });\n+\n+        let ty_obligations = ty_outlives.iter().map(move |(t1, r2)| {\n+            let t1 = substitute_value(self.tcx, result_subst, t1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n+            )\n+        });\n+\n+        region_obligations.chain(ty_obligations)\n+    }\n+\n+    /// Given two sets of values for the same set of canonical variables, unify them.\n+    /// The second set is produced lazilly by supplying indices from the first set.\n+    fn unify_canonical_vars(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        variables1: &CanonicalVarValues<'tcx>,\n+        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        self.commit_if_ok(|_| {\n+            let mut obligations = vec![];\n+            for (index, value1) in variables1.var_values.iter_enumerated() {\n+                let value2 = variables2(index);\n+\n+                match (value1.unpack(), value2.unpack()) {\n+                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                    }\n+                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    _ => {\n+                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n+                    }\n+                }\n+            }\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        })\n+    }\n+\n+    /// Canonicalizes a query value `V`. When we canonicalize a query,\n+    /// we not only canonicalize unbound inference variables, but we\n+    /// *also* replace all free regions whatsoever. So for example a\n+    /// query like `T: Trait<'static>` would be canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#canonicalizing-the-query\n+    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        self.tcx.sess.perf_stats.queries_canonicalized.increment();\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(true),\n+        )\n+    }\n+\n+    /// Canonicalizes a query *response* `V`. When we canonicalize a\n+    /// query response, we only canonicalize unbound inference\n+    /// variables, and we leave other free regions alone. So,\n+    /// continuing with the example from `canonicalize_query`, if\n+    /// there was an input query `T: Trait<'static>`, it would have\n+    /// been canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n+    /// exists only one possible impl of `Trait`, and it looks like\n+    ///\n+    ///     impl<T> Trait<'static> for T { .. }\n+    ///\n+    /// then we would prepare a query result R that (among other\n+    /// things) includes a mapping to `'?0 := 'static`. When\n+    /// canonicalizing this query result R, we would leave this\n+    /// reference to `'static` alone.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#canonicalizing-the-query-result\n+    pub fn canonicalize_response<V>(\n+        &self,\n+        value: &V,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(false),\n+        )\n+    }\n+}\n+\n+/// If this flag is true, then all free regions will be replaced with\n+/// a canonical var. This is used to make queries as generic as\n+/// possible. For example, the query `F: Foo<'static>` would be\n+/// canonicalized to `F: Foo<'0>`.\n+struct CanonicalizeAllFreeRegions(bool);\n+\n+struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n+    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    needs_canonical_flags: TypeFlags,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReVar(vid) => {\n+                let r = self.infcx\n+                    .unwrap()\n+                    .borrow_region_constraints()\n+                    .opportunistic_resolve_var(self.tcx, vid);\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Region,\n+                };\n+                debug!(\n+                    \"canonical: region var found with vid {:?}, \\\n+                     opportunistically resolved to {:?}\",\n+                    vid, r\n+                );\n+                let cvar = self.canonical_var(info, Kind::from(r));\n+                self.tcx().mk_region(ty::ReCanonical(cvar))\n+            }\n+\n+            ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReScope(_)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased => {\n+                if self.canonicalize_all_free_regions.0 {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, Kind::from(r));\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n+                bug!(\"canonical region encountered during canonicalization\")\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+\n+            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+\n+            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"encountered a fresh type during canonicalization\")\n+            }\n+\n+            ty::TyInfer(ty::CanonicalTy(_)) => {\n+                bug!(\"encountered a canonical type during canonicalization\")\n+            }\n+\n+            ty::TyClosure(..)\n+            | ty::TyGenerator(..)\n+            | ty::TyGeneratorWitness(..)\n+            | ty::TyBool\n+            | ty::TyChar\n+            | ty::TyInt(..)\n+            | ty::TyUint(..)\n+            | ty::TyFloat(..)\n+            | ty::TyAdt(..)\n+            | ty::TyStr\n+            | ty::TyError\n+            | ty::TyArray(..)\n+            | ty::TySlice(..)\n+            | ty::TyRawPtr(..)\n+            | ty::TyRef(..)\n+            | ty::TyFnDef(..)\n+            | ty::TyFnPtr(_)\n+            | ty::TyDynamic(..)\n+            | ty::TyNever\n+            | ty::TyTuple(..)\n+            | ty::TyProjection(..)\n+            | ty::TyForeign(..)\n+            | ty::TyParam(..)\n+            | ty::TyAnon(..) => {\n+                if t.flags.intersects(self.needs_canonical_flags) {\n+                    t.super_fold_with(self)\n+                } else {\n+                    t\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+    /// The main `canonicalize` method, shared impl of\n+    /// `canonicalize_query` and `canonicalize_response`.\n+    fn canonicalize<V>(\n+        value: &V,\n+        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        debug_assert!(\n+            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            \"canonicalizing a canonical value: {:?}\",\n+            value,\n+        );\n+\n+        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n+            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n+        } else {\n+            TypeFlags::KEEP_IN_LOCAL_TCX\n+        };\n+\n+        let gcx = tcx.global_tcx();\n+\n+        // Fast path: nothing that needs to be canonicalized.\n+        if !value.has_type_flags(needs_canonical_flags) {\n+            let out_value = gcx.lift(value).unwrap();\n+            let canon_value = V::intern(\n+                gcx,\n+                Canonical {\n+                    variables: Slice::empty(),\n+                    value: out_value,\n+                },\n+            );\n+            let values = CanonicalVarValues {\n+                var_values: IndexVec::default(),\n+            };\n+            return (canon_value, values);\n+        }\n+\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            tcx,\n+            canonicalize_all_free_regions,\n+            needs_canonical_flags,\n+            variables: IndexVec::default(),\n+            indices: FxHashMap::default(),\n+            var_values: IndexVec::default(),\n+        };\n+        let out_value = value.fold_with(&mut canonicalizer);\n+\n+        // Once we have canonicalized `out_value`, it should not\n+        // contain anything that ties it to this inference context\n+        // anymore, so it should live in the global arena.\n+        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n+            bug!(\n+                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n+                out_value,\n+                value\n+            )\n+        });\n+\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+\n+        let canonical_value = V::intern(\n+            gcx,\n+            Canonical {\n+                variables: canonical_variables,\n+                value: out_value,\n+            },\n+        );\n+        let canonical_var_values = CanonicalVarValues {\n+            var_values: canonicalizer.var_values,\n+        };\n+        (canonical_value, canonical_var_values)\n+    }\n+\n+    /// Creates a canonical variable replacing `kind` from the input,\n+    /// or returns an existing variable if `kind` has already been\n+    /// seen. `kind` is expected to be an unbound variable (or\n+    /// potentially a free region).\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n+        let Canonicalizer {\n+            indices,\n+            variables,\n+            var_values,\n+            ..\n+        } = self;\n+\n+        indices\n+            .entry(kind)\n+            .or_insert_with(|| {\n+                let cvar1 = variables.push(info);\n+                let cvar2 = var_values.push(kind);\n+                assert_eq!(cvar1, cvar2);\n+                cvar1\n+            })\n+            .clone()\n+    }\n+\n+    /// Given a type variable `ty_var` of the given kind, first check\n+    /// if `ty_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `ty_var`.\n+    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n+        let bound_to = infcx.shallow_resolve(ty_var);\n+        if bound_to != ty_var {\n+            self.fold_ty(bound_to)\n+        } else {\n+            let info = CanonicalVarInfo {\n+                kind: CanonicalVarKind::Ty(ty_kind),\n+            };\n+            let cvar = self.canonical_var(info, Kind::from(ty_var));\n+            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n+        }\n+    }\n+}\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Instantiate the wrapped value, replacing each canonical value\n+    /// with the value given in `var_values`.\n+    fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    /// Invoke `projection_fn` with `self.value` to get a value V that\n+    /// is expressed in terms of the same canonical variables bound in\n+    /// `self`. Apply the substitution `var_values` to this value V,\n+    /// replacing each of the canonical variables.\n+    fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        let value = projection_fn(&self.value);\n+        substitute_value(tcx, var_values, value)\n+    }\n+}\n+\n+/// Substitute the values from `var_values` into `value`. `var_values`\n+/// must be values for the set of cnaonical variables that appear in\n+/// `value`.\n+fn substitute_value<'a, 'tcx, T>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    var_values: &CanonicalVarValues<'tcx>,\n+    value: &'a T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    if var_values.var_values.is_empty() {\n+        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n+        value.clone()\n+    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+        value.clone()\n+    } else {\n+        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+    }\n+}\n+\n+struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    var_values: &'cx CanonicalVarValues<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+                match self.var_values.var_values[c].unpack() {\n+                    UnpackedKind::Type(ty) => ty,\n+                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n+                }\n+            }\n+            _ => {\n+                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n+            },\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    for <'tcx> {\n+        ::infer::canonical::Certainty,\n+        ::infer::canonical::CanonicalVarInfo,\n+        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+        ::infer::canonical::CanonicalVarKind,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n+        variables,\n+        value,\n+    } where C: TypeFoldable<'tcx>\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n+        self.var_values.iter().cloned()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = Kind<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for CanonicalVarValues<'a> {\n+        type Lifted = CanonicalVarValues<'tcx>;\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for CanonicalVarValues<'tcx> {\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n+        type Lifted = QueryRegionConstraints<'tcx>;\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    } where R: TypeFoldable<'tcx>,\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n+        type Lifted = QueryResult<'tcx, R::Lifted>;\n+        var_values, region_constraints, certainty, value\n+    } where R: Lift<'tcx>\n+}\n+\n+impl<'tcx> Index<CanonicalVar> for CanonicalVarValues<'tcx> {\n+    type Output = Kind<'tcx>;\n+\n+    fn index(&self, value: CanonicalVar) -> &Kind<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}, {"sha": "1c581c44464e72ab7085df3a8f736a95fcaf9f75", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -34,10 +34,10 @@\n \n use super::equate::Equate;\n use super::glb::Glb;\n+use super::{InferCtxt, MiscVariable, TypeTrace};\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::InferCtxt;\n-use super::{MiscVariable, TypeTrace};\n+use super::type_variable::TypeVariableValue;\n \n use hir::def_id::DefId;\n use ty::{IntType, UintType};\n@@ -132,7 +132,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     {\n         self.int_unification_table\n             .borrow_mut()\n-            .unify_var_value(vid, val)\n+            .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n             IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n@@ -148,7 +148,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     {\n         self.float_unification_table\n             .borrow_mut()\n-            .unify_var_value(vid, val)\n+            .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n     }\n@@ -194,7 +194,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_none());\n+        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -402,12 +402,12 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     // `vid` are related via subtyping.\n                     return Err(TypeError::CyclicTy(self.root_ty));\n                 } else {\n-                    match variables.probe_root(vid) {\n-                        Some(u) => {\n+                    match variables.probe(vid) {\n+                        TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        None => {\n+                        TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -423,8 +423,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = variables.origin(vid);\n-                            let new_var_id = variables.new_var(false, origin, None);\n+                            let origin = *variables.var_origin(vid);\n+                            let new_var_id = variables.new_var(universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n@@ -476,6 +476,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 }\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 span_bug!(\n                     self.span,\n@@ -518,9 +519,9 @@ fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::Int\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n-                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 v: (ty::FloatVarValue, ty::FloatVarValue))\n                                  -> TypeError<'tcx>\n {\n-    let (a, b) = v;\n+    let (ty::FloatVarValue(a), ty::FloatVarValue(b)) = v;\n     TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "96c2309882108769634a9f91b1c978a4b9e86b1b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 483, "deletions": 373, "changes": 856, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -56,7 +56,7 @@\n //! time of error detection.\n \n use infer;\n-use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n@@ -81,54 +81,22 @@ mod need_type_info;\n pub mod nice_region_error;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn note_and_explain_region(self,\n-                                   region_scope_tree: &region::ScopeTree,\n-                                   err: &mut DiagnosticBuilder,\n-                                   prefix: &str,\n-                                   region: ty::Region<'tcx>,\n-                                   suffix: &str) {\n-        fn item_scope_tag(item: &hir::Item) -> &'static str {\n-            match item.node {\n-                hir::ItemImpl(..) => \"impl\",\n-                hir::ItemStruct(..) => \"struct\",\n-                hir::ItemUnion(..) => \"union\",\n-                hir::ItemEnum(..) => \"enum\",\n-                hir::ItemTrait(..) => \"trait\",\n-                hir::ItemFn(..) => \"function body\",\n-                _ => \"item\"\n-            }\n-        }\n-\n-        fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n-            match item.node {\n-                hir::TraitItemKind::Method(..) => \"method body\",\n-                hir::TraitItemKind::Const(..) |\n-                hir::TraitItemKind::Type(..) => \"associated item\"\n-            }\n-        }\n-\n-        fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n-            match item.node {\n-                hir::ImplItemKind::Method(..) => \"method body\",\n-                hir::ImplItemKind::Const(..) |\n-                hir::ImplItemKind::Type(_) => \"associated item\"\n-            }\n-        }\n-\n-        fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        heading: &str, span: Span)\n-                                        -> (String, Option<Span>) {\n-            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo());\n-            (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n-             Some(span))\n-        }\n-\n+    pub fn note_and_explain_region(\n+        self,\n+        region_scope_tree: &region::ScopeTree,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n         let (description, span) = match *region {\n             ty::ReScope(scope) => {\n                 let new_string;\n                 let unknown_scope = || {\n-                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                            prefix, scope, suffix)\n+                    format!(\n+                        \"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                        prefix, scope, suffix\n+                    )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n@@ -137,153 +105,226 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprCall(..) => \"call\",\n                         hir::ExprMethodCall(..) => \"method call\",\n                         hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n                         hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n                     Some(hir_map::NodeStmt(_)) => \"statement\",\n-                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n+                    Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n+                    Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n                     }\n                 };\n                 let scope_decorated_tag = match scope.data() {\n                     region::ScopeData::Node(_) => tag,\n-                    region::ScopeData::CallSite(_) => {\n-                        \"scope of call-site for function\"\n-                    }\n-                    region::ScopeData::Arguments(_) => {\n-                        \"scope of function body\"\n-                    }\n+                    region::ScopeData::CallSite(_) => \"scope of call-site for function\",\n+                    region::ScopeData::Arguments(_) => \"scope of function body\",\n                     region::ScopeData::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n                     region::ScopeData::Remainder(r) => {\n-                        new_string = format!(\"block suffix following statement {}\",\n-                                             r.first_statement_index.index());\n+                        new_string = format!(\n+                            \"block suffix following statement {}\",\n+                            r.first_statement_index.index()\n+                        );\n                         &new_string[..]\n                     }\n                 };\n-                explain_span(self, scope_decorated_tag, span)\n+                self.explain_span(scope_decorated_tag, span)\n             }\n \n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(_) => {\n-                let scope = region.free_region_binding_scope(self);\n-                let node = self.hir.as_local_node_id(scope)\n-                                   .unwrap_or(DUMMY_NODE_ID);\n-                let unknown;\n-                let tag = match self.hir.find(node) {\n-                    Some(hir_map::NodeBlock(_)) |\n-                    Some(hir_map::NodeExpr(_)) => \"body\",\n-                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n-\n-                    // this really should not happen, but it does:\n-                    // FIXME(#27942)\n-                    Some(_) => {\n-                        unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n-                                           Please report a bug.\",\n-                                          self.hir.node_to_string(node), scope);\n-                        &unknown\n-                    }\n-                    None => {\n-                        unknown = format!(\"unknown node for scope {:?}.  \\\n-                                           Please report a bug.\", scope);\n-                        &unknown\n-                    }\n-                };\n-                let (prefix, span) = match *region {\n-                    ty::ReEarlyBound(ref br) => {\n-                        (format!(\"the lifetime {} as defined on\", br.name),\n-                         self.sess.codemap().def_span(self.hir.span(node)))\n-                    }\n-                    ty::ReFree(ref fr) => {\n-                        match fr.bound_region {\n-                            ty::BrAnon(idx) => {\n-                                (format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                                 self.hir.span(node))\n-                            }\n-                            ty::BrFresh(_) => (\"an anonymous lifetime defined on\".to_owned(),\n-                                               self.hir.span(node)),\n-                            _ => (format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                                  self.sess.codemap().def_span(self.hir.span(node))),\n-                        }\n-                    }\n-                    _ => bug!()\n-                };\n-                let (msg, opt_span) = explain_span(self, tag, span);\n-                (format!(\"{} {}\", prefix, msg), opt_span)\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n+                self.msg_span_from_free_region(region)\n             }\n \n-            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-\n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n             // FIXME(#13998) ReSkolemized should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::ReSkolemized(..) |\n-            ty::ReVar(_) |\n-            ty::ReLateBound(..) |\n-            ty::ReErased => {\n+            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n-                bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n-                    region,\n+                bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n+            }\n+        };\n+\n+        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+    }\n+\n+    pub fn note_and_explain_free_region(\n+        self,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n+        let (description, span) = self.msg_span_from_free_region(region);\n+\n+        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+    }\n+\n+    fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_)  => {\n+                self.msg_span_from_early_bound_and_free_regions(region)\n+            },\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            _ => bug!(),\n+        }\n+    }\n+\n+    fn msg_span_from_early_bound_and_free_regions(\n+        self,\n+        region: ty::Region<'tcx>,\n+    ) -> (String, Option<Span>) {\n+        let scope = region.free_region_binding_scope(self);\n+        let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+        let unknown;\n+        let tag = match self.hir.find(node) {\n+            Some(hir_map::NodeBlock(_)) | Some(hir_map::NodeExpr(_)) => \"body\",\n+            Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n+            Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+\n+            // this really should not happen, but it does:\n+            // FIXME(#27942)\n+            Some(_) => {\n+                unknown = format!(\n+                    \"unexpected node ({}) for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    self.hir.node_to_string(node),\n+                    scope\n                 );\n+                &unknown\n             }\n+            None => {\n+                unknown = format!(\n+                    \"unknown node for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    scope\n+                );\n+                &unknown\n+            }\n+        };\n+        let (prefix, span) = match *region {\n+            ty::ReEarlyBound(ref br) => (\n+                format!(\"the lifetime {} as defined on\", br.name),\n+                self.sess.codemap().def_span(self.hir.span(node)),\n+            ),\n+            ty::ReFree(ref fr) => match fr.bound_region {\n+                ty::BrAnon(idx) => (\n+                    format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n+                    self.hir.span(node),\n+                ),\n+                ty::BrFresh(_) => (\n+                    \"an anonymous lifetime defined on\".to_owned(),\n+                    self.hir.span(node),\n+                ),\n+                _ => (\n+                    format!(\"the lifetime {} as defined on\", fr.bound_region),\n+                    self.sess.codemap().def_span(self.hir.span(node)),\n+                ),\n+            },\n+            _ => bug!(),\n         };\n+        let (msg, opt_span) = self.explain_span(tag, span);\n+        (format!(\"{} {}\", prefix, msg), opt_span)\n+    }\n+\n+    fn emit_msg_span(\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        description: String,\n+        span: Option<Span>,\n+        suffix: &str,\n+    ) {\n         let message = format!(\"{}{}{}\", prefix, description, suffix);\n+\n         if let Some(span) = span {\n             err.span_note(span, &message);\n         } else {\n             err.note(&message);\n         }\n     }\n+\n+    fn item_scope_tag(item: &hir::Item) -> &'static str {\n+        match item.node {\n+            hir::ItemImpl(..) => \"impl\",\n+            hir::ItemStruct(..) => \"struct\",\n+            hir::ItemUnion(..) => \"union\",\n+            hir::ItemEnum(..) => \"enum\",\n+            hir::ItemTrait(..) => \"trait\",\n+            hir::ItemFn(..) => \"function body\",\n+            _ => \"item\",\n+        }\n+    }\n+\n+    fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n+        match item.node {\n+            hir::TraitItemKind::Method(..) => \"method body\",\n+            hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n+        }\n+    }\n+\n+    fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n+        match item.node {\n+            hir::ImplItemKind::Method(..) => \"method body\",\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) => \"associated item\",\n+        }\n+    }\n+\n+    fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n+        let lo = self.sess.codemap().lookup_char_pos_adj(span.lo());\n+        (\n+            format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n+            Some(span),\n+        )\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_region_errors(&self,\n-                                region_scope_tree: &region::ScopeTree,\n-                                errors: &Vec<RegionResolutionError<'tcx>>,\n-                                will_later_be_reported_by_nll: bool) {\n+    pub fn report_region_errors(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+        will_later_be_reported_by_nll: bool,\n+    ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n-        if will_later_be_reported_by_nll && self.tcx.sess.nll() {\n+        if will_later_be_reported_by_nll && self.tcx.nll() {\n             // With `#![feature(nll)]`, we want to present a nice user\n             // experience, so don't even mention the errors from the\n             // AST checker.\n-            if self.tcx.sess.features.borrow().nll {\n+            if self.tcx.features().nll {\n                 return;\n             }\n \n             // But with -Znll, it's nice to have some note for later.\n             for error in errors {\n                 match *error {\n-                    RegionResolutionError::ConcreteFailure(ref origin, ..) |\n-                    RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            origin.span(),\n-                            \"not reporting region error due to -Znll\");\n+                    RegionResolutionError::ConcreteFailure(ref origin, ..)\n+                    | RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n+                        self.tcx\n+                            .sess\n+                            .span_warn(origin.span(), \"not reporting region error due to -Znll\");\n                     }\n \n                     RegionResolutionError::SubSupConflict(ref rvo, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            rvo.span(),\n-                            \"not reporting region error due to -Znll\");\n+                        self.tcx\n+                            .sess\n+                            .span_warn(rvo.span(), \"not reporting region error due to -Znll\");\n                     }\n                 }\n             }\n@@ -295,7 +336,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+        debug!(\n+            \"report_region_errors: {} errors after preprocessing\",\n+            errors.len()\n+        );\n \n         for error in errors {\n             debug!(\"report_region_errors: error = {:?}\", error);\n@@ -310,7 +354,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the error. If all of these fails, we fall back to a rather\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n-                        self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n+                        self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n+                            .emit();\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n@@ -323,17 +368,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         );\n                     }\n \n-                    RegionResolutionError::SubSupConflict(var_origin,\n-                                                          sub_origin,\n-                                                          sub_r,\n-                                                          sup_origin,\n-                                                          sup_r) => {\n-                        self.report_sub_sup_conflict(region_scope_tree,\n-                                                     var_origin,\n-                                                     sub_origin,\n-                                                     sub_r,\n-                                                     sup_origin,\n-                                                     sup_r);\n+                    RegionResolutionError::SubSupConflict(\n+                        var_origin,\n+                        sub_origin,\n+                        sub_r,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        self.report_sub_sup_conflict(\n+                            region_scope_tree,\n+                            var_origin,\n+                            sub_origin,\n+                            sub_r,\n+                            sup_origin,\n+                            sup_r,\n+                        );\n                     }\n                 }\n             }\n@@ -350,8 +399,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // The method also attempts to weed out messages that seem like\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>> {\n+    fn process_errors(\n+        &self,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n \n         // We want to avoid reporting generic-bound failures if we can\n@@ -368,15 +419,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n-            RegionResolutionError::ConcreteFailure(..) |\n-            RegionResolutionError::SubSupConflict(..) => false,\n+            RegionResolutionError::ConcreteFailure(..)\n+            | RegionResolutionError::SubSupConflict(..) => false,\n         };\n \n-\n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n             errors.clone()\n         } else {\n-            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n+            errors\n+                .iter()\n+                .filter(|&e| !is_bound_failure(e))\n+                .cloned()\n+                .collect()\n         };\n \n         // sort the errors by span, for better error message stability.\n@@ -389,10 +443,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self,\n-                                         err: &mut DiagnosticBuilder,\n-                                         terr: &TypeError<'tcx>,\n-                                         sp: Span) {\n+    fn check_and_note_conflicting_crates(\n+        &self,\n+        err: &mut DiagnosticBuilder,\n+        terr: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         let report_path_match = |err: &mut DiagnosticBuilder, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n@@ -403,12 +459,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let found_abs_path = self.tcx.absolute_item_path_str(did2);\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path\n-                || exp_abs_path == found_abs_path {\n+                if exp_path == found_path || exp_abs_path == found_abs_path {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.span_note(sp, &format!(\"Perhaps two different versions \\\n-                                                of crate `{}` are being used?\",\n-                                               crate_name));\n+                    err.span_note(\n+                        sp,\n+                        &format!(\n+                            \"Perhaps two different versions \\\n+                             of crate `{}` are being used?\",\n+                            crate_name\n+                        ),\n+                    );\n                 }\n             }\n         };\n@@ -419,24 +479,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n                     (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 }\n-            },\n+            }\n             TypeError::Traits(ref exp_found) => {\n                 report_path_match(err, exp_found.expected, exp_found.found);\n-            },\n-            _ => () // FIXME(#22750) handle traits and stuff\n+            }\n+            _ => (), // FIXME(#22750) handle traits and stuff\n         }\n     }\n \n-    fn note_error_origin(&self,\n-                         err: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>)\n-    {\n+    fn note_error_origin(&self, err: &mut DiagnosticBuilder<'tcx>, cause: &ObligationCause<'tcx>) {\n         match cause.code {\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n-                hir::MatchSource::IfLetDesugar {..} => {\n+                hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";\n                     if self.tcx.sess.codemap().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n@@ -453,7 +510,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -470,13 +527,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn highlight_outer(&self,\n-                       value: &mut DiagnosticStyledString,\n-                       other_value: &mut DiagnosticStyledString,\n-                       name: String,\n-                       sub: &ty::subst::Substs<'tcx>,\n-                       pos: usize,\n-                       other_ty: &Ty<'tcx>) {\n+    fn highlight_outer(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        name: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        pos: usize,\n+        other_ty: &Ty<'tcx>,\n+    ) {\n         // `value` and `other_value` hold two incomplete type representation for display.\n         // `name` is the path of both types being compared. `sub`\n         value.push_highlighted(name);\n@@ -486,14 +545,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Output the lifetimes fot the first type\n-        let lifetimes = sub.regions().map(|lifetime| {\n-            let s = format!(\"{}\", lifetime);\n-            if s.is_empty() {\n-                \"'_\".to_string()\n-            } else {\n-                s\n-            }\n-        }).collect::<Vec<_>>().join(\", \");\n+        let lifetimes = sub.regions()\n+            .map(|lifetime| {\n+                let s = format!(\"{}\", lifetime);\n+                if s.is_empty() {\n+                    \"'_\".to_string()\n+                } else {\n+                    s\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n         if !lifetimes.is_empty() {\n             if sub.regions().count() < len {\n                 value.push_normal(lifetimes + &\", \");\n@@ -543,13 +605,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn cmp_type_arg(&self,\n-                    mut t1_out: &mut DiagnosticStyledString,\n-                    mut t2_out: &mut DiagnosticStyledString,\n-                    path: String,\n-                    sub: &ty::subst::Substs<'tcx>,\n-                    other_path: String,\n-                    other_ty: &Ty<'tcx>) -> Option<()> {\n+    fn cmp_type_arg(\n+        &self,\n+        mut t1_out: &mut DiagnosticStyledString,\n+        mut t2_out: &mut DiagnosticStyledString,\n+        path: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        other_path: String,\n+        other_ty: &Ty<'tcx>,\n+    ) -> Option<()> {\n         for (i, ta) in sub.types().enumerate() {\n             if &ta == other_ty {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -567,11 +631,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Add a `,` to the type representation only if it is appropriate.\n-    fn push_comma(&self,\n-                  value: &mut DiagnosticStyledString,\n-                  other_value: &mut DiagnosticStyledString,\n-                  len: usize,\n-                  pos: usize) {\n+    fn push_comma(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        len: usize,\n+        pos: usize,\n+    ) {\n         if len > 0 && pos != len - 1 {\n             value.push_normal(\", \");\n             other_value.push_normal(\", \");\n@@ -580,39 +646,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Compare two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n-    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>)\n-        -> (DiagnosticStyledString, DiagnosticStyledString)\n-    {\n+    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (a, b) if *a == *b => true,\n-                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_)) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_)) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)),\n-                 &ty::TyInfer(ty::InferTy::FloatVar(_))) => true,\n+                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n+                | (\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                ) => true,\n                 _ => false,\n             }\n         }\n \n-        fn push_ty_ref<'tcx>(r: &ty::Region<'tcx>,\n-                             tnm: &ty::TypeAndMut<'tcx>,\n-                             s: &mut DiagnosticStyledString) {\n+        fn push_ty_ref<'tcx>(\n+            r: &ty::Region<'tcx>,\n+            tnm: &ty::TypeAndMut<'tcx>,\n+            s: &mut DiagnosticStyledString,\n+        ) {\n             let r = &format!(\"{}\", r);\n-            s.push_highlighted(format!(\"&{}{}{}\",\n-                                       r,\n-                                       if r == \"\" {\n-                                           \"\"\n-                                       } else {\n-                                           \" \"\n-                                       },\n-                                       if tnm.mutbl == hir::MutMutable {\n-                                          \"mut \"\n-                                       } else {\n-                                           \"\"\n-                                       }));\n+            s.push_highlighted(format!(\n+                \"&{}{}{}\",\n+                r,\n+                if r == \"\" { \"\" } else { \" \" },\n+                if tnm.mutbl == hir::MutMutable {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                }\n+            ));\n             s.push_normal(format!(\"{}\", tnm.ty));\n         }\n \n@@ -705,32 +771,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //     Foo<Bar<Qux>\n                     //         ------- this type argument is exactly the same as the other type\n                     //     Bar<Qux>\n-                    if self.cmp_type_arg(&mut values.0,\n-                                         &mut values.1,\n-                                         path1.clone(),\n-                                         sub1,\n-                                         path2.clone(),\n-                                         &t2).is_some() {\n+                    if self.cmp_type_arg(\n+                        &mut values.0,\n+                        &mut values.1,\n+                        path1.clone(),\n+                        sub1,\n+                        path2.clone(),\n+                        &t2,\n+                    ).is_some()\n+                    {\n                         return values;\n                     }\n                     // Check for case:\n                     //     let x: Bar<Qux> = y:<Foo<Bar<Qux>>>();\n                     //     Bar<Qux>\n                     //     Foo<Bar<Qux>>\n                     //         ------- this type argument is exactly the same as the other type\n-                    if self.cmp_type_arg(&mut values.1,\n-                                         &mut values.0,\n-                                         path2,\n-                                         sub2,\n-                                         path1,\n-                                         &t1).is_some() {\n+                    if self.cmp_type_arg(&mut values.1, &mut values.0, path2, sub2, path1, &t1)\n+                        .is_some()\n+                    {\n                         return values;\n                     }\n \n                     // We couldn't find anything in common, highlight everything.\n                     //     let x: Bar<Qux> = y::<Foo<Zar>>();\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n \n@@ -759,37 +827,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 if t1 == t2 {\n                     // The two types are the same, elide and don't highlight.\n-                    (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n+                    (\n+                        DiagnosticStyledString::normal(\"_\"),\n+                        DiagnosticStyledString::normal(\"_\"),\n+                    )\n                 } else {\n                     // We couldn't find anything in common, highlight everything.\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n         }\n     }\n \n-    pub fn note_type_err(&self,\n-                         diag: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>,\n-                         secondary_span: Option<(Span, String)>,\n-                         mut values: Option<ValuePairs<'tcx>>,\n-                         terr: &TypeError<'tcx>)\n-    {\n+    pub fn note_type_err(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        secondary_span: Option<(Span, String)>,\n+        mut values: Option<ValuePairs<'tcx>>,\n+        terr: &TypeError<'tcx>,\n+    ) {\n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n         match terr {\n-            TypeError::CyclicTy(_) => { values = None; }\n-            _ => { }\n+            TypeError::CyclicTy(_) => {\n+                values = None;\n+            }\n+            _ => {}\n         }\n \n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n             Some(values) => {\n                 let (is_simple_error, exp_found) = match values {\n                     ValuePairs::Types(exp_found) => {\n-                        let is_simple_err = exp_found.expected.is_primitive()\n-                            && exp_found.found.is_primitive();\n+                        let is_simple_err =\n+                            exp_found.expected.is_primitive() && exp_found.found.is_primitive();\n \n                         (is_simple_err, Some(exp_found))\n                     }\n@@ -800,7 +876,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     None => {\n                         // Derived error. Cancel the emitter.\n                         self.tcx.sess.diagnostic().cancel(diag);\n-                        return\n+                        return;\n                     }\n                 };\n                 (vals, exp_found, is_simple_error)\n@@ -818,22 +894,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n                     diag.note_expected_found_extra(\n-                        &\"type\", expected, found,\n+                        &\"type\",\n+                        expected,\n+                        found,\n                         &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                        &format!(\" ({})\", values.found.sort_string(self.tcx)));\n+                        &format!(\" ({})\", values.found.sort_string(self.tcx)),\n+                    );\n                 }\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n                             TypeVariants::TyFnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n-                            _ => (None, None)\n+                            _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n                             TypeVariants::TyAdt(def, _) => def.is_struct(),\n-                            _ => false\n+                            _ => false,\n                         };\n \n                         if let (Some(def_id), Some(ret_ty)) = (def_id, ret_ty) {\n@@ -861,14 +940,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_error_origin(diag, &cause);\n     }\n \n-    pub fn report_and_explain_type_error(&self,\n-                                         trace: TypeTrace<'tcx>,\n-                                         terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx>\n-    {\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\",\n-               trace,\n-               terr);\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: &TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        debug!(\n+            \"report_and_explain_type_error(trace={:?}, terr={:?})\",\n+            trace, terr\n+        );\n \n         let span = trace.cause.span(&self.tcx);\n         let failure_code = trace.cause.as_failure_code(terr);\n@@ -890,19 +970,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag\n     }\n \n-    fn values_str(&self, values: &ValuePairs<'tcx>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+    fn values_str(\n+        &self,\n+        values: &ValuePairs<'tcx>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n+            infer::Regions(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str_ty(&self,\n-                             exp_found: &ty::error::ExpectedFound<Ty<'tcx>>)\n-                             -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    fn expected_found_str_ty(\n+        &self,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n@@ -914,25 +997,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n-        exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+        exp_found: &ty::error::ExpectedFound<T>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n-              DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n+        Some((\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found)),\n+        ))\n     }\n \n-    pub fn report_generic_bound_failure(&self,\n-                                        region_scope_tree: &region::ScopeTree,\n-                                        span: Span,\n-                                        origin: Option<SubregionOrigin<'tcx>>,\n-                                        bound_kind: GenericKind<'tcx>,\n-                                        sub: Region<'tcx>)\n-    {\n+    pub fn report_generic_bound_failure(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        span: Span,\n+        origin: Option<SubregionOrigin<'tcx>>,\n+        bound_kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+    ) {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -958,8 +1043,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // `sp` only covers `T`, change it so that it covers\n                             // `T:` when appropriate\n                             let sp = if has_lifetimes {\n-                                sp.to(self.tcx.sess.codemap().next_point(\n-                                        self.tcx.sess.codemap().next_point(sp)))\n+                                sp.to(self.tcx\n+                                    .sess\n+                                    .codemap()\n+                                    .next_point(self.tcx.sess.codemap().next_point(sp)))\n                             } else {\n                                 sp\n                             };\n@@ -974,37 +1061,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let labeled_user_string = match bound_kind {\n-            GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p),\n-            GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p),\n+            GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n+            GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n         };\n \n         if let Some(SubregionOrigin::CompareImplMethodObligation {\n-            span, item_name, impl_item_def_id, trait_item_def_id,\n-        }) = origin {\n-            self.report_extra_impl_obligation(span,\n-                                              item_name,\n-                                              impl_item_def_id,\n-                                              trait_item_def_id,\n-                                              &format!(\"`{}: {}`\", bound_kind, sub))\n-                .emit();\n+            span,\n+            item_name,\n+            impl_item_def_id,\n+            trait_item_def_id,\n+        }) = origin\n+        {\n+            self.report_extra_impl_obligation(\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+                &format!(\"`{}: {}`\", bound_kind, sub),\n+            ).emit();\n             return;\n         }\n \n-        fn binding_suggestion<'tcx, S: fmt::Display>(err: &mut DiagnosticBuilder<'tcx>,\n-                                                     type_param_span: Option<(Span, bool)>,\n-                                                     bound_kind: GenericKind<'tcx>,\n-                                                     sub: S) {\n-            let consider = &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                                    bound_kind,\n-                                    sub);\n+        fn binding_suggestion<'tcx, S: fmt::Display>(\n+            err: &mut DiagnosticBuilder<'tcx>,\n+            type_param_span: Option<(Span, bool)>,\n+            bound_kind: GenericKind<'tcx>,\n+            sub: S,\n+        ) {\n+            let consider = &format!(\n+                \"consider adding an explicit lifetime bound `{}: {}`...\",\n+                bound_kind, sub\n+            );\n             if let Some((sp, has_lifetimes)) = type_param_span {\n-                let tail = if has_lifetimes {\n-                    \" + \"\n-                } else {\n-                    \"\"\n-                };\n+                let tail = if has_lifetimes { \" + \" } else { \"\" };\n                 let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n                 err.span_suggestion_short(sp, consider, suggestion);\n             } else {\n@@ -1013,44 +1102,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut err = match *sub {\n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n+            ty::ReEarlyBound(_)\n+            | ty::ReFree(ty::FreeRegion {\n+                bound_region: ty::BrNamed(..),\n+                ..\n+            }) => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0309,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0309,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, sub);\n                 err\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0310,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0310,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n                 err\n             }\n \n             _ => {\n                 // If not, be less specific.\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0311,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n-                err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n-                                  bound_kind));\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0311,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n+                err.help(&format!(\n+                    \"consider adding an explicit lifetime bound for `{}`\",\n+                    bound_kind\n+                ));\n                 self.tcx.note_and_explain_region(\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n-                    \"...\");\n+                    \"...\",\n+                );\n                 err\n             }\n         };\n@@ -1061,26 +1162,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_sub_sup_conflict(&self,\n-                               region_scope_tree: &region::ScopeTree,\n-                               var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region<'tcx>,\n-                               sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region<'tcx>) {\n-\n+    fn report_sub_sup_conflict(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        var_origin: RegionVariableOrigin,\n+        sub_origin: SubregionOrigin<'tcx>,\n+        sub_region: Region<'tcx>,\n+        sup_origin: SubregionOrigin<'tcx>,\n+        sup_region: Region<'tcx>,\n+    ) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         match (&sup_origin, &sub_origin) {\n             (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n-                if let (Some((sup_expected, sup_found)),\n-                        Some((sub_expected, sub_found))) = (self.values_str(&sup_trace.values),\n-                                                            self.values_str(&sub_trace.values)) {\n+                if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) = (\n+                    self.values_str(&sup_trace.values),\n+                    self.values_str(&sub_trace.values),\n+                ) {\n                     if sub_expected == sup_expected && sub_found == sup_found {\n                         self.tcx.note_and_explain_region(\n                             region_scope_tree,\n@@ -1089,10 +1195,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             sub_region,\n                             \"...\",\n                         );\n-                        err.note(&format!(\"...so that the {}:\\nexpected {}\\n   found {}\",\n-                                          sup_trace.cause.as_requirement_str(),\n-                                          sup_expected.content(),\n-                                          sup_found.content()));\n+                        err.note(&format!(\n+                            \"...so that the {}:\\nexpected {}\\n   found {}\",\n+                            sup_trace.cause.as_requirement_str(),\n+                            sup_expected.content(),\n+                            sup_found.content()\n+                        ));\n                         err.emit();\n                         return;\n                     }\n@@ -1103,20 +1211,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin)\n-                                -> DiagnosticBuilder<'tcx> {\n+    fn report_inference_failure(\n+        &self,\n+        var_origin: RegionVariableOrigin,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n             let mut s = br.to_string();\n             if !s.is_empty() {\n@@ -1131,23 +1243,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n-                format!(\" for lifetime parameter {}in function call\",\n-                        br_string(br))\n+                format!(\" for lifetime parameter {}in function call\", br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n                 format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n-            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => {\n-                format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), self.tcx.associated_item(def_id).name)\n-            }\n-            infer::EarlyBoundRegion(_, name) => {\n-                format!(\" for lifetime parameter `{}`\",\n-                        name)\n-            }\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n+                \" for lifetime parameter {}in trait containing associated type `{}`\",\n+                br_string(br),\n+                self.tcx.associated_item(def_id).name\n+            ),\n+            infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::BoundRegionInCoherence(name) => {\n-                format!(\" for lifetime parameter `{}` in coherence check\",\n-                        name)\n+                format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n@@ -1157,10 +1265,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n-        struct_span_err!(self.tcx.sess, var_origin.span(), E0495,\n-                  \"cannot infer an appropriate lifetime{} \\\n-                   due to conflicting requirements\",\n-                  var_description)\n+        struct_span_err!(\n+            self.tcx.sess,\n+            var_origin.span(),\n+            E0495,\n+            \"cannot infer an appropriate lifetime{} \\\n+             due to conflicting requirements\",\n+            var_description\n+        )\n     }\n }\n \n@@ -1178,12 +1290,11 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n                 _ => \"match arms have incompatible types\",\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n-            EquatePredicate => Error0308(\"equality predicate not satisfied\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n             StartFunctionType => Error0308(\"start function has wrong type\"),\n             IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n@@ -1193,11 +1304,11 @@ impl<'tcx> ObligationCause<'tcx> {\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n-                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() =>\n-                    Error0644(\"closure/generator type that references itself\"),\n-                _ =>\n-                    Error0308(\"mismatched types\"),\n-            }\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n+                    Error0644(\"closure/generator type that references itself\")\n+                }\n+                _ => Error0308(\"mismatched types\"),\n+            },\n         }\n     }\n \n@@ -1207,12 +1318,11 @@ impl<'tcx> ObligationCause<'tcx> {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n             MatchExpressionArm { source, .. } => match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have compatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n             IfExpression => \"if and else have compatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n-            EquatePredicate => \"equality where clause is satisfied\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\",\n             IntrinsicType => \"intrinsic has the correct type\","}, {"sha": "6074bfd083d46dc82a0f1d8e5080ea8a85d6230e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -114,9 +114,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 self.tcx().types.re_erased\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    \"encountered unexpected region: {:?}\",\n                     r,\n                 );\n             }\n@@ -133,7 +134,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v);\n+                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen(\n                     opt_ty,\n                     ty::TyVar(v),\n@@ -143,7 +144,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(v)) => {\n                 self.freshen(\n                     self.infcx.int_unification_table.borrow_mut()\n-                                                    .probe(v)\n+                                                    .probe_value(v)\n                                                     .map(|v| v.to_type(tcx)),\n                     ty::IntVar(v),\n                     ty::FreshIntTy)\n@@ -152,7 +153,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyInfer(ty::FloatVar(v)) => {\n                 self.freshen(\n                     self.infcx.float_unification_table.borrow_mut()\n-                                                      .probe(v)\n+                                                      .probe_value(v)\n                                                       .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n                     ty::FreshFloatTy)\n@@ -170,6 +171,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n+            ty::TyInfer(ty::CanonicalTy(..)) =>\n+                bug!(\"encountered canonical ty during freshening\"),\n+\n             ty::TyGenerator(..) |\n             ty::TyBool |\n             ty::TyChar |"}, {"sha": "48eb253415cdf07172abb3e66a6575fdac7f9eb9", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -131,15 +131,21 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // variables to their binding anyhow, we know\n                         // that it is unbound, so we can just return\n                         // it.\n-                        debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_none());\n+                        debug_assert!(self.infcx.type_variables.borrow_mut()\n+                                      .probe(vid)\n+                                      .is_unknown());\n                         ty\n                     }\n \n                     Some(&origin) => {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        self.infcx.next_ty_var(origin)\n+                        //\n+                        // The ROOT universe is fine because we only\n+                        // ever invoke this routine at the\n+                        // \"item-level\" of inference.\n+                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n                     }\n                 }\n             }"}, {"sha": "a317e0699b4bba29e755138815ef2036b24fcbd6", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -479,7 +479,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n-                       snapshot: &CombinedSnapshot,\n+                       snapshot: &CombinedSnapshot<'a, 'tcx>,\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot)\n+                                        snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                         -> Vec<ty::RegionVid>\n     {\n         /*!\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// See `README.md` for more details.\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot)\n+                                           snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                            -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n@@ -609,7 +609,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                       overly_polymorphic: bool,\n                       _span: Span,\n                       skol_map: &SkolemizationMap<'tcx>,\n-                      snapshot: &CombinedSnapshot)\n+                      snapshot: &CombinedSnapshot<'a, 'tcx>)\n                       -> RelateResult<'tcx, ()>\n     {\n         debug!(\"leak_check: skol_map={:?}\",\n@@ -684,7 +684,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n                          skol_map: SkolemizationMap<'tcx>,\n-                         snapshot: &CombinedSnapshot,\n+                         snapshot: &CombinedSnapshot<'a, 'tcx>,\n                          value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n@@ -770,8 +770,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n     pub fn pop_skolemized(&self,\n                           skol_map: SkolemizationMap<'tcx>,\n-                          snapshot: &CombinedSnapshot)\n-    {\n+                          snapshot: &CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.borrow_region_constraints()"}, {"sha": "c4722f9a7f96cb39d86cdbbad25092baceeb2133", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -70,14 +70,6 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n     let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n     let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n     match (&a.sty, &b.sty) {\n-        (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n-            if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n-            let v = infcx.next_diverging_ty_var(\n-                TypeVariableOrigin::LatticeVariable(this.cause().span));\n-            this.relate_bound(v, a, b)?;\n-            Ok(v)\n-        }\n-\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n         // relate `v` to the non-type-variable first (by passing it\n@@ -96,13 +88,17 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(..)), _) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(a_vid)), _) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(b_vid))) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "00b2ac7449f7e9a9ac1e5378296d3c560b25eadb", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -258,6 +258,8 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.region_rels.tcx;\n         match (a, b) {\n+            (&ty::ReCanonical(..), _) |\n+            (_, &ty::ReCanonical(..)) |\n             (&ty::ReClosureBound(..), _) |\n             (_, &ty::ReClosureBound(..)) |\n             (&ReLateBound(..), _) |"}, {"sha": "fe919775da0b412a8e27280ca3b2bfed1d56e43a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 108, "deletions": 332, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -21,21 +21,20 @@ use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n-use mir::tcx::PlaceTy;\n-use ty::subst::{Kind, Subst, Substs};\n+use ty::subst::Substs;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations, Reveal};\n-use rustc_data_structures::unify::{self, UnificationTable};\n+use traits::{self, ObligationCause, PredicateObligations};\n+use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n-use syntax_pos::{self, Span, DUMMY_SP};\n+use syntax_pos::{self, Span};\n use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n \n@@ -50,6 +49,7 @@ use self::unify_key::ToType;\n \n pub mod anon_types;\n pub mod at;\n+pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -68,6 +68,7 @@ pub mod type_variable;\n pub mod unify_key;\n \n #[must_use]\n+#[derive(Debug)]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n     pub obligations: PredicateObligations<'tcx>,\n@@ -99,10 +100,10 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n+    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n+    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n \n     // Tracks the set of region variables and the constraints between\n     // them.  This is initially `Some(_)` but when\n@@ -180,7 +181,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // for each body-id in this map, which will process the\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n-    region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+    pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -191,6 +192,7 @@ pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n+    Regions(ExpectedFound<ty::Region<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n@@ -441,8 +443,8 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             in_progress_tables,\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(UnificationTable::new()),\n-            float_unification_table: RefCell::new(UnificationTable::new()),\n+            int_unification_table: RefCell::new(ut::UnificationTable::new()),\n+            float_unification_table: RefCell::new(ut::UnificationTable::new()),\n             region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n@@ -472,188 +474,25 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     }\n }\n \n+impl<'tcx> InferOk<'tcx, ()> {\n+    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot,\n-    int_snapshot: unify::Snapshot<ty::IntVid>,\n-    float_snapshot: unify::Snapshot<ty::FloatVid>,\n+    type_snapshot: type_variable::Snapshot<'tcx>,\n+    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n+    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n     region_obligations_snapshot: usize,\n     was_in_snapshot: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n-/// Helper trait for shortening the lifetimes inside a\n-/// value for post-type-checking normalization.\n-pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>)\n-                                 -> Self;\n-}\n-\n-macro_rules! items { ($($item:item)+) => ($($item)+) }\n-macro_rules! impl_trans_normalize {\n-    ($lt_gcx:tt, $($ty:ty),+) => {\n-        items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n-            fn trans_normalize<'a, 'tcx>(&self,\n-                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n-                                         param_env: ty::ParamEnv<'tcx>)\n-                                         -> Self {\n-                infcx.normalize_projections_in(param_env, self)\n-            }\n-        })+);\n-    }\n-}\n-\n-impl_trans_normalize!('gcx,\n-    Ty<'gcx>,\n-    &'gcx ty::Const<'gcx>,\n-    &'gcx Substs<'gcx>,\n-    ty::FnSig<'gcx>,\n-    ty::PolyFnSig<'gcx>,\n-    ty::ClosureSubsts<'gcx>,\n-    ty::PolyTraitRef<'gcx>,\n-    ty::ExistentialTraitRef<'gcx>\n-);\n-\n-impl<'gcx> TransNormalize<'gcx> for PlaceTy<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>)\n-                                 -> Self {\n-        match *self {\n-            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n-            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n-                PlaceTy::Downcast {\n-                    adt_def,\n-                    substs: substs.trans_normalize(infcx, param_env),\n-                    variant_index,\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// NOTE: Callable from trans only!\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Currently, higher-ranked type bounds inhibit normalization. Therefore,\n-    /// each time we erase them in translation, we need to normalize\n-    /// the contents.\n-    pub fn erase_late_bound_regions_and_normalize<T>(self, value: &ty::Binder<T>)\n-        -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        assert!(!value.needs_subst());\n-        let value = self.erase_late_bound_regions(value);\n-        self.fully_normalize_associated_types_in(&value)\n-    }\n-\n-    /// Fully normalizes any associated types in `value`, using an\n-    /// empty environment and `Reveal::All` mode (therefore, suitable\n-    /// only for monomorphized code during trans, basically).\n-    pub fn fully_normalize_associated_types_in<T>(self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        debug!(\"fully_normalize_associated_types_in(t={:?})\", value);\n-\n-        let param_env = ty::ParamEnv::empty(Reveal::All);\n-        let value = self.erase_regions(value);\n-\n-        if !value.has_projections() {\n-            return value;\n-        }\n-\n-        self.infer_ctxt().enter(|infcx| {\n-            value.trans_normalize(&infcx, param_env)\n-        })\n-    }\n-\n-    /// Does a best-effort to normalize any associated types in\n-    /// `value`; this includes revealing specializable types, so this\n-    /// should be not be used during type-checking, but only during\n-    /// optimization and code generation.\n-    pub fn normalize_associated_type_in_env<T>(\n-        self, value: &T, env: ty::ParamEnv<'tcx>\n-    ) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        debug!(\"normalize_associated_type_in_env(t={:?})\", value);\n-\n-        let value = self.erase_regions(value);\n-\n-        if !value.has_projections() {\n-            return value;\n-        }\n-\n-        self.infer_ctxt().enter(|infcx| {\n-            value.trans_normalize(&infcx, env.reveal_all())\n-       })\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn normalize_projections_in<T>(&self, param_env: ty::ParamEnv<'tcx>, value: &T) -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-    {\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-\n-        debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n-                result, obligations);\n-\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(self, obligation);\n-        }\n-\n-        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n-    }\n-\n-    /// Finishes processes any obligations that remain in the\n-    /// fulfillment context, and then returns the result with all type\n-    /// variables removed and regions erased. Because this is intended\n-    /// for use after type-check has completed, if any errors occur,\n-    /// it will panic. It is used during normalization and other cases\n-    /// where processing the obligations in `fulfill_cx` may cause\n-    /// type inference variables that appear in `result` to be\n-    /// unified, and hence we need to process those obligations to get\n-    /// the complete picture of the type.\n-    pub fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                            span: Span,\n-                                            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                            result: &T)\n-                                            -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-    {\n-        debug!(\"drain_fulfillment_cx_or_panic()\");\n-\n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                          errors);\n-            }\n-        }\n-\n-        let result = self.resolve_type_vars_if_possible(result);\n-        let result = self.tcx.erase_regions(&result);\n-\n-        match self.tcx.lift_to_global(&result) {\n-            Some(result) => result,\n-            None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n-            }\n-        }\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -678,14 +517,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::TyInfer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().has_value(vid) {\n+                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             },\n             ty::TyInfer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().has_value(vid) {\n+                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -695,46 +534,35 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns a type variable's default fallback if any exists. A default\n-    /// must be attached to the variable when created, if it is created\n-    /// without a default, this will return None.\n-    ///\n-    /// This code does not apply to integral or floating point variables,\n-    /// only to use declared defaults.\n-    ///\n-    /// See `new_ty_var_with_default` to create a type variable with a default.\n-    /// See `type_variable::Default` for details about what a default entails.\n-    pub fn default(&self, ty: Ty<'tcx>) -> Option<type_variable::Default<'tcx>> {\n-        match ty.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().default(vid),\n-            _ => None\n-        }\n-    }\n-\n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n         let mut variables = Vec::new();\n \n-        let unbound_ty_vars = self.type_variables\n-                                  .borrow_mut()\n-                                  .unsolved_variables()\n-                                  .into_iter()\n-                                  .map(|t| self.tcx.mk_var(t));\n-\n-        let unbound_int_vars = self.int_unification_table\n-                                   .borrow_mut()\n-                                   .unsolved_variables()\n-                                   .into_iter()\n-                                   .map(|v| self.tcx.mk_int_var(v));\n+        {\n+            let mut type_variables = self.type_variables.borrow_mut();\n+            variables.extend(\n+                type_variables\n+                    .unsolved_variables()\n+                    .into_iter()\n+                    .map(|t| self.tcx.mk_var(t)));\n+        }\n \n-        let unbound_float_vars = self.float_unification_table\n-                                     .borrow_mut()\n-                                     .unsolved_variables()\n-                                     .into_iter()\n-                                     .map(|v| self.tcx.mk_float_var(v));\n+        {\n+            let mut int_unification_table = self.int_unification_table.borrow_mut();\n+            variables.extend(\n+                (0..int_unification_table.len())\n+                    .map(|i| ty::IntVid { index: i as u32 })\n+                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n+                    .map(|v| self.tcx.mk_int_var(v)));\n+        }\n \n-        variables.extend(unbound_ty_vars);\n-        variables.extend(unbound_int_vars);\n-        variables.extend(unbound_float_vars);\n+        {\n+            let mut float_unification_table = self.float_unification_table.borrow_mut();\n+            variables.extend(\n+                (0..float_unification_table.len())\n+                    .map(|i| ty::FloatVid { index: i as u32 })\n+                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n+                    .map(|v| self.tcx.mk_float_var(v)));\n+        }\n \n         return variables;\n     }\n@@ -776,7 +604,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot<'b>(&'b self) -> CombinedSnapshot<'b, 'tcx> {\n+    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.get();\n@@ -798,7 +626,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -830,7 +658,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .rollback_to(region_constraints_snapshot);\n     }\n \n-    fn commit_from(&self, snapshot: CombinedSnapshot) {\n+    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -872,7 +700,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n@@ -887,7 +715,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n     pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot) -> T\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -898,7 +726,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n-        F: FnOnce(&CombinedSnapshot) -> R,\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n@@ -954,23 +782,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().make_subregion(origin, a, b);\n     }\n \n-    pub fn equality_predicate(&self,\n-                              cause: &ObligationCause<'tcx>,\n-                              param_env: ty::ParamEnv<'tcx>,\n-                              predicate: &ty::PolyEquatePredicate<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::EquatePredicate(a, b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n-            let cause_span = cause.span;\n-            let eqty_ok = self.at(cause, param_env).eq(b, a)?;\n-            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n-            self.pop_skolemized(skol_map, snapshot);\n-            Ok(eqty_ok.unit())\n-        })\n-    }\n-\n     pub fn subtype_predicate(&self,\n                              cause: &ObligationCause<'tcx>,\n                              param_env: ty::ParamEnv<'tcx>,\n@@ -1026,18 +837,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+    pub fn next_ty_var_id(&self,\n+                          universe: ty::UniverseIndex,\n+                          diverging: bool,\n+                          origin: TypeVariableOrigin)\n+                          -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, origin, None)\n+            .new_var(universe, diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n+    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n+    pub fn next_diverging_ty_var(&self,\n+                                 universe: ty::UniverseIndex,\n+                                 origin: TypeVariableOrigin)\n+                                 -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1092,41 +910,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n+                            universe: ty::UniverseIndex,\n                             span: Span,\n-                            def: &ty::TypeParameterDef,\n-                            substs: &[Kind<'tcx>])\n+                            def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n-        let default = if def.has_default {\n-            let default = self.tcx.type_of(def.def_id);\n-            Some(type_variable::Default {\n-                ty: default.subst_spanned(self.tcx, substs, Some(span)),\n-                origin_span: span,\n-                def_id: def.def_id\n-            })\n-        } else {\n-            None\n-        };\n-\n-\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false,\n-                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name),\n-                                     default);\n+                            .new_var(universe,\n+                                     false,\n+                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n+                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n-        }, |def, substs| {\n-            self.type_var_for_def(span, def, substs)\n+        }, |def, _| {\n+            self.type_var_for_def(universe, span, def)\n         })\n     }\n \n@@ -1244,6 +1051,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().take_and_reset_data()\n     }\n \n+    /// Gives temporary access to the region constraint data.\n+    #[allow(non_camel_case_types)] // bug with impl trait\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let region_constraints = self.borrow_region_constraints();\n+        op(region_constraints.data())\n+    }\n+\n     /// Takes ownership of the list of variable regions. This implies\n     /// that all the region constriants have already been taken, and\n     /// hence that `resolve_regions_and_report_errors` can never be\n@@ -1278,29 +1095,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n                 // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n+                // variables from unifyxing to other type variables\n                 // directly (though they may be embedded\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n                 self.type_variables.borrow_mut()\n-                    .probe(v)\n-                    .map(|t| self.shallow_resolve(t))\n-                    .unwrap_or(typ)\n+                                   .probe(v)\n+                                   .known()\n+                                   .map(|t| self.shallow_resolve(t))\n+                                   .unwrap_or(typ)\n             }\n \n             ty::TyInfer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n-                    .probe(v)\n+                    .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n             ty::TyInfer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n-                    .probe(v)\n+                    .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n@@ -1402,28 +1220,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_and_explain_type_error(trace, &err)\n     }\n \n-    pub fn report_conflicting_default_types(&self,\n-                                            span: Span,\n-                                            body_id: ast::NodeId,\n-                                            expected: type_variable::Default<'tcx>,\n-                                            actual: type_variable::Default<'tcx>) {\n-        let trace = TypeTrace {\n-            cause: ObligationCause::misc(span, body_id),\n-            values: Types(ExpectedFound {\n-                expected: expected.ty,\n-                found: actual.ty\n-            })\n-        };\n-\n-        self.report_and_explain_type_error(\n-            trace,\n-            &TypeError::TyParamDefaultMismatch(ExpectedFound {\n-                expected,\n-                found: actual\n-            }))\n-            .emit();\n-    }\n-\n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n         span: Span,\n@@ -1555,11 +1351,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         InferOk { value, obligations }\n     }\n \n-    fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n+    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n         RefMut::map(\n             self.region_constraints.borrow_mut(),\n             |c| c.as_mut().expect(\"region constraints already solved\"))\n     }\n+\n+    /// Clears the selection, evaluation, and projection cachesThis is useful when\n+    /// repeatedly attemping to select an Obligation while changing only\n+    /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n+    pub fn clear_caches(&self) {\n+        self.selection_cache.clear();\n+        self.evaluation_cache.clear();\n+        self.projection_cache.borrow_mut().clear();\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n@@ -1667,40 +1472,12 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ValuePairs::Types(ref ef) => {\n-                ValuePairs::Types(ef.fold_with(folder))\n-            }\n-            ValuePairs::TraitRefs(ref ef) => {\n-                ValuePairs::TraitRefs(ef.fold_with(folder))\n-            }\n-            ValuePairs::PolyTraitRefs(ref ef) => {\n-                ValuePairs::PolyTraitRefs(ef.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ValuePairs::Types(ref ef) => ef.visit_with(visitor),\n-            ValuePairs::TraitRefs(ref ef) => ef.visit_with(visitor),\n-            ValuePairs::PolyTraitRefs(ref ef) => ef.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TypeTrace {\n-            cause: self.cause.fold_with(folder),\n-            values: self.values.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n+        (ValuePairs::Types)(a),\n+        (ValuePairs::Regions)(a),\n+        (ValuePairs::TraitRefs)(a),\n+        (ValuePairs::PolyTraitRefs)(a),\n     }\n }\n \n@@ -1711,4 +1488,3 @@ impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n                self.sup_type)\n     }\n }\n-"}, {"sha": "8bb3f4158ff5b8a56ec833bfbc3cc6135d61464a", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -117,7 +117,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 assert!(!obligation.has_escaping_regions());\n                 match obligation.predicate {\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::Subtype(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::ClosureKind(..) |\n@@ -152,7 +151,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // get solved *here*.\n         match fulfill_cx.select_all_or_error(self) {\n             Ok(()) => (),\n-            Err(errors) => self.report_fulfillment_errors(&errors, None),\n+            Err(errors) => self.report_fulfillment_errors(&errors, None, false),\n         }\n \n         implied_bounds\n@@ -204,7 +203,6 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .filter_map(move |predicate| match predicate {\n             ty::Predicate::Projection(..) |\n             ty::Predicate::Trait(..) |\n-            ty::Predicate::Equate(..) |\n             ty::Predicate::Subtype(..) |\n             ty::Predicate::WellFormed(..) |\n             ty::Predicate::ObjectSafe(..) |"}, {"sha": "e5461685bd470bd21a744008698bf75013d6f0ac", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -99,6 +99,16 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .push((body_id, obligation));\n     }\n \n+    /// Trait queries just want to pass back type obligations \"as is\"\n+    pub fn take_registered_region_obligations(\n+        &self,\n+    ) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+        ::std::mem::replace(\n+            &mut *self.region_obligations.borrow_mut(),\n+            vec![],\n+        )\n+    }\n+\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n     /// the region bounds in scope and so forth. This function must be"}, {"sha": "0c8e49fda1840d7cab10569ee946bfebd5be85e9", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -18,7 +18,7 @@ use super::unify_key;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::unify::{self, UnificationTable};\n+use rustc_data_structures::unify as ut;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::ReStatic;\n@@ -48,7 +48,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     glbs: CombineMap<'tcx>,\n \n     /// Number of skolemized variables currently active.\n-    skolemization_count: u32,\n+    skolemization_count: ty::UniverseIndex,\n \n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n@@ -73,7 +73,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// is iterating to a fixed point, because otherwise we sometimes\n     /// would wind up with a fresh stream of region variables that\n     /// have been equated but appear distinct.\n-    unification_table: UnificationTable<ty::RegionVid>,\n+    unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n }\n \n pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n@@ -82,7 +82,7 @@ pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n /// Describes constraints between the region variables and other\n /// regions, as well as other conditions that must be verified, or\n /// assumptions that can be made.\n-#[derive(Debug, Default)]\n+#[derive(Debug, Default, Clone)]\n pub struct RegionConstraintData<'tcx> {\n     /// Constraints of the form `A <= B`, where either `A` or `B` can\n     /// be a region variable (or neither, as it happens).\n@@ -142,7 +142,7 @@ pub enum Constraint<'tcx> {\n /// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n /// `i`. Inference variables may be involved (but this verification\n /// step doesn't influence inference).\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Verify<'tcx> {\n     pub kind: GenericKind<'tcx>,\n     pub origin: SubregionOrigin<'tcx>,\n@@ -159,7 +159,7 @@ pub enum GenericKind<'tcx> {\n /// When we introduce a verification step, we wish to test that a\n /// particular region (let's call it `'min`) meets some bound.\n /// The bound is described the by the following grammar:\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n     /// B = exists {R} --> some 'r in {R} must outlive 'min\n     ///\n@@ -232,8 +232,8 @@ type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionSnapshot {\n     length: usize,\n-    region_snapshot: unify::Snapshot<ty::RegionVid>,\n-    skolemization_count: u32,\n+    region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n+    skolemization_count: ty::UniverseIndex,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -277,17 +277,21 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: 0,\n+            skolemization_count: ty::UniverseIndex::ROOT,\n             bound_count: 0,\n             undo_log: Vec::new(),\n-            unification_table: UnificationTable::new(),\n+            unification_table: ut::UnificationTable::new(),\n         }\n     }\n \n     pub fn var_origins(&self) -> &VarOrigins {\n         &self.var_origins\n     }\n \n+    pub fn region_constraint_data(&self) -> &RegionConstraintData<'tcx> {\n+        &self.data\n+    }\n+\n     /// Once all the constraints have been gathered, extract out the final data.\n     ///\n     /// Not legal during a snapshot.\n@@ -325,7 +329,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             unification_table,\n         } = self;\n \n-        assert_eq!(*skolemization_count, 0);\n+        assert_eq!(skolemization_count.as_usize(), 0);\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -338,14 +342,18 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // un-unified\" state. Note that when we unify `a` and `b`, we\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n-        *unification_table = UnificationTable::new();\n+        *unification_table = ut::UnificationTable::new();\n         for vid in var_origins.indices() {\n             unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n         }\n \n         mem::replace(data, RegionConstraintData::default())\n     }\n \n+    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n+        &self.data\n+    }\n+\n     fn in_snapshot(&self) -> bool {\n         !self.undo_log.is_empty()\n     }\n@@ -367,7 +375,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n             self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {} now vs {} at start\",\n+            \"failed to pop skolemized regions: {:?} now vs {:?} at start\",\n             self.skolemization_count,\n             snapshot.skolemization_count\n         );\n@@ -475,9 +483,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n-        let sc = self.skolemization_count;\n-        self.skolemization_count = sc + 1;\n-        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+        let universe = self.skolemization_count.subuniverse();\n+        self.skolemization_count = universe;\n+        tcx.mk_region(ReSkolemized(universe, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -495,34 +503,34 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count as usize >= skols.len(),\n+            self.skolemization_count.as_usize() >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n              sc now = {}, skols.len = {}\",\n-            self.skolemization_count,\n+            self.skolemization_count.as_usize(),\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count;\n-        let first_to_pop = last_to_pop - (skols.len() as u32);\n+        let last_to_pop = self.skolemization_count.subuniverse();\n+        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - (skols.len() as u32));\n \n         assert!(\n             first_to_pop >= snapshot.skolemization_count,\n             \"popping more regions than snapshot contains, \\\n-             sc now = {}, sc then = {}, skols.len = {}\",\n+             sc now = {:?}, sc then = {:?}, skols.len = {}\",\n             self.skolemization_count,\n             snapshot.skolemization_count,\n             skols.len()\n         );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(index, _) =>\n-                         index.index >= first_to_pop &&\n-                         index.index < last_to_pop,\n+                     ty::ReSkolemized(universe, _) =>\n+                         universe >= first_to_pop &&\n+                         universe < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n+            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n             snapshot.skolemization_count,\n             self.skolemization_count,\n             skols\n@@ -772,7 +780,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.find_value(rid).min_vid;\n+        let vid = self.unification_table.probe_value(rid).min_vid;\n         tcx.mk_region(ty::ReVar(vid))\n     }\n \n@@ -857,7 +865,7 @@ impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             f,\n-            \"RegionSnapshot(length={},skolemization={})\",\n+            \"RegionSnapshot(length={},skolemization={:?})\",\n             self.length,\n             self.skolemization_count\n         )\n@@ -892,7 +900,7 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n-    fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n+    fn for_each_region(&self, f: &mut dyn FnMut(ty::Region<'tcx>)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n                 f(r);"}, {"sha": "77b722c5695f86803465b0586d96ec7c2360c666", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -173,12 +173,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n                 ty::TyInfer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n-                ty::TyTuple(tys, true) => {\n-                    // Un-default defaulted tuples - we are going to a\n-                    // different infcx, and the default will just cause\n-                    // pollution.\n-                    self.tcx().intern_tup(tys, false)\n-                }\n                 _ => {\n                     t.super_fold_with(self)\n                 }"}, {"sha": "66360ea50bbe004d2f8879ed7dce20d81ab69e5f", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 211, "deletions": 115, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,26 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::TypeVariableValue::*;\n-use hir::def_id::{DefId};\n use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n-use std::cmp::min;\n+use std::cmp;\n use std::marker::PhantomData;\n-use std::mem;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate<'tcx>>,\n+    values: sv::SnapshotVec<Delegate>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n-    /// constraint `?X == ?Y`.\n-    eq_relations: ut::UnificationTable<ty::TyVid>,\n+    /// constraint `?X == ?Y`. This table also stores, for each key,\n+    /// the known value.\n+    eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n@@ -46,7 +44,7 @@ pub struct TypeVariableTable<'tcx> {\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n-    sub_relations: ut::UnificationTable<ty::TyVid>,\n+    sub_relations: ut::UnificationTable<ut::InPlace<ty::TyVid>>,\n }\n \n /// Reasons to create a type inference variable\n@@ -72,42 +70,60 @@ pub enum TypeVariableOrigin {\n \n pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n \n-struct TypeVariableData<'tcx> {\n-    value: TypeVariableValue<'tcx>,\n+struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n-enum TypeVariableValue<'tcx> {\n-    Known(Ty<'tcx>),\n-    Bounded {\n-        default: Option<Default<'tcx>>\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum TypeVariableValue<'tcx> {\n+    Known { value: Ty<'tcx> },\n+    Unknown { universe: ty::UniverseIndex },\n }\n \n-// We will use this to store the required information to recapitulate what happened when\n-// an error occurs.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct Default<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    /// The span where the default was incurred\n-    pub origin_span: Span,\n-    /// The definition that the default originates from\n-    pub def_id: DefId\n+#[derive(Copy, Clone, Debug)]\n+pub enum ProbeTyValue<'tcx> {\n+    Ty(Ty<'tcx>),\n+    Vid(ty::TyVid),\n+}\n+\n+impl<'tcx> TypeVariableValue<'tcx> {\n+    /// If this value is known, returns the type it is known to be.\n+    /// Otherwise, `None`.\n+    pub fn known(&self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => None,\n+            TypeVariableValue::Known { value } => Some(value),\n+        }\n+    }\n+\n+    /// If this value is unknown, returns the universe, otherwise `None`.\n+    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n+        match *self {\n+            TypeVariableValue::Unknown { universe } => Some(universe),\n+            TypeVariableValue::Known { .. } => None,\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            TypeVariableValue::Unknown { .. } => true,\n+            TypeVariableValue::Known { .. } => false,\n+        }\n+    }\n }\n \n-pub struct Snapshot {\n+pub struct Snapshot<'tcx> {\n     snapshot: sv::Snapshot,\n-    eq_snapshot: ut::Snapshot<ty::TyVid>,\n-    sub_snapshot: ut::Snapshot<ty::TyVid>,\n+    eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n+    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n }\n \n-struct Instantiate<'tcx> {\n+struct Instantiate {\n     vid: ty::TyVid,\n-    default: Option<Default<'tcx>>,\n }\n \n-struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n+struct Delegate;\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n@@ -118,17 +134,18 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n-        match &self.values.get(vid.index as usize).value {\n-            &Known(_) => None,\n-            &Bounded { ref default, .. } => default.clone()\n-        }\n-    }\n-\n+    /// Returns the diverges flag given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n         self.values.get(vid.index as usize).diverging\n     }\n \n+    /// Returns the origin that was given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n         &self.values.get(vid.index as usize).origin\n     }\n@@ -137,8 +154,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.eq_relations.union(a, b);\n         self.sub_relations.union(a, b);\n     }\n@@ -147,8 +164,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n-        debug_assert!(self.probe(a).is_none());\n-        debug_assert!(self.probe(b).is_none());\n+        debug_assert!(self.probe(a).is_unknown());\n+        debug_assert!(self.probe(b).is_unknown());\n         self.sub_relations.union(a, b);\n     }\n \n@@ -157,41 +174,50 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Precondition: `vid` must not have been previously instantiated.\n     pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n         let vid = self.root_var(vid);\n-        debug_assert!(self.probe_root(vid).is_none());\n-\n-        let old_value = {\n-            let vid_data = &mut self.values[vid.index as usize];\n-            mem::replace(&mut vid_data.value, TypeVariableValue::Known(ty))\n-        };\n-\n-        match old_value {\n-            TypeVariableValue::Bounded { default } => {\n-                self.values.record(Instantiate { vid: vid, default: default });\n-            }\n-            TypeVariableValue::Known(old_ty) => {\n-                bug!(\"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n-                     vid, ty, old_ty)\n-            }\n-        }\n+        debug_assert!(self.probe(vid).is_unknown());\n+        debug_assert!(self.eq_relations.probe_value(vid).is_unknown(),\n+                      \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n+                      vid, ty, self.eq_relations.probe_value(vid));\n+        self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n+\n+        // Hack: we only need this so that `types_escaping_snapshot`\n+        // can see what has been unified; see the Delegate impl for\n+        // more details.\n+        self.values.record(Instantiate { vid: vid });\n     }\n \n+    /// Creates a new type variable.\n+    ///\n+    /// - `diverging`: indicates if this is a \"diverging\" type\n+    ///   variable, e.g.  one created as the type of a `return`\n+    ///   expression. The code in this module doesn't care if a\n+    ///   variable is diverging, but the main Rust type-checker will\n+    ///   sometimes \"unify\" such variables with the `!` or `()` types.\n+    /// - `origin`: indicates *why* the type variable was created.\n+    ///   The code in this module doesn't care, but it can be useful\n+    ///   for improving error messages.\n     pub fn new_var(&mut self,\n+                   universe: ty::UniverseIndex,\n                    diverging: bool,\n-                   origin: TypeVariableOrigin,\n-                   default: Option<Default<'tcx>>,) -> ty::TyVid {\n-        debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n-        self.eq_relations.new_key(());\n-        self.sub_relations.new_key(());\n+                   origin: TypeVariableOrigin)\n+                   -> ty::TyVid {\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+\n+        let sub_key = self.sub_relations.new_key(());\n+        assert_eq!(eq_key.vid, sub_key);\n+\n         let index = self.values.push(TypeVariableData {\n-            value: Bounded { default: default },\n             origin,\n             diverging,\n         });\n-        let v = ty::TyVid { index: index as u32 };\n-        debug!(\"new_var: diverging={:?} index={:?}\", diverging, v);\n-        v\n+        assert_eq!(eq_key.vid.index, index as u32);\n+\n+        debug!(\"new_var(index={:?}, diverging={:?}, origin={:?}\", eq_key.vid, diverging, origin);\n+\n+        eq_key.vid\n     }\n \n+    /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n         self.values.len()\n     }\n@@ -202,7 +228,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n     /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.eq_relations.find(vid)\n+        self.eq_relations.find(vid).vid\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `sub_relations`\n@@ -222,45 +248,43 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_root_var(a) == self.sub_root_var(b)\n     }\n \n-    pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        let vid = self.root_var(vid);\n-        self.probe_root(vid)\n-    }\n-\n-    pub fn origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {\n-        self.values.get(vid.index as usize).origin.clone()\n-    }\n-\n-    /// Retrieves the type of `vid` given that it is currently a root in the unification table\n-    pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        debug_assert!(self.root_var(vid) == vid);\n-        match self.values.get(vid.index as usize).value {\n-            Bounded { .. } => None,\n-            Known(t) => Some(t)\n-        }\n+    /// Retrieves the type to which `vid` has been instantiated, if\n+    /// any.\n+    pub fn probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n+        self.eq_relations.probe_value(vid)\n     }\n \n+    /// If `t` is a type-inference variable, and it has been\n+    /// instantiated, then return the with which it was\n+    /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n-                    None => t,\n-                    Some(u) => u\n+                    TypeVariableValue::Unknown { .. } => t,\n+                    TypeVariableValue::Known { value } => value,\n                 }\n             }\n             _ => t,\n         }\n     }\n \n-    pub fn snapshot(&mut self) -> Snapshot {\n+    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// must later be committed (`commit()`) or rolled back\n+    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// be processed in a stack-like fashion.\n+    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n             snapshot: self.values.start_snapshot(),\n             eq_snapshot: self.eq_relations.snapshot(),\n             sub_snapshot: self.sub_relations.snapshot(),\n         }\n     }\n \n-    pub fn rollback_to(&mut self, s: Snapshot) {\n+    /// Undoes all changes since the snapshot was created. Any\n+    /// snapshots created since that point must already have been\n+    /// committed or rolled back.\n+    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n         debug!(\"rollback_to{:?}\", {\n             for action in self.values.actions_since_snapshot(&s.snapshot) {\n                 match *action {\n@@ -278,7 +302,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.rollback_to(sub_snapshot);\n     }\n \n-    pub fn commit(&mut self, s: Snapshot) {\n+    /// Commits all changes since the snapshot was created, making\n+    /// them permanent (unless this snapshot was created within\n+    /// another snapshot). Any snapshots created since that point\n+    /// must already have been committed or rolled back.\n+    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n         let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n         self.values.commit(snapshot);\n         self.eq_relations.commit(eq_snapshot);\n@@ -289,7 +317,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// ty-variables created during the snapshot, and the values\n     /// `{V2}` are the root variables that they were unified with,\n     /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, s: &Snapshot) -> TypeVariableMap {\n+    pub fn types_created_since_snapshot(&mut self, s: &Snapshot<'tcx>) -> TypeVariableMap {\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n \n         actions_since_snapshot\n@@ -305,16 +333,13 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n \n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n-        /*!\n-         * Find the set of type variables that existed *before* `s`\n-         * but which have only been unified since `s` started, and\n-         * return the types with which they were unified. So if we had\n-         * a type variable `V0`, then we started the snapshot, then we\n-         * created a type variable `V1`, unifed `V0` with `T0`, and\n-         * unified `V1` with `T1`, this function would return `{T0}`.\n-         */\n-\n+    /// Find the set of type variables that existed *before* `s`\n+    /// but which have only been unified since `s` started, and\n+    /// return the types with which they were unified. So if we had\n+    /// a type variable `V0`, then we started the snapshot, then we\n+    /// created a type variable `V1`, unifed `V0` with `T0`, and\n+    /// unified `V1` with `T1`, this function would return `{T0}`.\n+    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n         let mut new_elem_threshold = u32::MAX;\n         let mut escaping_types = Vec::new();\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n@@ -327,17 +352,17 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     // always be the first one we see). Note that this\n                     // action must precede those variables being\n                     // specified.\n-                    new_elem_threshold = min(new_elem_threshold, index as u32);\n+                    new_elem_threshold = cmp::min(new_elem_threshold, index as u32);\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n                 sv::UndoLog::Other(Instantiate { vid, .. }) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n-                        let escaping_type = match self.values.get(vid.index as usize).value {\n-                            Bounded { .. } => bug!(),\n-                            Known(ty) => ty,\n+                        let escaping_type = match self.eq_relations.probe_value(vid) {\n+                            TypeVariableValue::Unknown { .. } => bug!(),\n+                            TypeVariableValue::Known { value } => value,\n                         };\n                         escaping_types.push(escaping_type);\n                     }\n@@ -351,28 +376,99 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         escaping_types\n     }\n \n+    /// Returns indices of all variables that are not yet\n+    /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n         (0..self.values.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n-                if self.probe(vid).is_some() {\n-                    None\n-                } else {\n-                    Some(vid)\n+                match self.probe(vid) {\n+                    TypeVariableValue::Unknown { .. } => Some(vid),\n+                    TypeVariableValue::Known { .. } => None,\n                 }\n             })\n             .collect()\n     }\n }\n \n-impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n-    type Value = TypeVariableData<'tcx>;\n-    type Undo = Instantiate<'tcx>;\n+impl sv::SnapshotVecDelegate for Delegate {\n+    type Value = TypeVariableData;\n+    type Undo = Instantiate;\n+\n+    fn reverse(_values: &mut Vec<TypeVariableData>, _action: Instantiate) {\n+        // We don't actually have to *do* anything to reverse an\n+        // instanation; the value for a variable is stored in the\n+        // `eq_relations` and hence its rollback code will handle\n+        // it. In fact, we could *almost* just remove the\n+        // `SnapshotVec` entirely, except that we would have to\n+        // reproduce *some* of its logic, since we want to know which\n+        // type variables have been instantiated since the snapshot\n+        // was started, so we can implement `types_escaping_snapshot`.\n+        //\n+        // (If we extended the `UnificationTable` to let us see which\n+        // values have been unified and so forth, that might also\n+        // suffice.)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// These structs (a newtyped TyVid) are used as the unification key\n+/// for the `eq_relations`; they carry a `TypeVariableValue` along\n+/// with them.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct TyVidEqKey<'tcx> {\n+    vid: ty::TyVid,\n+\n+    // in the table, we map each ty-vid to one of these:\n+    phantom: PhantomData<TypeVariableValue<'tcx>>,\n+}\n+\n+impl<'tcx> From<ty::TyVid> for TyVidEqKey<'tcx> {\n+    fn from(vid: ty::TyVid) -> Self {\n+        TyVidEqKey { vid, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'tcx> ut::UnifyKey for TyVidEqKey<'tcx> {\n+    type Value = TypeVariableValue<'tcx>;\n+    fn index(&self) -> u32 { self.vid.index }\n+    fn from_index(i: u32) -> Self { TyVidEqKey::from(ty::TyVid { index: i }) }\n+    fn tag() -> &'static str { \"TyVidEqKey\" }\n+}\n+\n+impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n+    type Error = ut::NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {\n+        match (value1, value2) {\n+            // We never equate two type variables, both of which\n+            // have known types.  Instead, we recursively equate\n+            // those types.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {\n+                bug!(\"equating two type variables, both of which have known types\")\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n+            (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: Instantiate<'tcx>) {\n-        let Instantiate { vid, default } = action;\n-        values[vid.index as usize].value = Bounded {\n-            default,\n-        };\n+            // If both sides are unknown, we need to pick the most restrictive universe.\n+            (&TypeVariableValue::Unknown { universe: universe1 },\n+             &TypeVariableValue::Unknown { universe: universe2 }) => {\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(TypeVariableValue::Unknown { universe })\n+            }\n+        }\n     }\n }\n+\n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n+impl ut::UnifyKey for ty::TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n+    fn tag() -> &'static str { \"TyVid\" }\n+}\n+"}, {"sha": "a1145572b79d95d9a80460cb22ac0821d1c40669", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n-use ty::{self, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::{Combine, UnifyKey};\n+use ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n+use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n \n pub trait ToType {\n     fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n@@ -20,7 +19,10 @@ impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n-    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n+    fn tag() -> &'static str { \"IntVid\" }\n+}\n+\n+impl EqUnifyValue for IntVarValue {\n }\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n@@ -31,23 +33,25 @@ pub struct RegionVidKey {\n     pub min_vid: ty::RegionVid\n }\n \n-impl Combine for RegionVidKey {\n-    fn combine(&self, other: &RegionVidKey) -> RegionVidKey {\n-        let min_vid = if self.min_vid.index() < other.min_vid.index() {\n-            self.min_vid\n+impl UnifyValue for RegionVidKey {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        let min_vid = if value1.min_vid.index() < value2.min_vid.index() {\n+            value1.min_vid\n         } else {\n-            other.min_vid\n+            value2.min_vid\n         };\n \n-        RegionVidKey { min_vid: min_vid }\n+        Ok(RegionVidKey { min_vid: min_vid })\n     }\n }\n \n impl UnifyKey for ty::RegionVid {\n     type Value = RegionVidKey;\n     fn index(&self) -> u32 { self.0 }\n     fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid(i) }\n-    fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n+    fn tag() -> &'static str { \"RegionVid\" }\n }\n \n impl ToType for IntVarValue {\n@@ -62,21 +66,17 @@ impl ToType for IntVarValue {\n // Floating point type keys\n \n impl UnifyKey for ty::FloatVid {\n-    type Value = Option<ast::FloatTy>;\n+    type Value = Option<FloatVarValue>;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n+    fn tag() -> &'static str { \"FloatVid\" }\n }\n \n-impl ToType for ast::FloatTy {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.mk_mach_float(*self)\n-    }\n+impl EqUnifyValue for FloatVarValue {\n }\n \n-impl UnifyKey for ty::TyVid {\n-    type Value = ();\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n-    fn tag(_: Option<ty::TyVid>) -> &'static str { \"TyVid\" }\n+impl ToType for FloatVarValue {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.mk_mach_float(self.0)\n+    }\n }"}, {"sha": "77259f156e5e24ff37dd636365849030c56162c8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -28,8 +28,9 @@\n //!   this code handles low-level equality and subtyping operations. The\n //!   type check pass in the compiler is found in the `librustc_typeck` crate.\n //!\n-//! For a deeper explanation of how the compiler works and is\n-//! organized, see the README.md file in this directory.\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/\n //!\n //! # Note\n //!\n@@ -48,18 +49,20 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(dyn_trait)]\n+#![feature(entry_or_default)]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n #![feature(i128)]\n #![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(inclusive_range_syntax)]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![cfg_attr(windows, feature(libc))]\n-#![feature(macro_vis_matcher)]\n #![feature(match_default_bindings)]\n-#![feature(never_type)]\n+#![feature(macro_lifetime_matcher)]\n+#![feature(macro_vis_matcher)]\n+#![feature(exhaustive_patterns)]\n #![feature(non_exhaustive)]\n #![feature(nonzero)]\n+#![feature(proc_macro_internals)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n@@ -69,8 +72,10 @@\n #![feature(underscore_lifetimes)]\n #![feature(universal_impl_trait)]\n #![feature(trace_macros)]\n+#![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n+#![feature(inclusive_range_fields)]\n \n #![recursion_limit=\"512\"]\n \n@@ -80,6 +85,7 @@ extern crate core;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n+#[macro_use] extern crate lazy_static;\n #[cfg(windows)]\n extern crate libc;\n extern crate rustc_back;\n@@ -91,6 +97,7 @@ extern crate rustc_errors as errors;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n extern crate jobserver;\n+extern crate proc_macro;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n@@ -179,5 +186,4 @@ fn noop() {\n \n \n // Build the diagnostics array at the end so that the metadata includes error use sites.\n-#[cfg(not(stage0))] // remove after the next snapshot\n __build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "b4ed9c269bd88334535b2b443c68b6206932f8cb", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -14,7 +14,16 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n+use errors::DiagnosticBuilder;\n use lint::{LintPass, LateLintPass, LintArray};\n+use session::Session;\n+use syntax::codemap::Span;\n+\n+declare_lint! {\n+    pub EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n \n declare_lint! {\n     pub CONST_ERR,\n@@ -142,13 +151,6 @@ declare_lint! {\n     \"lints that have been renamed or removed\"\n }\n \n-declare_lint! {\n-    pub RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n-    Deny,\n-    \"attempt to resolve a trait on an expression whose type cannot be inferred but which \\\n-     currently defaults to ()\"\n-}\n-\n declare_lint! {\n     pub SAFE_EXTERN_STATICS,\n     Deny,\n@@ -228,12 +230,6 @@ declare_lint! {\n     \"detect mut variables which don't need to be mutable\"\n }\n \n-declare_lint! {\n-    pub COERCE_NEVER,\n-    Deny,\n-    \"detect coercion to !\"\n-}\n-\n declare_lint! {\n     pub SINGLE_USE_LIFETIME,\n     Allow,\n@@ -252,6 +248,18 @@ declare_lint! {\n     \"hidden lifetime parameters are deprecated, try `Foo<'_>`\"\n }\n \n+declare_lint! {\n+    pub BARE_TRAIT_OBJECT,\n+    Allow,\n+    \"suggest using `dyn Trait` for trait objects\"\n+}\n+\n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+    Warn,\n+    \"floating-point literals cannot be used in patterns\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -260,6 +268,8 @@ pub struct HardwiredLints;\n impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n+            ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+            EXCEEDING_BITSHIFTS,\n             UNUSED_IMPORTS,\n             UNUSED_EXTERN_CRATES,\n             UNUSED_QUALIFICATIONS,\n@@ -281,7 +291,6 @@ impl LintPass for HardwiredLints {\n             INVALID_TYPE_PARAM_DEFAULT,\n             CONST_ERR,\n             RENAMED_AND_REMOVED_LINTS,\n-            RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n             SAFE_EXTERN_STATICS,\n             SAFE_PACKED_BORROWS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -295,13 +304,36 @@ impl LintPass for HardwiredLints {\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,\n-            COERCE_NEVER,\n             SINGLE_USE_LIFETIME,\n             TYVAR_BEHIND_RAW_POINTER,\n-            ELIDED_LIFETIME_IN_PATH\n-\n+            ELIDED_LIFETIME_IN_PATH,\n+            BARE_TRAIT_OBJECT\n         )\n     }\n }\n \n+// this could be a closure, but then implementing derive traits\n+// becomes hacky (and it gets allocated)\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+pub enum BuiltinLintDiagnostics {\n+    Normal,\n+    BareTraitObject(Span, /* is_global */ bool)\n+}\n+\n+impl BuiltinLintDiagnostics {\n+    pub fn run(self, sess: &Session, db: &mut DiagnosticBuilder) {\n+        match self {\n+            BuiltinLintDiagnostics::Normal => (),\n+            BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n+                let sugg = match sess.codemap().span_to_snippet(span) {\n+                    Ok(ref s) if is_global => format!(\"dyn ({})\", s),\n+                    Ok(s) => format!(\"dyn {}\", s),\n+                    Err(_) => format!(\"dyn <type>\")\n+                };\n+                db.span_suggestion(span, \"use `dyn`\", sugg);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HardwiredLints {}"}, {"sha": "4fa6594df169cd4af5f33efb3b9172410b6e7cba", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -29,18 +29,19 @@ use self::TargetLint::*;\n use std::slice;\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Level, Lint, LintId, LintPass, LintBuffer};\n+use lint::builtin::BuiltinLintDiagnostics;\n use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use session::{config, early_error, Session};\n-use traits::Reveal;\n use ty::{self, TyCtxt, Ty};\n use ty::layout::{LayoutError, LayoutOf, TyLayout};\n use util::nodemap::FxHashMap;\n \n use std::default::Default as StdDefault;\n use std::cell::{Ref, RefCell};\n use syntax::ast;\n+use syntax::epoch;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n use hir;\n@@ -92,14 +93,19 @@ pub struct BufferedEarlyLint {\n     pub ast_id: ast::NodeId,\n     pub span: MultiSpan,\n     pub msg: String,\n+    pub diagnostic: BuiltinLintDiagnostics,\n }\n \n /// Extra information for a future incompatibility lint. See the call\n /// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n /// guidelines.\n pub struct FutureIncompatibleInfo {\n     pub id: LintId,\n-    pub reference: &'static str // e.g., a URL for an issue/PR/RFC or error code\n+    /// e.g., a URL for an issue/PR/RFC or error code\n+    pub reference: &'static str,\n+    /// If this is an epoch fixing lint, the epoch in which\n+    /// this lint becomes obsolete\n+    pub epoch: Option<epoch::Epoch>,\n }\n \n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n@@ -194,11 +200,24 @@ impl LintStore {\n     pub fn register_future_incompatible(&mut self,\n                                         sess: Option<&Session>,\n                                         lints: Vec<FutureIncompatibleInfo>) {\n-        let ids = lints.iter().map(|f| f.id).collect();\n-        self.register_group(sess, false, \"future_incompatible\", ids);\n-        for info in lints {\n-            self.future_incompatible.insert(info.id, info);\n+\n+        for epoch in epoch::ALL_EPOCHS {\n+            let lints = lints.iter().filter(|f| f.epoch == Some(*epoch)).map(|f| f.id)\n+                             .collect::<Vec<_>>();\n+            if !lints.is_empty() {\n+                self.register_group(sess, false, epoch.lint_name(), lints)\n+            }\n         }\n+\n+        let mut future_incompatible = vec![];\n+        for lint in lints {\n+            future_incompatible.push(lint.id);\n+            self.future_incompatible.insert(lint.id, lint);\n+        }\n+\n+        self.register_group(sess, false, \"future_incompatible\", future_incompatible);\n+\n+\n     }\n \n     pub fn future_incompatible(&self, id: LintId) -> Option<&FutureIncompatibleInfo> {\n@@ -429,6 +448,16 @@ pub trait LintContext<'tcx>: Sized {\n         self.lookup(lint, span, msg).emit();\n     }\n \n+    fn lookup_and_emit_with_diagnostics<S: Into<MultiSpan>>(&self,\n+                                                            lint: &'static Lint,\n+                                                            span: Option<S>,\n+                                                            msg: &str,\n+                                                            diagnostic: BuiltinLintDiagnostics) {\n+        let mut db = self.lookup(lint, span, msg);\n+        diagnostic.run(self.sess(), &mut db);\n+        db.emit();\n+    }\n+\n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n@@ -499,9 +528,10 @@ impl<'a> EarlyContext<'a> {\n \n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.buffered.take(id) {\n-            self.lookup_and_emit(early_lint.lint_id.lint,\n-                                 Some(early_lint.span.clone()),\n-                                 &early_lint.msg);\n+            self.lookup_and_emit_with_diagnostics(early_lint.lint_id.lint,\n+                                                  Some(early_lint.span.clone()),\n+                                                  &early_lint.msg,\n+                                                  early_lint.diagnostic);\n         }\n     }\n }\n@@ -793,6 +823,17 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_generics(self, g);\n     }\n \n+    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n+        run_lints!(self, check_where_predicate, late_passes, p);\n+        hir_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef,\n+                            m: hir::TraitBoundModifier) {\n+        run_lints!(self, check_poly_trait_ref, late_passes, t, m);\n+        hir_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         let generics = self.generics.take();\n         self.generics = Some(&trait_item.generics);\n@@ -955,6 +996,16 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         ast_visit::walk_generics(self, g);\n     }\n \n+    fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n+        run_lints!(self, check_where_predicate, early_passes, p);\n+        ast_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n+        run_lints!(self, check_poly_trait_ref, early_passes, t, m);\n+        ast_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n     fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n         self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n@@ -1003,7 +1054,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut cx = LateContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+        param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),\n         last_ast_node_with_lint_attrs: ast::CRATE_NODE_ID,\n@@ -1054,7 +1105,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     if !sess.opts.actually_rustdoc {\n         for (_id, lints) in cx.buffered.map {\n             for early_lint in lints {\n-                span_bug!(early_lint.span, \"failed to process buffered lint here\");\n+                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n             }\n         }\n     }"}, {"sha": "8a899a35ecb547a7e27e5fc59549a6df067a17f3", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -89,14 +89,15 @@ impl LintLevelSets {\n     fn get_lint_level(&self,\n                       lint: &'static Lint,\n                       idx: u32,\n-                      aux: Option<&FxHashMap<LintId, (Level, LintSource)>>)\n+                      aux: Option<&FxHashMap<LintId, (Level, LintSource)>>,\n+                      sess: &Session)\n         -> (Level, LintSource)\n     {\n         let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n \n         // If `level` is none then we actually assume the default level for this\n         // lint.\n-        let mut level = level.unwrap_or(lint.default_level);\n+        let mut level = level.unwrap_or(lint.default_level(sess));\n \n         // If we're about to issue a warning, check at the last minute for any\n         // directives against the warnings \"lint\". If, for example, there's an\n@@ -235,7 +236,8 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                         let (level, src) = self.sets.get_lint_level(lint,\n                                                                     self.cur,\n-                                                                    Some(&specs));\n+                                                                    Some(&specs),\n+                                                                    &sess);\n                         lint::struct_lint_level(self.sess,\n                                                 lint,\n                                                 level,\n@@ -248,7 +250,8 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) = self.sets.get_lint_level(lint,\n                                                                     self.cur,\n-                                                                    Some(&specs));\n+                                                                    Some(&specs),\n+                                                                    self.sess);\n                         let msg = format!(\"unknown lint: `{}`\", name);\n                         let mut db = lint::struct_lint_level(self.sess,\n                                                 lint,\n@@ -342,7 +345,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                        msg: &str)\n         -> DiagnosticBuilder<'a>\n     {\n-        let (level, src) = self.sets.get_lint_level(lint, self.cur, None);\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n         lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n     }\n \n@@ -377,11 +380,11 @@ impl LintLevelMap {\n     /// If the `id` was not previously registered, returns `None`. If `None` is\n     /// returned then the parent of `id` should be acquired and this function\n     /// should be called again.\n-    pub fn level_and_source(&self, lint: &'static Lint, id: HirId)\n+    pub fn level_and_source(&self, lint: &'static Lint, id: HirId, session: &Session)\n         -> Option<(Level, LintSource)>\n     {\n         self.id_to_set.get(&id).map(|idx| {\n-            self.sets.get_lint_level(lint, *idx, None)\n+            self.sets.get_lint_level(lint, *idx, None, session)\n         })\n     }\n \n@@ -391,10 +394,10 @@ impl LintLevelMap {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let LintLevelMap {\n             ref sets,"}, {"sha": "7c103dc2721091b31e2472f1ec0f0f12ce963605", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388", "patch": "@@ -31,16 +31,18 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n-use std::rc::Rc;\n+use rustc_data_structures::sync::Lrc;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, FnKind};\n use hir;\n+use lint::builtin::BuiltinLintDiagnostics;\n use session::{Session, DiagnosticMessageId};\n use std::hash;\n use syntax::ast;\n use syntax::codemap::MultiSpan;\n+use syntax::epoch::Epoch;\n use syntax::symbol::Symbol;\n use syntax::visit as ast_visit;\n use syntax_pos::Span;\n@@ -74,25 +76,46 @@ pub struct Lint {\n     ///\n     /// e.g. \"imports that are never used\"\n     pub desc: &'static str,\n+\n+    /// Deny lint after this epoch\n+    pub epoch_deny: Option<Epoch>,\n }\n \n impl Lint {\n     /// Get the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n     }\n+\n+    pub fn default_level(&self, session: &Session) -> Level {\n+        if let Some(epoch_deny) = self.epoch_deny {\n+            if session.epoch() >= epoch_deny {\n+                return Level::Deny\n+            }\n+        }\n+        self.default_level\n+    }\n }\n \n /// Declare a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n+    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $epoch: expr) => (\n+        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+            name: stringify!($NAME),\n+            default_level: $crate::lint::$Level,\n+            desc: $desc,\n+            epoch_deny: Some($epoch)\n+        };\n+    );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n-            desc: $desc\n+            desc: $desc,\n+            epoch_deny: None,\n         };\n-    )\n+    );\n }\n \n /// Declare a static `LintArray` and return it as an expression.\n@@ -158,6 +181,9 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n     fn check_ty(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Ty) { }\n     fn check_generic_param(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::GenericParam) { }\n     fn check_generics(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Generics) { }\n+    fn check_where_predicate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::WherePredicate) { }\n+    fn check_poly_trait_ref(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::PolyTraitRef,\n+                            _: hir::TraitBoundModifier) { }\n     fn check_fn(&mut self,\n                 _: &LateContext<'a, 'tcx>,\n                 _: FnKind<'tcx>,\n@@ -230,6 +256,9 @@ pub trait EarlyLintPass: LintPass {\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }\n     fn check_generic_param(&mut self, _: &EarlyContext, _: &ast::GenericParam) { }\n     fn check_generics(&mut self, _: &EarlyContext, _: &ast::Generics) { }\n+    fn check_where_predicate(&mut self, _: &EarlyContext, _: &ast::WherePredicate) { }\n+    fn check_poly_trait_ref(&mut self, _: &EarlyContext, _: &ast::PolyTraitRef,\n+                            _: &ast::TraitBoundModifier) { }\n     fn check_fn(&mut self, _: &EarlyContext,\n         _: ast_visit::FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n     fn check_fn_post(&mut self, _: &EarlyContext,\n@@ -258,8 +287,8 @@ pub trait EarlyLintPass: LintPass {\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n-pub type LateLintPassObject = Box<for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n+pub type EarlyLintPassObject = Box<dyn EarlyLintPass + 'static>;\n+pub type LateLintPassObject = Box<dyn for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]\n@@ -304,7 +333,7 @@ impl LintId {\n /// Setting for how to handle a lint.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n pub enum Level {\n-    Allow, Warn, Deny, Forbid\n+    Allow, Warn, Deny, Forbid,\n }\n \n impl_stable_hash_for!(enum self::Level {\n@@ -378,12 +407,14 @@ impl LintBuffer {\n                     lint: &'static Lint,\n                     id: ast::NodeId,\n                     sp: MultiSpan,\n-                    msg: &str) {\n+                    msg: &str,\n+                    diagnostic: BuiltinLintDiagnostics) {\n         let early_lint = BufferedEarlyLint {\n             lint_id: LintId::of(lint),\n             ast_id: id,\n             span: sp,\n             msg: msg.to_string(),\n+            diagnostic\n         };\n         let arr = self.map.entry(id).or_insert(Vec::new());\n         if !arr.contains(&early_lint) {\n@@ -468,9 +499,14 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     // Check for future incompatibility lints and issue a stronger warning.\n     let lints = sess.lint_store.borrow();\n     if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n+        let future = if let Some(epoch) = future_incompatible.epoch {\n+            format!(\"the {} epoch\", epoch)\n+        } else {\n+            \"a future release\".to_owned()\n+        };\n         let explanation = format!(\"this was previously accepted by the compiler \\\n                                    but is being phased out; \\\n-                                   it will become a hard error in a future release!\");\n+                                   it will become a hard error in {}!\", future);\n         let citation = format!(\"for more information, see {}\",\n                                future_incompatible.reference);\n         err.warn(&explanation);\n@@ -481,7 +517,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n }\n \n fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n-    -> Rc<LintLevelMap>\n+    -> Lrc<LintLevelMap>\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n@@ -494,7 +530,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n         intravisit::walk_crate(builder, krate);\n     });\n \n-    Rc::new(builder.levels.build_map())\n+    Lrc::new(builder.levels.build_map())\n }\n \n struct LintLevelMapBuilder<'a, 'tcx: 'a> {"}, {"sha": "7dc84b9ca29561bc2d754ea859d19f442edb36d4", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "6f5791ed5d71bc063c11a69b1b3a10e4525b3eef", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "8c3dfd0bce752e51463411de9b2618e98f9d48e8", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 57, "deletions": 85, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3c451d7ae46a1070cab54d0aa66594cc2d3de843", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "e7055827c491fd6eb74f8252e118c07cc566aac2", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "37d79f408f3f00a7ab1487869e690ce6a07672e1", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "b1418792490fcc3d40c832f62aec98ca9c050080", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "28524678e9916bcc8f3bc35e590da1d9d6cfc7b1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3b37031cf461452978a78fa6a4760262543b4514", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "d13b16dce89864f99ce699e5d1a842f213319dd1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "6bf0c5d1ba3e39478389c9fa1d60b95fec599f37", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "48a62c8c14d6969e00b20916ba05ecd55ee4c682", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "c73930553cdea679a69addc7499c105fe3e0218a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "0aa750aba066057b50db4eca855e2472a535362f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "16c33d6bd837da03f301396a7eb42a43b11d2ac9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "cac86be0fcb75c76a191cfb3a5223704ff868d37", "filename": "src/librustc/mir/README.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fmir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fmir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e"}, {"sha": "9b75c19a875ebc4ad83ac100ae5f1aa6a78afb92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "9e69990f22c0d0c20af457727493daf481e919be", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "04ffb9af29ed5fd0898d78b63c93efe641633f59", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "7289d74bfbb1bd653fa529cd7951ff7da8a11bb6", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "939710ffd2b86a53a7864b91241da4dfd41e84da", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 196, "deletions": 158, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "d01059a3e017185bfd2dd001410c066c1954d926", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "20902d9111019bd33c50ad11b927e7101e7317f2", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "650af8dc4d903fa41ab133d94ef5b40bad093ebc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "0d91074e946bda028c813aebb2804082c91569fe", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 704, "deletions": 606, "changes": 1310, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3f52ecfc0999b5980e8c28498d5faf93f4f0413e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 441, "deletions": 302, "changes": 743, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "fa7f5c08608bb6486aa3b0e9444c8eeca9b6a885", "filename": "src/librustc/traits/README.md", "status": "removed", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e"}, {"sha": "06926b1648df5ed67acb09754865599c3e64e088", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "7e5dc02798dff72ad6ca12d170cc092621aab5f0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 127, "deletions": 51, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "150a2ead9e96d61f338796e357b2537edcc6aaae", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a0ba88f7d559af588dc43214c3b381a1b849a780", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 106, "deletions": 36, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "52a0a897595b211013bf1f47fc71d694c2cb5186", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a9dc49157437967d198dc0e6bf3c44b8dadf4e61", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 145, "deletions": 125, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "017c4f5262e255f095616409124d6e6278489d10", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "f1f9256f825373bca5101446e98f9ca7318292aa", "filename": "src/librustc/traits/query/mod.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "70c5cf5f3902934794b497b16a3465d77d1a401f", "filename": "src/librustc/traits/query/normalize.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a9734e9c2986e0831dd4c1c404e038ea2fa88ae3", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "4db81cf1dec1d3827f9689f2366ee21cd2c56ce3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 135, "deletions": 158, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "5ea089abb8e86ac6be8e413515d73671ab23f737", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "f8b895177f381dfa74c02ca0341ceabcde309361", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "d6e6f0e98adc48afb18f4f61efdae5ac64dec78d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 150, "deletions": 211, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "cc8b74e0ee23a3fad3a90288ae5ff918c8dab0bd", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 56, "deletions": 96, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "8f7a24057472c1c2d65b48b4a52e13b366a393e6", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3fd956ecfb87dea7f60567b9cf192103b7b5c8e2", "filename": "src/librustc/ty/README.md", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e"}, {"sha": "f98bc953560988f2290b1443c2ef4318b1f39fed", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "fd3465f59ebf2c79661fc694f21dde7dff3f9072", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 232, "deletions": 96, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "eb3924186472c57d9364ca1b551db96f7026bf87", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "6533a7440ac384a86ec3614da8f79f59773c511d", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "086fc66c70f9d27e85bef68f93c77bade8f3231e", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "8071cd0c639da6b8a3dec899d13b7dd9853b94ab", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "325f8575fd0a792b922546a9277cc3d737fdb4c2", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "76f7a0b59a2a568352ee86726154598e2a21d76b", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "1f23b0a27e33de547d85402b0bf9301317978ce1", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3a3f10cb87db4c6d5d74b56423fecf919079ff5e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a3a0e26a843ac02f010c6b822efa7824c94e6c02", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "b8167ec918638be880a6bc0351e98c105208dd01", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "b6b7361bb2f72b2758851fc126a7b2d5b4466e9f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 113, "deletions": 61, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "e56d8f8e818dde032338542a3d15ad438f137e65", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 122, "deletions": 20, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "dd65d4b4190718ff5fbcfdf49bb1235bff36a1f7", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "8d38d7dbbbbff6e3594f0319a727f991197a06ea", "filename": "src/librustc/ty/maps/values.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "c915022351925f835a8afc49de54dd2b082425f7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 294, "deletions": 221, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "36eb3e3f94cfa0c529750b954c27d160bd310f8a", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "c9a69d5405c9a4e716ea0bcf159d777ff2cafa88", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 370, "deletions": 548, "changes": 918, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "ae053d7f4f58db96dbe39d02edb1d0b729268b69", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a301049fe1c4022da43636eba170082e99629a8b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 101, "deletions": 87, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "32f0d3384c4dcea44d47bb5cd3086369b851dfcd", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "91d460a96f785725eea068e89dce00f6bbbe1567", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 139, "deletions": 218, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "46c048e839b4b9e422942b387f1e2f3e8169f4aa", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "f05d56c9d8371657ccb05c6d1b76cd422f425b6c", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "96b77d351e24cb38da56c030d7ceb22e8ef4a17e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "2c3ee1ec285a9bd5d8f5b0cf80e6085ef5caa2db", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "02e704b6841856779af8b5c5696d04caa96eaf0a", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "4c5b1417a2f670865a8c535d01f2243c171ef018", "filename": "src/librustc_back/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FCargo.toml?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "9baee26770998a4ffe92f3bb53ad7d4a303134d9", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a5d0e5bf166dd8c507b5c3978ff7371c7d128de4", "filename": "src/librustc_back/target/aarch64_unknown_cloudabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_cloudabi.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "fa66a35abbf353a37104d9c01223b6d09e6b8b8d", "filename": "src/librustc_back/target/armv7_unknown_cloudabi_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_cloudabi_eabihf.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "88f2b59675186da00dc2a016675df3effadf314a", "filename": "src/librustc_back/target/armv7_unknown_linux_musleabihf.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "ab7df4ba1c543395b28c6b857c4a657997375685", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "bacada3f5ab02c6f666234a112340d1428b3710b", "filename": "src/librustc_back/target/emscripten_base.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d740083fc8981ee933dc48a6b3dcee21b82c993e/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs?ref=d740083fc8981ee933dc48a6b3dcee21b82c993e"}, {"sha": "a1ccb632cab79eadffda4a628c61bba37f003e37", "filename": "src/librustc_back/target/haiku_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "69c3b298caba0459e331fdc91016dc07636fd50a", "filename": "src/librustc_back/target/i686_unknown_cloudabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_cloudabi.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "3b13ef015006432fadc3f1d768d1d92351317f0c", "filename": "src/librustc_back/target/l4re_base.rs", "status": "modified", "additions": 16, "deletions": 56, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "cffd1daed99f28bc7a5a0adf560d052b98cda8b3", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "555855b8f815ddea8dc971a62fc2a54f60b60896", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "6bef2fe2ea717eb0cbb88452c17179d1de62bfed", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a5dbdd111835976abf0112af111da65a48dd7a08", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "f53eeb86a9c56f562b77e05e528382e335a9386d", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "d0f512ae47cd9d02392ad4358bbacdd9f1009fbc", "filename": "src/librustc_back/target/msp430_none_elf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "ffcc321749b5ad553f0e4025d3a057d521220d22", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnuspe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnuspe.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "2c78dbd206171a072f64c2ab3d30ef342dd7a8c9", "filename": "src/librustc_back/target/powerpc_unknown_netbsd.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_netbsd.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "a03e6937b2ca751d38dd513534941eb42ec76261", "filename": "src/librustc_back/target/sparc_unknown_linux_gnu.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsparc_unknown_linux_gnu.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "6a8f52f509310b0cf0a962be74c3f56b1dca7932", "filename": "src/librustc_back/target/thumb_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "13dee3a576869c0a45b9dcb1da338ecadcffaf5d", "filename": "src/librustc_back/target/wasm32_experimental_emscripten.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "2770e67e30a5bd9234d319a0be7c0a8467fb6098", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "1d84e13751740f82e58bb5874ac86abeefd46e0e", "filename": "src/librustc_back/target/wasm32_unknown_unknown.rs", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}, {"sha": "05b6247c9518f040fedda7f653c6346803473732", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dac20e017d321b9999b04fd6d3132c4a21a388/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=00dac20e017d321b9999b04fd6d3132c4a21a388"}]}