{"sha": "b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MGU0YzdiZDUxZTMxOTM1MDRkN2FjZjhjZmMzMjIwOTMzY2Q1ZWU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-05T11:15:18Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-05T11:15:18Z"}, "message": "hir naming, removed lookup, match full path", "tree": {"sha": "9c8b5c24a0a5da407f77599bf8124cfb5870b3a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8b5c24a0a5da407f77599bf8124cfb5870b3a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "html_url": "https://github.com/rust-lang/rust/commit/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd91110ec0ca4f823145a13033cfd45f74ce72c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd91110ec0ca4f823145a13033cfd45f74ce72c6", "html_url": "https://github.com/rust-lang/rust/commit/cd91110ec0ca4f823145a13033cfd45f74ce72c6"}], "stats": {"total": 53, "additions": 18, "deletions": 35}, "files": [{"sha": "0c32dc5efadfa272a54957f1506aed16a6725aa0", "filename": "src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "patch": "@@ -154,8 +154,8 @@ impl PartialOrd for Constant {\n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n         LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n-        LitBinary(ref blob) => ConstantBinary(blob.clone()),\n         LitByte(b) => ConstantByte(b),\n+        LitByteStr(ref s) => ConstantBinary(s.clone()),\n         LitChar(c) => ConstantChar(c),\n         LitInt(value, ty) => ConstantInt(value, ty),\n         LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),"}, {"sha": "d7a74aa8c8b61c9b44c20692a334394148da083f", "filename": "src/minmax.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b90e4c7bd51e3193504d7acf8cfc3220933cd5ee/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=b90e4c7bd51e3193504d7acf8cfc3220933cd5ee", "patch": "@@ -1,11 +1,10 @@\n use rustc::lint::{Context, LintPass, LintArray};\n use rustc_front::hir::*;\n-use syntax::codemap::Spanned;\n use syntax::ptr::P;\n use std::cmp::PartialOrd;\n use std::cmp::Ordering::*;\n \n-use consts::{Constant, constant};\n+use consts::{Constant, constant_simple};\n use utils::{match_path, span_lint};\n use self::MinMax::{Min, Max};\n \n@@ -22,8 +21,8 @@ impl LintPass for MinMaxPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n-            if let Some((inner_max, inner_c, _)) = min_max(cx, oe) {\n+        if let Some((outer_max, outer_c, oe)) = min_max(expr) {\n+            if let Some((inner_max, inner_c, _)) = min_max(oe) {\n                 if outer_max == inner_max { return; }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n                     (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n@@ -43,47 +42,31 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'e>(cx: &Context, expr: &'e Expr) ->\n-        Option<(MinMax, Constant, &'e Expr)> {\n-    match expr.node {\n-        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n-            let name = ident.name;\n-            if name == \"min\" {\n-                fetch_const(cx, args, Min)\n+fn min_max(expr: &Expr) -> Option<(MinMax, Constant, &Expr)> {\n+    if let ExprCall(ref path, ref args) = expr.node {\n+        if let ExprPath(None, ref path) = path.node {\n+            if match_path(path, &[\"std\", \"cmp\", \"min\"]) {\n+                fetch_const(args, Min)\n             } else {\n-                if name == \"max\" {\n-                    fetch_const(cx, args, Max)\n+                if match_path(path, &[\"std\", \"cmp\", \"max\"]) {\n+                    fetch_const(args, Max)\n                 } else {\n                     None\n                 }\n             }\n-        },\n-        ExprCall(ref path, ref args) => {\n-            if let &ExprPath(None, ref path) = &path.node {\n-                if match_path(path, &[\"min\"]) {\n-                    fetch_const(cx, args, Min)\n-                } else {\n-                    if match_path(path, &[\"max\"]) {\n-                        fetch_const(cx, args, Max)\n-                    } else {\n-                        None\n-                    }\n-                }\n-            } else { None }\n-         },\n-         _ => None,\n-     }\n+        } else { None }\n+    } else { None }\n  }\n \n-fn fetch_const<'e>(cx: &Context, args: &'e Vec<P<Expr>>, m: MinMax) ->\n-        Option<(MinMax, Constant, &'e Expr)> {\n+fn fetch_const(args: &[P<Expr>], m: MinMax) ->\n+        Option<(MinMax, Constant, &Expr)> {\n     if args.len() != 2 { return None }\n-    if let Some((c, _)) = constant(cx, &args[0]) {\n-        if let None = constant(cx, &args[1]) { // otherwise ignore\n+    if let Some(c) = constant_simple(&args[0]) {\n+        if let None = constant_simple(&args[1]) { // otherwise ignore\n             Some((m, c, &args[1]))\n         } else { None }\n     } else {\n-        if let Some((c, _)) = constant(cx, &args[1]) {\n+        if let Some(c) = constant_simple(&args[1]) {\n             Some((m, c, &args[0]))\n         } else { None }\n     }"}]}