{"sha": "4f9c14c256b08458c873290a5e34eb493156532e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOWMxNGMyNTZiMDg0NThjODczMjkwYTVlMzRlYjQ5MzE1NjUzMmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-05T14:26:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-07T14:10:22Z"}, "message": "deduplicate RangeMap elements in iter_mut\n\nThis cuts down execution time of the benchmark in the OP of https://github.com/solson/miri/issues/593 by another 25%, and it cuts max-RSS by 90% (!)", "tree": {"sha": "b9ec1ccd1469ecbe61f20691a79becaf20fef76a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ec1ccd1469ecbe61f20691a79becaf20fef76a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9c14c256b08458c873290a5e34eb493156532e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c14c256b08458c873290a5e34eb493156532e", "html_url": "https://github.com/rust-lang/rust/commit/4f9c14c256b08458c873290a5e34eb493156532e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9c14c256b08458c873290a5e34eb493156532e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f24d0354f95615731d49a993adf2ea2983b661c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f24d0354f95615731d49a993adf2ea2983b661c1", "html_url": "https://github.com/rust-lang/rust/commit/f24d0354f95615731d49a993adf2ea2983b661c1"}], "stats": {"total": 115, "additions": 67, "deletions": 48}, "files": [{"sha": "a8fd432282a102692dcc0e97e4d3faad193bb511", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c14c256b08458c873290a5e34eb493156532e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c14c256b08458c873290a5e34eb493156532e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4f9c14c256b08458c873290a5e34eb493156532e", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, range_contains)]\n \n #![allow(clippy::cast_lossless)]\n "}, {"sha": "d157cbf0549f2195a3e42437f7e02267154f89a0", "filename": "src/range_map.rs", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c14c256b08458c873290a5e34eb493156532e/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c14c256b08458c873290a5e34eb493156532e/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=4f9c14c256b08458c873290a5e34eb493156532e", "patch": "@@ -12,26 +12,16 @@ use std::num::NonZeroU64;\n \n use rustc::ty::layout::Size;\n \n-// Representation: offset-length-data tuples, sorted by offset.\n #[derive(Clone, Debug)]\n struct Elem<T> {\n-    offset: u64,\n-    len: NonZeroU64,\n+    range: ops::Range<u64>, // the range covered by this element, never empty\n     data: T,\n }\n-// Length is always > 0.\n #[derive(Clone, Debug)]\n pub struct RangeMap<T> {\n     v: Vec<Elem<T>>,\n }\n \n-impl<T> Elem<T> {\n-    #[inline(always)]\n-    fn contains(&self, offset: u64) -> bool {\n-        offset >= self.offset && offset < self.offset + self.len.get()\n-    }\n-}\n-\n impl<T> RangeMap<T> {\n     /// Create a new RangeMap for the given size, and with the given initial value used for\n     /// the entire range.\n@@ -41,8 +31,7 @@ impl<T> RangeMap<T> {\n         let mut map = RangeMap { v: Vec::new() };\n         if size > 0 {\n             map.v.push(Elem {\n-                offset: 0,\n-                len: NonZeroU64::new(size).unwrap(),\n+                range: 0..size,\n                 data: init\n             });\n         }\n@@ -57,11 +46,11 @@ impl<T> RangeMap<T> {\n         loop {\n             let candidate = left.checked_add(right).unwrap() / 2;\n             let elem = &self.v[candidate];\n-            if elem.offset > offset {\n+            if offset < elem.range.start {\n                 // we are too far right (offset is further left)\n                 debug_assert!(candidate < right); // we are making progress\n                 right = candidate;\n-            } else if offset >= elem.offset + elem.len.get() {\n+            } else if offset >= elem.range.end {\n                 // we are too far left (offset is further right)\n                 debug_assert!(candidate >= left); // we are making progress\n                 left = candidate+1;\n@@ -85,12 +74,12 @@ impl<T> RangeMap<T> {\n                 // yield the element that surrounds this position.\n                 &[]\n             } else {\n-                let first = self.find_offset(offset);\n-                &self.v[first..]\n+                let first_idx = self.find_offset(offset);\n+                &self.v[first_idx..]\n             };\n         let end = offset + len; // the first offset that is not included any more\n         slice.iter()\n-            .take_while(move |elem| elem.offset < end)\n+            .take_while(move |elem| elem.range.start < end)\n             .map(|elem| &elem.data)\n     }\n \n@@ -106,22 +95,19 @@ impl<T> RangeMap<T> {\n         T: Clone,\n     {\n         let elem = &mut self.v[index];\n-        let first_len = split_offset.checked_sub(elem.offset)\n-            .expect(\"The split_offset is before the element to be split\");\n-        assert!(first_len <= elem.len.get(),\n-            \"The split_offset is after the element to be split\");\n-        if first_len == 0 || first_len == elem.len.get() {\n+        if split_offset == elem.range.start || split_offset == elem.range.end {\n             // Nothing to do\n             return false;\n         }\n+        debug_assert!(elem.range.contains(&split_offset),\n+            \"The split_offset is not in the element to be split\");\n \n         // Now we really have to split.  Reduce length of first element.\n-        let second_len = elem.len.get() - first_len;\n-        elem.len = NonZeroU64::new(first_len).unwrap();\n+        let second_range = split_offset..elem.range.end;\n+        elem.range.end = split_offset;\n         // Copy the data, and insert 2nd element\n         let second = Elem {\n-            offset: split_offset,\n-            len: NonZeroU64::new(second_len).unwrap(),\n+            range: second_range,\n             data: elem.data.clone(),\n         };\n         self.v.insert(index+1, second);\n@@ -137,7 +123,7 @@ impl<T> RangeMap<T> {\n         len: Size,\n     ) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n-        T: Clone,\n+        T: Clone + PartialEq,\n     {\n         let offset = offset.bytes();\n         let len = len.bytes();\n@@ -149,33 +135,53 @@ impl<T> RangeMap<T> {\n                 &mut []\n             } else {\n                 // Make sure we got a clear beginning\n-                let mut first = self.find_offset(offset);\n-                if self.split_index(first, offset) {\n+                let mut first_idx = self.find_offset(offset);\n+                if self.split_index(first_idx, offset) {\n                     // The newly created 2nd element is ours\n-                    first += 1;\n+                    first_idx += 1;\n                 }\n-                let first = first; // no more mutation\n+                let first_idx = first_idx; // no more mutation\n                 // Find our end.  Linear scan, but that's okay because the iteration\n                 // is doing the same linear scan anyway -- no increase in complexity.\n-                let mut end = first; // the last element to be included\n+                // We combine this scan with a scan for duplicates that we can merge, to reduce\n+                // the number of elements.\n+                let mut equal_since_idx = first_idx;\n+                let mut end_idx = first_idx; // when the loop is done, this is the first excluded element.\n                 loop {\n-                    let elem = &self.v[end];\n-                    if elem.offset+elem.len.get() < offset+len {\n-                        // We need to scan further.\n-                        end += 1;\n-                        debug_assert!(end < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n-                    } else {\n-                        // `elem` is the last included element.  Stop search.\n+                    // Compute if `end` is the last element we need to look at.\n+                    let done = (self.v[end_idx].range.end >= offset+len);\n+                    // We definitely need to include `end`, so move the index.\n+                    end_idx += 1;\n+                    debug_assert!(done || end_idx < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n+                    // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n+                    if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n+                        // Everything in `equal_since..end` was equal.  Make them just one element covering\n+                        // the entire range.\n+                        let equal_elems = end_idx - equal_since_idx; // number of equal elements\n+                        if equal_elems > 1 {\n+                            // Adjust the range of the first element to cover all of them.\n+                            let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n+                            self.v[equal_since_idx].range.end = equal_until;\n+                            // Delete the rest of them.\n+                            self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n+                            // Adjust `end_idx` because we made the list shorter.\n+                            end_idx -= (equal_elems - 1);\n+                        }\n+                        // Go on scanning.\n+                        equal_since_idx = end_idx;\n+                    }\n+                    // Leave loop if this is the last element.\n+                    if done {\n                         break;\n                     }\n                 }\n-                let end = end; // no more mutation\n+                let end_idx = end_idx-1; // Move to last included instead of first excluded index.\n                 // We need to split the end as well.  Even if this performs a\n                 // split, we don't have to adjust our index as we only care about\n                 // the first part of the split.\n-                self.split_index(end, offset+len);\n+                self.split_index(end_idx, offset+len);\n                 // Now we yield the slice. `end` is inclusive.\n-                &mut self.v[first..=end]\n+                &mut self.v[first_idx..=end_idx]\n             };\n         slice.iter_mut().map(|elem| &mut elem.data)\n     }\n@@ -241,18 +247,31 @@ mod tests {\n             }\n         }\n         assert_eq!(map.v.len(), 6);\n-\n         assert_eq!(\n             to_vec(&map, 10, 10),\n             vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n+\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n         assert_eq!(map.v.len(), 6);\n-        assert_eq!(map.iter(Size::from_bytes(19), Size::from_bytes(1))\n-            .map(|&t| t).collect::<Vec<_>>(), vec![19]);\n+        assert_eq!(\n+            to_vec(&map, 10, 10),\n+            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n+        );\n+        // Should be seeing two blocks with 19\n+        assert_eq!(map.iter(Size::from_bytes(15), Size::from_bytes(2))\n+            .map(|&t| t).collect::<Vec<_>>(), vec![19, 19]);\n+\n+        // a NOP iter_mut should trigger merging\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) { }\n+        assert_eq!(map.v.len(), 5);\n+        assert_eq!(\n+            to_vec(&map, 10, 10),\n+            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n+        );\n     }\n }"}, {"sha": "1fc705c03bb5e30c06a5ea0537b0b6aa150f4e07", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9c14c256b08458c873290a5e34eb493156532e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9c14c256b08458c873290a5e34eb493156532e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4f9c14c256b08458c873290a5e34eb493156532e", "patch": "@@ -67,7 +67,7 @@ pub enum BorStackItem {\n }\n \n /// Extra per-location state\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n     borrows: Vec<BorStackItem>, // used as a stack; never empty\n     frozen_since: Option<Timestamp>, // virtual frozen \"item\" on top of the stack"}]}