{"sha": "e5f3fd625022c22f0f415e9c11ca84e1f2be5771", "node_id": "C_kwDOAAsO6NoAKGU1ZjNmZDYyNTAyMmMyMmYwZjQxNWU5YzExY2E4NGUxZjJiZTU3NzE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T00:10:21Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T10:46:59Z"}, "message": "Use a better return type for `inner_parse_loop`.\n\nBecause `inner_parse_loop` has only one way to not succeed, not three.", "tree": {"sha": "6d67329975cc53404653bffa5b5b56fda8a62b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d67329975cc53404653bffa5b5b56fda8a62b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f3fd625022c22f0f415e9c11ca84e1f2be5771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f3fd625022c22f0f415e9c11ca84e1f2be5771", "html_url": "https://github.com/rust-lang/rust/commit/e5f3fd625022c22f0f415e9c11ca84e1f2be5771", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f3fd625022c22f0f415e9c11ca84e1f2be5771/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "643ba50004996b474c073e58d70fdbc9f797a8bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/643ba50004996b474c073e58d70fdbc9f797a8bd", "html_url": "https://github.com/rust-lang/rust/commit/643ba50004996b474c073e58d70fdbc9f797a8bd"}], "stats": {"total": 60, "additions": 35, "deletions": 25}, "files": [{"sha": "69f293b241c77258f62167f14821eddc7c4a0f27", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e5f3fd625022c22f0f415e9c11ca84e1f2be5771/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f3fd625022c22f0f415e9c11ca84e1f2be5771/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=e5f3fd625022c22f0f415e9c11ca84e1f2be5771", "patch": "@@ -266,6 +266,12 @@ impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n     }\n }\n \n+enum EofItems<'root, 'tt> {\n+    None,\n+    One(MatcherPosHandle<'root, 'tt>),\n+    Multiple,\n+}\n+\n /// Represents the possible results of an attempted parse.\n crate enum ParseResult<T> {\n     /// Parsed successfully.\n@@ -449,10 +455,10 @@ fn inner_parse_loop<'root, 'tt>(\n     sess: &ParseSess,\n     cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n-    eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n+    eof_items: &mut EofItems<'root, 'tt>,\n     token: &Token,\n-) -> ParseResult<()> {\n+) -> Result<(), (rustc_span::Span, String)> {\n     // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n         // When unzipped trees end, remove them. This corresponds to backtracking out of a\n@@ -522,7 +528,10 @@ fn inner_parse_loop<'root, 'tt>(\n             } else {\n                 // If we are not in a repetition, then being at the end of a matcher means that we\n                 // have reached the potential end of the input.\n-                eof_items.push(item);\n+                *eof_items = match eof_items {\n+                    EofItems::None => EofItems::One(item),\n+                    EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n+                }\n             }\n         } else {\n             // We are in the middle of a matcher. Look at what token in the matcher we are trying\n@@ -567,7 +576,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        return Error(span, \"missing fragment specifier\".to_string());\n+                        return Err((span, \"missing fragment specifier\".to_string()));\n                     }\n                 }\n \n@@ -615,7 +624,7 @@ fn inner_parse_loop<'root, 'tt>(\n     }\n \n     // Yay a successful parse (so far)!\n-    Success(())\n+    Ok(())\n }\n \n /// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n@@ -638,12 +647,13 @@ pub(super) fn parse_tt(\n     let mut next_items = Vec::new();\n \n     loop {\n+        assert!(next_items.is_empty());\n+\n         // Matcher positions black-box parsed by parser.rs (`parser`)\n         let mut bb_items = SmallVec::new();\n \n         // Matcher positions that would be valid if the macro invocation was over now\n-        let mut eof_items = SmallVec::new();\n-        assert!(next_items.is_empty());\n+        let mut eof_items = EofItems::None;\n \n         // Process `cur_items` until either we have finished the input or we need to get some\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n@@ -652,34 +662,34 @@ pub(super) fn parse_tt(\n             parser.sess,\n             &mut cur_items,\n             &mut next_items,\n-            &mut eof_items,\n             &mut bb_items,\n+            &mut eof_items,\n             &parser.token,\n         ) {\n-            Success(_) => {}\n-            Failure(token, msg) => return Failure(token, msg),\n-            Error(sp, msg) => return Error(sp, msg),\n-            ErrorReported => return ErrorReported,\n+            Ok(()) => {}\n+            Err((sp, msg)) => return Error(sp, msg),\n         }\n \n         // inner parse loop handled all cur_items, so it's empty\n         assert!(cur_items.is_empty());\n \n-        // We need to do some post processing after the `inner_parser_loop`.\n+        // We need to do some post processing after the `inner_parse_loop`.\n         //\n         // Error messages here could be improved with links to original rules.\n \n         // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n         // either the parse is ambiguous (which should never happen) or there is a syntax error.\n         if parser.token == token::Eof {\n-            return if eof_items.len() == 1 {\n-                let matches =\n-                    eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                nameize(parser.sess, ms, matches)\n-            } else if eof_items.len() > 1 {\n-                Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n-            } else {\n-                Failure(\n+            return match eof_items {\n+                EofItems::One(mut eof_item) => {\n+                    let matches =\n+                        eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n+                    nameize(parser.sess, ms, matches)\n+                }\n+                EofItems::Multiple => {\n+                    Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n+                }\n+                EofItems::None => Failure(\n                     Token::new(\n                         token::Eof,\n                         if parser.token.span.is_dummy() {\n@@ -689,12 +699,12 @@ pub(super) fn parse_tt(\n                         },\n                     ),\n                     \"missing tokens in macro arguments\",\n-                )\n+                ),\n             };\n         }\n-        // Performance hack: eof_items may share matchers via Rc with other things that we want\n-        // to modify. Dropping eof_items now may drop these refcounts to 1, preventing an\n-        // unnecessary implicit clone later in Rc::make_mut.\n+        // Performance hack: `eof_items` may share matchers via `Rc` with other things that we want\n+        // to modify. Dropping `eof_items` now may drop these refcounts to 1, preventing an\n+        // unnecessary implicit clone later in `Rc::make_mut`.\n         drop(eof_items);\n \n         // If there are no possible next positions AND we aren't waiting for the black-box parser,"}]}