{"sha": "e08b3bf70bee5b091442d296e36769a67af7d6f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOGIzYmY3MGJlZTViMDkxNDQyZDI5NmUzNjc2OWE2N2FmN2Q2ZjE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-14T00:07:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-14T00:07:50Z"}, "message": "Merge #10231\n\n10231: feat: Make inlay hints work in attributed items r=Veykril a=Veykril\n\n![image](https://user-images.githubusercontent.com/3757771/133172697-8563329f-e77e-46e4-86ab-99b50040dfd5.png)\r\nNote the lack of chaining hints, this is currently due to macro expansion lacking the input whitespace. We might be able to recover this from the input somehow in the future.\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10043\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "369e8bfec023248b25f68774f746e813227bfd0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/369e8bfec023248b25f68774f746e813227bfd0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e08b3bf70bee5b091442d296e36769a67af7d6f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhP+fWCRBK7hj4Ov3rIwAAxNIIAJIXohl28HE8yFXi75MEsiZj\nieNZuo17dHudt7rE1AISUkIn+iqJSZGC1pwJhNNSPsG4Xwt5Dar4MMQu9zb3Mqvy\nC9KzLVA649n+XBB+VT/sygNvPT0/1NFPjbJAhOMmFJV2ics1YB53ymAIyVmrdN++\nLDU7xHJkdKEVn7f8rSbQ/qMAAYxaZ46BxmO0Fq4KkMHnlWHgzXkX1FhA596PaKRh\nvqL3fwWUiwuj4CD59cYEccB5h5oqAyGSXNYjmNnd0gMzjo38rNEm6c6d8Qm1JlBa\nfqLSrcR+geQXz818PS7/QGwF68SgC6vTciFI9NTVKKsodMRnhyfq1bn1yzriXtY=\n=BvW5\n-----END PGP SIGNATURE-----\n", "payload": "tree 369e8bfec023248b25f68774f746e813227bfd0f\nparent 42617231bd80ee1dbf1d574e357cd1a1235d427f\nparent e193e3b076b2b7108e5324736b8d7e28425c034a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631578070 +0000\ncommitter GitHub <noreply@github.com> 1631578070 +0000\n\nMerge #10231\n\n10231: feat: Make inlay hints work in attributed items r=Veykril a=Veykril\n\n![image](https://user-images.githubusercontent.com/3757771/133172697-8563329f-e77e-46e4-86ab-99b50040dfd5.png)\r\nNote the lack of chaining hints, this is currently due to macro expansion lacking the input whitespace. We might be able to recover this from the input somehow in the future.\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10043\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e08b3bf70bee5b091442d296e36769a67af7d6f1", "html_url": "https://github.com/rust-lang/rust/commit/e08b3bf70bee5b091442d296e36769a67af7d6f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e08b3bf70bee5b091442d296e36769a67af7d6f1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42617231bd80ee1dbf1d574e357cd1a1235d427f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42617231bd80ee1dbf1d574e357cd1a1235d427f", "html_url": "https://github.com/rust-lang/rust/commit/42617231bd80ee1dbf1d574e357cd1a1235d427f"}, {"sha": "e193e3b076b2b7108e5324736b8d7e28425c034a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e193e3b076b2b7108e5324736b8d7e28425c034a", "html_url": "https://github.com/rust-lang/rust/commit/e193e3b076b2b7108e5324736b8d7e28425c034a"}], "stats": {"total": 114, "additions": 98, "deletions": 16}, "files": [{"sha": "ed27f6122b4f3a251f7d10da385acac44f470d54", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e08b3bf70bee5b091442d296e36769a67af7d6f1/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08b3bf70bee5b091442d296e36769a67af7d6f1/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e08b3bf70bee5b091442d296e36769a67af7d6f1", "patch": "@@ -211,6 +211,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     ) -> impl Iterator<Item = SyntaxNode> + '_ {\n         token.parent().into_iter().flat_map(move |it| self.ancestors_with_macros(it))\n     }\n+\n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         self.imp.ancestors_with_macros(node)\n     }"}, {"sha": "cca3bb3fa8c8801688d9d8902c3d3c4cc29596a8", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 97, "deletions": 16, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e08b3bf70bee5b091442d296e36769a67af7d6f1/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08b3bf70bee5b091442d296e36769a67af7d6f1/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=e08b3bf70bee5b091442d296e36769a67af7d6f1", "patch": "@@ -64,17 +64,35 @@ pub(crate) fn inlay_hints(\n     let file = sema.parse(file_id);\n \n     let mut res = Vec::new();\n-    for node in file.syntax().descendants() {\n-        if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            get_chaining_hints(&mut res, &sema, config, expr);\n-        }\n+    let mut queue = vec![file.syntax().preorder()];\n \n-        match_ast! {\n-            match node {\n-                ast::CallExpr(it) => { get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it)); },\n-                ast::MethodCallExpr(it) => { get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it)); },\n-                ast::IdentPat(it) => { get_bind_pat_hints(&mut res, &sema, config, it); },\n-                _ => (),\n+    while let Some(mut preorder) = queue.pop() {\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                syntax::WalkEvent::Enter(node) => node,\n+                syntax::WalkEvent::Leave(_) => continue,\n+            };\n+            if let Some(node) =\n+                ast::Item::cast(node.clone()).and_then(|item| sema.expand_attr_macro(&item))\n+            {\n+                preorder.skip_subtree();\n+                queue.push(node.preorder());\n+                continue;\n+            }\n+\n+            if let Some(expr) = ast::Expr::cast(node.clone()) {\n+                get_chaining_hints(&mut res, &sema, config, &expr);\n+                match expr {\n+                    ast::Expr::CallExpr(it) => {\n+                        get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it));\n+                    }\n+                    ast::Expr::MethodCallExpr(it) => {\n+                        get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it));\n+                    }\n+                    _ => (),\n+                }\n+            } else if let Some(it) = ast::IdentPat::cast(node.clone()) {\n+                get_bind_pat_hints(&mut res, &sema, config, it);\n             }\n         }\n     }\n@@ -85,7 +103,7 @@ fn get_chaining_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<RootDatabase>,\n     config: &InlayHintsConfig,\n-    expr: ast::Expr,\n+    expr: &ast::Expr,\n ) -> Option<()> {\n     if !config.chaining_hints {\n         return None;\n@@ -117,7 +135,7 @@ fn get_chaining_hints(\n             next_next = tokens.next()?.kind();\n         }\n         if next_next == T![.] {\n-            let ty = sema.type_of_expr(&expr)?.original;\n+            let ty = sema.type_of_expr(expr)?.original;\n             if ty.is_unknown() {\n                 return None;\n             }\n@@ -129,7 +147,7 @@ fn get_chaining_hints(\n                 }\n             }\n             acc.push(InlayHint {\n-                range: expr.syntax().text_range(),\n+                range: sema.original_range(expr.syntax()).range,\n                 kind: InlayKind::ChainingHint,\n                 label: hint_iterator(sema, &famous_defs, config, &ty).unwrap_or_else(|| {\n                     ty.display_truncated(sema.db, config.max_length).to_string().into()\n@@ -167,7 +185,7 @@ fn get_param_name_hints(\n         })\n         .filter(|(param_name, arg)| !should_hide_param_name_hint(sema, &callable, param_name, arg))\n         .map(|(param_name, arg)| InlayHint {\n-            range: arg.syntax().text_range(),\n+            range: sema.original_range(arg.syntax()).range,\n             kind: InlayKind::ParameterHint,\n             label: param_name.into(),\n         });\n@@ -197,8 +215,8 @@ fn get_bind_pat_hints(\n \n     acc.push(InlayHint {\n         range: match pat.name() {\n-            Some(name) => name.syntax().text_range(),\n-            None => pat.syntax().text_range(),\n+            Some(name) => sema.original_range(name.syntax()).range,\n+            None => sema.original_range(pat.syntax()).range,\n         },\n         kind: InlayKind::TypeHint,\n         label: hint_iterator(sema, &famous_defs, config, &ty)\n@@ -1467,4 +1485,67 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hints_in_attr_call() {\n+        // chaining hints do not currently work as macros lose all whitespace information\n+        check_expect(\n+            TEST_CONFIG,\n+            r#\"\n+//- proc_macros: identity, input_replace\n+struct Struct;\n+impl Struct {\n+    fn chain(self) -> Self {\n+        self\n+    }\n+}\n+\n+#[proc_macros::identity]\n+fn main() {\n+    let strukt = Struct;\n+    strukt\n+        .chain()\n+        .chain()\n+        .chain();\n+    Struct::chain(strukt);\n+}\n+\n+#[proc_macros::input_replace(\n+    fn not_main() {\n+        let strukt = Struct;\n+        strukt\n+            .chain()\n+            .chain()\n+            .chain();\n+        Struct::chain(strukt);\n+    }\n+)]\n+fn main() {}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 297..303,\n+                        kind: TypeHint,\n+                        label: \"Struct\",\n+                    },\n+                    InlayHint {\n+                        range: 415..421,\n+                        kind: ParameterHint,\n+                        label: \"self\",\n+                    },\n+                    InlayHint {\n+                        range: 125..131,\n+                        kind: TypeHint,\n+                        label: \"Struct\",\n+                    },\n+                    InlayHint {\n+                        range: 223..229,\n+                        kind: ParameterHint,\n+                        label: \"self\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n }"}]}