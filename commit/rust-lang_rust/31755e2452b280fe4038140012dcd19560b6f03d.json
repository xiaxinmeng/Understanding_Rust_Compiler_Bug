{"sha": "31755e2452b280fe4038140012dcd19560b6f03d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNzU1ZTI0NTJiMjgwZmU0MDM4MTQwMDEyZGNkMTk1NjBiNmYwM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-07T19:14:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-08T07:03:11Z"}, "message": "rustc: Use CStore, not a separate crate cache\n\nThis separate crate cache is one factor which is causing libstd to be loaded\ntwice during normal compilation. The crates loaded for syntax extensions have a\nseparate cache than the crates loaded for linking, so all crates are loaded once\nper #[phase] they're tagged with.\n\nThis removes the cache and instead uses the CStore structure itself as the cache\nfor loaded crates. This should allow crates loaded during the syntax phase to be\nshared with the crates loaded during the link phase.", "tree": {"sha": "495fe532ee42e95610701b9d2597cb8e48a47635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495fe532ee42e95610701b9d2597cb8e48a47635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31755e2452b280fe4038140012dcd19560b6f03d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31755e2452b280fe4038140012dcd19560b6f03d", "html_url": "https://github.com/rust-lang/rust/commit/31755e2452b280fe4038140012dcd19560b6f03d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31755e2452b280fe4038140012dcd19560b6f03d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef37cfdeccbdf8151129d2d182a568d7310754c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef37cfdeccbdf8151129d2d182a568d7310754c1", "html_url": "https://github.com/rust-lang/rust/commit/ef37cfdeccbdf8151129d2d182a568d7310754c1"}], "stats": {"total": 131, "additions": 61, "deletions": 70}, "files": [{"sha": "9c0c73288eb0d007059d1ceaf6d4e69c9922cb33", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/31755e2452b280fe4038140012dcd19560b6f03d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31755e2452b280fe4038140012dcd19560b6f03d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=31755e2452b280fe4038140012dcd19560b6f03d", "patch": "@@ -18,6 +18,7 @@ use driver::{driver, session};\n use driver::session::Session;\n use metadata::csearch;\n use metadata::cstore;\n+use metadata::cstore::CStore;\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::Os;\n@@ -38,6 +39,13 @@ use syntax::parse::token;\n use syntax::crateid::CrateId;\n use syntax::visit;\n \n+struct Env<'a> {\n+    sess: &'a Session,\n+    os: loader::Os,\n+    next_crate_num: ast::CrateNum,\n+    intr: Rc<IdentInterner>\n+}\n+\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(sess: &Session,\n@@ -47,16 +55,13 @@ pub fn read_crates(sess: &Session,\n     let mut e = Env {\n         sess: sess,\n         os: os,\n-        crate_cache: @RefCell::new(Vec::new()),\n-        next_crate_num: 1,\n+        next_crate_num: sess.cstore.next_crate_num(),\n         intr: intr\n     };\n     visit_crate(&e, krate);\n     visit::walk_crate(&mut e, krate, ());\n-    dump_crates(e.crate_cache.borrow().as_slice());\n-    warn_if_multiple_versions(&mut e,\n-                              sess.diagnostic(),\n-                              e.crate_cache.borrow().as_slice());\n+    dump_crates(&sess.cstore);\n+    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore)\n }\n \n impl<'a> visit::Visitor<()> for Env<'a> {\n@@ -70,55 +75,36 @@ impl<'a> visit::Visitor<()> for Env<'a> {\n     }\n }\n \n-#[deriving(Clone)]\n-struct cache_entry {\n-    cnum: ast::CrateNum,\n-    span: Span,\n-    hash: Svh,\n-    crate_id: CrateId,\n-}\n-\n-fn dump_crates(crate_cache: &[cache_entry]) {\n+fn dump_crates(cstore: &CStore) {\n     debug!(\"resolved crates:\");\n-    for entry in crate_cache.iter() {\n-        debug!(\"cnum: {:?}\", entry.cnum);\n-        debug!(\"span: {:?}\", entry.span);\n-        debug!(\"hash: {:?}\", entry.hash);\n-    }\n+    cstore.iter_crate_data(|_, data| {\n+        debug!(\"crate_id: {}\", data.crate_id());\n+        debug!(\"  cnum: {}\", data.cnum);\n+        debug!(\"  hash: {}\", data.hash());\n+    })\n }\n \n-fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: &SpanHandler,\n-                             crate_cache: &[cache_entry]) {\n-    if crate_cache.len() != 0u {\n-        let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();\n-\n-        let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == entry.crate_id.name);\n+fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n+    let mut map = HashMap::new();\n \n-        assert!(!matches.is_empty());\n+    cstore.iter_crate_data(|cnum, data| {\n+        let crateid = data.crate_id();\n+        let key = (crateid.name.clone(), crateid.path.clone());\n+        map.find_or_insert_with(key, |_| Vec::new()).push(cnum);\n+    });\n \n-        if matches.len() != 1u {\n-            diag.handler().warn(\n-                format!(\"using multiple versions of crate `{}`\", name));\n-            for match_ in matches.iter() {\n-                diag.span_note(match_.span, \"used here\");\n-                loader::note_crateid_attr(diag, &match_.crate_id);\n-            }\n+    for ((name, _), dupes) in map.move_iter() {\n+        if dupes.len() == 1 { continue }\n+        diag.handler().warn(\n+            format!(\"using multiple versions of crate `{}`\", name));\n+        for dupe in dupes.move_iter() {\n+            let data = cstore.get_crate_data(dupe);\n+            diag.span_note(data.span, \"used here\");\n+            loader::note_crateid_attr(diag, &data.crate_id());\n         }\n-\n-        warn_if_multiple_versions(e, diag, non_matches);\n     }\n }\n \n-struct Env<'a> {\n-    sess: &'a Session,\n-    os: loader::Os,\n-    crate_cache: @RefCell<Vec<cache_entry>>,\n-    next_crate_num: ast::CrateNum,\n-    intr: Rc<IdentInterner>\n-}\n-\n fn visit_crate(e: &Env, c: &ast::Crate) {\n     for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n@@ -269,14 +255,18 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n fn existing_match(e: &Env, crate_id: &CrateId,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    for c in e.crate_cache.borrow().iter() {\n-        if !crate_id.matches(&c.crate_id) { continue }\n-        match hash {\n-            Some(hash) if *hash != c.hash => {}\n-            Some(..) | None => return Some(c.cnum)\n+    let mut ret = None;\n+    e.sess.cstore.iter_crate_data(|cnum, data| {\n+        let other_id = data.crate_id();\n+        if crate_id.matches(&other_id) {\n+            let other_hash = data.hash();\n+            match hash {\n+                Some(hash) if *hash != other_hash => {}\n+                Some(..) | None => { ret = Some(cnum); }\n+            }\n         }\n-    }\n-    None\n+    });\n+    return ret;\n }\n \n fn resolve_crate<'a>(e: &mut Env,\n@@ -304,17 +294,8 @@ fn resolve_crate<'a>(e: &mut Env,\n                 dylib, rlib, metadata\n             } = load_ctxt.load_library_crate(root);\n \n-            let crate_id = decoder::get_crate_id(metadata.as_slice());\n-            let hash = decoder::get_crate_hash(metadata.as_slice());\n-\n             // Claim this crate number and cache it\n             let cnum = e.next_crate_num;\n-            e.crate_cache.borrow_mut().push(cache_entry {\n-                cnum: cnum,\n-                span: span,\n-                hash: hash,\n-                crate_id: crate_id,\n-            });\n             e.next_crate_num += 1;\n \n             // Stash paths for top-most crate locally if necessary.\n@@ -331,16 +312,15 @@ fn resolve_crate<'a>(e: &mut Env,\n             let root = if root.is_some() { root } else { &crate_paths };\n \n             // Now resolve the crates referenced by this crate\n-            let cnum_map = resolve_crate_deps(e,\n-            root,\n-            metadata.as_slice(),\n-            span);\n+            let cnum_map = resolve_crate_deps(e, root, metadata.as_slice(),\n+                                              span);\n \n             let cmeta = @cstore::crate_metadata {\n                 name: load_ctxt.crate_id.name.to_owned(),\n                 data: metadata,\n                 cnum_map: cnum_map,\n-                cnum: cnum\n+                cnum: cnum,\n+                span: span,\n             };\n \n             e.sess.cstore.set_crate_data(cnum, cmeta);\n@@ -390,8 +370,7 @@ impl<'a> Loader<'a> {\n             env: Env {\n                 sess: sess,\n                 os: os,\n-                crate_cache: @RefCell::new(Vec::new()),\n-                next_crate_num: 1,\n+                next_crate_num: sess.cstore.next_crate_num(),\n                 intr: token::get_ident_interner(),\n             }\n         }\n@@ -406,7 +385,7 @@ impl<'a> CrateLoader for Loader<'a> {\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {\n             lib: library.dylib,\n-            cnum: cnum\n+            cnum: cnum,\n         }\n     }\n "}, {"sha": "2d46f92e88fa47939859c746c4aba9214effef25", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31755e2452b280fe4038140012dcd19560b6f03d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31755e2452b280fe4038140012dcd19560b6f03d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=31755e2452b280fe4038140012dcd19560b6f03d", "patch": "@@ -22,6 +22,8 @@ use std::c_vec::CVec;\n use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n+use syntax::crateid::CrateId;\n+use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n \n // A map from external crate numbers (as decoded from some crate file) to\n@@ -40,6 +42,7 @@ pub struct crate_metadata {\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n+    pub span: Span,\n }\n \n #[deriving(Eq)]\n@@ -88,6 +91,10 @@ impl CStore {\n         }\n     }\n \n+    pub fn next_crate_num(&self) -> ast::CrateNum {\n+        self.metas.borrow().len() as ast::CrateNum + 1\n+    }\n+\n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n         *self.metas.borrow().get(&cnum)\n     }\n@@ -121,6 +128,9 @@ impl CStore {\n             .map(|source| source.clone())\n     }\n \n+    pub fn dump_phase_syntax_crates(&self) {\n+    }\n+\n     pub fn reset(&self) {\n         self.metas.borrow_mut().clear();\n         self.extern_mod_crate_map.borrow_mut().clear();\n@@ -202,6 +212,8 @@ impl CStore {\n \n impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n+    pub fn crate_id(&self) -> CrateId { decoder::get_crate_id(self.data()) }\n+    pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n }\n \n impl MetadataBlob {"}]}