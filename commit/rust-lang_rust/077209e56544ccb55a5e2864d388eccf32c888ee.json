{"sha": "077209e56544ccb55a5e2864d388eccf32c888ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NzIwOWU1NjU0NGNjYjU1YTVlMjg2NGQzODhlY2NmMzJjODg4ZWU=", "commit": {"author": {"name": "Kitsu", "email": "mail@kitsu.me", "date": "2020-04-18T11:56:04Z"}, "committer": {"name": "Kitsu", "email": "mail@kitsu.me", "date": "2020-04-18T11:56:04Z"}, "message": "Support file hashes in .debug_line", "tree": {"sha": "a918298dd50bc2491589272299ce0c4821c9e6f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a918298dd50bc2491589272299ce0c4821c9e6f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/077209e56544ccb55a5e2864d388eccf32c888ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/077209e56544ccb55a5e2864d388eccf32c888ee", "html_url": "https://github.com/rust-lang/rust/commit/077209e56544ccb55a5e2864d388eccf32c888ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/077209e56544ccb55a5e2864d388eccf32c888ee/comments", "author": {"login": "l4l", "id": 5658339, "node_id": "MDQ6VXNlcjU2NTgzMzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5658339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/l4l", "html_url": "https://github.com/l4l", "followers_url": "https://api.github.com/users/l4l/followers", "following_url": "https://api.github.com/users/l4l/following{/other_user}", "gists_url": "https://api.github.com/users/l4l/gists{/gist_id}", "starred_url": "https://api.github.com/users/l4l/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/l4l/subscriptions", "organizations_url": "https://api.github.com/users/l4l/orgs", "repos_url": "https://api.github.com/users/l4l/repos", "events_url": "https://api.github.com/users/l4l/events{/privacy}", "received_events_url": "https://api.github.com/users/l4l/received_events", "type": "User", "site_admin": false}, "committer": {"login": "l4l", "id": 5658339, "node_id": "MDQ6VXNlcjU2NTgzMzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5658339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/l4l", "html_url": "https://github.com/l4l", "followers_url": "https://api.github.com/users/l4l/followers", "following_url": "https://api.github.com/users/l4l/following{/other_user}", "gists_url": "https://api.github.com/users/l4l/gists{/gist_id}", "starred_url": "https://api.github.com/users/l4l/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/l4l/subscriptions", "organizations_url": "https://api.github.com/users/l4l/orgs", "repos_url": "https://api.github.com/users/l4l/repos", "events_url": "https://api.github.com/users/l4l/events{/privacy}", "received_events_url": "https://api.github.com/users/l4l/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78f851ea40f0c03095368e6fae6e92a2d3062de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78f851ea40f0c03095368e6fae6e92a2d3062de", "html_url": "https://github.com/rust-lang/rust/commit/a78f851ea40f0c03095368e6fae6e92a2d3062de"}], "stats": {"total": 82, "additions": 66, "deletions": 16}, "files": [{"sha": "a507821647e1bda981c323cb729770bf71b0c97e", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/077209e56544ccb55a5e2864d388eccf32c888ee/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077209e56544ccb55a5e2864d388eccf32c888ee/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=077209e56544ccb55a5e2864d388eccf32c888ee", "patch": "@@ -1,14 +1,15 @@\n use std::ffi::OsStr;\n+use std::time::SystemTime;\n use std::path::{Component, Path};\n \n use crate::prelude::*;\n \n-use rustc_span::{FileName, SourceFileAndLine, Pos};\n+use rustc_span::{FileName, SourceFile, SourceFileAndLine, Pos, SourceFileHash, SourceFileHashAlgorithm};\n \n use cranelift_codegen::binemit::CodeOffset;\n \n use gimli::write::{\n-    Address, AttributeValue, FileId, LineProgram, LineString, LineStringTable, UnitEntryId,\n+    Address, AttributeValue, FileId, LineProgram, LineString, FileInfo, LineStringTable, UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -38,9 +39,9 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n fn line_program_add_file(\n     line_program: &mut LineProgram,\n     line_strings: &mut LineStringTable,\n-    file: &FileName,\n+    file: &SourceFile,\n ) -> FileId {\n-    match file {\n+    match &file.name {\n         FileName::Real(path) => {\n             let (dir_path, file_name) = split_path_dir_and_file(path);\n             let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n@@ -57,13 +58,32 @@ fn line_program_add_file(\n                 line_program.encoding(),\n                 line_strings,\n             );\n-            line_program.add_file(file_name, dir_id, None)\n+\n+            let md5 = Some(file.src_hash)\n+                .filter(|h| matches!(h, SourceFileHash { kind: SourceFileHashAlgorithm::Md5, .. }))\n+                .map(|h| {\n+                    let mut buf = [0u8; super::MD5_LEN];\n+                    buf.copy_from_slice(h.hash_bytes());\n+                    buf\n+                });\n+\n+            line_program.file_has_timestamp = true;\n+            line_program.file_has_md5 = md5.is_some();\n+\n+            line_program.add_file(file_name, dir_id, Some(FileInfo {\n+                timestamp: SystemTime::now()\n+                    .duration_since(SystemTime::UNIX_EPOCH)\n+                    .map(|t| t.as_secs())\n+                    .unwrap_or(0),\n+                size: 0,\n+                md5: md5.unwrap_or_default(),\n+            }))\n         }\n         // FIXME give more appropriate file names\n-        _ => {\n+        filename => {\n             let dir_id = line_program.default_directory();\n             let dummy_file_name = LineString::new(\n-                file.to_string().into_bytes(),\n+                filename.to_string().into_bytes(),\n                 line_program.encoding(),\n                 line_strings,\n             );\n@@ -79,7 +99,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let file_id = line_program_add_file(\n             &mut self.dwarf.unit.line_program,\n             &mut self.dwarf.line_strings,\n-            &loc.file.name,\n+            &loc.file,\n         );\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n@@ -167,7 +187,7 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                 true\n             };\n             if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file.name);\n+                let file_id = line_program_add_file(line_program, line_strings, &file);\n                 line_program.row().file = file_id;\n                 last_file = Some(file.clone());\n             }"}, {"sha": "d6225e8052ab89ed098c7c6a90668b8918a7bef6", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/077209e56544ccb55a5e2864d388eccf32c888ee/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077209e56544ccb55a5e2864d388eccf32c888ee/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=077209e56544ccb55a5e2864d388eccf32c888ee", "patch": "@@ -1,15 +1,19 @@\n mod emit;\n mod line_info;\n \n+use std::time::SystemTime;\n+\n use crate::prelude::*;\n \n+use rustc_span::{FileName, SourceFileHash, SourceFileHashAlgorithm};\n+\n use cranelift_codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n     self, Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId, Writer,\n+    LocationList, Range, RangeList, UnitEntryId, Writer, FileInfo,\n };\n use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n \n@@ -24,6 +28,8 @@ fn target_endian(tcx: TyCtxt<'_>) -> RunTimeEndian {\n     }\n }\n \n+const MD5_LEN: usize = 16;\n+\n pub(crate) struct DebugContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n@@ -42,7 +48,8 @@ impl<'tcx> DebugContext<'tcx> {\n             format: Format::Dwarf32,\n             // TODO: this should be configurable\n             // macOS doesn't seem to support DWARF > 3\n-            version: 3,\n+            // 5 version is required for md5 file hash\n+            version: 5,\n             address_size,\n         };\n \n@@ -52,18 +59,41 @@ impl<'tcx> DebugContext<'tcx> {\n         // Normally this would use option_env!(\"CFG_VERSION\").\n         let producer = format!(\"cg_clif (rustc {})\", \"unknown version\");\n         let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n-        let name = match tcx.sess.local_crate_source_file {\n-            Some(ref path) => path.to_string_lossy().into_owned(),\n-            None => tcx.crate_name(LOCAL_CRATE).to_string(),\n+        let (name, md5) = match tcx.sess.local_crate_source_file.clone() {\n+            Some(path) => {\n+                let name = path.to_string_lossy().into_owned();\n+                let hash = tcx.sess\n+                    .source_map()\n+                    .get_source_file(&FileName::Real(path))\n+                    .map(|f| f.src_hash)\n+                    .filter(|h| matches!(h, SourceFileHash { kind: SourceFileHashAlgorithm::Md5, .. }))\n+                    .map(|h| {\n+                        let mut buf = [0u8; MD5_LEN];\n+                        buf.copy_from_slice(h.hash_bytes());\n+                        buf\n+                    });\n+                (name, hash)\n+            },\n+            None => (tcx.crate_name(LOCAL_CRATE).to_string(), None),\n         };\n \n-        let line_program = LineProgram::new(\n+        let mut line_program = LineProgram::new(\n             encoding,\n             LineEncoding::default(),\n             LineString::new(comp_dir.as_bytes(), encoding, &mut dwarf.line_strings),\n             LineString::new(name.as_bytes(), encoding, &mut dwarf.line_strings),\n-            None,\n+            Some(FileInfo {\n+                timestamp: SystemTime::now()\n+                    .duration_since(SystemTime::UNIX_EPOCH)\n+                    .map(|t| t.as_secs())\n+                    .unwrap_or(0),\n+                size: 0,\n+                md5: md5.unwrap_or_default(),\n+            }),\n         );\n+        line_program.file_has_timestamp = true;\n+        line_program.file_has_md5 = md5.is_some();\n+\n         dwarf.unit.line_program = line_program;\n \n         {"}]}