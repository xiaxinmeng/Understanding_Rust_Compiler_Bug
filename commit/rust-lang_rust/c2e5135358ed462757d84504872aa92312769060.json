{"sha": "c2e5135358ed462757d84504872aa92312769060", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZTUxMzUzNThlZDQ2Mjc1N2Q4NDUwNDg3MmFhOTIzMTI3NjkwNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-12T13:27:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-12T13:27:03Z"}, "message": "auto merge of #12807 : pnkfelix/rust/fsk-issue5121-fns-with-early-lifetime-params, r=pnkfelix\n\nFix issue #5121: Add proper support for early/late distinction for lifetime bindings.\r\n\r\nThere are some little refactoring cleanups as separate commits; the real meat that has the actual fix is in the final commit.\r\n\r\nThe original author of the work was @nikomatsakis; I have reviewed it, revised it slightly, refactored it into these separate commits, and done some rebasing work.", "tree": {"sha": "781d226279e8a13f344a699c67d709de50c1d57c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/781d226279e8a13f344a699c67d709de50c1d57c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e5135358ed462757d84504872aa92312769060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e5135358ed462757d84504872aa92312769060", "html_url": "https://github.com/rust-lang/rust/commit/c2e5135358ed462757d84504872aa92312769060", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e5135358ed462757d84504872aa92312769060/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397abb7242b7d2d3e14a3a11b1ec8b5dadeea06f", "url": "https://api.github.com/repos/rust-lang/rust/commits/397abb7242b7d2d3e14a3a11b1ec8b5dadeea06f", "html_url": "https://github.com/rust-lang/rust/commit/397abb7242b7d2d3e14a3a11b1ec8b5dadeea06f"}, {"sha": "742e458102ff5236ecf24a05ab94898c76d6d1cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/742e458102ff5236ecf24a05ab94898c76d6d1cf", "html_url": "https://github.com/rust-lang/rust/commit/742e458102ff5236ecf24a05ab94898c76d6d1cf"}], "stats": {"total": 1015, "additions": 702, "deletions": 313}, "files": [{"sha": "c1fd83cab54cc6ccd4f3cecd83359e694d430e9a", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -164,12 +164,12 @@ impl fold::Folder for PreludeInjector {\n             segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n-                    lifetimes: opt_vec::Empty,\n+                    lifetimes: Vec::new(),\n                     types: opt_vec::Empty,\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n-                    lifetimes: opt_vec::Empty,\n+                    lifetimes: Vec::new(),\n                     types: opt_vec::Empty,\n                 }),\n         };"}, {"sha": "d403efcf8cd2637efa6f38ac48601bfbe5e4e328", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -369,7 +369,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n         global: false,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetimes: opt_vec::Empty,\n+            lifetimes: Vec::new(),\n             types: opt_vec::Empty,\n         }).collect()\n     }\n@@ -381,7 +381,7 @@ fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n         global: true,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetimes: opt_vec::Empty,\n+            lifetimes: Vec::new(),\n             types: opt_vec::Empty,\n         }).collect()\n     }"}, {"sha": "678e81b7fea7e523cef027905a927ddb535b7fbc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -273,7 +273,7 @@ fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n                                              tag_region_param_def_def_id);\n             let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n             let def_id = translate_def_id(cdata, def_id);\n-            v.push(ty::RegionParameterDef { ident: ident.name,\n+            v.push(ty::RegionParameterDef { name: ident.name,\n                                             def_id: def_id });\n             true\n         });"}, {"sha": "b6eab7b8a7474495d3780a52615689f684099eb2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -184,7 +184,7 @@ fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n         ebml_w.start_tag(tag_region_param_def);\n \n         ebml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(ebml_w, param.ident);\n+        encode_name(ebml_w, param.name);\n         ebml_w.end_tag();\n \n         ebml_w.wr_tagged_str(tag_region_param_def_def_id,"}, {"sha": "590487f20d09a4cea772f4b79ec614ab93ae7f0c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -176,11 +176,11 @@ fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n-        ty::ReEarlyBound(node_id, index, ident) => {\n+        ty::ReEarlyBound(node_id, index, name) => {\n             mywrite!(w, \"B[{}|{}|{}]\",\n                      node_id,\n                      index,\n-                     token::get_name(ident));\n+                     token::get_name(name));\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[{}|\", fr.scope_id);\n@@ -208,10 +208,10 @@ fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n         }\n-        ty::BrNamed(d, s) => {\n+        ty::BrNamed(d, name) => {\n             mywrite!(w, \"[{}|{}]\",\n                      (cx.ds)(d),\n-                     token::get_name(s));\n+                     token::get_name(name));\n         }\n         ty::BrFresh(id) => {\n             mywrite!(w, \"f{}|\", id);"}, {"sha": "5cee3e1a20dd9414f6a34e7f44720df479f0a9c9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -13,6 +13,7 @@\n //! which are available for use externally when compiled as a library.\n \n use std::mem::replace;\n+use std::vec_ng::Vec;\n \n use metadata::csearch;\n use middle::lint;\n@@ -855,7 +856,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                 debug!(\"privacy - list {}\", pid.node.id);\n                                 let seg = ast::PathSegment {\n                                     identifier: pid.node.name,\n-                                    lifetimes: opt_vec::Empty,\n+                                    lifetimes: Vec::new(),\n                                     types: opt_vec::Empty,\n                                 };\n                                 let segs = vec!(seg);"}, {"sha": "88eaf256be8cfde39466a5368d63ece9856a6b2e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 184, "deletions": 62, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -19,9 +19,11 @@\n \n use driver::session;\n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n@@ -33,18 +35,31 @@ use syntax::visit::Visitor;\n // that it corresponds to\n pub type NamedRegionMap = NodeMap<ast::DefRegion>;\n \n+// Returns an instance of some type that implements std::fmt::Show\n+fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n+    token::get_name(*lt_name)\n+}\n+\n struct LifetimeContext {\n     sess: session::Session,\n     named_region_map: @RefCell<NamedRegionMap>,\n }\n \n enum ScopeChain<'a> {\n-    ItemScope(&'a OptVec<ast::Lifetime>),\n-    FnScope(ast::NodeId, &'a OptVec<ast::Lifetime>, &'a ScopeChain<'a>),\n-    BlockScope(ast::NodeId, &'a ScopeChain<'a>),\n+    /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n+    /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n+    EarlyScope(uint, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    /// LateScope(binder_id, ['a, 'b, ...], s) extends s with late-bound\n+    /// lifetimes introduced by the declaration binder_id.\n+    LateScope(ast::NodeId, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    /// lifetimes introduced by items within a code block are scoped\n+    /// to that block.\n+    BlockScope(ast::NodeId, Scope<'a>),\n     RootScope\n }\n \n+type Scope<'a> = &'a ScopeChain<'a>;\n+\n pub fn krate(sess: session::Session, krate: &ast::Crate)\n              -> @RefCell<NamedRegionMap> {\n     let mut ctxt = LifetimeContext {\n@@ -56,10 +71,11 @@ pub fn krate(sess: session::Session, krate: &ast::Crate)\n     ctxt.named_region_map\n }\n \n-impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n+impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n     fn visit_item(&mut self,\n                   item: &ast::Item,\n-                  _: &'a ScopeChain<'a>) {\n+                  _: Scope<'a>) {\n+        let root = RootScope;\n         let scope = match item.node {\n             ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n             ast::ItemMod(..) |\n@@ -74,7 +90,7 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n             ast::ItemImpl(ref generics, _, _, _) |\n             ast::ItemTrait(ref generics, _, _) => {\n                 self.check_lifetime_names(&generics.lifetimes);\n-                ItemScope(&generics.lifetimes)\n+                EarlyScope(0, &generics.lifetimes, &root)\n             }\n         };\n         debug!(\"entering scope {:?}\", scope);\n@@ -84,58 +100,50 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n \n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 b: &ast::Block, s: Span, n: ast::NodeId,\n-                scope: &'a ScopeChain<'a>) {\n+                scope: Scope<'a>) {\n         match *fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                let scope1 = FnScope(n, &generics.lifetimes, scope);\n-                self.check_lifetime_names(&generics.lifetimes);\n-                debug!(\"pushing fn scope id={} due to item/method\", n);\n-                visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n-                debug!(\"popping fn scope id={} due to item/method\", n);\n+                self.visit_fn_decl(\n+                    n, generics, scope,\n+                    |this, scope1| visit::walk_fn(this, fk, fd, b, s, n, scope1))\n             }\n             visit::FkFnBlock(..) => {\n-                visit::walk_fn(self, fk, fd, b, s, n, scope);\n+                visit::walk_fn(self, fk, fd, b, s, n, scope)\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &ast::Ty,\n-                scope: &'a ScopeChain<'a>) {\n+    fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n         match ty.node {\n-            ast::TyClosure(closure) => {\n-                let scope1 = FnScope(ty.id, &closure.lifetimes, scope);\n-                self.check_lifetime_names(&closure.lifetimes);\n-                debug!(\"pushing fn scope id={} due to type\", ty.id);\n-                visit::walk_ty(self, ty, &scope1);\n-                debug!(\"popping fn scope id={} due to type\", ty.id);\n-            }\n-            ast::TyBareFn(bare_fn) => {\n-                let scope1 = FnScope(ty.id, &bare_fn.lifetimes, scope);\n-                self.check_lifetime_names(&bare_fn.lifetimes);\n-                debug!(\"pushing fn scope id={} due to type\", ty.id);\n-                visit::walk_ty(self, ty, &scope1);\n-                debug!(\"popping fn scope id={} due to type\", ty.id);\n-            }\n-            _ => {\n-                visit::walk_ty(self, ty, scope);\n-            }\n+            ast::TyClosure(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            _ => visit::walk_ty(self, ty, scope),\n+        }\n+\n+        fn push_fn_scope(this: &mut LifetimeContext,\n+                         ty: &ast::Ty,\n+                         scope: Scope,\n+                         lifetimes: &Vec<ast::Lifetime>) {\n+            let scope1 = LateScope(ty.id, lifetimes, scope);\n+            this.check_lifetime_names(lifetimes);\n+            debug!(\"pushing fn scope id={} due to type\", ty.id);\n+            visit::walk_ty(this, ty, &scope1);\n+            debug!(\"popping fn scope id={} due to type\", ty.id);\n         }\n     }\n \n     fn visit_ty_method(&mut self,\n                        m: &ast::TypeMethod,\n-                       scope: &'a ScopeChain<'a>) {\n-        let scope1 = FnScope(m.id, &m.generics.lifetimes, scope);\n-        self.check_lifetime_names(&m.generics.lifetimes);\n-        debug!(\"pushing fn scope id={} due to ty_method\", m.id);\n-        visit::walk_ty_method(self, m, &scope1);\n-        debug!(\"popping fn scope id={} due to ty_method\", m.id);\n+                       scope: Scope<'a>) {\n+        self.visit_fn_decl(\n+            m.id, &m.generics, scope,\n+            |this, scope1| visit::walk_ty_method(this, m, scope1))\n     }\n \n     fn visit_block(&mut self,\n                    b: &ast::Block,\n-                   scope: &'a ScopeChain<'a>) {\n+                   scope: Scope<'a>) {\n         let scope1 = BlockScope(b.id, scope);\n         debug!(\"pushing block scope {}\", b.id);\n         visit::walk_block(self, b, &scope1);\n@@ -144,19 +152,94 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n \n     fn visit_lifetime_ref(&mut self,\n                           lifetime_ref: &ast::Lifetime,\n-                          scope: &'a ScopeChain<'a>) {\n-        if lifetime_ref.ident == special_idents::statik.name {\n+                          scope: Scope<'a>) {\n+        if lifetime_ref.name == special_idents::statik.name {\n             self.insert_lifetime(lifetime_ref, ast::DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref, scope);\n     }\n }\n \n+impl<'a> ScopeChain<'a> {\n+    fn count_early_params(&self) -> uint {\n+        /*!\n+         * Counts the number of early-bound parameters that are in\n+         * scope.  Used when checking methods: the early-bound\n+         * lifetime parameters declared on the method are assigned\n+         * indices that come after the indices from the type.  Given\n+         * something like `impl<'a> Foo { ... fn bar<'b>(...) }`\n+         * then `'a` gets index 0 and `'b` gets index 1.\n+         */\n+\n+        match *self {\n+            RootScope => 0,\n+            EarlyScope(base, lifetimes, _) => base + lifetimes.len(),\n+            LateScope(_, _, s) => s.count_early_params(),\n+            BlockScope(_, _) => 0,\n+        }\n+    }\n+}\n+\n impl LifetimeContext {\n+    /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n+    fn visit_fn_decl(&mut self,\n+                     n: ast::NodeId,\n+                     generics: &ast::Generics,\n+                     scope: Scope,\n+                     walk: |&mut LifetimeContext, Scope|) {\n+        /*!\n+         * Handles visiting fns and methods. These are a bit\n+         * complicated because we must distinguish early- vs late-bound\n+         * lifetime parameters. We do this by checking which lifetimes\n+         * appear within type bounds; those are early bound lifetimes,\n+         * and the rest are late bound.\n+         *\n+         * For example:\n+         *\n+         *    fn foo<'a,'b,'c,T:Trait<'b>>(...)\n+         *\n+         * Here `'a` and `'c` are late bound but `'b` is early\n+         * bound. Note that early- and late-bound lifetimes may be\n+         * interspersed together.\n+         *\n+         * If early bound lifetimes are present, we separate them into\n+         * their own list (and likewise for late bound). They will be\n+         * numbered sequentially, starting from the lowest index that\n+         * is already in scope (for a fn item, that will be 0, but for\n+         * a method it might not be). Late bound lifetimes are\n+         * resolved by name and associated with a binder id (`n`), so\n+         * the ordering is not important there.\n+         */\n+\n+        self.check_lifetime_names(&generics.lifetimes);\n+\n+        let early_count = scope.count_early_params();\n+        let referenced_idents = free_lifetimes(&generics.ty_params);\n+        debug!(\"pushing fn scope id={} due to fn item/method\\\n+               referenced_idents={:?} \\\n+               early_count={}\",\n+               n,\n+               referenced_idents.map(lifetime_show),\n+               early_count);\n+        if referenced_idents.is_empty() {\n+            let scope1 = LateScope(n, &generics.lifetimes, scope);\n+            walk(self, &scope1)\n+        } else {\n+            let (early, late) = generics.lifetimes.clone().partition(\n+                |l| referenced_idents.iter().any(|&i| i == l.name));\n+\n+            let scope1 = EarlyScope(early_count, &early, scope);\n+            let scope2 = LateScope(n, &late, &scope1);\n+\n+            walk(self, &scope2);\n+        }\n+        debug!(\"popping fn scope id={} due to fn item/method\", n);\n+    }\n+\n     fn resolve_lifetime_ref(&self,\n                             lifetime_ref: &ast::Lifetime,\n-                            scope: &ScopeChain) {\n+                            scope: Scope) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes. If we encounter a code\n@@ -175,23 +258,25 @@ impl LifetimeContext {\n                     break;\n                 }\n \n-                ItemScope(lifetimes) => {\n+                EarlyScope(base, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, decl_id)) => {\n+                        Some((offset, decl_id)) => {\n+                            let index = base + offset;\n                             let def = ast::DefEarlyBoundRegion(index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n                         None => {\n-                            break;\n+                            depth += 1;\n+                            scope = s;\n                         }\n                     }\n                 }\n \n-                FnScope(id, lifetimes, s) => {\n+                LateScope(binder_id, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = ast::DefLateBoundRegion(id, depth, decl_id);\n+                            let def = ast::DefLateBoundRegion(binder_id, depth, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -211,7 +296,7 @@ impl LifetimeContext {\n     fn resolve_free_lifetime_ref(&self,\n                                  scope_id: ast::NodeId,\n                                  lifetime_ref: &ast::Lifetime,\n-                                 scope: &ScopeChain) {\n+                                 scope: Scope) {\n         // Walk up the scope chain, tracking the outermost free scope,\n         // until we encounter a scope that contains the named lifetime\n         // or we run out of scopes.\n@@ -229,12 +314,8 @@ impl LifetimeContext {\n                     break;\n                 }\n \n-                ItemScope(lifetimes) => {\n-                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n-                    break;\n-                }\n-\n-                FnScope(_, lifetimes, s) => {\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(_, lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n                         break;\n@@ -262,32 +343,32 @@ impl LifetimeContext {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `'{}`\",\n-                    token::get_name(lifetime_ref.ident)));\n+                    token::get_name(lifetime_ref.name)));\n     }\n \n-    fn check_lifetime_names(&self, lifetimes: &OptVec<ast::Lifetime>) {\n+    fn check_lifetime_names(&self, lifetimes: &Vec<ast::Lifetime>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = lifetimes.get(i);\n \n             let special_idents = [special_idents::statik];\n             for lifetime in lifetimes.iter() {\n-                if special_idents.iter().any(|&i| i.name == lifetime.ident) {\n+                if special_idents.iter().any(|&i| i.name == lifetime.name) {\n                     self.sess.span_err(\n                         lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.ident)));\n+                                token::get_name(lifetime.name)));\n                 }\n             }\n \n             for j in range(i + 1, lifetimes.len()) {\n                 let lifetime_j = lifetimes.get(j);\n \n-                if lifetime_i.ident == lifetime_j.ident {\n+                if lifetime_i.name == lifetime_j.name {\n                     self.sess.span_err(\n                         lifetime_j.span,\n                         format!(\"lifetime name `'{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.ident)));\n+                                token::get_name(lifetime_j.name)));\n                 }\n             }\n         }\n@@ -311,13 +392,54 @@ impl LifetimeContext {\n     }\n }\n \n-fn search_lifetimes(lifetimes: &OptVec<ast::Lifetime>,\n+fn search_lifetimes(lifetimes: &Vec<ast::Lifetime>,\n                     lifetime_ref: &ast::Lifetime)\n                     -> Option<(uint, ast::NodeId)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n-        if lifetime_decl.ident == lifetime_ref.ident {\n+        if lifetime_decl.name == lifetime_ref.name {\n             return Some((i, lifetime_decl.id));\n         }\n     }\n     return None;\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifetime> {\n+    let referenced_idents = free_lifetimes(&generics.ty_params);\n+    if referenced_idents.is_empty() {\n+        return Vec::new();\n+    }\n+\n+    generics.lifetimes.iter()\n+        .filter(|l| referenced_idents.iter().any(|&i| i == l.name))\n+        .map(|l| *l)\n+        .collect()\n+}\n+\n+pub fn free_lifetimes(ty_params: &OptVec<ast::TyParam>) -> OptVec<ast::Name> {\n+    /*!\n+     * Gathers up and returns the names of any lifetimes that appear\n+     * free in `ty_params`. Of course, right now, all lifetimes appear\n+     * free, since we don't currently have any binders in type parameter\n+     * declarations; just being forwards compatible with future extensions.\n+     */\n+\n+    let mut collector = FreeLifetimeCollector { names: opt_vec::Empty };\n+    for ty_param in ty_params.iter() {\n+        visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n+    }\n+    return collector.names;\n+\n+    struct FreeLifetimeCollector {\n+        names: OptVec<ast::Name>,\n+    }\n+\n+    impl Visitor<()> for FreeLifetimeCollector {\n+        fn visit_lifetime_ref(&mut self,\n+                              lifetime_ref: &ast::Lifetime,\n+                              _: ()) {\n+            self.names.push(lifetime_ref.name);\n+        }\n+    }\n+}"}, {"sha": "b0cf17c5b5467f6362c18f8b31d2f58029de8031", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -276,7 +276,7 @@ impl Subst for ty::Region {\n         // bound in *fn types*. Region substitution of the bound\n         // regions that appear in a function signature is done using\n         // the specialized routine\n-        // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n+        // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n         match self {\n             &ty::ReEarlyBound(_, i, _) => {\n                 match substs.regions {"}, {"sha": "6ade20d29136df4f40abbd5e7aea753644373c48", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -540,7 +540,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return FunctionWithoutDebugInfo;\n     }\n \n-    let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n+    let empty_generics = ast::Generics { lifetimes: Vec::new(), ty_params: opt_vec::Empty };\n \n     let fnitem = cx.tcx.map.get(fn_ast_id);\n "}, {"sha": "b2a879b1946e1c566c7e55a09cbb524ff04ae8e4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -996,7 +996,7 @@ pub struct TypeParameterDef {\n \n #[deriving(Encodable, Decodable, Clone)]\n pub struct RegionParameterDef {\n-    ident: ast::Name,\n+    name: ast::Name,\n     def_id: ast::DefId,\n }\n \n@@ -1008,6 +1008,7 @@ pub struct Generics {\n     type_param_defs: Rc<Vec<TypeParameterDef> >,\n \n     /// List of region parameters declared on the item.\n+    /// For a fn or method, only includes *early-bound* lifetimes.\n     region_param_defs: Rc<Vec<RegionParameterDef> >,\n }\n \n@@ -5077,6 +5078,7 @@ pub fn construct_parameter_environment(\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],\n     item_region_params: &[RegionParameterDef],\n+    method_region_params: &[RegionParameterDef],\n     free_id: ast::NodeId)\n     -> ParameterEnvironment\n {\n@@ -5104,11 +5106,24 @@ pub fn construct_parameter_environment(\n         });\n \n     // map bound 'a => free 'a\n-    let region_params = item_region_params.iter().\n-        map(|r| ty::ReFree(ty::FreeRegion {\n-                scope_id: free_id,\n-                bound_region: ty::BrNamed(r.def_id, r.ident)})).\n-        collect();\n+    let region_params = {\n+        fn push_region_params(accum: OptVec<ty::Region>,\n+                              free_id: ast::NodeId,\n+                              region_params: &[RegionParameterDef])\n+                              -> OptVec<ty::Region> {\n+            let mut accum = accum;\n+            for r in region_params.iter() {\n+                accum.push(\n+                    ty::ReFree(ty::FreeRegion {\n+                            scope_id: free_id,\n+                            bound_region: ty::BrNamed(r.def_id, r.name)}));\n+            }\n+            accum\n+        }\n+\n+        let t = push_region_params(opt_vec::Empty, free_id, item_region_params);\n+        push_region_params(t, free_id, method_region_params)\n+    };\n \n     let free_substs = substs {\n         self_ty: self_ty,\n@@ -5130,6 +5145,15 @@ pub fn construct_parameter_environment(\n         }\n     });\n \n+    debug!(\"construct_parameter_environment: free_id={} \\\n+           free_subst={} \\\n+           self_param_bound={} \\\n+           type_param_bound={}\",\n+           free_id,\n+           free_substs.repr(tcx),\n+           self_bound_substd.repr(tcx),\n+           type_param_bounds_substd.repr(tcx));\n+\n     ty::ParameterEnvironment {\n         free_substs: free_substs,\n         self_param_bound: self_bound_substd,"}, {"sha": "e8770f9d142cfe492d8714adfa95bf5df3615c85", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -92,18 +92,18 @@ pub fn ast_region_to_region(tcx: ty::ctxt, lifetime: &ast::Lifetime)\n \n         Some(&ast::DefLateBoundRegion(binder_id, _, id)) => {\n             ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n-                                                   lifetime.ident))\n+                                                   lifetime.name))\n         }\n \n         Some(&ast::DefEarlyBoundRegion(index, id)) => {\n-            ty::ReEarlyBound(id, index, lifetime.ident)\n+            ty::ReEarlyBound(id, index, lifetime.name)\n         }\n \n         Some(&ast::DefFreeRegion(scope_id, id)) => {\n             ty::ReFree(ty::FreeRegion {\n                     scope_id: scope_id,\n                     bound_region: ty::BrNamed(ast_util::local_def(id),\n-                                              lifetime.ident)\n+                                              lifetime.name)\n                 })\n         }\n     };\n@@ -186,9 +186,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         }\n \n         match anon_regions {\n-            Ok(v) => opt_vec::from(v.move_iter().collect()),\n-            Err(()) => opt_vec::from(Vec::from_fn(expected_num_region_params,\n-                                                  |_| ty::ReStatic)) // hokey\n+            Ok(v) => v.move_iter().collect(),\n+            Err(()) => Vec::from_fn(expected_num_region_params,\n+                                    |_| ty::ReStatic) // hokey\n         }\n     };\n \n@@ -231,7 +231,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                             .collect();\n \n     let mut substs = substs {\n-        regions: ty::NonerasedRegions(regions),\n+        regions: ty::NonerasedRegions(opt_vec::from(regions)),\n         self_ty: self_ty,\n         tps: tps\n     };"}, {"sha": "ca36fca687abd5afe1d54cf18118c98793ac35ad", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -93,7 +93,7 @@ use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n use middle::typeck::{param_numbered, param_self, param_index};\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n@@ -428,7 +428,7 @@ impl<'a> LookupContext<'a> {\n                                             substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n-               substs_to_str(self.tcx(), substs));\n+               substs.repr(self.tcx()));\n         let _indenter = indenter();\n \n         // It is illegal to invoke a method on a trait instance that\n@@ -554,7 +554,8 @@ impl<'a> LookupContext<'a> {\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n-                            debug!(\"pushing inherent candidate for param: {:?}\", cand);\n+                            debug!(\"pushing inherent candidate for param: {}\",\n+                                   cand.repr(self.tcx()));\n                             self.inherent_candidates.borrow_mut().get().push(cand);\n                         }\n                         None => {}\n@@ -938,8 +939,9 @@ impl<'a> LookupContext<'a> {\n             let mut j = i + 1;\n             while j < candidates.len() {\n                 let candidate_b = &candidates[j];\n-                debug!(\"attempting to merge {:?} and {:?}\",\n-                       candidate_a, candidate_b);\n+                debug!(\"attempting to merge {} and {}\",\n+                       candidate_a.repr(self.tcx()),\n+                       candidate_b.repr(self.tcx()));\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n@@ -984,19 +986,20 @@ impl<'a> LookupContext<'a> {\n \n         let tcx = self.tcx();\n \n-        debug!(\"confirm_candidate(expr={}, candidate={})\",\n+        debug!(\"confirm_candidate(expr={}, rcvr_ty={}, candidate={})\",\n                self.expr.repr(tcx),\n-               self.cand_to_str(candidate));\n+               self.ty_to_str(rcvr_ty),\n+               candidate.repr(self.tcx()));\n \n         self.enforce_object_limitations(candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != SelfStatic);\n \n-        // Determine the values for the type parameters of the method.\n+        // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n-        // type variables.\n+        // variables.\n         let num_supplied_tps = self.supplied_tps.len();\n         let num_method_tps = candidate.method_ty.generics.type_param_defs().len();\n         let m_substs = {\n@@ -1018,12 +1021,26 @@ impl<'a> LookupContext<'a> {\n             }\n         };\n \n+        // Determine values for the early-bound lifetime parameters.\n+        // FIXME -- permit users to manually specify lifetimes\n+        let mut all_regions = match candidate.rcvr_substs.regions {\n+            NonerasedRegions(ref v) => v.clone(),\n+            ErasedRegions => tcx.sess.span_bug(self.expr.span, \"ErasedRegions\")\n+        };\n+        let m_regions =\n+            self.fcx.infcx().region_vars_for_defs(\n+                self.expr.span,\n+                candidate.method_ty.generics.region_param_defs.borrow().as_slice());\n+        for &r in m_regions.iter() {\n+            all_regions.push(r);\n+        }\n+\n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n             tps: vec_ng::append(candidate.rcvr_substs.tps.clone(),\n                                 m_substs.as_slice()),\n-            regions: candidate.rcvr_substs.regions.clone(),\n+            regions: NonerasedRegions(all_regions),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n \n@@ -1057,10 +1074,10 @@ impl<'a> LookupContext<'a> {\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_bound_regions_in_fn_sig( tcx, &fn_sig, |br| {\n-            self.fcx.infcx().next_region_var(\n-                infer::BoundRegionInFnCall(self.expr.span, br))\n-        });\n+        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n+            tcx, &fn_sig,\n+            |br| self.fcx.infcx().next_region_var(\n+                infer::LateBoundRegion(self.expr.span, br)));\n         let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1245,7 +1262,7 @@ impl<'a> LookupContext<'a> {\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n-               self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n+               self.ty_to_str(rcvr_ty), candidate.repr(self.tcx()));\n \n         return match candidate.method_ty.explicit_self {\n             SelfStatic => {\n@@ -1385,13 +1402,6 @@ impl<'a> LookupContext<'a> {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n-             cand.rcvr_match_condition.repr(self.tcx()),\n-             ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n-             cand.origin)\n-    }\n-\n     fn did_to_str(&self, did: DefId) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n@@ -1401,6 +1411,15 @@ impl<'a> LookupContext<'a> {\n     }\n }\n \n+impl Repr for Candidate {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n+                self.rcvr_match_condition.repr(tcx),\n+                self.rcvr_substs.repr(tcx),\n+                self.origin)\n+    }\n+}\n+\n impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {"}, {"sha": "026d2d5d73454bd26383a7f161f11c69f1da7a72", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -97,7 +97,7 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n@@ -439,7 +439,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let (_, fn_sig) = replace_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n+    let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n         ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n     });\n \n@@ -563,13 +563,13 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n       ast::ItemFn(decl, _, _, _, body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n-        // FIXME(#5121) -- won't work for lifetimes that appear in type bounds\n         let param_env = ty::construct_parameter_environment(\n                 ccx.tcx,\n                 None,\n                 fn_tpt.generics.type_param_defs(),\n                 [],\n                 [],\n+                fn_tpt.generics.region_param_defs.borrow().as_slice(),\n                 body.id);\n \n         check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n@@ -679,6 +679,7 @@ fn check_method_body(ccx: @CrateCtxt,\n             item_generics.type_param_defs(),\n             method_generics.type_param_defs(),\n             item_generics.region_param_defs(),\n+            method_generics.region_param_defs(),\n             method.body.id);\n \n     // Compute the fty from point of view of inside fn\n@@ -901,7 +902,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n         impl_generics.region_param_defs().iter().\n         map(|l| ty::ReFree(ty::FreeRegion {\n                 scope_id: impl_m_body_id,\n-                bound_region: ty::BrNamed(l.def_id, l.ident)})).\n+                bound_region: ty::BrNamed(l.def_id, l.name)})).\n         collect();\n     let dummy_substs = ty::substs {\n         tps: vec_ng::append(dummy_impl_tps, dummy_method_tps.as_slice()),\n@@ -1439,22 +1440,17 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n-    let (n_tps, n_rps, raw_ty) = {\n-        let ity = ty::lookup_item_type(tcx, did);\n+    let ity = ty::lookup_item_type(tcx, did);\n+    let (n_tps, rps, raw_ty) =\n         (ity.generics.type_param_defs().len(),\n-         ity.generics.region_param_defs().len(),\n-         ity.ty)\n-    };\n+         ity.generics.region_param_defs(),\n+         ity.ty);\n \n-    let rps =\n-        vcx.infcx.next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(location_info.span),\n-            n_rps);\n+    let rps = vcx.infcx.region_vars_for_defs(location_info.span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n     let substs = substs {\n-        regions: ty::NonerasedRegions(opt_vec::from(rps.move_iter()\n-                                                       .collect())),\n+        regions: ty::NonerasedRegions(rps),\n         self_ty: None,\n         tps: tps,\n     };\n@@ -1888,9 +1884,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n-            fcx.infcx()\n-               .next_region_var(infer::BoundRegionInFnCall(call_expr.span, br))\n+        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n+            fcx.infcx().next_region_var(infer::LateBoundRegion(call_expr.span, br))\n         });\n \n         // Call the generic checker.\n@@ -2214,7 +2209,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n                     let (_, sig) =\n-                        replace_bound_regions_in_fn_sig(\n+                        replace_late_bound_regions_in_fn_sig(\n                             tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     (Some(sig), cenv.purity, cenv.sigil,\n@@ -2462,16 +2457,14 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         // determine whether the class is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, class_id);\n         let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_parameter_count = item_type.generics.region_param_defs().len();\n+        let region_param_defs = item_type.generics.region_param_defs();\n         let raw_type = item_type.ty;\n \n         // Generate the struct type.\n-        let regions = fcx.infcx().next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count).move_iter().collect();\n+        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n+            regions: ty::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -2520,16 +2513,14 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         // determine whether the enum is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, enum_id);\n         let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_parameter_count = item_type.generics.region_param_defs().len();\n+        let region_param_defs = item_type.generics.region_param_defs();\n         let raw_type = item_type.ty;\n \n         // Generate the enum type.\n-        let regions = fcx.infcx().next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count).move_iter().collect();\n+        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n+            regions: ty::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -3727,8 +3718,8 @@ pub fn instantiate_path(fcx: @FnCtxt,\n     let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        pth.segments.last().unwrap().lifetimes.map(\n-            |l| ast_region_to_region(fcx.tcx(), l))\n+        opt_vec::from(pth.segments.last().unwrap().lifetimes.map(\n+            |l| ast_region_to_region(fcx.tcx(), l)))\n     } else {\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err(\n@@ -3741,9 +3732,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                         nsupplied = num_supplied_regions));\n         }\n \n-        opt_vec::from(fcx.infcx().next_region_vars(\n-                infer::BoundRegionInTypeOrImpl(span),\n-                num_expected_regions).move_iter().collect())\n+        fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.borrow().as_slice())\n     };\n     let regions = ty::NonerasedRegions(regions);\n "}, {"sha": "c8a126382f4b4cec26b9a2fd1ca5b166e0395cbe", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -21,12 +21,12 @@ use util::ppaux;\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_bound_regions_in_fn_sig(\n+pub fn replace_late_bound_regions_in_fn_sig(\n         tcx: ty::ctxt,\n         fn_sig: &ty::FnSig,\n         mapf: |ty::BoundRegion| -> ty::Region)\n         -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n-    debug!(\"replace_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n+    debug!(\"replace_late_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n \n     let mut map = HashMap::new();\n     let fn_sig = {"}, {"sha": "57e85ab55d3bc0705b28fbaf91c81c64227e65f1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -777,6 +777,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n         impl_generics.type_param_defs(),\n         [],\n         impl_generics.region_param_defs(),\n+        [],\n         impl_item.id);\n \n     let impl_trait_ref = @impl_trait_ref.subst(tcx, &param_env.free_substs);\n@@ -832,7 +833,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n     if has_trait_bounds(type_param_defs.as_slice()) {\n         let vcx = VtableContext {\n             infcx: &infer::new_infer_ctxt(tcx),\n-            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], id)\n+            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n         };\n         let loc_info = LocationInfo {\n             id: id,"}, {"sha": "ca5befa8d4e06949b54fbc067d316e0e3746e421", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -42,7 +42,6 @@ use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::Span;\n-use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::visit;\n \n@@ -516,18 +515,17 @@ impl CoherenceChecker {\n     // type variables. Returns the monotype and the type variables created.\n     fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n                                      -> UniversalQuantificationResult {\n-        let region_parameter_count = polytype.generics.region_param_defs().len();\n         let region_parameters =\n-            self.inference_context.next_region_vars(\n-                infer::BoundRegionInCoherence,\n-                region_parameter_count);\n+            polytype.generics.region_param_defs().iter()\n+            .map(|d| self.inference_context.next_region_var(\n+                infer::BoundRegionInCoherence(d.name)))\n+            .collect();\n \n         let bounds_count = polytype.generics.type_param_defs().len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(\n-                             region_parameters.move_iter().collect())),\n+            regions: ty::NonerasedRegions(region_parameters),\n             self_ty: None,\n             tps: type_parameters\n         };"}, {"sha": "234e6e92bac9fd8fa2c786339d224bf67db0b6b0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 70, "deletions": 58, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -32,6 +32,7 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n+use middle::resolve_lifetime;\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n@@ -45,7 +46,6 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n-use std::vec;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use syntax::abi::AbiSet;\n@@ -160,7 +160,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::StructVariantKind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, generics, 0),\n+                    generics: ty_generics_for_type(ccx, generics),\n                     ty: enum_ty\n                 };\n \n@@ -173,7 +173,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         };\n \n         let tpt = ty_param_bounds_and_ty {\n-            generics: ty_generics(ccx, generics, 0),\n+            generics: ty_generics_for_type(ccx, generics),\n             ty: result_ty\n         };\n \n@@ -192,7 +192,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemTrait(ref generics, _, ref ms) => {\n-                    let trait_ty_generics = ty_generics(ccx, generics, 0);\n+                    let trait_ty_generics = ty_generics_for_type(ccx, generics);\n \n                     // For each method, construct a suitable ty::Method and\n                     // store it into the `tcx.methods` table:\n@@ -293,7 +293,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs().len();\n-        let non_shifted_trait_tps = vec::from_fn(num_trait_bounds, |i| {\n+        let non_shifted_trait_tps = Vec::from_fn(num_trait_bounds, |i| {\n             ty::mk_param(tcx, i, trait_ty_generics.type_param_defs()[i].def_id)\n         });\n \n@@ -303,7 +303,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // Represents [E',F',G']\n         let num_method_bounds = m.generics.type_param_defs().len();\n-        let shifted_method_tps = vec::from_fn(num_method_bounds, |i| {\n+        let shifted_method_tps = Vec::from_fn(num_method_bounds, |i| {\n             ty::mk_param(tcx, i + num_trait_bounds + 1,\n                          m.generics.type_param_defs()[i].def_id)\n         });\n@@ -315,7 +315,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let rps_from_trait =\n             trait_ty_generics.region_param_defs().iter().\n             enumerate().\n-            map(|(index,d)| ty::ReEarlyBound(d.def_id.node, index, d.ident)).\n+            map(|(index,d)| ty::ReEarlyBound(d.def_id.node, index, d.name)).\n             collect();\n \n         // build up the substitution from\n@@ -326,8 +326,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let substs = substs {\n             regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n-            tps: vec_ng::append(Vec::from_slice(non_shifted_trait_tps),\n-                                shifted_method_tps)\n+            tps: vec_ng::append(non_shifted_trait_tps,\n+                                shifted_method_tps.as_slice())\n         };\n \n         // create the type of `foo`, applying the substitution above\n@@ -394,10 +394,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let fty = astconv::ty_of_method(this, *m_id, *m_purity, trait_self_ty,\n                                         *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.type_param_defs().len();\n+        let ty_generics = ty_generics_for_fn_or_method(this, m_generics,\n+                                                       num_trait_type_params);\n         ty::Method::new(\n             *m_ident,\n-            // FIXME(#5121) -- distinguish early vs late lifetime params\n-            ty_generics(this, m_generics, num_trait_type_params),\n+            ty_generics,\n             fty,\n             m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n@@ -477,7 +478,8 @@ fn convert_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     for m in ms.iter() {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n-        let m_ty_generics = ty_generics(ccx, &m.generics, num_rcvr_ty_params);\n+        let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n+                                                         num_rcvr_ty_params);\n         let mty = @ty_of_method(ccx,\n                                 container,\n                                 *m,\n@@ -503,7 +505,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                             Vec::from_slice(\n                                 rcvr_ty_generics.type_param_defs()),\n                             m_ty_generics.type_param_defs())),\n-                        region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n+                        region_param_defs: Rc::new(vec_ng::append(\n+                                Vec::from_slice(rcvr_ty_generics.region_param_defs()),\n+                                m_ty_generics.region_param_defs())),\n                     },\n                     ty: fty\n                 });\n@@ -533,10 +537,11 @@ fn convert_methods(ccx: &CrateCtxt,\n         let method_vis = m.vis.inherit_from(rcvr_visibility);\n \n         let num_rcvr_type_params = rcvr_generics.ty_params.len();\n+        let m_ty_generics =\n+            ty_generics_for_fn_or_method(ccx, &m.generics, num_rcvr_type_params);\n         ty::Method::new(\n             m.ident,\n-            // FIXME(#5121) -- distinguish early vs late lifetime params\n-            ty_generics(ccx, &m.generics, num_rcvr_type_params),\n+            m_ty_generics,\n             fty,\n             m.explicit_self.node,\n             method_vis,\n@@ -588,15 +593,15 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                    generics);\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n-            let i_ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             {\n                 let mut tcache = tcx.tcache.borrow_mut();\n                 tcache.get().insert(local_def(it.id),\n                                     ty_param_bounds_and_ty {\n-                                        generics: i_ty_generics.clone(),\n+                                        generics: ty_generics.clone(),\n                                         ty: selfty});\n             }\n \n@@ -615,7 +620,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             ImplContainer(local_def(it.id)),\n                             ms.as_slice(),\n                             selfty,\n-                            &i_ty_generics,\n+                            &ty_generics,\n                             generics,\n                             parent_visibility);\n \n@@ -813,7 +818,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n     match it.node {\n         ast::ItemTrait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n             let bounds = ensure_supertraits(ccx,\n                                             it.id,\n@@ -857,17 +862,14 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return tpt;\n         }\n         ast::ItemFn(decl, purity, abi, ref generics, _) => {\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_fn_or_method(ccx, generics, 0);\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n                                               purity,\n                                               abi,\n                                               decl);\n             let tpt = ty_param_bounds_and_ty {\n-                generics: ty::Generics {\n-                    type_param_defs: ty_generics.type_param_defs.clone(),\n-                    region_param_defs: Rc::new(Vec::new()),\n-                },\n+                generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n@@ -891,7 +893,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let tpt = {\n                 let ty = ccx.to_ty(&ExplicitRscope, t);\n                 ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, generics, 0),\n+                    generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n                 }\n             };\n@@ -902,7 +904,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n             let t = ty::mk_enum(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n@@ -920,7 +922,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 format!(\"invoked ty_of_item on trait\"));\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n@@ -961,42 +963,51 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n+pub fn ty_generics_for_type(ccx: &CrateCtxt,\n+                            generics: &ast::Generics)\n+                            -> ty::Generics {\n+    ty_generics(ccx, &generics.lifetimes, &generics.ty_params, 0)\n+}\n+\n+pub fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n+                                    generics: &ast::Generics,\n+                                    base_index: uint)\n+                                    -> ty::Generics {\n+    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n+    ty_generics(ccx, &early_lifetimes, &generics.ty_params, base_index)\n+}\n+\n pub fn ty_generics(ccx: &CrateCtxt,\n-                   generics: &ast::Generics,\n+                   lifetimes: &Vec<ast::Lifetime>,\n+                   ty_params: &OptVec<ast::TyParam>,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n-        region_param_defs: Rc::new(generics.lifetimes.iter().map(|l| {\n-                ty::RegionParameterDef { ident: l.ident,\n+        region_param_defs: Rc::new(lifetimes.iter().map(|l| {\n+                ty::RegionParameterDef { name: l.name,\n                                          def_id: local_def(l.id) }\n             }).collect()),\n-        type_param_defs: Rc::new(generics.ty_params.mapi_to_vec(|offset, param| {\n+        type_param_defs: Rc::new(ty_params.mapi_to_vec(|offset, param| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n-                ty_param_defs.get().find(&param.id).map(|def| *def)\n+                ty_param_defs.get().find(&param.id).map(|&def| def)\n             };\n-            match existing_def_opt {\n-                Some(def) => def,\n-                None => {\n-                    let param_ty = ty::param_ty {idx: base_index + offset,\n-                                                 def_id: local_def(param.id)};\n-                    let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n-                    let default = param.default.map(|x| ast_ty_to_ty(ccx, &ExplicitRscope, x));\n-                    let def = ty::TypeParameterDef {\n-                        ident: param.ident,\n-                        def_id: local_def(param.id),\n-                        bounds: bounds,\n-                        default: default\n-                    };\n-                    debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-\n-                    let mut ty_param_defs = ccx.tcx\n-                                               .ty_param_defs\n-                                               .borrow_mut();\n-                    ty_param_defs.get().insert(param.id, def);\n-                    def\n-                }\n-            }\n-        }).move_iter().collect())\n+            existing_def_opt.unwrap_or_else(|| {\n+                let param_ty = ty::param_ty {idx: base_index + offset,\n+                                             def_id: local_def(param.id)};\n+                let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n+                let default = param.default.map(|x| ast_ty_to_ty(ccx, &ExplicitRscope, x));\n+                let def = ty::TypeParameterDef {\n+                    ident: param.ident,\n+                    def_id: local_def(param.id),\n+                    bounds: bounds,\n+                    default: default\n+                };\n+                debug!(\"def for param: {}\", def.repr(ccx.tcx));\n+                let mut ty_param_defs = ccx.tcx.ty_param_defs.borrow_mut();\n+                ty_param_defs.get().insert(param.id, def);\n+                def\n+            })\n+        }).move_iter().collect()),\n     };\n \n     fn compute_bounds(\n@@ -1056,7 +1067,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         }\n     }\n \n-    let ty_generics = ty_generics(ccx, ast_generics, 0);\n+    let ty_generics_for_fn_or_method =\n+        ty_generics_for_fn_or_method(ccx, ast_generics, 0);\n     let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs\n                         .iter()\n@@ -1076,7 +1088,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                             variadic: decl.variadic}\n         });\n     let tpt = ty_param_bounds_and_ty {\n-        generics: ty_generics,\n+        generics: ty_generics_for_fn_or_method,\n         ty: t_fn\n     };\n \n@@ -1095,7 +1107,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n \n     let regions: OptVec<ty::Region> =\n         ty_generics.region_param_defs().iter().enumerate().map(\n-            |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.ident)).collect();\n+            |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.name)).collect();\n \n     substs {regions: ty::NonerasedRegions(regions),\n             self_ty: self_ty,"}, {"sha": "0dea3460012c199b445db55c4f76b57d5b61360c", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -72,6 +72,7 @@ use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n use syntax::opt_vec::OptVec;\n+use syntax::parse::token;\n use util::ppaux::UserString;\n use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n@@ -479,19 +480,21 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::AddrOfSlice(_) => ~\" for slice expression\",\n             infer::Autoref(_) => ~\" for autoref\",\n             infer::Coercion(_) => ~\" for automatic coercion\",\n-            infer::BoundRegionInFnCall(_, br) => {\n+            infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n-                        bound_region_to_str(self.tcx, \"region \", true, br))\n+                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::BoundRegionInFnType(_, br) => {\n                 format!(\" for {}in function type\",\n-                        bound_region_to_str(self.tcx, \"region \", true, br))\n+                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n             }\n-            infer::BoundRegionInTypeOrImpl(_) => {\n-                format!(\" for region in type/impl\")\n+            infer::EarlyBoundRegion(_, name) => {\n+                format!(\" for lifetime parameter `{}\",\n+                        token::get_name(name).get())\n             }\n-            infer::BoundRegionInCoherence(..) => {\n-                format!(\" for coherence check\")\n+            infer::BoundRegionInCoherence(name) => {\n+                format!(\" for lifetime parameter `{} in coherence check\",\n+                        token::get_name(name).get())\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\","}, {"sha": "ac73c30802557d4d3b9838a1bb79af1025d4b7ab", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -136,11 +136,11 @@ impl<'f> Combine for Glb<'f> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, b);\n         let b_vars = var_ids(self, &b_map);\n "}, {"sha": "7d772065da61e91e3b7f0167ab14b61c3579388f", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -126,10 +126,10 @@ impl<'f> Combine for Lub<'f> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n         let (b_with_fresh, _) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, b);\n \n         // Collect constraints."}, {"sha": "d3ae7d697e69984e051985dbb43bca7eaad54451", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -27,7 +27,7 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n@@ -44,6 +44,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n+use syntax::opt_vec::OptVec;\n use util::common::indent;\n use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n \n@@ -221,19 +222,20 @@ pub enum RegionVariableOrigin {\n     // Regions created as part of an automatic coercion\n     Coercion(TypeTrace),\n \n+    // Region variables created as the values for early-bound regions\n+    EarlyBoundRegion(Span, ast::Name),\n+\n     // Region variables created for bound regions\n     // in a function or method that is called\n-    BoundRegionInFnCall(Span, ty::BoundRegion),\n+    LateBoundRegion(Span, ty::BoundRegion),\n \n     // Region variables created for bound regions\n     // when doing subtyping/lub/glb computations\n     BoundRegionInFnType(Span, ty::BoundRegion),\n \n     UpvarRegion(ty::UpvarId, Span),\n \n-    BoundRegionInTypeOrImpl(Span),\n-\n-    BoundRegionInCoherence,\n+    BoundRegionInCoherence(ast::Name),\n }\n \n pub enum fixup_err {\n@@ -663,6 +665,15 @@ impl InferCtxt {\n         Vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n+    pub fn region_vars_for_defs(&self,\n+                                span: Span,\n+                                defs: &[ty::RegionParameterDef])\n+                                -> OptVec<ty::Region> {\n+        defs.iter()\n+            .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n+            .collect()\n+    }\n+\n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n         self.region_vars.new_bound(binder_id)\n     }\n@@ -809,14 +820,14 @@ impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    pub fn replace_bound_regions_with_fresh_regions(&self,\n-                                                    trace: TypeTrace,\n-                                                    fsig: &ty::FnSig)\n+    pub fn replace_late_bound_regions_with_fresh_regions(&self,\n+                                                         trace: TypeTrace,\n+                                                         fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,\n                                                         HashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n         let (map, fn_sig) =\n-            replace_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n+            replace_late_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\",\n@@ -932,10 +943,10 @@ impl RegionVariableOrigin {\n             AddrOfSlice(a) => a,\n             Autoref(a) => a,\n             Coercion(a) => a.span(),\n-            BoundRegionInFnCall(a, _) => a,\n+            EarlyBoundRegion(a, _) => a,\n+            LateBoundRegion(a, _) => a,\n             BoundRegionInFnType(a, _) => a,\n-            BoundRegionInTypeOrImpl(a) => a,\n-            BoundRegionInCoherence => codemap::DUMMY_SP,\n+            BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n             UpvarRegion(_, a) => a\n         }\n     }\n@@ -950,13 +961,14 @@ impl Repr for RegionVariableOrigin {\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n             Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => format!(\"bound_regionInFnCall({},{})\",\n+            EarlyBoundRegion(a, b) => format!(\"EarlyBoundRegion({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n+            LateBoundRegion(a, b) => format!(\"LateBoundRegion({},{})\",\n+                                             a.repr(tcx), b.repr(tcx)),\n             BoundRegionInFnType(a, b) => format!(\"bound_regionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => format!(\"bound_regionInTypeOrImpl({})\",\n-                                               a.repr(tcx)),\n-            BoundRegionInCoherence => format!(\"bound_regionInCoherence\"),\n+            BoundRegionInCoherence(a) => format!(\"bound_regionInCoherence({})\",\n+                                                 a.repr(tcx)),\n             UpvarRegion(a, b) => format!(\"UpvarRegion({}, {})\",\n                                          a.repr(tcx),\n                                          b.repr(tcx)),"}, {"sha": "2233e680bc99e801d59704012b76a3589b85e1a7", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -12,7 +12,7 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::ty::TyVar;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::glb::Glb;\n@@ -166,13 +166,13 @@ impl<'f> Combine for Sub<'f> {\n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, b_sig) = {\n-            replace_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n+            replace_late_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n                 let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.get_ref().infcx.tcx, \"\", false, br),"}, {"sha": "078415bc644116e3bb1fe5e12ce25740c31e5922", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -78,5 +78,5 @@ pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n                           -> OptVec<ty::Region> {\n     assert!(defs.iter().all(|def| def.def_id.krate == ast::LOCAL_CRATE));\n     defs.iter().enumerate().map(\n-        |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.ident)).collect()\n+        |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.name)).collect()\n }"}, {"sha": "2f06ab67a3bab52811601df67d00c8be0369b054", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -161,8 +161,8 @@ pub fn bound_region_to_str(cx: ctxt,\n     }\n \n     match br {\n-        BrNamed(_, ident)   => format!(\"{}'{}{}\", prefix,\n-                                       token::get_name(ident), space_str),\n+        BrNamed(_, name)   => format!(\"{}'{}{}\", prefix,\n+                                      token::get_name(name), space_str),\n         BrAnon(_)           => prefix.to_str(),\n         BrFresh(_)          => prefix.to_str(),\n     }\n@@ -224,7 +224,7 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n         ty::ReScope(_) => prefix.to_str(),\n-        ty::ReEarlyBound(_, _, ident) => token::get_name(ident).get().to_str(),\n+        ty::ReEarlyBound(_, _, name) => token::get_name(name).get().to_str(),\n         ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n         ty::ReInfer(ReSkolemized(_, br)) => {\n@@ -634,7 +634,7 @@ impl Repr for ty::TypeParameterDef {\n impl Repr for ty::RegionParameterDef {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"RegionParameterDef({}, {:?})\",\n-                token::get_name(self.ident),\n+                token::get_name(self.name),\n                 self.def_id)\n     }\n }\n@@ -720,9 +720,9 @@ impl Repr for ty::BoundRegion {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n-            ty::BrNamed(id, ident) => format!(\"BrNamed({}, {})\",\n-                                               id.repr(tcx),\n-                                               token::get_name(ident)),\n+            ty::BrNamed(id, name) => format!(\"BrNamed({}, {})\",\n+                                             id.repr(tcx),\n+                                             token::get_name(name)),\n             ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n         }\n     }\n@@ -731,9 +731,9 @@ impl Repr for ty::BoundRegion {\n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n-            ty::ReEarlyBound(id, index, ident) => {\n+            ty::ReEarlyBound(id, index, name) => {\n                 format!(\"ReEarlyBound({}, {}, {})\",\n-                        id, index, token::get_name(ident))\n+                        id, index, token::get_name(name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {\n@@ -841,6 +841,12 @@ impl Repr for ty::Method {\n     }\n }\n \n+impl Repr for ast::Name {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        token::get_name(*self).get().to_str()\n+    }\n+}\n+\n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         token::get_ident(*self).get().to_str()\n@@ -1010,6 +1016,12 @@ impl UserString for ty::t {\n     }\n }\n \n+impl UserString for ast::Ident {\n+    fn user_string(&self, _tcx: ctxt) -> ~str {\n+        token::get_name(self.name).get().to_owned()\n+    }\n+}\n+\n impl Repr for AbiSet {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         self.to_str()"}, {"sha": "625cc5bc623463f690f916bec97c7cf8ee6a17a8", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -333,7 +333,7 @@ impl Lifetime {\n \n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self) -> Lifetime {\n-        Lifetime(token::get_name(self.ident).get().to_owned())\n+        Lifetime(token::get_name(self.name).get().to_owned())\n     }\n }\n "}, {"sha": "eed5143b7cff1bfff2b57a8ed63808a52b2f176b", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -64,6 +64,26 @@ impl<T> Vec<T> {\n             xs\n         }\n     }\n+\n+    /**\n+     * Partitions the vector into two vectors `(A,B)`, where all\n+     * elements of `A` satisfy `f` and all elements of `B` do not.\n+     */\n+    #[inline]\n+    pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n+\n+        for elt in self.move_iter() {\n+            if f(&elt) {\n+                lefts.push(elt);\n+            } else {\n+                rights.push(elt);\n+            }\n+        }\n+\n+        (lefts, rights)\n+    }\n }\n \n impl<T: Clone> Vec<T> {"}, {"sha": "b6b18f6671d311a1cb85655586ce97ca4e5e4416", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -118,7 +118,7 @@ pub type FnIdent = Option<Ident>;\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n-    ident: Name\n+    name: Name\n }\n \n // a \"Path\" is essentially Rust's notion of a name;\n@@ -142,7 +142,7 @@ pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     identifier: Ident,\n     /// The lifetime parameters for this path segment.\n-    lifetimes: OptVec<Lifetime>,\n+    lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     types: OptVec<P<Ty>>,\n }\n@@ -187,7 +187,7 @@ pub struct TyParam {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Generics {\n-    lifetimes: OptVec<Lifetime>,\n+    lifetimes: Vec<Lifetime>,\n     ty_params: OptVec<TyParam>,\n }\n \n@@ -795,7 +795,7 @@ impl fmt::Show for Onceness {\n pub struct ClosureTy {\n     sigil: Sigil,\n     region: Option<Lifetime>,\n-    lifetimes: OptVec<Lifetime>,\n+    lifetimes: Vec<Lifetime>,\n     purity: Purity,\n     onceness: Onceness,\n     decl: P<FnDecl>,\n@@ -810,7 +810,7 @@ pub struct ClosureTy {\n pub struct BareFnTy {\n     purity: Purity,\n     abis: AbiSet,\n-    lifetimes: OptVec<Lifetime>,\n+    lifetimes: Vec<Lifetime>,\n     decl: P<FnDecl>\n }\n "}, {"sha": "d45ea2067924bb70a05ca6c3db85d98fe062fb1c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -195,7 +195,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetimes: opt_vec::Empty,\n+                lifetimes: Vec::new(),\n                 types: opt_vec::Empty,\n             }\n         ),\n@@ -311,7 +311,7 @@ pub fn operator_prec(op: ast::BinOp) -> uint {\n pub static as_prec: uint = 12u;\n \n pub fn empty_generics() -> Generics {\n-    Generics {lifetimes: opt_vec::Empty,\n+    Generics {lifetimes: Vec::new(),\n               ty_params: opt_vec::Empty}\n }\n \n@@ -690,10 +690,11 @@ mod test {\n     use ast::*;\n     use super::*;\n     use opt_vec;\n+    use std::vec_ng::Vec;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment {identifier:id.clone(),\n-                     lifetimes: opt_vec::Empty,\n+                     lifetimes: Vec::new(),\n                      types: opt_vec::Empty}\n     }\n "}, {"sha": "6aa90e5e8428adf6de25686075814c0c8cfd4f97", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -42,7 +42,7 @@ pub trait AstBuilder {\n     fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: Vec<ast::Ident> ,\n-                lifetimes: OptVec<ast::Lifetime>,\n+                lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>> )\n         -> ast::Path;\n \n@@ -255,27 +255,27 @@ pub trait AstBuilder {\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, opt_vec::Empty, Vec::new())\n+        self.path_all(span, false, strs, Vec::new(), Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec!(id))\n     }\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, opt_vec::Empty, Vec::new())\n+        self.path_all(span, true, strs, Vec::new(), Vec::new())\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n-                lifetimes: OptVec<ast::Lifetime>,\n+                lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetimes: opt_vec::Empty,\n+                lifetimes: Vec::new(),\n                 types: opt_vec::Empty,\n             }\n         }).collect();\n@@ -342,7 +342,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               self.ident_of(\"option\"),\n                               self.ident_of(\"Option\")\n                           ),\n-                          opt_vec::Empty,\n+                          Vec::new(),\n                           vec!( ty )), None)\n     }\n \n@@ -413,8 +413,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n-    fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime {\n-        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, ident: ident }\n+    fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {\n+        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, name: name }\n     }\n \n     fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt {"}, {"sha": "ee3adb7aad89022dd1523b738329e1cd1b864b9f", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -15,6 +15,7 @@ use ext::base;\n use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n+use std::vec_ng::Vec;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n@@ -51,7 +52,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                  segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetimes: opt_vec::Empty,\n+                        lifetimes: Vec::new(),\n                         types: opt_vec::Empty,\n                     }\n                 )"}, {"sha": "b8ef9d98b2935ba4dc6fe79f019390e951f901dc", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -14,7 +14,6 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n-use opt_vec;\n \n use std::vec_ng::Vec;\n \n@@ -84,7 +83,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n             let rand_name = cx.path_all(trait_span,\n                                         true,\n                                         rand_ident.clone(),\n-                                        opt_vec::Empty,\n+                                        Vec::new(),\n                                         Vec::new());\n             let rand_name = cx.expr_path(rand_name);\n "}, {"sha": "60166f30f1ef9d634cd174780fc44131827bc89b", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -19,7 +19,6 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use opt_vec;\n-use opt_vec::OptVec;\n \n use std::vec_ng::Vec;\n \n@@ -118,11 +117,12 @@ fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifet\n     }\n }\n \n-fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Lifetime> {\n-    match *lt {\n+fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n+    let lifetimes = match *lt {\n         Some(ref s) => opt_vec::with(cx.lifetime(span, cx.ident_of(*s).name)),\n         None => opt_vec::Empty\n-    }\n+    };\n+    opt_vec::take_vec(lifetimes)\n }\n \n impl<'a> Ty<'a> {\n@@ -199,7 +199,7 @@ fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n \n fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -> Generics {\n     Generics {\n-        lifetimes: opt_vec::from(lifetimes),\n+        lifetimes: lifetimes,\n         ty_params: opt_vec::from(ty_params)\n     }\n }"}, {"sha": "0c7b92d0373cc2fd4004f7aea4dbf5bfb3b1640c", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -19,10 +19,10 @@ use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use opt_vec;\n use parse::token;\n \n use std::os;\n+use std::vec_ng::Vec;\n \n pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n@@ -38,7 +38,7 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                    vec!(cx.ident_of(\"std\"),\n                                         cx.ident_of(\"option\"),\n                                         cx.ident_of(\"None\")),\n-                                   opt_vec::Empty,\n+                                   Vec::new(),\n                                    vec!(cx.ty_rptr(sp,\n                                                    cx.ty_ident(sp,\n                                                         cx.ident_of(\"str\")),"}, {"sha": "0db948c30b7c4ad0fc60d5086a6c02f4f9d04762", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -14,7 +14,6 @@ use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use opt_vec;\n use parse::token::InternedString;\n use parse::token;\n use rsparse = parse;\n@@ -509,7 +508,7 @@ impl<'a> Context<'a> {\n                 sp,\n                 true,\n                 self.rtpath(\"Method\"),\n-                opt_vec::with(life),\n+                vec!(life),\n                 Vec::new()\n                     ), None);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n@@ -632,8 +631,8 @@ impl<'a> Context<'a> {\n                     self.ecx.ident_of(\"fmt\"),\n                     self.ecx.ident_of(\"rt\"),\n                     self.ecx.ident_of(\"Piece\")),\n-                opt_vec::with(\n-                    self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\").name)),\n+                vec!(self.ecx.lifetime(self.fmtsp,\n+                                       self.ecx.ident_of(\"static\").name)),\n                 Vec::new()\n             ), None);\n         let ty = ast::TyFixedLengthVec("}, {"sha": "0b56cd07c887ffdb17a3f6e5b2ea557d578a5ba7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -435,12 +435,12 @@ pub fn fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n-        ident: l.ident\n+        name: l.name\n     }\n }\n \n-pub fn fold_lifetimes<T: Folder>(lts: &OptVec<Lifetime>, fld: &mut T)\n-                                   -> OptVec<Lifetime> {\n+pub fn fold_lifetimes<T: Folder>(lts: &Vec<Lifetime>, fld: &mut T)\n+                                   -> Vec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n "}, {"sha": "cb49ad0905cdaf96795aef68a2de76bb165d51ab", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -323,7 +323,7 @@ mod test {\n                         segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetimes: opt_vec::Empty,\n+                                lifetimes: Vec::new(),\n                                 types: opt_vec::Empty,\n                             }\n                         ),\n@@ -342,12 +342,12 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetimes: opt_vec::Empty,\n+                                    lifetimes: Vec::new(),\n                                     types: opt_vec::Empty,\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: opt_vec::Empty,\n+                                    lifetimes: Vec::new(),\n                                     types: opt_vec::Empty,\n                                 }\n                             )\n@@ -556,7 +556,7 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetimes: opt_vec::Empty,\n+                                    lifetimes: Vec::new(),\n                                     types: opt_vec::Empty,\n                                 }\n                             ),\n@@ -578,7 +578,7 @@ mod test {\n                                segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: opt_vec::Empty,\n+                                    lifetimes: Vec::new(),\n                                     types: opt_vec::Empty,\n                                 }\n                                ),\n@@ -605,7 +605,7 @@ mod test {\n                                     segments: vec!(\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n-                                            lifetimes: opt_vec::Empty,\n+                                            lifetimes: Vec::new(),\n                                             types: opt_vec::Empty,\n                                         }\n                                     ),\n@@ -633,7 +633,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetimes: opt_vec::Empty,\n+                                                lifetimes: Vec::new(),\n                                                 types: opt_vec::Empty,\n                                             }\n                                         ),\n@@ -651,7 +651,7 @@ mod test {\n                                                     ast::PathSegment {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n-                                                        lifetimes: opt_vec::Empty,\n+                                                        lifetimes: Vec::new(),\n                                                         types: opt_vec::Empty,\n                                                     }\n                                                 ),\n@@ -671,7 +671,7 @@ mod test {\n                                     ast::ImpureFn,\n                                     abi::AbiSet::Rust(),\n                                     ast::Generics{ // no idea on either of these:\n-                                        lifetimes: opt_vec::Empty,\n+                                        lifetimes: Vec::new(),\n                                         ty_params: opt_vec::Empty,\n                                     },\n                                     ast::P(ast::Block {\n@@ -689,7 +689,7 @@ mod test {\n                                                                 str_to_ident(\n                                                                     \"b\"),\n                                                                 lifetimes:\n-                                                                opt_vec::Empty,\n+                                                                Vec::new(),\n                                                                 types:\n                                                                 opt_vec::Empty\n                                                             }"}, {"sha": "7760ca89eb2711ce03697b78a766922fae1f9f5c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -958,7 +958,7 @@ impl Parser {\n \n                     lifetimes\n                 } else {\n-                    opt_vec::Empty\n+                    Vec::new()\n                 };\n \n                 let inputs = if self.eat(&token::OROR) {\n@@ -1015,7 +1015,7 @@ impl Parser {\n \n     // parse a function type (following the 'fn')\n     pub fn parse_ty_fn_decl(&mut self, allow_variadic: bool)\n-                            -> (P<FnDecl>, OptVec<ast::Lifetime>) {\n+                            -> (P<FnDecl>, Vec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -1031,7 +1031,7 @@ impl Parser {\n             self.expect_gt();\n             lifetimes\n         } else {\n-            opt_vec::Empty\n+            Vec::new()\n         };\n \n         let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n@@ -1510,7 +1510,7 @@ impl Parser {\n                 segments.push(PathSegmentAndBoundSet {\n                     segment: ast::PathSegment {\n                         identifier: identifier,\n-                        lifetimes: opt_vec::Empty,\n+                        lifetimes: Vec::new(),\n                         types: opt_vec::Empty,\n                     },\n                     bound_set: bound_set\n@@ -1525,7 +1525,7 @@ impl Parser {\n                         self.parse_generic_values_after_lt();\n                     (true, lifetimes, opt_vec::from(types))\n                 } else {\n-                    (false, opt_vec::Empty, opt_vec::Empty)\n+                    (false, Vec::new(), opt_vec::Empty)\n                 }\n             };\n \n@@ -1609,7 +1609,7 @@ impl Parser {\n                 return ast::Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,\n-                    ident: i.name\n+                    name: i.name\n                 };\n             }\n             _ => {\n@@ -1621,7 +1621,7 @@ impl Parser {\n     // matches lifetimes = ( lifetime ) | ( lifetime , lifetimes )\n     // actually, it matches the empty one too, but putting that in there\n     // messes up the grammar....\n-    pub fn parse_lifetimes(&mut self) -> OptVec<ast::Lifetime> {\n+    pub fn parse_lifetimes(&mut self) -> Vec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -1630,7 +1630,7 @@ impl Parser {\n          * lists, where we expect something like `<'a, 'b, T>`.\n          */\n \n-        let mut res = opt_vec::Empty;\n+        let mut res = Vec::new();\n         loop {\n             match self.token {\n                 token::LIFETIME(_) => {\n@@ -1995,7 +1995,7 @@ impl Parser {\n                         self.expect(&token::LT);\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        (opt_vec::Empty, Vec::new())\n+                        (Vec::new(), Vec::new())\n                     };\n \n                     // expr.f() method call\n@@ -3515,7 +3515,7 @@ impl Parser {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, Vec<P<Ty>> ) {\n+    fn parse_generic_values_after_lt(&mut self) -> (Vec<ast::Lifetime>, Vec<P<Ty>> ) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n@@ -4886,7 +4886,7 @@ impl Parser {\n                 segments: path.move_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetimes: opt_vec::Empty,\n+                        lifetimes: Vec::new(),\n                         types: opt_vec::Empty,\n                     }\n                 }).collect()\n@@ -4921,7 +4921,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: opt_vec::Empty,\n+                                lifetimes: Vec::new(),\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4939,7 +4939,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: opt_vec::Empty,\n+                                lifetimes: Vec::new(),\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4961,7 +4961,7 @@ impl Parser {\n             segments: path.move_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetimes: opt_vec::Empty,\n+                    lifetimes: Vec::new(),\n                     types: opt_vec::Empty,\n                 }\n             }).collect()"}, {"sha": "45ab4c6956a49bb7bd36e3f5326d11d864c09b4c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -1956,7 +1956,7 @@ pub fn print_bounds(s: &mut State, bounds: &OptVec<ast::TyParamBound>,\n pub fn print_lifetime(s: &mut State,\n                       lifetime: &ast::Lifetime) -> io::IoResult<()> {\n     try!(word(&mut s.s, \"'\"));\n-    print_name(s, lifetime.ident)\n+    print_name(s, lifetime.name)\n }\n \n pub fn print_generics(s: &mut State,"}, {"sha": "538528fb1484a79aa4f91447577cdf414bd22d91", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -15,6 +15,7 @@ use codemap::Span;\n use parse;\n use opt_vec;\n use opt_vec::OptVec;\n+use std::vec_ng::Vec;\n \n // Context-passing AST walker. Each overridden visit method has full control\n // over what happens with its node, it can do its own traversal of the node's\n@@ -55,7 +56,7 @@ pub fn generics_of_fn(fk: &FnKind) -> Generics {\n         }\n         FkFnBlock(..) => {\n             Generics {\n-                lifetimes: opt_vec::Empty,\n+                lifetimes: Vec::new(),\n                 ty_params: opt_vec::Empty,\n             }\n         }\n@@ -370,7 +371,7 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n }\n \n fn walk_lifetime_decls<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                lifetimes: &OptVec<Lifetime>,\n+                                                lifetimes: &Vec<Lifetime>,\n                                                 env: E) {\n     for l in lifetimes.iter() {\n         visitor.visit_lifetime_decl(l, env.clone());"}, {"sha": "9c8f8f8c30cc5b0fbe52bfe224e1887bea4f2013", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a> {\n+    fn get(&self) -> &'a int;\n+}\n+\n+struct Box<'a> {\n+    t: &'a int\n+}\n+\n+impl<'a> GetRef<'a> for Box<'a> {\n+    fn get(&self) -> &'a int {\n+        self.t\n+    }\n+}\n+\n+impl<'a> Box<'a> {\n+    fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a int {\n+        g2.get() //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "9cff4849cbeb2b6bf339c38062376f276bcd7a98", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a, T> {\n+    fn get(&self) -> &'a T;\n+}\n+\n+struct Box<'a, T> {\n+    t: &'a T\n+}\n+\n+impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n+    fn get(&self) -> &'a T {\n+        self.t\n+    }\n+}\n+\n+fn get<'a,'b,G:GetRef<'a, int>>(g1: G, b: &'b int) -> &'b int {\n+    g1.get() //~ ERROR lifetime mismatch\n+}\n+\n+fn main() {\n+}"}, {"sha": "c011d11749b60318f4bd859881bce3300813fd6c", "filename": "src/test/run-pass/regions-early-bound-used-in-bound-method.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a> {\n+    fn get(&self) -> &'a int;\n+}\n+\n+struct Box<'a> {\n+    t: &'a int\n+}\n+\n+impl<'a> GetRef<'a> for Box<'a> {\n+    fn get(&self) -> &'a int {\n+        self.t\n+    }\n+}\n+\n+impl<'a> Box<'a> {\n+    fn add<'b,G:GetRef<'b>>(&self, g2: G) -> int {\n+        *self.t + *g2.get()\n+    }\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(b1.add(b1), 6);\n+}"}, {"sha": "22ea87c8d2809009b07aa7779eb4119cacb00fe1", "filename": "src/test/run-pass/regions-early-bound-used-in-bound.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a, T> {\n+    fn get(&self) -> &'a T;\n+}\n+\n+struct Box<'a, T> {\n+    t: &'a T\n+}\n+\n+impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n+    fn get(&self) -> &'a T {\n+        self.t\n+    }\n+}\n+\n+fn add<'a,G:GetRef<'a, int>>(g1: G, g2: G) -> int {\n+    *g1.get() + *g2.get()\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(add(b1, b1), 6);\n+}"}, {"sha": "592f48223938584194a19a5fb0a59d67cf37819c", "filename": "src/test/run-pass/regions-early-bound-used-in-type-param.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e5135358ed462757d84504872aa92312769060/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs?ref=c2e5135358ed462757d84504872aa92312769060", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+struct Box<T> {\n+    t: T\n+}\n+\n+impl<T:Clone> Get<T> for Box<T> {\n+    fn get(&self) -> T {\n+        self.t.clone()\n+    }\n+}\n+\n+fn add<'a,G:Get<&'a int>>(g1: G, g2: G) -> int {\n+    *g1.get() + *g2.get()\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(add(b1, b1), 6);\n+}"}]}