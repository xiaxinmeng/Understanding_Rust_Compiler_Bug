{"sha": "7e1901537c1bccf323a2e33644b56b6a589ab388", "node_id": "C_kwDOAAsO6NoAKDdlMTkwMTUzN2MxYmNjZjMyM2EyZTMzNjQ0YjU2YjZhNTg5YWIzODg", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-06-08T13:39:04Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-06-08T13:39:04Z"}, "message": "add `check_invariants` method", "tree": {"sha": "7ad01cfe486877fec306cb3cf462a704ad656bbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ad01cfe486877fec306cb3cf462a704ad656bbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e1901537c1bccf323a2e33644b56b6a589ab388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1901537c1bccf323a2e33644b56b6a589ab388", "html_url": "https://github.com/rust-lang/rust/commit/7e1901537c1bccf323a2e33644b56b6a589ab388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e1901537c1bccf323a2e33644b56b6a589ab388/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8db6d4bae2ec0551ee091fe345525532d9a03eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8db6d4bae2ec0551ee091fe345525532d9a03eb3", "html_url": "https://github.com/rust-lang/rust/commit/8db6d4bae2ec0551ee091fe345525532d9a03eb3"}], "stats": {"total": 40, "additions": 33, "deletions": 7}, "files": [{"sha": "b444fb724e855f7a63accbb49fcfbaca52fe61c6", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7e1901537c1bccf323a2e33644b56b6a589ab388/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1901537c1bccf323a2e33644b56b6a589ab388/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=7e1901537c1bccf323a2e33644b56b6a589ab388", "patch": "@@ -11,6 +11,10 @@ use smallvec::SmallVec;\n mod tests;\n \n /// Stores a set of intervals on the indices.\n+///\n+/// The elements in `map` are sorted and non-adjacent, which means\n+/// the second value of the previous element is *greater* than the\n+/// first value of the following element.\n #[derive(Debug, Clone)]\n pub struct IntervalSet<I> {\n     // Start, end\n@@ -84,7 +88,7 @@ impl<I: Idx> IntervalSet<I> {\n         // continue to the next range. We're looking here for the first\n         // range which starts *non-adjacently* to our end.\n         let next = self.map.partition_point(|r| r.0 <= end + 1);\n-        if let Some(right) = next.checked_sub(1) {\n+        let result = if let Some(right) = next.checked_sub(1) {\n             let (prev_start, prev_end) = self.map[right];\n             if prev_end + 1 >= start {\n                 // If the start for the inserted range is adjacent to the\n@@ -99,25 +103,25 @@ impl<I: Idx> IntervalSet<I> {\n                     if left != right {\n                         self.map.drain(left..right);\n                     }\n-                    return true;\n+                    true\n                 } else {\n                     // We overlap with the previous range, increase it to\n                     // include us.\n                     //\n                     // Make sure we're actually going to *increase* it though --\n                     // it may be that end is just inside the previously existing\n                     // set.\n-                    return if end > prev_end {\n+                    if end > prev_end {\n                         self.map[right].1 = end;\n                         true\n                     } else {\n                         false\n-                    };\n+                    }\n                 }\n             } else {\n                 // Otherwise, we don't overlap, so just insert\n                 self.map.insert(right + 1, (start, end));\n-                return true;\n+                true\n             }\n         } else {\n             if self.map.is_empty() {\n@@ -127,8 +131,16 @@ impl<I: Idx> IntervalSet<I> {\n             } else {\n                 self.map.insert(next, (start, end));\n             }\n-            return true;\n-        }\n+            true\n+        };\n+        debug_assert!(\n+            self.check_invariants(),\n+            \"wrong intervals after insert {:?}..={:?} to {:?}\",\n+            start,\n+            end,\n+            self\n+        );\n+        result\n     }\n \n     pub fn contains(&self, needle: I) -> bool {\n@@ -192,6 +204,7 @@ impl<I: Idx> IntervalSet<I> {\n     pub fn insert_all(&mut self) {\n         self.clear();\n         self.map.push((0, self.domain.try_into().unwrap()));\n+        debug_assert!(self.check_invariants());\n     }\n \n     pub fn union(&mut self, other: &IntervalSet<I>) -> bool\n@@ -203,8 +216,21 @@ impl<I: Idx> IntervalSet<I> {\n         for range in other.iter_intervals() {\n             did_insert |= self.insert_range(range);\n         }\n+        debug_assert!(self.check_invariants());\n         did_insert\n     }\n+\n+    // Check the intervals are valid, sorted and non-adjacent\n+    fn check_invariants(&self) -> bool {\n+        let mut current: Option<u32> = None;\n+        for (start, end) in &self.map {\n+            if start > end || current.map_or(false, |x| x + 1 >= *start) {\n+                return false;\n+            }\n+            current = Some(*end);\n+        }\n+        current.map_or(true, |x| x < self.domain as u32)\n+    }\n }\n \n /// This data structure optimizes for cases where the stored bits in each row"}]}