{"sha": "c45dda92feedaaed22bd9d74ec24164dc206da44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NWRkYTkyZmVlZGFhZWQyMmJkOWQ3NGVjMjQxNjRkYzIwNmRhNDQ=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-02-07T17:27:43Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-04-26T13:50:29Z"}, "message": "rustc_target: move for_variant and field TyLayout methods to a trait.", "tree": {"sha": "3d10cd4a0c13984316ea890f08891b0e95ad8541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d10cd4a0c13984316ea890f08891b0e95ad8541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c45dda92feedaaed22bd9d74ec24164dc206da44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c45dda92feedaaed22bd9d74ec24164dc206da44", "html_url": "https://github.com/rust-lang/rust/commit/c45dda92feedaaed22bd9d74ec24164dc206da44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c45dda92feedaaed22bd9d74ec24164dc206da44/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a5147616b16b78a65d80f13b85c3010131d3b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a5147616b16b78a65d80f13b85c3010131d3b7a", "html_url": "https://github.com/rust-lang/rust/commit/7a5147616b16b78a65d80f13b85c3010131d3b7a"}], "stats": {"total": 179, "additions": 98, "deletions": 81}, "files": [{"sha": "f7ac25a0db09031388c008cb64bc46f2a98952cd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 39, "deletions": 80, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c45dda92feedaaed22bd9d74ec24164dc206da44/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45dda92feedaaed22bd9d74ec24164dc206da44/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c45dda92feedaaed22bd9d74ec24164dc206da44", "patch": "@@ -19,7 +19,7 @@ use std::cmp;\n use std::fmt;\n use std::i128;\n use std::mem;\n-use std::ops::{Deref, RangeInclusive};\n+use std::ops::RangeInclusive;\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -801,9 +801,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                     if let Some(i) = dataful_variant {\n                         let count = (niche_variants.end - niche_variants.start + 1) as u128;\n-                        for (field_index, field) in variants[i].iter().enumerate() {\n+                        for (field_index, &field) in variants[i].iter().enumerate() {\n                             let (offset, niche, niche_start) =\n-                                match field.find_niche(self, count)? {\n+                                match self.find_niche(field, count)? {\n                                     Some(niche) => niche,\n                                     None => continue\n                                 };\n@@ -1300,26 +1300,6 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n     }\n }\n \n-/// The details of the layout of a type, alongside the type itself.\n-/// Provides various type traversal APIs (e.g. recursing into fields).\n-///\n-/// Note that the details are NOT guaranteed to always be identical\n-/// to those obtained from `layout_of(ty)`, as we need to produce\n-/// layouts for which Rust types do not exist, such as enum variants\n-/// or synthetic fields of enums (i.e. discriminants) and fat pointers.\n-#[derive(Copy, Clone, Debug)]\n-pub struct TyLayout<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    details: &'tcx LayoutDetails\n-}\n-\n-impl<'tcx> Deref for TyLayout<'tcx> {\n-    type Target = &'tcx LayoutDetails;\n-    fn deref(&self) -> &&'tcx LayoutDetails {\n-        &self.details\n-    }\n-}\n-\n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n }\n@@ -1371,6 +1351,8 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n     }\n }\n \n+pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n+\n impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n@@ -1458,22 +1440,22 @@ impl<'a, 'tcx> ty::maps::TyCtxtAt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyLayout<'tcx> {\n-    pub fn for_variant<C>(&self, cx: C, variant_index: usize) -> Self\n-        where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n-              C::TyLayout: MaybeResult<TyLayout<'tcx>>\n-    {\n-        let details = match self.variants {\n-            Variants::Single { index } if index == variant_index => self.details,\n+impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx> \n+    where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n+          C::TyLayout: MaybeResult<TyLayout<'tcx>>\n+{\n+    fn for_variant(this: TyLayout<'tcx>, cx: C, variant_index: usize) -> TyLayout<'tcx> {\n+        let details = match this.variants {\n+            Variants::Single { index } if index == variant_index => this.details,\n \n             Variants::Single { index } => {\n                 // Deny calling for_variant more than once for non-Single enums.\n-                cx.layout_of(self.ty).map_same(|layout| {\n+                cx.layout_of(this.ty).map_same(|layout| {\n                     assert_eq!(layout.variants, Variants::Single { index });\n                     layout\n                 });\n \n-                let fields = match self.ty.sty {\n+                let fields = match this.ty.sty {\n                     ty::TyAdt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!()\n                 };\n@@ -1491,17 +1473,14 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         assert_eq!(details.variants, Variants::Single { index: variant_index });\n \n         TyLayout {\n-            ty: self.ty,\n+            ty: this.ty,\n             details\n         }\n     }\n \n-    pub fn field<C>(&self, cx: C, i: usize) -> C::TyLayout\n-        where C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n-              C::TyLayout: MaybeResult<TyLayout<'tcx>>\n-    {\n+    fn field(this: TyLayout<'tcx>, cx: C, i: usize) -> C::TyLayout {\n         let tcx = cx.tcx();\n-        cx.layout_of(match self.ty.sty {\n+        cx.layout_of(match this.ty.sty {\n             ty::TyBool |\n             ty::TyChar |\n             ty::TyInt(_) |\n@@ -1513,7 +1492,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TyGeneratorWitness(..) |\n             ty::TyForeign(..) |\n             ty::TyDynamic(..) => {\n-                bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+                bug!(\"TyLayout::field_type({:?}): not applicable\", this)\n             }\n \n             // Potentially-fat pointers.\n@@ -1527,13 +1506,13 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                 // as the `Abi` or `FieldPlacement` is checked by users.\n                 if i == 0 {\n                     let nil = tcx.mk_nil();\n-                    let ptr_ty = if self.ty.is_unsafe_ptr() {\n+                    let ptr_ty = if this.ty.is_unsafe_ptr() {\n                         tcx.mk_mut_ptr(nil)\n                     } else {\n                         tcx.mk_mut_ref(tcx.types.re_static, nil)\n                     };\n                     return cx.layout_of(ptr_ty).map_same(|mut ptr_layout| {\n-                        ptr_layout.ty = self.ty;\n+                        ptr_layout.ty = this.ty;\n                         ptr_layout\n                     });\n                 }\n@@ -1546,7 +1525,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                         // the correct number of vtables slots.\n                         tcx.mk_imm_ref(tcx.types.re_static, tcx.mk_nil())\n                     }\n-                    _ => bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+                    _ => bug!(\"TyLayout::field_type({:?}): not applicable\", this)\n                 }\n             }\n \n@@ -1568,12 +1547,12 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n-                self.ty.simd_type(tcx)\n+                this.ty.simd_type(tcx)\n             }\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                match self.variants {\n+                match this.variants {\n                     Variants::Single { index } => {\n                         def.variants[index].fields[i].ty(tcx, substs)\n                     }\n@@ -1593,45 +1572,25 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n             ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n             ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"TyLayout::field_type: unexpected type `{}`\", self.ty)\n+                bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty)\n             }\n         })\n     }\n+}\n \n-    /// Returns true if the layout corresponds to an unsized type.\n-    pub fn is_unsized(&self) -> bool {\n-        self.abi.is_unsized()\n-    }\n-\n-    /// Returns true if the type is a ZST and not unsized.\n-    pub fn is_zst(&self) -> bool {\n-        match self.abi {\n-            Abi::Uninhabited => true,\n-            Abi::Scalar(_) |\n-            Abi::ScalarPair(..) |\n-            Abi::Vector { .. } => false,\n-            Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n-        }\n-    }\n-\n-    pub fn size_and_align(&self) -> (Size, Align) {\n-        (self.size, self.align)\n-    }\n-\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates, which\n     /// has at least `count` consecutive invalid values.\n     /// The tuple is `(offset, scalar, niche_value)`.\n     // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche<C>(&self, cx: C, count: u128)\n+    fn find_niche(self, layout: TyLayout<'tcx>, count: u128)\n         -> Result<Option<(Size, Scalar, u128)>, LayoutError<'tcx>>\n-        where C: LayoutOf<Ty = Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n-                 HasTyCtxt<'tcx>\n     {\n         let scalar_component = |scalar: &Scalar, offset| {\n             let Scalar { value, valid_range: ref v } = *scalar;\n \n-            let bits = value.size(cx).bits();\n+            let bits = value.size(self).bits();\n             assert!(bits <= 128);\n             let max_value = !0u128 >> (128 - bits);\n \n@@ -1658,17 +1617,17 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         // Locals variables which live across yields are stored\n         // in the generator type as fields. These may be uninitialized\n         // so we don't look for niches there.\n-        if let ty::TyGenerator(..) = self.ty.sty {\n+        if let ty::TyGenerator(..) = layout.ty.sty {\n             return Ok(None);\n         }\n \n-        match self.abi {\n+        match layout.abi {\n             Abi::Scalar(ref scalar) => {\n                 return Ok(scalar_component(scalar, Size::from_bytes(0)));\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n                 return Ok(scalar_component(a, Size::from_bytes(0)).or_else(|| {\n-                    scalar_component(b, a.value.size(cx).abi_align(b.value.align(cx)))\n+                    scalar_component(b, a.value.size(self).abi_align(b.value.align(self)))\n                 }));\n             }\n             Abi::Vector { ref element, .. } => {\n@@ -1678,22 +1637,22 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n \n         // Perhaps one of the fields is non-zero, let's recurse and find out.\n-        if let FieldPlacement::Union(_) = self.fields {\n+        if let FieldPlacement::Union(_) = layout.fields {\n             // Only Rust enums have safe-to-inspect fields\n             // (a discriminant), other unions are unsafe.\n-            if let Variants::Single { .. } = self.variants {\n+            if let Variants::Single { .. } = layout.variants {\n                 return Ok(None);\n             }\n         }\n-        if let FieldPlacement::Array { .. } = self.fields {\n-            if self.fields.count() > 0 {\n-                return self.field(cx, 0)?.find_niche(cx, count);\n+        if let FieldPlacement::Array { .. } = layout.fields {\n+            if layout.fields.count() > 0 {\n+                return self.find_niche(layout.field(self, 0)?, count);\n             }\n         }\n-        for i in 0..self.fields.count() {\n-            let r = self.field(cx, i)?.find_niche(cx, count)?;\n+        for i in 0..layout.fields.count() {\n+            let r = self.find_niche(layout.field(self, i)?, count)?;\n             if let Some((offset, scalar, niche_value)) = r {\n-                let offset = self.fields.offset(i) + offset;\n+                let offset = layout.fields.offset(i) + offset;\n                 return Ok(Some((offset, scalar, niche_value)));\n             }\n         }"}, {"sha": "cc3fd3e0cdd1e0f429a593510054314c77dafc88", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c45dda92feedaaed22bd9d74ec24164dc206da44/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45dda92feedaaed22bd9d74ec24164dc206da44/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=c45dda92feedaaed22bd9d74ec24164dc206da44", "patch": "@@ -14,7 +14,7 @@ pub use self::Primitive::*;\n use spec::Target;\n \n use std::cmp;\n-use std::ops::{Add, Sub, Mul, AddAssign, RangeInclusive};\n+use std::ops::{Add, Deref, Sub, Mul, AddAssign, RangeInclusive};\n \n pub mod call;\n \n@@ -757,9 +757,67 @@ impl LayoutDetails {\n     }\n }\n \n+/// The details of the layout of a type, alongside the type itself.\n+/// Provides various type traversal APIs (e.g. recursing into fields).\n+///\n+/// Note that the details are NOT guaranteed to always be identical\n+/// to those obtained from `layout_of(ty)`, as we need to produce\n+/// layouts for which Rust types do not exist, such as enum variants\n+/// or synthetic fields of enums (i.e. discriminants) and fat pointers.\n+#[derive(Copy, Clone, Debug)]\n+pub struct TyLayout<'a, Ty> {\n+    pub ty: Ty,\n+    pub details: &'a LayoutDetails\n+}\n+\n+impl<'a, Ty> Deref for TyLayout<'a, Ty> {\n+    type Target = &'a LayoutDetails;\n+    fn deref(&self) -> &&'a LayoutDetails {\n+        &self.details\n+    }\n+}\n+\n pub trait LayoutOf {\n     type Ty;\n     type TyLayout;\n \n     fn layout_of(self, ty: Self::Ty) -> Self::TyLayout;\n }\n+\n+pub trait TyLayoutMethods<'a, C: LayoutOf>: Sized {\n+    fn for_variant(this: TyLayout<'a, Self>, cx: C, variant_index: usize) -> TyLayout<'a, Self>;\n+    fn field(this: TyLayout<'a, Self>, cx: C, i: usize) -> C::TyLayout;\n+}\n+\n+impl<'a, Ty> TyLayout<'a, Ty> {\n+    pub fn for_variant<C>(self, cx: C, variant_index: usize) -> Self\n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf {\n+        Ty::for_variant(self, cx, variant_index)\n+    }\n+    pub fn field<C>(self, cx: C, i: usize) -> C::TyLayout \n+    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf {\n+        Ty::field(self, cx, i)\n+    }\n+}\n+\n+impl<'a, Ty> TyLayout<'a, Ty> {\n+    /// Returns true if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        self.abi.is_unsized()\n+    }\n+\n+    /// Returns true if the type is a ZST and not unsized.\n+    pub fn is_zst(&self) -> bool {\n+        match self.abi {\n+            Abi::Uninhabited => true,\n+            Abi::Scalar(_) |\n+            Abi::ScalarPair(..) |\n+            Abi::Vector { .. } => false,\n+            Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n+        }\n+    }\n+\n+    pub fn size_and_align(&self) -> (Size, Align) {\n+        (self.size, self.align)\n+    }\n+}\n\\ No newline at end of file"}]}