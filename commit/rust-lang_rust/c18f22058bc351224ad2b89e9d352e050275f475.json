{"sha": "c18f22058bc351224ad2b89e9d352e050275f475", "node_id": "C_kwDOAAsO6NoAKGMxOGYyMjA1OGJjMzUxMjI0YWQyYjg5ZTlkMzUyZTA1MDI3NWY0NzU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-09T17:20:49Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-09T17:20:49Z"}, "message": "Rename integer log* methods to ilog*\n\nThis reflects the concensus from the libs team as reported at\nhttps://github.com/rust-lang/rust/issues/70887#issuecomment-1209513261\n\nCo-authored-by: Yosh Wuyts <github@yosh.is>", "tree": {"sha": "b8ac9c71955cce1a4f47bf5e1e2d716b7240d576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8ac9c71955cce1a4f47bf5e1e2d716b7240d576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c18f22058bc351224ad2b89e9d352e050275f475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c18f22058bc351224ad2b89e9d352e050275f475", "html_url": "https://github.com/rust-lang/rust/commit/c18f22058bc351224ad2b89e9d352e050275f475", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c18f22058bc351224ad2b89e9d352e050275f475/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4dd6fc9f1a5c798df269933c7e442b79661a86", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4dd6fc9f1a5c798df269933c7e442b79661a86", "html_url": "https://github.com/rust-lang/rust/commit/cc4dd6fc9f1a5c798df269933c7e442b79661a86"}], "stats": {"total": 264, "additions": 132, "deletions": 132}, "files": [{"sha": "3c01e2998cd2f02d4a5c2e8fe49a3fd402793467", "filename": "library/core/benches/num/int_log/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -9,7 +9,7 @@ macro_rules! int_log_bench {\n                 for n in 0..(<$t>::BITS / 8) {\n                     for i in 1..=(100 as $t) {\n                         let x = black_box(i << (n * 8));\n-                        black_box(x.log10());\n+                        black_box(x.ilog10());\n                     }\n                 }\n             });\n@@ -27,7 +27,7 @@ macro_rules! int_log_bench {\n                 .collect();\n             bench.iter(|| {\n                 for x in &numbers {\n-                    black_box(black_box(x).log10());\n+                    black_box(black_box(x).ilog10());\n                 }\n             });\n         }\n@@ -44,7 +44,7 @@ macro_rules! int_log_bench {\n                 .collect();\n             bench.iter(|| {\n                 for x in &numbers {\n-                    black_box(black_box(x).log10());\n+                    black_box(black_box(x).ilog10());\n                 }\n             });\n         }"}, {"sha": "d2a21b6b38260770323a2d68b39bc0471b09c47b", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -137,7 +137,7 @@ macro_rules! define_bignum {\n                 // Find the most significant non-zero digit.\n                 let msd = digits.iter().rposition(|&x| x != 0);\n                 match msd {\n-                    Some(msd) => msd * digitbits + digits[msd].log2() as usize + 1,\n+                    Some(msd) => msd * digitbits + digits[msd].ilog2() as usize + 1,\n                     // There are no non-zero digits, i.e., the number is zero.\n                     _ => 0,\n                 }"}, {"sha": "92b12ed33528db86c9cf897d785bc6347bf72353", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -2204,7 +2204,7 @@ macro_rules! int_impl {\n         /// rounded down.\n         ///\n         /// This method might not be optimized owing to implementation details;\n-        /// `log2` can produce results more efficiently for base 2, and `log10`\n+        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n         /// can produce results more efficiently for base 10.\n         ///\n         /// # Panics\n@@ -2217,7 +2217,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -2226,8 +2226,8 @@ macro_rules! int_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log(self, base: Self) -> u32 {\n-            match self.checked_log(base) {\n+        pub const fn ilog(self, base: Self) -> u32 {\n+            match self.checked_ilog(base) {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -2250,7 +2250,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -2259,8 +2259,8 @@ macro_rules! int_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log2(self) -> u32 {\n-            match self.checked_log2() {\n+        pub const fn ilog2(self) -> u32 {\n+            match self.checked_ilog2() {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -2283,7 +2283,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -2292,8 +2292,8 @@ macro_rules! int_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log10(self) -> u32 {\n-            match self.checked_log10() {\n+        pub const fn ilog10(self) -> u32 {\n+            match self.checked_ilog10() {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -2311,20 +2311,20 @@ macro_rules! int_impl {\n         /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n         ///\n         /// This method might not be optimized owing to implementation details;\n-        /// `checked_log2` can produce results more efficiently for base 2, and\n-        /// `checked_log10` can produce results more efficiently for base 10.\n+        /// `checked_ilog2` can produce results more efficiently for base 2, and\n+        /// `checked_ilog10` can produce results more efficiently for base 10.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log(self, base: Self) -> Option<u32> {\n+        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n             if self <= 0 || base <= 1 {\n                 None\n             } else {\n@@ -2333,7 +2333,7 @@ macro_rules! int_impl {\n \n                 // Optimization for 128 bit wide integers.\n                 if Self::BITS == 128 {\n-                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    let b = Self::ilog2(self) / (Self::ilog2(base) + 1);\n                     n += b;\n                     r /= base.pow(b as u32);\n                 }\n@@ -2354,13 +2354,13 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log2(self) -> Option<u32> {\n+        pub const fn checked_ilog2(self) -> Option<u32> {\n             if self <= 0 {\n                 None\n             } else {\n@@ -2378,13 +2378,13 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log10(self) -> Option<u32> {\n+        pub const fn checked_ilog10(self) -> Option<u32> {\n             if self > 0 {\n                 Some(int_log10::$ActualT(self as $ActualT))\n             } else {"}, {"sha": "6196c4da4e32928670529a82433ff98baaea50ba", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -450,7 +450,7 @@ macro_rules! nonzero_unsigned_operations {\n                 /// Returns the base 2 logarithm of the number, rounded down.\n                 ///\n                 /// This is the same operation as\n-                #[doc = concat!(\"[`\", stringify!($Int), \"::log2`],\")]\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::ilog2`],\")]\n                 /// except that it has no failure cases to worry about\n                 /// since this value can never be zero.\n                 ///\n@@ -460,22 +460,22 @@ macro_rules! nonzero_unsigned_operations {\n                 /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().log2(), 2);\")]\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().log2(), 3);\")]\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().log2(), 3);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().ilog2(), 2);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().ilog2(), 3);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().ilog2(), 3);\")]\n                 /// ```\n                 #[unstable(feature = \"int_log\", issue = \"70887\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n-                pub const fn log2(self) -> u32 {\n+                pub const fn ilog2(self) -> u32 {\n                     Self::BITS - 1 - self.leading_zeros()\n                 }\n \n                 /// Returns the base 10 logarithm of the number, rounded down.\n                 ///\n                 /// This is the same operation as\n-                #[doc = concat!(\"[`\", stringify!($Int), \"::log10`],\")]\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::ilog10`],\")]\n                 /// except that it has no failure cases to worry about\n                 /// since this value can never be zero.\n                 ///\n@@ -485,15 +485,15 @@ macro_rules! nonzero_unsigned_operations {\n                 /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().log10(), 1);\")]\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().log10(), 2);\")]\n-                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().log10(), 2);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().ilog10(), 1);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().ilog10(), 2);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().ilog10(), 2);\")]\n                 /// ```\n                 #[unstable(feature = \"int_log\", issue = \"70887\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n-                pub const fn log10(self) -> u32 {\n+                pub const fn ilog10(self) -> u32 {\n                     super::int_log10::$Int(self.0)\n                 }\n             }"}, {"sha": "aa3e8b9974ecb9e820f287330a3bd84e21d65d4a", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -700,7 +700,7 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -709,8 +709,8 @@ macro_rules! uint_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log(self, base: Self) -> u32 {\n-            match self.checked_log(base) {\n+        pub const fn ilog(self, base: Self) -> u32 {\n+            match self.checked_ilog(base) {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -733,7 +733,7 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -742,8 +742,8 @@ macro_rules! uint_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log2(self) -> u32 {\n-            match self.checked_log2() {\n+        pub const fn ilog2(self) -> u32 {\n+            match self.checked_ilog2() {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -766,7 +766,7 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n@@ -775,8 +775,8 @@ macro_rules! uint_impl {\n         #[track_caller]\n         #[rustc_inherit_overflow_checks]\n         #[allow(arithmetic_overflow)]\n-        pub const fn log10(self) -> u32 {\n-            match self.checked_log10() {\n+        pub const fn ilog10(self) -> u32 {\n+            match self.checked_ilog10() {\n                 Some(n) => n,\n                 None => {\n                     // In debug builds, trigger a panic on None.\n@@ -794,20 +794,20 @@ macro_rules! uint_impl {\n         /// Returns `None` if the number is zero, or if the base is not at least 2.\n         ///\n         /// This method might not be optimized owing to implementation details;\n-        /// `checked_log2` can produce results more efficiently for base 2, and\n-        /// `checked_log10` can produce results more efficiently for base 10.\n+        /// `checked_ilog2` can produce results more efficiently for base 2, and\n+        /// `checked_ilog10` can produce results more efficiently for base 10.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log(self, base: Self) -> Option<u32> {\n+        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n             if self <= 0 || base <= 1 {\n                 None\n             } else {\n@@ -816,7 +816,7 @@ macro_rules! uint_impl {\n \n                 // Optimization for 128 bit wide integers.\n                 if Self::BITS == 128 {\n-                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    let b = Self::ilog2(self) / (Self::ilog2(base) + 1);\n                     n += b;\n                     r /= base.pow(b as u32);\n                 }\n@@ -837,15 +837,15 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log2(self) -> Option<u32> {\n+        pub const fn checked_ilog2(self) -> Option<u32> {\n             if let Some(x) = <$NonZeroT>::new(self) {\n-                Some(x.log2())\n+                Some(x.ilog2())\n             } else {\n                 None\n             }\n@@ -859,15 +859,15 @@ macro_rules! uint_impl {\n         ///\n         /// ```\n         /// #![feature(int_log)]\n-        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n         #[unstable(feature = \"int_log\", issue = \"70887\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n-        pub const fn checked_log10(self) -> Option<u32> {\n+        pub const fn checked_ilog10(self) -> Option<u32> {\n             if let Some(x) = <$NonZeroT>::new(self) {\n-                Some(x.log10())\n+                Some(x.ilog10())\n             } else {\n                 None\n             }"}, {"sha": "2c57569b5aa5376ae3d4616f90cdd40ffb697669", "filename": "library/core/src/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -1135,7 +1135,7 @@ impl fmt::Debug for Duration {\n                     // 2. The postfix: can be \"\u00b5s\" so we have to count UTF8 characters.\n                     let mut actual_w = prefix.len() + postfix.chars().count();\n                     // 3. The integer part:\n-                    if let Some(log) = integer_part.checked_log10() {\n+                    if let Some(log) = integer_part.checked_ilog10() {\n                         // integer_part is > 0, so has length log10(x)+1\n                         actual_w += 1 + log as usize;\n                     } else {"}, {"sha": "be203fb5c04ff00eb04757cec2448f43db1adf68", "filename": "library/core/tests/num/int_log.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18f22058bc351224ad2b89e9d352e050275f475/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs?ref=c18f22058bc351224ad2b89e9d352e050275f475", "patch": "@@ -1,166 +1,166 @@\n-//! This tests the `Integer::{log,log2,log10}` methods. These tests are in a\n+//! This tests the `Integer::{ilog,log2,log10}` methods. These tests are in a\n //! separate file because there's both a large number of them, and not all tests\n-//! can be run on Android. This is because in Android `log2` uses an imprecise\n+//! can be run on Android. This is because in Android `ilog2` uses an imprecise\n //! approximation:https://github.com/rust-lang/rust/blob/4825e12fc9c79954aa0fe18f5521efa6c19c7539/src/libstd/sys/unix/android.rs#L27-L53\n \n #[test]\n-fn checked_log() {\n-    assert_eq!(999u32.checked_log(10), Some(2));\n-    assert_eq!(1000u32.checked_log(10), Some(3));\n-    assert_eq!(555u32.checked_log(13), Some(2));\n-    assert_eq!(63u32.checked_log(4), Some(2));\n-    assert_eq!(64u32.checked_log(4), Some(3));\n-    assert_eq!(10460353203u64.checked_log(3), Some(21));\n-    assert_eq!(10460353202u64.checked_log(3), Some(20));\n-    assert_eq!(147808829414345923316083210206383297601u128.checked_log(3), Some(80));\n-    assert_eq!(147808829414345923316083210206383297600u128.checked_log(3), Some(79));\n-    assert_eq!(22528399544939174411840147874772641u128.checked_log(19683), Some(8));\n-    assert_eq!(22528399544939174411840147874772631i128.checked_log(19683), Some(7));\n-\n-    assert_eq!(0u8.checked_log(4), None);\n-    assert_eq!(0u16.checked_log(4), None);\n-    assert_eq!(0i8.checked_log(4), None);\n-    assert_eq!(0i16.checked_log(4), None);\n+fn checked_ilog() {\n+    assert_eq!(999u32.checked_ilog(10), Some(2));\n+    assert_eq!(1000u32.checked_ilog(10), Some(3));\n+    assert_eq!(555u32.checked_ilog(13), Some(2));\n+    assert_eq!(63u32.checked_ilog(4), Some(2));\n+    assert_eq!(64u32.checked_ilog(4), Some(3));\n+    assert_eq!(10460353203u64.checked_ilog(3), Some(21));\n+    assert_eq!(10460353202u64.checked_ilog(3), Some(20));\n+    assert_eq!(147808829414345923316083210206383297601u128.checked_ilog(3), Some(80));\n+    assert_eq!(147808829414345923316083210206383297600u128.checked_ilog(3), Some(79));\n+    assert_eq!(22528399544939174411840147874772641u128.checked_ilog(19683), Some(8));\n+    assert_eq!(22528399544939174411840147874772631i128.checked_ilog(19683), Some(7));\n+\n+    assert_eq!(0u8.checked_ilog(4), None);\n+    assert_eq!(0u16.checked_ilog(4), None);\n+    assert_eq!(0i8.checked_ilog(4), None);\n+    assert_eq!(0i16.checked_ilog(4), None);\n \n     #[cfg(not(miri))] // Miri is too slow\n     for i in i16::MIN..=0 {\n-        assert_eq!(i.checked_log(4), None);\n+        assert_eq!(i.checked_ilog(4), None);\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=i16::MAX {\n-        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as u32));\n+        assert_eq!(i.checked_ilog(13), Some((i as f32).log(13.0) as u32));\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=u16::MAX {\n-        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as u32));\n+        assert_eq!(i.checked_ilog(13), Some((i as f32).log(13.0) as u32));\n     }\n }\n \n #[test]\n-fn checked_log2() {\n-    assert_eq!(5u32.checked_log2(), Some(2));\n-    assert_eq!(0u64.checked_log2(), None);\n-    assert_eq!(128i32.checked_log2(), Some(7));\n-    assert_eq!((-55i16).checked_log2(), None);\n+fn checked_ilog2() {\n+    assert_eq!(5u32.checked_ilog2(), Some(2));\n+    assert_eq!(0u64.checked_ilog2(), None);\n+    assert_eq!(128i32.checked_ilog2(), Some(7));\n+    assert_eq!((-55i16).checked_ilog2(), None);\n \n-    assert_eq!(0u8.checked_log2(), None);\n-    assert_eq!(0u16.checked_log2(), None);\n-    assert_eq!(0i8.checked_log2(), None);\n-    assert_eq!(0i16.checked_log2(), None);\n+    assert_eq!(0u8.checked_ilog2(), None);\n+    assert_eq!(0u16.checked_ilog2(), None);\n+    assert_eq!(0i8.checked_ilog2(), None);\n+    assert_eq!(0i16.checked_ilog2(), None);\n \n     for i in 1..=u8::MAX {\n-        assert_eq!(i.checked_log2(), Some((i as f32).log2() as u32));\n+        assert_eq!(i.checked_ilog2(), Some((i as f32).log2() as u32));\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=u16::MAX {\n-        // Guard against Android's imprecise f32::log2 implementation.\n+        // Guard against Android's imprecise f32::ilog2 implementation.\n         if i != 8192 && i != 32768 {\n-            assert_eq!(i.checked_log2(), Some((i as f32).log2() as u32));\n+            assert_eq!(i.checked_ilog2(), Some((i as f32).log2() as u32));\n         }\n     }\n     for i in i8::MIN..=0 {\n-        assert_eq!(i.checked_log2(), None);\n+        assert_eq!(i.checked_ilog2(), None);\n     }\n     for i in 1..=i8::MAX {\n-        assert_eq!(i.checked_log2(), Some((i as f32).log2() as u32));\n+        assert_eq!(i.checked_ilog2(), Some((i as f32).log2() as u32));\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in i16::MIN..=0 {\n-        assert_eq!(i.checked_log2(), None);\n+        assert_eq!(i.checked_ilog2(), None);\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=i16::MAX {\n-        // Guard against Android's imprecise f32::log2 implementation.\n+        // Guard against Android's imprecise f32::ilog2 implementation.\n         if i != 8192 {\n-            assert_eq!(i.checked_log2(), Some((i as f32).log2() as u32));\n+            assert_eq!(i.checked_ilog2(), Some((i as f32).log2() as u32));\n         }\n     }\n }\n \n-// Validate cases that fail on Android's imprecise float log2 implementation.\n+// Validate cases that fail on Android's imprecise float ilog2 implementation.\n #[test]\n #[cfg(not(target_os = \"android\"))]\n-fn checked_log2_not_android() {\n-    assert_eq!(8192u16.checked_log2(), Some((8192f32).log2() as u32));\n-    assert_eq!(32768u16.checked_log2(), Some((32768f32).log2() as u32));\n-    assert_eq!(8192i16.checked_log2(), Some((8192f32).log2() as u32));\n+fn checked_ilog2_not_android() {\n+    assert_eq!(8192u16.checked_ilog2(), Some((8192f32).log2() as u32));\n+    assert_eq!(32768u16.checked_ilog2(), Some((32768f32).log2() as u32));\n+    assert_eq!(8192i16.checked_ilog2(), Some((8192f32).log2() as u32));\n }\n \n #[test]\n-fn checked_log10() {\n-    assert_eq!(0u8.checked_log10(), None);\n-    assert_eq!(0u16.checked_log10(), None);\n-    assert_eq!(0i8.checked_log10(), None);\n-    assert_eq!(0i16.checked_log10(), None);\n+fn checked_ilog10() {\n+    assert_eq!(0u8.checked_ilog10(), None);\n+    assert_eq!(0u16.checked_ilog10(), None);\n+    assert_eq!(0i8.checked_ilog10(), None);\n+    assert_eq!(0i16.checked_ilog10(), None);\n \n     #[cfg(not(miri))] // Miri is too slow\n     for i in i16::MIN..=0 {\n-        assert_eq!(i.checked_log10(), None);\n+        assert_eq!(i.checked_ilog10(), None);\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=i16::MAX {\n-        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u32));\n+        assert_eq!(i.checked_ilog10(), Some((i as f32).log10() as u32));\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=u16::MAX {\n-        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u32));\n+        assert_eq!(i.checked_ilog10(), Some((i as f32).log10() as u32));\n     }\n     #[cfg(not(miri))] // Miri is too slow\n     for i in 1..=100_000u32 {\n-        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u32));\n+        assert_eq!(i.checked_ilog10(), Some((i as f32).log10() as u32));\n     }\n }\n \n-macro_rules! log10_loop {\n-    ($T:ty, $log10_max:expr) => {\n-        assert_eq!(<$T>::MAX.log10(), $log10_max);\n-        for i in 0..=$log10_max {\n+macro_rules! ilog10_loop {\n+    ($T:ty, $ilog10_max:expr) => {\n+        assert_eq!(<$T>::MAX.ilog10(), $ilog10_max);\n+        for i in 0..=$ilog10_max {\n             let p = (10 as $T).pow(i as u32);\n             if p >= 10 {\n-                assert_eq!((p - 9).log10(), i - 1);\n-                assert_eq!((p - 1).log10(), i - 1);\n+                assert_eq!((p - 9).ilog10(), i - 1);\n+                assert_eq!((p - 1).ilog10(), i - 1);\n             }\n-            assert_eq!(p.log10(), i);\n-            assert_eq!((p + 1).log10(), i);\n+            assert_eq!(p.ilog10(), i);\n+            assert_eq!((p + 1).ilog10(), i);\n             if p >= 10 {\n-                assert_eq!((p + 9).log10(), i);\n+                assert_eq!((p + 9).ilog10(), i);\n             }\n \n-            // also check `x.log(10)`\n+            // also check `x.ilog(10)`\n             if p >= 10 {\n-                assert_eq!((p - 9).log(10), i - 1);\n-                assert_eq!((p - 1).log(10), i - 1);\n+                assert_eq!((p - 9).ilog(10), i - 1);\n+                assert_eq!((p - 1).ilog(10), i - 1);\n             }\n-            assert_eq!(p.log(10), i);\n-            assert_eq!((p + 1).log(10), i);\n+            assert_eq!(p.ilog(10), i);\n+            assert_eq!((p + 1).ilog(10), i);\n             if p >= 10 {\n-                assert_eq!((p + 9).log(10), i);\n+                assert_eq!((p + 9).ilog(10), i);\n             }\n         }\n     };\n }\n \n #[test]\n-fn log10_u8() {\n-    log10_loop! { u8, 2 }\n+fn ilog10_u8() {\n+    ilog10_loop! { u8, 2 }\n }\n \n #[test]\n-fn log10_u16() {\n-    log10_loop! { u16, 4 }\n+fn ilog10_u16() {\n+    ilog10_loop! { u16, 4 }\n }\n \n #[test]\n-fn log10_u32() {\n-    log10_loop! { u32, 9 }\n+fn ilog10_u32() {\n+    ilog10_loop! { u32, 9 }\n }\n \n #[test]\n-fn log10_u64() {\n-    log10_loop! { u64, 19 }\n+fn ilog10_u64() {\n+    ilog10_loop! { u64, 19 }\n }\n \n #[test]\n-fn log10_u128() {\n-    log10_loop! { u128, 38 }\n+fn ilog10_u128() {\n+    ilog10_loop! { u128, 38 }\n }"}]}