{"sha": "927aff1724465ca92b49153236c96781038dc17e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyN2FmZjE3MjQ0NjVjYTkyYjQ5MTUzMjM2Yzk2NzgxMDM4ZGMxN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-14T15:35:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-14T15:35:15Z"}, "message": "auto merge of #8452 : Kimundi/rust/stuff02, r=bstrie\n\n- Methodyfied the string ascii extionsion functions - They got added recently, I wrapped them in a trait.\r\n- Added `into_owned()` method for vectors - similar to `Str`'s `into_owned()` function, allows to convert to a owned vector without making a copy if the source is a owned vector.\r\n- Added `or_some` method to option - similar to `unwrap_or_default`, but keeps the values wrapped in an `Option`. Useful for `Option` chains, eg Iterator impls.\r\n- Added `DoubleEndedIterator` impl to `Option` - Just for compatibility with generic Iterator functions.\r\n- Renamed nil.rs to unit.rs - the type got renamed ages ago, it's time the source file is as well.", "tree": {"sha": "fc86e33c55113833391060cb8143436e8c8846f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc86e33c55113833391060cb8143436e8c8846f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/927aff1724465ca92b49153236c96781038dc17e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/927aff1724465ca92b49153236c96781038dc17e", "html_url": "https://github.com/rust-lang/rust/commit/927aff1724465ca92b49153236c96781038dc17e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/927aff1724465ca92b49153236c96781038dc17e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "836a3d9bdbea4561cc49944a05135e2d8abf5371", "url": "https://api.github.com/repos/rust-lang/rust/commits/836a3d9bdbea4561cc49944a05135e2d8abf5371", "html_url": "https://github.com/rust-lang/rust/commit/836a3d9bdbea4561cc49944a05135e2d8abf5371"}, {"sha": "a00becd0eb8c04dc7416a5f8a633b73c9080c65d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00becd0eb8c04dc7416a5f8a633b73c9080c65d", "html_url": "https://github.com/rust-lang/rust/commit/a00becd0eb8c04dc7416a5f8a633b73c9080c65d"}], "stats": {"total": 135, "additions": 88, "deletions": 47}, "files": [{"sha": "af4fabef78b64687f3cb6b3ee7f0e64249b91d95", "filename": "src/libstd/option.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -46,8 +46,8 @@ use cmp::{Eq,Ord};\n use ops::Add;\n use util;\n use num::Zero;\n-use iterator::Iterator;\n use iterator;\n+use iterator::{Iterator, DoubleEndedIterator};\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use clone::DeepClone;\n@@ -372,7 +372,7 @@ impl<T:Zero> Option<T> {\n         }\n     }\n \n-    /// Returns self or `Some(zero)` (for this type)\n+    /// Returns self or `Some`-wrapped zero value\n     #[inline]\n     pub fn or_zero(self) -> Option<T> {\n         match self {\n@@ -407,6 +407,13 @@ impl<A> Iterator<A> for OptionIterator<A> {\n     }\n }\n \n+impl<A> DoubleEndedIterator<A> for OptionIterator<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        self.opt.take()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "9370e7b0e84c9021f7d03be5b04ad0c5485d591b", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -110,7 +110,7 @@ pub mod prelude;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n-pub mod nil;\n+pub mod unit;\n pub mod bool;\n pub mod char;\n pub mod tuple;"}, {"sha": "9148767851f52e99c1a701dceef9785aec8eb6e0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -1050,7 +1050,7 @@ pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n \n-    /// Convert `self` into a ~str.\n+    /// Convert `self` into a ~str, not making a copy if possible\n     fn into_owned(self) -> ~str;\n }\n "}, {"sha": "e0068f5e53e141a1e666e13f6f1f4ddde1e86571", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -23,7 +23,7 @@ use to_bytes::IterBytes;\n use option::{Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq)]\n pub struct Ascii { priv chr: u8 }\n \n impl Ascii {\n@@ -250,21 +250,40 @@ impl ToBytesConsume for ~[Ascii] {\n     }\n }\n \n-\n-/// Convert the string to ASCII upper case:\n-/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-/// but non-ASCII letters are unchanged.\n-#[inline]\n-pub fn to_ascii_upper(string: &str) -> ~str {\n-    map_bytes(string, ASCII_UPPER_MAP)\n+/// Extension methods for ASCII-subset only operations on strings\n+pub trait StrAsciiExt {\n+    /// Convert the string to ASCII upper case:\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    fn to_ascii_upper(&self) -> ~str;\n+\n+    /// Convert the string to ASCII lower case:\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    fn to_ascii_lower(&self) -> ~str;\n+\n+    /// Check that two strings are an ASCII case-insensitive match.\n+    /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n+    /// but without allocating and copying temporary strings.\n+    fn eq_ignore_ascii_case(&self, other: &str) -> bool;\n }\n \n-/// Convert the string to ASCII lower case:\n-/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-/// but non-ASCII letters are unchanged.\n-#[inline]\n-pub fn to_ascii_lower(string: &str) -> ~str {\n-    map_bytes(string, ASCII_LOWER_MAP)\n+impl<'self> StrAsciiExt for &'self str {\n+    #[inline]\n+    fn to_ascii_upper(&self) -> ~str {\n+        map_bytes(*self, ASCII_UPPER_MAP)\n+    }\n+\n+    #[inline]\n+    fn to_ascii_lower(&self) -> ~str {\n+        map_bytes(*self, ASCII_LOWER_MAP)\n+    }\n+\n+    #[inline]\n+    fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.len() == other.len() && self.as_bytes().iter().zip(other.as_bytes().iter()).all(\n+            |(byte_self, byte_other)| ASCII_LOWER_MAP[*byte_self] == ASCII_LOWER_MAP[*byte_other])\n+    }\n }\n \n #[inline]\n@@ -283,15 +302,6 @@ fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n     result\n }\n \n-/// Check that two strings are an ASCII case-insensitive match.\n-/// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n-/// but without allocating and copying temporary strings.\n-#[inline]\n-pub fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && a.as_bytes().iter().zip(b.as_bytes().iter()).all(\n-        |(byte_a, byte_b)| ASCII_LOWER_MAP[*byte_a] == ASCII_LOWER_MAP[*byte_b])\n-}\n-\n static ASCII_LOWER_MAP: &'static [u8] = &[\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n@@ -453,49 +463,48 @@ mod tests {\n \n     #[test]\n     fn test_to_ascii_upper() {\n-        assert_eq!(to_ascii_upper(\"url()URL()uRl()\u00fcrl\"), ~\"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(to_ascii_upper(\"h\u0131\u212a\u00df\"), ~\"H\u0131\u212a\u00df\");\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), ~\"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), ~\"H\u0131\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let c = i as char;\n             let upper = if 'a' <= c && c <= 'z' { c + 'A' - 'a' } else { c };\n-            assert_eq!(to_ascii_upper(from_char(i as char)), from_char(upper))\n+            assert_eq!(from_char(i as char).to_ascii_upper(), from_char(upper))\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_to_ascii_lower() {\n-        assert_eq!(to_ascii_lower(\"url()URL()uRl()\u00dcrl\"), ~\"url()url()url()\u00dcrl\");\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), ~\"url()url()url()\u00dcrl\");\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(to_ascii_lower(\"H\u0130\u212a\u00df\"), ~\"h\u0130\u212a\u00df\");\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), ~\"h\u0130\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let c = i as char;\n             let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n-            assert_eq!(to_ascii_lower(from_char(i as char)), from_char(lower))\n+            assert_eq!(from_char(i as char).to_ascii_lower(), from_char(lower))\n             i += 1;\n         }\n     }\n \n-\n     #[test]\n     fn test_eq_ignore_ascii_case() {\n-        assert!(eq_ignore_ascii_case(\"url()URL()uRl()\u00dcrl\", \"url()url()url()\u00dcrl\"));\n-        assert!(!eq_ignore_ascii_case(\"\u00dcrl\", \"\u00fcrl\"));\n+        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert!(eq_ignore_ascii_case(\"H\u0130\u212a\u00df\", \"h\u0130\u212a\u00df\"));\n-        assert!(!eq_ignore_ascii_case(\"\u0130\", \"i\"));\n-        assert!(!eq_ignore_ascii_case(\"\u212a\", \"k\"));\n-        assert!(!eq_ignore_ascii_case(\"\u00df\", \"s\"));\n+        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n \n         let mut i = 0;\n         while i <= 500 {\n             let c = i as char;\n             let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n-            assert!(eq_ignore_ascii_case(from_char(i as char), from_char(lower)));\n+            assert!(from_char(i as char).eq_ignore_ascii_case(from_char(lower)));\n             i += 1;\n         }\n     }"}, {"sha": "82f14e4c8d72b507fe680212e83e3aa333672860", "filename": "src/libstd/unit.rs", "status": "renamed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -19,8 +19,6 @@ use prelude::*;\n #[cfg(not(test))]\n use num::Zero;\n \n-\n-\n #[cfg(not(test))]\n impl Eq for () {\n     #[inline]\n@@ -54,4 +52,3 @@ impl Zero for () {\n     #[inline]\n     fn is_zero(&self) -> bool { true }\n }\n-", "previous_filename": "src/libstd/nil.rs"}, {"sha": "6d27c43def8c0dd5431287041476c0b0fe499e90", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927aff1724465ca92b49153236c96781038dc17e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=927aff1724465ca92b49153236c96781038dc17e", "patch": "@@ -707,14 +707,17 @@ pub trait Vector<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n+\n impl<'self,T> Vector<T> for &'self [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n+\n impl<T> Vector<T> for ~[T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n+\n impl<T> Vector<T> for @[T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n@@ -748,13 +751,17 @@ impl<T> Container for ~[T] {\n     }\n }\n \n-#[allow(missing_doc)]\n+/// Extension methods for vector slices with copyable elements\n pub trait CopyableVector<T> {\n+    /// Copy `self` into a new owned vector\n     fn to_owned(&self) -> ~[T];\n+\n+    /// Convert `self` into a owned vector, not making a copy if possible.\n+    fn into_owned(self) -> ~[T];\n }\n \n-/// Extension methods for vectors\n-impl<'self,T:Clone> CopyableVector<T> for &'self [T] {\n+/// Extension methods for vector slices\n+impl<'self, T: Clone> CopyableVector<T> for &'self [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n@@ -764,6 +771,27 @@ impl<'self,T:Clone> CopyableVector<T> for &'self [T] {\n         }\n         result\n     }\n+\n+    #[inline(always)]\n+    fn into_owned(self) -> ~[T] { self.to_owned() }\n+}\n+\n+/// Extension methods for owned vectors\n+impl<T: Clone> CopyableVector<T> for ~[T] {\n+    #[inline]\n+    fn to_owned(&self) -> ~[T] { self.clone() }\n+\n+    #[inline(always)]\n+    fn into_owned(self) -> ~[T] { self }\n+}\n+\n+/// Extension methods for managed vectors\n+impl<T: Clone> CopyableVector<T> for @[T] {\n+    #[inline]\n+    fn to_owned(&self) -> ~[T] { self.as_slice().to_owned() }\n+\n+    #[inline(always)]\n+    fn into_owned(self) -> ~[T] { self.to_owned() }\n }\n \n #[allow(missing_doc)]"}]}