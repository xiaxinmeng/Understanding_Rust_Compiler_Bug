{"sha": "7e2b2f30cd55cf2c506852a14ad01c4214406f52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMmIyZjMwY2Q1NWNmMmM1MDY4NTJhMTRhZDAxYzQyMTQ0MDZmNTI=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-09T17:14:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-09T17:14:23Z"}, "message": "Rollup merge of #39682 - solson:fix-unaligned-read, r=eddyb\n\nFix unsafe unaligned loads in test.\n\nr? @eddyb\ncc @Aatch @nikomatsakis\n\nThe `#[derive(PartialEq, Debug)]` impls on a packed struct contain undefined behaviour. Both generated impls take references to unaligned fields, which will fail to compile once we correctly treat that as unsafe (see https://github.com/rust-lang/rust/issues/27060).\n\nThis UB was found by running the test under [Miri](https://github.com/solson/miri/) which rejects these unsafe unaligned loads. \ud83d\ude04\n\nHere's a simpler example:\n\n```rust\nstruct Packed {\n    a: u8,\n    b: u64,\n}\n```\n\nIt expands to:\n\n```rust\n    fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        match *self {\n            Packed { a: ref __self_0_0, b: ref __self_0_1 } => { // BAD: these patterns are unsafe\n                let mut builder = __arg_0.debug_struct(\"Packed\");\n                let _ = builder.field(\"a\", &&(*__self_0_0));\n                let _ = builder.field(\"b\", &&(*__self_0_1));\n                builder.finish()\n            }\n        }\n    }\n```\n\nand\n\n```rust\n    fn eq(&self, __arg_0: &Packed) -> bool {\n        match *__arg_0 {\n            Packed { a: ref __self_1_0, b: ref __self_1_1 } => // BAD: these patterns are unsafe\n            match *self {\n                Packed { a: ref __self_0_0, b: ref __self_0_1 } => // BAD: these patterns are unsafe\n                true && (*__self_0_0) == (*__self_1_0) &&\n                    (*__self_0_1) == (*__self_1_1),\n            },\n        }\n    }\n```", "tree": {"sha": "78bfc4f4adc6f417fd17156809faeddb49a00741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78bfc4f4adc6f417fd17156809faeddb49a00741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e2b2f30cd55cf2c506852a14ad01c4214406f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e2b2f30cd55cf2c506852a14ad01c4214406f52", "html_url": "https://github.com/rust-lang/rust/commit/7e2b2f30cd55cf2c506852a14ad01c4214406f52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e2b2f30cd55cf2c506852a14ad01c4214406f52/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bd0da7e89faea251e77215ec70f7a5b2c26a3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd0da7e89faea251e77215ec70f7a5b2c26a3f8", "html_url": "https://github.com/rust-lang/rust/commit/7bd0da7e89faea251e77215ec70f7a5b2c26a3f8"}, {"sha": "2589f4a7511ab04a3325b0372cd2ae174940c6c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2589f4a7511ab04a3325b0372cd2ae174940c6c8", "html_url": "https://github.com/rust-lang/rust/commit/2589f4a7511ab04a3325b0372cd2ae174940c6c8"}], "stats": {"total": 61, "additions": 46, "deletions": 15}, "files": [{"sha": "eb96d94efec930d3edaf3149d43b38a94a488d20", "filename": "src/test/run-pass/mir_adt_construction.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7e2b2f30cd55cf2c506852a14ad01c4214406f52/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e2b2f30cd55cf2c506852a14ad01c4214406f52/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs?ref=7e2b2f30cd55cf2c506852a14ad01c4214406f52", "patch": "@@ -8,23 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n+\n #[repr(C)]\n enum CEnum {\n     Hello = 30,\n     World = 60\n }\n \n fn test1(c: CEnum) -> i32 {\n-  let c2 = CEnum::Hello;\n-  match (c, c2) {\n-    (CEnum::Hello, CEnum::Hello) => 42,\n-    (CEnum::World, CEnum::Hello) => 0,\n-    _ => 1\n-  }\n+    let c2 = CEnum::Hello;\n+    match (c, c2) {\n+        (CEnum::Hello, CEnum::Hello) => 42,\n+        (CEnum::World, CEnum::Hello) => 0,\n+        _ => 1\n+    }\n }\n \n #[repr(packed)]\n-#[derive(PartialEq, Debug)]\n struct Pakd {\n     a: u64,\n     b: u32,\n@@ -33,6 +34,36 @@ struct Pakd {\n     e: ()\n }\n \n+// It is unsafe to use #[derive(Debug)] on a packed struct because the code generated by the derive\n+// macro takes references to the fields instead of accessing them directly.\n+impl fmt::Debug for Pakd {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // It's important that we load the fields into locals by-value here. This will do safe\n+        // unaligned loads into the locals, then pass references to the properly-aligned locals to\n+        // the formatting code.\n+        let Pakd { a, b, c, d, e } = *self;\n+        f.debug_struct(\"Pakd\")\n+            .field(\"a\", &a)\n+            .field(\"b\", &b)\n+            .field(\"c\", &c)\n+            .field(\"d\", &d)\n+            .field(\"e\", &e)\n+            .finish()\n+    }\n+}\n+\n+// It is unsafe to use #[derive(PartialEq)] on a packed struct because the code generated by the\n+// derive macro takes references to the fields instead of accessing them directly.\n+impl PartialEq for Pakd {\n+    fn eq(&self, other: &Pakd) -> bool {\n+        self.a == other.a &&\n+            self.b == other.b &&\n+            self.c == other.c &&\n+            self.d == other.d &&\n+            self.e == other.e\n+    }\n+}\n+\n impl Drop for Pakd {\n     fn drop(&mut self) {}\n }\n@@ -59,12 +90,12 @@ fn test5(x: fn(u32) -> Option<u32>) -> (Option<u32>, Option<u32>) {\n }\n \n fn main() {\n-  assert_eq!(test1(CEnum::Hello), 42);\n-  assert_eq!(test1(CEnum::World), 0);\n-  assert_eq!(test2(), Pakd { a: 42, b: 42, c: 42, d: 42, e: () });\n-  assert_eq!(test3(), TupleLike(42, 42));\n-  let t4 = test4(TupleLike);\n-  assert_eq!(t4.0, t4.1);\n-  let t5 = test5(Some);\n-  assert_eq!(t5.0, t5.1);\n+    assert_eq!(test1(CEnum::Hello), 42);\n+    assert_eq!(test1(CEnum::World), 0);\n+    assert_eq!(test2(), Pakd { a: 42, b: 42, c: 42, d: 42, e: () });\n+    assert_eq!(test3(), TupleLike(42, 42));\n+    let t4 = test4(TupleLike);\n+    assert_eq!(t4.0, t4.1);\n+    let t5 = test5(Some);\n+    assert_eq!(t5.0, t5.1);\n }"}]}