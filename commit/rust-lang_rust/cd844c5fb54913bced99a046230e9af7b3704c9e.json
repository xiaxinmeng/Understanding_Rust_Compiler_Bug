{"sha": "cd844c5fb54913bced99a046230e9af7b3704c9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkODQ0YzVmYjU0OTEzYmNlZDk5YTA0NjIzMGU5YWY3YjM3MDRjOWU=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-05-31T12:21:39Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2014-05-31T12:58:12Z"}, "message": "Remove unnecessary allocations / clones during method lookup\n\nBy dropping the intermediate vector that holds the relevant candidates\nincluding duplicates and directly building the vector that has the\nduplicates removed we can eliminate quite a few allocations. This\nreduces the times for type checking by 5-10% (measured with libstd,\nlibsyntax and librustc).", "tree": {"sha": "f436f41d808d6899440d487db91bfb89463b771b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f436f41d808d6899440d487db91bfb89463b771b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd844c5fb54913bced99a046230e9af7b3704c9e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd844c5fb54913bced99a046230e9af7b3704c9e", "html_url": "https://github.com/rust-lang/rust/commit/cd844c5fb54913bced99a046230e9af7b3704c9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd844c5fb54913bced99a046230e9af7b3704c9e/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768", "html_url": "https://github.com/rust-lang/rust/commit/ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768"}], "stats": {"total": 44, "additions": 10, "deletions": 34}, "files": [{"sha": "dcba3a22b703aa6f920aec165a2fb45a767c4bdc", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd844c5fb54913bced99a046230e9af7b3704c9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd844c5fb54913bced99a046230e9af7b3704c9e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cd844c5fb54913bced99a046230e9af7b3704c9e", "patch": "@@ -1026,13 +1026,7 @@ impl<'a> LookupContext<'a> {\n     fn consider_candidates(&self, rcvr_ty: ty::t,\n                            candidates: &[Candidate])\n                            -> Option<MethodCallee> {\n-        // FIXME(pcwalton): Do we need to clone here?\n-        let relevant_candidates: Vec<Candidate> =\n-            candidates.iter().map(|c| (*c).clone()).\n-                filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n-\n-        let relevant_candidates =\n-            self.merge_candidates(relevant_candidates.as_slice());\n+        let relevant_candidates = self.filter_candidates(rcvr_ty, candidates);\n \n         if relevant_candidates.len() == 0 {\n             return None;\n@@ -1069,22 +1063,16 @@ impl<'a> LookupContext<'a> {\n         Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n     }\n \n-    fn merge_candidates(&self, candidates: &[Candidate]) -> Vec<Candidate> {\n-        let mut merged = Vec::new();\n-        let mut i = 0;\n-        while i < candidates.len() {\n-            let candidate_a = &candidates[i];\n-\n-            let mut skip = false;\n+    fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n+        let mut relevant_candidates: Vec<Candidate> = Vec::new();\n \n-            let mut j = i + 1;\n-            while j < candidates.len() {\n-                let candidate_b = &candidates[j];\n+        for candidate_a in candidates.iter().filter(|&c| self.is_relevant(rcvr_ty, c)) {\n+            // Skip this one if we already have one like it\n+            if !relevant_candidates.iter().any(|candidate_b| {\n                 debug!(\"attempting to merge {} and {}\",\n                        candidate_a.repr(self.tcx()),\n                        candidate_b.repr(self.tcx()));\n-                let candidates_same = match (&candidate_a.origin,\n-                                             &candidate_b.origin) {\n+                match (&candidate_a.origin, &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n                         let same_trait = p1.trait_id == p2.trait_id;\n                         let same_method = p1.method_num == p2.method_num;\n@@ -1095,25 +1083,13 @@ impl<'a> LookupContext<'a> {\n                         same_trait && same_method && same_param\n                     }\n                     _ => false\n-                };\n-                if candidates_same {\n-                    skip = true;\n-                    break;\n                 }\n-                j += 1;\n-            }\n-\n-            i += 1;\n-\n-            if skip {\n-                // There are more than one of these and we need only one\n-                continue;\n-            } else {\n-                merged.push(candidate_a.clone());\n+            }) {\n+                relevant_candidates.push(candidate_a.clone());\n             }\n         }\n \n-        return merged;\n+        relevant_candidates\n     }\n \n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)"}]}