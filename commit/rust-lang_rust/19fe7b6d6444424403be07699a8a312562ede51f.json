{"sha": "19fe7b6d6444424403be07699a8a312562ede51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZmU3YjZkNjQ0NDQyNDQwM2JlMDc2OTlhOGEzMTI1NjJlZGU1MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-29T19:28:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-29T19:28:27Z"}, "message": "Auto merge of #28623 - llogiq:faster-fasta, r=brson\n\nI just removed the num_cpus dependency (because we don't want that in there), using 4 threads instead.\r\n\r\nI should add that Veedrac asked me to submit this here in his name.", "tree": {"sha": "8ef2496e4f7a13af723b03c8736b2d87440d3496", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ef2496e4f7a13af723b03c8736b2d87440d3496"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19fe7b6d6444424403be07699a8a312562ede51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19fe7b6d6444424403be07699a8a312562ede51f", "html_url": "https://github.com/rust-lang/rust/commit/19fe7b6d6444424403be07699a8a312562ede51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19fe7b6d6444424403be07699a8a312562ede51f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f06607e23783ba0fbcd8a6a7d2a516507fda4a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f06607e23783ba0fbcd8a6a7d2a516507fda4a7", "html_url": "https://github.com/rust-lang/rust/commit/5f06607e23783ba0fbcd8a6a7d2a516507fda4a7"}, {"sha": "12d990d385246e7bcde4209cee94b8a148fd2c2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d990d385246e7bcde4209cee94b8a148fd2c2d", "html_url": "https://github.com/rust-lang/rust/commit/12d990d385246e7bcde4209cee94b8a148fd2c2d"}], "stats": {"total": 837, "additions": 597, "deletions": 240}, "files": [{"sha": "6d64c50b826b58c9cfc8f616b9f426af1b13a7b0", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 292, "deletions": 153, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/19fe7b6d6444424403be07699a8a312562ede51f/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fe7b6d6444424403be07699a8a312562ede51f/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=19fe7b6d6444424403be07699a8a312562ede51f", "patch": "@@ -39,199 +39,338 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::cmp::min;\n-use std::env;\n-use std::io;\n-use std::io::BufWriter;\n-use std::io::prelude::*;\n+use std::io::{self, Write};\n+use std::sync::{Arc, Mutex};\n+use std::thread;\n+\n \n const LINE_LEN: usize = 60;\n+\n+const BLOCK_LINES: usize = 512;\n+const BLOCK_THOROUGHPUT: usize = LINE_LEN * BLOCK_LINES;\n+const BLOCK_LEN: usize = BLOCK_THOROUGHPUT + BLOCK_LINES;\n+\n+const STDIN_BUF: usize = (LINE_LEN + 1) * 1024;\n const LOOKUP_SIZE: usize = 4 * 1024;\n const LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n \n-// Random number generator constants\n-const IM: u32 = 139968;\n-const IA: u32 = 3877;\n-const IC: u32 = 29573;\n-\n-const ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n-                            GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA\\\n-                            GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA\\\n-                            AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT\\\n-                            CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC\\\n-                            CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG\\\n-                            CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-\n-const NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n-\n-static IUB: [AminoAcid;15] = [\n-    AminoAcid { c: 'a' as u8, p: 0.27 },\n-    AminoAcid { c: 'c' as u8, p: 0.12 },\n-    AminoAcid { c: 'g' as u8, p: 0.12 },\n-    AminoAcid { c: 't' as u8, p: 0.27 },\n-    AminoAcid { c: 'B' as u8, p: 0.02 },\n-    AminoAcid { c: 'D' as u8, p: 0.02 },\n-    AminoAcid { c: 'H' as u8, p: 0.02 },\n-    AminoAcid { c: 'K' as u8, p: 0.02 },\n-    AminoAcid { c: 'M' as u8, p: 0.02 },\n-    AminoAcid { c: 'N' as u8, p: 0.02 },\n-    AminoAcid { c: 'R' as u8, p: 0.02 },\n-    AminoAcid { c: 'S' as u8, p: 0.02 },\n-    AminoAcid { c: 'V' as u8, p: 0.02 },\n-    AminoAcid { c: 'W' as u8, p: 0.02 },\n-    AminoAcid { c: 'Y' as u8, p: 0.02 },\n-];\n-\n-static HOMO_SAPIENS: [AminoAcid;4] = [\n-    AminoAcid { c: 'a' as u8, p: 0.3029549426680 },\n-    AminoAcid { c: 'c' as u8, p: 0.1979883004921 },\n-    AminoAcid { c: 'g' as u8, p: 0.1975473066391 },\n-    AminoAcid { c: 't' as u8, p: 0.3015094502008 },\n-];\n-\n-fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n-    let mut p = 0f32;\n-    let mut result: Vec<AminoAcid> = a.iter().map(|a_i| {\n-        p += a_i.p;\n-        AminoAcid { c: a_i.c, p: p * LOOKUP_SCALE }\n-    }).collect();\n-    let result_len = result.len();\n-    result[result_len - 1].p = LOOKUP_SCALE;\n-    result\n-}\n+const ALU: &'static [u8] =\n+    b\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n+      GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n+      CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n+      ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n+      GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n+      AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n+      AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+const IUB: &'static [(u8, f32)] =\n+    &[(b'a', 0.27), (b'c', 0.12), (b'g', 0.12),\n+      (b't', 0.27), (b'B', 0.02), (b'D', 0.02),\n+      (b'H', 0.02), (b'K', 0.02), (b'M', 0.02),\n+      (b'N', 0.02), (b'R', 0.02), (b'S', 0.02),\n+      (b'V', 0.02), (b'W', 0.02), (b'Y', 0.02)];\n+\n+const HOMOSAPIENS: &'static [(u8, f32)] =\n+    &[(b'a', 0.3029549426680),\n+      (b'c', 0.1979883004921),\n+      (b'g', 0.1975473066391),\n+      (b't', 0.3015094502008)];\n+\n+// We need a specific Rng,\n+// so implement this manually\n+\n+const MODULUS: u32 = 139968;\n+const MULTIPLIER: u32 = 3877;\n+const ADDITIVE: u32 = 29573;\n+\n+// Why doesn't rust already have this?\n+// Algorithm directly taken from Wikipedia\n+fn powmod(mut base: u64, mut exponent: u32, modulus: u64) -> u64 {\n+    let mut ret = 1;\n+    base %= modulus;\n \n-#[derive(Copy, Clone)]\n-struct AminoAcid {\n-    c: u8,\n-    p: f32,\n+    while exponent > 0 {\n+        if exponent & 1 == 1 {\n+           ret *= base;\n+           ret %= modulus;\n+        }\n+        exponent >>= 1;\n+        base *= base;\n+        base %= modulus;\n+    }\n+\n+    ret\n }\n \n-struct RepeatFasta<'a, W:'a> {\n-    alu: &'static str,\n-    out: &'a mut W\n+// Just a typical LCRNG\n+pub struct Rng {\n+    last: u32\n }\n \n-impl<'a, W: Write> RepeatFasta<'a, W> {\n-    fn new(alu: &'static str, w: &'a mut W) -> RepeatFasta<'a, W> {\n-        RepeatFasta { alu: alu, out: w }\n+impl Rng {\n+    pub fn new() -> Rng {\n+        Rng { last: 42 }\n     }\n \n-    fn make(&mut self, n: usize) -> io::Result<()> {\n-        let alu_len = self.alu.len();\n-        let mut buf = vec![0; alu_len + LINE_LEN];\n-        let alu: &[u8] = self.alu.as_bytes();\n+    pub fn max_value() -> u32 {\n+        MODULUS - 1\n+    }\n \n-        for (slot, val) in buf.iter_mut().zip(alu) {\n-            *slot = *val;\n-        }\n-        let buf_len = buf.len();\n-        for (slot, val) in buf[alu_len..buf_len].iter_mut().zip(&alu[..LINE_LEN]) {\n-            *slot = *val;\n-        }\n+    pub fn normalize(p: f32) -> u32 {\n+        (p * MODULUS as f32).floor() as u32\n+    }\n \n-        let mut pos = 0;\n-        let mut bytes;\n-        let mut n = n;\n-        while n > 0 {\n-            bytes = min(LINE_LEN, n);\n-            try!(self.out.write_all(&buf[pos..pos + bytes]));\n-            try!(self.out.write_all(&[b'\\n']));\n-            pos += bytes;\n-            if pos > alu_len {\n-                pos -= alu_len;\n-            }\n-            n -= bytes;\n-        }\n-        Ok(())\n+    pub fn gen(&mut self) -> u32 {\n+        self.last = (self.last * MULTIPLIER + ADDITIVE) % MODULUS;\n+        self.last\n     }\n-}\n \n-fn make_lookup(a: &[AminoAcid]) -> [AminoAcid;LOOKUP_SIZE] {\n-    let mut lookup = [ NULL_AMINO_ACID;LOOKUP_SIZE ];\n-    let mut j = 0;\n-    for (i, slot) in lookup.iter_mut().enumerate() {\n-        while a[j].p < (i as f32) {\n-            j += 1;\n-        }\n-        *slot = a[j];\n+    // This allows us to fast-forward the RNG,\n+    // allowing us to run it in parallel.\n+    pub fn future(&self, n: u32) -> Rng {\n+        let a = MULTIPLIER as u64;\n+        let b = ADDITIVE as u64;\n+        let m = MODULUS as u64;\n+\n+        //                          (a^n - 1) mod (a-1) m\n+        // x_k = ((a^n x_0 mod m) + --------------------- b) mod m\n+        //                                   a - 1\n+        //\n+        // Since (a - 1) divides (a^n - 1) mod (a-1) m,\n+        // the subtraction does not overflow and thus can be non-modular.\n+        //\n+        let new_seed =\n+            (powmod(a, n, m) * self.last as u64) % m +\n+            (powmod(a, n, (a-1) * m) - 1) / (a-1) * b;\n+\n+        Rng { last: (new_seed % m) as u32 }\n     }\n-    lookup\n }\n \n-struct RandomFasta<'a, W:'a> {\n-    seed: u32,\n-    lookup: [AminoAcid;LOOKUP_SIZE],\n-    out: &'a mut W,\n+\n+// This will end up keeping track of threads, like\n+// in the other multithreaded Rust version, in\n+// order to keep writes in order.\n+//\n+// This is stolen from another multithreaded Rust\n+// implementation, although that implementation\n+// was not able to parallelize the RNG itself.\n+struct BlockSubmitter<W: io::Write> {\n+    writer: W,\n+    pub waiting_on: usize,\n }\n \n-impl<'a, W: Write> RandomFasta<'a, W> {\n-    fn new(w: &'a mut W, a: &[AminoAcid]) -> RandomFasta<'a, W> {\n-        RandomFasta {\n-            seed: 42,\n-            out: w,\n-            lookup: make_lookup(a),\n+impl<W: io::Write> BlockSubmitter<W> {\n+    fn submit(&mut self, data: &[u8], block_num: usize) -> Option<io::Result<()>> {\n+        if block_num == self.waiting_on {\n+            self.waiting_on += 1;\n+            Some(self.submit_async(data))\n+        }\n+        else {\n+            None\n         }\n     }\n \n-    fn rng(&mut self, max: f32) -> f32 {\n-        self.seed = (self.seed * IA + IC) % IM;\n-        (max * self.seed as f32) / (IM as f32)\n+    fn submit_async(&mut self, data: &[u8]) -> io::Result<()> {\n+        self.writer.write_all(data)\n     }\n+}\n+\n+\n+// For repeating strings as output\n+fn fasta_static<W: io::Write>(\n+    writer: &mut W,\n+    header: &[u8],\n+    data: &[u8],\n+    mut n: usize\n+) -> io::Result<()>\n+{\n+    // The aim here is to print a short(ish) string cyclically\n+    // with line breaks as appropriate.\n+    //\n+    // The secret technique is to repeat the string such that\n+    // any wanted line is a single offset in the string.\n+    //\n+    // This technique is stolen from the Haskell version.\n+\n+    try!(writer.write_all(header));\n \n-    fn nextc(&mut self) -> u8 {\n-        let r = self.rng(LOOKUP_SCALE);\n-        for i in (r as usize..LOOKUP_SIZE) {\n-            if self.lookup[i].p >= r {\n-                return self.lookup[i].c;\n+    // Maximum offset is data.len(),\n+    // Maximum read len is LINE_LEN\n+    let stream = data.iter().cloned().cycle();\n+    let mut extended: Vec<u8> = stream.take(data.len() + LINE_LEN + 1).collect();\n+\n+    let mut offset = 0;\n+    while n > 0 {\n+        let write_len = min(LINE_LEN, n);\n+        let end = offset + write_len;\n+        n -= write_len;\n+\n+        let tmp = extended[end];\n+        extended[end] = b'\\n';\n+        try!(writer.write_all(&extended[offset..end + 1]));\n+        extended[end] = tmp;\n+\n+        offset = end;\n+        offset %= data.len();\n+    }\n+\n+    Ok(())\n+}\n+\n+\n+// For RNG streams as output\n+fn fasta<W: io::Write + Send + 'static>(\n+    submitter: &Arc<Mutex<BlockSubmitter<W>>>,\n+    header: &[u8],\n+    table: &'static [(u8, f32)],\n+    rng: &mut Rng,\n+    n: usize\n+) -> io::Result<()>\n+{\n+    // Here the lookup table is part of the algorithm and needs the\n+    // original probabilities (scaled with the LOOKUP_SCALE), because\n+    // Isaac says so :-)\n+    fn sum_and_scale(a: &'static [(u8, f32)]) -> Vec<(u8, f32)> {\n+        let mut p = 0f32;\n+        let mut result: Vec<(u8, f32)> = a.iter().map(|e| {\n+            p += e.1;\n+            (e.0, p * LOOKUP_SCALE)\n+        }).collect();\n+        let result_len = result.len();\n+        result[result_len - 1].1 = LOOKUP_SCALE;\n+        result\n+    }\n+\n+    fn make_lookup(a: &[(u8, f32)]) -> [(u8, f32); LOOKUP_SIZE] {\n+        let mut lookup = [(0, 0f32); LOOKUP_SIZE];\n+        let mut j = 0;\n+        for (i, slot) in lookup.iter_mut().enumerate() {\n+            while a[j].1 < (i as f32) {\n+                j += 1;\n             }\n+            *slot = a[j];\n         }\n-        unreachable!();\n+        lookup\n+    }\n+\n+    {\n+        try!(submitter.lock().unwrap().submit_async(header));\n+    }\n+\n+    let lookup_table = Arc::new(make_lookup(&sum_and_scale(table)));\n+\n+    let thread_count = 4;\n+    let mut threads = Vec::new();\n+    for block_num in (0..thread_count) {\n+        let offset = BLOCK_THOROUGHPUT * block_num;\n+\n+        let local_submitter = submitter.clone();\n+        let local_lookup_table = lookup_table.clone();\n+        let local_rng = rng.future(offset as u32);\n+\n+        threads.push(thread::spawn(move || {\n+            gen_block(\n+                local_submitter,\n+                local_lookup_table,\n+                local_rng,\n+                n.saturating_sub(offset),\n+                block_num,\n+                thread_count\n+            )\n+        }));\n+    }\n+\n+    for thread in threads {\n+        try!(thread.join().unwrap());\n     }\n \n-    fn make(&mut self, n: usize) -> io::Result<()> {\n-        let lines = n / LINE_LEN;\n-        let chars_left = n % LINE_LEN;\n-        let mut buf = [0;LINE_LEN + 1];\n+    *rng = rng.future(n as u32);\n \n-        for _ in 0..lines {\n-            for i in 0..LINE_LEN {\n-                buf[i] = self.nextc();\n+    Ok(())\n+}\n+\n+// A very optimized writer.\n+// I have a feeling a simpler version wouldn't slow\n+// things down too much, though, since the RNG\n+// is the really heavy hitter.\n+fn gen_block<W: io::Write>(\n+    submitter: Arc<Mutex<BlockSubmitter<W>>>,\n+    lookup_table: Arc<[(u8, f32)]>,\n+    mut rng: Rng,\n+    mut length: usize,\n+    mut block_num: usize,\n+    block_stride: usize,\n+) -> io::Result<()>\n+{\n+    // Include newlines in block\n+    length += length / LINE_LEN;\n+    let block: &mut [u8] = &mut [b'\\n'; BLOCK_LEN];\n+\n+    while length > 0 {\n+        {\n+            let gen_into = &mut block[..min(length, BLOCK_LEN)];\n+\n+            // Write random numbers, skipping newlines\n+            for (i, byte) in gen_into.iter_mut().enumerate() {\n+                if (i + 1) % (LINE_LEN + 1) != 0 {\n+                    let p = rng.gen() as f32 * (LOOKUP_SCALE / MODULUS as f32);\n+                    *byte = lookup_table[p as usize..LOOKUP_SIZE].iter().find(\n+                        |le| le.1 >= p).unwrap().0;\n+                }\n             }\n-            buf[LINE_LEN] = '\\n' as u8;\n-            try!(self.out.write(&buf));\n         }\n-        for i in 0..chars_left {\n-            buf[i] = self.nextc();\n+\n+        let write_out = {\n+            if length >= BLOCK_LEN               { &mut *block }\n+            else if length % (LINE_LEN + 1) == 0 { &mut block[..length] }\n+            else                                 { &mut block[..length + 1] }\n+        };\n+\n+        *write_out.last_mut().unwrap() = b'\\n';\n+        loop {\n+            // Make sure to release lock before calling `yield_now`\n+            let res = { submitter.lock().unwrap().submit(write_out, block_num) };\n+\n+            match res {\n+                Some(result) => { try!(result); break; }\n+                None => std::thread::yield_now()\n+            }\n         }\n-        self.out.write_all(&buf[..chars_left])\n+        block_num += block_stride;\n+        rng = rng.future((BLOCK_THOROUGHPUT * (block_stride - 1)) as u32);\n+        length = length.saturating_sub(BLOCK_LEN * (block_stride - 1));\n+\n+        length = length.saturating_sub(BLOCK_LEN);\n     }\n+\n+    Ok(())\n }\n \n-fn main() {\n-    let mut args = env::args();\n-    let n = if args.len() > 1 {\n-        args.nth(1).unwrap().parse::<usize>().unwrap()\n-    } else {\n-        5\n-    };\n+fn run<W: io::Write + Send + 'static>(writer: W) -> io::Result<()> {\n+    let n = std::env::args_os().nth(1)\n+        .and_then(|s| s.into_string().ok())\n+        .and_then(|n| n.parse().ok())\n+        .unwrap_or(1000);\n \n-    let stdout = io::stdout();\n-    let mut out = BufWriter::new(stdout.lock());\n+    let rng = &mut Rng::new();\n \n-    out.write_all(b\">ONE Homo sapiens alu\\n\").unwrap();\n-    {\n-        let mut repeat = RepeatFasta::new(ALU, &mut out);\n-        repeat.make(n * 2).unwrap();\n-    }\n+    // Use automatic buffering for the static version...\n+    let mut writer = io::BufWriter::with_capacity(STDIN_BUF, writer);\n+    try!(fasta_static(&mut writer, b\">ONE Homo sapiens alu\\n\", ALU, n * 2));\n+\n+    // ...but the dynamic version does its own buffering already\n+    let writer = try!(writer.into_inner());\n+    let submitter = Arc::new(Mutex::new(BlockSubmitter { writer: writer, waiting_on: 0 }));\n \n-    out.write_all(b\">TWO IUB ambiguity codes\\n\").unwrap();\n-    let iub = sum_and_scale(&IUB);\n-    let mut random = RandomFasta::new(&mut out, &iub);\n-    random.make(n * 3).unwrap();\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">TWO IUB ambiguity codes\\n\", &IUB, rng, n * 3));\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">THREE Homo sapiens frequency\\n\", &HOMOSAPIENS, rng, n * 5));\n \n-    random.out.write_all(b\">THREE Homo sapiens frequency\\n\").unwrap();\n-    let homo_sapiens = sum_and_scale(&HOMO_SAPIENS);\n-    random.lookup = make_lookup(&homo_sapiens);\n-    random.make(n * 5).unwrap();\n+    Ok(())\n+}\n \n-    random.out.write_all(b\"\\n\").unwrap();\n+fn main() {\n+    run(io::stdout()).unwrap()\n }"}, {"sha": "a5731f150c6d024c6ef78cc3daccd02521e1c9b3", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 305, "deletions": 87, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/19fe7b6d6444424403be07699a8a312562ede51f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19fe7b6d6444424403be07699a8a312562ede51f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=19fe7b6d6444424403be07699a8a312562ede51f", "patch": "@@ -39,114 +39,332 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::cmp::min;\n-use std::env;\n-use std::fs::File;\n-use std::io::{self, BufWriter};\n-use std::io::prelude::*;\n+use std::io::{self, Write};\n+use std::sync::{Arc, Mutex};\n+use std::thread;\n \n-const LINE_LENGTH: usize = 60;\n-const IM: u32 = 139968;\n \n-struct MyRandom {\n+const LINE_LEN: usize = 60;\n+\n+const BLOCK_LINES: usize = 512;\n+const BLOCK_THOROUGHPUT: usize = LINE_LEN * BLOCK_LINES;\n+const BLOCK_LEN: usize = BLOCK_THOROUGHPUT + BLOCK_LINES;\n+\n+const STDIN_BUF: usize = (LINE_LEN + 1) * 1024;\n+\n+\n+const ALU: &'static [u8] =\n+    b\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n+      GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n+      CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n+      ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n+      GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n+      AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n+      AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+const IUB: &'static [(u8, f32)] =\n+    &[(b'a', 0.27), (b'c', 0.12), (b'g', 0.12),\n+      (b't', 0.27), (b'B', 0.02), (b'D', 0.02),\n+      (b'H', 0.02), (b'K', 0.02), (b'M', 0.02),\n+      (b'N', 0.02), (b'R', 0.02), (b'S', 0.02),\n+      (b'V', 0.02), (b'W', 0.02), (b'Y', 0.02)];\n+\n+const HOMOSAPIENS: &'static [(u8, f32)] =\n+    &[(b'a', 0.3029549426680),\n+      (b'c', 0.1979883004921),\n+      (b'g', 0.1975473066391),\n+      (b't', 0.3015094502008)];\n+\n+\n+// We need a specific Rng,\n+// so implement this manually\n+const MODULUS: u32 = 139968;\n+const MULTIPLIER: u32 = 3877;\n+const ADDITIVE: u32 = 29573;\n+\n+// Why doesn't rust already have this?\n+// Algorithm directly taken from Wikipedia\n+fn powmod(mut base: u64, mut exponent: u32, modulus: u64) -> u64 {\n+    let mut ret = 1;\n+    base %= modulus;\n+\n+    while exponent > 0 {\n+        if exponent & 1 == 1 {\n+           ret *= base;\n+           ret %= modulus;\n+        }\n+        exponent >>= 1;\n+        base *= base;\n+        base %= modulus;\n+    }\n+\n+    ret\n+}\n+\n+// Just a typical LCRNG\n+pub struct Rng {\n     last: u32\n }\n-impl MyRandom {\n-    fn new() -> MyRandom { MyRandom { last: 42 } }\n-    fn normalize(p: f32) -> u32 {(p * IM as f32).floor() as u32}\n-    fn gen(&mut self) -> u32 {\n-        self.last = (self.last * 3877 + 29573) % IM;\n+\n+impl Rng {\n+    pub fn new() -> Rng {\n+        Rng { last: 42 }\n+    }\n+\n+    pub fn max_value() -> u32 {\n+        MODULUS - 1\n+    }\n+\n+    pub fn normalize(p: f32) -> u32 {\n+        (p * MODULUS as f32).floor() as u32\n+    }\n+\n+    pub fn gen(&mut self) -> u32 {\n+        self.last = (self.last * MULTIPLIER + ADDITIVE) % MODULUS;\n         self.last\n     }\n+\n+    // This allows us to fast-forward the RNG,\n+    // allowing us to run it in parallel.\n+    pub fn future(&self, n: u32) -> Rng {\n+        let a = MULTIPLIER as u64;\n+        let b = ADDITIVE as u64;\n+        let m = MODULUS as u64;\n+\n+        //                          (a^n - 1) mod (a-1) m\n+        // x_k = ((a^n x_0 mod m) + --------------------- b) mod m\n+        //                                   a - 1\n+        //\n+        // Since (a - 1) divides (a^n - 1) mod (a-1) m,\n+        // the subtraction does not overflow and thus can be non-modular.\n+        //\n+        let new_seed =\n+            (powmod(a, n, m) * self.last as u64) % m +\n+            (powmod(a, n, (a-1) * m) - 1) / (a-1) * b;\n+\n+        Rng { last: (new_seed % m) as u32 }\n+    }\n }\n \n-struct AAGen<'a> {\n-    rng: &'a mut MyRandom,\n-    data: Vec<(u32, u8)>\n+\n+// This will end up keeping track of threads, like\n+// in the other multithreaded Rust version, in\n+// order to keep writes in order.\n+//\n+// This is stolen from another multithreaded Rust\n+// implementation, although that implementation\n+// was not able to parallelize the RNG itself.\n+struct BlockSubmitter<W: io::Write> {\n+    writer: W,\n+    pub waiting_on: usize,\n }\n-impl<'a> AAGen<'a> {\n-    fn new<'b>(rng: &'b mut MyRandom, aa: &[(char, f32)]) -> AAGen<'b> {\n-        let mut cum = 0.;\n-        let data = aa.iter()\n-            .map(|&(ch, p)| { cum += p; (MyRandom::normalize(cum), ch as u8) })\n-            .collect();\n-        AAGen { rng: rng, data: data }\n+\n+impl<W: io::Write> BlockSubmitter<W> {\n+    fn submit(&mut self, data: &[u8], block_num: usize) -> Option<io::Result<()>> {\n+        if block_num == self.waiting_on {\n+            self.waiting_on += 1;\n+            Some(self.submit_async(data))\n+        }\n+        else {\n+            None\n+        }\n     }\n-}\n-impl<'a> Iterator for AAGen<'a> {\n-    type Item = u8;\n-\n-    fn next(&mut self) -> Option<u8> {\n-        let r = self.rng.gen();\n-        self.data.iter()\n-            .skip_while(|pc| pc.0 < r)\n-            .map(|&(_, c)| c)\n-            .next()\n+\n+    fn submit_async(&mut self, data: &[u8]) -> io::Result<()> {\n+        self.writer.write_all(data)\n     }\n }\n \n-fn make_fasta<W: Write, I: Iterator<Item=u8>>(\n-    wr: &mut W, header: &str, mut it: I, mut n: usize)\n-    -> io::Result<()>\n+\n+// For repeating strings as output\n+fn fasta_static<W: io::Write>(\n+    writer: &mut W,\n+    header: &[u8],\n+    data: &[u8],\n+    mut n: usize\n+) -> io::Result<()>\n {\n-    try!(wr.write(header.as_bytes()));\n-    let mut line = [0; LINE_LENGTH + 1];\n+    // The aim here is to print a short(ish) string cyclically\n+    // with line breaks as appropriate.\n+    //\n+    // The secret technique is to repeat the string such that\n+    // any wanted line is a single offset in the string.\n+    //\n+    // This technique is stolen from the Haskell version.\n+\n+    try!(writer.write_all(header));\n+\n+    // Maximum offset is data.len(),\n+    // Maximum read len is LINE_LEN\n+    let stream = data.iter().cloned().cycle();\n+    let mut extended: Vec<u8> = stream.take(data.len() + LINE_LEN + 1).collect();\n+\n+    let mut offset = 0;\n     while n > 0 {\n-        let nb = min(LINE_LENGTH, n);\n-        for i in 0..nb {\n-            line[i] = it.next().unwrap();\n+        let write_len = min(LINE_LEN, n);\n+        let end = offset + write_len;\n+        n -= write_len;\n+\n+        let tmp = extended[end];\n+        extended[end] = b'\\n';\n+        try!(writer.write_all(&extended[offset..end + 1]));\n+        extended[end] = tmp;\n+\n+        offset = end;\n+        offset %= data.len();\n+    }\n+\n+    Ok(())\n+}\n+\n+\n+// For RNG streams as output\n+fn fasta<W: io::Write + Send + 'static>(\n+    submitter: &Arc<Mutex<BlockSubmitter<W>>>,\n+    header: &[u8],\n+    table: &[(u8, f32)],\n+    rng: &mut Rng,\n+    n: usize\n+) -> io::Result<()>\n+{\n+    // There's another secret technique in use here:\n+    // we generate a lookup table to cache search of the\n+    // aa buffer.\n+    //\n+    // The secret technique used is stolen from Haskell's\n+    // implementation, and is the main secret to the Haskell\n+    // implementation's  speed.\n+    fn gen_lookup_table(aa: &[(u8, f32)]) -> Vec<u8> {\n+        let mut table = Vec::with_capacity(Rng::max_value() as usize + 1);\n+\n+        let mut cumulative_prob = 0.0;\n+        let mut cumulative_norm = 0;\n+\n+        for &(byte, prob) in aa {\n+            let last_norm = cumulative_norm;\n+            cumulative_prob += prob;\n+            cumulative_norm = min(Rng::max_value(), Rng::normalize(cumulative_prob)) + 1;\n+\n+            table.extend((0..cumulative_norm - last_norm).map(|_| byte));\n         }\n-        n -= nb;\n-        line[nb] = '\\n' as u8;\n-        try!(wr.write(&line[..nb+1]));\n+\n+        table\n+    }\n+\n+    {\n+        try!(submitter.lock().unwrap().submit_async(header));\n     }\n+\n+    let lookup_table = Arc::new(gen_lookup_table(table));\n+\n+    let thread_count = 4; // avoid external dependency\n+    let mut threads = Vec::new();\n+    for block_num in (0..thread_count) {\n+        let offset = BLOCK_THOROUGHPUT * block_num;\n+\n+        let local_submitter = submitter.clone();\n+        let local_lookup_table = lookup_table.clone();\n+        let local_rng = rng.future(offset as u32);\n+\n+        threads.push(thread::spawn(move || {\n+            gen_block(\n+                local_submitter,\n+                local_lookup_table,\n+                local_rng,\n+                n.saturating_sub(offset),\n+                block_num,\n+                thread_count\n+            )\n+        }));\n+    }\n+\n+    for thread in threads {\n+        try!(thread.join().unwrap());\n+    }\n+\n+    *rng = rng.future(n as u32);\n+\n     Ok(())\n }\n \n-fn run<W: Write>(writer: &mut W) -> io::Result<()> {\n-    let mut args = env::args();\n-    let n = if env::var_os(\"RUST_BENCH\").is_some() {\n-        25000000\n-    } else if args.len() <= 1 {\n-        1000\n-    } else {\n-        args.nth(1).unwrap().parse().unwrap()\n-    };\n-\n-    let rng = &mut MyRandom::new();\n-    let alu =\n-        \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n-        GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n-        CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n-        ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n-        GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n-        AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n-        AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-    let iub = &[('a', 0.27), ('c', 0.12), ('g', 0.12),\n-                ('t', 0.27), ('B', 0.02), ('D', 0.02),\n-                ('H', 0.02), ('K', 0.02), ('M', 0.02),\n-                ('N', 0.02), ('R', 0.02), ('S', 0.02),\n-                ('V', 0.02), ('W', 0.02), ('Y', 0.02)];\n-    let homosapiens = &[('a', 0.3029549426680),\n-                        ('c', 0.1979883004921),\n-                        ('g', 0.1975473066391),\n-                        ('t', 0.3015094502008)];\n-\n-    try!(make_fasta(writer, \">ONE Homo sapiens alu\\n\",\n-                    alu.as_bytes().iter().cycle().cloned(), n * 2));\n-    try!(make_fasta(writer, \">TWO IUB ambiguity codes\\n\",\n-                    AAGen::new(rng, iub), n * 3));\n-    try!(make_fasta(writer, \">THREE Homo sapiens frequency\\n\",\n-                    AAGen::new(rng, homosapiens), n * 5));\n-\n-    writer.flush()\n+// A very optimized writer.\n+// I have a feeling a simpler version wouldn't slow\n+// things down too much, though, since the RNG\n+// is the really heavy hitter.\n+fn gen_block<W: io::Write>(\n+    submitter: Arc<Mutex<BlockSubmitter<W>>>,\n+    lookup_table: Arc<Vec<u8>>,\n+    mut rng: Rng,\n+    mut length: usize,\n+    mut block_num: usize,\n+    block_stride: usize,\n+) -> io::Result<()>\n+{\n+    // Include newlines in block\n+    length += length / LINE_LEN;\n+    let block: &mut [u8] = &mut [b'\\n'; BLOCK_LEN];\n+\n+    while length > 0 {\n+        {\n+            let gen_into = &mut block[..min(length, BLOCK_LEN)];\n+\n+            // Write random numbers, skipping newlines\n+            for (i, byte) in gen_into.iter_mut().enumerate() {\n+                if (i + 1) % (LINE_LEN + 1) != 0 {\n+                    *byte = lookup_table[rng.gen() as usize];\n+                }\n+            }\n+        }\n+\n+        let write_out = {\n+            if length >= BLOCK_LEN               { &mut *block }\n+            else if length % (LINE_LEN + 1) == 0 { &mut block[..length] }\n+            else                                 { &mut block[..length + 1] }\n+        };\n+\n+        *write_out.last_mut().unwrap() = b'\\n';\n+        loop {\n+            match submitter.lock().unwrap().submit(write_out, block_num) {\n+                Some(result) => { try!(result); break; }\n+                None => std::thread::yield_now()\n+            }\n+        }\n+        block_num += block_stride;\n+        rng = rng.future((BLOCK_THOROUGHPUT * (block_stride - 1)) as u32);\n+        length = length.saturating_sub(BLOCK_LEN * (block_stride - 1));\n+\n+        length = length.saturating_sub(BLOCK_LEN);\n+    }\n+\n+    Ok(())\n }\n \n+\n+fn run<W: io::Write + Send + 'static>(writer: W) -> io::Result<()> {\n+    let n = std::env::args_os().nth(1)\n+        .and_then(|s| s.into_string().ok())\n+        .and_then(|n| n.parse().ok())\n+        .unwrap_or(1000);\n+\n+    let rng = &mut Rng::new();\n+\n+    // Use automatic buffering for the static version...\n+    let mut writer = io::BufWriter::with_capacity(STDIN_BUF, writer);\n+    try!(fasta_static(&mut writer, b\">ONE Homo sapiens alu\\n\", ALU, n * 2));\n+\n+    // ...but the dynamic version does its own buffering already\n+    let writer = try!(writer.into_inner());\n+    let submitter = Arc::new(Mutex::new(BlockSubmitter { writer: writer, waiting_on: 0 }));\n+\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">TWO IUB ambiguity codes\\n\", &IUB, rng, n * 3));\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">THREE Homo sapiens frequency\\n\", &HOMOSAPIENS, rng, n * 5));\n+\n+    Ok(())\n+}\n+\n+\n fn main() {\n-    let res = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let mut file = BufWriter::new(File::create(\"./shootout-fasta.data\").unwrap());\n-        run(&mut file)\n-    } else {\n-        run(&mut io::stdout())\n-    };\n-    res.unwrap()\n+    run(io::stdout()).unwrap()\n }"}]}