{"sha": "fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "node_id": "C_kwDOAAsO6NoAKGZiMmQwZjVjMDNkMmY2OTllYjg3YmMxOTg2Mzg2YmRjZjZhM2Y2ZWI", "commit": {"author": {"name": "John Kugelman", "email": "john@kugelman.name", "date": "2021-10-14T23:56:53Z"}, "committer": {"name": "Kugelman, John R", "email": "Kugelman.John@vast-inc.com", "date": "2021-10-15T15:46:49Z"}, "message": "Add #[must_use] to remaining alloc functions", "tree": {"sha": "28c56c4502ee837b968171f9508e6f4ca87deed5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28c56c4502ee837b968171f9508e6f4ca87deed5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "html_url": "https://github.com/rust-lang/rust/commit/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/comments", "author": {"login": "jkugelman", "id": 4551859, "node_id": "MDQ6VXNlcjQ1NTE4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4551859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkugelman", "html_url": "https://github.com/jkugelman", "followers_url": "https://api.github.com/users/jkugelman/followers", "following_url": "https://api.github.com/users/jkugelman/following{/other_user}", "gists_url": "https://api.github.com/users/jkugelman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkugelman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkugelman/subscriptions", "organizations_url": "https://api.github.com/users/jkugelman/orgs", "repos_url": "https://api.github.com/users/jkugelman/repos", "events_url": "https://api.github.com/users/jkugelman/events{/privacy}", "received_events_url": "https://api.github.com/users/jkugelman/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1e9319d93aea755c444c8f8ff863b0936d7a4b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1e9319d93aea755c444c8f8ff863b0936d7a4b6", "html_url": "https://github.com/rust-lang/rust/commit/e1e9319d93aea755c444c8f8ff863b0936d7a4b6"}], "stats": {"total": 101, "additions": 78, "deletions": 23}, "files": [{"sha": "89c21929dbcda121f7e1183515775682a492e472", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -290,7 +290,7 @@ where\n         let mut c = 0;\n         for i in 0..BENCH_RANGE_SIZE {\n             for j in i + 1..BENCH_RANGE_SIZE {\n-                black_box(map.range(f(i, j)));\n+                let _ = black_box(map.range(f(i, j)));\n                 c += 1;\n             }\n         }\n@@ -322,7 +322,7 @@ fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n         for _ in 0..repeats {\n-            black_box(map.iter());\n+            let _ = black_box(map.iter());\n         }\n     });\n }"}, {"sha": "a73eeac6115843a4102dbd777f529f83ce0a9cca", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -512,6 +512,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();\n@@ -850,7 +851,6 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n     /// ```\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n     pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n         IntoIterSorted { inner: self }\n@@ -877,6 +877,7 @@ impl<T> BinaryHeap<T> {\n     /// # Time complexity\n     ///\n     /// Cost is *O*(1) in the worst case.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -894,6 +895,7 @@ impl<T> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n         self.data.capacity()\n@@ -1203,6 +1205,7 @@ impl<T> Drop for Hole<'_, T> {\n /// documentation for more.\n ///\n /// [`iter`]: BinaryHeap::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n@@ -1337,6 +1340,7 @@ impl<I> AsIntoIter for IntoIter<I> {\n     }\n }\n \n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n #[derive(Clone, Debug)]\n pub struct IntoIterSorted<T> {"}, {"sha": "3a77cdeac6d09e516b148ad9ec85f3e66ea66392", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -288,6 +288,7 @@ where\n /// documentation for more.\n ///\n /// [`iter`]: BTreeMap::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: LazyLeafRange<marker::Immut<'a>, K, V>,\n@@ -316,6 +317,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -359,6 +361,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n /// documentation for more.\n ///\n /// [`keys`]: BTreeMap::keys\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -377,6 +380,7 @@ impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// documentation for more.\n ///\n /// [`values`]: BTreeMap::values\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -395,6 +399,7 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n /// documentation for more.\n ///\n /// [`values_mut`]: BTreeMap::values_mut\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n@@ -413,6 +418,7 @@ impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n /// See its documentation for more.\n ///\n /// [`into_keys`]: BTreeMap::into_keys\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n pub struct IntoKeys<K, V> {\n     inner: IntoIter<K, V>,\n@@ -431,6 +437,7 @@ impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n /// See its documentation for more.\n ///\n /// [`into_values`]: BTreeMap::into_values\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n pub struct IntoValues<K, V> {\n     inner: IntoIter<K, V>,\n@@ -449,6 +456,7 @@ impl<K, V: fmt::Debug> fmt::Debug for IntoValues<K, V> {\n /// documentation for more.\n ///\n /// [`range`]: BTreeMap::range\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n     inner: LeafRange<marker::Immut<'a>, K, V>,\n@@ -467,6 +475,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// documentation for more.\n ///\n /// [`range_mut`]: BTreeMap::range_mut\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n     inner: LeafRange<marker::ValMut<'a>, K, V>,\n@@ -1265,7 +1274,6 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[inline]\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_keys(self) -> IntoKeys<K, V> {\n         IntoKeys { inner: self.into_iter() }\n@@ -1288,7 +1296,6 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n     /// ```\n     #[inline]\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_values(self) -> IntoValues<K, V> {\n         IntoValues { inner: self.into_iter() }"}, {"sha": "5cef007a46f0d1ea9d725fd87c3b8f703288426c", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -347,6 +347,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// map.entry(\"poneyland\").or_insert(12);\n     /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n@@ -391,6 +392,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     ///     assert_eq!(o.get(), &12);\n     /// }\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1"}, {"sha": "17389657afb92564e0371865ff1f5a43f707446a", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -744,35 +744,35 @@ fn test_range_equal_empty_cases() {\n #[should_panic]\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(2), Excluded(2)));\n+    let _ = map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Included(3), Included(2)));\n+    let _ = map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Included(3), Excluded(2)));\n+    let _ = map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(3), Included(2)));\n+    let _ = map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(3), Excluded(2)));\n+    let _ = map.range((Excluded(3), Excluded(2)));\n }\n \n #[test]\n@@ -783,7 +783,7 @@ fn test_range_finding_ill_order_in_map() {\n     // we cause a different panic than `test_range_backwards_1` does.\n     // A more refined `should_panic` would be welcome.\n     if Cyclic3::C < Cyclic3::A {\n-        map.range(Cyclic3::C..=Cyclic3::A);\n+        let _ = map.range(Cyclic3::C..=Cyclic3::A);\n     }\n }\n \n@@ -824,7 +824,7 @@ fn test_range_finding_ill_order_in_range_ord() {\n     }\n \n     let map = (0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())).collect::<BTreeMap<_, _>>();\n-    map.range(EvilTwin(5)..=EvilTwin(7));\n+    let _ = map.range(EvilTwin(5)..=EvilTwin(7));\n }\n \n #[test]\n@@ -1239,32 +1239,32 @@ fn test_borrow() {\n \n     #[allow(dead_code)]\n     fn get<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get(t);\n+        let _ = v.get(t);\n     }\n \n     #[allow(dead_code)]\n     fn get_mut<T: Ord>(v: &mut BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get_mut(t);\n+        let _ = v.get_mut(t);\n     }\n \n     #[allow(dead_code)]\n     fn get_key_value<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get_key_value(t);\n+        let _ = v.get_key_value(t);\n     }\n \n     #[allow(dead_code)]\n     fn contains_key<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.contains_key(t);\n+        let _ = v.contains_key(t);\n     }\n \n     #[allow(dead_code)]\n     fn range<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: T) {\n-        v.range(t..);\n+        let _ = v.range(t..);\n     }\n \n     #[allow(dead_code)]\n     fn range_mut<T: Ord>(v: &mut BTreeMap<Box<T>, ()>, t: T) {\n-        v.range_mut(t..);\n+        let _ = v.range_mut(t..);\n     }\n \n     #[allow(dead_code)]"}, {"sha": "b112cb6e41839547ddf2f1b7fcd44760c2af8a4a", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -92,6 +92,7 @@ impl<T: Clone> Clone for BTreeSet<T> {\n /// See its documentation for more.\n ///\n /// [`iter`]: BTreeSet::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>,\n@@ -123,6 +124,7 @@ pub struct IntoIter<T> {\n /// See its documentation for more.\n ///\n /// [`range`]: BTreeSet::range\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n@@ -668,6 +670,7 @@ impl<T> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.first(), Some(&1));\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first(&self) -> Option<&T>\n     where\n@@ -694,6 +697,7 @@ impl<T> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.last(), Some(&2));\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last(&self) -> Option<&T>\n     where"}, {"sha": "01cf62b32eccd5f02cb6ae204c8beb71d548174d", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -613,8 +613,8 @@ fn test_ord_absence() {\n         set.is_empty();\n         set.len();\n         set.clear();\n-        set.iter();\n-        set.into_iter();\n+        let _ = set.iter();\n+        let _ = set.into_iter();\n     }\n \n     fn set_debug<K: Debug>(set: BTreeSet<K>) {"}, {"sha": "4c74113338774a92f1e77b4852d2842cbefc59e8", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -64,6 +64,7 @@ struct Node<T> {\n ///\n /// This `struct` is created by [`LinkedList::iter()`]. See its\n /// documentation for more.\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -99,6 +100,7 @@ impl<T> Clone for Iter<'_, T> {\n ///\n /// This `struct` is created by [`LinkedList::iter_mut()`]. See its\n /// documentation for more.\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -529,6 +531,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_front(&self) -> Cursor<'_, T> {\n         Cursor { index: 0, current: self.head, list: self }\n@@ -538,6 +541,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n         CursorMut { index: 0, current: self.head, list: self }\n@@ -547,6 +551,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_back(&self) -> Cursor<'_, T> {\n         Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n@@ -556,6 +561,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n         CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n@@ -678,6 +684,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.front(), Some(&1));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         unsafe { self.head.as_ref().map(|node| &node.as_ref().element) }\n@@ -706,6 +713,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.front(), Some(&5));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         unsafe { self.head.as_mut().map(|node| &mut node.as_mut().element) }\n@@ -728,6 +736,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.back(), Some(&1));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         unsafe { self.tail.as_ref().map(|node| &node.as_ref().element) }\n@@ -1178,6 +1187,7 @@ impl<'a, T> Cursor<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn index(&self) -> Option<usize> {\n         let _ = self.current?;\n@@ -1232,6 +1242,7 @@ impl<'a, T> Cursor<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&self) -> Option<&'a T> {\n         unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n@@ -1242,6 +1253,7 @@ impl<'a, T> Cursor<'a, T> {\n     /// If the cursor is pointing to the \"ghost\" non-element then this returns\n     /// the first element of the `LinkedList`. If it is pointing to the last\n     /// element of the `LinkedList` then this returns `None`.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_next(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1258,6 +1270,7 @@ impl<'a, T> Cursor<'a, T> {\n     /// If the cursor is pointing to the \"ghost\" non-element then this returns\n     /// the last element of the `LinkedList`. If it is pointing to the first\n     /// element of the `LinkedList` then this returns `None`.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_prev(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1271,13 +1284,15 @@ impl<'a, T> Cursor<'a, T> {\n \n     /// Provides a reference to the front element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front(&self) -> Option<&'a T> {\n         self.list.front()\n     }\n \n     /// Provides a reference to the back element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back(&self) -> Option<&'a T> {\n         self.list.back()\n@@ -1289,6 +1304,7 @@ impl<'a, T> CursorMut<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn index(&self) -> Option<usize> {\n         let _ = self.current?;\n@@ -1343,6 +1359,7 @@ impl<'a, T> CursorMut<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&mut self) -> Option<&mut T> {\n         unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n@@ -1631,20 +1648,23 @@ impl<'a, T> CursorMut<'a, T> {\n \n     /// Provides a reference to the front element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list.front()\n     }\n \n     /// Provides a mutable reference to the front element of the cursor's\n     /// parent list, or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list.front_mut()\n     }\n \n     /// Provides a reference to the back element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list.back()\n@@ -1671,6 +1691,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// assert_eq!(contents.next(), Some(0));\n     /// assert_eq!(contents.next(), None);\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list.back_mut()"}, {"sha": "1ea135a2aed82aaa12d71598a977e7737eda0277", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -65,6 +65,7 @@ pub struct TryReserveError {\n impl TryReserveError {\n     /// Details about the allocation that caused the error\n     #[inline]\n+    #[must_use]\n     #[unstable(\n         feature = \"try_reserve_kind\",\n         reason = \"Uncertain how much info should be exposed\","}, {"sha": "50e789d76b7f3b951bf2f581f8d74e3f7ebdc633", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -572,6 +572,7 @@ use crate::string;\n /// [`format_args!`]: core::format_args\n /// [`format!`]: crate::format\n #[cfg(not(no_global_oom_handling))]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "2950ec421da9ed58cebedb38ee7757b5f0898b36", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -2246,6 +2246,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong() } else { 0 }\n@@ -2254,6 +2255,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If no strong pointers remain, this will return zero.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -2324,6 +2326,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()"}, {"sha": "3b875477df3b86f2e21509d64755e6662033b5e9", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -243,6 +243,7 @@ impl str {\n     /// assert_eq!(*boxed_bytes, *s.as_bytes());\n     /// ```\n     #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n         self.into()\n@@ -484,6 +485,7 @@ impl str {\n     /// assert_eq!(boxed_str.into_string(), string);\n     /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_string(self: Box<str>) -> String {\n         let slice = Box::<[u8]>::from(self);\n@@ -508,9 +510,10 @@ impl str {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// \"0123456789abcdef\".repeat(usize::MAX);\n+    /// let huge = \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use]\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n         unsafe { String::from_utf8_unchecked(self.as_bytes().repeat(n)) }"}, {"sha": "14ebc4dfe8b90b584f01e67b325e2260afc73165", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -898,6 +898,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n         self.vec.capacity()\n@@ -1822,6 +1823,7 @@ impl FromUtf8Error {\n     /// // the first byte is invalid here\n     /// assert_eq!(1, error.valid_up_to());\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error {\n         self.error"}, {"sha": "039971a17654883ec0bee66bcf6773d4cf5e30d8", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -953,6 +953,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(1, Arc::weak_count(&five));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn weak_count(this: &Self) -> usize {\n         let cnt = this.inner().weak.load(SeqCst);\n@@ -982,6 +983,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(2, Arc::strong_count(&five));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.inner().strong.load(SeqCst)\n@@ -1079,8 +1081,6 @@ impl<T: ?Sized> Arc<T> {\n         drop(Weak { ptr: self.ptr });\n     }\n \n-    #[inline]\n-    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Arc`s point to the same allocation\n     /// (in a vein similar to [`ptr::eq`]).\n     ///\n@@ -1098,6 +1098,9 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     ///\n     /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n+    #[inline]\n+    #[must_use]\n+    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1904,6 +1907,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong.load(SeqCst) } else { 0 }\n@@ -1920,6 +1924,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n     /// `Weak`s pointing to the same allocation.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -1999,6 +2004,7 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()"}, {"sha": "ff98091a0d2abf18924b663e78634c827fce6e38", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "patch": "@@ -60,6 +60,7 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n \n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[must_use]\n     #[inline]\n     pub fn allocator(&self) -> &A {\n         unsafe { self.vec.as_ref().allocator() }"}]}