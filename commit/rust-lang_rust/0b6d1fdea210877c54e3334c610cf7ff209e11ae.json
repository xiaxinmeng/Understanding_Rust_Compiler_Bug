{"sha": "0b6d1fdea210877c54e3334c610cf7ff209e11ae", "node_id": "C_kwDOAAsO6NoAKDBiNmQxZmRlYTIxMDg3N2M1NGUzMzM0YzYxMGNmN2ZmMjA5ZTExYWU", "commit": {"author": {"name": "hotate29", "email": "hotate_oc@yahoo.co.jp", "date": "2021-12-15T14:23:36Z"}, "committer": {"name": "hotate29", "email": "hotate_oc@yahoo.co.jp", "date": "2021-12-24T15:29:29Z"}, "message": "refactor ```Sugg::BinOp```", "tree": {"sha": "b821a59830f4af682bd024ea6703bf68e67a3e04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b821a59830f4af682bd024ea6703bf68e67a3e04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b6d1fdea210877c54e3334c610cf7ff209e11ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEaFZ9ibIIMdUY9nqJ23IOcqY4C1oFAmHF51kACgkQ23IOcqY4\nC1qUjhAAlCcw2enPROQvShVZB8tmeWhaclBAwlAV+/pLDpDRoNlrgCGgiO+Ji1kB\nEcYhNdDQkjHka8i6pCbEDHbtRZ5b/Q0aeRMGsoWHxj77sMJl9H9t/dUMAiIUDYBb\notC2TlpTwa09UKui1cmF2kq0S+S4sqxVtDXr1+z+rZ+MNcJGSrR0SZWXBbEDNnYc\n8dm/RZTRxeFCSqDMKTAX15KSvP8Dq/rRKjDgDJN/TGZ8sxA7uyB5ILuwORX9ysbP\nJ58VLmAwayNGOXWb155MpUHXBN+Hp4qEh4hGDGqQlHmYo/hw7YE7oC202ka6+RCQ\nM+41eYlQp5isvCESDOisNGGD+O0u59A5I37B//0yjBHc97ZfkOym/g5IrygnQ38b\nk6A80Ob2fRuFh1H54vyLZAUevgHv2Prlie2NtPhudzwLgHoCu/ICIYXdS4xGbouH\nKIBfSNSZe4AwlOMewQ/C7NYN/+iBrfsOtkQAkWxU3FcNumEFMy7REYMOqtRHEVCj\n1sMqhgAS8sUMhrf/85+9s+oQd5Ab54CL5sib7YnzIOjtxstyHDj26WYaQsPn/HJI\nDxdAKDlpkFMasDur+JHO5PhcSBqTe34/7FEM3YBe6wgEUv4iazhfqMqsGBKj3VZC\nThK8Yxqk+iqzAfDJ5Mre7WoauuEBoN+1w4oonfVJA31cifE7eQA=\n=2KZg\n-----END PGP SIGNATURE-----", "payload": "tree b821a59830f4af682bd024ea6703bf68e67a3e04\nparent b3b65a1bf6790af0bbaf6dba2e6a688ecd6e9387\nauthor hotate29 <hotate_oc@yahoo.co.jp> 1639578216 +0900\ncommitter hotate29 <hotate_oc@yahoo.co.jp> 1640359769 +0900\n\nrefactor ```Sugg::BinOp```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6d1fdea210877c54e3334c610cf7ff209e11ae", "html_url": "https://github.com/rust-lang/rust/commit/0b6d1fdea210877c54e3334c610cf7ff209e11ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b6d1fdea210877c54e3334c610cf7ff209e11ae/comments", "author": {"login": "hotate29", "id": 44938840, "node_id": "MDQ6VXNlcjQ0OTM4ODQw", "avatar_url": "https://avatars.githubusercontent.com/u/44938840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hotate29", "html_url": "https://github.com/hotate29", "followers_url": "https://api.github.com/users/hotate29/followers", "following_url": "https://api.github.com/users/hotate29/following{/other_user}", "gists_url": "https://api.github.com/users/hotate29/gists{/gist_id}", "starred_url": "https://api.github.com/users/hotate29/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hotate29/subscriptions", "organizations_url": "https://api.github.com/users/hotate29/orgs", "repos_url": "https://api.github.com/users/hotate29/repos", "events_url": "https://api.github.com/users/hotate29/events{/privacy}", "received_events_url": "https://api.github.com/users/hotate29/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hotate29", "id": 44938840, "node_id": "MDQ6VXNlcjQ0OTM4ODQw", "avatar_url": "https://avatars.githubusercontent.com/u/44938840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hotate29", "html_url": "https://github.com/hotate29", "followers_url": "https://api.github.com/users/hotate29/followers", "following_url": "https://api.github.com/users/hotate29/following{/other_user}", "gists_url": "https://api.github.com/users/hotate29/gists{/gist_id}", "starred_url": "https://api.github.com/users/hotate29/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hotate29/subscriptions", "organizations_url": "https://api.github.com/users/hotate29/orgs", "repos_url": "https://api.github.com/users/hotate29/repos", "events_url": "https://api.github.com/users/hotate29/events{/privacy}", "received_events_url": "https://api.github.com/users/hotate29/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3b65a1bf6790af0bbaf6dba2e6a688ecd6e9387", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b65a1bf6790af0bbaf6dba2e6a688ecd6e9387", "html_url": "https://github.com/rust-lang/rust/commit/b3b65a1bf6790af0bbaf6dba2e6a688ecd6e9387"}], "stats": {"total": 304, "additions": 166, "deletions": 138}, "files": [{"sha": "c62fa5e998bd475da630f949ac6198c71ce02a97", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=0b6d1fdea210877c54e3334c610cf7ff209e11ae", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Pat, PatKind, StmtKind}\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n+use std::fmt::Display;\n use std::iter::Iterator;\n \n /// Checks for for loops that sequentially copy items from one slice-like\n@@ -108,7 +109,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     src: &IndexExpr<'_>,\n ) -> String {\n     fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        if offset.as_str() == \"0\" {\n+        if offset.to_string() == \"0\" {\n             sugg::EMPTY.into()\n         } else {\n             offset\n@@ -123,7 +124,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n             if let Some(arg) = len_args.get(0);\n             if path_to_local(arg) == path_to_local(base);\n             then {\n-                if sugg.as_str() == end_str {\n+                if sugg.to_string() == end_str {\n                     sugg::EMPTY.into()\n                 } else {\n                     sugg\n@@ -147,7 +148,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n             print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n             print_limit(\n                 end,\n-                end_str.as_str(),\n+                end_str.to_string().as_str(),\n                 idx_expr.base,\n                 apply_offset(&end_str, &idx_expr.idx_offset),\n             )\n@@ -159,7 +160,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n                 print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n                 print_limit(\n                     end,\n-                    end_str.as_str(),\n+                    end_str.to_string().as_str(),\n                     idx_expr.base,\n                     apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n                 )\n@@ -202,12 +203,13 @@ fn build_manual_memcpy_suggestion<'tcx>(\n #[derive(Clone)]\n struct MinifyingSugg<'a>(Sugg<'a>);\n \n-impl<'a> MinifyingSugg<'a> {\n-    fn as_str(&self) -> &str {\n-        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n-        s.as_ref()\n+impl Display for MinifyingSugg<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        self.0.fmt(f)\n     }\n+}\n \n+impl<'a> MinifyingSugg<'a> {\n     fn into_sugg(self) -> Sugg<'a> {\n         self.0\n     }\n@@ -222,7 +224,7 @@ impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n impl std::ops::Add for &MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (\"0\", _) => rhs.clone(),\n             (_, \"0\") => self.clone(),\n             (_, _) => (&self.0 + &rhs.0).into(),\n@@ -233,7 +235,7 @@ impl std::ops::Add for &MinifyingSugg<'static> {\n impl std::ops::Sub for &MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (_, \"0\") => self.clone(),\n             (\"0\", _) => (-rhs.0.clone()).into(),\n             (x, y) if x == y => sugg::ZERO.into(),\n@@ -245,7 +247,7 @@ impl std::ops::Sub for &MinifyingSugg<'static> {\n impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (\"0\", _) => rhs.clone(),\n             (_, \"0\") => self,\n             (_, _) => (self.0 + &rhs.0).into(),\n@@ -256,7 +258,7 @@ impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n     type Output = MinifyingSugg<'static>;\n     fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n-        match (self.as_str(), rhs.as_str()) {\n+        match (self.to_string().as_str(), rhs.to_string().as_str()) {\n             (_, \"0\") => self,\n             (\"0\", _) => (-rhs.0.clone()).into(),\n             (x, y) if x == y => sugg::ZERO.into(),"}, {"sha": "778d49cb4b6ed1634cc1024bfad5e3d6883376bb", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=0b6d1fdea210877c54e3334c610cf7ff209e11ae", "patch": "@@ -187,14 +187,14 @@ impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n                 BinOpKind::Eq => {\n                     let true_case = Some((|h| h, \"equality checks against true are unnecessary\"));\n                     let false_case = Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"equality checks against false can be replaced by a negation\",\n                     ));\n                     check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal);\n                 },\n                 BinOpKind::Ne => {\n                     let true_case = Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"inequality checks against true can be replaced by a negation\",\n                     ));\n                     let false_case = Some((|h| h, \"inequality checks against false are unnecessary\"));\n@@ -206,27 +206,27 @@ impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n                     ignore_case,\n                     Some((|h| h, \"greater than checks against false are unnecessary\")),\n                     Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"less than comparison against true can be replaced by a negation\",\n                     )),\n                     ignore_case,\n                     Some((\n-                        |l: Sugg<'_>, r: Sugg<'_>| (!l).bit_and(&r),\n+                        |l: Sugg<'tcx>, r: Sugg<'tcx>| (!l).bit_and(&r),\n                         \"order comparisons between booleans can be simplified\",\n                     )),\n                 ),\n                 BinOpKind::Gt => check_comparison(\n                     cx,\n                     e,\n                     Some((\n-                        |h: Sugg<'_>| !h,\n+                        |h: Sugg<'tcx>| !h,\n                         \"less than comparison against true can be replaced by a negation\",\n                     )),\n                     ignore_case,\n                     ignore_case,\n                     Some((|h| h, \"greater than checks against false are unnecessary\")),\n                     Some((\n-                        |l: Sugg<'_>, r: Sugg<'_>| l.bit_and(&(!r)),\n+                        |l: Sugg<'tcx>, r: Sugg<'tcx>| l.bit_and(&(!r)),\n                         \"order comparisons between booleans can be simplified\",\n                     )),\n                 ),"}, {"sha": "0a240a8b76377fceeb8a839defc07fa1604619f3", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 145, "deletions": 119, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6d1fdea210877c54e3334c610cf7ff209e11ae/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=0b6d1fdea210877c54e3334c610cf7ff209e11ae", "patch": "@@ -1,9 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{\n-    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n-};\n+use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite};\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n@@ -33,7 +31,7 @@ pub enum Sugg<'a> {\n     MaybeParen(Cow<'a, str>),\n     /// A binary operator expression, including `as`-casts and explicit type\n     /// coercion.\n-    BinOp(AssocOp, Cow<'a, str>),\n+    BinOp(AssocOp, Cow<'a, str>, Cow<'a, str>),\n }\n \n /// Literal constant `0`, for convenience.\n@@ -46,7 +44,8 @@ pub const EMPTY: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"\"));\n impl Display for Sugg<'_> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match *self {\n-            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n+            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) => s.fmt(f),\n+            Sugg::BinOp(op, ref lhs, ref rhs) => binop_to_string(op, lhs, rhs).fmt(f),\n         }\n     }\n }\n@@ -55,10 +54,8 @@ impl Display for Sugg<'_> {\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n     pub fn hir_opt(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Self> {\n-        snippet_opt(cx, expr.span).map(|snippet| {\n-            let snippet = Cow::Owned(snippet);\n-            Self::hir_from_snippet(expr, snippet)\n-        })\n+        let get_snippet = |span| snippet(cx, span, \"\");\n+        snippet_opt(cx, expr.span).map(|_| Self::hir_from_snippet(expr, get_snippet))\n     }\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n@@ -93,9 +90,8 @@ impl<'a> Sugg<'a> {\n \n     /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n     pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n-        let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n-\n-        Self::hir_from_snippet(expr, snippet)\n+        let get_snippet = |span| snippet_with_macro_callsite(cx, span, default);\n+        Self::hir_from_snippet(expr, get_snippet)\n     }\n \n     /// Same as `hir`, but first walks the span up to the given context. This will result in the\n@@ -112,24 +108,26 @@ impl<'a> Sugg<'a> {\n         default: &'a str,\n         applicability: &mut Applicability,\n     ) -> Self {\n-        let (snippet, in_macro) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n-\n-        if in_macro {\n-            Sugg::NonParen(snippet)\n+        if expr.span.ctxt() == ctxt {\n+            Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            Self::hir_from_snippet(expr, snippet)\n+            let snip = snippet_with_applicability(cx, expr.span, default, applicability);\n+            Sugg::NonParen(snip)\n         }\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n+    fn hir_from_snippet(expr: &hir::Expr<'_>, get_snippet: impl Fn(Span) -> Cow<'a, str>) -> Self {\n         if let Some(range) = higher::Range::hir(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,\n             };\n-            return Sugg::BinOp(op, snippet);\n+            let start = range.start.map_or(\"\".into(), |expr| get_snippet(expr.span));\n+            let end = range.end.map_or(\"\".into(), |expr| get_snippet(expr.span));\n+\n+            return Sugg::BinOp(op, start, end);\n         }\n \n         match expr.kind {\n@@ -139,7 +137,7 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Let(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n-            | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            | hir::ExprKind::Match(..) => Sugg::MaybeParen(get_snippet(expr.span)),\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Yield(..)\n             | hir::ExprKind::Array(..)\n@@ -160,23 +158,33 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Tup(..)\n             | hir::ExprKind::DropTemps(_)\n-            | hir::ExprKind::Err => Sugg::NonParen(snippet),\n-            hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-            hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-            hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node.into()), snippet),\n-            hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-            hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+            | hir::ExprKind::Err => Sugg::NonParen(get_snippet(expr.span)),\n+            hir::ExprKind::Assign(lhs, rhs, _) => {\n+                Sugg::BinOp(AssocOp::Assign, get_snippet(lhs.span), get_snippet(rhs.span))\n+            },\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+                Sugg::BinOp(hirbinop2assignop(op), get_snippet(lhs.span), get_snippet(rhs.span))\n+            },\n+            hir::ExprKind::Binary(op, lhs, rhs) => Sugg::BinOp(\n+                AssocOp::from_ast_binop(op.node.into()),\n+                get_snippet(lhs.span),\n+                get_snippet(rhs.span),\n+            ),\n+            hir::ExprKind::Cast(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n+            hir::ExprKind::Type(lhs, ty) => Sugg::BinOp(AssocOp::Colon, get_snippet(lhs.span), get_snippet(ty.span)),\n         }\n     }\n \n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use rustc_ast::ast::RangeLimits;\n \n-        let snippet = if expr.span.from_expansion() {\n-            snippet_with_macro_callsite(cx, expr.span, default)\n-        } else {\n-            snippet(cx, expr.span, default)\n+        let get_whole_snippet = || {\n+            if expr.span.from_expansion() {\n+                snippet_with_macro_callsite(cx, expr.span, default)\n+            } else {\n+                snippet(cx, expr.span, default)\n+            }\n         };\n \n         match expr.kind {\n@@ -186,7 +194,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::If(..)\n             | ast::ExprKind::Let(..)\n             | ast::ExprKind::Unary(..)\n-            | ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            | ast::ExprKind::Match(..) => Sugg::MaybeParen(get_whole_snippet()),\n             ast::ExprKind::Async(..)\n             | ast::ExprKind::Block(..)\n             | ast::ExprKind::Break(..)\n@@ -215,14 +223,42 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::Array(..)\n             | ast::ExprKind::While(..)\n             | ast::ExprKind::Await(..)\n-            | ast::ExprKind::Err => Sugg::NonParen(snippet),\n-            ast::ExprKind::Range(.., RangeLimits::HalfOpen) => Sugg::BinOp(AssocOp::DotDot, snippet),\n-            ast::ExprKind::Range(.., RangeLimits::Closed) => Sugg::BinOp(AssocOp::DotDotEq, snippet),\n-            ast::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-            ast::ExprKind::AssignOp(op, ..) => Sugg::BinOp(astbinop2assignop(op), snippet),\n-            ast::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node), snippet),\n-            ast::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-            ast::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+            | ast::ExprKind::Err => Sugg::NonParen(get_whole_snippet()),\n+            ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::HalfOpen) => Sugg::BinOp(\n+                AssocOp::DotDot,\n+                lhs.as_ref().map_or(\"\".into(), |lhs| snippet(cx, lhs.span, default)),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| snippet(cx, rhs.span, default)),\n+            ),\n+            ast::ExprKind::Range(ref lhs, ref rhs, RangeLimits::Closed) => Sugg::BinOp(\n+                AssocOp::DotDotEq,\n+                lhs.as_ref().map_or(\"\".into(), |lhs| snippet(cx, lhs.span, default)),\n+                rhs.as_ref().map_or(\"\".into(), |rhs| snippet(cx, rhs.span, default)),\n+            ),\n+            ast::ExprKind::Assign(ref lhs, ref rhs, _) => Sugg::BinOp(\n+                AssocOp::Assign,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => Sugg::BinOp(\n+                astbinop2assignop(op),\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => Sugg::BinOp(\n+                AssocOp::from_ast_binop(op.node),\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, rhs.span, default),\n+            ),\n+            ast::ExprKind::Cast(ref lhs, ref ty) => Sugg::BinOp(\n+                AssocOp::As,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, ty.span, default),\n+            ),\n+            ast::ExprKind::Type(ref lhs, ref ty) => Sugg::BinOp(\n+                AssocOp::Colon,\n+                snippet(cx, lhs.span, default),\n+                snippet(cx, ty.span, default),\n+            ),\n         }\n     }\n \n@@ -306,17 +342,51 @@ impl<'a> Sugg<'a> {\n                     Sugg::NonParen(format!(\"({})\", sugg).into())\n                 }\n             },\n-            Sugg::BinOp(_, sugg) => {\n-                if has_enclosing_paren(&sugg) {\n-                    Sugg::NonParen(sugg)\n-                } else {\n-                    Sugg::NonParen(format!(\"({})\", sugg).into())\n-                }\n+            Sugg::BinOp(op, lhs, rhs) => {\n+                let sugg = binop_to_string(op, &lhs, &rhs);\n+                Sugg::NonParen(format!(\"({})\", sugg).into())\n             },\n         }\n     }\n }\n \n+/// Generates a string from the operator and both sides.\n+fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n+    match op {\n+        AssocOp::Add\n+        | AssocOp::Subtract\n+        | AssocOp::Multiply\n+        | AssocOp::Divide\n+        | AssocOp::Modulus\n+        | AssocOp::LAnd\n+        | AssocOp::LOr\n+        | AssocOp::BitXor\n+        | AssocOp::BitAnd\n+        | AssocOp::BitOr\n+        | AssocOp::ShiftLeft\n+        | AssocOp::ShiftRight\n+        | AssocOp::Equal\n+        | AssocOp::Less\n+        | AssocOp::LessEqual\n+        | AssocOp::NotEqual\n+        | AssocOp::Greater\n+        | AssocOp::GreaterEqual => format!(\n+            \"{} {} {}\",\n+            lhs,\n+            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+            rhs\n+        ),\n+        AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n+        AssocOp::AssignOp(op) => {\n+            format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs)\n+        },\n+        AssocOp::As => format!(\"{} as {}\", lhs, rhs),\n+        AssocOp::DotDot => format!(\"{}..{}\", lhs, rhs),\n+        AssocOp::DotDotEq => format!(\"{}..={}\", lhs, rhs),\n+        AssocOp::Colon => format!(\"{}: {}\", lhs, rhs),\n+    }\n+}\n+\n /// Return `true` if `sugg` is enclosed in parenthesis.\n fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n@@ -391,34 +461,22 @@ impl Neg for Sugg<'_> {\n     }\n }\n \n-impl Not for Sugg<'_> {\n-    type Output = Sugg<'static>;\n-    fn not(self) -> Sugg<'static> {\n+impl Not for Sugg<'a> {\n+    type Output = Sugg<'a>;\n+    fn not(self) -> Sugg<'a> {\n         use AssocOp::{Equal, Greater, GreaterEqual, Less, LessEqual, NotEqual};\n \n-        /// Convert ```AssocOp``` to a string of operators.\n-        fn op_as_str(op: AssocOp) -> &'static str {\n-            op.to_ast_binop().unwrap().to_string()\n-        }\n-\n-        /// Replace the operator in the Snippet.\n-        fn replace_op(from_op: AssocOp, to_op: AssocOp, snip: Cow<'_, str>) -> Sugg<'static> {\n-            let from = op_as_str(from_op);\n-            let to = op_as_str(to_op);\n-            let snip = snip.into_owned().replace(from, to);\n-            Sugg::BinOp(to_op, Cow::Owned(snip))\n-        }\n-\n-        if let Sugg::BinOp(op, snip) = self {\n-            match op {\n-                Equal => replace_op(op, NotEqual, snip),\n-                NotEqual => replace_op(op, Equal, snip),\n-                Less => replace_op(op, GreaterEqual, snip),\n-                GreaterEqual => replace_op(op, Less, snip),\n-                Greater => replace_op(op, LessEqual, snip),\n-                LessEqual => replace_op(op, Greater, snip),\n-                _ => make_unop(\"!\", Sugg::BinOp(op, snip)),\n-            }\n+        if let Sugg::BinOp(op, lhs, rhs) = self {\n+            let to_op = match op {\n+                Equal => NotEqual,\n+                NotEqual => Equal,\n+                Less => GreaterEqual,\n+                GreaterEqual => Less,\n+                Greater => LessEqual,\n+                LessEqual => Greater,\n+                _ => return make_unop(\"!\", Sugg::BinOp(op, lhs, rhs)),\n+            };\n+            Sugg::BinOp(to_op, lhs, rhs)\n         } else {\n             make_unop(\"!\", self)\n         }\n@@ -490,53 +548,21 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n             || is_shift(other) && is_arith(op)\n     }\n \n-    let lhs_paren = if let Sugg::BinOp(lop, _) = *lhs {\n+    let lhs_paren = if let Sugg::BinOp(lop, _, _) = *lhs {\n         needs_paren(op, lop, Associativity::Left)\n     } else {\n         false\n     };\n \n-    let rhs_paren = if let Sugg::BinOp(rop, _) = *rhs {\n+    let rhs_paren = if let Sugg::BinOp(rop, _, _) = *rhs {\n         needs_paren(op, rop, Associativity::Right)\n     } else {\n         false\n     };\n \n-    let lhs = ParenHelper::new(lhs_paren, lhs);\n-    let rhs = ParenHelper::new(rhs_paren, rhs);\n-    let sugg = match op {\n-        AssocOp::Add\n-        | AssocOp::BitAnd\n-        | AssocOp::BitOr\n-        | AssocOp::BitXor\n-        | AssocOp::Divide\n-        | AssocOp::Equal\n-        | AssocOp::Greater\n-        | AssocOp::GreaterEqual\n-        | AssocOp::LAnd\n-        | AssocOp::LOr\n-        | AssocOp::Less\n-        | AssocOp::LessEqual\n-        | AssocOp::Modulus\n-        | AssocOp::Multiply\n-        | AssocOp::NotEqual\n-        | AssocOp::ShiftLeft\n-        | AssocOp::ShiftRight\n-        | AssocOp::Subtract => format!(\n-            \"{} {} {}\",\n-            lhs,\n-            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n-            rhs\n-        ),\n-        AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n-        AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, token_kind_to_string(&token::BinOp(op)), rhs),\n-        AssocOp::As => format!(\"{} as {}\", lhs, rhs),\n-        AssocOp::DotDot => format!(\"{}..{}\", lhs, rhs),\n-        AssocOp::DotDotEq => format!(\"{}..={}\", lhs, rhs),\n-        AssocOp::Colon => format!(\"{}: {}\", lhs, rhs),\n-    };\n-\n-    Sugg::BinOp(op, sugg.into())\n+    let lhs = ParenHelper::new(lhs_paren, lhs).to_string();\n+    let rhs = ParenHelper::new(rhs_paren, rhs).to_string();\n+    Sugg::BinOp(op, lhs.into(), rhs.into())\n }\n \n /// Convenience wrapper around `make_assoc` and `AssocOp::from_ast_binop`.\n@@ -1034,43 +1060,43 @@ mod test {\n \n     #[test]\n     fn binop_maybe_par() {\n-        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1)\".into());\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"1\".into(), \"1\".into());\n         assert_eq!(\"(1 + 1)\", sugg.maybe_par().to_string());\n \n-        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1) + (1 + 1)\".into());\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1)\".into(), \"(1 + 1)\".into());\n         assert_eq!(\"((1 + 1) + (1 + 1))\", sugg.maybe_par().to_string());\n     }\n     #[test]\n     fn not_op() {\n         use AssocOp::{Add, Equal, Greater, GreaterEqual, LAnd, LOr, Less, LessEqual, NotEqual};\n \n         // Invert the comparison operator.\n-        let sugg = Sugg::BinOp(Equal, \"1 == 1\".into());\n+        let sugg = Sugg::BinOp(Equal, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 != 1\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(NotEqual, \"1 != 1\".into());\n+        let sugg = Sugg::BinOp(NotEqual, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 == 1\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(Less, \"1 < 1\".into());\n+        let sugg = Sugg::BinOp(Less, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 >= 1\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(LessEqual, \"1 <= 1\".into());\n+        let sugg = Sugg::BinOp(LessEqual, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 > 1\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(Greater, \"1 > 1\".into());\n+        let sugg = Sugg::BinOp(Greater, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 <= 1\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(GreaterEqual, \"1 >= 1\".into());\n+        let sugg = Sugg::BinOp(GreaterEqual, \"1\".into(), \"1\".into());\n         assert_eq!(\"1 < 1\", (!sugg).to_string());\n \n         // Other operators are inverted like !(..).\n-        let sugg = Sugg::BinOp(Add, \"1 + 1\".into());\n+        let sugg = Sugg::BinOp(Add, \"1\".into(), \"1\".into());\n         assert_eq!(\"!(1 + 1)\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(LAnd, \"1 && 1\".into());\n+        let sugg = Sugg::BinOp(LAnd, \"1\".into(), \"1\".into());\n         assert_eq!(\"!(1 && 1)\", (!sugg).to_string());\n \n-        let sugg = Sugg::BinOp(LOr, \"1 || 1\".into());\n+        let sugg = Sugg::BinOp(LOr, \"1\".into(), \"1\".into());\n         assert_eq!(\"!(1 || 1)\", (!sugg).to_string());\n     }\n }"}, {"sha": "2e3ebadd7b5d2c580d2c89b09898d01b67f00adc", "filename": "tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b6d1fdea210877c54e3334c610cf7ff209e11ae/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b6d1fdea210877c54e3334c610cf7ff209e11ae/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=0b6d1fdea210877c54e3334c610cf7ff209e11ae", "patch": "@@ -43,7 +43,7 @@ LL | /     for i in 3..(3 + src.len()) {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..(3 + src.len() - 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:35:5"}]}