{"sha": "9692f3bc941795dafac998294cc4e50e78efb4b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OTJmM2JjOTQxNzk1ZGFmYWM5OTgyOTRjYzRlNTBlNzhlZmI0YjU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:57:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:57:03Z"}, "message": "Rollup merge of #22635 - kmcallister:macros-chapter, r=steveklabnik\n\n r? @steveklabnik", "tree": {"sha": "1d5500407aadb3655b0820685e9ad6e947e373f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d5500407aadb3655b0820685e9ad6e947e373f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9692f3bc941795dafac998294cc4e50e78efb4b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9692f3bc941795dafac998294cc4e50e78efb4b5", "html_url": "https://github.com/rust-lang/rust/commit/9692f3bc941795dafac998294cc4e50e78efb4b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9692f3bc941795dafac998294cc4e50e78efb4b5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b711b6a5b2bc52ca27d75d5031239dbac92e42e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b711b6a5b2bc52ca27d75d5031239dbac92e42e2", "html_url": "https://github.com/rust-lang/rust/commit/b711b6a5b2bc52ca27d75d5031239dbac92e42e2"}, {"sha": "848a7e692102643d99bb208b5a64199b6d6d87a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/848a7e692102643d99bb208b5a64199b6d6d87a1", "html_url": "https://github.com/rust-lang/rust/commit/848a7e692102643d99bb208b5a64199b6d6d87a1"}], "stats": {"total": 5186, "additions": 2506, "deletions": 2680}, "files": [{"sha": "781b40be768c86f03b05ce809ce1a9c7aead5145", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -731,15 +731,20 @@ Rust syntax is restricted in two ways:\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n-## Syntax extensions useful for the macro author\n+## Syntax extensions useful in macros\n \n-* `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n * `stringify!` : turn the identifier argument into a string literal\n * `concat!` : concatenates a comma-separated list of literals\n-* `concat_idents!` : create a new identifier by concatenating the arguments\n \n-The following attributes are used for quasiquoting in procedural macros:\n+## Syntax extensions for macro debugging\n+\n+* `log_syntax!` : print out the arguments at compile time\n+* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n+\n+## Quasiquoting\n+\n+The following syntax extensions are used for quasiquoting Rust syntax trees,\n+usually in [procedural macros](book/plugins.html#syntax-extensions):\n \n * `quote_expr!`\n * `quote_item!`\n@@ -748,6 +753,8 @@ The following attributes are used for quasiquoting in procedural macros:\n * `quote_tokens!`\n * `quote_ty!`\n \n+Documentation is very limited at the moment.\n+\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*"}, {"sha": "a226e4d0bf911ac97b57c420129c3ff515bb53aa", "filename": "src/doc/trpl/advanced-macros.md", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -192,19 +192,58 @@ To keep this system simple and correct, `#[macro_use] extern crate ...` may\n only appear at the root of your crate, not inside `mod`. This ensures that\n `$crate` is a single identifier.\n \n-# A final note\n+# The deep end\n \n-Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside a\n-macro, and errors caused by parse problems in generated code can be very\n-tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, invoking `trace_macros!(true)` will automatically print those\n-intermediate states out, and passing the flag `--pretty expanded` as a\n-command-line argument to the compiler will show the result of expansion.\n+The introductory chapter mentioned recursive macros, but it did not give the\n+full story. Recursive macros are useful for another reason: Each recursive\n+invocation gives you another opportunity to pattern-match the macro's\n+arguments.\n+\n+As an extreme example, it is possible, though hardly advisable, to implement\n+the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n+within Rust's macro system.\n+\n+```rust\n+#![feature(trace_macros)]\n+\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+\n+fn main() {\n+    trace_macros!(true);\n+# /* just check the definition\n+    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n+# */\n+}\n+```\n+\n+Exercise: use macros to reduce duplication in the above definition of the\n+`bct!` macro.\n+\n+# Procedural macros\n \n If Rust's macro system can't do what you need, you may want to write a\n [compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n-and the warnings about debugging apply ten-fold. In exchange you get the\n+and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax\n extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "7da36043f6cf17726a3641bab0381564aeb1ada1", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -189,14 +189,12 @@ shorthand for a data type could be valid as either an expression or a pattern.\n \n ## Repetition\n \n-The repetition behavior can seem somewhat magical, especially when multiple\n-names are bound at multiple nested levels of repetition. The two rules to keep\n-in mind are:\n+The repetition operator follows two principal rules:\n \n-1. the behavior of `$(...)*` is to walk through one \"layer\" of repetitions, for\n-all of the `$name`s it contains, in lockstep, and\n+1. `$(...)*` walks through one \"layer\" of repetitions, for all of the `$name`s\n+   it contains, in lockstep, and\n 2. each `$name` must be under at least as many `$(...)*`s as it was matched\n-against. If it is under more, it'll be duplicated, as appropriate.\n+   against. If it is under more, it'll be duplicated, as appropriate.\n \n This baroque macro illustrates the duplication of variables from outer\n repetition levels.\n@@ -226,6 +224,10 @@ That's most of the matcher syntax. These examples use `$(...)*`, which is a\n more\" match. Both forms optionally include a separator, which can be any token\n except `+` or `*`.\n \n+This system is based on\n+\"[Macro-by-Example](http://www.cs.indiana.edu/ftp/techreports/TR206.pdf)\"\n+(PDF link).\n+\n # Hygiene\n \n Some languages implement macros using simple text substitution, which leads to\n@@ -273,19 +275,26 @@ macro, using [a GNU C extension] to emulate Rust's expression blocks.\n })\n ```\n \n-This looks reasonable, but watch what happens in this example:\n+Here's a simple use case that goes terribly wrong:\n \n ```text\n const char *state = \"reticulating splines\";\n-LOG(state);\n+LOG(state)\n ```\n \n-The program will likely segfault, after it tries to execute\n+This expands to\n \n ```text\n-printf(\"log(%d): %s\\n\", state, state);\n+const char *state = \"reticulating splines\";\n+int state = get_log_state();\n+if (state > 0) {\n+    printf(\"log(%d): %s\\n\", state, state);\n+}\n ```\n \n+The second variable named `state` shadows the first one.  This is a problem\n+because the print statement should refer to both of them.\n+\n The equivalent Rust macro has the desired behavior.\n \n ```rust\n@@ -357,6 +366,64 @@ fn main() {\n \n [items]: ../reference.html#items\n \n+# Recursive macros\n+\n+A macro's expansion can include more macro invocations, including invocations\n+of the very same macro being expanded.  These recursive macros are useful for\n+processing tree-structured input, as illustrated by this (simplistic) HTML\n+shorthand:\n+\n+```rust\n+# #![allow(unused_must_use)]\n+macro_rules! write_html {\n+    ($w:expr, ) => (());\n+\n+    ($w:expr, $e:tt) => (write!($w, \"{}\", $e));\n+\n+    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{\n+        write!($w, \"<{}>\", stringify!($tag));\n+        write_html!($w, $($inner)*);\n+        write!($w, \"</{}>\", stringify!($tag));\n+        write_html!($w, $($rest)*);\n+    }};\n+}\n+\n+fn main() {\n+#   // FIXME(#21826)\n+    use std::fmt::Write;\n+    let mut out = String::new();\n+\n+    write_html!(&mut out,\n+        html[\n+            head[title[\"Macros guide\"]]\n+            body[h1[\"Macros are the best!\"]]\n+        ]);\n+\n+    assert_eq!(out,\n+        \"<html><head><title>Macros guide</title></head>\\\n+         <body><h1>Macros are the best!</h1></body></html>\");\n+}\n+```\n+\n+# Debugging macro code\n+\n+To see the results of expanding macros, run `rustc --pretty expanded`. The\n+output represents a whole crate, so you can also feed it back in to `rustc`,\n+which will sometimes produce better error messages than the original\n+compilation. Note that the `--pretty expanded` output may have a different\n+meaning if multiple variables of the same name (but different syntax contexts)\n+are in play in the same scope. In this case `--pretty expanded,hygiene` will\n+tell you about the syntax contexts.\n+\n+`rustc` provides two syntax extensions that help with macro debugging. For now,\n+they are unstable and require feature gates.\n+\n+* `log_syntax!(...)` will print its arguments to standard output, at compile\n+  time, and \"expand\" to nothing.\n+\n+* `trace_macros!(true)` will enable a compiler message every time a macro is\n+  expanded. Use `trace_macros!(false)` later in expansion to turn it off.\n+\n # Further reading\n \n The [advanced macros chapter][] goes into more detail about macro syntax. It"}, {"sha": "f609a0a918aa7628a6dc05372da67c168dd7335f", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -146,14 +146,7 @@ a more involved macro example, see\n \n ## Tips and tricks\n \n-To see the results of expanding syntax extensions, run\n-`rustc --pretty expanded`. The output represents a whole crate, so you\n-can also feed it back in to `rustc`, which will sometimes produce better\n-error messages than the original compilation. Note that the\n-`--pretty expanded` output may have a different meaning if multiple\n-variables of the same name (but different syntax contexts) are in play\n-in the same scope. In this case `--pretty expanded,hygiene` will tell\n-you about the syntax contexts.\n+Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n \n You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n higher-level syntax elements like expressions:\n@@ -184,6 +177,11 @@ and return\n [`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n so that the compiler can continue and find further errors.\n \n+To print syntax fragments for debugging, you can use\n+[`span_note`](../syntax/ext/base/struct.ExtCtxt.html#method.span_note) together\n+with\n+[`syntax::print::pprust::*_to_string`](http://doc.rust-lang.org/syntax/print/pprust/index.html#functions).\n+\n The example above produced an integer literal using\n [`AstBuilder::expr_uint`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of"}, {"sha": "ca27ec9d3bbd97a61ffa51be6124fd363c7a0c09", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -790,7 +790,7 @@ pub trait SliceExt {\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[unstable(feature = \"collections\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n "}, {"sha": "b4ccf93043729072b2df6861fb4cebd65ab8a699", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -981,7 +981,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn cloned(self) -> Cloned<Self> where\n         Self::Item: Deref,\n-        <Self::Item as Deref>::Output: Clone,\n+        <Self::Item as Deref>::Target: Clone,\n     {\n         Cloned { it: self }\n     }"}, {"sha": "a4f69e651df60a9e1738c4034d9018f12417b40f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -405,8 +405,8 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[path_id].clone() {\n+    fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n+        match self.cx.tcx.def_map.borrow()[id].full_def() {\n             def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n             def::DefTy(..) => {\n-                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&ty_id) {\n+                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n                     Some(&ty::atttce_resolved(t)) => t,\n                     _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n@@ -437,9 +437,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        match ty.node {\n-            ast::TyPath(_, id) => self.check_def(ty.span, ty.id, id),\n-            _ => (),\n+        if let ast::TyPath(..) = ty.node {\n+            self.check_def(ty.span, ty.id);\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -683,8 +682,8 @@ impl LintPass for PathStatements {\n         match s.node {\n             ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENTS, s.span,\n-                                                     \"path statement with no effect\"),\n+                    ast::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                                                      \"path statement with no effect\"),\n                     _ => ()\n                 }\n             }\n@@ -1001,7 +1000,8 @@ impl LintPass for NonSnakeCase {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         if let &ast::PatIdent(_, ref path1, _) = &p.node {\n-            if let Some(&def::DefLocal(_)) = cx.tcx.def_map.borrow().get(&p.id) {\n+            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+            if let Some(def::DefLocal(_)) = def {\n                 self.check_snake_case(cx, \"variable\", path1.node, p.span);\n             }\n         }\n@@ -1066,8 +1066,8 @@ impl LintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id)) {\n-            (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node, p.span);\n             }\n@@ -1227,10 +1227,13 @@ impl LintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let ast::PatStruct(_, ref v, _) = pat.node {\n-            for fieldpat in v.iter()\n-                             .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                             .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n-                                                == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n+            let field_pats = v.iter()\n+                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n+                              .filter(|fieldpat| {\n+                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n+                def == Some(def::DefLocal(fieldpat.node.pat.id))\n+            });\n+            for fieldpat in field_pats {\n                 if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n@@ -1899,10 +1902,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-                .map_or(false, |def| {\n-                    let did = def.def_id();\n-                    ast_util::is_local(did) && did.node == fn_id\n-                })\n+                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`"}, {"sha": "f5c4cce065955659fddcfcc17c6f0d4dee2d426e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -150,12 +150,9 @@ pub fn get_trait_name(cstore: &cstore::CStore, def: ast::DefId) -> ast::Name {\n                             def.node)\n }\n \n-pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n-                                    -> (ast::Name, def::TraitItemKind) {\n+pub fn is_static_method(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_item_name_and_kind(cstore.intr.clone(),\n-                                          &*cdata,\n-                                          def.node)\n+    decoder::is_static_method(&*cdata, def.node)\n }\n \n pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: ast::DefId)"}, {"sha": "0503045ac6e2d1673027bdf9bf1ede727c0c6f23", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -119,7 +119,6 @@ enum Family {\n     StaticMethod,          // F\n     Method,                // h\n     Type,                  // y\n-    ForeignType,           // T\n     Mod,                   // m\n     ForeignMod,            // n\n     Enum,                  // t\n@@ -145,7 +144,6 @@ fn item_family(item: rbml::Doc) -> Family {\n       'F' => StaticMethod,\n       'h' => Method,\n       'y' => Type,\n-      'T' => ForeignType,\n       'm' => Mod,\n       'n' => ForeignMod,\n       't' => Enum,\n@@ -174,16 +172,13 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     }\n }\n \n-fn item_sort(item: rbml::Doc) -> char {\n+fn item_sort(item: rbml::Doc) -> Option<char> {\n     let mut ret = None;\n     reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n         ret = Some(doc.as_str_slice().as_bytes()[0] as char);\n         false\n     });\n-    match ret {\n-        Some(r) => r,\n-        None => panic!(\"No item_sort found\")\n-    }\n+    ret\n }\n \n fn item_symbol(item: rbml::Doc) -> String {\n@@ -339,14 +334,16 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            match fam {\n-                // We don't bother to get encode/decode the trait id, we don't need it.\n-                Method => DlDef(def::DefMethod(did, None, provenance)),\n-                StaticMethod => DlDef(def::DefStaticMethod(did, provenance)),\n-                _ => panic!()\n+            DlDef(def::DefMethod(did, provenance))\n+        }\n+        Type => {\n+            if item_sort(item) == Some('t') {\n+                let trait_did = item_reqd_and_translated_parent_item(cnum, item);\n+                DlDef(def::DefAssociatedTy(trait_did, did))\n+            } else {\n+                DlDef(def::DefTy(did, false))\n             }\n         }\n-        Type | ForeignType => DlDef(def::DefTy(did, false)),\n         Mod => DlDef(def::DefMod(did)),\n         ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n@@ -357,7 +354,7 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n-        Trait => DlDef(def::DefaultImpl(did)),\n+        Trait => DlDef(def::DefTrait(did)),\n         Enum => DlDef(def::DefTy(did, true)),\n         Impl | DefaultImpl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n@@ -831,8 +828,10 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                         tag_item_impl_item, |doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n-            'r' | 'p' => impl_items.push(ty::MethodTraitItemId(def_id)),\n-            't' => impl_items.push(ty::TypeTraitItemId(def_id)),\n+            Some('r') | Some('p') => {\n+                impl_items.push(ty::MethodTraitItemId(def_id))\n+            }\n+            Some('t') => impl_items.push(ty::TypeTraitItemId(def_id)),\n             _ => panic!(\"unknown impl item sort\"),\n         }\n         true\n@@ -849,22 +848,13 @@ pub fn get_trait_name(intr: Rc<IdentInterner>,\n     item_name(&*intr, doc)\n }\n \n-pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n-                                    cdata: Cmd,\n-                                    id: ast::NodeId)\n-                                    -> (ast::Name, def::TraitItemKind) {\n+pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n     let doc = lookup_item(id, cdata.data());\n-    let name = item_name(&*intr, doc);\n     match item_sort(doc) {\n-        'r' | 'p' => {\n-            let explicit_self = get_explicit_self(doc);\n-            (name, def::TraitItemKind::from_explicit_self_category(explicit_self))\n-        }\n-        't' => (name, def::TypeTraitItemKind),\n-        c => {\n-            panic!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n-                   in metadata: `{}`\", c)\n+        Some('r') | Some('p') => {\n+            get_explicit_self(doc) == ty::StaticExplicitSelfCategory\n         }\n+        _ => false\n     }\n }\n \n@@ -889,7 +879,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(method_doc);\n \n     match item_sort(method_doc) {\n-        'r' | 'p' => {\n+        Some('r') | Some('p') => {\n             let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n             let fty = doc_method_fty(method_doc, tcx, cdata);\n@@ -906,7 +896,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                                         container,\n                                                         provided_source)))\n         }\n-        't' => {\n+        Some('t') => {\n             ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n                 name: name,\n                 vis: vis,\n@@ -926,8 +916,10 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_trait_item, |mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n-            'r' | 'p' => result.push(ty::MethodTraitItemId(def_id)),\n-            't' => result.push(ty::TypeTraitItemId(def_id)),\n+            Some('r') | Some('p') => {\n+                result.push(ty::MethodTraitItemId(def_id));\n+            }\n+            Some('t') => result.push(ty::TypeTraitItemId(def_id)),\n             _ => panic!(\"unknown trait item sort\"),\n         }\n         true\n@@ -956,7 +948,7 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n-        if item_sort(mth) == 'p' {\n+        if item_sort(mth) == Some('p') {\n             let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                     cdata,\n                                                     did.node,\n@@ -1560,7 +1552,7 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n     match maybe_find_item(id, items) {\n         None => false,\n-        Some(item) => item_sort(item) == 't',\n+        Some(item) => item_sort(item) == Some('t'),\n     }\n }\n "}, {"sha": "ee2745ca66bc59980a675bd7dd7da2f24129d447", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -1193,15 +1193,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ast::ItemDefaultImpl(unsafety, ref ast_trait_ref) => {\n+      ast::ItemDefaultImpl(unsafety, _) => {\n           add_to_index(item, rbml_w, index);\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id(rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::node_id_to_trait_ref(tcx, ast_trait_ref.ref_id);\n+          let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n           encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1221,7 +1221,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n-            ast::TyPath(ref path, _) if path.segments.len() == 1 => {\n+            ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n                 let ident = path.segments.last().unwrap().identifier;\n                 encode_impl_type_basename(rbml_w, ident);\n             }\n@@ -1241,9 +1241,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(ref ast_trait_ref) = *opt_trait {\n-            let trait_ref = ty::node_id_to_trait_ref(\n-                tcx, ast_trait_ref.ref_id);\n+        if opt_trait.is_some() {\n+            let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1871,9 +1870,7 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_map = &self.ecx.tcx.def_map;\n-            let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n-            let def_id = trait_def.def_id();\n+            let def_id = self.ecx.tcx.def_map.borrow()[trait_ref.ref_id].def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate."}, {"sha": "17fd80ceaea428063654da274aef672114ca5b89", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -22,68 +22,58 @@ use util::ppaux::Repr;\n pub const NO_REGIONS: uint = 1;\n pub const NO_TPS: uint = 2;\n \n-pub fn check_path_args(tcx: &ty::ctxt,\n-                       path: &ast::Path,\n-                       flags: uint) {\n-    if (flags & NO_TPS) != 0 {\n-        if path.segments.iter().any(|s| s.parameters.has_types()) {\n-            span_err!(tcx.sess, path.span, E0109,\n-                \"type parameters are not allowed on this type\");\n+pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: uint) {\n+    for segment in segments {\n+        if (flags & NO_TPS) != 0 {\n+            for typ in segment.parameters.types() {\n+                span_err!(tcx.sess, typ.span, E0109,\n+                          \"type parameters are not allowed on this type\");\n+                break;\n+            }\n         }\n-    }\n \n-    if (flags & NO_REGIONS) != 0 {\n-        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n-            span_err!(tcx.sess, path.span, E0110,\n-                \"region parameters are not allowed on this type\");\n+        if (flags & NO_REGIONS) != 0 {\n+            for lifetime in segment.parameters.lifetimes() {\n+                span_err!(tcx.sess, lifetime.span, E0110,\n+                          \"lifetime parameters are not allowed on this type\");\n+                break;\n+            }\n         }\n     }\n }\n \n+pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                           segments: &[ast::PathSegment],\n+                           nty: ast::PrimTy)\n+                           -> Ty<'tcx> {\n+    check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+    match nty {\n+        ast::TyBool => tcx.types.bool,\n+        ast::TyChar => tcx.types.char,\n+        ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n+        ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n+        ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n+        ast::TyStr => ty::mk_str(tcx)\n+    }\n+}\n+\n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n-    match ast_ty.node {\n-        ast::TyPath(ref path, id) => {\n-            let a_def = match tcx.def_map.borrow().get(&id) {\n-                None => {\n-                    tcx.sess.span_bug(ast_ty.span,\n-                                      &format!(\"unbound path {}\",\n-                                              path.repr(tcx)))\n-                }\n-                Some(&d) => d\n-            };\n-            match a_def {\n-                def::DefPrimTy(nty) => {\n-                    match nty {\n-                        ast::TyBool => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(tcx.types.bool)\n-                        }\n-                        ast::TyChar => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(tcx.types.char)\n-                        }\n-                        ast::TyInt(it) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_int(tcx, it))\n-                        }\n-                        ast::TyUint(uit) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_uint(tcx, uit))\n-                        }\n-                        ast::TyFloat(ft) => {\n-                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_float(tcx, ft))\n-                        }\n-                        ast::TyStr => {\n-                            Some(ty::mk_str(tcx))\n-                        }\n-                    }\n-                }\n-                _ => None\n+    if let ast::TyPath(None, ref path) = ast_ty.node {\n+        let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n+            None => {\n+                tcx.sess.span_bug(ast_ty.span,\n+                                  &format!(\"unbound path {}\", path.repr(tcx)))\n             }\n+            Some(d) => d.full_def()\n+        };\n+        if let def::DefPrimTy(nty) = def {\n+            Some(prim_ty_to_ty(tcx, &path.segments[], nty))\n+        } else {\n+            None\n         }\n-        _ => None\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "5983829ed8fbef20e56b6124b2a1e868201aaf0d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -25,6 +25,7 @@ use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n@@ -423,13 +424,8 @@ impl tr for def::Def {\n     fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n           def::DefFn(did, is_ctor) => def::DefFn(did.tr(dcx), is_ctor),\n-          def::DefStaticMethod(did, p) => {\n-            def::DefStaticMethod(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n-          }\n-          def::DefMethod(did0, did1, p) => {\n-            def::DefMethod(did0.tr(dcx),\n-                           did1.map(|did1| did1.tr(dcx)),\n-                           p.map(|did2| did2.tr(dcx)))\n+          def::DefMethod(did, p) => {\n+            def::DefMethod(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n           }\n           def::DefSelfTy(nid) => { def::DefSelfTy(dcx.tr_id(nid)) }\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n@@ -440,13 +436,10 @@ impl tr for def::Def {\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n-          def::DefaultImpl(did) => def::DefaultImpl(did.tr(dcx)),\n+          def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n           def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n-          def::DefAssociatedTy(did) => def::DefAssociatedTy(did.tr(dcx)),\n-          def::DefAssociatedPath(def::TyParamProvenance::FromSelf(did), ident) =>\n-              def::DefAssociatedPath(def::TyParamProvenance::FromSelf(did.tr(dcx)), ident),\n-          def::DefAssociatedPath(def::TyParamProvenance::FromParam(did), ident) =>\n-              def::DefAssociatedPath(def::TyParamProvenance::FromParam(did.tr(dcx)), ident),\n+          def::DefAssociatedTy(trait_did, did) =>\n+              def::DefAssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n@@ -455,9 +448,6 @@ impl tr for def::Def {\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n           def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n-          def::DefTyParamBinder(nid) => {\n-            def::DefTyParamBinder(dcx.tr_id(nid))\n-          }\n           def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n         }\n     }\n@@ -1159,10 +1149,10 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    if let Some(def) = tcx.def_map.borrow().get(&id) {\n+    if let Some(def) = tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n+            rbml_w.tag(c::tag_table_val, |rbml_w| def.encode(rbml_w).unwrap());\n         })\n     }\n \n@@ -1862,7 +1852,12 @@ fn decode_side_tables(dcx: &DecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(dcx, val_doc);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def);\n+                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n+                            base_def: def,\n+                            // This doesn't matter cross-crate.\n+                            last_private: LastMod(AllPublic),\n+                            depth: 0\n+                        });\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);"}, {"sha": "24c54b53590c04f57a4ff6eafe82f3179b9d3cfa", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -398,8 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprMac(..) |\n             ast::ExprClosure(..) |\n             ast::ExprLit(..) |\n-            ast::ExprPath(..) |\n-            ast::ExprQPath(..) => {\n+            ast::ExprPath(..) => {\n                 self.straightline(expr, pred, None::<ast::Expr>.iter())\n             }\n         }\n@@ -610,32 +609,24 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope(&self,\n                   expr: &ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n-        match label {\n-            None => {\n-                return *self.loop_scopes.last().unwrap();\n-            }\n-\n-            Some(_) => {\n-                match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def::DefLabel(loop_id)) => {\n-                        for l in &self.loop_scopes {\n-                            if l.loop_id == loop_id {\n-                                return *l;\n-                            }\n-                        }\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            &format!(\"no loop scope for id {}\",\n-                                    loop_id));\n-                    }\n+        if label.is_none() {\n+            return *self.loop_scopes.last().unwrap();\n+        }\n \n-                    r => {\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            &format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r));\n+        match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n+            Some(def::DefLabel(loop_id)) => {\n+                for l in &self.loop_scopes {\n+                    if l.loop_id == loop_id {\n+                        return *l;\n                     }\n                 }\n+                self.tcx.sess.span_bug(expr.span,\n+                    &format!(\"no loop scope for id {}\", loop_id));\n+            }\n+\n+            r => {\n+                self.tcx.sess.span_bug(expr.span,\n+                    &format!(\"bad entry `{:?}` in def_map for label\", r));\n             }\n         }\n     }"}, {"sha": "8401d25024d3577e7fa4921445d7d03a0694393b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -439,8 +439,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = v.tcx.def_map.borrow().get(&e.id).cloned();\n+        ast::ExprPath(..) => {\n+            let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n                     // Count the discriminator or function pointer.\n@@ -452,8 +452,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         v.add_qualif(NON_ZERO_SIZED);\n                     }\n                 }\n-                Some(def::DefFn(..)) |\n-                Some(def::DefStaticMethod(..)) | Some(def::DefMethod(..)) => {\n+                Some(def::DefFn(..)) | Some(def::DefMethod(..)) => {\n                     // Count the function pointer.\n                     v.add_qualif(NON_ZERO_SIZED);\n                 }\n@@ -500,7 +499,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     _ => break\n                 };\n             }\n-            let def = v.tcx.def_map.borrow().get(&callee.id).cloned();\n+            let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefStruct(..)) => {}\n                 Some(def::DefVariant(..)) => {"}, {"sha": "c409c8fb13f14502437aa2d1c9813b1365624f9d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -242,7 +242,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = ty::pat_ty(cx.tcx, p);\n                 if let ty::ty_enum(def_id, _) = pat_ty.sty {\n-                    let def = cx.tcx.def_map.borrow().get(&p.id).cloned();\n+                    let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n                         if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n             ast::PatIdent(..) | ast::PatEnum(..) => {\n-                let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n+                let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n@@ -733,28 +733,28 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         ast::PatIdent(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefStruct(_)) => vec!(Single),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefStruct(_)) => vec!(Single),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         ast::PatEnum(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         ast::PatStruct(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         ast::PatLit(ref expr) =>\n@@ -847,7 +847,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n \n         ast::PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n+            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n                 Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -862,7 +862,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n+            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -880,7 +880,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n+            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "b97978fc03fff33ae23e04c0cb05595511f2d380", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -93,10 +93,10 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                match self.def_map.borrow().get(&e.id) {\n-                    Some(&DefStatic(def_id, _)) |\n-                    Some(&DefConst(def_id)) if\n+            ast::ExprPath(..) => {\n+                match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n+                    Some(DefStatic(def_id, _)) |\n+                    Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>"}, {"sha": "f793d3ce2fb4522c08aca64f0849c4022d18bf39", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -31,7 +31,7 @@ use std::{i8, i16, i32, i64};\n use std::rc::Rc;\n \n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n-    let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+    let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n         Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n@@ -148,11 +148,11 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow()[callee.id].clone();\n+            let def = tcx.def_map.borrow()[callee.id];\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }\n-            let path = match def {\n+            let path = match def.full_def() {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n@@ -178,8 +178,8 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatVec(pats, None, vec![])\n         }\n \n-        ast::ExprPath(ref path) => {\n-            let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n+        ast::ExprPath(_, ref path) => {\n+            let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n                     ast::PatStruct(path.clone(), vec![], false),\n@@ -194,13 +194,6 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             }\n         }\n \n-        ast::ExprQPath(_) => {\n-            match lookup_const(tcx, expr) {\n-                Some(actual) => return const_expr_to_pat(tcx, actual, span),\n-                _ => unreachable!()\n-            }\n-        }\n-\n         _ => ast::PatLit(P(expr.clone()))\n     };\n     P(ast::Pat { id: expr.id, node: pat, span: span })\n@@ -388,8 +381,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         cast_const(val, ety)\n       }\n-      ast::ExprPath(_) | ast::ExprQPath(_) => {\n-          let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+      ast::ExprPath(..) => {\n+          let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n                   if ast_util::is_local(def_id) {"}, {"sha": "2d837ce52b56a4f9abcee7e973d8dc95d7a55d3f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -71,13 +71,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n-            match def {\n-                &def::DefConst(_) => {\n+            match def.full_def() {\n+                def::DefConst(_) => {\n                     self.check_def_id(def.def_id())\n                 }\n                 _ if self.ignore_non_const_paths => (),\n-                &def::DefPrimTy(_) => (),\n-                &def::DefVariant(enum_id, variant_id, _) => {\n+                def::DefPrimTy(_) => (),\n+                def::DefVariant(enum_id, variant_id, _) => {\n                     self.check_def_id(enum_id);\n                     self.check_def_id(variant_id);\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match (*self.tcx.def_map.borrow())[lhs.id] {\n+        let id = match self.tcx.def_map.borrow()[lhs.id].full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,"}, {"sha": "1a054c0f464aac9afb5a91adb6f007490a8969da", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 45, "deletions": 56, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -10,10 +10,9 @@\n \n pub use self::Def::*;\n pub use self::MethodProvenance::*;\n-pub use self::TraitItemKind::*;\n \n+use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n-use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -23,7 +22,6 @@ use std::cell::RefCell;\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n-    DefStaticMethod(/* method */ ast::DefId, MethodProvenance),\n     DefSelfTy(/* trait id */ ast::NodeId),\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n@@ -32,13 +30,8 @@ pub enum Def {\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n-    DefAssociatedTy(ast::DefId),\n-    // A partially resolved path to an associated type `T::U` where `T` is a concrete\n-    // type (indicated by the DefId) which implements a trait which has an associated\n-    // type `U` (indicated by the Ident).\n-    // FIXME(#20301) -- should use Name\n-    DefAssociatedPath(TyParamProvenance, ast::Ident),\n-    DefaultImpl(ast::DefId),\n+    DefAssociatedTy(ast::DefId /* trait */, ast::DefId),\n+    DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n     DefUse(ast::DefId),\n@@ -54,14 +47,48 @@ pub enum Def {\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the StructDef.ctor_id.\n     DefStruct(ast::DefId),\n-    DefTyParamBinder(ast::NodeId), /* struct, impl or trait with ty params */\n     DefRegion(ast::NodeId),\n     DefLabel(ast::NodeId),\n-    DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */, MethodProvenance),\n+    DefMethod(ast::DefId /* method */, MethodProvenance),\n+}\n+\n+/// The result of resolving a path.\n+/// Before type checking completes, `depth` represents the number of\n+/// trailing segments which are yet unresolved. Afterwards, if there\n+/// were no errors, all paths should be fully resolved, with `depth`\n+/// set to `0` and `base_def` representing the final resolution.\n+///\n+///     module::Type::AssocX::AssocY::MethodOrAssocType\n+///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+///     base_def      depth = 3\n+///\n+///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n+///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n+///           base_def        depth = 2\n+#[derive(Copy, Debug)]\n+pub struct PathResolution {\n+    pub base_def: Def,\n+    pub last_private: LastPrivate,\n+    pub depth: usize\n+}\n+\n+impl PathResolution {\n+    /// Get the definition, if fully resolved, otherwise panic.\n+    pub fn full_def(&self) -> Def {\n+        if self.depth != 0 {\n+            panic!(\"path not fully resolved: {:?}\", self);\n+        }\n+        self.base_def\n+    }\n+\n+    /// Get the DefId, if fully resolved, otherwise panic.\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.full_def().def_id()\n+    }\n }\n \n // Definition mapping\n-pub type DefMap = RefCell<NodeMap<Def>>;\n+pub type DefMap = RefCell<NodeMap<PathResolution>>;\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n@@ -78,12 +105,6 @@ pub enum MethodProvenance {\n     FromImpl(ast::DefId),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TyParamProvenance {\n-    FromSelf(ast::DefId),\n-    FromParam(ast::DefId),\n-}\n-\n impl MethodProvenance {\n     pub fn map<F>(self, f: F) -> MethodProvenance where\n         F: FnOnce(ast::DefId) -> ast::DefId,\n@@ -95,34 +116,6 @@ impl MethodProvenance {\n     }\n }\n \n-impl TyParamProvenance {\n-    pub fn def_id(&self) -> ast::DefId {\n-        match *self {\n-            TyParamProvenance::FromSelf(ref did) => did.clone(),\n-            TyParamProvenance::FromParam(ref did) => did.clone(),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Eq, PartialEq)]\n-pub enum TraitItemKind {\n-    NonstaticMethodTraitItemKind,\n-    StaticMethodTraitItemKind,\n-    TypeTraitItemKind,\n-}\n-\n-impl TraitItemKind {\n-    pub fn from_explicit_self_category(explicit_self_category:\n-                                       ExplicitSelfCategory)\n-                                       -> TraitItemKind {\n-        if explicit_self_category == StaticExplicitSelfCategory {\n-            StaticMethodTraitItemKind\n-        } else {\n-            NonstaticMethodTraitItemKind\n-        }\n-    }\n-}\n-\n impl Def {\n     pub fn local_node_id(&self) -> ast::NodeId {\n         let def_id = self.def_id();\n@@ -132,25 +125,21 @@ impl Def {\n \n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n-            DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |\n-            DefForeignMod(id) | DefStatic(id, _) |\n-            DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n-            DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefaultImpl(id) |\n-            DefMethod(id, _, _) | DefConst(id) |\n-            DefAssociatedPath(TyParamProvenance::FromSelf(id), _) |\n-            DefAssociatedPath(TyParamProvenance::FromParam(id), _) => {\n+            DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n+            DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n+            DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n+            DefMethod(id, _) | DefConst(id) => {\n                 id\n             }\n             DefLocal(id) |\n             DefSelfTy(id) |\n             DefUpvar(id, _) |\n             DefRegion(id) |\n-            DefTyParamBinder(id) |\n             DefLabel(id) => {\n                 local_def(id)\n             }\n \n-            DefPrimTy(_) => panic!()\n+            DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\")\n         }\n     }\n "}, {"sha": "9c85b7748ab0c3449118daaf2502ea9ffbe44538", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }"}, {"sha": "a1e38a1c8bda795d4c35e304cb35bc4bc406fc32", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -422,7 +422,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.walk_expr(&**subexpr)\n             }\n \n-            ast::ExprPath(_) | ast::ExprQPath(_) => { }\n+            ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n                 if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n@@ -1017,7 +1017,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow()[pat.id].clone();\n+                let def = def_map.borrow()[pat.id].full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n@@ -1097,13 +1097,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n             match pat.node {\n                 ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n-                    match def_map.get(&pat.id) {\n+                    match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n                             // struct or enum pattern.\n                         }\n \n-                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {\n+                        Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n                                 if ty::enum_is_univariant(tcx, enum_did) {\n                                     cmt_pat\n@@ -1119,7 +1119,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n \n-                        Some(&def::DefStruct(..)) | Some(&def::DefTy(_, false)) => {\n+                        Some(def::DefStruct(..)) | Some(def::DefTy(_, false)) => {\n                             // A struct (in either the value or type\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n@@ -1131,14 +1131,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n \n-                        Some(&def::DefConst(..)) |\n-                        Some(&def::DefLocal(..)) => {\n+                        Some(def::DefConst(..)) |\n+                        Some(def::DefLocal(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call.\n                         }\n \n-                        Some(def @ &def::DefTy(_, true)) => {\n+                        Some(def @ def::DefTy(_, true)) => {\n                             // An enum's type -- should never be in a\n                             // pattern.\n "}, {"sha": "da4df813030c3ab504f228b24935a4f1d5b4a79f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -1233,16 +1233,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref path, id) => {\n-                    let a_def = match self.tcx.def_map.borrow().get(&id) {\n+                ast::TyPath(ref maybe_qself, ref path) => {\n+                    let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n                         None => {\n                             self.tcx\n                                 .sess\n                                 .fatal(&format!(\n                                         \"unbound path {}\",\n                                         pprust::path_to_string(path)))\n                         }\n-                        Some(&d) => d\n+                        Some(d) => d.full_def()\n                     };\n                     match a_def {\n                         def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1277,9 +1277,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 region_names: region_names\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n+                            let qself = maybe_qself.as_ref().map(|qself| {\n+                                ast::QSelf {\n+                                    ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n+                                                                      anon_nums, region_names),\n+                                    position: qself.position\n+                                }\n+                            });\n                             let to = ast::Ty {\n                                 id: cur_ty.id,\n-                                node: ast::TyPath(new_path, id),\n+                                node: ast::TyPath(qself, new_path),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));"}, {"sha": "2ac019aa964dc6f1f0f15c9c4a17e917d8085a13", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -445,8 +445,8 @@ fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ast::ExprPath(_) | ast::ExprQPath(_) => {\n-        let def = ir.tcx.def_map.borrow()[expr.id].clone();\n+      ast::ExprPath(..) => {\n+        let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -705,8 +705,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().get(&id) {\n-                    Some(&DefLabel(loop_id)) => loop_id,\n+                match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+                    Some(DefLabel(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n                 }\n@@ -947,7 +947,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n@@ -1275,7 +1275,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => succ,\n+            ast::ExprPath(..) => succ,\n             ast::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             ast::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                     -> LiveNode {\n         match expr.node {\n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n+          ast::ExprPath(..) => {\n               self.access_path(expr, succ, acc)\n           }\n \n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n+        match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1468,7 +1468,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n       ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n-      ast::ExprRange(..) | ast::ExprQPath(..) => {\n+      ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {\n@@ -1561,8 +1561,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].clone() {\n+            ast::ExprPath(..) => {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "c4446b87855ca622d6a5ebd4fcca78f7ca0b9042", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -529,8 +529,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = (*self.tcx().def_map.borrow())[expr.id];\n+          ast::ExprPath(..) => {\n+            let def = self.tcx().def_map.borrow()[expr.id].full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -575,14 +575,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n-          def::DefFn(..) | def::DefStaticMethod(..) |  def::DefMethod(..) => {\n+          def::DefFn(..) | def::DefMethod(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n-          def::DefaultImpl(_) | def::DefTy(..) | def::DefPrimTy(_) |\n-          def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n+          def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n+          def::DefTyParam(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) |\n-          def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n+          def::DefAssociatedTy(..) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -1199,14 +1199,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         (*op)(self, cmt.clone(), pat);\n \n-        let def_map = self.tcx().def_map.borrow();\n-        let opt_def = def_map.get(&pat.id);\n+        let opt_def = self.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n \n         // Note: This goes up here (rather than within the PatEnum arm\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n-            Some(&def::DefVariant(enum_did, variant_did, _))\n+            Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n                 if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n@@ -1224,7 +1223,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n             match opt_def {\n-                Some(&def::DefVariant(..)) => {\n+                Some(def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n@@ -1237,7 +1236,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(subcmt, &**subpat, op));\n                     }\n                 }\n-                Some(&def::DefStruct(..)) => {\n+                Some(def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n@@ -1247,7 +1246,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(&def::DefConst(..)) => {\n+                Some(def::DefConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }"}, {"sha": "c5abff3b96360bceaa9ca8b8d8124e02ad4fb08e", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -34,8 +34,8 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefVariant(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefVariant(..)) => true,\n                 _ => false\n             }\n         }\n@@ -49,8 +49,8 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefVariant(..)) | Some(DefStruct(..)) => true,\n                 _ => false\n             }\n         }\n@@ -61,8 +61,8 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n-            match dm.borrow().get(&pat.id) {\n-                Some(&DefConst(..)) => true,\n+            match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                Some(DefConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "3a253735f925b032e93390ce3618f6c4aa4aec87", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -16,7 +16,7 @@ pub use self::PrivateDep::*;\n pub use self::ImportUse::*;\n pub use self::LastPrivate::*;\n \n-use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n+use util::nodemap::{DefIdSet, NodeSet};\n \n use syntax::ast;\n \n@@ -32,9 +32,6 @@ pub type ExternalExports = DefIdSet;\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = NodeSet;\n \n-// FIXME: dox\n-pub type LastPrivateMap = NodeMap<LastPrivate>;\n-\n #[derive(Copy, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),"}, {"sha": "45d565ec693807f63e74e3887839602091372ecd", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -94,9 +94,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n \n         match expr.node {\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def) => def,\n+                    Some(d) => d.full_def(),\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                \"def ID not in def map?!\")"}, {"sha": "a8a2887644a9da40a237e472e9f0e5a66985f4e4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -165,13 +165,13 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_ty(this, ty);\n                 });\n             }\n-            ast::TyPath(ref path, id) => {\n+            ast::TyPath(None, ref path) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n-                match self.def_map.borrow().get(&id) {\n-                    Some(&def::DefaultImpl(..)) => {\n+                match self.def_map.borrow().get(&ty.id).map(|d| (d.base_def, d.depth)) {\n+                    Some((def::DefTrait(..), 0)) => {\n                         self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n-                            this.visit_path(path, id);\n+                            this.visit_path(path, ty.id);\n                         });\n                     }\n                     _ => {\n@@ -270,16 +270,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n                 }\n-                this.visit_trait_ref(&trait_ref.trait_ref)\n+                visit::walk_path(this, &trait_ref.trait_ref.path)\n             })\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref)\n         }\n     }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n-        self.visit_path(&trait_ref.path, trait_ref.ref_id);\n-    }\n }\n \n impl<'a> LifetimeContext<'a> {"}, {"sha": "f67e470ee54917a1a2f9105fca63a5c50c5a877a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -393,12 +393,14 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n \n pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n                   cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n-    let did = match tcx.def_map.borrow().get(&id) {\n-        Some(&def::DefPrimTy(..)) => return,\n-        Some(def) => def.def_id(),\n-        None => return\n-    };\n-    maybe_do_stability_check(tcx, did, path.span, cb)\n+    match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+        Some(def::DefPrimTy(..)) => {}\n+        Some(def) => {\n+            maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n+        }\n+        None => {}\n+    }\n+\n }\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,"}, {"sha": "9131363339710f35bf22e44868e8af02db23497b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -709,7 +709,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n \n-    pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n+    pub impl_trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n@@ -2423,7 +2423,7 @@ impl<'tcx> CommonTypes<'tcx> {\n \n pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n-                     dm: DefMap,\n+                     def_map: DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n@@ -2445,11 +2445,11 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         item_variance_map: RefCell::new(DefIdMap()),\n         variance_computed: Cell::new(false),\n         sess: s,\n-        def_map: dm,\n+        def_map: def_map,\n         region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n-        trait_refs: RefCell::new(NodeMap()),\n+        impl_trait_refs: RefCell::new(NodeMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n@@ -4174,12 +4174,12 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n     }\n }\n \n-pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n+pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n                                   -> Rc<ty::TraitRef<'tcx>> {\n-    match cx.trait_refs.borrow().get(&id) {\n+    match cx.impl_trait_refs.borrow().get(&id) {\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n-            &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+            &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n                     cx.map.node_to_string(id)))\n     }\n }\n@@ -4502,7 +4502,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n \n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().get(&expr.id) {\n-        Some(&def) => def,\n+        Some(def) => def.full_def(),\n         None => {\n             tcx.sess.span_bug(expr.span, &format!(\n                 \"no def-map entry for expr {}\", expr.id));\n@@ -4550,7 +4550,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     }\n \n     match expr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             match resolve_expr(tcx, expr) {\n                 def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n@@ -4581,7 +4581,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefFn(_, true) => RvalueDpsExpr,\n \n                 // Fn pointers are just scalar values.\n-                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => RvalueDatumExpr,\n+                def::DefFn(..) | def::DefMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n@@ -4685,11 +4685,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprBox(Some(ref place), _) => {\n             // Special case `Box<T>` for now:\n-            let definition = match tcx.def_map.borrow().get(&place.id) {\n-                Some(&def) => def,\n+            let def_id = match tcx.def_map.borrow().get(&place.id) {\n+                Some(def) => def.def_id(),\n                 None => panic!(\"no def for place\"),\n             };\n-            let def_id = definition.def_id();\n             if tcx.lang_items.exchange_heap() == Some(def_id) {\n                 RvalueDatumExpr\n             } else {\n@@ -5116,25 +5115,16 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-            match cx.map.find(id.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, ref opt_trait, _, _) => {\n-                            match opt_trait {\n-                                &Some(ref t) => {\n-                                    let trait_ref = ty::node_id_to_trait_ref(cx, t.ref_id);\n-                                    Some(trait_ref)\n-                                }\n-                                &None => None\n-                            }\n-                        }\n-                        ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-                            Some(ty::node_id_to_trait_ref(cx, ast_trait_ref.ref_id))\n-                        }\n-                        _ => None\n+            if let Some(ast_map::NodeItem(item)) = cx.map.find(id.node) {\n+                match item.node {\n+                    ast::ItemImpl(_, _, _, Some(_), _, _) |\n+                    ast::ItemDefaultImpl(..) => {\n+                        Some(ty::impl_id_to_trait_ref(cx, id.node))\n                     }\n+                    _ => None\n                 }\n-                _ => None\n+            } else {\n+                None\n             }\n         } else {\n             csearch::get_impl_trait(cx, id)\n@@ -5143,10 +5133,7 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n-    let def = *tcx.def_map.borrow()\n-                     .get(&tr.ref_id)\n-                     .expect(\"no def-map entry for trait\");\n-    def.def_id()\n+    tcx.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n }\n \n pub fn try_add_builtin_trait(\n@@ -5848,7 +5835,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n-                ast::ExprPath(ast::Path {\n+                ast::ExprPath(None, ast::Path {\n                     global: false,\n                     ref segments,\n                     .."}, {"sha": "e16df61c25c47a9e83c97746f13b61ab3c13f41c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -244,8 +244,7 @@ mod svh_visitor {\n         SawExprAssignOp(ast::BinOp_),\n         SawExprIndex,\n         SawExprRange,\n-        SawExprPath,\n-        SawExprQPath,\n+        SawExprPath(Option<usize>),\n         SawExprAddrOf(ast::Mutability),\n         SawExprRet,\n         SawExprInlineAsm(&'a ast::InlineAsm),\n@@ -277,8 +276,7 @@ mod svh_visitor {\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprRange(..)            => SawExprRange,\n-            ExprPath(..)             => SawExprPath,\n-            ExprQPath(..)            => SawExprQPath,\n+            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),\n             ExprBreak(id)            => SawExprBreak(id.map(content)),\n             ExprAgain(id)            => SawExprAgain(id.map(content)),"}, {"sha": "bd911c20afc47e0aeb178cd30485ec1470ef926f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -571,7 +571,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n         export_map,\n         trait_map,\n         external_exports,\n-        last_private_map,\n         glob_map,\n     } =\n         time(time_passes, \"resolution\", (),\n@@ -620,10 +619,9 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"const checking\", (), |_|\n          middle::check_const::check_crate(&ty_cx));\n \n-    let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n-            time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 rustc_privacy::check_crate(&ty_cx, &export_map, a, b));\n+            time(time_passes, \"privacy checking\", (), |_|\n+                 rustc_privacy::check_crate(&ty_cx, &export_map, external_exports));\n \n     // Do not move this check past lint\n     time(time_passes, \"stability index\", (), |_|"}, {"sha": "436a826687e1368616c83aee88ebda2e6bf06166", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 41, "deletions": 63, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -17,7 +17,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(core)]\n #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -38,8 +37,7 @@ use rustc::middle::def;\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n-use rustc::middle::privacy::{ExportedItems, PublicItems, LastPrivateMap};\n-use rustc::middle::privacy::{ExternalExports};\n+use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n@@ -259,8 +257,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // * Private trait impls for private types can be completely ignored\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n-                    ast::TyPath(_, id) => {\n-                        match self.tcx.def_map.borrow()[id].clone() {\n+                    ast::TyPath(..) => {\n+                        match self.tcx.def_map.borrow()[ty.id].full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -326,8 +324,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n \n             ast::ItemTy(ref ty, _) if public_first => {\n-                if let ast::TyPath(_, id) = ty.node {\n-                    match self.tcx.def_map.borrow()[id].clone() {\n+                if let ast::TyPath(..) = ty.node {\n+                    match self.tcx.def_map.borrow()[ty.id].full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n@@ -379,7 +377,6 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     in_foreign: bool,\n     parents: NodeMap<ast::NodeId>,\n     external_exports: ExternalExports,\n-    last_private_map: LastPrivateMap,\n }\n \n enum PrivacyResult {\n@@ -628,11 +625,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     // back up the chains to find the relevant struct/enum that\n                     // was private.\n                     ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                        let id = match ty.node {\n-                            ast::TyPath(_, id) => id,\n+                        match ty.node {\n+                            ast::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow()[id].clone();\n+                        let def = self.tcx.def_map.borrow()[ty.id].full_def();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -716,21 +713,21 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a path is in scope.\n-    fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n+    fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n+        let path_res = self.tcx.def_map.borrow()[path_id];\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n-                let name = token::get_ident(path.segments.last().unwrap().identifier);\n-                let origdid = orig_def.def_id();\n+                let name = token::get_ident(last);\n+                let origdid = path_res.def_id();\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n                                    &format!(\"{} `{}`\", tyname, name))\n             };\n \n-            match self.last_private_map[path_id] {\n+            match path_res.last_private {\n                 LastMod(AllPublic) => {},\n                 LastMod(DependsOn(def)) => {\n                     self.report_error(ck_public(def));\n@@ -794,17 +791,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        match self.tcx.def_map.borrow()[path_id].clone() {\n-            def::DefStaticMethod(..) => ck(\"static method\"),\n+        match path_res.full_def() {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefConst(..) => ck(\"const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n-            def::DefaultImpl(..) => ck(\"trait\"),\n+            def::DefTrait(..) => ck(\"trait\"),\n             def::DefStruct(..) => ck(\"struct\"),\n-            def::DefMethod(_, Some(..), _) => ck(\"trait method\"),\n             def::DefMethod(..) => ck(\"method\"),\n             def::DefMod(..) => ck(\"module\"),\n             _ => {}\n@@ -832,37 +827,22 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemUse(ref vpath) => {\n-                match vpath.node {\n-                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n-                    ast::ViewPathList(ref prefix, ref list) => {\n-                        for pid in list {\n-                            match pid.node {\n-                                ast::PathListIdent { id, name } => {\n-                                    debug!(\"privacy - ident item {}\", id);\n-                                    let seg = ast::PathSegment {\n-                                        identifier: name,\n-                                        parameters: ast::PathParameters::none(),\n-                                    };\n-                                    let segs = vec![seg];\n-                                    let path = ast::Path {\n-                                        global: false,\n-                                        span: pid.span,\n-                                        segments: segs,\n-                                    };\n-                                    self.check_path(pid.span, id, &path);\n-                                }\n-                                ast::PathListMod { id } => {\n-                                    debug!(\"privacy - mod item {}\", id);\n-                                    self.check_path(pid.span, id, prefix);\n-                                }\n-                            }\n+        if let ast::ItemUse(ref vpath) = item.node {\n+            if let ast::ViewPathList(ref prefix, ref list) = vpath.node {\n+                for pid in list {\n+                    match pid.node {\n+                        ast::PathListIdent { id, name } => {\n+                            debug!(\"privacy - ident item {}\", id);\n+                            self.check_path(pid.span, id, name);\n+                        }\n+                        ast::PathListMod { id } => {\n+                            debug!(\"privacy - mod item {}\", id);\n+                            let name = prefix.segments.last().unwrap().identifier;\n+                            self.check_path(pid.span, id, name);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item);\n@@ -908,7 +888,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].clone() {\n+                        match self.tcx.def_map.borrow()[expr.id].full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,\n@@ -927,7 +907,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                                             struct type?!\"),\n                 }\n             }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n+            ast::ExprPath(..) => {\n                 let guard = |did: ast::DefId| {\n                     let fields = ty::lookup_struct_fields(self.tcx, did);\n                     let any_priv = fields.iter().any(|f| {\n@@ -941,8 +921,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                              with private fields\");\n                     }\n                 };\n-                match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def::DefStruct(did)) => {\n+                match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n+                    Some(def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n                         } else {\n@@ -981,8 +961,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&pattern.id) {\n-                            Some(&def::DefVariant(_, variant_id, _)) => {\n+                        match self.tcx.def_map.borrow().get(&pattern.id).map(|d| d.full_def()) {\n+                            Some(def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.node.ident.name));\n@@ -1033,7 +1013,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        self.check_path(path.span, id, path);\n+        self.check_path(path.span, id, path.segments.last().unwrap().identifier);\n         visit::walk_path(self, path);\n     }\n }\n@@ -1233,7 +1213,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(def::DefPrimTy(..)) => return false,\n             Some(def) => def.def_id()\n@@ -1273,8 +1253,8 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(_, path_id) = ty.node {\n-            if self.inner.path_is_private_type(path_id) {\n+        if let ast::TyPath(..) = ty.node {\n+            if self.inner.path_is_private_type(ty.id) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n                 // working.\n@@ -1398,7 +1378,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            self.visit_trait_ref(tr)\n+                            visit::walk_path(self, &tr.path);\n                         }\n                     }\n                 } else if trait_ref.is_none() && self_is_public_path {\n@@ -1479,9 +1459,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n-        if let ast::TyPath(ref p, path_id) = t.node {\n+        if let ast::TyPath(_, ref p) = t.node {\n             if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(path_id) {\n+                self.path_is_private_type(t.id) {\n                 self.tcx.sess.span_err(p.span,\n                                        \"private type in exported type signature\");\n             }\n@@ -1517,8 +1497,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    export_map: &def::ExportMap,\n-                   external_exports: ExternalExports,\n-                   last_private_map: LastPrivateMap)\n+                   external_exports: ExternalExports)\n                    -> (ExportedItems, PublicItems) {\n     let krate = tcx.map.krate();\n \n@@ -1536,7 +1515,6 @@ pub fn check_crate(tcx: &ty::ctxt,\n         tcx: tcx,\n         parents: visitor.parents,\n         external_exports: external_exports,\n-        last_private_map: last_private_map,\n     };\n     visit::walk_crate(&mut visitor, krate);\n "}, {"sha": "67e2b409c8e2213d8dfd8613d68d803972992dd5", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 41, "deletions": 315, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -23,38 +23,32 @@ use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n-use RibKind::*;\n use Shadowable;\n use TypeNsDef;\n-use TypeParameters::HasTypeParameters;\n \n use self::DuplicateCheckingMode::*;\n use self::NamespaceError::*;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n-use rustc::middle::subst::FnSpace;\n \n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n-use syntax::ast::{PathListIdent, PathListMod};\n-use syntax::ast::{Public, SelfStatic};\n+use syntax::ast::{Name, NamedField, NodeId};\n+use syntax::ast::{PathListIdent, PathListMod, Public};\n use syntax::ast::StmtDecl;\n use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n-use syntax::ast::TyObjectSum;\n-use syntax::ast::{TypeImplItem, UnnamedField};\n+use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n-use syntax::ast::TyPath;\n use syntax::ast;\n-use syntax::ast_util::{self, PostExpansionMethod, local_def};\n+use syntax::ast_util::{self, local_def};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -181,12 +175,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateTypesAndModules => {\n-                        match child.def_for_namespace(TypeNS) {\n-                            None => {}\n-                            Some(_) if child.get_module_if_available()\n-                                            .map(|m| m.kind.get()) ==\n-                                       Some(ImplModuleKind) => {}\n-                            Some(_) => duplicate_type = TypeError\n+                        if child.defined_in_namespace(TypeNS) {\n+                            duplicate_type = TypeError;\n                         }\n                         Some(TypeNS)\n                     }\n@@ -465,9 +455,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 name_bindings.define_type(DefTy(local_def(item.id), true), sp, modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                // We want to make sure the module type is EnumModuleKind\n-                // even if there's already an ImplModuleKind module defined,\n-                // since that's how we prevent duplicate enum definitions\n                 name_bindings.set_module_kind(parent_link,\n                                               Some(local_def(item.id)),\n                                               EnumModuleKind,\n@@ -517,147 +504,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 parent.clone()\n             }\n \n-            ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n-                // If this implements an anonymous trait, then add all the\n-                // methods within to a new module, if the type was defined\n-                // within this module.\n-\n-                let mod_name = match ty.node {\n-                    TyPath(ref path, _) if path.segments.len() == 1 => {\n-                        // FIXME(18446) we should distinguish between the name of\n-                        // a trait and the name of an impl of that trait.\n-                        Some(path.segments.last().unwrap().identifier.name)\n-                    }\n-                    TyObjectSum(ref lhs_ty, _) => {\n-                        match lhs_ty.node {\n-                            TyPath(ref path, _) if path.segments.len() == 1 => {\n-                                Some(path.segments.last().unwrap().identifier.name)\n-                            }\n-                            _ => {\n-                                None\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        None\n-                    }\n-                };\n-\n-                let mod_name = match mod_name {\n-                    Some(mod_name) => mod_name,\n-                    None => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\");\n-                        return parent.clone();\n-                    }\n-                };\n-                // Create the module and add all methods.\n-                let child_opt = parent.children.borrow().get(&mod_name)\n-                                       .and_then(|m| m.get_module_if_available());\n-                let new_parent = match child_opt {\n-                    // It already exists\n-                    Some(ref child) if (child.kind.get() == ImplModuleKind ||\n-                                        child.kind.get() == TraitModuleKind) => {\n-                        child.clone()\n-                    }\n-                    Some(ref child) if child.kind.get() == EnumModuleKind ||\n-                                       child.kind.get() == TypeModuleKind => {\n-                        child.clone()\n-                    }\n-                    // Create the module\n-                    _ => {\n-                        let name_bindings =\n-                            self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n-\n-                        let parent_link = self.get_parent_link(parent, name);\n-                        let def_id = local_def(item.id);\n-                        let ns = TypeNS;\n-                        let is_public =\n-                            !name_bindings.defined_in_namespace(ns) ||\n-                            name_bindings.defined_in_public_namespace(ns);\n-\n-                        name_bindings.define_module(parent_link,\n-                                                    Some(def_id),\n-                                                    ImplModuleKind,\n-                                                    false,\n-                                                    is_public,\n-                                                    sp);\n-\n-                        name_bindings.get_module()\n-                    }\n-                };\n-\n-                // For each implementation item...\n-                for impl_item in impl_items {\n-                    match *impl_item {\n-                        MethodImplItem(ref method) => {\n-                            // Add the method to the module.\n-                            let name = method.pe_ident().name;\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               &new_parent,\n-                                               ForbidDuplicateValues,\n-                                               method.span);\n-                            let def = match method.pe_explicit_self()\n-                                .node {\n-                                    SelfStatic => {\n-                                        // Static methods become\n-                                        // `DefStaticMethod`s.\n-                                        DefStaticMethod(local_def(method.id),\n-                                                        FromImpl(local_def(item.id)))\n-                                    }\n-                                    _ => {\n-                                        // Non-static methods become\n-                                        // `DefMethod`s.\n-                                        DefMethod(local_def(method.id),\n-                                                  None,\n-                                                  FromImpl(local_def(item.id)))\n-                                    }\n-                                };\n-\n-                            // NB: not IMPORTABLE\n-                            let modifiers = if method.pe_vis() == ast::Public {\n-                                PUBLIC\n-                            } else {\n-                                DefModifiers::empty()\n-                            };\n-                            method_name_bindings.define_value(\n-                                def,\n-                                method.span,\n-                                modifiers);\n-                        }\n-                        TypeImplItem(ref typedef) => {\n-                            // Add the typedef to the module.\n-                            let name = typedef.ident.name;\n-                            let typedef_name_bindings =\n-                                self.add_child(\n-                                    name,\n-                                    &new_parent,\n-                                    ForbidDuplicateTypesAndModules,\n-                                    typedef.span);\n-                            let def = DefAssociatedTy(local_def(\n-                                typedef.id));\n-                            // NB: not IMPORTABLE\n-                            let modifiers = if typedef.vis == ast::Public {\n-                                PUBLIC\n-                            } else {\n-                                DefModifiers::empty()\n-                            };\n-                            typedef_name_bindings.define_type(\n-                                def,\n-                                typedef.span,\n-                                modifiers);\n-                        }\n-                    }\n-                }\n-                parent.clone()\n-            }\n-\n             ItemDefaultImpl(_, _) |\n-            ItemImpl(_, _, _, Some(_), _, _) => parent.clone(),\n+            ItemImpl(..) => parent.clone(),\n \n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings =\n@@ -677,31 +525,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let (name, kind) = match *trait_item {\n+                    let (name, trait_item_id) = match *trait_item {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n                             let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n \n                             let name = ty_m.ident.name;\n \n                             // Add it as a name in the trait module.\n-                            let (def, static_flag) = match ty_m.explicit_self\n-                                                               .node {\n-                                SelfStatic => {\n-                                    // Static methods become `DefStaticMethod`s.\n-                                    (DefStaticMethod(\n-                                            local_def(ty_m.id),\n-                                            FromTrait(local_def(item.id))),\n-                                     StaticMethodTraitItemKind)\n-                                }\n-                                _ => {\n-                                    // Non-static methods become `DefMethod`s.\n-                                    (DefMethod(local_def(ty_m.id),\n-                                               Some(local_def(item.id)),\n-                                               FromTrait(local_def(item.id))),\n-                                     NonstaticMethodTraitItemKind)\n-                                }\n-                            };\n+                            let def = DefMethod(local_def(ty_m.id),\n+                                                FromTrait(local_def(item.id)));\n \n                             let method_name_bindings =\n                                 self.add_child(name,\n@@ -713,11 +546,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                               ty_m.span,\n                                                               PUBLIC);\n \n-                            (name, static_flag)\n+                            (name, local_def(ty_m.id))\n                         }\n                         ast::TypeTraitItem(ref associated_type) => {\n-                            let def = DefAssociatedTy(local_def(\n-                                    associated_type.ty_param.id));\n+                            let def = DefAssociatedTy(local_def(item.id),\n+                                                      local_def(associated_type.ty_param.id));\n \n                             let name_bindings =\n                                 self.add_child(associated_type.ty_param.ident.name,\n@@ -729,14 +562,15 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                       associated_type.ty_param.span,\n                                                       PUBLIC);\n \n-                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n+                            (associated_type.ty_param.ident.name,\n+                             local_def(associated_type.ty_param.id))\n                         }\n                     };\n \n-                    self.trait_item_map.insert((name, def_id), kind);\n+                    self.trait_item_map.insert((name, def_id), trait_item_id);\n                 }\n \n-                name_bindings.define_type(DefaultImpl(def_id), sp, modifiers);\n+                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n                 parent.clone()\n             }\n             ItemMac(..) => parent.clone()\n@@ -773,38 +607,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n-                                               foreign_item: &ForeignItem,\n-                                               parent: &Rc<Module>,\n-                                               f: F) where\n-        F: FnOnce(&mut Resolver),\n-    {\n+    fn build_reduced_graph_for_foreign_item(&mut self,\n+                                            foreign_item: &ForeignItem,\n+                                            parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n-        match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), false);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                self.with_type_parameter_rib(\n-                    HasTypeParameters(generics,\n-                                      FnSpace,\n-                                      foreign_item.id,\n-                                      NormalRibKind),\n-                    f);\n+        let def = match foreign_item.node {\n+            ForeignItemFn(..) => {\n+                DefFn(local_def(foreign_item.id), false)\n             }\n             ForeignItemStatic(_, m) => {\n-                let def = DefStatic(local_def(foreign_item.id), m);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                f(self.resolver)\n+                DefStatic(local_def(foreign_item.id), m)\n             }\n-        }\n+        };\n+        name_bindings.define_value(def, foreign_item.span, modifiers);\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n@@ -850,8 +671,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let kind = match def {\n             DefTy(_, true) => EnumModuleKind,\n-            DefTy(_, false) => TypeModuleKind,\n-            DefStruct(..) => ImplModuleKind,\n+            DefTy(_, false) | DefStruct(..) => TypeModuleKind,\n             _ => NormalModuleKind\n         };\n \n@@ -905,7 +725,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n           }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+          DefFn(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier\n@@ -918,7 +738,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n             child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }\n-          DefaultImpl(def_id) => {\n+          DefTrait(def_id) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n@@ -927,21 +747,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n               let trait_item_def_ids =\n                 csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def_id in &trait_item_def_ids {\n-                  let (trait_item_name, trait_item_kind) =\n-                      csearch::get_trait_item_name_and_kind(\n-                          &self.session.cstore,\n-                          trait_item_def_id.def_id());\n+              for trait_item_def in &trait_item_def_ids {\n+                  let trait_item_name = csearch::get_trait_name(&self.session.cstore,\n+                                                                trait_item_def.def_id());\n \n                   debug!(\"(building reduced graph for external crate) ... \\\n                           adding trait item '{}'\",\n                          token::get_name(trait_item_name));\n \n-                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n+                  self.trait_item_map.insert((trait_item_name, def_id),\n+                                             trait_item_def.def_id());\n \n                   if is_exported {\n-                      self.external_exports\n-                          .insert(trait_item_def_id.def_id());\n+                      self.external_exports.insert(trait_item_def.def_id());\n                   }\n               }\n \n@@ -956,7 +774,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                   is_public,\n                                                   DUMMY_SP)\n           }\n-          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n+          DefTy(..) | DefAssociatedTy(..) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n@@ -980,7 +798,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n           }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n-          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n+          DefLabel(..) | DefSelfTy(..) => {\n             panic!(\"didn't expect `{:?}`\", def);\n           }\n         }\n@@ -1027,92 +845,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 }\n             }\n-            DlImpl(def) => {\n-                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n-                    None => {}\n-                    Some(final_name) => {\n-                        let methods_opt =\n-                            csearch::get_methods_if_impl(&self.session.cstore, def);\n-                        match methods_opt {\n-                            Some(ref methods) if\n-                                methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n-                                        external crate) processing \\\n-                                        static methods for type name {}\",\n-                                        token::get_name(final_name));\n-\n-                                let child_name_bindings =\n-                                    self.add_child(\n-                                        final_name,\n-                                        root,\n-                                        OverwriteDuplicates,\n-                                        DUMMY_SP);\n-\n-                                // Process the static methods. First,\n-                                // create the module.\n-                                let type_module;\n-                                let type_def = child_name_bindings.type_def.borrow().clone();\n-                                match type_def {\n-                                    Some(TypeNsDef {\n-                                        module_def: Some(module_def),\n-                                        ..\n-                                    }) => {\n-                                        // We already have a module. This\n-                                        // is OK.\n-                                        type_module = module_def;\n-\n-                                        // Mark it as an impl module if\n-                                        // necessary.\n-                                        type_module.kind.set(ImplModuleKind);\n-                                    }\n-                                    Some(_) | None => {\n-                                        let parent_link =\n-                                            self.get_parent_link(root, final_name);\n-                                        child_name_bindings.define_module(\n-                                            parent_link,\n-                                            Some(def),\n-                                            ImplModuleKind,\n-                                            true,\n-                                            true,\n-                                            DUMMY_SP);\n-                                        type_module =\n-                                            child_name_bindings.\n-                                                get_module();\n-                                    }\n-                                }\n-\n-                                // Add each static method to the module.\n-                                let new_parent = type_module;\n-                                for method_info in methods {\n-                                    let name = method_info.name;\n-                                    debug!(\"(building reduced graph for \\\n-                                             external crate) creating \\\n-                                             static method '{}'\",\n-                                           token::get_name(name));\n-\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       &new_parent,\n-                                                       OverwriteDuplicates,\n-                                                       DUMMY_SP);\n-                                    let def = DefFn(method_info.def_id, false);\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method_info.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def, DUMMY_SP, modifiers);\n-                                }\n-                            }\n-\n-                            // Otherwise, do nothing.\n-                            Some(_) | None => {}\n-                        }\n-                    }\n-                }\n+            DlImpl(_) => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring impl\");\n             }\n             DlField => {\n                 debug!(\"(building reduced graph for external crate) \\\n@@ -1241,16 +976,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        let parent = &self.parent;\n-        self.builder.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                          parent,\n-                                                          |r| {\n-            let mut v = BuildReducedGraphVisitor {\n-                builder: GraphBuilder { resolver: r },\n-                parent: parent.clone()\n-            };\n-            visit::walk_foreign_item(&mut v, foreign_item);\n-        })\n+        self.builder.build_reduced_graph_for_foreign_item(foreign_item, &self.parent);\n     }\n \n     fn visit_block(&mut self, block: &Block) {"}, {"sha": "aebbe14407380336174b9c85f82bd693b5084dbd", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -68,17 +68,17 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                                   \"unused import\".to_string());\n         }\n \n-        let (v_priv, t_priv) = match self.last_private.get(&id) {\n-            Some(&LastImport {\n-                value_priv: v,\n-                value_used: _,\n-                type_priv: t,\n-                type_used: _\n-            }) => (v, t),\n-            Some(_) => {\n+        let mut def_map = self.def_map.borrow_mut();\n+        let path_res = if let Some(r) = def_map.get_mut(&id) {\n+            r\n+        } else {\n+            return;\n+        };\n+        let (v_priv, t_priv) = match path_res.last_private {\n+            LastImport { value_priv, type_priv, .. } => (value_priv, type_priv),\n+            _ => {\n                 panic!(\"we should only have LastImport for `use` directives\")\n             }\n-            _ => return,\n         };\n \n         let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n@@ -100,10 +100,12 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             _ => {},\n         }\n \n-        self.last_private.insert(id, LastImport{value_priv: v_priv,\n-                                                value_used: v_used,\n-                                                type_priv: t_priv,\n-                                                type_used: t_used});\n+        path_res.last_private = LastImport {\n+            value_priv: v_priv,\n+            value_used: v_used,\n+            type_priv: t_priv,\n+            type_used: t_used\n+        };\n     }\n }\n "}, {"sha": "95523be68c3bf9ffa3ec594ca0c3202db98e267f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 587, "deletions": 938, "changes": 1525, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5"}, {"sha": "371b9268fba0de800de32544ce97f95de7f9b707", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -218,7 +218,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n+        let def = self.analysis.ty_cx.def_map.borrow()[ref_id].full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -231,15 +231,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n         }\n-        let def = (*def_map)[ref_id];\n+        let def = def_map[ref_id].full_def();\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n             def::DefStruct(_) => Some(recorder::StructRef),\n             def::DefTy(..) |\n             def::DefAssociatedTy(..) |\n-            def::DefAssociatedPath(..) |\n-            def::DefaultImpl(_) => Some(recorder::TypeRef),\n+            def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n             def::DefLocal(_) |\n@@ -250,9 +249,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n             def::DefSelfTy(_) |\n             def::DefRegion(_) |\n-            def::DefTyParamBinder(_) |\n             def::DefLabel(_) |\n-            def::DefStaticMethod(..) |\n             def::DefTyParam(..) |\n             def::DefUse(_) |\n             def::DefMethod(..) |\n@@ -662,9 +659,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n         match typ.node {\n             // Common case impl for a struct or something basic.\n-            ast::TyPath(ref path, id) => {\n+            ast::TyPath(None, ref path) => {\n                 let sub_span = self.span.sub_span_for_type_name(path.span);\n-                let self_id = self.lookup_type_ref(id).map(|id| {\n+                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n                     self.fmt.ref_str(recorder::TypeRef,\n                                      path.span,\n                                      sub_span,\n@@ -795,9 +792,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n-        let def = &(*def_map)[id];\n+        let def = def_map[id].full_def();\n         let sub_span = self.span.span_for_last_ident(span);\n-        match *def {\n+        match def {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n@@ -817,8 +814,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                       sub_span,\n                                                       def_id,\n                                                       self.cur_scope),\n-            def::DefStaticMethod(declid, provenence) |\n-            def::DefMethod(declid, _, provenence) => {\n+            def::DefMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n@@ -870,11 +866,18 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     &format!(\"Unexpected def kind while looking \\\n                                               up path in `{}`: `{:?}`\",\n                                              self.span.snippet(span),\n-                                             *def)),\n+                                             def)),\n         }\n         // modules or types in the path prefix\n-        match *def {\n-            def::DefStaticMethod(..) => self.write_sub_path_trait_truncated(path),\n+        match def {\n+            def::DefMethod(did, _) => {\n+                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n+                if let ty::MethodTraitItem(m) = ti {\n+                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n+                        self.write_sub_path_trait_truncated(path);\n+                    }\n+                }\n+            }\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n@@ -1001,7 +1004,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow()[p.id];\n+                let def = self.analysis.ty_cx.def_map.borrow()[p.id].full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n@@ -1303,8 +1306,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match t.node {\n-            ast::TyPath(ref path, id) => {\n-                match self.lookup_type_ref(id) {\n+            ast::TyPath(_, ref path) => {\n+                match self.lookup_type_ref(t.id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(t.span);\n                         self.fmt.ref_str(recorder::TypeRef,\n@@ -1334,16 +1337,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n-            },\n-            ast::ExprPath(ref path) => {\n-                self.process_path(ex.id, path.span, path, None);\n-                visit::walk_path(self, path);\n             }\n-            ast::ExprQPath(ref qpath) => {\n-                let mut path = qpath.trait_ref.path.clone();\n-                path.segments.push(qpath.item_path.clone());\n-                self.process_path(ex.id, ex.span, &path, None);\n-                visit::walk_qpath(self, ex.span, &**qpath);\n+            ast::ExprPath(_, ref path) => {\n+                self.process_path(ex.id, path.span, path, None);\n+                visit::walk_expr(self, ex);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n@@ -1459,8 +1456,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n                                            id));\n             }\n-            let def = &(*def_map)[id];\n-            match *def {\n+            let def = def_map[id].full_def();\n+            match def {\n                 def::DefLocal(id)  => {\n                     let value = if *immut {\n                         self.span.snippet(p.span).to_string()\n@@ -1483,7 +1480,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            *def)\n+                            def)\n             }\n         }\n         for &(id, ref path, ref_kind) in &paths_to_process {"}, {"sha": "8de046fa6ebb6c8486604be025597ffd6684a976", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -238,6 +238,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n         let mut bracket_count = 0;\n+        let mut found_ufcs_sep = false;\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n@@ -254,13 +255,20 @@ impl<'a> SpanUtils<'a> {\n             }\n             bracket_count += match ts.tok {\n                 token::Lt => 1,\n-                token::Gt => -1,\n+                token::Gt => {\n+                    // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n+                    if !found_ufcs_sep && bracket_count == 0 {\n+                        found_ufcs_sep = true;\n+                        0\n+                    } else {\n+                        -1\n+                    }\n+                }\n                 token::BinOp(token::Shl) => 2,\n                 token::BinOp(token::Shr) => -2,\n                 _ => 0\n             };\n-            if ts.tok.is_ident() &&\n-               bracket_count == nesting {\n+            if ts.tok.is_ident() && bracket_count == nesting {\n                 result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n             }\n         }"}, {"sha": "9a121a8830b2b8d1b94d41e63e527463db1614f8", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -598,7 +598,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n+                let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n@@ -725,14 +725,14 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n-                match tcx.def_map.borrow().get(&pat.id) {\n-                    Some(&def::DefVariant(..)) => false,\n+                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                    Some(def::DefVariant(..)) => false,\n                     _ => true,\n                 }\n             }\n             ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n-                match tcx.def_map.borrow().get(&pat.id) {\n-                    Some(&def::DefStruct(..)) => true,\n+                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n+                    Some(def::DefStruct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -1277,20 +1277,20 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     let (vid, field) = match discr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => match bcx.def(discr.id) {\n+        ast::ExprPath(..) => match bcx.def(discr.id) {\n             def::DefLocal(vid) | def::DefUpvar(vid, _) => (vid, None),\n             _ => return false\n         },\n         ast::ExprField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n+            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node.name)))\n         },\n         ast::ExprTupField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id) {\n-                Some(&def::DefLocal(vid)) | Some(&def::DefUpvar(vid, _)) => vid,\n+            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))\n@@ -1689,7 +1689,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).cloned();\n+            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "59fcd5492ebde534e3be049a8331a631c9cc8dec", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -93,7 +93,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n         _ => {}\n@@ -165,13 +165,11 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n             }\n-            def::DefFn(did, _) | def::DefMethod(did, _, def::FromImpl(_)) |\n-            def::DefStaticMethod(did, def::FromImpl(_)) => {\n+            def::DefFn(did, _) | def::DefMethod(did, def::FromImpl(_)) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n                                             bcx.fcx.param_substs).val)\n             }\n-            def::DefStaticMethod(meth_did, def::FromTrait(trait_did)) |\n-            def::DefMethod(meth_did, _, def::FromTrait(trait_did)) => {\n+            def::DefMethod(meth_did, def::FromTrait(trait_did)) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx.ccx(),\n                                                                 meth_did,\n                                                                 trait_did,\n@@ -207,11 +205,10 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            def::DefMod(..) | def::DefForeignMod(..) | def::DefaultImpl(..) |\n+            def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n-            def::DefUse(..) | def::DefTyParamBinder(..) |\n-            def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |\n-            def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n+            def::DefUse(..) | def::DefRegion(..) | def::DefLabel(..) |\n+            def::DefTyParam(..) | def::DefSelfTy(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "d8fc6df2685dd5d9656ee561e0dd9a5565b90371", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -603,7 +603,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().get(&nid) {\n-            Some(v) => v.clone(),\n+            Some(v) => v.full_def(),\n             None => {\n                 self.tcx().sess.bug(&format!(\n                     \"no def associated with node id {}\", nid));"}, {"sha": "c1d22cc973c240c209b88dce5d1d5c8728c2eb70", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -193,8 +193,8 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           -> ValueRef {\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n-        ast::ExprPath(_) => {\n-            let def = ccx.tcx().def_map.borrow()[expr.id];\n+        ast::ExprPath(..) => {\n+            let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n             match def {\n                 def::DefConst(def_id) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n@@ -582,7 +582,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => break,\n                   }\n               }\n-              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n+              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n                   get_static_val(cx, def_id, ety)\n               } else {\n@@ -663,10 +663,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 C_array(llunitty, &vs[..])\n             }\n           }\n-          ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            let def = cx.tcx().def_map.borrow()[e.id];\n+          ast::ExprPath(..) => {\n+            let def = cx.tcx().def_map.borrow()[e.id].full_def();\n             match def {\n-                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => {\n+                def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n                 def::DefConst(def_id) => {\n@@ -701,7 +701,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n+              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).map(|d| d.full_def());\n               let arg_vals = map_list(&args[..]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {"}, {"sha": "ad96c506c9ddf14333af894780629a2dc254f47b", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -306,11 +306,10 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr.id) {\n-                Some(&def::DefLabel(loop_id)) => loop_id,\n-                ref r => {\n-                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n-                                               r))\n+            match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n+                Some(def::DefLabel(loop_id)) => loop_id,\n+                r => {\n+                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\", r))\n                 }\n             }\n         }"}, {"sha": "d70a904b81189fde012837d6b320799e493eabe5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -3487,8 +3487,7 @@ fn create_scope_map(cx: &CrateContext,\n             ast::ExprLit(_)   |\n             ast::ExprBreak(_) |\n             ast::ExprAgain(_) |\n-            ast::ExprPath(_)  |\n-            ast::ExprQPath(_) => {}\n+            ast::ExprPath(..) => {}\n \n             ast::ExprCast(ref sub_exp, _)     |\n             ast::ExprAddrOf(_, ref sub_exp)  |"}, {"sha": "5cc1baf66c6219806e17520f42b2e224413ea45f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -143,7 +143,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // it prefers in-place instantiation, likely because it contains\n             // `[x; N]` somewhere within.\n             match expr.node {\n-                ast::ExprPath(_) | ast::ExprQPath(_) => {\n+                ast::ExprPath(..) => {\n                     match bcx.def(expr.id) {\n                         def::DefConst(did) => {\n                             let expr = consts::get_const_expr(bcx.ccx(), did, expr);\n@@ -629,7 +629,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprParen(ref e) => {\n             trans(bcx, &**e)\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         ast::ExprField(ref base, ident) => {\n@@ -875,7 +875,7 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) |\n+        def::DefFn(..) | def::DefMethod(..) |\n         def::DefStruct(_) | def::DefVariant(..) => {\n             let datum = trans_def_fn_unadjusted(bcx.ccx(), ref_expr, def,\n                                                 bcx.fcx.param_substs);\n@@ -1033,7 +1033,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprParen(ref e) => {\n             trans_into(bcx, &**e, dest)\n         }\n-        ast::ExprPath(_) | ast::ExprQPath(_) => {\n+        ast::ExprPath(..) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n         ast::ExprIf(ref cond, ref thn, ref els) => {\n@@ -1275,12 +1275,10 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match def {\n         def::DefFn(did, _) |\n         def::DefStruct(did) | def::DefVariant(_, did, _) |\n-        def::DefStaticMethod(did, def::FromImpl(_)) |\n-        def::DefMethod(did, _, def::FromImpl(_)) => {\n+        def::DefMethod(did, def::FromImpl(_)) => {\n             callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n         }\n-        def::DefStaticMethod(impl_did, def::FromTrait(trait_did)) |\n-        def::DefMethod(impl_did, _, def::FromTrait(trait_did)) => {\n+        def::DefMethod(impl_did, def::FromTrait(trait_did)) => {\n             meth::trans_static_method_callee(ccx, impl_did,\n                                              trait_did, ref_expr.id,\n                                              param_substs)\n@@ -1365,7 +1363,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow()[node_id].clone();\n+                    let def = tcx.def_map.borrow()[node_id].full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id("}, {"sha": "9e50fdb4c48158a21907bc569c46874ae4efc5bd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 377, "deletions": 284, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -48,22 +48,23 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use middle::astconv_util::{ast_ty_to_prim_ty, check_path_args, NO_TPS, NO_REGIONS};\n+use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n-use TypeAndSubsts;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n-use std::rc::Rc;\n use std::iter::{repeat, AdditiveIterator};\n+use std::rc::Rc;\n+use std::slice;\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -245,8 +246,10 @@ pub fn opt_ast_region_to_region<'tcx>(\n pub fn ast_path_substs_for_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n+    param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n-    path: &ast::Path)\n+    item_segment: &ast::PathSegment)\n     -> Substs<'tcx>\n {\n     let tcx = this.tcx();\n@@ -262,27 +265,36 @@ pub fn ast_path_substs_for_ty<'tcx>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n-    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match item_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            convert_angle_bracketed_parameters(this, rscope, path.span, decl_generics, data)\n+            convert_angle_bracketed_parameters(this, rscope, span, decl_generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            span_err!(tcx.sess, path.span, E0214,\n+            span_err!(tcx.sess, span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            convert_parenthesized_parameters(this, rscope, path.span, decl_generics, data)\n+            convert_parenthesized_parameters(this, rscope, span, decl_generics, data)\n         }\n     };\n \n     prohibit_projections(this.tcx(), &assoc_bindings);\n \n     create_substs_for_ast_path(this,\n-                               path.span,\n+                               span,\n+                               param_mode,\n                                decl_generics,\n                                None,\n                                types,\n                                regions)\n }\n \n+#[derive(PartialEq, Eq)]\n+pub enum PathParamMode {\n+    // Any path in a type context.\n+    Explicit,\n+    // The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n fn create_region_substs<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n@@ -330,6 +342,7 @@ fn create_region_substs<'tcx>(\n fn create_substs_for_ast_path<'tcx>(\n     this: &AstConv<'tcx>,\n     span: Span,\n+    param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types_provided: Vec<Ty<'tcx>>,\n@@ -348,13 +361,21 @@ fn create_substs_for_ast_path<'tcx>(\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = types_provided.len();\n     let formal_ty_param_count = ty_param_defs.len();\n     let required_ty_param_count = ty_param_defs.iter()\n                                                .take_while(|x| x.default.is_none())\n                                                .count();\n \n-    let mut type_substs = types_provided;\n+    // Fill with `ty_infer` if no params were specified, as long as\n+    // they were optional (e.g. paths inside expressions).\n+    let mut type_substs = if param_mode == PathParamMode::Optional &&\n+                             types_provided.is_empty() {\n+        (0..formal_ty_param_count).map(|_| this.ty_infer(span)).collect()\n+    } else {\n+        types_provided\n+    };\n+\n+    let supplied_ty_param_count = type_substs.len();\n     check_type_argument_count(this.tcx(), span, supplied_ty_param_count,\n                               required_ty_param_count, formal_ty_param_count);\n \n@@ -414,7 +435,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    return substs;\n+    substs\n }\n \n struct ConvertedBinding<'tcx> {\n@@ -574,9 +595,9 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     // lifetimes. Oh well, not there yet.\n     let shifted_rscope = ShiftedRscope::new(rscope);\n \n-    let trait_ref =\n-        instantiate_trait_ref(this, &shifted_rscope, &ast_trait_ref.trait_ref,\n-                              self_ty, Some(&mut projections));\n+    let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n+                                          &ast_trait_ref.trait_ref,\n+                                          None, self_ty, Some(&mut projections));\n \n     for projection in projections {\n         poly_projections.push(ty::Binder(projection));\n@@ -594,35 +615,42 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n pub fn instantiate_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n-    ast_trait_ref: &ast::TraitRef,\n+    trait_ref: &ast::TraitRef,\n+    impl_id: Option<ast::NodeId>,\n     self_ty: Option<Ty<'tcx>>,\n     projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n-        def::DefaultImpl(trait_def_id) => {\n+    let path = &trait_ref.path;\n+    match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n+        def::DefTrait(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n+                                                  path.span,\n+                                                  PathParamMode::Explicit,\n                                                   trait_def_id,\n                                                   self_ty,\n-                                                  &ast_trait_ref.path,\n+                                                  path.segments.last().unwrap(),\n                                                   projections);\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id, trait_ref.clone());\n+            if let Some(id) = impl_id {\n+                this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n+            }\n             trait_ref\n         }\n         _ => {\n-            span_fatal!(this.tcx().sess, ast_trait_ref.path.span, E0245,\n-                \"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx()));\n+            span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n+                        path.user_string(this.tcx()));\n         }\n     }\n }\n \n fn object_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n+    param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n-    path: &ast::Path,\n+    trait_segment: &ast::PathSegment,\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n@@ -633,9 +661,11 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     let mut tmp = Vec::new();\n     let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n                                                      &shifted_rscope,\n+                                                     span,\n+                                                     param_mode,\n                                                      trait_def_id,\n                                                      None,\n-                                                     path,\n+                                                     trait_segment,\n                                                      Some(&mut tmp)));\n     projections.extend(tmp.into_iter().map(ty::Binder));\n     trait_ref\n@@ -644,48 +674,51 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n fn ast_path_to_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n+    param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    path: &ast::Path,\n+    trait_segment: &ast::PathSegment,\n     mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {:?}\", path);\n+    debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n-    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match trait_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n             if !this.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n-                span_err!(this.tcx().sess, path.span, E0215,\n+                span_err!(this.tcx().sess, span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n-                span_help!(this.tcx().sess, path.span,\n+                span_help!(this.tcx().sess, span,\n                            \"add `#![feature(unboxed_closures)]` to \\\n                             the crate attributes to enable\");\n             }\n \n-            convert_angle_bracketed_parameters(this, rscope, path.span, &trait_def.generics, data)\n+            convert_angle_bracketed_parameters(this, rscope, span, &trait_def.generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n             if !this.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n-                span_err!(this.tcx().sess, path.span, E0216,\n+                span_err!(this.tcx().sess, span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n-                span_help!(this.tcx().sess, path.span,\n+                span_help!(this.tcx().sess, span,\n                            \"add `#![feature(unboxed_closures)]` to \\\n                             the crate attributes to enable\");\n             }\n \n-            convert_parenthesized_parameters(this, rscope, path.span, &trait_def.generics, data)\n+            convert_parenthesized_parameters(this, rscope, span, &trait_def.generics, data)\n         }\n     };\n \n     let substs = create_substs_for_ast_path(this,\n-                                            path.span,\n+                                            span,\n+                                            param_mode,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n@@ -818,78 +851,31 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     })\n }\n \n-pub fn ast_path_to_ty<'tcx>(\n+fn ast_path_to_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n+    param_mode: PathParamMode,\n     did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts<'tcx>\n+    item_segment: &ast::PathSegment)\n+    -> Ty<'tcx>\n {\n-    let tcx = this.tcx();\n     let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n     } = this.get_item_type_scheme(did);\n \n-    let substs = ast_path_substs_for_ty(this,\n-                                        rscope,\n-                                        &generics,\n-                                        path);\n-    let ty = decl_ty.subst(tcx, &substs);\n-    TypeAndSubsts { substs: substs, ty: ty }\n-}\n+    let substs = ast_path_substs_for_ty(this, rscope,\n+                                        span, param_mode,\n+                                        &generics, item_segment);\n \n-/// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n-/// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<'tcx>(\n-        this: &AstConv<'tcx>,\n-        rscope: &RegionScope,\n-        ast_ty: &ast::Ty)\n-        -> Option<Ty<'tcx>> {\n-    match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n-        Some(typ) => return Some(typ),\n-        None => {}\n+    // FIXME(#12938): This is a hack until we have full support for DST.\n+    if Some(did) == this.tcx().lang_items.owned_box() {\n+        assert_eq!(substs.types.len(TypeSpace), 1);\n+        return ty::mk_uniq(this.tcx(), *substs.types.get(TypeSpace, 0));\n     }\n \n-    match ast_ty.node {\n-        ast::TyPath(ref path, id) => {\n-            let a_def = match this.tcx().def_map.borrow().get(&id) {\n-                None => {\n-                    this.tcx()\n-                        .sess\n-                        .span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())))\n-                }\n-                Some(&d) => d\n-            };\n-\n-            // FIXME(#12938): This is a hack until we have full support for\n-            // DST.\n-            match a_def {\n-                def::DefTy(did, _) |\n-                def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    let ty = ast_path_to_ty(this, rscope, did, path).ty;\n-                    match ty.sty {\n-                        ty::ty_struct(struct_def_id, ref substs) => {\n-                            assert_eq!(struct_def_id, did);\n-                            assert_eq!(substs.types.len(TypeSpace), 1);\n-                            let referent_ty = *substs.types.get(TypeSpace, 0);\n-                            Some(ty::mk_uniq(this.tcx(), referent_ty))\n-                        }\n-                        _ => {\n-                            this.tcx().sess.span_bug(\n-                                path.span,\n-                                &format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx())));\n-                        }\n-                    }\n-                }\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n+    decl_ty.subst(this.tcx(), &substs)\n }\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n@@ -912,14 +898,20 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n      */\n \n     match ty.node {\n-        ast::TyPath(ref path, id) => {\n-            match this.tcx().def_map.borrow().get(&id) {\n-                Some(&def::DefaultImpl(trait_def_id)) => {\n+        ast::TyPath(None, ref path) => {\n+            let def = match this.tcx().def_map.borrow().get(&ty.id) {\n+                Some(&def::PathResolution { base_def, depth: 0, .. }) => Some(base_def),\n+                _ => None\n+            };\n+            match def {\n+                Some(def::DefTrait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n                     let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                   rscope,\n+                                                                  path.span,\n+                                                                  PathParamMode::Explicit,\n                                                                   trait_def_id,\n-                                                                  path,\n+                                                                  path.segments.last().unwrap(),\n                                                                   &mut projection_bounds);\n                     Ok((trait_ref, projection_bounds))\n                 }\n@@ -983,21 +975,40 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n }\n \n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n-                                   ast_ty: &ast::Ty,\n-                                   provenance: def::TyParamProvenance,\n-                                   assoc_name: ast::Name)\n-                                   -> Ty<'tcx>\n+                                   span: Span,\n+                                   ty: Ty<'tcx>,\n+                                   ty_path_def: def::Def,\n+                                   item_segment: &ast::PathSegment)\n+                                   -> (Ty<'tcx>, def::Def)\n {\n     let tcx = this.tcx();\n-    let ty_param_def_id = provenance.def_id();\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n+    let assoc_name = item_segment.identifier.name;\n+\n+    let is_param = match (&ty.sty, ty_path_def) {\n+        (&ty::ty_param(_), def::DefTyParam(..)) |\n+        (&ty::ty_param(_), def::DefSelfTy(_)) => true,\n+        _ => false\n+    };\n+\n+    let ty_param_node_id = if is_param {\n+        ty_path_def.local_node_id()\n+    } else {\n+        span_err!(tcx.sess, span, E0223,\n+                \"ambiguous associated type; specify the type using the syntax \\\n+                `<{} as Trait>::{}`\",\n+                ty.user_string(tcx), token::get_name(assoc_name));\n+        return (tcx.types.err, ty_path_def);\n+    };\n \n     let mut suitable_bounds: Vec<_>;\n     let ty_param_name: ast::Name;\n     { // contain scope of refcell:\n         let ty_param_defs = tcx.ty_param_defs.borrow();\n-        let ty_param_def = &ty_param_defs[ty_param_def_id.node];\n+        let ty_param_def = &ty_param_defs[ty_param_node_id];\n         ty_param_name = ty_param_def.name;\n \n+\n         // FIXME(#20300) -- search where clauses, not bounds\n         suitable_bounds =\n             traits::transitive_bounds(tcx, &ty_param_def.bounds.trait_bounds)\n@@ -1006,29 +1017,54 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        span_err!(tcx.sess, ast_ty.span, E0220,\n+        span_err!(tcx.sess, span, E0220,\n                           \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n-        return this.tcx().types.err;\n+        return (this.tcx().types.err, ty_path_def);\n     }\n \n     if suitable_bounds.len() > 1 {\n-        span_err!(tcx.sess, ast_ty.span, E0221,\n+        span_err!(tcx.sess, span, E0221,\n                           \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n \n         for suitable_bound in &suitable_bounds {\n-            span_note!(this.tcx().sess, ast_ty.span,\n+            span_note!(this.tcx().sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        token::get_name(ty_param_name),\n                        suitable_bound.user_string(this.tcx()));\n         }\n     }\n \n     let suitable_bound = suitable_bounds.pop().unwrap().clone();\n-    return this.projected_ty_from_poly_trait_ref(ast_ty.span, suitable_bound, assoc_name);\n+    let trait_did = suitable_bound.0.def_id;\n+\n+    let ty = this.projected_ty_from_poly_trait_ref(span, suitable_bound, assoc_name);\n+\n+    let item_did = if trait_did.krate == ast::LOCAL_CRATE {\n+        // `ty::trait_items` used below requires information generated\n+        // by type collection, which may be in progress at this point.\n+        match this.tcx().map.expect_item(trait_did.node).node {\n+            ast::ItemTrait(_, _, _, ref trait_items) => {\n+                trait_items.iter().filter_map(|i| {\n+                    if let ast::TypeTraitItem(ref assoc) = *i {\n+                        if assoc.ty_param.ident.name == assoc_name {\n+                            return Some(ast_util::local_def(assoc.ty_param.id));\n+                        }\n+                    }\n+                    None\n+                }).next().expect(\"missing associated type\")\n+            }\n+            _ => unreachable!()\n+        }\n+    } else {\n+        let trait_items = ty::trait_items(this.tcx(), trait_did);\n+        let item = trait_items.iter().find(|i| i.name() == assoc_name);\n+        item.expect(\"missing associated type\").def_id()\n+    };\n+    (ty, def::DefAssociatedTy(trait_did, item_did))\n }\n \n fn trait_defines_associated_type_named(this: &AstConv,\n@@ -1043,31 +1079,43 @@ fn trait_defines_associated_type_named(this: &AstConv,\n \n fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                      rscope: &RegionScope,\n-                     ast_ty: &ast::Ty, // the TyQPath\n-                     qpath: &ast::QPath)\n+                     span: Span,\n+                     param_mode: PathParamMode,\n+                     opt_self_ty: Option<Ty<'tcx>>,\n+                     trait_def_id: ast::DefId,\n+                     trait_segment: &ast::PathSegment,\n+                     item_segment: &ast::PathSegment)\n                      -> Ty<'tcx>\n {\n-    debug!(\"qpath_to_ty(ast_ty={})\",\n-           ast_ty.repr(this.tcx()));\n+    let tcx = this.tcx();\n \n-    let self_type = ast_ty_to_ty(this, rscope, &*qpath.self_type);\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n+\n+    let self_ty = if let Some(ty) = opt_self_ty {\n+        ty\n+    } else {\n+        let path_str = ty::item_path_str(tcx, trait_def_id);\n+        span_err!(tcx.sess, span, E0223,\n+                  \"ambiguous associated type; specify the type using the syntax \\\n+                   `<Type as {}>::{}`\",\n+                   path_str, &token::get_ident(item_segment.identifier));\n+        return tcx.types.err;\n+    };\n \n-    debug!(\"qpath_to_ty: self_type={}\", self_type.repr(this.tcx()));\n+    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref = instantiate_trait_ref(this,\n+    let trait_ref = ast_path_to_trait_ref(this,\n                                           rscope,\n-                                          &*qpath.trait_ref,\n-                                          Some(self_type),\n+                                          span,\n+                                          param_mode,\n+                                          trait_def_id,\n+                                          Some(self_ty),\n+                                          trait_segment,\n                                           None);\n \n-    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n+    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n \n-    // `<T as Trait>::U<V>` shouldn't parse right now.\n-    assert!(qpath.item_path.parameters.is_empty());\n-\n-    return this.projected_ty(ast_ty.span,\n-                             trait_ref,\n-                             qpath.item_path.identifier.name);\n+    this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n \n /// Convert a type supplied as value for a type argument from AST into our\n@@ -1103,6 +1151,96 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n+pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                                        rscope: &RegionScope,\n+                                        span: Span,\n+                                        param_mode: PathParamMode,\n+                                        def: &mut def::Def,\n+                                        opt_self_ty: Option<Ty<'tcx>>,\n+                                        segments: &[ast::PathSegment],\n+                                        assoc_segments: &[ast::PathSegment])\n+                                        -> Ty<'tcx> {\n+    let tcx = this.tcx();\n+\n+    let base_ty = match *def {\n+        def::DefTrait(trait_def_id) => {\n+            // N.B. this case overlaps somewhat with\n+            // TyObjectSum, see that fn for details\n+            let mut projection_bounds = Vec::new();\n+\n+            let trait_ref = object_path_to_poly_trait_ref(this,\n+                                                          rscope,\n+                                                          span,\n+                                                          param_mode,\n+                                                          trait_def_id,\n+                                                          segments.last().unwrap(),\n+                                                          &mut projection_bounds);\n+\n+            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            trait_ref_to_object_type(this, rscope, span, trait_ref,\n+                                     projection_bounds, &[])\n+        }\n+        def::DefTy(did, _) | def::DefStruct(did) => {\n+            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            ast_path_to_ty(this, rscope, span,\n+                           param_mode, did,\n+                           segments.last().unwrap())\n+        }\n+        def::DefTyParam(space, index, _, name) => {\n+            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            ty::mk_param(tcx, space, index, name)\n+        }\n+        def::DefSelfTy(_) => {\n+            // n.b.: resolve guarantees that the this type only appears in a\n+            // trait, which we rely upon in various places when creating\n+            // substs\n+            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            ty::mk_self_type(tcx)\n+        }\n+        def::DefAssociatedTy(trait_did, _) => {\n+            check_path_args(tcx, &segments[..segments.len()-2], NO_TPS | NO_REGIONS);\n+            qpath_to_ty(this, rscope, span, param_mode,\n+                        opt_self_ty, trait_did,\n+                        &segments[segments.len()-2],\n+                        segments.last().unwrap())\n+        }\n+        def::DefMod(id) => {\n+            // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n+            // FIXME(#22519) This part of the resolution logic should be\n+            // avoided entirely for that form, once we stop needed a Def\n+            // for `associated_path_def_to_ty`.\n+            if segments.is_empty() {\n+                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n+            } else {\n+                tcx.sess.span_bug(span,\n+                                  &format!(\"found module name used as a type: {}\",\n+                                           tcx.map.node_to_string(id.node)));\n+            }\n+        }\n+        def::DefPrimTy(prim_ty) => {\n+            prim_ty_to_ty(tcx, segments, prim_ty)\n+        }\n+        _ => {\n+            span_fatal!(tcx.sess, span, E0248,\n+                        \"found value name used as a type: {:?}\", *def);\n+        }\n+    };\n+\n+    // If any associated type segments remain, attempt to resolve them.\n+    let mut ty = base_ty;\n+    for segment in assoc_segments {\n+        if ty.sty == ty::ty_err {\n+            break;\n+        }\n+        // This is pretty bad (it will fail except for T::A and Self::A).\n+        let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n+                                                      ty, *def, segment);\n+        ty = a_ty;\n+        *def = a_def;\n+    }\n+    ty\n+}\n+\n /// Parses the programmer's textual representation of a type into our\n /// internal notion of a type.\n pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n@@ -1129,173 +1267,128 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n     ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n     drop(ast_ty_to_ty_cache);\n \n-    let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n-        match ast_ty.node {\n-            ast::TyVec(ref ty) => {\n-                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n-            }\n-            ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[..]) {\n-                    Ok((trait_ref, projection_bounds)) => {\n-                        trait_ref_to_object_type(this,\n-                                                 rscope,\n-                                                 ast_ty.span,\n-                                                 trait_ref,\n-                                                 projection_bounds,\n-                                                 &bounds[..])\n-                    }\n-                    Err(ErrorReported) => {\n-                        this.tcx().types.err\n-                    }\n+    let typ = match ast_ty.node {\n+        ast::TyVec(ref ty) => {\n+            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n+        }\n+        ast::TyObjectSum(ref ty, ref bounds) => {\n+            match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n+                Ok((trait_ref, projection_bounds)) => {\n+                    trait_ref_to_object_type(this,\n+                                             rscope,\n+                                             ast_ty.span,\n+                                             trait_ref,\n+                                             projection_bounds,\n+                                             bounds)\n                 }\n-            }\n-            ast::TyPtr(ref mt) => {\n-                ty::mk_ptr(tcx, ty::mt {\n-                    ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n-                    mutbl: mt.mutbl\n-                })\n-            }\n-            ast::TyRptr(ref region, ref mt) => {\n-                let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-                debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                let rscope1 =\n-                    &ObjectLifetimeDefaultRscope::new(\n-                        rscope,\n-                        Some(ty::ObjectLifetimeDefault::Specific(r)));\n-                let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n-                ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n-            }\n-            ast::TyTup(ref fields) => {\n-                let flds = fields.iter()\n-                                 .map(|t| ast_ty_to_ty(this, rscope, &**t))\n-                                 .collect();\n-                ty::mk_tup(tcx, flds)\n-            }\n-            ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n-            ast::TyBareFn(ref bf) => {\n-                if bf.decl.variadic && bf.abi != abi::C {\n-                    span_err!(tcx.sess, ast_ty.span, E0222,\n-                                      \"variadic function must have C calling convention\");\n+                Err(ErrorReported) => {\n+                    this.tcx().types.err\n                 }\n-                let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n-                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n-            ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n+        }\n+        ast::TyPtr(ref mt) => {\n+            ty::mk_ptr(tcx, ty::mt {\n+                ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n+                mutbl: mt.mutbl\n+            })\n+        }\n+        ast::TyRptr(ref region, ref mt) => {\n+            let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+            debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n+            let rscope1 =\n+                &ObjectLifetimeDefaultRscope::new(\n+                    rscope,\n+                    Some(ty::ObjectLifetimeDefault::Specific(r)));\n+            let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n+            ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n+        }\n+        ast::TyTup(ref fields) => {\n+            let flds = fields.iter()\n+                             .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+                             .collect();\n+            ty::mk_tup(tcx, flds)\n+        }\n+        ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n+        ast::TyBareFn(ref bf) => {\n+            if bf.decl.variadic && bf.abi != abi::C {\n+                span_err!(tcx.sess, ast_ty.span, E0222,\n+                          \"variadic function must have C calling convention\");\n             }\n-            ast::TyPath(ref path, id) => {\n-                let a_def = match tcx.def_map.borrow().get(&id) {\n-                    None => {\n-                        tcx.sess\n-                           .span_bug(ast_ty.span,\n-                                     &format!(\"unbound path {}\",\n-                                             path.repr(tcx)))\n-                    }\n-                    Some(&d) => d\n-                };\n-                match a_def {\n-                    def::DefaultImpl(trait_def_id) => {\n-                        // N.B. this case overlaps somewhat with\n-                        // TyObjectSum, see that fn for details\n-                        let mut projection_bounds = Vec::new();\n-\n-                        let trait_ref = object_path_to_poly_trait_ref(this,\n-                                                                      rscope,\n-                                                                      trait_def_id,\n-                                                                      path,\n-                                                                      &mut projection_bounds);\n-\n-                        trait_ref_to_object_type(this, rscope, path.span,\n-                                                 trait_ref, projection_bounds, &[])\n-                    }\n-                    def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n-                    }\n-                    def::DefTyParam(space, index, _, name) => {\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_param(tcx, space, index, name)\n-                    }\n-                    def::DefSelfTy(_) => {\n-                        // n.b.: resolve guarantees that the this type only appears in a\n-                        // trait, which we rely upon in various places when creating\n-                        // substs\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_self_type(tcx)\n-                    }\n-                    def::DefMod(id) => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0247,\n-                            \"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node));\n-                    }\n-                    def::DefPrimTy(_) => {\n-                        panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n-                    }\n-                    def::DefAssociatedTy(trait_type_id) => {\n-                        let path_str = tcx.map.path_to_string(\n-                            tcx.map.get_parent(trait_type_id.node));\n-                        span_err!(tcx.sess, ast_ty.span, E0223,\n-                                          \"ambiguous associated \\\n-                                                   type; specify the type \\\n-                                                   using the syntax `<Type \\\n-                                                   as {}>::{}`\",\n-                                                  path_str,\n-                                                  &token::get_ident(\n-                                                      path.segments\n-                                                          .last()\n-                                                          .unwrap()\n-                                                          .identifier));\n-                        this.tcx().types.err\n-                    }\n-                    def::DefAssociatedPath(provenance, assoc_ident) => {\n-                        associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n-                    }\n-                    _ => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0248,\n-                                            \"found value name used \\\n-                                                     as a type: {:?}\",\n-                                                    a_def);\n-                    }\n+            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n+            ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n+        }\n+        ast::TyPolyTraitRef(ref bounds) => {\n+            conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n+        }\n+        ast::TyPath(ref maybe_qself, ref path) => {\n+            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n+                d\n+            } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n+                // Create some fake resolution that can't possibly be a type.\n+                def::PathResolution {\n+                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n                 }\n+            } else {\n+                tcx.sess.span_bug(ast_ty.span,\n+                                  &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n+            };\n+            let mut def = path_res.base_def;\n+            let base_ty_end = path.segments.len() - path_res.depth;\n+            let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n+                ast_ty_to_ty(this, rscope, &qself.ty)\n+            });\n+            let ty = finish_resolving_def_to_ty(this, rscope, ast_ty.span,\n+                                                PathParamMode::Explicit, &mut def,\n+                                                opt_self_ty,\n+                                                &path.segments[..base_ty_end],\n+                                                &path.segments[base_ty_end..]);\n+\n+            if path_res.depth != 0 && ty.sty != ty::ty_err {\n+                // Write back the new resolution.\n+                tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n+                    base_def: def,\n+                    last_private: path_res.last_private,\n+                    depth: 0\n+                });\n             }\n-            ast::TyQPath(ref qpath) => {\n-                qpath_to_ty(this, rscope, ast_ty, &**qpath)\n-            }\n-            ast::TyFixedLengthVec(ref ty, ref e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n-                    Ok(ref r) => {\n-                        match *r {\n-                            const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                           Some(i as uint)),\n-                            const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                           Some(i as uint)),\n-                            _ => {\n-                                span_fatal!(tcx.sess, ast_ty.span, E0249,\n-                                            \"expected constant expr for array length\");\n-                            }\n+\n+            ty\n+        }\n+        ast::TyFixedLengthVec(ref ty, ref e) => {\n+            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n+                Ok(r) => {\n+                    match r {\n+                        const_eval::const_int(i) =>\n+                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n+                                        Some(i as uint)),\n+                        const_eval::const_uint(i) =>\n+                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n+                                        Some(i as uint)),\n+                        _ => {\n+                            span_fatal!(tcx.sess, ast_ty.span, E0249,\n+                                        \"expected constant expr for array length\");\n                         }\n                     }\n-                    Err(ref r) => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0250,\n-                            \"expected constant expr for array \\\n-                                     length: {}\",\n-                                    *r);\n-                    }\n                 }\n-            }\n-            ast::TyTypeof(ref _e) => {\n-                tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n-            }\n-            ast::TyInfer => {\n-                // TyInfer also appears as the type of arguments or return\n-                // values in a ExprClosure, or as\n-                // the type of local variables. Both of these cases are\n-                // handled specially and will not descend into this routine.\n-                this.ty_infer(ast_ty.span)\n+                Err(r) => {\n+                    span_fatal!(tcx.sess, ast_ty.span, E0250,\n+                                \"expected constant expr for array length: {}\", r);\n+                }\n             }\n         }\n-    });\n+        ast::TyTypeof(ref _e) => {\n+            tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n+        }\n+        ast::TyInfer => {\n+            // TyInfer also appears as the type of arguments or return\n+            // values in a ExprClosure, or as\n+            // the type of local variables. Both of these cases are\n+            // handled specially and will not descend into this routine.\n+            this.ty_infer(ast_ty.span)\n+        }\n+    };\n \n     tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;\n@@ -1803,8 +1896,8 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n-                match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n-                    def::DefaultImpl(trait_did) => {\n+                match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n+                    def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some"}, {"sha": "dd2ab6c6b13ca5d5ee273eb59080b04edc962333", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -103,7 +103,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n+            let const_did = tcx.def_map.borrow()[pat.id].def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n@@ -433,9 +433,9 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].clone();\n+    let def = tcx.def_map.borrow()[pat.id].full_def();\n     let (enum_def_id, variant_def_id) = match def {\n-        def::DefaultImpl(_) => {\n+        def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0168,\n                 \"use of trait `{}` in a struct pattern\", name);\n@@ -470,7 +470,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     };\n \n     instantiate_path(pcx.fcx,\n-                     path,\n+                     &path.segments,\n                      ty::lookup_item_type(tcx, enum_def_id),\n                      &ty::lookup_predicates(tcx, enum_def_id),\n                      None,\n@@ -502,7 +502,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].clone();\n+    let def = tcx.def_map.borrow()[pat.id].full_def();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -517,7 +517,9 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_scheme, &ctor_predicates, None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, &path.segments,\n+                     path_scheme, &ctor_predicates,\n+                     None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "7ef2db2c28d883f59c4f36a2fd34120aad269704", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -14,6 +14,8 @@ use astconv::AstConv;\n use check::{FnCtxt};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n+use middle::def;\n+use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::*;\n@@ -66,7 +68,8 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         call_expr_id: ast::NodeId)\n                         -> bool\n {\n-    match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n+    let mode = probe::Mode::MethodCall;\n+    match probe::probe(fcx, span, mode, method_name, self_ty, call_expr_id) {\n         Ok(..) => true,\n         Err(NoMatch(..)) => false,\n         Err(Ambiguity(..)) => true,\n@@ -103,8 +106,9 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n+    let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n-    let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n+    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n@@ -301,6 +305,29 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n+pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              method_name: ast::Name,\n+                              self_ty: Ty<'tcx>,\n+                              expr_id: ast::NodeId)\n+                              -> Result<(def::Def, LastPrivate), MethodError>\n+{\n+    let mode = probe::Mode::Path;\n+    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n+    let def_id = pick.method_ty.def_id;\n+    let mut lp = LastMod(AllPublic);\n+    let provenance = match pick.kind {\n+        probe::InherentImplPick(impl_def_id) => {\n+            if pick.method_ty.vis != ast::Public {\n+                lp = LastMod(DependsOn(def_id));\n+            }\n+            def::FromImpl(impl_def_id)\n+        }\n+        _ => def::FromTrait(pick.method_ty.container.id())\n+    };\n+    Ok((def::DefMethod(def_id, provenance), lp))\n+}\n+\n \n /// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n /// index (or `None`, if no such method)."}, {"sha": "f24da78bc7d3974ea304f5c8f38f9d1f80a237ec", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 81, "deletions": 26, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -37,6 +37,7 @@ pub use self::PickKind::*;\n struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n+    mode: Mode,\n     method_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n@@ -108,17 +109,30 @@ pub enum PickAdjustment {\n     AutoRef(ast::Mutability, Box<PickAdjustment>),\n }\n \n+#[derive(PartialEq, Eq, Copy)]\n+pub enum Mode {\n+    // An expression of the form `receiver.method_name(...)`.\n+    // Autoderefs are performed on `receiver`, lookup is done based on the\n+    // `self` argument  of the method, and static methods aren't considered.\n+    MethodCall,\n+    // An expression of the form `Type::method` or `<T>::method`.\n+    // No autoderefs are performed, lookup is done based on the type each\n+    // implementation is for, and static methods are included.\n+    Path\n+}\n+\n pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        span: Span,\n+                       mode: Mode,\n                        method_name: ast::Name,\n                        self_ty: Ty<'tcx>,\n-                       call_expr_id: ast::NodeId)\n+                       scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, method_name={}, call_expr_id={})\",\n+    debug!(\"probe(self_ty={}, method_name={}, scope_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n            method_name,\n-           call_expr_id);\n+           scope_expr_id);\n \n     // FIXME(#18741) -- right now, creating the steps involves evaluating the\n     // `*` operator, which registers obligations that then escape into\n@@ -127,9 +141,16 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // it ride, although it's really not great, and in fact could I\n     // think cause spurious errors. Really though this part should\n     // take place in the `fcx.infcx().probe` below.\n-    let steps = match create_steps(fcx, span, self_ty) {\n-        Some(steps) => steps,\n-        None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+    let steps = if mode == Mode::MethodCall {\n+        match create_steps(fcx, span, self_ty) {\n+            Some(steps) => steps,\n+            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+        }\n+    } else {\n+        vec![CandidateStep {\n+            self_ty: self_ty,\n+            adjustment: AutoDeref(0)\n+        }]\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -153,12 +174,15 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n-    let mut dummy = Some((steps, opt_simplified_steps)); // FIXME(#18101) need once closures\n     fcx.infcx().probe(|_| {\n-        let (steps, opt_simplified_steps) = dummy.take().unwrap();\n-        let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n+        let mut probe_cx = ProbeContext::new(fcx,\n+                                             span,\n+                                             mode,\n+                                             method_name,\n+                                             steps,\n+                                             opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n-        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id));\n+        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id));\n         probe_cx.pick()\n     })\n }\n@@ -198,6 +222,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n+           mode: Mode,\n            method_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n@@ -206,6 +231,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         ProbeContext {\n             fcx: fcx,\n             span: span,\n+            mode: mode,\n             method_name: method_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n@@ -255,6 +281,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::ty_closure(did, _, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n+            ty::ty_uniq(_) => {\n+                if let Some(box_did) = self.tcx().lang_items.owned_box() {\n+                    self.assemble_inherent_impl_candidates_for_type(box_did);\n+                }\n+            }\n             ty::ty_param(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n@@ -292,11 +323,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        let impl_substs = self.impl_substs(impl_def_id);\n+        let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+        let impl_ty = self.fcx.instantiate_type_scheme(self.span, &impl_substs, &impl_ty);\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n-            self.xform_self_ty(&method, &impl_substs);\n+            self.xform_self_ty(&method, impl_ty, &impl_substs);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n@@ -330,7 +362,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                           new_trait_ref.def_id,\n                                                           method_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs);\n+            let xform_self_ty = this.xform_self_ty(&m,\n+                                                   new_trait_ref.self_ty(),\n+                                                   new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -373,7 +407,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m, trait_ref.substs);\n+                this.xform_self_ty(&m,\n+                                   trait_ref.self_ty(),\n+                                   trait_ref.substs);\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n@@ -540,7 +576,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let impl_substs = self.impl_substs(impl_def_id);\n+            let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n \n             debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n \n@@ -553,7 +589,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method, impl_trait_ref.substs);\n+                self.xform_self_ty(&method,\n+                                   impl_trait_ref.self_ty(),\n+                                   impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n@@ -630,7 +668,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n \n-            let xform_self_ty = self.xform_self_ty(&method_ty, &substs);\n+            let xform_self_ty = self.xform_self_ty(&method_ty,\n+                                                   step.self_ty,\n+                                                   &substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n@@ -684,7 +724,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        bound.repr(self.tcx()));\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&method, bound.substs);\n+                    let xform_self_ty = self.xform_self_ty(&method,\n+                                                           bound.self_ty(),\n+                                                           bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n                            bound.repr(self.tcx()),\n@@ -714,7 +756,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs);\n+            let xform_self_ty = self.xform_self_ty(&method_ty,\n+                                                   bound.self_ty(),\n+                                                   bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n                    bound.repr(self.tcx()),\n@@ -1023,7 +1067,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // \"fast track\" -- check for usage of sugar\n         match method.explicit_self {\n             ty::StaticExplicitSelfCategory => {\n-                // fallthrough\n+                if self.mode == Mode::Path {\n+                    return true;\n+                }\n             }\n             ty::ByValueExplicitSelfCategory |\n             ty::ByReferenceExplicitSelfCategory(..) |\n@@ -1047,11 +1093,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn xform_self_ty(&self,\n                      method: &Rc<ty::Method<'tcx>>,\n+                     impl_ty: Ty<'tcx>,\n                      substs: &subst::Substs<'tcx>)\n                      -> Ty<'tcx>\n     {\n-        debug!(\"xform_self_ty(self_ty={}, substs={})\",\n-               method.fty.sig.0.inputs[0].repr(self.tcx()),\n+        debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n+               impl_ty.repr(self.tcx()),\n+               method.fty.sig.0.inputs.get(0).repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n         assert!(!substs.has_escaping_regions());\n@@ -1063,6 +1111,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // if there are any.\n         assert_eq!(substs.types.len(subst::FnSpace), 0);\n         assert_eq!(substs.regions().len(subst::FnSpace), 0);\n+\n+        if self.mode == Mode::Path {\n+            return impl_ty;\n+        }\n+\n         let placeholder;\n         let mut substs = substs;\n         if\n@@ -1094,9 +1147,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         xform_self_ty\n     }\n \n-    fn impl_substs(&self,\n-                   impl_def_id: ast::DefId)\n-                   -> subst::Substs<'tcx>\n+    /// Get the type of an impl and generate substitutions with placeholders.\n+    fn impl_ty_and_substs(&self,\n+                          impl_def_id: ast::DefId)\n+                          -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n         let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n \n@@ -1108,7 +1162,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             impl_pty.generics.regions.map(\n                 |_| ty::ReStatic); // see erase_late_bound_regions() for an expl of why 'static\n \n-        subst::Substs::new(type_vars, region_placeholders)\n+        let substs = subst::Substs::new(type_vars, region_placeholders);\n+        (impl_pty.ty, substs)\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "9832fe1cb6eacd35ebf8ac3723829c28a68a129b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -33,7 +33,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n                               method_name: ast::Name,\n-                              callee_expr: &ast::Expr,\n+                              rcvr_expr: Option<&ast::Expr>,\n                               error: MethodError)\n {\n     // avoid suggestions when we don't know what's going on.\n@@ -46,16 +46,6 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let cx = fcx.tcx();\n             let method_ustring = method_name.user_string(cx);\n \n-            // True if the type is a struct and contains a field with\n-            // the same name as the not-found method\n-            let is_field = match rcvr_ty.sty {\n-                ty::ty_struct(did, _) =>\n-                    ty::lookup_struct_fields(cx, did)\n-                        .iter()\n-                        .any(|f| f.name.user_string(cx) == method_ustring),\n-                _ => false\n-            };\n-\n             fcx.type_error_message(\n                 span,\n                 |actual| {\n@@ -68,10 +58,13 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the method has the name of a field, give a help note\n-            if is_field {\n-                cx.sess.span_note(span,\n-                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring));\n+            if let (&ty::ty_struct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n+                let fields = ty::lookup_struct_fields(cx, did);\n+                if fields.iter().any(|f| f.name == method_name) {\n+                    cx.sess.span_note(span,\n+                        &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                                 function stored in the `{0}` field\", method_ustring));\n+                }\n             }\n \n             if static_sources.len() > 0 {\n@@ -82,7 +75,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 report_candidates(fcx, span, method_name, static_sources);\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, method_name, out_of_scope_traits)\n+            suggest_traits_to_import(fcx, span, rcvr_ty, method_name,\n+                                     rcvr_expr, out_of_scope_traits)\n         }\n \n         MethodError::Ambiguity(sources) => {\n@@ -93,15 +87,18 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         MethodError::ClosureAmbiguity(trait_def_id) => {\n-            fcx.sess().span_err(\n-                span,\n-                &*format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n-                           invoked on this closure as we have not yet inferred what \\\n-                           kind of closure it is; use overloaded call notation instead \\\n-                           (e.g., `{}()`)\",\n-                          method_name.user_string(fcx.tcx()),\n-                          ty::item_path_str(fcx.tcx(), trait_def_id),\n-                          pprust::expr_to_string(callee_expr)));\n+            let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n+                               invoked on this closure as we have not yet inferred what \\\n+                               kind of closure it is\",\n+                               method_name.user_string(fcx.tcx()),\n+                               ty::item_path_str(fcx.tcx(), trait_def_id));\n+            let msg = if let Some(callee) = rcvr_expr {\n+                format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n+                        msg, pprust::expr_to_string(callee))\n+            } else {\n+                msg\n+            };\n+            fcx.sess().span_err(span, &msg);\n         }\n     }\n \n@@ -156,6 +153,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       rcvr_ty: Ty<'tcx>,\n                                       method_name: ast::Name,\n+                                      rcvr_expr: Option<&ast::Expr>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n@@ -184,7 +182,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         return\n     }\n \n-    let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty);\n+    let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty, rcvr_expr);\n \n     // there's no implemented traits, so lets suggest some traits to\n     // implement, by finding ones that have the method name, and are\n@@ -233,33 +231,39 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// autoderefs of `rcvr_ty`.\n fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   span: Span,\n-                                  rcvr_ty: Ty<'tcx>) -> bool {\n-    check::autoderef(fcx, span, rcvr_ty, None,\n-                     check::UnresolvedTypeAction::Ignore, check::NoPreference,\n-                     |&: ty, _| {\n-        let is_local = match ty.sty {\n+                                  rcvr_ty: Ty<'tcx>,\n+                                  rcvr_expr: Option<&ast::Expr>) -> bool {\n+    fn is_local(ty: Ty) -> bool {\n+        match ty.sty {\n             ty::ty_enum(did, _) | ty::ty_struct(did, _) => ast_util::is_local(did),\n \n             ty::ty_trait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n \n             ty::ty_param(_) => true,\n \n-            // the user cannot implement traits for unboxed closures, so\n-            // there's no point suggesting anything at all, local or not.\n-            ty::ty_closure(..) => return Some(false),\n-\n             // everything else (primitive types etc.) is effectively\n             // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n             // the noise from these sort of types is usually just really\n             // annoying, rather than any sort of help).\n             _ => false\n-        };\n-        if is_local {\n-            Some(true)\n+        }\n+    }\n+\n+    // This occurs for UFCS desugaring of `T::method`, where there is no\n+    // receiver expression for the method call, and thus no autoderef.\n+    if rcvr_expr.is_none() {\n+        return is_local(fcx.resolve_type_vars_if_possible(rcvr_ty));\n+    }\n+\n+    check::autoderef(fcx, span, rcvr_ty, None,\n+                     check::UnresolvedTypeAction::Ignore, check::NoPreference,\n+                     |ty, _| {\n+        if is_local(ty) {\n+            Some(())\n         } else {\n             None\n         }\n-    }).2.unwrap_or(false)\n+    }).2.is_some()\n }\n \n #[derive(Copy)]\n@@ -330,7 +334,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                                cstore: &cstore::CStore,\n                                dl: decoder::DefLike) {\n             match dl {\n-                decoder::DlDef(def::DefaultImpl(did)) => {\n+                decoder::DlDef(def::DefTrait(did)) => {\n                     traits.push(TraitInfo::new(did));\n                 }\n                 decoder::DlDef(def::DefMod(did)) => {"}, {"sha": "d7a11b8a5152f933e4e6b05149f85b3838a8c111", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 145, "deletions": 113, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -82,14 +82,16 @@ pub use self::compare_method::compare_impl_method;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv};\n+use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n+use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::{const_eval, def};\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n+use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n@@ -101,7 +103,7 @@ use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n-use {CrateCtxt, lookup_def_ccx, require_same_types};\n+use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n@@ -1598,23 +1600,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty::TypeScheme { generics, ty: decl_ty } =\n             ty::lookup_item_type(tcx, did);\n \n-        let wants_params =\n-            generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n-\n-        let needs_defaults =\n-            wants_params &&\n-            path.segments.iter().all(|s| s.parameters.is_empty());\n-\n-        let substs = if needs_defaults {\n-            let tps =\n-                self.infcx().next_ty_vars(generics.types.len(TypeSpace));\n-            let rps =\n-                self.infcx().region_vars_for_defs(path.span,\n-                                                  generics.regions.get_slice(TypeSpace));\n-            Substs::new_type(tps, rps)\n-        } else {\n-            astconv::ast_path_substs_for_ty(self, self, &generics, path)\n-        };\n+        let substs = astconv::ast_path_substs_for_ty(self, self,\n+                                                     path.span,\n+                                                     PathParamMode::Optional,\n+                                                     &generics,\n+                                                     path.segments.last().unwrap());\n \n         let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n \n@@ -2698,7 +2688,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t,\n-                                     method_name.node.name, rcvr, error);\n+                                     method_name.node.name, Some(rcvr), error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }\n@@ -3408,10 +3398,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let mut checked = false;\n           opt_place.as_ref().map(|place| match place.node {\n-              ast::ExprPath(ref path) => {\n+              ast::ExprPath(None, ref path) => {\n                   // FIXME(pcwalton): For now we hardcode the two permissible\n                   // places: the exchange heap and the managed heap.\n-                  let definition = lookup_def(fcx, path.span, place.id);\n+                  let definition = lookup_full_def(tcx, path.span, place.id);\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n                   if tcx.lang_items.exchange_heap() == Some(def_id) {\n@@ -3601,26 +3591,65 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprPath(ref path) => {\n-          let defn = lookup_def(fcx, path.span, id);\n-          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, path, scheme, &predicates, None, defn, expr.span, expr.id);\n+      ast::ExprPath(ref maybe_qself, ref path) => {\n+          let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n+              fcx.to_ty(&qself.ty)\n+          });\n \n-          // We always require that the type provided as the value for\n-          // a type parameter outlives the moment of instantiation.\n-          constrain_path_type_parameters(fcx, expr);\n-      }\n-      ast::ExprQPath(ref qpath) => {\n-          // Require explicit type params for the trait.\n-          let self_ty = fcx.to_ty(&*qpath.self_type);\n-          astconv::instantiate_trait_ref(fcx, fcx, &*qpath.trait_ref, Some(self_ty), None);\n-\n-          let defn = lookup_def(fcx, expr.span, id);\n-          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          let mut path = qpath.trait_ref.path.clone();\n-          path.segments.push(qpath.item_path.clone());\n-          instantiate_path(fcx, &path, scheme, &predicates, Some(self_ty),\n-                           defn, expr.span, expr.id);\n+          let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n+              d\n+          } else if let Some(ast::QSelf { position: 0, .. }) = *maybe_qself {\n+                // Create some fake resolution that can't possibly be a type.\n+                def::PathResolution {\n+                    base_def: def::DefMod(local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n+            } else {\n+              tcx.sess.span_bug(expr.span,\n+                                &format!(\"unbound path {}\", expr.repr(tcx))[])\n+          };\n+\n+          let mut def = path_res.base_def;\n+          if path_res.depth == 0 {\n+              let (scheme, predicates) =\n+                  type_scheme_and_predicates_for_def(fcx, expr.span, def);\n+              instantiate_path(fcx, &path.segments,\n+                               scheme, &predicates,\n+                               opt_self_ty, def, expr.span, id);\n+          } else {\n+              let ty_segments = path.segments.init();\n+              let base_ty_end = path.segments.len() - path_res.depth;\n+              let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, expr.span,\n+                                                           PathParamMode::Optional,\n+                                                           &mut def,\n+                                                           opt_self_ty,\n+                                                           &ty_segments[..base_ty_end],\n+                                                           &ty_segments[base_ty_end..]);\n+              let method_segment = path.segments.last().unwrap();\n+              let method_name = method_segment.identifier.name;\n+              match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n+                  Ok((def, lp)) => {\n+                      // Write back the new resolution.\n+                      tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n+                          base_def: def,\n+                          last_private: path_res.last_private.or(lp),\n+                          depth: 0\n+                      });\n+\n+                      let (scheme, predicates) =\n+                          type_scheme_and_predicates_for_def(fcx, expr.span, def);\n+                      instantiate_path(fcx, slice::ref_slice(method_segment),\n+                                       scheme, &predicates,\n+                                       Some(ty), def, expr.span, id);\n+                  }\n+                  Err(error) => {\n+                      method::report_error(fcx, expr.span, ty,\n+                                           method_name, None, error);\n+                      fcx.write_error(id);\n+                  }\n+              }\n+          }\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -3855,14 +3884,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().get(&id).cloned();\n+        let def = lookup_full_def(tcx, path.span, id);\n         let struct_id = match def {\n-            Some(def::DefVariant(enum_id, variant_id, true)) => {\n+            def::DefVariant(enum_id, variant_id, true) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, &fields[..]);\n                 enum_id\n             }\n-            Some(def::DefaultImpl(def_id)) => {\n+            def::DefTrait(def_id) => {\n                 span_err!(tcx.sess, path.span, E0159,\n                     \"use of trait `{}` as a struct constructor\",\n                     pprust::path_to_string(path));\n@@ -3872,7 +3901,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                              base_expr);\n                 def_id\n             },\n-            Some(def) => {\n+            def => {\n                 // Verify that this was actually a struct.\n                 let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n                 match typ.ty.sty {\n@@ -3897,10 +3926,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                 def.def_id()\n             }\n-            _ => {\n-                tcx.sess.span_bug(path.span,\n-                                  \"structure constructor wasn't resolved\")\n-            }\n         };\n \n         // Turn the path into a type and verify that that type unifies with\n@@ -4614,10 +4639,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n-    lookup_def_ccx(fcx.ccx, sp, id)\n-}\n-\n // Returns the type parameter count and the type for the given definition.\n fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 sp: Span,\n@@ -4629,22 +4650,20 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n              ty::GenericPredicates::empty())\n         }\n-        def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n+        def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n         def::DefStruct(id) | def::DefConst(id) => {\n             (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n         }\n-        def::DefaultImpl(_) |\n+        def::DefTrait(_) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n-        def::DefAssociatedPath(..) |\n         def::DefPrimTy(_) |\n         def::DefTyParam(..) |\n         def::DefMod(..) |\n         def::DefForeignMod(..) |\n         def::DefUse(..) |\n         def::DefRegion(..) |\n-        def::DefTyParamBinder(..) |\n         def::DefLabel(..) |\n         def::DefSelfTy(..) => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n@@ -4655,15 +4674,15 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  path: &ast::Path,\n+                                  segments: &[ast::PathSegment],\n                                   type_scheme: TypeScheme<'tcx>,\n                                   type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={}, def={}, node_id={}, type_scheme={})\",\n-           path.repr(fcx.tcx()),\n+    debug!(\"instantiate_path(path={:?}, def={}, node_id={}, type_scheme={})\",\n+           segments,\n            def.repr(fcx.tcx()),\n            node_id,\n            type_scheme.repr(fcx.tcx()));\n@@ -4727,49 +4746,53 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // The first step then is to categorize the segments appropriately.\n \n-    assert!(path.segments.len() >= 1);\n+    assert!(segments.len() >= 1);\n+\n+    let mut ufcs_method = None;\n     let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n         def::DefSelfTy(..) |\n         def::DefStruct(..) |\n         def::DefVariant(..) |\n-        def::DefTyParamBinder(..) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n-        def::DefAssociatedPath(..) |\n-        def::DefaultImpl(..) |\n+        def::DefTrait(..) |\n         def::DefPrimTy(..) |\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n-            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n+            segment_spaces = repeat(None).take(segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n         def::DefConst(..) |\n         def::DefStatic(..) => {\n-            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n+            segment_spaces = repeat(None).take(segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n         // Case 3. Reference to a method.\n-        def::DefStaticMethod(_, providence) |\n-        def::DefMethod(_, _, providence) => {\n-            assert!(path.segments.len() >= 2);\n-\n-            match providence {\n+        def::DefMethod(_, provenance) => {\n+            match provenance {\n                 def::FromTrait(trait_did) => {\n                     callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n                 }\n                 def::FromImpl(_) => {}\n             }\n \n-            segment_spaces = repeat(None).take(path.segments.len() - 2).collect();\n-            segment_spaces.push(Some(subst::TypeSpace));\n-            segment_spaces.push(Some(subst::FnSpace));\n+            if segments.len() >= 2 {\n+                segment_spaces = repeat(None).take(segments.len() - 2).collect();\n+                segment_spaces.push(Some(subst::TypeSpace));\n+                segment_spaces.push(Some(subst::FnSpace));\n+            } else {\n+                // `<T>::method` will end up here, and so can `T::method`.\n+                let self_ty = opt_self_ty.expect(\"UFCS sugared method missing Self\");\n+                segment_spaces = vec![Some(subst::FnSpace)];\n+                ufcs_method = Some((provenance, self_ty));\n+            }\n         }\n \n         // Other cases. Various nonsense that really shouldn't show up\n@@ -4782,10 +4805,15 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n-            segment_spaces = repeat(None).take(path.segments.len()).collect();\n+            segment_spaces = repeat(None).take(segments.len()).collect();\n         }\n     }\n-    assert_eq!(segment_spaces.len(), path.segments.len());\n+    assert_eq!(segment_spaces.len(), segments.len());\n+\n+    // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n+    // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n+    // type parameters are not mandatory.\n+    let require_type_space = opt_self_ty.is_some() && ufcs_method.is_none();\n \n     debug!(\"segment_spaces={:?}\", segment_spaces);\n \n@@ -4799,16 +4827,17 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // provided (if any) into their appropriate spaces. We'll also report\n     // errors if type parameters are provided in an inappropriate place.\n     let mut substs = Substs::empty();\n-    for (opt_space, segment) in segment_spaces.iter().zip(path.segments.iter()) {\n+    for (opt_space, segment) in segment_spaces.iter().zip(segments.iter()) {\n         match *opt_space {\n             None => {\n-                report_error_if_segment_contains_type_parameters(fcx, segment);\n+                check_path_args(fcx.tcx(), slice::ref_slice(segment),\n+                                NO_TPS | NO_REGIONS);\n             }\n \n             Some(space) => {\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n-                                                                path.span,\n+                                                                span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n@@ -4817,9 +4846,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n     if let Some(self_ty) = opt_self_ty {\n-        // `<T as Trait>::foo` shouldn't have resolved to a `Self`-less item.\n-        assert_eq!(type_defs.len(subst::SelfSpace), 1);\n-        substs.types.push(subst::SelfSpace, self_ty);\n+        if type_defs.len(subst::SelfSpace) == 1 {\n+            substs.types.push(subst::SelfSpace, self_ty);\n+        }\n     }\n \n     // Now we have to compare the types that the user *actually*\n@@ -4829,7 +4858,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // to add defaults. If the user provided *too many* types, that's\n     // a problem.\n     for &space in &ParamSpace::all() {\n-        adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n+        adjust_type_parameters(fcx, span, space, type_defs,\n+                               require_type_space, &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n         adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n@@ -4852,27 +4882,32 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // the referenced item.\n     let ty_substituted = fcx.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n-    fcx.write_ty(node_id, ty_substituted);\n-    fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n-    return;\n \n-    fn report_error_if_segment_contains_type_parameters(\n-        fcx: &FnCtxt,\n-        segment: &ast::PathSegment)\n-    {\n-        for typ in &segment.parameters.types() {\n-            span_err!(fcx.tcx().sess, typ.span, E0085,\n-                \"type parameters may not appear here\");\n-            break;\n-        }\n+    if let Some((def::FromImpl(impl_def_id), self_ty)) = ufcs_method {\n+        // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n+        // is inherent, there is no `Self` parameter, instead, the impl needs\n+        // type parameters, which we can infer by unifying the provided `Self`\n+        // with the substituted impl type.\n+        let impl_scheme = ty::lookup_item_type(fcx.tcx(), impl_def_id);\n+        assert_eq!(substs.types.len(subst::TypeSpace),\n+                   impl_scheme.generics.types.len(subst::TypeSpace));\n+        assert_eq!(substs.regions().len(subst::TypeSpace),\n+                   impl_scheme.generics.regions.len(subst::TypeSpace));\n \n-        for lifetime in &segment.parameters.lifetimes() {\n-            span_err!(fcx.tcx().sess, lifetime.span, E0086,\n-                \"lifetime parameters may not appear here\");\n-            break;\n+        let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n+        if fcx.mk_subty(false, infer::Misc(span), self_ty, impl_ty).is_err() {\n+            fcx.tcx().sess.span_bug(span,\n+            &format!(\n+                \"instantiate_path: (UFCS) {} was a subtype of {} but now is not?\",\n+                self_ty.repr(fcx.tcx()),\n+                impl_ty.repr(fcx.tcx())));\n         }\n     }\n \n+    fcx.write_ty(node_id, ty_substituted);\n+    fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n+    return;\n+\n     /// Finds the parameters that the user provided and adds them to `substs`. If too many\n     /// parameters are provided, then reports an error and clears the output vector.\n     ///\n@@ -5007,6 +5042,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         span: Span,\n         space: ParamSpace,\n         defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n+        require_type_space: bool,\n         substs: &mut Substs<'tcx>)\n     {\n         let provided_len = substs.types.len(space);\n@@ -5029,9 +5065,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Nothing specified at all: supply inference variables for\n         // everything.\n-        if provided_len == 0 {\n-            substs.types.replace(space,\n-                                 fcx.infcx().next_ty_vars(desired.len()));\n+        if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n+            substs.types.replace(space, fcx.infcx().next_ty_vars(desired.len()));\n             return;\n         }\n \n@@ -5153,18 +5188,15 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n             _ => false\n         }\n     })) ||\n-   // Second: is there a labeled break with label\n-   // <id> nested anywhere inside the loop?\n+    // Second: is there a labeled break with label\n+    // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n-        match e.node {\n-            ast::ExprBreak(Some(_)) => {\n-                match cx.def_map.borrow().get(&e.id) {\n-                    Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n-                    _ => false,\n-                }\n-            }\n-            _ => false\n-        }}))\n+        if let ast::ExprBreak(Some(_)) = e.node {\n+            lookup_full_def(cx, e.span, e.id) == def::DefLabel(id)\n+        } else {\n+            false\n+        }\n+    }))\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "e024526d0016f7756c18baa0e2036f2379b0a213", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -81,8 +81,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemImpl(_, ast::ImplPolarity::Positive, _, _, _, _) => {\n                 self.check_impl(item);\n             }\n-            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(ref tref), _, _) => {\n-                let trait_ref = ty::node_id_to_trait_ref(ccx.tcx, tref.ref_id);\n+            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n+                let trait_ref = ty::impl_id_to_trait_ref(ccx.tcx, item.id);\n                 ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}"}, {"sha": "e89c96b36e1a23887e2b52631945d2a2c99985dd", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -28,8 +28,8 @@ struct ImplsChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v ast::Item) {\n         match item.node {\n-            ast::ItemImpl(_, _, _, Some(ref opt_trait), _, _) => {\n-                let trait_ref = ty::node_id_to_trait_ref(self.tcx, opt_trait.ref_id);\n+            ast::ItemImpl(_, _, _, Some(_), _, _) => {\n+                let trait_ref = ty::impl_id_to_trait_ref(self.tcx, item.id);\n                 if let Some(_) = self.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}"}, {"sha": "1913b55f1d8e69d03da3fc0b368345b055522ed5", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -106,19 +106,9 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n \n         //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n \n-        match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, _) => {\n-                match opt_trait.clone() {\n-                    Some(opt_trait) => {\n-                        self.cc.check_implementation(item, &[opt_trait]);\n-                    }\n-                    None => self.cc.check_implementation(item, &[])\n-                }\n-            }\n-            _ => {\n-                // Nothing to do.\n-            }\n-        };\n+        if let ItemImpl(_, _, _, ref opt_trait, _, _) = item.node {\n+            self.cc.check_implementation(item, opt_trait.as_ref())\n+        }\n \n         visit::walk_item(self, item);\n     }\n@@ -155,9 +145,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.check_implementations_of_copy();\n     }\n \n-    fn check_implementation(&self,\n-                            item: &Item,\n-                            associated_traits: &[TraitRef]) {\n+    fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n         let self_type = ty::lookup_item_type(tcx, impl_did);\n@@ -167,9 +155,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        for associated_trait in associated_traits {\n-            let trait_ref = ty::node_id_to_trait_ref(self.crate_context.tcx,\n-                                                     associated_trait.ref_id);\n+        if opt_trait.is_some() {\n+            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx, item.id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n@@ -191,7 +178,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             Some(base_type_def_id) => {\n                 // FIXME: Gather up default methods?\n-                if associated_traits.len() == 0 {\n+                if opt_trait.is_none() {\n                     self.add_inherent_impl(base_type_def_id, impl_did);\n                 }\n             }\n@@ -289,7 +276,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref trait_refs, _, ref ast_items) => {\n+            ItemImpl(_, _, _, ref opt_trait, _, ref ast_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         ast_items.iter()\n                                  .map(|ast_item| {\n@@ -304,13 +291,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                             }\n                         }).collect();\n \n-                if let Some(ref trait_ref) = *trait_refs {\n-                    let ty_trait_ref = ty::node_id_to_trait_ref(\n-                        self.crate_context.tcx,\n-                        trait_ref.ref_id);\n+                if opt_trait.is_some() {\n+                    let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n+                                                             item.id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     &*ty_trait_ref,\n+                                                     &*trait_ref,\n                                                      &mut items);\n                 }\n "}, {"sha": "95dafccd866bf3369136c8f936b31edf362e7397", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -16,7 +16,6 @@ use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::Span;\n use syntax::visit;\n use util::ppaux::{Repr, UserString};\n \n@@ -30,9 +29,9 @@ struct OrphanChecker<'cx, 'tcx:'cx> {\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n-    fn check_def_id(&self, span: Span, def_id: ast::DefId) {\n+    fn check_def_id(&self, item: &ast::Item, def_id: ast::DefId) {\n         if def_id.krate != ast::LOCAL_CRATE {\n-            span_err!(self.tcx.sess, span, E0116,\n+            span_err!(self.tcx.sess, item.span, E0116,\n                       \"cannot associate methods with a type outside the \\\n                        crate the type is defined in; define and implement \\\n                        a trait or new type instead\");\n@@ -41,7 +40,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &'v ast::Item) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let def_id = ast_util::local_def(item.id);\n         match item.node {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n@@ -52,15 +51,13 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 match self_ty.sty {\n                     ty::ty_enum(def_id, _) |\n                     ty::ty_struct(def_id, _) => {\n-                        self.check_def_id(item.span, def_id);\n+                        self.check_def_id(item, def_id);\n                     }\n                     ty::ty_trait(ref data) => {\n-                        self.check_def_id(item.span, data.principal_def_id());\n+                        self.check_def_id(item, data.principal_def_id());\n                     }\n                     ty::ty_uniq(..) => {\n-                        self.check_def_id(item.span,\n-                                          self.tcx.lang_items.owned_box()\n-                                              .unwrap());\n+                        self.check_def_id(item, self.tcx.lang_items.owned_box().unwrap());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,\n@@ -96,10 +93,10 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n+            ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\", item.repr(self.tcx));\n-                let trait_ref = ty::node_id_to_trait_ref(self.tcx, ast_trait_ref.ref_id);\n+                let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,\n                               \"cannot create default implementations for traits outside the \\"}, {"sha": "bc0c61ad7ad52aed65855a181b271f76097445fe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -649,8 +649,12 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                    &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref = astconv::instantiate_trait_ref(ccx, &ExplicitRscope,\n-                                                           ast_trait_ref, None, None);\n+            let trait_ref = astconv::instantiate_trait_ref(ccx,\n+                                                           &ExplicitRscope,\n+                                                           ast_trait_ref,\n+                                                           Some(it.id),\n+                                                           None,\n+                                                           None);\n \n             ty::record_default_trait_implementation(tcx, trait_ref.def_id, local_def(it.id))\n         }\n@@ -741,6 +745,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                 astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n                                                trait_ref,\n+                                               Some(it.id),\n                                                Some(selfty),\n                                                None);\n             }\n@@ -1682,20 +1687,15 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 index: u32)\n                 -> bool\n     {\n-        match ast_ty.node {\n-            ast::TyPath(_, id) => {\n-                match ccx.tcx.def_map.borrow()[id] {\n-                    def::DefTyParam(s, i, _, _) => {\n-                        space == s && index == i\n-                    }\n-                    _ => {\n-                        false\n-                    }\n-                }\n-            }\n-            _ => {\n+        if let ast::TyPath(None, _) = ast_ty.node {\n+            let path_res = ccx.tcx.def_map.borrow()[ast_ty.id];\n+            if let def::DefTyParam(s, i, _, _) = path_res.base_def {\n+                path_res.depth == 0 && space == s && index == i\n+            } else {\n                 false\n             }\n+        } else {\n+            false\n         }\n     }\n }"}, {"sha": "7b43a9fef06dcd36d604f5b42425fd42b3cecf72", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -80,6 +80,7 @@ register_diagnostics! {\n     E0120,\n     E0121,\n     E0122,\n+    E0123,\n     E0124,\n     E0127,\n     E0128,"}, {"sha": "78dd66c8e7dbbd02e80bc8f197f2d014a2bf990e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -163,20 +163,16 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n }\n-fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n+\n+fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().get(&id) {\n-        Some(x) => x.clone(),\n-        _ => {\n+        Some(x) => x.full_def(),\n+        None => {\n             span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n         }\n     }\n }\n \n-fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n-                   -> def::Def {\n-    lookup_def_tcx(ccx.tcx, sp, id)\n-}\n-\n fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n                                    t1_is_expected: bool,"}, {"sha": "24b9d03400cb32275d92e2ae02683c49e55e0e3c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -46,7 +46,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n         None => return None,\n     };\n     let def = match tcx.def_map.borrow().get(&id) {\n-        Some(def) => *def,\n+        Some(d) => d.full_def(),\n         None => return None,\n     };\n     let did = def.def_id();\n@@ -69,7 +69,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n-        def::DefaultImpl(did) => {\n+        def::DefTrait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(cx, tcx, did))\n         }"}, {"sha": "b88620d577f3766304fb24102bee2d2efee982a9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -1344,8 +1344,6 @@ pub enum Type {\n         typarams: Option<Vec<TyParamBound>>,\n         did: ast::DefId,\n     },\n-    // I have no idea how to usefully use this.\n-    TyParamBinder(ast::NodeId),\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(String),\n@@ -1496,8 +1494,17 @@ impl Clean<Type> for ast::Ty {\n             TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n                                                            e.span.to_src(cx)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(ref p, id) => {\n-                resolve_type(cx, p.clean(cx), id)\n+            TyPath(None, ref p) => {\n+                resolve_type(cx, p.clean(cx), self.id)\n+            }\n+            TyPath(Some(ref qself), ref p) => {\n+                let mut trait_path = p.clone();\n+                trait_path.segments.pop();\n+                Type::QPath {\n+                    name: p.segments.last().unwrap().identifier.clean(cx),\n+                    self_type: box qself.ty.clean(cx),\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n+                }\n             }\n             TyObjectSum(ref lhs, ref bounds) => {\n                 let lhs_ty = lhs.clean(cx);\n@@ -1512,7 +1519,6 @@ impl Clean<Type> for ast::Ty {\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n-            TyQPath(ref qp) => qp.clean(cx),\n             TyPolyTraitRef(ref bounds) => {\n                 PolyTraitRef(bounds.clean(cx))\n             },\n@@ -1624,16 +1630,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     }\n }\n \n-impl Clean<Type> for ast::QPath {\n-    fn clean(&self, cx: &DocContext) -> Type {\n-        Type::QPath {\n-            name: self.item_path.identifier.clean(cx),\n-            self_type: box self.self_type.clean(cx),\n-            trait_: box self.trait_ref.clean(cx)\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes\n@@ -2392,7 +2388,7 @@ fn resolve_type(cx: &DocContext,\n     };\n     debug!(\"searching for {} in defmap\", id);\n     let def = match tcx.def_map.borrow().get(&id) {\n-        Some(&k) => k,\n+        Some(k) => k.full_def(),\n         None => panic!(\"unresolved id not in defmap\")\n     };\n \n@@ -2418,7 +2414,6 @@ fn resolve_type(cx: &DocContext,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n         def::DefTyParam(_, _, _, n) => return Generic(token::get_name(n).to_string()),\n-        def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n     let did = register_def(&*cx, def);\n@@ -2430,7 +2425,7 @@ fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i, false) => (i, TypeTypedef),\n         def::DefTy(i, true) => (i, TypeEnum),\n-        def::DefaultImpl(i) => (i, TypeTrait),\n+        def::DefTrait(i) => (i, TypeTrait),\n         def::DefStruct(i) => (i, TypeStruct),\n         def::DefMod(i) => (i, TypeModule),\n         def::DefStatic(i, _) => (i, TypeStatic),\n@@ -2459,7 +2454,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().get(&id).map(|&def| register_def(cx, def))\n+        tcx.def_map.borrow().get(&id).map(|d| register_def(cx, d.full_def()))\n     })\n }\n "}, {"sha": "03a2d708ee43aa5b742c2efc9c19aacdf4764ecf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -454,9 +454,6 @@ fn tybounds(w: &mut fmt::Formatter,\n impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::TyParamBinder(id) => {\n-                f.write_str(&cache().typarams[ast_util::local_def(id)])\n-            }\n             clean::Generic(ref name) => {\n                 f.write_str(name)\n             }"}, {"sha": "3e998166397bc5deb38e2a30bb6497c0da82e63c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = (*tcx.def_map.borrow())[id].def_id();\n+        let def = tcx.def_map.borrow()[id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "6d6fdffa95095b25c6fd6b5684df59d12d8ae611", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -753,11 +753,10 @@ pub enum Expr_ {\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n-    /// Variable reference, possibly containing `::` and/or\n-    /// type parameters, e.g. foo::bar::<baz>\n-    ExprPath(Path),\n-    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    ExprQPath(P<QPath>),\n+    /// Variable reference, possibly containing `::` and/or type\n+    /// parameters, e.g. foo::bar::<baz>. Optionally \"qualified\",\n+    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    ExprPath(Option<QSelf>, Path),\n \n     ExprAddrOf(Mutability, P<Expr>),\n     ExprBreak(Option<Ident>),\n@@ -778,16 +777,22 @@ pub enum Expr_ {\n     ExprParen(P<Expr>)\n }\n \n-/// A \"qualified path\":\n+/// The explicit Self type in a \"qualified path\". The actual\n+/// path, including the trait and the associated item, is stored\n+/// sepparately. `position` represents the index of the associated\n+/// item qualified with this Self type.\n ///\n-///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n-///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n-///      self_type  trait_name  item_path\n+///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///      ^~~~~     ~~~~~~~~~~~~~~^\n+///      ty        position = 3\n+///\n+///     <Vec<T>>::AssociatedItem\n+///      ^~~~~    ^\n+///      ty       position = 0\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct QPath {\n-    pub self_type: P<Ty>,\n-    pub trait_ref: P<TraitRef>,\n-    pub item_path: PathSegment,\n+pub struct QSelf {\n+    pub ty: P<Ty>,\n+    pub position: usize\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1254,16 +1259,15 @@ pub enum Ty_ {\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(Vec<P<Ty>> ),\n-    /// A path (`module::module::...::Type`) or primitive\n+    /// A path (`module::module::...::Type`), optionally\n+    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n-    TyPath(Path, NodeId),\n+    TyPath(Option<QSelf>, Path),\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     TyPolyTraitRef(TyParamBounds),\n-    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n     /// Unused for now"}, {"sha": "79f0433761da531ec4a01d34401a344ce1efed58", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -134,7 +134,7 @@ pub fn unop_to_string(op: UnOp) -> &'static str {\n }\n \n pub fn is_path(e: P<Expr>) -> bool {\n-    return match e.node { ExprPath(_) => true, _ => false };\n+    match e.node { ExprPath(..) => true, _ => false }\n }\n \n /// Get a string representation of a signed int type, with its value.\n@@ -488,9 +488,6 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n \n     fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n-        if let TyPath(_, id) = typ.node {\n-            self.operation.visit_id(id);\n-        }\n         visit::walk_ty(self, typ)\n     }\n \n@@ -564,13 +561,18 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_trait_item(self, tm);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n         self.operation.visit_id(lifetime.id);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n         self.visit_lifetime_ref(&def.lifetime);\n     }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n+        self.operation.visit_id(trait_ref.ref_id);\n+        visit::walk_trait_ref(self, trait_ref);\n+    }\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,"}, {"sha": "d916651b05617d25cedd8bd6f06867eba885f712", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -41,16 +41,16 @@ pub trait AstBuilder {\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n-             trait_ref: P<ast::TraitRef>,\n-             ident: ast::Ident )\n-        -> P<ast::QPath>;\n+             trait_path: ast::Path,\n+             ident: ast::Ident)\n+             -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n-                trait_ref: P<ast::TraitRef>,\n+                trait_path: ast::Path,\n                 ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n-                bindings: Vec<P<ast::TypeBinding>> )\n-        -> P<ast::QPath>;\n+                bindings: Vec<P<ast::TypeBinding>>)\n+                -> (ast::QSelf, ast::Path);\n \n     // types\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n@@ -114,7 +114,7 @@ pub trait AstBuilder {\n     // expressions\n     fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n-    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr>;\n+    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n@@ -346,40 +346,40 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     /// Constructs a qualified path.\n     ///\n-    /// Constructs a path like `<self_type as trait_ref>::ident`.\n+    /// Constructs a path like `<self_type as trait_path>::ident`.\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n-             trait_ref: P<ast::TraitRef>,\n+             trait_path: ast::Path,\n              ident: ast::Ident)\n-             -> P<ast::QPath> {\n-        self.qpath_all(self_type, trait_ref, ident, Vec::new(), Vec::new(), Vec::new())\n+             -> (ast::QSelf, ast::Path) {\n+        self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n \n     /// Constructs a qualified path.\n     ///\n-    /// Constructs a path like `<self_type as trait_ref>::ident<a, T, A=Bar>`.\n+    /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A=Bar>`.\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n-                 trait_ref: P<ast::TraitRef>,\n+                 trait_path: ast::Path,\n                  ident: ast::Ident,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n-                 bindings: Vec<P<ast::TypeBinding>> )\n-                 -> P<ast::QPath> {\n-        let segment = ast::PathSegment {\n+                 bindings: Vec<P<ast::TypeBinding>>)\n+                 -> (ast::QSelf, ast::Path) {\n+        let mut path = trait_path;\n+        path.segments.push(ast::PathSegment {\n             identifier: ident,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: OwnedSlice::from_vec(types),\n                 bindings: OwnedSlice::from_vec(bindings),\n             })\n-        };\n+        });\n \n-        P(ast::QPath {\n-            self_type: self_type,\n-            trait_ref: trait_ref,\n-            item_path: segment,\n-        })\n+        (ast::QSelf {\n+            ty: self_type,\n+            position: path.segments.len() - 1\n+        }, path)\n     }\n \n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n@@ -398,7 +398,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n-        self.ty(path.span, ast::TyPath(path, ast::DUMMY_NODE_ID))\n+        self.ty(path.span, ast::TyPath(None, path))\n     }\n \n     fn ty_sum(&self, path: ast::Path, bounds: OwnedSlice<ast::TyParamBound>) -> P<ast::Ty> {\n@@ -603,12 +603,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(path.span, ast::ExprPath(path))\n+        self.expr(path.span, ast::ExprPath(None, path))\n     }\n \n     /// Constructs a QPath expression.\n-    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprQPath(qpath))\n+    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n+        self.expr(span, ast::ExprPath(Some(qself), path))\n     }\n \n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {"}, {"sha": "2303eb9645b640415c7c3a1f9eaac7aa1e25315e", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -53,7 +53,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(\n+        node: ast::ExprPath(None,\n             ast::Path {\n                  span: sp,\n                  global: false,"}, {"sha": "80ef882745f878e152f3d24b29276bf6624db513", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -70,7 +70,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path!(bool)),\n+                ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     $f(a, b, c)"}, {"sha": "be4a33002aa1c69e87f2227fa0e6490e6571c120", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -36,7 +36,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path!(bool)),\n+                ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |cx, span, substr| {\n                     cs_op($op, $equal, cx, span, substr)"}, {"sha": "973c8f5fa1e0b4b26a39defe621cbe74107aab0f", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -30,6 +30,12 @@ macro_rules! path {\n     )\n }\n \n+macro_rules! path_local {\n+    ($x:ident) => (\n+        ::ext::deriving::generic::ty::Path::new_local(stringify!($x))\n+    )\n+}\n+\n macro_rules! pathvec_std {\n     ($cx:expr, $first:ident :: $($rest:ident)::+) => (\n         if $cx.use_std {"}, {"sha": "3b96292323a95039ab6f17535c704ce75023138b", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 name: \"from_i64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: vec!(Literal(path!(i64))),\n+                args: vec!(Literal(path_local!(i64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n                                            vec!(box Self_),\n@@ -53,7 +53,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 name: \"from_u64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: vec!(Literal(path!(u64))),\n+                args: vec!(Literal(path_local!(u64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n                                            vec!(box Self_),"}, {"sha": "bea57ae14e4af27c91d8600e7016525bdda30456", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -41,7 +41,7 @@ pub fn expand_type(t: P<ast::Ty>,\n     debug!(\"expanding type {:?} with impl_ty {:?}\", t, impl_ty);\n     let t = match (t.node.clone(), impl_ty) {\n         // Expand uses of `Self` in impls to the concrete type.\n-        (ast::Ty_::TyPath(ref path, _), Some(ref impl_ty)) => {\n+        (ast::Ty_::TyPath(None, ref path), Some(ref impl_ty)) => {\n             let path_as_ident = path_to_ident(path);\n             // Note unhygenic comparison here. I think this is correct, since\n             // even though `Self` is almost just a type parameter, the treatment\n@@ -1594,13 +1594,10 @@ mod test {\n \n     impl<'v> Visitor<'v> for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n-            match expr.node {\n-                ast::ExprPath(ref p) => {\n-                    self.path_accumulator.push(p.clone());\n-                    // not calling visit_path, but it should be fine.\n-                }\n-                _ => visit::walk_expr(self, expr)\n+            if let ast::ExprPath(None, ref p) = expr.node {\n+                self.path_accumulator.push(p.clone());\n             }\n+            visit::walk_expr(self, expr);\n         }\n     }\n "}, {"sha": "32fd5b49f9a44a150e24a932be90c8b2c02af8f6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyPath(ref p, _) => {\n+            ast::TyPath(None, ref p) => {\n                 match &*p.segments {\n \n                     [ast::PathSegment { identifier, .. }] => {"}, {"sha": "a556b2dfd2a99a88104844817f329d13a9f6669e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -146,10 +146,6 @@ pub trait Folder : Sized {\n         noop_fold_ty(t, self)\n     }\n \n-    fn fold_qpath(&mut self, t: P<QPath>) -> P<QPath> {\n-        noop_fold_qpath(t, self)\n-    }\n-\n     fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n         noop_fold_ty_binding(t, self)\n     }\n@@ -428,17 +424,19 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             }\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n-            TyPath(path, id) => {\n-                let id = fld.new_id(id);\n-                TyPath(fld.fold_path(path), id)\n+            TyPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: fld.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                TyPath(qself, fld.fold_path(path))\n             }\n             TyObjectSum(ty, bounds) => {\n                 TyObjectSum(fld.fold_ty(ty),\n                             fld.fold_bounds(bounds))\n             }\n-            TyQPath(qpath) => {\n-                TyQPath(fld.fold_qpath(qpath))\n-            }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n@@ -453,19 +451,6 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     })\n }\n \n-pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n-    qpath.map(|qpath| {\n-        QPath {\n-            self_type: fld.fold_ty(qpath.self_type),\n-            trait_ref: qpath.trait_ref.map(|tr| fld.fold_trait_ref(tr)),\n-            item_path: PathSegment {\n-                identifier: fld.fold_ident(qpath.item_path.identifier),\n-                parameters: fld.fold_path_parameters(qpath.item_path.parameters),\n-            }\n-        }\n-    })\n-}\n-\n pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n@@ -1364,8 +1349,15 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprRange(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n-            ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n-            ExprQPath(qpath) => ExprQPath(folder.fold_qpath(qpath)),\n+            ExprPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: folder.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                ExprPath(qself, folder.fold_path(path))\n+            }\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),"}, {"sha": "4d099529cb49ae50439b15fe1b3a03142d419af8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -774,7 +774,7 @@ mod test {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(ast::Path {\n+                    node: ast::ExprPath(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n                         segments: vec!(\n@@ -792,7 +792,7 @@ mod test {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(ast::Path {\n+                    node: ast::ExprPath(None, ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n                             segments: vec!(\n@@ -974,7 +974,7 @@ mod test {\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n-                        node:ast::ExprPath(ast::Path{\n+                        node:ast::ExprPath(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n                             segments: vec!(\n@@ -995,7 +995,7 @@ mod test {\n                    P(Spanned{\n                        node: ast::StmtExpr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n-                           node: ast::ExprPath(ast::Path {\n+                           node: ast::ExprPath(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n                                segments: vec!(\n@@ -1041,7 +1041,7 @@ mod test {\n                             node: ast::ItemFn(P(ast::FnDecl {\n                                 inputs: vec!(ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                  node: ast::TyPath(ast::Path{\n+                                                  node: ast::TyPath(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: vec!(\n@@ -1051,7 +1051,7 @@ mod test {\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n-                                        }, ast::DUMMY_NODE_ID),\n+                                        }),\n                                         span:sp(10,13)\n                                     }),\n                                     pat: P(ast::Pat {\n@@ -1084,7 +1084,7 @@ mod test {\n                                         stmts: vec!(P(Spanned{\n                                             node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n-                                                node: ast::ExprPath(\n+                                                node: ast::ExprPath(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,"}, {"sha": "f171e8279f49c47440ce715dd1e616d469a614fb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -25,7 +25,7 @@ use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n-use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n+use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n@@ -43,7 +43,7 @@ use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef};\n-use ast::{QPath, RequiredMethod};\n+use ast::{QSelf, RequiredMethod};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub, StrStyle};\n@@ -53,7 +53,7 @@ use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n+use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n use ast::{UnnamedField, UnsafeBlock};\n@@ -143,7 +143,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(pt)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt)))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -1076,8 +1076,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ty_path(&mut self) -> Ty_ {\n-        let path = self.parse_path(LifetimeAndTypesWithoutColons);\n-        TyPath(path, ast::DUMMY_NODE_ID)\n+        TyPath(None, self.parse_path(LifetimeAndTypesWithoutColons))\n     }\n \n     /// parse a TyBareFn type:\n@@ -1525,19 +1524,36 @@ impl<'a> Parser<'a> {\n         } else if self.eat_lt() {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             let self_type = self.parse_ty_sum();\n-            self.expect_keyword(keywords::As);\n-            let trait_ref = self.parse_trait_ref();\n+\n+            let mut path = if self.eat_keyword(keywords::As) {\n+                self.parse_path(LifetimeAndTypesWithoutColons)\n+            } else {\n+                ast::Path {\n+                    span: self.span,\n+                    global: false,\n+                    segments: vec![]\n+                }\n+            };\n+\n+            let qself = QSelf {\n+                ty: self_type,\n+                position: path.segments.len()\n+            };\n+\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n-            let item_name = self.parse_ident();\n-            TyQPath(P(QPath {\n-                self_type: self_type,\n-                trait_ref: P(trait_ref),\n-                item_path: ast::PathSegment {\n-                    identifier: item_name,\n-                    parameters: ast::PathParameters::none()\n-                }\n-            }))\n+\n+            path.segments.push(ast::PathSegment {\n+                identifier: self.parse_ident(),\n+                parameters: ast::PathParameters::none()\n+            });\n+\n+            if path.segments.len() == 1 {\n+                path.span.lo = self.last_span.lo;\n+            }\n+            path.span.hi = self.last_span.hi;\n+\n+            TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n@@ -2178,7 +2194,7 @@ impl<'a> Parser<'a> {\n                          }, token::Plain) => {\n                 self.bump();\n                 let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n-                ex = ExprPath(path);\n+                ex = ExprPath(None, path);\n                 hi = self.last_span.hi;\n             }\n             token::OpenDelim(token::Bracket) => {\n@@ -2220,10 +2236,22 @@ impl<'a> Parser<'a> {\n                 if self.eat_lt() {\n                     // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n                     let self_type = self.parse_ty_sum();\n-                    self.expect_keyword(keywords::As);\n-                    let trait_ref = self.parse_trait_ref();\n+                    let mut path = if self.eat_keyword(keywords::As) {\n+                        self.parse_path(LifetimeAndTypesWithoutColons)\n+                    } else {\n+                        ast::Path {\n+                            span: self.span,\n+                            global: false,\n+                            segments: vec![]\n+                        }\n+                    };\n+                    let qself = QSelf {\n+                        ty: self_type,\n+                        position: path.segments.len()\n+                    };\n                     self.expect(&token::Gt);\n                     self.expect(&token::ModSep);\n+\n                     let item_name = self.parse_ident();\n                     let parameters = if self.eat(&token::ModSep) {\n                         self.expect_lt();\n@@ -2238,15 +2266,18 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ast::PathParameters::none()\n                     };\n+                    path.segments.push(ast::PathSegment {\n+                        identifier: item_name,\n+                        parameters: parameters\n+                    });\n+\n+                    if path.segments.len() == 1 {\n+                        path.span.lo = self.last_span.lo;\n+                    }\n+                    path.span.hi = self.last_span.hi;\n+\n                     let hi = self.span.hi;\n-                    return self.mk_expr(lo, hi, ExprQPath(P(QPath {\n-                        self_type: self_type,\n-                        trait_ref: P(trait_ref),\n-                        item_path: ast::PathSegment {\n-                            identifier: item_name,\n-                            parameters: parameters\n-                        }\n-                    })));\n+                    return self.mk_expr(lo, hi, ExprPath(Some(qself), path));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n                     return self.parse_lambda_expr(CaptureByValue);\n@@ -2386,7 +2417,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     hi = pth.span.hi;\n-                    ex = ExprPath(pth);\n+                    ex = ExprPath(None, pth);\n                 } else {\n                     // other literal expression\n                     let lit = self.parse_lit();\n@@ -3428,7 +3459,7 @@ impl<'a> Parser<'a> {\n                 let end = if self.token.is_ident() || self.token.is_path() {\n                     let path = self.parse_path(LifetimeAndTypesWithColons);\n                     let hi = self.span.hi;\n-                    self.mk_expr(lo, hi, ExprPath(path))\n+                    self.mk_expr(lo, hi, ExprPath(None, path))\n                 } else {\n                     self.parse_literal_maybe_minus()\n                 };\n@@ -4815,10 +4846,10 @@ impl<'a> Parser<'a> {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             match ty.node {\n-                TyPath(ref path, node_id) => {\n+                TyPath(None, ref path) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n-                        ref_id: node_id,\n+                        ref_id: ty.id,\n                     })\n                 }\n                 _ => {"}, {"sha": "af16e19c9f034a1c33399045ef009407cdbf09c1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -373,7 +373,7 @@ pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    $to_string(|s| s.print_path(p, false))\n+    $to_string(|s| s.print_path(p, false, 0))\n }\n \n pub fn ident_to_string(id: &ast::Ident) -> String {\n@@ -729,8 +729,11 @@ impl<'a> State<'a> {\n                                       &generics,\n                                       None));\n             }\n-            ast::TyPath(ref path, _) => {\n-                try!(self.print_path(path, false));\n+            ast::TyPath(None, ref path) => {\n+                try!(self.print_path(path, false, 0));\n+            }\n+            ast::TyPath(Some(ref qself), ref path) => {\n+                try!(self.print_qpath(path, qself, false))\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n@@ -739,9 +742,6 @@ impl<'a> State<'a> {\n             ast::TyPolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n-            ast::TyQPath(ref qpath) => {\n-                try!(self.print_qpath(&**qpath, false))\n-            }\n             ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n@@ -1018,7 +1018,7 @@ impl<'a> State<'a> {\n             ast::ItemMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n                 try!(self.print_visibility(item.vis));\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n@@ -1033,7 +1033,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> IoResult<()> {\n-        self.print_path(&t.path, false)\n+        self.print_path(&t.path, false, 0)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> IoResult<()> {\n@@ -1297,7 +1297,7 @@ impl<'a> State<'a> {\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n                 // code copied from ItemMac:\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n@@ -1514,7 +1514,7 @@ impl<'a> State<'a> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n             ast::MacInvocTT(ref pth, ref tts, _) => {\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"!\"));\n                 match delim {\n                     token::Paren => try!(self.popen()),\n@@ -1584,7 +1584,7 @@ impl<'a> State<'a> {\n                          path: &ast::Path,\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n-        try!(self.print_path(path, true));\n+        try!(self.print_path(path, true, 0));\n         if !(fields.is_empty() && wth.is_none()) {\n             try!(word(&mut self.s, \"{\"));\n             try!(self.commasep_cmnt(\n@@ -1852,8 +1852,12 @@ impl<'a> State<'a> {\n                     try!(self.print_expr(&**e));\n                 }\n             }\n-            ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n-            ast::ExprQPath(ref qpath) => try!(self.print_qpath(&**qpath, true)),\n+            ast::ExprPath(None, ref path) => {\n+                try!(self.print_path(path, true, 0))\n+            }\n+            ast::ExprPath(Some(ref qself), ref path) => {\n+                try!(self.print_qpath(path, qself, true))\n+            }\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n@@ -2014,16 +2018,14 @@ impl<'a> State<'a> {\n \n     fn print_path(&mut self,\n                   path: &ast::Path,\n-                  colons_before_params: bool)\n+                  colons_before_params: bool,\n+                  depth: usize)\n                   -> IoResult<()>\n     {\n         try!(self.maybe_print_comment(path.span.lo));\n-        if path.global {\n-            try!(word(&mut self.s, \"::\"));\n-        }\n \n-        let mut first = true;\n-        for segment in &path.segments {\n+        let mut first = !path.global;\n+        for segment in &path.segments[..path.segments.len()-depth] {\n             if first {\n                 first = false\n             } else {\n@@ -2039,19 +2041,24 @@ impl<'a> State<'a> {\n     }\n \n     fn print_qpath(&mut self,\n-                   qpath: &ast::QPath,\n+                   path: &ast::Path,\n+                   qself: &ast::QSelf,\n                    colons_before_params: bool)\n                    -> IoResult<()>\n     {\n         try!(word(&mut self.s, \"<\"));\n-        try!(self.print_type(&*qpath.self_type));\n-        try!(space(&mut self.s));\n-        try!(self.word_space(\"as\"));\n-        try!(self.print_trait_ref(&*qpath.trait_ref));\n+        try!(self.print_type(&qself.ty));\n+        if qself.position > 0 {\n+            try!(space(&mut self.s));\n+            try!(self.word_space(\"as\"));\n+            let depth = path.segments.len() - qself.position;\n+            try!(self.print_path(&path, false, depth));\n+        }\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n-        try!(self.print_ident(qpath.item_path.identifier));\n-        self.print_path_parameters(&qpath.item_path.parameters, colons_before_params)\n+        let item_segment = path.segments.last().unwrap();\n+        try!(self.print_ident(item_segment.identifier));\n+        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n     fn print_path_parameters(&mut self,\n@@ -2156,7 +2163,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::PatEnum(ref path, ref args_) => {\n-                try!(self.print_path(path, true));\n+                try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n                     Some(ref args) => {\n@@ -2170,7 +2177,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::PatStruct(ref path, ref fields, etc) => {\n-                try!(self.print_path(path, true));\n+                try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n@@ -2555,7 +2562,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    try!(self.print_path(path, false));\n+                    try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_type(&**ty));\n@@ -2592,7 +2599,7 @@ impl<'a> State<'a> {\n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> IoResult<()> {\n         match vp.node {\n             ast::ViewPathSimple(ident, ref path) => {\n-                try!(self.print_path(path, false));\n+                try!(self.print_path(path, false, 0));\n \n                 // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name !=\n@@ -2606,15 +2613,15 @@ impl<'a> State<'a> {\n             }\n \n             ast::ViewPathGlob(ref path) => {\n-                try!(self.print_path(path, false));\n+                try!(self.print_path(path, false, 0));\n                 word(&mut self.s, \"::*\")\n             }\n \n             ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n-                    try!(self.print_path(path, false));\n+                    try!(self.print_path(path, false, 0));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {"}, {"sha": "33d8d56b4b11469cb6ccbf9890a57ba9d7555389", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -125,9 +125,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_qpath(&mut self, qpath_span: Span, qpath: &'v QPath) {\n-        walk_qpath(self, qpath_span, qpath)\n-    }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n@@ -399,16 +396,16 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n             walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n-        TyPath(ref path, id) => {\n-            visitor.visit_path(path, id);\n+        TyPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, typ.id);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(&**ty);\n             walk_ty_param_bounds_helper(visitor, bounds);\n         }\n-        TyQPath(ref qpath) => {\n-            visitor.visit_qpath(typ.span, &**qpath);\n-        }\n         TyFixedLengthVec(ref ty, ref expression) => {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n@@ -436,14 +433,6 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                      qpath_span: Span,\n-                                      qpath: &'v QPath) {\n-    visitor.visit_ty(&*qpath.self_type);\n-    visitor.visit_trait_ref(&*qpath.trait_ref);\n-    visitor.visit_path_segment(qpath_span, &qpath.item_path);\n-}\n-\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n@@ -869,12 +858,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_expr_opt(visitor, start);\n             walk_expr_opt(visitor, end)\n         }\n-        ExprPath(ref path) => {\n+        ExprPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprQPath(ref qpath) => {\n-            visitor.visit_qpath(expression.span, &**qpath)\n-        }\n         ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(ref optional_expression) => {\n             walk_expr_opt(visitor, optional_expression)"}, {"sha": "becbc27138b770e700d524844357252c7c017c95", "filename": "src/test/compile-fail/associated-types-in-ambiguous-context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -22,5 +22,8 @@ trait Grab {\n     //~^ ERROR ambiguous associated type\n }\n \n+type X = std::ops::Deref::Target;\n+//~^ ERROR ambiguous associated type\n+\n fn main() {\n }"}, {"sha": "7a7406115d39365a5735d7f24a735eaa43c91941", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -43,7 +43,7 @@ fn foo<'a>() {\n     //~^ ERROR too many type parameters provided\n \n     let _ = S::<'a,isize>::new::<f64>(1, 1.0);\n-    //~^ ERROR too many lifetime parameters provided\n+    //~^ ERROR wrong number of lifetime parameters\n \n     let _: S2 = Trait::new::<isize,f64>(1, 1.0);\n     //~^ ERROR too many type parameters provided"}, {"sha": "21334e1d51375420c373ed906fdd09e59f1c6bc0", "filename": "src/test/compile-fail/extern-with-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -24,7 +24,7 @@ extern \"rust-intrinsic\" {\n \n     // Unresolved bounds should still error.\n     fn align_of<T: NoSuchTrait>() -> usize;\n-    //~^ ERROR attempt to bound type parameter with a nonexistent trait `NoSuchTrait`\n+    //~^ ERROR use of undeclared trait name `NoSuchTrait`\n }\n \n fn main() {}"}, {"sha": "5fa429445a35e66fc5d68df606e872227e308adf", "filename": "src/test/compile-fail/generic-impl-less-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-less-params-with-defaults.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -19,5 +19,5 @@ impl<A, B, C = (A, B)> Foo<A, B, C> {\n \n fn main() {\n     Foo::<isize>::new();\n-    //~^ ERROR too few type parameters provided\n+    //~^ ERROR wrong number of type arguments\n }"}, {"sha": "d3babb8982ddca652bdd9c16e113d89ea74f445a", "filename": "src/test/compile-fail/generic-impl-more-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-impl-more-params-with-defaults.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -21,5 +21,5 @@ impl<T, A = Heap> Vec<T, A> {\n \n fn main() {\n     Vec::<isize, Heap, bool>::new();\n-    //~^ ERROR too many type parameters provided\n+    //~^ ERROR wrong number of type arguments\n }"}, {"sha": "181503db818462907d8854a0cbb9e6b4cd4752dd", "filename": "src/test/compile-fail/glob-resolve1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -36,9 +36,6 @@ fn main() {\n     import(); //~ ERROR: unresolved\n \n     foo::<A>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n     foo::<C>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n     foo::<D>(); //~ ERROR: undeclared\n-    //~^ ERROR: undeclared\n }"}, {"sha": "c0c951dd8b10835c990421bfc3a26ddfa2a9f055", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate definition of value `orange`\n+    fn orange(&self){}   //~ ERROR error: duplicate method in trait impl\n }\n \n fn main() {}"}, {"sha": "cf2a70deee513cf3945a6389557febc52367ec1f", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -14,7 +14,8 @@ enum Bar<T> { What }\n \n fn foo<T>() {\n     static a: Bar<T> = Bar::What;\n-    //~^ ERROR: cannot use an outer type parameter in this context\n+    //~^ ERROR cannot use an outer type parameter in this context\n+    //~| ERROR use of undeclared type name `T`\n }\n \n fn main() {"}, {"sha": "51b6dc0d07865eda130cbc0e8633f90907501550", "filename": "src/test/compile-fail/issue-13641.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13641.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -17,9 +17,9 @@ mod a {\n \n fn main() {\n     a::Foo::new();\n-    //~^ ERROR: static method `new` is inaccessible\n+    //~^ ERROR: method `new` is inaccessible\n     //~^^ NOTE: struct `Foo` is private\n     a::Bar::new();\n-    //~^ ERROR: static method `new` is inaccessible\n+    //~^ ERROR: method `new` is inaccessible\n     //~^^ NOTE: enum `Bar` is private\n }"}, {"sha": "ce5fa1f1fe1a5e66e4fc4cb9fc54f8d4de85c873", "filename": "src/test/compile-fail/issue-14254.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -29,7 +29,7 @@ impl Foo for *const BarTy {\n         baz();\n         //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n     }\n }\n \n@@ -42,11 +42,11 @@ impl<'a> Foo for &'a BarTy {\n         y;\n         //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n         bah;\n         //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n         b;\n-        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+        //~^ ERROR: unresolved name `b`\n     }\n }\n \n@@ -59,11 +59,11 @@ impl<'a> Foo for &'a mut BarTy {\n         y;\n         //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n         a;\n-        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        //~^ ERROR: unresolved name `a`\n         bah;\n         //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n         b;\n-        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+        //~^ ERROR: unresolved name `b`\n     }\n }\n "}, {"sha": "c6ff82364b3e7cd57c279b9e4772aab1d386c51f", "filename": "src/test/compile-fail/issue-19883.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -15,18 +15,11 @@ trait From<Src> {\n }\n \n trait To {\n-    // This is a typo, the return type should be `<Dst as From<Self>>::Output`\n-    fn to<Dst: From<Self>>(\n-        self\n-        //~^ error: the trait `core::marker::Sized` is not implemented\n-    ) ->\n+    fn to<Dst: From<Self>>(self) ->\n         <Dst as From<Self>>::Dst\n-        //~^ error: the trait `core::marker::Sized` is not implemented\n+        //~^ ERROR use of undeclared associated type `From::Dst`\n     {\n-        From::from(\n-            //~^ error: the trait `core::marker::Sized` is not implemented\n-            self\n-        )\n+        From::from(self)\n     }\n }\n "}, {"sha": "05485008e51fddabce97136adf959f142d0fb3cf", "filename": "src/test/compile-fail/issue-21202.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21202.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -18,7 +18,7 @@ mod B {\n     use crate1::A::Foo;\n     fn bar(f: Foo) {\n         Foo::foo(&f);\n-        //~^ ERROR: function `foo` is private\n+        //~^ ERROR: method `foo` is private\n     }\n }\n "}, {"sha": "48cc27e228940b74f93d71640562f64224e88f59", "filename": "src/test/compile-fail/issue-2356.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2356.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -36,7 +36,7 @@ impl Groom for cat {\n     shave(4);\n     //~^ ERROR: unresolved name `shave`. Did you mean to call `Groom::shave`?\n     purr();\n-    //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+    //~^ ERROR: unresolved name `purr`\n   }\n }\n \n@@ -45,13 +45,13 @@ impl cat {\n \n     fn purr_louder() {\n         static_method();\n-        //~^ ERROR: unresolved name `static_method`. Did you mean to call `cat::static_method`\n+        //~^ ERROR: unresolved name `static_method`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n         purr();\n-        //~^ ERROR: unresolved name `purr`. Did you mean to call `self.purr`?\n+        //~^ ERROR: unresolved name `purr`\n     }\n }\n \n@@ -65,7 +65,7 @@ impl cat {\n \n   fn purr(&self) {\n     grow_older();\n-    //~^ ERROR: unresolved name `grow_older`. Did you mean to call `cat::grow_older`\n+    //~^ ERROR: unresolved name `grow_older`\n     shave();\n     //~^ ERROR: unresolved name `shave`\n   }\n@@ -79,7 +79,7 @@ impl cat {\n     whiskers = 4;\n     //~^ ERROR: unresolved name `whiskers`. Did you mean `self.whiskers`?\n     purr_louder();\n-    //~^ ERROR: unresolved name `purr_louder`. Did you mean to call `cat::purr_louder`\n+    //~^ ERROR: unresolved name `purr_louder`\n   }\n }\n "}, {"sha": "ad5bc4e445c9839b7ebc41064ef684f460087340", "filename": "src/test/compile-fail/issue-3521-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -11,7 +11,9 @@\n fn main() {\n     let foo = 100;\n \n-    static y: isize = foo + 1; //~ ERROR: attempt to use a non-constant value in a constant\n+    static y: isize = foo + 1;\n+    //~^ ERROR attempt to use a non-constant value in a constant\n+    //~| ERROR unresolved name `foo`\n \n     println!(\"{}\", y);\n }"}, {"sha": "f06aa45ac38fd1848c106847d37e1e5421e717af", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -13,7 +13,9 @@ fn main() {\n \n     #[derive(Debug)]\n     enum Stuff {\n-        Bar = foo //~ ERROR attempt to use a non-constant value in a constant\n+        Bar = foo\n+        //~^ ERROR attempt to use a non-constant value in a constant\n+        //~| ERROR unresolved name `foo`\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "a09c8090de06de5716e718d3d33e6291f7edfaf9", "filename": "src/test/compile-fail/issue-3668-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n fn f(x:isize) {\n-    static child: isize = x + 1; //~ ERROR attempt to use a non-constant value in a constant\n+    static child: isize = x + 1;\n+    //~^ ERROR attempt to use a non-constant value in a constant\n+    //~| ERROR unresolved name `x`\n }\n \n fn main() {}"}, {"sha": "9b7476244f0d26a19e0d91639fea3c306c20406f", "filename": "src/test/compile-fail/issue-3668.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -17,6 +17,7 @@ impl PTrait for P {\n    fn getChildOption(&self) -> Option<Box<P>> {\n        static childVal: Box<P> = self.child.get();\n        //~^ ERROR attempt to use a non-constant value in a constant\n+       //~| ERROR unresolved name `self`\n        panic!();\n    }\n }"}, {"sha": "2652fb5dfc2fd6dc453f73f1d3d9094847ccbe86", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -30,7 +30,5 @@ impl ToString_ for Point {\n \n fn main() {\n     let p = Point::new(0.0, 0.0);\n-    //~^ ERROR unresolved name `Point::new`\n-    //~^^ ERROR failed to resolve. Use of undeclared type or module `Point`\n     println!(\"{}\", p.to_string());\n }"}, {"sha": "ab18e0bcddcf08ef7005c27a814343b131404578", "filename": "src/test/compile-fail/issue-4265.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -17,7 +17,7 @@ impl Foo {\n         Foo { baz: 0 }.bar();\n     }\n \n-    fn bar() { //~ ERROR duplicate definition of value `bar`\n+    fn bar() { //~ ERROR duplicate method in trait impl\n     }\n }\n "}, {"sha": "4ac901776099d0b0e4164e4d6296645ccbbd57b0", "filename": "src/test/compile-fail/issue-7607-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n struct Foo {\n     x: isize\n }\n \n-impl Fo { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+impl Fo { //~ ERROR use of undeclared type name `Fo`\n     fn foo() {}\n }\n "}, {"sha": "2ef0a75f77b5a9fb25b4b1784d24c98d24075861", "filename": "src/test/compile-fail/issue-8767.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n \n-impl B { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+impl B { //~ ERROR use of undeclared type name `B`\n }\n \n fn main() {"}, {"sha": "90792848855721b89f39ed4342a9ab3090685411", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 144, "deletions": 7, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -29,45 +29,104 @@ mod cross_crate {\n     use lint_stability::*;\n \n     fn test() {\n+        type Foo = MethodTester;\n         let foo = MethodTester;\n \n         deprecated(); //~ ERROR use of deprecated item\n         foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n \n         deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n \n         deprecated_unstable(); //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n         foo.method_deprecated_unstable(); //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n+        Foo::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n         foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n+        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n \n         deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n         foo.method_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n+        Foo::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n         foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n+        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n \n         unstable(); //~ WARNING use of unstable library feature\n         foo.method_unstable(); //~ WARNING use of unstable library feature\n+        Foo::method_unstable(&foo); //~ WARNING use of unstable library feature\n+        <Foo>::method_unstable(&foo); //~ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n+        Trait::trait_unstable(&foo); //~ WARNING use of unstable library feature\n+        <Foo>::trait_unstable(&foo); //~ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_unstable(&foo); //~ WARNING use of unstable library feature\n \n-        unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n-        foo.method_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n+        unstable_text();\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        foo.method_unstable_text();\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        Foo::method_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        <Foo>::method_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        foo.trait_unstable_text();\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        Trait::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        <Foo>::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n \n         stable();\n         foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n         foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n \n         stable_text();\n         foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n         foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n         let _ = DeprecatedUnstableStruct { i: 0 }; //~ ERROR use of deprecated item\n@@ -104,16 +163,47 @@ mod cross_crate {\n         macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n     }\n \n-    fn test_method_param<F: Trait>(foo: F) {\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n         foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n+        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n+        //~^ WARNING use of unstable library feature\n         foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n+        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        //~^ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n+        Trait::trait_unstable(&foo); //~ WARNING use of unstable library feature\n+        <Foo>::trait_unstable(&foo); //~ WARNING use of unstable library feature\n+        <Foo as Trait>::trait_unstable(&foo); //~ WARNING use of unstable library feature\n+        foo.trait_unstable_text();\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        Trait::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        <Foo>::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n+        <Foo as Trait>::trait_unstable_text(&foo);\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n         foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n     }\n \n     fn test_method_object(foo: &Trait) {\n@@ -124,7 +214,8 @@ mod cross_crate {\n         foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n+        foo.trait_unstable_text();\n+        //~^ WARNING use of unstable library feature 'test_feature': text\n         foo.trait_stable();\n     }\n \n@@ -264,31 +355,62 @@ mod this_crate {\n         // errors, because other stability attributes now have meaning\n         // only *across* crates, not within a single crate.\n \n+        type Foo = MethodTester;\n         let foo = MethodTester;\n \n         deprecated(); //~ ERROR use of deprecated item\n         foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n \n         deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n \n         unstable();\n         foo.method_unstable();\n+        Foo::method_unstable(&foo);\n+        <Foo>::method_unstable(&foo);\n         foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n \n         unstable_text();\n         foo.method_unstable_text();\n+        Foo::method_unstable_text(&foo);\n+        <Foo>::method_unstable_text(&foo);\n         foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n \n         stable();\n         foo.method_stable();\n+        Foo::method_stable(&foo);\n+        <Foo>::method_stable(&foo);\n         foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n \n         stable_text();\n         foo.method_stable_text();\n+        Foo::method_stable_text(&foo);\n+        <Foo>::method_stable_text(&foo);\n         foo.trait_stable_text();\n+        Trait::trait_stable_text(&foo);\n+        <Foo>::trait_stable_text(&foo);\n+        <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n         let _ = UnstableStruct { i: 0 };\n@@ -307,12 +429,27 @@ mod this_crate {\n         let _ = StableTupleStruct (1);\n     }\n \n-    fn test_method_param<F: Trait>(foo: F) {\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n         foo.trait_unstable();\n+        Trait::trait_unstable(&foo);\n+        <Foo>::trait_unstable(&foo);\n+        <Foo as Trait>::trait_unstable(&foo);\n         foo.trait_unstable_text();\n+        Trait::trait_unstable_text(&foo);\n+        <Foo>::trait_unstable_text(&foo);\n+        <Foo as Trait>::trait_unstable_text(&foo);\n         foo.trait_stable();\n+        Trait::trait_stable(&foo);\n+        <Foo>::trait_stable(&foo);\n+        <Foo as Trait>::trait_stable(&foo);\n     }\n \n     fn test_method_object(foo: &Trait) {"}, {"sha": "c9ef2df8e1326f01f26bb275f40bde1ce2f4d29d", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -29,7 +29,7 @@ impl S {\n \n     // Cause an error. It shouldn't have any macro backtrace frames.\n     fn bar(&self) { }\n-    fn bar(&self) { } //~ ERROR duplicate definition\n+    fn bar(&self) { } //~ ERROR duplicate method\n }\n \n fn main() { }"}, {"sha": "526750257d2785c81f52b11599084aebf589cd16", "filename": "src/test/compile-fail/no-implicit-prelude-nested.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -18,23 +18,23 @@\n mod foo {\n     mod baz {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl Add for Test {} //~ ERROR: use of undeclared trait\n+        impl Clone for Test {} //~ ERROR: use of undeclared trait\n+        impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+        impl ToString for Test {} //~ ERROR: use of undeclared trait\n+        impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n         fn foo() {\n             drop(2) //~ ERROR: unresolved name\n         }\n     }\n \n     struct Test;\n-    impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-    impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+    impl Add for Test {} //~ ERROR: use of undeclared trait\n+    impl Clone for Test {} //~ ERROR: use of undeclared trait\n+    impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+    impl ToString for Test {} //~ ERROR: use of undeclared trait\n+    impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n     fn foo() {\n         drop(2) //~ ERROR: unresolved name\n@@ -45,11 +45,11 @@ fn qux() {\n     #[no_implicit_prelude]\n     mod qux_inner {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-        impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+        impl Add for Test {} //~ ERROR: use of undeclared trait\n+        impl Clone for Test {} //~ ERROR: use of undeclared trait\n+        impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+        impl ToString for Test {} //~ ERROR: use of undeclared trait\n+        impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n         fn foo() {\n             drop(2) //~ ERROR: unresolved name"}, {"sha": "c4bcd33b93bd0beb67f68e1bf121553ec12432c6", "filename": "src/test/compile-fail/no-implicit-prelude.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -17,11 +17,11 @@\n // fail with the same error message).\n \n struct Test;\n-impl Add for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Clone for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Iterator for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl ToString for Test {} //~ ERROR: attempt to implement a nonexistent trait\n-impl Writer for Test {} //~ ERROR: attempt to implement a nonexistent trait\n+impl Add for Test {} //~ ERROR: use of undeclared trait\n+impl Clone for Test {} //~ ERROR: use of undeclared trait\n+impl Iterator for Test {} //~ ERROR: use of undeclared trait\n+impl ToString for Test {} //~ ERROR: use of undeclared trait\n+impl Writer for Test {} //~ ERROR: use of undeclared trait\n \n fn main() {\n     drop(2) //~ ERROR: unresolved name"}, {"sha": "3983a84f6ad1795a8d0ffac46710870b32d3d3cd", "filename": "src/test/compile-fail/resolve-unknown-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -10,11 +10,11 @@\n \n \n trait NewTrait : SomeNonExistentTrait {}\n-//~^ ERROR attempt to derive a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n \n impl SomeNonExistentTrait for isize {}\n-//~^ ERROR attempt to implement a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n \n fn f<T:SomeNonExistentTrait>() {}\n-//~^ ERROR attempt to bound type parameter with a nonexistent trait `SomeNonExistentTrait`\n+//~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n "}, {"sha": "969b6398fdb10d787ed9ef456c64273afc92ade3", "filename": "src/test/compile-fail/trait-impl-for-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -14,7 +14,7 @@ mod a {\n trait A {\n }\n \n-impl A for a { //~ERROR found module name used as a type\n+impl A for a { //~ ERROR use of undeclared type name `a`\n }\n \n fn main() {"}, {"sha": "3aec23a55b8118e9f4766c28ed7c5d2c9e02e5d5", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n-impl<T> Option<T> { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+impl<T> Option<T> {\n+//~^ ERROR cannot associate methods with a type outside the crate the type is defined in\n     pub fn foo(&self) { }\n }\n "}, {"sha": "b3fe178dc455e83b0d8c40f7092b57cbee1090fd", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -12,5 +12,5 @@ use std::borrow::IntoCow;\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());\n-    //~^ ERROR wrong number of type arguments: expected 1, found 0\n+    //~^ ERROR too few type parameters provided: expected 1 parameter(s)\n }"}, {"sha": "f28bf7acadd371240b0c3b3c1b77fa885ed95554", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-fn f<F:Nonexist(isize) -> isize>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n+fn f<F:Nonexist(isize) -> isize>(x: F) {} //~ ERROR undeclared trait name `Nonexist`\n \n type Typedef = isize;\n "}, {"sha": "49d8622976bb2dfd43159d1ee1ce01c9d764591b", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -11,7 +11,7 @@\n use Trait::foo;\n //~^ ERROR `foo` is not directly importable\n use Foo::new;\n-//~^ ERROR `new` is not directly importable\n+//~^ ERROR unresolved import `Foo::new`. Not a module `Foo`\n \n pub trait Trait {\n     fn foo();"}, {"sha": "663ed24d60e48483ba246e1f41a977f2aa94fea8", "filename": "src/test/run-pass/impl-inherent-non-conflict.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-inherent-non-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-inherent-non-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-inherent-non-conflict.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that an user-defined type admits multiple inherent methods\n+// with the same name, which can be called on values that have a\n+// precise enough type to allow distinguishing between the methods.\n+\n+struct Foo<T>(T);\n+\n+impl Foo<usize> {\n+    fn bar(&self) -> i32 { self.0 as i32 }\n+}\n+\n+impl Foo<isize> {\n+    fn bar(&self) -> i32 { -(self.0 as i32) }\n+}\n+\n+fn main() {\n+    let foo_u = Foo::<usize>(5);\n+    assert_eq!(foo_u.bar(), 5);\n+\n+    let foo_i = Foo::<isize>(3);\n+    assert_eq!(foo_i.bar(), -3);\n+}"}, {"sha": "3031228b3ab44f5361fd2a6263e4dc706381a3cd", "filename": "src/test/run-pass/impl-inherent-prefer-over-trait.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-inherent-prefer-over-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-inherent-prefer-over-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-inherent-prefer-over-trait.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+trait Trait {\n+    fn bar(&self);\n+}\n+\n+// Inherent impls should be preferred over trait ones.\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+impl Trait {\n+    fn baz(_: &Foo) {}\n+}\n+\n+impl Trait for Foo {\n+    fn bar(&self) { panic!(\"wrong method called!\") }\n+}\n+\n+fn main() {\n+    Foo.bar();\n+    Foo::bar(&Foo);\n+    <Foo>::bar(&Foo);\n+\n+    // Should work even if Trait::baz doesn't exist.\n+    // N.B: `<Trait>::bar` would be ambiguous.\n+    <Trait>::baz(&Foo);\n+}"}, {"sha": "c1dc68b245655b2c521be9d7fa012e50e12169a9", "filename": "src/test/run-pass/impl-not-adjacent-to-type.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-not-adjacent-to-type.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test calling methods on an impl for a bare trait. This test checks trait impls\n-// must be in the same module as the trait.\n-\n-mod Foo {\n-    trait T {}\n+mod foo {\n+    pub struct Point {\n+        pub x: i32,\n+        pub y: i32,\n+    }\n }\n \n-mod Bar {\n-    impl<'a> ::Foo::T+'a { //~ERROR: inherent implementations may only be implemented in the same\n-        fn foo(&self) {}\n-    }\n+impl foo::Point {\n+    fn x(&self) -> i32 { self.x }\n }\n \n-fn main() {}\n+fn main() {\n+    assert_eq!((foo::Point { x: 1, y: 3}).x(), 1);\n+}", "previous_filename": "src/test/compile-fail/trait-impl-2.rs"}, {"sha": "09c0c8604adc28be4c66f0800ca3a91394f4b098", "filename": "src/test/run-pass/issue-12729.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fissue-12729.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fissue-12729.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12729.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n pub struct Foo;\n \n mod bar {\n     use Foo;\n \n-    impl Foo { //~ERROR inherent implementations are only allowed on types defined in the current module\n+    impl Foo {\n         fn baz(&self) {}\n     }\n }", "previous_filename": "src/test/compile-fail/issue-12729.rs"}, {"sha": "c52051fab96e31e272fdb1a7de7c9fa0685a08d3", "filename": "src/test/run-pass/issue-7607-2.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fissue-7607-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fissue-7607-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7607-2.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n pub mod a {\n     pub struct Foo { a: usize }\n }\n \n pub mod b {\n     use a::Foo;\n-    impl Foo { //~ERROR inherent implementations are only allowed on types defined in the current module\n+    impl Foo {\n         fn bar(&self) { }\n     }\n }", "previous_filename": "src/test/compile-fail/issue-7607-2.rs"}, {"sha": "abc35bcc29d415b8655687ee8c7a9d548399fa74", "filename": "src/test/run-pass/trait-impl-2.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-impl-2.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod foo {\n-    pub struct Foo {\n-        x: isize,\n-        y: isize,\n+pub mod Foo {\n+    pub trait Trait {\n+        fn foo(&self);\n     }\n }\n \n-impl foo::Foo {\n-//~^ ERROR implementations may only be implemented in the same module\n-    fn bar() {}\n+mod Bar {\n+    impl<'a> ::Foo::Trait+'a {\n+        fn bar(&self) { self.foo() }\n+    }\n }\n \n fn main() {}\n-", "previous_filename": "src/test/compile-fail/impl-not-adjacent-to-type.rs"}, {"sha": "29b1c8f81d3c610f5ecda098fbed2fa110eff5fb", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "renamed", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9692f3bc941795dafac998294cc4e50e78efb4b5/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=9692f3bc941795dafac998294cc4e50e78efb4b5", "patch": "@@ -27,11 +27,11 @@ struct Newt<T>(T);\n fn id<T>(x: T) -> T { x }\n fn eq<T: Eq>(a: T, b: T) -> bool { a == b }\n fn u8_as_i8(x: u8) -> i8 { x as i8 }\n-fn odd(x: uint) -> bool { x % 2 == 1 }\n+fn odd(x: usize) -> bool { x % 2 == 1 }\n fn dummy_rng() -> DummyRng { DummyRng::new_unseeded() }\n \n trait Size: Sized {\n-    fn size() -> uint { std::mem::size_of::<Self>() }\n+    fn size() -> usize { std::mem::size_of::<Self>() }\n }\n impl<T> Size for T {}\n \n@@ -47,24 +47,26 @@ macro_rules! tests {\n \n tests! {\n     // Free function.\n-    id, fn(int) -> int, (5);\n-    id::<int>, fn(int) -> int, (5);\n+    id, fn(i32) -> i32, (5);\n+    id::<i32>, fn(i32) -> i32, (5);\n \n     // Enum variant constructor.\n-    Some, fn(int) -> Option<int>, (5);\n-    Some::<int>, fn(int) -> Option<int>, (5);\n+    Some, fn(i32) -> Option<i32>, (5);\n+    Some::<i32>, fn(i32) -> Option<i32>, (5);\n \n     // Tuple struct constructor.\n-    Newt, fn(int) -> Newt<int>, (5);\n-    Newt::<int>, fn(int) -> Newt<int>, (5);\n+    Newt, fn(i32) -> Newt<i32>, (5);\n+    Newt::<i32>, fn(i32) -> Newt<i32>, (5);\n \n     // Inherent static methods.\n     Vec::new, fn() -> Vec<()>, ();\n     Vec::<()>::new, fn() -> Vec<()>, ();\n-    Vec::with_capacity, fn(uint) -> Vec<()>, (5);\n-    Vec::<()>::with_capacity, fn(uint) -> Vec<()>, (5);\n-    BitVec::from_fn, fn(uint, fn(uint) -> bool) -> BitVec, (5, odd);\n-    BitVec::from_fn::<fn(uint) -> bool>, fn(uint, fn(uint) -> bool) -> BitVec, (5, odd);\n+    <Vec<()>>::new, fn() -> Vec<()>, ();\n+    Vec::with_capacity, fn(usize) -> Vec<()>, (5);\n+    Vec::<()>::with_capacity, fn(usize) -> Vec<()>, (5);\n+    <Vec<()>>::with_capacity, fn(usize) -> Vec<()>, (5);\n+    BitVec::from_fn, fn(usize, fn(usize) -> bool) -> BitVec, (5, odd);\n+    BitVec::from_fn::<fn(usize) -> bool>, fn(usize, fn(usize) -> bool) -> BitVec, (5, odd);\n \n     // Inherent non-static method.\n     Vec::map_in_place, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>, (vec![b'f', b'o', b'o'], u8_as_i8);\n@@ -77,29 +79,52 @@ tests! {\n     //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n \n     // Trait static methods.\n-    <bool as Size>::size, fn() -> uint, ();\n-    Default::default, fn() -> int, ();\n-    <int as Default>::default, fn() -> int, ();\n-    Rand::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n-    <int as Rand>::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n-    Rand::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n-    <int as Rand>::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    bool::size, fn() -> usize, ();\n+    <bool>::size, fn() -> usize, ();\n+    <bool as Size>::size, fn() -> usize, ();\n+\n+    Default::default, fn() -> i32, ();\n+    i32::default, fn() -> i32, ();\n+    <i32>::default, fn() -> i32, ();\n+    <i32 as Default>::default, fn() -> i32, ();\n+\n+    Rand::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    i32::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32>::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32 as Rand>::rand, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    Rand::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    i32::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32>::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n+    <i32 as Rand>::rand::<DummyRng>, fn(&mut DummyRng) -> i32, (&mut dummy_rng());\n \n     // Trait non-static methods.\n-    Clone::clone, fn(&int) -> int, (&5);\n-    <int as Clone>::clone, fn(&int) -> int, (&5);\n-    FromIterator::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n-    <Vec<_> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n+    Clone::clone, fn(&i32) -> i32, (&5);\n+    i32::clone, fn(&i32) -> i32, (&5);\n+    <i32>::clone, fn(&i32) -> i32, (&5);\n+    <i32 as Clone>::clone, fn(&i32) -> i32, (&5);\n+\n+    FromIterator::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n+    Vec::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n+    <Vec<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>, (Some(5).into_iter());\n+    <Vec<_> as FromIterator<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>,\n         (Some(5).into_iter());\n-    <Vec<int> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n+    <Vec<i32> as FromIterator<_>>::from_iter, fn(OptionIter<i32>) -> Vec<i32>,\n         (Some(5).into_iter());\n-    FromIterator::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>,\n+    FromIterator::from_iter::<OptionIter<i32>>, fn(OptionIter<i32>) -> Vec<i32>,\n         (Some(5).into_iter());\n-    <Vec<int> as FromIterator<_>>::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>,\n+    <Vec<i32> as FromIterator<_>>::from_iter::<OptionIter<i32>>, fn(OptionIter<i32>) -> Vec<i32>,\n         (Some(5).into_iter());\n+\n     Add::add, fn(i32, i32) -> i32, (5, 6);\n+    i32::add, fn(i32, i32) -> i32, (5, 6);\n+    <i32>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<_>>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<i32>>::add, fn(i32, i32) -> i32, (5, 6);\n+\n+    String::into_cow, fn(String) -> Cow<'static, str>,\n+        (\"foo\".to_string());\n+    <String>::into_cow, fn(String) -> Cow<'static, str>,\n+        (\"foo\".to_string());\n     <String as IntoCow<_>>::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n     <String as IntoCow<'static, _>>::into_cow, fn(String) -> Cow<'static, str>,", "previous_filename": "src/test/run-pass/const-polymorphic-paths.rs"}]}